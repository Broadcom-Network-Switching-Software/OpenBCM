/*
 * 
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * Soc_petra-B COSQ
 */
#ifdef _ERR_MSG_MODULE_NAME
  #error "_ERR_MSG_MODULE_NAME redefined"
#endif

#define _ERR_MSG_MODULE_NAME BSL_BCM_COSQ

#include <shared/bsl.h>
#include <shared/swstate/access/sw_state_access.h>
#include <bcm/debug.h>
#include <bcm/error.h>
#include <bcm_int/common/debug.h>
#include <bcm/cosq.h>
#include <shared/gport.h>
#include <bcm_int/api_xlate_port.h>
#include <bcm_int/petra_dispatch.h>
#include <bcm_int/dpp/utils.h>
#include <bcm_int/dpp/error.h>
#include <bcm_int/dpp/extender.h>
#include <bcm_int/dpp/gport_mgmt.h>
#include <bcm_int/dpp/utils.h>
#include <bcm_int/dpp/error.h>
#include <bcm_int/dpp/port.h>
#include <bcm_int/dpp/cosq.h>
#include <bcm_int/dpp/switch.h>
#include <bcm_int/control.h>
#include <bcm_int/dpp/alloc_mngr.h>
#include <bcm_int/dpp/alloc_mngr_cosq.h>
#include <bcm_int/dpp/fabric.h>
#include <bcm_int/dpp/stack.h>
#include <bcm_int/dpp/counters.h>
#include <bcm_int/dpp/alloc_mngr_utils.h>


#include <soc/dcmn/error.h>
#include <soc/dcmn/dcmn_wb.h>
#include <soc/dpp/dpp_config_defs.h>
#include <soc/dpp/dpp_config_imp_defs.h>
#include <soc/dpp/mbcm.h>
#include <soc/dpp/drv.h>
#include <soc/dpp/port_map.h>
#include <soc/dpp/TMC/tmc_api_ingress_packet_queuing.h>
#include <soc/dpp/TMC/tmc_api_ingress_scheduler.h>
#include <soc/dpp/TMC/tmc_api_ingress_traffic_mgmt.h>
#include <soc/dpp/TMC/tmc_api_egr_queuing.h>
#include <soc/dpp/TMC/tmc_api_ofp_rates.h>
#include <soc/dpp/TMC/tmc_api_multicast_fabric.h>
#include <soc/dpp/TMC/tmc_api_flow_control.h>
#include <soc/dpp/TMC/tmc_api_ingress_scheduler.h>
#include <soc/dpp/TMC/tmc_api_ports.h>
#include <soc/dpp/SAND/Utils/sand_framework.h>
#include <soc/dpp/debug.h>

#include <shared/swstate/access/sw_state_access.h>
#include <soc/dpp/ARAD/arad_api_ofp_rates.h>
#include <soc/dpp/ARAD/arad_scheduler_elements.h>
#include <soc/dpp/ARAD/arad_scheduler_end2end.h>
#include <soc/dpp/ARAD/arad_api_mgmt.h>
#include <soc/dpp/ARAD/arad_sw_db.h>
#include <soc/dpp/ARAD/arad_nif.h>
#include <soc/dpp/ARAD/arad_ingress_scheduler.h>
#include <soc/dpp/ARAD/arad_api_ingress_scheduler.h>
#include <soc/dpp/ARAD/arad_api_cnm.h>
#include <soc/dpp/ARAD/arad_api_flow_control.h>
#include <soc/dpp/ARAD/arad_egr_queuing.h>
#include <soc/dpp/ARAD/arad_api_ingress_packet_queuing.h>
#include <soc/dpp/port_sw_db.h>
#ifdef BCM_JERICHO_SUPPORT
    #include <soc/dpp/JER/jer_nif.h>
    #include <soc/dpp/JER/jer_egr_queuing.h>
#endif

#ifdef CRASH_RECOVERY_SUPPORT
#include <soc/hwstate/hw_log.h>
#endif
/* 
 * local defines
 */

/*Used to handle delay tolarence MACRO to user q type translation*/
#define DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) (SOC_IS_JERICHO(unit) ? SOC_TMC_ITM_NOF_QT_STATIC : 0)
#define DPP_COSQ_USER_Q_TYPE_NOF_DYNANIC(unit) (ARAD_SW_DB_NOF_LEGAL_DYNAMIC_QUEUE_TYPES(unit))
/*Relevant only for Jericho*/
#define DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type) \
            (hw_q_type = (user_q_type >= SOC_TMC_ITM_PREDEFIEND_OFFSET) ? (user_q_type - SOC_TMC_ITM_PREDEFIEND_OFFSET) : user_q_type)


#define DPP_COSQ_SLOW_LEVEL_SCALING_FACTOR 250
#define DPP_COSQ_SLOW_LEVEL_VAL_MAX (SOC_TMC_ITM_CR_SLOW_LEVEL_VAL_MAX * DPP_COSQ_SLOW_LEVEL_SCALING_FACTOR)

#define DPP_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX     (SOC_TMC_EGR_OFP_SCH_WFQ_WEIGHT_MAX)
#define DPP_COSQ_E2E_OFP_SCH_WFQ_WEIGHT_MAX     (1023)

#define DPP_COSQ_EGR_OFP_SCH_SP_LOW             (BCM_COSQ_SP1)
#define DPP_COSQ_EGR_OFP_SCH_SP_HIGH            (BCM_COSQ_SP0)

/* COSQ max num for PB */
#define DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit)  (SOC_DPP_CONFIG(unit)->tm.max_egr_q_prio-1)
#define DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)  (cosq >= 0 && cosq <= DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit))

/* Egress thresh limitations */
#define DPP_COSQ_PB_EGR_THRESH_MNT_NOF_BITS     (5)
#define DPP_COSQ_PB_EGR_THRESH_EXP_NOF_BITS     (4)
#define DPP_COSQ_PB_EGR_THRESH_NOF_BITS         (DPP_COSQ_PB_EGR_THRESH_MNT_NOF_BITS + DPP_COSQ_PB_EGR_THRESH_EXP_NOF_BITS)


/* COSQ max dp */
#define DPP_COSQ_EGR_DP_NUM_MAX                 (DPP_DEVICE_COSQ_EGR_NOF_DP-1)

/* FMQ limitations */
#define DPP_COSQ_PACKET_NOF_TC                  (8)
#define DPP_COSQ_FMQ_MAX_CLS_TC                 (SOC_TMC_MULT_FABRIC_CLS_MAX)
#define DPP_COSQ_FMQ_MAX_BURST_LIMIT            (63)
#define DPP_COSQ_FMQ_MAX_BE_WEIGHT              (15)
#define DPP_COSQ_FMQ_NOF_BE                     (SOC_TMC_MULT_FABRIC_NOF_BE_CLASSES)

#define DPP_COSQ_PB_EGR_OFP_SCH_MODE_HP_OVER_LP_FAIR (0)

/* Bandwidth limits */
#define DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT (SOC_TMC_OFP_RATES_BURST_LIMIT_MAX)

#define DPP_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT (SOC_TMC_OFP_RATES_SCH_BURST_LIMIT_MAX)
#define DPP_COSQ_PB_E2E_ERP_RATE                 (10*1000*1000)
#define DPP_COSQ_PB_E2E_OLP_RATE                 (10*1000*1000)
#define DPP_COSQ_PB_E2E_OAMP_RATE                (10*1000*1000)

/* DRM factor bandwidth */
#define DPP_COSQ_DRM_FACTOR_BANDWIDTH            (72)


#define DPP_COSQ_TCG_NOF_PRIORITIES_SUPPORT      (SOC_TMC_TCG_NOF_PRIORITIES_SUPPORT)

/* Default profile for Ingress TC mapping */
#define DPP_COSQ_INGRESS_TC_MAPPING_DEFAULT_PROFILE (0)

/* Default profiles for multisets */
#define DPP_COSQ_PB_ING_RATE_CLS_DEFAULT_PROFILE    (0)
#define DPP_COSQ_PB_ING_SYSTEM_RED_DP_PR_DEFAULT_PROFILE (0)
#define DPP_COSQ_PB_VSQ_RATE_CLS_DEFAULT_PROFILE    (0)
#define DPP_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL  (1048576) 
#define DPP_COSQ_PB_ING_QUEUE_MIN_PACKET_SIZE       (64)
#define DPP_COSQ_PB_ING_QUEUE_MAX_SRAM_PDS_DEFAULT_VAL  (DPP_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL / DPP_COSQ_PB_ING_QUEUE_MIN_PACKET_SIZE)
#define DPP_COSQ_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL  (1048576)
#define DPP_COSQ_JER_ING_QUEUE_OCB_MAX_SIZE_BUFFERS_DEFAULT_VAL  (1048576)
#define DPP_COSQ_PB_ING_WRED_EXP_WQ_DEFAULT_VAL  (2)
#define DPP_COSQ_PB_ING_DISCOUNT_CLS_DEFAULT_PROFILE (0)
#define DPP_COSQ_PB_ING_DISCOUNT_DEFAULT_VALUE      (14)

#define DPP_COSQ_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE         (0)

/* Scheduler compensation final delta */
#define DPP_COSQ_ADJUST_SIZE_FINAL_DELTA_DEFAULT_PROFILE  (0)

/* Tail drop info definiations */

/* WRED info limitations */
#define DPP_COSQ_PB_WRED_WQ_MAX                     (31) /*SOC_PETRA_ITM_WQ_MAX*/

/* Discard info limitation */
#define BCM_DPP_COSQ_DISCARD_FROP_PROB              (100)
#define BCM_DPP_COSQ_DISCARD_SYSTEM_RED_FROP_PROB   (0xffff)

/* 256 MB */
#define DPP_COSQ_PB_WRED_MIN_AVRG_TH_MAX            (0XFFFFFFF)
#define DPP_COSQ_PB_WRED_MAX_AVRG_TH_MAX            (0XFFFFFFF)

/* Word takes 16Bytes */
#define DPP_COSQ_WORDS_RESOLUTION   (16)

/* Buffer takes 256Bytes */
#define DPP_COSQ_BUFFERS_RESOLUTION   (256)

/* Convert number in Bytes to number in Words (16B) */
#define DPP_COSQ_BYTES_TO_WORDS(num)    (SOC_SAND_DIV_ROUND_UP(num,DPP_COSQ_WORDS_RESOLUTION) * DPP_COSQ_WORDS_RESOLUTION)

/* Convert number in Bytes to number in Buffers (256B) */
#define DPP_COSQ_BYTES_TO_BUFFERS(num)    SOC_SAND_DIV_ROUND_UP(num,DPP_COSQ_BUFFERS_RESOLUTION)

/* Convert number in Buffers (256B) to number in Bytes */
#define DPP_COSQ_BUFFERS_TO_BYTES(num)    (num * DPP_COSQ_BUFFERS_RESOLUTION)

/* minumum FSM mutiplier size, under which the mecahnism is disabled */
#define DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MIN_SIZE (1 << 5)
/* maximum FSM mutiplier size, over which the multiplier will still be the maximum */
#define DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE (1 << 12)

/* The default credit size with cosq performance optimized */
#define DPP_COSQ_CREDIT_SIZE_DEFAULT                (1024)

/* credit discount limitations */
#define DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL             (127)
#define DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL             (-128)

/* credit egress dicsount limitations */
#define DPP_COSQ_EGRESS_CR_DISCOUNT_MIN_VAL         (-64)
#define DPP_COSQ_EGRESS_CR_DISCOUNT_MAX_VAL         (64)

/* Cosq maximum connection class */
#define DPP_COSQ_VSQ_NOF_CONNECTION_CLASS           (32)
/* Cosq maximum VSQ pointer */
#define DPP_COSQ_VSQ_NOF_PP_POINTERS(unit)          (SOC_DPP_DEFS_GET(unit, nof_local_ports)) /*In Arad (256), in Jericho 512*/

#define DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH           (4095)
#define DPP_COSQ_ARAD_MAX_SP_PD_THRESH              (13000)
#define DPP_COSQ_MAX_SP_PD_THRESH                   (15000)

#define DPP_COSQ_ARAD_CNM_MAX_CP_QUEUES             (8*1024)

/* Soc_petra-B comptaible mode. In case E2E gport is being retrieved always refer it as the first base_queue (cosq =0) */
#define DPP_COSQ_PB_DEFAULT_PORT_TC          (0)

/* Flow Control */
#define DPP_COSQ_FC_NOF_PRIORITIES           (8)

/* reserved connectors region */
#define DPP_DEVICE_COSQ_QUEUE_RESERVED_REGION_ID(unit) (SOC_IS_QUX(unit) ? 96 : (SOC_IS_QAX(unit) ? 64 : 0))


#define SOC_SAND_TRUE  1
#define SOC_SAND_FALSE 0
/* Set all HR modes as request depend on Port-TC */
#define DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,mode) \
{ \
    if (SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) { \
        int tc; \
        for (tc = 0; tc < SOC_TMC_NOF_TRAFFIC_CLASSES; tc++) \
        { \
          port_info.hr_modes[tc] = mode; \
        }\
    } else { \
        port_info.hr_mode = mode; \
    } \
}

/* DROP Hyst threshold set */
#define DPP_COSQ_THRESHOLD_HYST_SET(unit,hyst,flags,value) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        hyst.set = value; \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        hyst.clear = value; \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* DROP Hyst threshold get */
#define DPP_COSQ_THRESHOLD_HYST_GET(unit,value,flags,hyst) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        value = hyst.set; \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        value = hyst.clear; \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* FC Hyst threshold set */
#define DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,hyst,cosq,flags,value) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            hyst.hp.set = value; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            hyst.lp.set = value; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            hyst.hp.clear = value; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            hyst.lp.clear = value; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}
/* FC Hyst threshold get */
#define DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,value,cosq,flags,hyst) \
{ \
    if (flags & BCM_COSQ_THRESHOLD_SET) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            value = hyst.hp.set; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            value = hyst.lp.set; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else if (flags & BCM_COSQ_THRESHOLD_CLEAR) { \
        if (cosq == BCM_COSQ_HIGH_PRIORITY) { \
            value = hyst.hp.clear; \
        } else if (cosq == BCM_COSQ_LOW_PRIORITY) { \
            value = hyst.lp.clear; \
        } else { \
            LOG_ERROR(BSL_LS_BCM_COSQ, \
                      (BSL_META_U(unit, \
                                  "unit %d, invalid cosq parameter %d "), unit, cosq)); \
            return BCM_E_PARAM; \
        } \
    } else { \
        LOG_ERROR(BSL_LS_BCM_COSQ, \
                  (BSL_META_U(unit, \
                              "unit %d, invalid flags 0x%x "), unit, flags)); \
        return BCM_E_PARAM; \
    } \
}

/* Add Addmistion tests to argument */
#define DPP_COSQ_ADMISSION_TEST_ADD(arg,admission_tests) \
{ \
    arg |= (admission_tests.ctgry_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CT:0; \
    arg |= (admission_tests.ctgry_trffc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CTTC:0; \
    arg |= (admission_tests.ctgry2_3_cnctn_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_CTCC:0; \
    arg |= (admission_tests.sttstcs_tag_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_ST:0; \
    arg |= (admission_tests.llfc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_LLFC:0; \
    arg |= (admission_tests.pfc_test_en == 1) ? BCM_COSQ_CONTROL_ADMISSION_PFC:0; \
}

/* Offsets for VSQ group IDS CBFC,LLFC*/
#define BCM_DPP_VSQ_ID_CBFC8_PETRA(soc_pb_internal_id,traffic_class) \
          (100 + ((soc_pb_internal_id / 8) << 3) + traffic_class)

#define BCM_DPP_VSQ_ID_LLFC_PETRA(soc_pb_internal_id) \
          (100 + ((soc_pb_internal_id) << 1))

#define BCM_DPP_VSQ_ID_CBFC_ARAD(arad_internal_id,traffic_class) \
          (388 + ((arad_internal_id * SOC_TMC_NOF_TRAFFIC_CLASSES) + traffic_class))

#define BCM_DPP_VSQ_ID_LLFC_ARAD(arad_internal_id) \
          (356 + (arad_internal_id))

#define BCM_DPP_COSQ_PORT_ID_TO_INTERFACE_ID(port_id) \
          (port_id - BCM_DPP_PORT_INTERFACE_START)


#define DPP_COSQ_COUNTERS_MAX_STATS               (20)
#define DPP_COSQ_COUNTERS_MAX_SETS                (SOC_TMC_NOF_TRAFFIC_CLASSES * SOC_TMC_NOF_DROP_PRECEDENCE * SOC_DPP_DEFS_MAX(NOF_CORES) * 2 /*System-multicast*/)
 

/* a drop precedence value indicating to some APIs to use ECN configuration instead of a drop precedence */
#define BCM_DPP_ECN_DP SOC_TMC_NOF_DROP_PRECEDENCE

#define BCM_DPP_COSQ_FC_CAL_ID_NUM 8

#define DPP_COSQ_VSQ_NOF_PG_VIPER 2
/* 
 * Data structures
 */
typedef enum
{
    /* 
     * sch_drop_words_consumed
     */
    BCM_DPP_COSQ_THRESH_SCH_DROP_WORDS = 0,
    /* 
     * unsch_drop_words_consumed
     */
    BCM_DPP_COSQ_THRESH_UNSCH_DROP_WORDS,
    /* 
     * sch_drop_pkts_consumed
     */
    BCM_DPP_COSQ_THRESH_SCH_DROP_PKTS,
    /* 
     * unsch_drop_pkts_consumed
     */
    BCM_DPP_COSQ_THRESH_UNSCH_DROP_PKTS,
    /* 
     * sch_fc_words_consumed
     */
    BCM_DPP_COSQ_THRESH_SCH_FC_WORDS

} bcm_dpp_cosq_thresh_field_t;

/* 
 * Profile type for ingress queue
 */
typedef enum
{
    /* 
     * Rate class profile
     */
    BCM_DPP_COSQ_RATE_CLS = 0,
    /* 
     * Discount class profile
     */
    BCM_DPP_COSQ_DISCOUNT_CLS = 1,
    /* 
     * VSQ connection class
     */
    BCM_DPP_COSQ_VSQ_CC = 2,
    /* 
     * VSQ traffic class
     */
    BCM_DPP_COSQ_VSQ_TC = 3,
    /* 
     * Queue signature
     */
    BCM_DPP_COSQ_QUEUE_SIGNATURE = 4,
    /* 
     * Last entry 
     */
    BCM_DPP_COSQ_NOF_CLSSES

} bcm_dpp_cosq_queue_profile_type_t;


typedef enum
{
  /*
 */
  _BCM_DPP_PFC_BITMAP_PORT = 0,
  /*
 */
  _BCM_DPP_PFC_BITMAP_INTF_TC = 1,
  /*
 */
  _BCM_DPP_PFC_BITMAP_PORT_TC = 2,
  /*
 */
  _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_UP = 3,
  /*
 */
  _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_DOWN = 4,
  /*
   *  Number of types in 
   */
  _BCM_DPP_PFC_BITMAP_NOF_TYPE = 5
  
}_bcm_dpp_pfc_bitmap_type;

/* Must match order in bcm_dpp_cosq_hdlist_type_t */
static char * _dpp_list_hd_type_str[] = 
{
    "voq group state",
    "connector group state",
    "scheduler state",
    "flow state",
    "not valid"
};

/*Used to verifying validity of rate class input for queue creating*/
typedef struct bcm_dpp_cosq_queue_attributes_verify_s {
    int rate_class_nof_additions[DPP_DEVICE_COSQ_MAX_COS];
    int delay_tolerance_nof_additions[DPP_DEVICE_COSQ_MAX_COS];
    bcm_cosq_queue_attributes_t queue_attributes[DPP_DEVICE_COSQ_MAX_COS];
    int nof_ocb_only_queues_per_rate_class[DPP_DEVICE_COSQ_MAX_COS];
    int nof_dram_mixed_queues_per_rate_class[DPP_DEVICE_COSQ_MAX_COS];
    int nof_delay_tolerance;
    int nof_rate_class;
    int32 reservation_change[DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int32 ocb_reservation_change;
} bcm_dpp_cosq_queue_attributes_verify_t;

typedef int (*num_elements_setter_cb)(int unit, int core, int num_elements);
typedef int (*type_setter_cb)(int unit, int core, bcm_dpp_cosq_hdlist_type_t type);
typedef int (*buff_allocater_cb)(int unit, int core, int nof_instances_to_alloc);


/* extern functions */

/*
 * the following 4 functions are implemented in jer_ingress_traffic_mgmt.c
 * and are used here to bypass mbcm mechanism since this is single device feature
 */
int jer_itm_ocb_fadt_enable_set(
    SOC_SAND_IN  int                          unit,
    SOC_SAND_IN  int  enable
    );

int jer_itm_ocb_fadt_enable_get(
    SOC_SAND_IN  int   unit,
    SOC_SAND_OUT int*  enable
    );

int jer_itm_ocb_fadt_drop_set(
    SOC_SAND_IN  int                            unit,
    SOC_SAND_IN  uint32                 rt_cls_ndx,
    SOC_SAND_IN  uint32                 drop_precedence_ndx,
    SOC_SAND_IN  SOC_TMC_ITM_OCB_FADT_DROP_THRESHOLD  *info,
    SOC_SAND_OUT SOC_TMC_ITM_OCB_FADT_DROP_THRESHOLD  *exact_info
    );

int jer_itm_ocb_fadt_drop_get(
    SOC_SAND_IN  int                          unit,
    SOC_SAND_IN  uint32                 rt_cls_ndx,
    SOC_SAND_IN  uint32                 drop_precedence_ndx,
    SOC_SAND_OUT SOC_TMC_ITM_OCB_FADT_DROP_THRESHOLD  *info
    );

/*
 * the following 2 functions are implemented in jer_ingress_traffic_mgmt.c
 * and are used here to bypass mbcm mechanism since this is single device feature
 */
int jer_itm_vsq_pg_fadt_fc_enable_set(
    SOC_SAND_IN  int                 unit,
    SOC_SAND_IN  int              fadt_enable
    );

int jer_itm_vsq_pg_fadt_fc_enable_get(
    SOC_SAND_IN  int                 unit,
    SOC_SAND_OUT int                *fadt_enable
    );

int jer_itm_ocb_range_select_set(
    SOC_SAND_IN  int                 unit,
    SOC_SAND_IN  uint32              ocb_free_threshold
      );

int jer_itm_ocb_range_select_get(
    SOC_SAND_IN  int                 unit,
    SOC_SAND_OUT  uint32              *ocb_free_threshold
      );

/*
 * local functions
 */
STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);

STATIC int
_bcm_petra_cosq_gport_e2e_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight);


STATIC int
_bcm_petra_cosq_gport_e2e_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight);

STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight);
STATIC int
_bcm_petra_cosq_gport_fmq_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight);
STATIC int
_bcm_petra_cosq_gport_fmq_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight);
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight);

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         uint32 kbits_sec_min,
                                         uint32 kbits_sec_max,
                                         uint32 flags);

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_set(int unit,
                                                       bcm_gport_t gport,
                                                       int mode,
                                                       int weight);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_set(int unit,
                                                       bcm_gport_t gport,
                                                       int mode,
                                                       int weight);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight);

STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_set(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 kbits_sec_min,
                                              uint32 kbits_sec_max,
                                              uint32 flags);
STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_get(int unit,
                          bcm_gport_t gport,
                          bcm_cos_queue_t cosq,
                          uint32 *kbits_sec_min,
                          uint32 *kbits_sec_max,
                          uint32 *flags);

STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags);
STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 kbits_sec_min,
                                                          uint32 kbits_sec_max,
                                                          uint32 flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 *kbits_sec_min,
                                                          uint32 *kbits_sec_max,
                                                          uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_set(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 kbits_sec_min,
                                                               uint32 kbits_sec_max,
                                                               uint32 flags);
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_get(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 *kbits_sec_min,
                                                               uint32 *kbits_sec_max,
                                                               uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags);

STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags);
STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags);
STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags);
STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags);
STATIC int 
_bcm_petra_egress_queue_from_cosq(int unit,
                                  int *queue_id,
                                  int cosq);
STATIC int
_bcm_petra_egress_cosq_validate(int unit, 
                                int cosq);

STATIC int
_bcm_dpp_cosq_internal_priority_get(int unit,
                                    int cosq,
                                    int *priority);
STATIC int
_bcm_petra_cosq_gport_egress_thresh_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_egress_thresh_profile_set(int unit,
                                          int port,
                                          int profile);
STATIC int
_bcm_petra_cosq_egress_thresh_profile_data_set(int unit,
                                               int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_arad_cosq_egress_thresh_profile_data_set(int unit,
                                              int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(int unit,
                                                               int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_entry_get(int unit,
                                                        int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(int unit,
                                                               int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile);
STATIC int
_bcm_petra_cosq_ocb_threshold_to_rate_class(int unit, 
                                            bcm_cosq_threshold_t *threshold,
                                            bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_cls);
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       int pool,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(int unit,
                                                       bcm_gport_t gport,
                                                       bcm_cos_queue_t cosq,
                                                       int pool,
                                                       bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_all_fc_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_all_fc_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_interface_egress_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_interface_egress_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold);

STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_get(int unit,
                                                            bcm_gport_t gport,
                                                            bcm_cos_queue_t cosq,
                                                            bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_gport_egress_queue_mapping_hw_set(int unit,
                                                  int profile,
                                                  int core,
                                                  CONST bcm_dpp_cosq_egress_queue_mapping_info_t* mapping_info);
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_get(int unit,
                                           bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t *offset);
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_set(int unit,
                                          bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t offset);

STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config);                                         
STATIC int
_bcm_petra_cosq_fmq_mapping_set(int unit, 
                                bcm_port_t port,
                                int count,
                                bcm_cos_t *priority, 
                                bcm_cos_queue_t *cosq);
STATIC int
_bcm_petra_cosq_fmq_mapping_get(int unit,
                                bcm_port_t port,
                                int count,
                                bcm_cos_t *priority,
                                bcm_cos_queue_t *cosq);
STATIC int
_bcm_petra_cosq_control_flow_get(int unit,
                                  bcm_gport_t port,
                                  bcm_cos_queue_t cosq,
                                  bcm_cosq_control_t type,
                                  int *arg);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg);

STATIC int
_bcm_petra_cosq_control_e2e_port_tc_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg);
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg);

STATIC int
_bcm_petra_cosq_control_egress_port_tc_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg);
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg);
STATIC int
_bcm_petra_cosq_control_e2e_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int
_bcm_petra_cosq_control_egress_port_tc_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg);
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg);
STATIC int
_bcm_petra_cosq_control_e2e_port_tc_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg);
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg);
STATIC int
_bcm_petra_cosq_control_flow_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int
_bcm_petra_cosq_control_congestion_port_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg);
STATIC int
_bcm_petra_cosq_control_congestion_port_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg);
STATIC int
_bcm_petra_cosq_control_profile_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg);
STATIC int
_bcm_petra_cosq_control_profile_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg);
STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg);
STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg);

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg);

STATIC int
_bcm_petra_cosq_ingress_port_set(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int arg);

STATIC int
_bcm_petra_cosq_ingress_port_get(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int *arg);

STATIC int
_bcm_petra_cosq_control_device_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);

STATIC int
_bcm_petra_cosq_control_e2e_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_fmq_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg);


STATIC int
_bcm_petra_cosq_control_fmq_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_device_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg);
STATIC int
_bcm_petra_cosq_control_system_port_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
STATIC int
_bcm_petra_cosq_control_system_port_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg);
STATIC int
_bcm_petra_cosq_control_egress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
STATIC int
_bcm_petra_cosq_control_egress_queue_get(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int *arg);
STATIC int
_bcm_petra_cosq_control_ingress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg);
STATIC int
_bcm_petra_cosq_control_ingress_queue_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg);
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(int unit,
                                                               int core,
                                                               uint8 is_ocb_only,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_old,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_new,
                                                               int nof_queues_mapped, 
                                                               int32 reservation_change[][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES]);
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set(int unit,
                                                        int core,
                                                        int qid,
                                                        int rate_class);
STATIC int
_bcm_petra_cosq_voq_class_mapping_set(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int profile);
STATIC int
_bcm_petra_cosq_voq_class_mapping_get(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int* profile);
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_get(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info);
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *exact_rate_class_info);

STATIC int
_bcm_petra_cosq_sys_red_dp_pr_hw_set(int unit,
                                     int dp_pr,
                                     bcm_dpp_cosq_ingress_system_red_dp_pr_info_t *rate_sys_red_dp_pr_info);

STATIC int
_bcm_petra_cosq_gport_gport_size_to_rate_class(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t* gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                               int set_alpha);
STATIC int
_bcm_petra_cosq_gport_rate_class_to_gport_size(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t *gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class);
STATIC int
_bcm_petra_cosq_gport_voq_color_size_verify(int unit, 
                                            bcm_color_t color,
                                            uint32      flags,
                                            bcm_cosq_gport_size_t* gport_size,
                                            int is_set,
                                            int*        set_alpha);
STATIC int
_bcm_petra_cosq_gport_rate_class_color_size_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size);

STATIC int
_bcm_petra_cosq_gport_voq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
STATIC int
_bcm_petra_cosq_gport_voq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);

STATIC int
_bcm_petra_cosq_gport_discard_to_rate_class_data(int unit, 
                                                 bcm_cosq_gport_discard_t *discard,
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class);
STATIC int
_bcm_petra_cosq_gport_rate_class_data_to_discard(int unit, 
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_voq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_voq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_sched_gport_add(int unit,
                                bcm_gport_t port,
                                int numq,
                                uint32 flags,
                                bcm_gport_t *gport);

STATIC int
_bcm_petra_cosq_connector_gport_add(int unit,
                                    int core,
                                    int src_modid,
                                    uint32 nof_remote_cores,
                                    bcm_gport_t port,
                                    int numq,
                                    uint32 flags,
                                    bcm_gport_t *gport);
STATIC int
_bcm_petra_cosq_mcast_gport_add(int unit,
                                bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                                bcm_gport_t *gport);
STATIC int
_bcm_petra_cosq_ucast_gport_add(int unit, 
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport);

STATIC int
_bcm_petra_cosq_connector_gport_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_gport_t *physical_port,
                                    int *num_cos_levels,
                                    uint32 *flags);

STATIC int
_bcm_petra_cosq_sched_gport_get(int unit,
                                bcm_gport_t gport,
                                bcm_gport_t *physical_port,
                                int *num_cos_levels,
                                uint32 *flags);

STATIC int
_bcm_petra_cosq_e2e_gport_get(int unit,
                              bcm_gport_t gport,
                              bcm_gport_t *physical_port,
                              int *num_cos_levels,
                              uint32 *flags);

STATIC int
_bcm_petra_cosq_ucast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags);

STATIC int
_bcm_petra_cosq_mcast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags);

STATIC int
_bcm_petra_cosq_delay_tolerance_to_user_q_type(
    int unit,
    int delay_tolerance_level,
    SOC_TMC_ITM_QT_NDX *user_q_type);
STATIC int
_bcm_petra_cosq_user_q_type_to_delay_tolerance(
    int unit,
    SOC_TMC_ITM_QT_NDX user_q_type,
    int *delay_tolerance_level);

int static
_bcm_petra_cosq_sched_connector_gport_detach(int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq);

STATIC int
_bcm_petra_cosq_sched_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_connector_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_mcast_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_ucast_gport_delete(int unit, bcm_gport_t gport);

STATIC int
_bcm_petra_cosq_fap_port_get(int unit,
                            bcm_gport_t gport,
                            uint32 *p_fap_port,
                            int *core,
                            int *is_interface);
STATIC int
_bcm_petra_cosq_vsq_fc_info_get(int unit, bcm_gport_t vsq_port, SOC_TMC_FC_GEN_INBND_INFO *inbnd_info);
int
bcm_petra_tm_port_get(int unit, int core, int p_fap_port, bcm_port_t* port);

int
bcm_petra_cosq_user_port_get(int unit, bcm_gport_t gport, bcm_port_t *user_port);

STATIC int
_bcm_petra_cosq_cal_reception_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count              /* INOUT */
                                           );

STATIC int
_bcm_petra_cosq_noncal_reception_fc_path_get(int unit,
                                             bcm_cosq_fc_direction_type_t fc_direction,
                                             bcm_cosq_fc_endpoint_t *source,
                                             int max_target,
                                             bcm_cosq_fc_endpoint_t *target, /* OUT */
                                             int *target_count               /* OUT */
                                             );

int
bcm_petra_cosq_fc_port_info_get(int             unit,
                                bcm_gport_t     gport,
                                int            *is_fc_calender,
                                int            *is_fc_inband,
                                uint32         *fc_calender_port);

STATIC int
_bcm_petra_cosq_sched_init(int unit);

STATIC int
_bcm_petra_cosq_sched_cl_verify_flags_mode_get(int unit, int flags, int *cl_mode, int *enhanced_mode, int *weight_mode);

STATIC int
_bcm_petra_sched_cl_profile_get(int unit, int mode, int enhanced_mode, int weight_mode, int validate_only, int *cid);

/* VSQ local functions  { */
STATIC int 
_bcm_petra_cosq_voq_discard_retrieve_dps(int unit,
                                         uint32 flags,
                                         int *dps,
                                         int *nof_dps);
STATIC int
_bcm_petra_cosq_gport_discard_verify(int unit,
                                     bcm_cosq_gport_discard_t *discard,
                                     int is_vsq);

/*Get a pointer for the VSQ rate class wred data*/
bcm_dpp_cosq_vsq_rate_class_wred_info_t* 
bcm_dpp_cosq_vsq_rate_class_wred_data_get(int unit, const SOC_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dpp_cosq_vsq_rate_class_info_t* data_rate_cls);

/*Get a pointer for the VSQ rate class tail-drop data*/
bcm_dpp_cosq_vsq_rate_class_taildrop_info_t* 
bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(int unit, const SOC_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, int headroom, bcm_dpp_cosq_vsq_rate_class_info_t* data_rate_cls);

/*Get a pointer for the VSQ rate class fc data*/
bcm_dpp_cosq_vsq_rate_class_fc_info_t* 
bcm_dpp_cosq_vsq_rate_class_fc_data_get(int unit, const SOC_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dpp_cosq_vsq_rate_class_info_t* data_rate_cls);

STATIC int
_bcm_petra_cosq_vsq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      SOC_TMC_ITM_VSQ_GROUP vsq_category_index,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *exact_rate_class_info);
STATIC int
_bcm_petra_cosq_vsq_rate_class_exchange_set(int unit,
                                            int core_id,
                                            SOC_TMC_ITM_VSQ_NDX vsq_id,
                                            bcm_dpp_cosq_vsq_rate_class_info_t *data_rate_class);
STATIC int 
_bcm_petra_cosq_vsq_id_range_verify(int unit,
                                    int core_id,
                                    int queue_id,
                                    int vsq_category,
                                    int *is_match);

STATIC int 
_bcm_petra_cosq_gport_vsq_get_group_type(int unit,
                                         bcm_cosq_vsq_info_t* vsq_info,
                                         bcm_dpp_cosq_vsq_type_t *vsq_group_type);
STATIC int 
_bcm_petra_cosq_gport_vsq_rate_class_destroy(
   int unit, 
   int core_id,
   int vsq_index,
   bcm_dpp_cosq_vsq_type_t vsq_group_type,
   uint8 ocb_only);

STATIC int
_bcm_petra_cosq_vsq_local_port_from_gport(int unit,
                                          bcm_gport_t src_port,
                                          int *local_port);
STATIC int 
_bcm_petra_cosq_gport_vsq_gport_set(int unit,
                                    bcm_cosq_vsq_info_t* vsq_info,
                                    bcm_dpp_cosq_vsq_type_t vsq_group_type,                                    
                                    bcm_gport_t *vsq_gport);

STATIC int 
_bcm_petra_cosq_vsq_info_verify(int unit,
                                bcm_cosq_vsq_info_t *vsq_info);
STATIC int
_bcm_petra_cosq_gport_vsq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_vsq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard);
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size);
STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold);
STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold);
STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_get(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold);
/* VSQ local functions  } */
STATIC int _bcm_petra_cosq_pfc_bitmap_get(int unit, 
                                          _bcm_dpp_pfc_bitmap_type pfc_bmp_type, 
                                          bcm_port_t port, 
                                          bcm_cos_queue_t cosq, 
                                          SOC_TMC_FC_PFC_GENERIC_BITMAP *generic_bm);
STATIC int
_bcm_petra_cosq_fc_path_add_remove(int unit,
                                   int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);

STATIC int
_bcm_petra_cosq_generation_fc_path_add(int unit,
                                       int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);
STATIC int
_bcm_petra_cosq_reception_fc_path_add(int unit,
                                      int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target);
STATIC int
_bcm_petra_cosq_generation_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count);
STATIC int
_bcm_petra_cosq_reception_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count);

STATIC int
_bcm_petra_cosq_fc_init(int unit);

STATIC int 
_bcm_petra_cosq_default_thresholds_set(int unit, int core, int any_port_with_1_priority, int total_mc_reserved_pds_sp0, int total_mc_reserved_pds_sp1);


/*
 * Support Functions - Flow 
 */
int
_bcm_petra_se_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow);

STATIC int
_bcm_petra_nbr_flow_quartets_for_queue_quartet(int unit, int is_interdigitated, int is_composite,
                                                                       int *nbr_flow_quartets);
STATIC int
_bcm_petra_cosq_mode_get(int unit, int core, SOC_TMC_SCH_FLOW *flow_config, int is_sf2, int *mode);

STATIC int
_bcm_petra_cosq_credit_class_info_get(int unit, int core, SOC_TMC_SCH_SE_INFO *se_config, int mode, bcm_dpp_cosq_class_info_t *info);

STATIC int
_bcm_petra_cosq_sched_enhanced_mode_get(int unit, int core, SOC_TMC_SCH_SE_INFO *sch_info, int *is_enhanced, int *enhanced_mode);

STATIC int
_bcm_petra_cosq_cl_sched_weight_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info, bcm_dpp_cosq_class_info_t *info, int *weight);

STATIC int
_bcm_petra_cosq_credit_class_weight_validate(int unit, int weight, bcm_dpp_cosq_class_info_t *info, int *updated_type);

STATIC int
_bcm_petra_cosq_alloc_n_gport_validate_info_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int flags, bcm_dpp_cosq_gport_info_t **info);

STATIC int
_bcm_petra_cosq_bcm_cosq_to_tcg(int unit,int cosq,SOC_TMC_TCG_NDX *tcg);
STATIC int
_bcm_petra_cosq_port_tcg_validate(int unit, bcm_gport_t gport, SOC_TMC_TCG_NDX tcg);

STATIC int
_bcm_petra_cosq_port_priority_validate(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq);

STATIC int
_bcm_petra_cosq_validate_connector_id(int unit, int is_non_contiguous, int is_composite, int num_cos, int flow_id);

STATIC int
_bcm_petra_cosq_parent_gport_to_resource_gport(int unit, bcm_gport_t sched_port, int allow_core_all, bcm_gport_t *parent_port);

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_set(int unit, bcm_port_t port, int count, bcm_cos_t *priority, bcm_cos_queue_t *cosq);

STATIC int 
_bcm_petra_cosq_ingress_tc_mapping_hw_set(int unit, int core_id, int profile, int is_flow, SOC_TMC_ITM_TC_MAPPING *tc_mapping);

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_get(int unit, bcm_port_t port, int count, bcm_cos_t *priority, bcm_cos_queue_t *cosq);

STATIC int 
_bcm_petra_cosq_stk_sysport_set(int unit, int core, int sysport, int *stk_exist);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_get(int unit, bcm_gport_t gport, uint32 *min, uint32 *max, uint32 *flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_get(int unit, bcm_gport_t gport, uint32 *min, uint32 *max, uint32 *flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_set(int unit, bcm_gport_t gport, uint32 min, uint32 max, uint32 flags);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_set(int unit, bcm_gport_t gport, uint32 min, uint32 max, uint32 flags);

int
_bcm_arad_cosq_control_congestion_queue_range_set(int unit, bcm_cosq_control_t type, int arg);

int
_bcm_arad_cosq_control_congestion_queue_range_get(int unit, bcm_cosq_control_t type, int *arg);


STATIC int 
_bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(int unit, int priority, int generic_bm_id, SOC_TMC_FC_PFC_GENERIC_BITMAP *bitmap);

STATIC int
_bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_get(int unit, int priority, int generic_bm_id, SOC_TMC_FC_PFC_GENERIC_BITMAP *bitmap);

int 
bcm_arad_cosq_qcn_config_set(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config);

int 
bcm_arad_cosq_qcn_config_get(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config);

int
_bcm_arad_cosq_update_reserved_pd_threshold_all_sps(int unit);

STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_set(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info);
STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_get(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info);

STATIC int
_bcm_petra_cosq_port2se_id(int unit, int core, int fap_port, bcm_cos_t priority, SOC_TMC_SCH_SE_ID *se_id);

STATIC int
_bcm_petra_cosq_se_id2port(int unit, int core, SOC_TMC_SCH_SE_ID se_id, int *fap_port, bcm_cos_t *priority);

STATIC int
_bcm_petra_cosq_vsq_info_get(int unit, bcm_gport_t vsq, bcm_cosq_vsq_info_t *vsq_info);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg);

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg);

STATIC int
_bcm_dpp_cosq_pkt_size_compensation_profiles_crps_init(int unit);

STATIC
int _bcm_dpp_cosq_pkt_size_compensation_profiles_stat_interface_init(int unit);

STATIC int
_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_set(int unit,
                                                    bcm_cosq_pkt_size_adjust_info_t * adjust_info,
                                                    int delta);

STATIC int
_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_get(int unit,
                                                    bcm_cosq_pkt_size_adjust_info_t * adjust_info,
                                                    int *delta);

STATIC int _bcm_petra_cosq_voq_rate_class_set(
    int unit,
    int core,
    int qid,
    bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
    bcm_dpp_cosq_ingress_rate_class_info_t* exact_data_rate_class
    );

STATIC int _bcm_petra_cosq_gport_voq_get(
    int unit,
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq,
    int *core,
    int *qid
    );

STATIC int _bcm_petra_cosq_gport_voq_validate_and_get(
    int unit,
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq, 
    int *core,
    int *qid
    );

STATIC int
_bcm_petra_cosq_gport_voq_rate_class_threshold_set(int unit, 
                                                    bcm_gport_t gport, 
                                                    bcm_cos_queue_t cosq,
                                                    bcm_dpp_cosq_rate_class_threshold_info_t* update_info,
                                                    bcm_dpp_cosq_ingress_rate_class_info_t* exact_data_rate_class);

STATIC int
_bcm_petra_cosq_gport_rate_class_get(int unit,
                                     bcm_gport_t gport,
                                     int* rate_class);

STATIC int
_bcm_petra_cosq_gport_voq_rate_class_data_get(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class);

STATIC int _bcm_petra_cosq_dram_bound_recovery_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold);
STATIC int _bcm_petra_cosq_dram_bound_recovery_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold);

STATIC int _bcm_petra_cosq_voq_rate_class_ocb_only_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int value);
STATIC int _bcm_petra_cosq_voq_rate_class_ocb_only_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int* value);

STATIC int _bcm_petra_cosq_voq_flush_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int timeout);

/*
 * element (data structure) allocation
 */
/* static */ bcm_dpp_cosq_list_hd_t * _bcm_petra_cosq_listhd_alloc(int unit);


/*
 * utility functions
 */

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
/*
 * Defines, Typedefs, ...
 * {
 */
/*
 * This is the 'leaf' (entry) of the data base for VIG
 * (_bcm_petra_cosq_alloc_n_gport_validate_info_get())
 */
typedef struct bcm_dpp_cosq_vig_leaf_s {
      /*
       * This element is loaded by a non-zero value
       * to indicate loaded information is valid.
       */
    int                            valid ;
      /*
       * This element is loaded by a non-zero value to indicate that
       * flow (index/key of this entry) was a 'base_flow_id' in
       * _bcm_petra_cosq_alloc_n_gport_validate_info_get().
       * Info corresponding to 'base_flow_id' is used, in the second stage,
       * to calculate the final flow id (which may be equal to
       * 'base_flow_id')
       */
    int                            is_base_flow ;
      /*
       * This element is loaded by a non-zero value to indicate that
       * flow (index/key of this entry) was a final (second stage) 'flow_id' in
       * _bcm_petra_cosq_alloc_n_gport_validate_info_get().
       * See 'is_base_flow' above
       */
    int                            is_final_flow ;
      /*
       * flow_id corresonding to the gport
       */
    int                            base_flow_id ;
      /*
       * corresponding gport
       */
    int                            gport ;
      /*
       * Indicator on how 'flow_id' was extracted. To get a match, both 'flow_id'
       * and its source must be the same. See _bcm_petra_cosq_alloc_n_gport_validate_info_get()
       */
    int                            source_of_flow_id ;
    bcm_dpp_cosq_gport_info_t      gport_info ;
    SOC_TMC_SCH_FLOW               flow_config ;
    SOC_TMC_SCH_SE_INFO            se_config ;
} bcm_dpp_cosq_vig_leaf_t ;
/*
 * }
 */


/*
 * Local static
 * {
 */
/*
 * 'vig' stands for _bcm_petra_cosq_alloc_n_gport_validate_info_get()
 */
/*
 * This is a pointer to the 'root' of the VIG data base array, per unit. Memory
 * is allocated dynamically in bcm_petra_vig_db_create().
 */
STATIC struct bcm_dpp_cosq_vig_leaf_s *Vig_db[SOC_MAX_NUM_DEVICES] = {(struct bcm_dpp_cosq_vig_leaf_s *)0} ;
/*
 * }
 */
/*****************************************************
*NAME
* bcm_petra_vig_db_create
*TYPE: PROC
*DATE: 08/APR/2015
*FUNCTION:
*  Allocate memory and initialize data base for storage
*  of data collected in
*  _bcm_petra_cosq_alloc_n_gport_validate_info_get()
*CALLING SEQUENCE:
*  bcm_petra_vig_db_create(unit,vig_db_pp,sizeof_vig_element)
*INPUT:
*  DIRECT:
*    int unit -
*      Identifier of device for which memory element is looked up.
*    bcm_dpp_cosq_vig_leaf_t **vig_db_pp -
*      This procedure loads pointed memory by the pointer
*      to the large array of memory elements, each of size
*      'sizeof(bcm_dpp_cosq_vig_leaf_t)'. Altogether, there are
*      SOC_DPP_DEFS_GET(unit,nof_flows_per_pipe) *
*                       SOC_DPP_DEFS_GET(unit,nof_cores)
*      such memory elements per unit.
*  INDIRECT:
*    SOC_MAX_NUM_DEVICES -
*      Maximal number of supported devices.
*    NOF_FLOWS_PER_PIPE -
*      Maximal number of flows per one core
*    NOF_CORES -
*      Maximal number of supported cores per device.
*    bcm_dpp_cosq_vig_leaf_t -
*      Structure of each memory element
*OUTPUT:
*  DIRECT:
*    bcm_error_t -
*      Standard error. If not equal to BCM_E_NONE then
*      some error was encountered.
*  INDIRECT:
*    Allocated memory.
*REMARKS:
*  None
*SEE ALSO:
 */
STATIC bcm_error_t bcm_petra_vig_db_create(int unit, bcm_dpp_cosq_vig_leaf_t **vig_db_pp)
{
  unsigned long size, count, total_allocated ;
  bcm_dpp_cosq_vig_leaf_t *vig_leaf_p ;

  BCMDNX_INIT_FUNC_DEFS ;

  size =
    (SOC_DPP_DEFS_GET(unit,nof_flows_per_pipe) * SOC_DPP_DEFS_GET(unit,nof_cores)) ;
  total_allocated = size * (unsigned long)sizeof(bcm_dpp_cosq_vig_leaf_t) ;
  vig_leaf_p = (bcm_dpp_cosq_vig_leaf_t *)sal_alloc(total_allocated,"vig_db") ;
  if (vig_leaf_p == NULL)
  {
    _rv = BCM_E_MEMORY ;
    goto exit ;
  }
  *vig_db_pp = (void *)vig_leaf_p ;
  for (count = 0 ; count < size ; count++, vig_leaf_p++)
  {
    vig_leaf_p->valid = 0 ;
  }
exit:
  BCMDNX_FUNC_RETURN ;
}
/*****************************************************
*NAME
* bcm_petra_vig_lookup
*TYPE: PROC
*DATE: 08/APR/2015
*FUNCTION:
*  Look up the data base (array pointed by vig_db) and see
*  if element characterised by input parameters is valid.
*  If it is, indicate by return value. Also return (indirectly)
*  the address of the corresponding element, valid or not.
*CALLING SEQUENCE:
*  bcm_petra_vig_lookup(
*    vig_db, unit, core, flow_id, source_of_flow_id, vig_leaf_pp)
*INPUT:
*  DIRECT:
*    bcm_dpp_cosq_vig_leaf_t *vig_db -
*      Pointer to the large array of memory elements (data base),
*      each of size 'sizeof(bcm_dpp_cosq_vig_leaf_t)' allocated for
*      this unit.
*    int unit -
*      Identifier of device for which memory element is looked up.
*    int core -
*      Identifier of core for which memory element is looked up.
*    int flow_id -
*      Identifier of flow id for which memory element is looked up.
*    int source_of_flow_id -
*      Identifier of source_of_flow_id for which memory element
*      is looked up. See 'vig_source_of_flow_id_t'. See remarks.
*      If set to '-1' then this parameter is ignored (i.e., 'do not care').
*    bcm_dpp_cosq_vig_leaf_t **vig_leaf_pp -
*      This procedure loads pointed memory by pointer to element
*      corresponding to input parameters.
*  INDIRECT:
*    bcm_dpp_cosq_vig_leaf_t -
*      Structure of each memory section
*OUTPUT:
*  DIRECT:
*    int -
*      If non-zero then valid element was found.
*  INDIRECT:
*    See vig_leaf_p
*REMARKS:
*  If valid element is found but there is no match between
*  input 'source_of_flow_id' and the one recorded within
*  the element then it is marked as empty (invalid) and
*  would, consequently, be reloaded (if in
*  _bcm_petra_cosq_alloc_n_gport_validate_info_get()).
*SEE ALSO:
 */
STATIC int bcm_petra_vig_lookup(
  bcm_dpp_cosq_vig_leaf_t *vig_db,
  int unit,
  int core,
  int flow_id,
  int source_of_flow_id,
  bcm_dpp_cosq_vig_leaf_t **vig_leaf_pp
  )
{
  int ret ;
  unsigned long offset ;
  bcm_dpp_cosq_vig_leaf_t *vig_leaf_p ;

  ret = 0 ;
  offset = (flow_id * SOC_DPP_DEFS_GET(unit,nof_cores)) + core ;
  vig_leaf_p = &(vig_db[offset]) ;
  *vig_leaf_pp = vig_leaf_p ;
  if (vig_leaf_p->valid)
  {
    if ((source_of_flow_id == vig_leaf_p->source_of_flow_id) || (source_of_flow_id == -1))
    {
      ret = 1 ;
    }
    else
    {
      /*
       * There is no match on 'source_of_flow_id'. Clear
       * element to be reloaded.
       */
      vig_leaf_p->valid = 0 ;
    }
  }
  return (ret) ;
}
/*****************************************************
*NAME
* bcm_petra_vig_delete_this_flow
*TYPE: PROC
*DATE: 15/APR/2015
*FUNCTION:
*  Remove all instances of specified flow from data base
*  corresponding to specified unit and core.
*CALLING SEQUENCE:
*  bcm_petra_vig_delete_this_flow(unit,core,vig_db,flow_id)
*INPUT:
*  DIRECT:
*    int unit -
*      Identifier of device for which flow_id is to be removed.
*    int core -
*      Identifier of core for which flow_id is to be removed.
*    bcm_dpp_cosq_vig_leaf_t *vig_db -
*      Pointer to the large array of memory elements (data base),
*      each of size 'sizeof(bcm_dpp_cosq_vig_leaf_t)' allocated for
*      this unit.
*    int flow_id -
*      Identifier of flow id for which memory element is looked up.
*  INDIRECT:
*    None
*OUTPUT:
*  DIRECT:
*    bcm_error_t -
*      Standard error. If not equal to BCM_E_NONE then
*      some error was encountered.
*  INDIRECT:
*    Allocated memory.
*REMARKS:
*  None
*SEE ALSO:
 */
STATIC bcm_error_t bcm_petra_vig_delete_this_flow(
  int unit, int core, bcm_dpp_cosq_vig_leaf_t *vig_db, int flow_id)
{
  BCMDNX_INIT_FUNC_DEFS ;

  if (vig_db) {
    /*
     * Data base has been set. Look for corresponding entry.
     */
    int entry_was_found ;
    int source_of_flow_id ;
    bcm_dpp_cosq_vig_leaf_t *vig_leaf_p ;
    /*
     * Indicate lookup with 'do not care on source_of_flow_id'.
     */
    source_of_flow_id = -1 ;
    do {
      entry_was_found =
          bcm_petra_vig_lookup(
            Vig_db[unit], unit, core, flow_id, source_of_flow_id, &vig_leaf_p) ;
      if (entry_was_found) {
        /*
         * Matching entry has been found. Entry is pointed by 'vig_leaf_p'.
         * Remove entry from data base.
         */
        vig_leaf_p->valid = 0 ;
      } else {
        /*
         * No matching entry has been found. All entries corresponding to
         * this flow_id have been removed.
         */
        BCM_EXIT ;
      }
    } while (1) ;
  }
exit:
  BCMDNX_FUNC_RETURN ;
}
/*****************************************************
*NAME
* bcm_petra_vig_display_whole_db
*TYPE: PROC
*DATE: 8/APR/2015
*FUNCTION:
*  Debug/monitor procedure for display of all valid entries
*  on data base.
*CALLING SEQUENCE:
*  bcm_petra_vig_display_whole_db()
*INPUT:
*  DIRECT:
*    None
*  INDIRECT:
*    Vig_db[] -
*      Pointer to data base per unit
*OUTPUT:
*  DIRECT:
*    None
*  INDIRECT:
*    Printed data base contents.
*REMARKS:
*  Currently, this procedure prints the contents of the
*  whole data base.
*SEE ALSO:
*  bcm_petra_vig_lookup(), bcm_petra_vig_db_create()
 */
void bcm_petra_vig_display_whole_db(void)
{
  int unit_counter, num_units ;
  int entry_counter, num_entrys ;
  int num_flows, num_cores ;
  int flow_id, core_id ;
  int num_valid_entries ;
  bcm_dpp_cosq_vig_leaf_t *vig_db_p ;

  num_units = (int)(sizeof(Vig_db) / sizeof(Vig_db[0])) ;
  for (unit_counter = 0 ; unit_counter < num_units ; unit_counter++)
  {
    if (Vig_db[unit_counter])
    {
      num_flows = SOC_DPP_DEFS_GET(unit_counter,nof_flows_per_pipe) ;
      num_cores = SOC_DPP_DEFS_GET(unit_counter,nof_cores) ;
      num_entrys = num_flows * num_cores ;
      sal_printf(
        "%s():Data base for unit %d:\r\n"
        "============================================\r\n",
        __func__,unit_counter) ;
      vig_db_p = Vig_db[unit_counter] ;
      num_valid_entries = 0 ;
      for (entry_counter = 0 ; entry_counter < num_entrys ; entry_counter++, vig_db_p++)
      {
        if (vig_db_p->valid)
        {
          flow_id = entry_counter / num_cores ;
          core_id = entry_counter - (flow_id * num_cores) ;
          sal_printf(
            "Flow %06d (0x%08lX) core %d gport %010d (0x%08lX) is_connector %d is_se %d\r\n",
            flow_id, (unsigned long)flow_id, core_id,
            vig_db_p->gport, (unsigned long)vig_db_p->gport,
            vig_db_p->gport_info.is_connector, vig_db_p->gport_info.is_se) ;
          num_valid_entries++ ;
        }
      }
      sal_printf("\r\n") ;
      sal_printf(
        "%s(): Total number of valid entries on unit %d: %d\r\n",__func__,unit_counter,num_valid_entries) ;
    }
    else
    {
      sal_printf(
        "%s(): No data base established for unit %d\r\n",__func__,unit_counter) ;
    }
  }
  return ;
}
/* } */
#else
/* { */
void bcm_petra_vig_display_whole_db(void)
{
    sal_printf(
        "%s(): This procedure is empty when OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is zero\r\n",__func__) ;
    return ;
}
/* } */
#endif
STATIC int
bcm_petra_cosq_nif_to_gport_get(int              unit,
                                soc_port_if_t    if_type,
                                uint32           protocol_offset,
                                bcm_gport_t      *gport)
{
    int rc = BCM_E_NONE;
    pbmp_t ports_bm;
    soc_port_if_t if_type_i;
    uint32 offset_i;
    int found = 0;
    soc_port_t port;
    BCMDNX_INIT_FUNC_DEFS;
    

    rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_bm);
    BCMDNX_IF_ERR_EXIT(rc);

    PBMP_ITER(ports_bm, port) {

        rc = soc_port_sw_db_interface_type_get(unit, port, &if_type_i);
        BCMDNX_IF_ERR_EXIT(rc);

        if(if_type_i != if_type) {
            continue;
        }

        rc = soc_port_sw_db_protocol_offset_get(unit, port, 0, &offset_i);
        BCMDNX_IF_ERR_EXIT(rc);

        if(offset_i != protocol_offset) {
            continue;
        }

        BCM_GPORT_LOCAL_SET(*gport, port);
        found = 1;

    }

    if(!found) {
        SOCDNX_EXIT_WITH_ERR(BCM_E_NOT_FOUND, (_BSL_SOC_MSG("Couldn't find port for interface(%d) offset(%d)"),if_type,protocol_offset));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Convert from BCM SP modes to petra EGR OFP interface prio modes
 */
STATIC int
_bcm_petra_cosq_mode_sp_to_egr_ofp_interface_prio(int unit, int mode,
                                            SOC_TMC_EGR_OFP_INTERFACE_PRIO *nif_priority)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

      switch(mode) {
          case BCM_COSQ_SP0:
              *nif_priority = SOC_TMC_EGR_OFP_INTERFACE_PRIO_HIGH;
              break;
          case BCM_COSQ_SP1:
              *nif_priority = SOC_TMC_EGR_OFP_INTERFACE_PRIO_LOW;
              break;          
          default:
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid mode %d"), unit ,mode));
      }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Convert BCM VSQ TYPES to TMC VSQ TYPES
 */
STATIC int
_bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(bcm_dpp_cosq_vsq_type_t vsq_type,
                                             SOC_TMC_ITM_VSQ_GROUP *soc_tmcvsq_type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch(vsq_type) {
        case BCM_DPP_COSQ_VSQ_TYPE_CTGRY:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_CTGRY;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_CTCC:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_CTGRY_2_3_CNCTN_CLS;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_CTTC:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_CTGRY_TRAFFIC_CLS;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_PP:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_STTSTCS_TAG;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_SRC_PORT;
            break;
        case BCM_DPP_COSQ_VSQ_TYPE_PG:
            *soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_PG;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG_STR("cosq type %d is not matched to tmc vsq group type\n"), vsq_type));  
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Convert TMC VSQ TYPES to BCM VSQ TYPES
 */
STATIC int
_bcm_petra_cosq_tmc_vsq_type_to_bcm_vsq_type(SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type,
                                             bcm_dpp_cosq_vsq_type_t *vsq_type)
{
    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    switch(soc_tmcvsq_type) {
        case SOC_TMC_ITM_VSQ_GROUP_CTGRY:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_CTGRY;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_CTGRY_2_3_CNCTN_CLS:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_CTCC;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_CTGRY_TRAFFIC_CLS:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_CTTC;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_STTSTCS_TAG:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_PP;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_LLFC:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_LLFC;
            break;
        case SOC_TMC_ITM_VSQ_GROUP_PFC:
            *vsq_type = BCM_DPP_COSQ_VSQ_TYPE_PFC;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG_STR("cosq tmc type %d is not matched to bcm vsq group type\n"), soc_tmcvsq_type));
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Convert from BCM cosq to petra EGR Q Prio
 */
STATIC int
_bcm_petra_cosq_bcm_cosq_to_egr_q_prio(int unit,
                                      int cosq,
                                      SOC_TMC_EGR_Q_PRIO *prio)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch(cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *prio = SOC_TMC_EGR_Q_PRIO_0;
            break;
        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *prio = SOC_TMC_EGR_Q_PRIO_1;
            break;
        case 2:
            *prio = SOC_TMC_EGR_Q_PRIO_2;
            break;
        case 3:
            *prio = SOC_TMC_EGR_Q_PRIO_3;
            break;
        case 4:
            *prio = SOC_TMC_EGR_Q_PRIO_4;
            break;
        case 5:
            *prio = SOC_TMC_EGR_Q_PRIO_5;
            break;
        case 6:
            *prio = SOC_TMC_EGR_Q_PRIO_6;
            break;
        case 7:
            *prio = SOC_TMC_EGR_Q_PRIO_7;
            break;
        case -1:
            *prio = SOC_TMC_EGR_Q_PRIO_ALL;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d: invalid cosq %d"), unit, cosq));
    }
exit:
    BCMDNX_FUNC_RETURN;
}
                      
STATIC int
_bcm_petra_cosq_port2se_id(int unit, int core,
                           int fap_port, 
                           bcm_cos_t priority, 
                           SOC_TMC_SCH_SE_ID *se_id)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 soc_sand_rc = 0;

    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        /* Priority must be default */
        if (priority != DPP_COSQ_PB_DEFAULT_PORT_TC) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, priortiy given is out of range, should be set to 0 or -1 %d"), unit, priority));
        }
        *se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_port2se_id,(fap_port)));     
    } else {      
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority, se_id)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority, soc_sand_rc, rc));
        }      
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_se_id2port(int unit, int core,
                           SOC_TMC_SCH_SE_ID se_id,
                           int *fap_port, 
                           bcm_cos_t *priority)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 soc_sand_rc = 0, port_id = 0, tc = 0;

    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        *fap_port = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2port_id,(se_id)));     
        *priority = DPP_COSQ_PB_DEFAULT_PORT_TC;
    }  else {      
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_se2port_tc_id,(unit, core, se_id, &port_id, &tc)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in getting port, tc from HR scheduler element %d, soc_sand error 0x%x, rc error 0x%x"), unit, se_id, soc_sand_rc, rc));
        }      
        *fap_port = port_id;
        *priority = tc;
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC unsigned int
_bcm_cosq_bit_count_get(uint32 value);

int
bcm_petra_cosq_internal_ports_init(int unit)
{
    bcm_error_t rc = BCM_E_NONE;
    int internal_ports_max = DPP_COSQ_SCH_MAX_PORT_ID(unit);
    int internal_ports_count, internal_ports_count_sum;
    bcm_gport_t internal_gport[SOC_DPP_DEFS_MAX(NOF_CORES)];    
    uint32 soc_sand_rc, tm_port;
    SOC_TMC_SCH_PORT_INFO port_info;
    uint32 internal_rates[6];
    bcm_gport_t internal_gport_sum[6];
    int internal_port_i;
    int core;
    soc_port_t port;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_SCH_PORT_INFO_clear(&port_info);
    /* Set default port information */
    port_info.enable = TRUE;    
    DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
    if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
    }

    /*
     * Get OLP/OAMP/ERP ports, and fill interface + rate per type
    */
    internal_ports_count_sum = 0;

    rc = bcm_petra_port_internal_get(unit, BCM_PORT_INTERNAL_OLP,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        BCM_ERR_EXIT_NO_MSG(rc);
    } 
    if (internal_ports_count) {
        for (internal_port_i = 0; internal_port_i < internal_ports_count; internal_port_i++) {
            internal_rates[internal_ports_count_sum] = DPP_COSQ_PB_E2E_OLP_RATE;
            internal_gport_sum[internal_ports_count_sum] = internal_gport[internal_port_i];
            ++internal_ports_count_sum;
        }
    }

    rc = bcm_petra_port_internal_get(unit, BCM_PORT_INTERNAL_EGRESS_REPLICATION,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        BCM_ERR_EXIT_NO_MSG(rc);
    } 
    if (internal_ports_count) {
        for (internal_port_i = 0; internal_port_i < internal_ports_count; internal_port_i++) {
            internal_rates[internal_ports_count_sum] = DPP_COSQ_PB_E2E_ERP_RATE;
            internal_gport_sum[internal_ports_count_sum] = internal_gport[internal_port_i];
            ++internal_ports_count_sum;
        }
    }

    rc = bcm_petra_port_internal_get(unit, BCM_PORT_INTERNAL_OAMP,internal_ports_max, &internal_gport[0], &internal_ports_count);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get Gport OLP/ERP/OAMP port error(0x%x)\n"),rc));       
        BCM_ERR_EXIT_NO_MSG(rc);
    } 
    if (internal_ports_count) {
        for (internal_port_i = 0; internal_port_i < internal_ports_count; internal_port_i++) {
            internal_rates[internal_ports_count_sum] = DPP_COSQ_PB_E2E_OAMP_RATE;
            internal_gport_sum[internal_ports_count_sum] = internal_gport[internal_port_i];
            ++internal_ports_count_sum;
        }
    }

    /* Configure OLP/OAMP/ERP if valid */
    for (internal_port_i = 0; internal_port_i < internal_ports_count_sum; internal_port_i++) {
        rc = _bcm_petra_cosq_fap_port_get(unit, internal_gport_sum[internal_port_i], &tm_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get OFP OLP/OAMP port gport: 0x%x, error(0x%x)\n"), internal_port_i, rc));                   
            BCM_ERR_EXIT_NO_MSG(rc);
        }
                          
        if (tm_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), tm_port));
            BCM_ERR_EXIT_NO_MSG(rc);
        }

        rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
        BCMDNX_IF_ERR_EXIT(rc);
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_if_weight_idx_set,(unit, port, 1)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), 
                                  unit, tm_port, soc_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_if_shaper_rate_set, (unit, core, tm_port, internal_rates[internal_port_i])));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), 
                                  unit, tm_port, soc_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }
        
        port_info.max_expected_rate = internal_rates[internal_port_i]/1000;;
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, tm_port, &port_info)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting OLP/ERP/OAMP scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, tm_port, soc_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }
    }
      
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(int unit)
{

    int rc = BCM_E_NONE;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    uint32 rate_class_index;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED)
    {
        /*enable new mode*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.set(unit, ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED));

        /*set all rate classes to default sttings*/
        for (rate_class_index = 0; rate_class_index < SOC_TMC_ITM_NOF_RATE_CLASSES; rate_class_index++) 
        {
            rc = _bcm_petra_cosq_voq_rate_class_default_set(unit, rate_class_index, &rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }

    } else if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        /*if we enabled simple mode we cnnot use the advanced mapping mode.*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue-to-rate class mapping mode is configured to be simple: advanced mapping cnnot be used")));
    } /*if we allready enabled advanced mode: do nothing.*/
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(int unit)
{

    int rc = BCM_E_NONE;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info;
    int is_allocated, 
        rate_class,
        ref_count;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&rate_class_info, 0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) {
        /*enable new mode*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.set(unit, ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE));
        /*init alloc mngr*/
        for (rate_class = 0; rate_class <= SOC_TMC_ITM_RATE_CLASS_MAX; rate_class++) {
            BCMDNX_IF_ERR_EXIT(arad_sw_db_rate_class_ref_count_get(unit, BCM_CORE_ALL, 2, (uint32)rate_class, (uint32*)&ref_count));
            if (ref_count != 0) {
                /*Get HW configuration*/
                rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &rate_class_info);
                BCMDNX_IF_ERR_EXIT(rc);
                rc = _bcm_dpp_am_template_queue_rate_cls_allocate_group(unit,
                                                                        BCM_DPP_AM_TEMPLATE_FLAG_ALLOC_WITH_ID,
                                                                        &rate_class_info,
                                                                        /*
                                                                         * template mngr manages all cores together, while queue_to_rate_class_mapping
                                                                         * manages each core separately
                                                                         */
                                                                        SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores * ref_count,
                                                                        &is_allocated,
                                                                        &rate_class);
                BCMDNX_IF_ERR_EXIT(rc);

                /* 
                 * rate class 0 is the default rate class, so we allocate a dummy entry so it will never be released when using exchange function 
                 * This extra allocation make sure the entr won't be released. 
                 */
                if (rate_class == 0) {
                    rc = _bcm_dpp_am_template_queue_rate_cls_allocate_group(unit,
                                                                            BCM_DPP_AM_TEMPLATE_FLAG_ALLOC_WITH_ID,
                                                                            &rate_class_info,
                                                                            1,
                                                                            &is_allocated,
                                                                            &rate_class);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
        }
    } else if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED) {
        /*if we enabled simple mode we cnnot use the advanced mapping mode.*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue-to-rate class mapping mode is configured to be advanced: simple mapping cnnot be used")));
    } /*if we allready sime advanced mode: do nothing.*/
exit:
    BCMDNX_FUNC_RETURN;
}

#define BCM_DPP_FINAL_DELTA_VAL_MIN   -16
#define BCM_DPP_FINAL_DELTA_VAL_MAX    15

STATIC int 
_bcm_petra_cosq_ingress_scheduler_compensation_init(int unit)
{
    SOC_TMC_ITM_CR_DISCOUNT_INFO discount_info;
    int delta, profile, rc = BCM_E_NONE;
    SOC_TMC_ITM_CGM_PKT_SIZE_ADJUST_TYPE adjust_type;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_PKT_SIZE_ADJUST_INFO additional_info;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Set Ingress discount class info (scheduler per queue compensation )*/   
    profile = DPP_COSQ_PB_ING_DISCOUNT_CLS_DEFAULT_PROFILE;
    SOC_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_info); 
    if (SOC_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit)) {
            discount_info.discount = 0; /* new mode */ 
    } else {
            discount_info.discount = DPP_COSQ_PB_ING_DISCOUNT_DEFAULT_VALUE; /* legacy mode */
    }
    /* state restored during warmboot */
    rc = _bcm_dpp_am_template_queue_discount_cls_init(unit,profile,&discount_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* state restored during warmboot */
    rc = _bcm_dpp_am_template_pp_port_discount_cls_init(unit,profile,&discount_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* legacy ingress compensation, always set */
    if (!SOC_IS_QAX(unit)) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_discount_set, (unit,profile,&discount_info)));
        SOC_SAND_IF_ERR_EXIT(soc_sand_rc); 
    }

    /* configure new mode credit class compensation */
    if (SOC_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit)) { /* new mechanism */
        adjust_type = SOC_TMC_ITM_PKT_SIZE_ADJUST_QUEUE;
        additional_info.index = profile; /* in pp port profile */
        additional_info.value = discount_info.discount; /* in pp port delta */
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_credits_adjust_size_set ,(unit, SOC_CORE_ALL, profile, adjust_type, discount_info.discount, &additional_info)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Init scheduler compensation final delta mapping (final delta is only relevant for Jericho) */
    if (SOC_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit) && !SOC_IS_QAX(unit)) {
        int final_delta = 0;
        /* init final delta default profile */
        profile = DPP_COSQ_ADJUST_SIZE_FINAL_DELTA_DEFAULT_PROFILE;
        rc = _bcm_dpp_am_template_scheduler_adjust_size_final_delta_mapping_init(unit, profile, &final_delta);
        BCMDNX_IF_ERR_EXIT(rc);

        /* by default map all 'in range' deltas 1-1, 'out range' deltas map to 'edges' values, meaning: 
         * values -128...-17 are mapped to -16. 
         * values -16...15 are mapped to themselves (1-1 mapping).
         * values 16...127 are mapped to 15. 
         */
        for (delta = DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL; delta < DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL; delta++) {
            if (delta < BCM_DPP_FINAL_DELTA_VAL_MIN) {
                final_delta = BCM_DPP_FINAL_DELTA_VAL_MIN;
            } else if (delta > BCM_DPP_FINAL_DELTA_VAL_MAX) {
                final_delta = BCM_DPP_FINAL_DELTA_VAL_MAX;
            } else {
                final_delta = delta;
            }
            rc = bcm_petra_cosq_pkt_size_adjust_delta_map_set(unit, delta, final_delta);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Ideally for code maintenance and readability code path could be the same across
 * coldboot and warmboot. This requires that that at the low level driver all
 * configuration (write accesses) be blocked. The low level driver should allow read
 * accesses (coreesponding write accesses e.g. reading indirect registers/memory).
 *
 * Since this is currently not implemented (i.e blocking all configuration changes)
 * specific coldboot/warmboot checks are added in the init phase.
 *
 * NOTE:
 *      mode of restoring state via replay of commands is not suppoted. Thus it is not
 *      mandatory for the low level driver to block writes during init phase.
 */
int
bcm_petra_cosq_init(int unit)
{
    bcm_error_t rc = BCM_E_NONE;
    int reserved_flow_id;
    int idx, idx1, discount_data = 0, tc;
    uint32 profile, tm_port, flags;
    bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info = NULL;
    bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *uc_thresh_info = NULL;
    bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *mc_thresh_info = NULL;
    bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info = NULL, *exact_rate_class_info = NULL;
    bcm_dpp_cosq_ingress_system_red_dp_pr_info_t *sys_red_dp_pr_info = NULL;
    bcm_dpp_cosq_vsq_rate_class_info_t *vsq_rate_class_info = NULL, *vsq_exact_rate_class_info = NULL;
    SOC_TMC_ITM_WRED_QT_DP_INFO wred_default_info;
    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO vsq_max_size_default_info;
    SOC_TMC_ITM_VSQ_FC_INFO fc_default_info;
    SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO egr_discount_info;
    SOC_TMC_ITM_TC_MAPPING tc_mapping;
    SOC_TMC_SCH_PORT_INFO port_info;
    bcm_port_t port_i;
    uint32 soc_sand_rc;
    int hr_fc_default_template, hr_fc_default_template_data, nof_remote_cores;
    bcm_gport_t gport, fmq_root_gport;
    SOC_TMC_SCH_SE_ID          se_index;
    bcm_cosq_delay_tolerance_t delay_tolerance;
    uint8 src_modid = 0;
    int is_coldboot = TRUE;
    uint32 rci_i, link_rate=0, link_rate_tmp, links_num_i, fap_port, nof_priorities, priority_i;
    int speed, core;
    SOC_TMC_SCH_DEVICE_RATE_ENTRY dev_rate ;
    pbmp_t ports_map;
    ARAD_CNM_CP_OPTIONS cnm_options;  
    ARAD_CNM_CP_INFO cp_info;
    ARAD_CNM_Q_MAPPING_INFO cnm_mapping_info;
    int soc_sand_dev_id;
    uint32 ocb_only_flags;
    int8 credit_watchdog_mode;
    uint32 nof_sch_active_links = SOC_DPP_DEFS_GET(unit, nof_sch_active_links);
    uint32 nof_fabric_links = SOC_DPP_DEFS_GET(unit, nof_fabric_links);
    int rsrc_type = SOC_TMC_INGRESS_THRESHOLD_INVALID;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);

    BCM_DPP_UNIT_CHECK(unit);

#ifdef BCM_WARM_BOOT_SUPPORT
        if (SOC_WARM_BOOT(unit)) {
            is_coldboot = FALSE;
        }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /* Allocation */
    BCMDNX_ALLOC(thresh_info, sizeof(bcm_dpp_cosq_egress_thresh_key_info_t), "egress thresh key info handle memory");
    if (thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);        
    }
    BCMDNX_ALLOC(uc_thresh_info, sizeof(bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t), "egress intf uc thresh key info handle memory");
    if (uc_thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress intf uc thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(mc_thresh_info, sizeof(bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t), "egress intf mc thresh key info handle memory");
    if (mc_thresh_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate egress intf mc thresh key info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(rate_class_info, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t), "cosq ingress rate class info handle memory");
    if (rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress rate class info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(exact_rate_class_info, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t), "cosq ingress rate class info exact handle memory");
    if (exact_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress rate class info exact handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(sys_red_dp_pr_info, sizeof(bcm_dpp_cosq_ingress_system_red_dp_pr_info_t), "system RED drop prob info handle memory");
    if (sys_red_dp_pr_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate cosq ingress system RED drop prob info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(vsq_rate_class_info, sizeof(bcm_dpp_cosq_vsq_rate_class_info_t), "vsq rate class info handle memory");
    if (vsq_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate vsq rate class info handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    BCMDNX_ALLOC(vsq_exact_rate_class_info, sizeof(bcm_dpp_cosq_vsq_rate_class_info_t), "vsq rate class info exact handle memory");
    if (vsq_exact_rate_class_info == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to allocate vsq rate class info exact handle memory\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    if (!SOC_WARM_BOOT(unit)) {
        if (sw_state_access[unit].dpp.bcm.cosq.alloc(unit) != _SHR_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to allocate warmboot cosq memory\n"), unit));
        }
    }

    sal_memset(thresh_info,0x0,sizeof(bcm_dpp_cosq_egress_thresh_key_info_t));
    sal_memset(uc_thresh_info,0x0,sizeof(bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t));
    sal_memset(mc_thresh_info,0x0,sizeof(bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t));
    sal_memset(rate_class_info,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(sys_red_dp_pr_info,0x0,sizeof(bcm_dpp_cosq_ingress_system_red_dp_pr_info_t));
    sal_memset(vsq_rate_class_info,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
    sal_memset(vsq_exact_rate_class_info,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t)); 
    SOC_TMC_ITM_TC_MAPPING_clear(&tc_mapping);
    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&vsq_max_size_default_info);
    
    if (is_coldboot) {    
        /* A.M initliaztion */        
        SOC_DPP_CORES_ITER(SOC_CORE_ALL, core)
        {
            /* Thresh type: Derive infromation from dune init, and set into A.M. */
            profile = SOC_DPP_DEFS_GET(unit, cosq_egr_default_thresh_type);
            rc = _bcm_petra_cosq_egress_thresh_entry_get(unit, core ,profile,thresh_info); 
            BCMDNX_IF_ERR_EXIT(rc);
        
            rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_map);
            SOC_PBMP_ITER(ports_map, idx) {
                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, idx, &flags));
                if (!(SOC_PORT_IS_NOT_VALID_FOR_EGRESS_TM(flags))) {
                    rc = _bcm_petra_cosq_egress_thresh_profile_set(unit,idx,profile);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
    
            rc = _bcm_petra_cosq_egress_thresh_profile_data_set(unit,core,profile,thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);
            
            /* state restored during warmboot */
            rc = _bcm_dpp_am_template_cosq_egr_thresh_init(unit,core ,profile,thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);           
        }

        /* Ingress compensation init */
        rc = _bcm_petra_cosq_ingress_scheduler_compensation_init(unit);
        BCMDNX_IF_ERR_EXIT(rc); 

        SOC_DPP_CORES_ITER(SOC_CORE_ALL, core)
        {
            /* Set Egress Interface Unicast Thresh class info */
            profile = DPP_COSQ_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE;    

            /* state restored during warmboot */
            rc = _bcm_petra_cosq_egress_fc_interface_uc_thresh_entry_get(unit, core, profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_init(unit, core ,profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(unit, core, profile, uc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            /* Set Egress Interface Multicast Thresh class info */
            profile = DPP_COSQ_ARAD_EGR_FC_INTERFACE_DEFAULT_THRESH_TYPE;    

            /* state restored during warmboot */
            rc = _bcm_petra_cosq_egress_fc_interface_mc_thresh_entry_get(unit, profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_init(unit, core ,profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(unit, core , profile, mc_thresh_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        /* Set Ingress rate class info, WRED already disabled by zeroing the structure */
        profile = DPP_COSQ_PB_ING_RATE_CLS_DEFAULT_PROFILE;

        /* state restored during warmboot */
        rc = _bcm_petra_cosq_voq_rate_class_default_set(unit,profile,exact_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);

        if (!SOC_IS_QAX(unit))
        {
            /* System RED */ 
            profile = DPP_COSQ_PB_ING_SYSTEM_RED_DP_PR_DEFAULT_PROFILE;
            _bcm_petra_cosq_sys_red_dp_pr_hw_set(unit, profile, sys_red_dp_pr_info);
            rc = _bcm_dpp_am_template_system_red_dp_pr_init(unit, profile, sys_red_dp_pr_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* Set VSQ rate class info */
        profile = DPP_COSQ_PB_VSQ_RATE_CLS_DEFAULT_PROFILE;    
        /*set default Tail Drop values to maximum alowed by hardware, assum that the length of IQM_VQPR_MA-E is identical*/
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_default_info);
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_tail_drop_default_get,(unit, &vsq_max_size_default_info)));
        SOC_SAND_IF_ERR_EXIT(soc_sand_rc);
        SOC_TMC_ITM_VSQ_FC_INFO_clear(&fc_default_info);
        if (SOC_IS_JERICHO(unit)) {
            /* Jericho and QAX - Set VSQ FC to max */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_fc_default_get,(unit, &fc_default_info)));
            SOC_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
        for (idx = 0 ; idx < SOC_TMC_NOF_NON_SRC_BASED_VSQ_GROUPS; idx++) {
            for (idx1 = 0 ; idx1 < DPP_DEVICE_COSQ_ING_NOF_DP; idx1++) {
                vsq_rate_class_info->queue[idx].taildrop.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                vsq_rate_class_info->queue[idx].taildrop.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                    vsq_rate_class_info->queue[idx].taildrop.max_size_th[rsrc_type][idx1] = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                }

                vsq_rate_class_info->queue[idx].wred.enable[idx1] = wred_default_info.wred_en;
                vsq_rate_class_info->queue[idx].wred.ignore_packet_size[idx1] = wred_default_info.ignore_packet_size;
                vsq_rate_class_info->queue[idx].wred.min_avrg_th[idx1] = wred_default_info.min_avrg_th;
                vsq_rate_class_info->queue[idx].wred.max_avrg_th[idx1] = wred_default_info.max_avrg_th;
                vsq_rate_class_info->queue[idx].wred.max_probability[idx1] = wred_default_info.max_probability;
            }
            vsq_rate_class_info->queue[idx].fc.queue_size = fc_default_info.q_size_fc;
            vsq_rate_class_info->queue[idx].fc.bd_size = fc_default_info.bd_size_fc;
            for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                vsq_rate_class_info->queue[idx].fc.size[rsrc_type] = fc_default_info.size_fc[rsrc_type];
            }
        }
        for (idx = 0; idx < DPP_DEVICE_COSQ_VSQ_NOF_RSRC_POOLS(unit); idx++) {
            for (idx1 = 0 ; idx1 < DPP_DEVICE_COSQ_ING_NOF_DP; idx1++) {
                if (SOC_IS_QAX(unit)) {
                    for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                        vsq_rate_class_info->port[idx].guaranteed_size[rsrc_type][idx1] = 0;
                        vsq_rate_class_info->port[idx].shared_size[rsrc_type][idx1] = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                        vsq_rate_class_info->port[idx].headroom_size[rsrc_type] = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    }
                } else {
                    vsq_rate_class_info->port[idx].shared.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                    vsq_rate_class_info->port[idx].shared.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                    vsq_rate_class_info->port[idx].headroom.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                    vsq_rate_class_info->port[idx].headroom.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                    vsq_rate_class_info->port[idx].min_threshold[idx1] = 0;
                }

                vsq_rate_class_info->port[idx].wred.enable[idx1] = wred_default_info.wred_en;
                vsq_rate_class_info->port[idx].wred.ignore_packet_size[idx1] = wred_default_info.ignore_packet_size;
                vsq_rate_class_info->port[idx].wred.min_avrg_th[idx1] = wred_default_info.min_avrg_th;
                vsq_rate_class_info->port[idx].wred.max_avrg_th[idx1] = wred_default_info.max_avrg_th;
                vsq_rate_class_info->port[idx].wred.max_probability[idx1] = wred_default_info.max_probability;
            }
            vsq_rate_class_info->port[idx].fc.queue_size = fc_default_info.q_size_fc;
            vsq_rate_class_info->port[idx].fc.bd_size = fc_default_info.bd_size_fc;
            for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                vsq_rate_class_info->port[idx].fc.size[rsrc_type] = fc_default_info.size_fc[rsrc_type];
            }
        }
        for (idx1 = 0 ; idx1 < DPP_DEVICE_COSQ_ING_NOF_DP; idx1++) {
            if (SOC_IS_QAX(unit)) {
                for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                    vsq_rate_class_info->pg.guaranteed_size[rsrc_type][idx1] = 0;
                    vsq_rate_class_info->pg.shared_size[rsrc_type][idx1].max_threshold = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.shared_size[rsrc_type][idx1].min_threshold = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.shared_size[rsrc_type][idx1].alpha = 0;
                    vsq_rate_class_info->pg.headroom_size[rsrc_type].max_headroom = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.headroom_size[rsrc_type].max_headroom_nominal = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                    vsq_rate_class_info->pg.headroom_size[rsrc_type].max_headroom_extension = vsq_max_size_default_info.max_inst_q_size_th[rsrc_type];
                }
            } else {
                vsq_rate_class_info->pg.shared.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                vsq_rate_class_info->pg.shared.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                vsq_rate_class_info->pg.headroom.max_size_bds[idx1] = vsq_max_size_default_info.max_inst_q_size_bds;
                vsq_rate_class_info->pg.headroom.max_size[idx1] = vsq_max_size_default_info.max_inst_q_size;
                vsq_rate_class_info->pg.min_threshold[idx1] = 0;
            }

            vsq_rate_class_info->pg.wred.enable[idx1] = wred_default_info.wred_en;
            vsq_rate_class_info->pg.wred.ignore_packet_size[idx1] = wred_default_info.ignore_packet_size;
            vsq_rate_class_info->pg.wred.min_avrg_th[idx1] = wred_default_info.min_avrg_th;
            vsq_rate_class_info->pg.wred.max_avrg_th[idx1] = wred_default_info.max_avrg_th;
            vsq_rate_class_info->pg.wred.max_probability[idx1] = wred_default_info.max_probability;
        }
        vsq_rate_class_info->pg.fc.queue_size = fc_default_info.q_size_fc;
        vsq_rate_class_info->pg.fc.bd_size = fc_default_info.bd_size_fc;
        for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
            vsq_rate_class_info->pg.fc.size[rsrc_type] = fc_default_info.size_fc[rsrc_type];
            vsq_rate_class_info->pg.fc.fadt_size[rsrc_type] = fc_default_info.fadt_size_fc[rsrc_type];
        }

        for (idx = 0 ; idx < DPP_DEVICE_COSQ_ING_NOF_DP; idx++) {
            vsq_rate_class_info->pg.queue_alpha_bds[idx] = vsq_max_size_default_info.alpha;
        }
        if (SOC_IS_QAX(unit)) {
            SOC_TMC_ITM_VSQ_PG_PRM pg_prm;
            SOC_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);
            for (idx = 0; idx < SOC_DPP_DEFS_GET(unit, nof_vsq_f); ++idx) {
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pb_prm_set, (unit, idx, &pg_prm));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        vsq_rate_class_info->pg.prm.pool_id = 0;
        vsq_rate_class_info->pg.prm.is_lossles = FALSE;
        vsq_rate_class_info->pg.prm.use_min_port = FALSE;
        vsq_rate_class_info->pg.prm.admit_profile = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.sign = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.exp = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.offset = 0;
        vsq_rate_class_info->pg.prm.fadt_fc.floor = 0;
        /* state restored during warmboot */
        for (idx = 0 ; idx < DPP_DEVICE_COSQ_VSQ_NOF_CATEGORY_MAX; idx++) {
            rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit, profile, idx, vsq_rate_class_info, vsq_exact_rate_class_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        rc = _bcm_dpp_am_template_vsq_rate_cls_init(unit, profile, vsq_exact_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);

        /* start - Ingress UC/FLOW TC Mapping profile */
        profile = DPP_COSQ_INGRESS_TC_MAPPING_DEFAULT_PROFILE;

        for(idx = 0 ; idx < SOC_TMC_NOF_TRAFFIC_CLASSES; idx++) {
            /* Default: Map each incoming TC to itself */ 
            tc_mapping.new_tc[idx] = idx;
        }

        rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_init(unit,profile,&tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);
        rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_init(unit,profile,&tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_petra_cosq_ingress_tc_mapping_hw_set(unit, BCM_CORE_ALL, profile, 0, &tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_petra_cosq_ingress_tc_mapping_hw_set(unit, BCM_CORE_ALL, profile, 1, &tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);
        /* end - Ingress UC/FLOW TC Mapping profile */

        if (SOC_IS_QAX(unit)) {
            int priority[SOC_TMC_NOF_TRAFFIC_CLASSES];
            int cosq[SOC_TMC_NOF_TRAFFIC_CLASSES];

            BCM_COSQ_GPORT_FMQ_ROOT_SET(fmq_root_gport);

            for (tc = 0; tc < SOC_TMC_NOF_TRAFFIC_CLASSES; ++tc) {
                /* 
                 * Default: Map incoming MC TC to queues 0-3:
                 * TC0-1 --> FMQ0
                 * TC2-3 --> FMQ1
                 * TC4-5 --> FMQ2
                 * TC6-7 --> FMQ3
                 */
                priority[tc] = tc;
                cosq[tc] = tc / 2;
            }
            rc = _bcm_petra_cosq_fmq_mapping_set(unit, fmq_root_gport, SOC_TMC_NOF_TRAFFIC_CLASSES, priority, cosq);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        if (SOC_IS_JERICHO(unit)) {
            uint32 pg_tc_bitmap = 0; /*All TCs are mapped to offset 0, by defalt*/
            rc = bcm_dpp_am_pg_init(unit);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = _bcm_dpp_am_template_vsq_pg_tc_mapping_profile_init(unit, BCM_CORE_ALL, pg_tc_bitmap);
            BCMDNX_IF_ERR_EXIT(rc);
            if (!SOC_IS_QAX(unit)) { /* QAX uses default HW values */
                rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_set, (unit, BCM_CORE_ALL, 0, pg_tc_bitmap)));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }
    /* init egress compensation data */
    SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&egr_discount_info);  
    discount_data = DPP_COSQ_EG_DISCOUNT_DEFAULT_VALUE;
    egr_discount_info.mc_credit_discount = discount_data;
    egr_discount_info.uc_credit_discount = discount_data;
    /* First, Initialize all ports */
    BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
    BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
    if (!SOC_WARM_BOOT(unit)) {
        BCM_PBMP_ITER(ports_map, port_i) {
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, port_i, &flags)); 
            if (SOC_PORT_IS_NOT_VALID_FOR_EGRESS_TM(flags))
            {
                continue;
            }
            rc = soc_port_sw_db_local_to_tm_port_get(unit,port_i, &tm_port, &core);
            BCMDNX_IF_ERR_EXIT(rc);
            /* state restored during warmboot */
            rc = _bcm_dpp_am_template_egress_port_discount_cls_init(unit,core,tm_port,&egr_discount_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (is_coldboot) {
        /* number of elements per block, set to total # voq groups for now */
        /* allocate in 1k blocks at later date.                            */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.num_elements.set(unit, 0,  DPP_DEVICE_PETRA_VOQ_HD_SIZE(unit)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.type.set(unit, 0, dpp_cosq_hdlist_voq_group));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.alloc(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_SIZE(unit)));
    
        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dpp_list_hd_type_str[dpp_cosq_hdlist_voq_group], DPP_DEVICE_PETRA_VOQ_HD_SIZE(unit)));

        BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
            /*
             * number of elements per block, set to total # flows for now
             * allocate in 1k blocks at later date.
             */
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.num_elements.set(unit, core, DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit)));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.type.set(unit, core, dpp_cosq_hdlist_flow));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.alloc(unit, core, DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit)));

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dpp_list_hd_type_str[dpp_cosq_hdlist_flow], DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit)));

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.num_elements.set(unit, core, DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit)));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.type.set(unit, core, dpp_cosq_hdlist_connector_group));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.alloc(unit, core, DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit)));

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dpp_list_hd_type_str[dpp_cosq_hdlist_connector_group], DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit)));

            /*
             * allocate SE data structures
             */
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.num_elements.set(unit, core, SOC_DPP_CONFIG(unit)->tm.max_ses));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.type.set(unit, core, dpp_cosq_hdlist_se));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.alloc(unit, core, SOC_DPP_CONFIG(unit)->tm.max_ses));

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit(%d) create hdlist memory for type(%s) num_elements(%d) \n"),
                              unit, _dpp_list_hd_type_str[dpp_cosq_hdlist_se], SOC_DPP_CONFIG(unit)->tm.max_ses));
        }
    }
    /* initialize cosq module resource manager */
    rc = bcm_dpp_am_cosq_init(unit);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, resource manager init failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_coldboot) {
        
        ocb_only_flags = SOC_DPP_CONFIG(unit)->arad->init.dram.nof_drams ? 0 : BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY;
        /* set standard credit request profiles */
        BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        /* If credit watchdog configuration is not set, set or restore it from hardware */
        if (IS_CREDIT_WATCHDOG_UNINITIALIZED(unit, credit_watchdog_mode)) {
            SOC_TMC_ITM_CR_WD_INFO crwd_info;
            SOC_TMC_ITM_CR_WD_INFO_clear(&crwd_info);
            crwd_info.top_queue = crwd_info.bottom_queue = ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, BCM_CORE_ALL,&crwd_info,&crwd_info)));
        }
        BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        if (is_coldboot) { /* In cold boot, configure the predefined credit request profiles */

            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_get(unit, BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED, &delay_tolerance));
            delay_tolerance.credit_request_hungry_multiplier = 2048; /* VERIFY */
            delay_tolerance.credit_request_satisfied_empty_queue_exceed_thresh = 1; /* VERIFY */
            /* The following two threshold will later also be set to the default by entering the credit watchdog mode. */
            delay_tolerance.credit_request_watchdog_status_msg_gen = IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode) ?
               0 : SOC_TMC_ITM_CREDIT_WATCHDOG_NORMAL_STATUS_MSG_THRESHOLD;

            delay_tolerance.credit_request_watchdog_delete_queue_thresh = SOC_TMC_ITM_CREDIT_WATCHDOG_NORMAL_DELETE_THRESHOLD;

            /* credit request profile (delay tolerance) for (any) 1Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 2 * 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_1G, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 10Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 10Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -38 * 1024 / 10;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 25 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 38 * 1024 / 10;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 76 * 1024 / 10;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_10G_LOW_DELAY, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 40Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 15 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 15 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_40G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 40Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -15 * 1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -15 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -15 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 30 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 30 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 15 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 15 * 1024 / 2;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 15 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 15 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 15 * 1024;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_40G_LOW_DELAY, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 100Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 38 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 38 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_100G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 100Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -38 * 1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -38 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -38 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -100 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 90 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 90 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 38 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 38 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 38 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 76 * 1024;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_100G_LOW_DELAY, &delay_tolerance));

            /* credit request profile (delay tolerance) for slow enabled 200Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = 0;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = 76 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = 76 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 76 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 0;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 1024;
            delay_tolerance.flags                                                   = ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_200G_SLOW_ENABLED, &delay_tolerance));

            /* credit request profile (delay tolerance) for delay sensitive 200Gb ports */
            delay_tolerance.credit_request_hungry_off_to_slow_thresh                = -76 * 1024;
            delay_tolerance.credit_request_hungry_off_to_normal_thresh              = -76 * 1024;
            delay_tolerance.credit_request_hungry_slow_to_normal_thresh             = -76 * 1024;
            delay_tolerance.credit_request_hungry_normal_to_slow_thresh             = -114688; /* max absolute value supported */
            delay_tolerance.credit_request_satisfied_backoff_enter_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backoff_exit_thresh            = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_enter_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backlog_exit_thresh            = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_enter_thresh          = 76 * 1024;
            delay_tolerance.credit_request_satisfied_backslow_exit_thresh           = 76 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_thresh             = 38 * 1024;
            delay_tolerance.credit_request_satisfied_empty_queue_max_balance_thresh = 64 * 1024;
            delay_tolerance.flags                                                   = BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | ocb_only_flags;
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY, &delay_tolerance));

            if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                delay_tolerance.flags = BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY | ocb_only_flags;
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, BCM_COSQ_DELAY_TOLERANCE_15, &delay_tolerance));
            }
        }
    }
    if (is_coldboot) {
        BCM_DPP_ASSYMETRIC_CORES_ITER(BCM_CORE_ALL, core) {
            /* Set VSQ category mode to be none by default */
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.ingress.vsq_category_mode.set(unit, core, bcmFabricVsqCatagoryModeNone));
        }
        rc = bcm_petra_fabric_control_set(unit,bcmFabricVsqCategory,bcmFabricVsqCatagoryModeNone);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "unit %d, failed in vsq mode none settings, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    {
        BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {

            nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][DPP_DEVICE_COSQ_QUEUE_RESERVED_REGION_ID(unit)];
             if (is_coldboot) {
                    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, nof_remote_cores, 0, FALSE, FALSE, FALSE, FALSE, 
                                                            DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, &src_modid, &reserved_flow_id);
                    if (rc != BCM_E_NONE) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, failed to reserve connector resources, error 0x%x\n"), unit, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d core %d, connector resources. reserved start region 0x%x\n"), unit, core, reserved_flow_id));
                }
        }
        if (is_coldboot) {
            SOC_TMC_SCH_PORT_INFO_clear(&port_info);
            /* Set default port information */
            port_info.enable = TRUE;
            DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
            if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
              port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
            }

            BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
            BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
            BCM_PBMP_ITER(ports_map, port_i) {
                SOCDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, port_i, &flags));
                if (!(SOC_PORT_IS_NOT_VALID_FOR_EGRESS_TM(flags))) {
                    BCM_COSQ_GPORT_E2E_PORT_SET(gport, port_i); /* Not necessary */
                    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
                    if (rc != BCM_E_NONE) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                              "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_i, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }

                    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities));

                    /* allocate port HRs */
                    for (priority_i = 0; priority_i < nof_priorities; priority_i++) {

                        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
                        if(SOC_SAND_FAILURE(soc_sand_rc)) {
                            rc = translate_sand_success_failure(soc_sand_rc);
                            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                                (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"),
                                                                                                                   unit, fap_port, priority_i, soc_sand_rc, rc));
                        }
                        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, se_index, DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));
                    }


                    if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "Invalid fap port %d\n"), fap_port));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }

                    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
                    if(SOC_SAND_FAILURE(soc_sand_rc)) {
                        rc = translate_sand_success_failure(soc_sand_rc);
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, error in setting scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
            }
        }
        if (is_coldboot) {
            rc = bcm_petra_cosq_internal_ports_init(unit);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failed in internal port initialization 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    
        /* update flow control template information */
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {   
            if (is_coldboot) {
                hr_fc_default_template = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3 - 1;
                hr_fc_default_template_data = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.hr_fc_default_template.set(unit, hr_fc_default_template));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.hr_fc_default_template_data.set(unit, hr_fc_default_template_data));
                
        
                LOG_VERBOSE(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "Setting up FC Template %d, Value %d"), hr_fc_default_template, hr_fc_default_template_data));

                BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
                    /* state restored during warmboot */
                    rc = _bcm_dpp_am_template_cosq_port_hr_fc_init(unit, core, hr_fc_default_template, &hr_fc_default_template_data);
                    if (rc != BCM_E_NONE) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                  "unit %d, failed in update of flow control HR temlates, error 0x%x\n"), unit, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
            }
        }

        SOC_DPP_ALLOW_WARMBOOT_WRITE(_bcm_petra_cosq_sched_init(unit), rc);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed in sched init, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
    
        if (is_coldboot) {
            /* Set default DRM (device rate memory) */
            SOC_TMC_SCH_DEVICE_RATE_ENTRY_clear(&dev_rate);
    
            /* Currently link_rate is triggered by maximal speed rate */
            link_rate = 0;


            PBMP_SFI_ITER(unit, port_i) {
                if (!SOC_PBMP_MEMBER(SOC_PORT_DISABLED_BITMAP(unit, sfi), port_i)) {
                    rc = bcm_petra_port_speed_get(unit, port_i, &speed);
                    BCMDNX_IF_ERR_EXIT(rc);
    
                    link_rate_tmp = (speed * DPP_COSQ_DRM_FACTOR_BANDWIDTH) / 100;
                    link_rate = (link_rate > link_rate_tmp) ? link_rate:link_rate_tmp;
                }
            }
            /*
             * Fill up the first eight entries in DRM tables. These (first 8) relate to 'local'
             * route and they get values corresponding to high bit rates.
             */
            for(rci_i = 0; rci_i < SOC_DPP_DEFS_GET(unit, nof_rci_levels) ; ++rci_i)
            {
              dev_rate.rci_level = rci_i;
              dev_rate.num_active_links = 0;
              dev_rate.rate = SOC_TMC_SCH_MAX_RATE_MBPS_ARAD(unit);
              /*
               *  0 links means local route
               */
              if (!SOC_IS_QAX(unit)) { /*for qax, SCH_SHARED_DEVICE_RATE_SHARED_DRM is not in use*/
                  soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_rate_entry_set,(unit, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate)));
                  if(SOC_SAND_FAILURE(soc_sand_rc)) {
                      rc = translate_sand_success_failure(soc_sand_rc);
                      LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                          "unit %d, error in setting mbcm_dpp_sch_device_rate_entry_set rci_level %d, num_active_links %d, soc_sand error 0x%x, error 0x%x\n"),
                          unit, dev_rate.rci_level, dev_rate.num_active_links, soc_sand_rc, rc));
                      BCMDNX_IF_ERR_EXIT(rc);
                  }
              }
              /*
               * The following clause is for multi-core systems only (Currently only Jericho), and QAX...!
               */
              if (SOC_IS_JERICHO(unit)) {
                /*
                 * For multi core systems (and QAX...), load the SCH_DEVICE_RATE_MEMORY_DRM table which is specific per core
                 * (unlike SCH_SHARED_DEVICE_RATE_SHARED_DRM, which is shared by the two cores and is loaded
                 * in the clause above and is common to all systems (single-core and multi-core))
                 */
                BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
                  soc_sand_rc =
                    (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_rate_entry_core_set,(unit, core, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate))) ;
                  if(SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                        "unit %d, error in setting mbcm_dpp_sch_device_rate_entry_core_set rci_level %d, num_active_links %d, soc_sand error 0x%x, error 0x%x\n"),
                        unit, dev_rate.rci_level, dev_rate.num_active_links, soc_sand_rc, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                  }
                }
              }
            }

            for(rci_i = 0; rci_i < SOC_DPP_DEFS_GET(unit, nof_rci_levels) ; ++rci_i)
            {
              for (links_num_i = 1; links_num_i <= nof_sch_active_links; links_num_i++)
              {

                dev_rate.rci_level = rci_i;
                dev_rate.num_active_links = links_num_i ;
                dev_rate.rate = (((links_num_i * link_rate) / (rci_i + 1))) * nof_fabric_links / nof_sch_active_links ; /* Translate fabric links to SCH links */
                /*
                 *  0 links means local route
                 *  RCI 0 - if the number of active links is small,
                 *  and the links are indeed in-use, the RCI will rise above 0.
                 *  Otherwise - we don't limit the scheduler rate.
                 */ 
                if(
                    (dev_rate.rate > SOC_TMC_SCH_MAX_RATE_MBPS_ARAD(unit)) ||
                    (dev_rate.rci_level == 0)
                  )
                {
                  dev_rate.rate = SOC_TMC_SCH_MAX_RATE_MBPS_ARAD(unit);
                }

                if (!SOC_IS_QAX(unit)) { /*for qax, SCH_SHARED_DEVICE_RATE_SHARED_DRM is not in use*/
                    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_rate_entry_set,(unit, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate)));
                    if(SOC_SAND_FAILURE(soc_sand_rc)) {
                        rc = translate_sand_success_failure(soc_sand_rc);
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                              "unit %d, error in setting mbcm_dpp_sch_device_rate_entry_set rci_level %d, num_active_links %d, soc_sand error 0x%x, error 0x%x\n"), unit, dev_rate.rci_level,
                                      dev_rate.num_active_links, soc_sand_rc, rc));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
                /*
                 * The following clause is for multi-core systems only (Currently only Jericho), and QAX...!
                 */
                if (SOC_IS_JERICHO(unit)) {
                  /*
                   * For multi core systems (and QAX...), load the SCH_DEVICE_RATE_MEMORY_DRM table which is specific per core
                   * (unlike SCH_SHARED_DEVICE_RATE_SHARED_DRM, which is shared by the two cores and is loaded
                   * in the clause above and is common to all systems (single-core and multi-core)
                   */
                  BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
                    soc_sand_rc =
                      (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_device_rate_entry_core_set,(unit, core, dev_rate.rci_level, dev_rate.num_active_links, dev_rate.rate))) ;
                    if(SOC_SAND_FAILURE(soc_sand_rc)) {
                      rc = translate_sand_success_failure(soc_sand_rc);
                      LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                          "unit %d, error in setting mbcm_dpp_sch_device_rate_entry_core_set rci_level %d, num_active_links %d, soc_sand error 0x%x, error 0x%x\n"),
                          unit, dev_rate.rci_level, dev_rate.num_active_links, soc_sand_rc, rc));
                      BCMDNX_IF_ERR_EXIT(rc);
                    }
                  }
                }
              }
            }
        }
    }
      

    if (!SOC_IS_JERICHO(unit)) { 

        if (!SOC_WARM_BOOT(unit)) {
            /* CNM Init */

            SOC_TMC_CNM_CPQ_INFO cpq_info;
            SOC_TMC_CNM_CP_PROFILE_INFO profile_info;

            soc_sand_rc = arad_cnm_cp_get(soc_sand_dev_id, &cp_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in getting CNM mode\n"), unit, soc_sand_rc));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            switch(SOC_DPP_CONFIG(unit)->tm.cnm_mode)
            {
            case 0:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_DUNE_PP;
            break;
            case 1:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_EXT_PP;
            break;
            case 2:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_SAMPLING;
            break;
            case 3:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_HIGIG;
            break;
            default:
            cp_info.pkt_gen_mode = SOC_TMC_CNM_GEN_MODE_DUNE_PP;
            }

            soc_sand_rc = arad_cnm_cp_set(soc_sand_dev_id, &cp_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in setting CNM mode (%d) \n"), unit, soc_sand_rc, SOC_DPP_CONFIG(unit)->tm.cnm_mode));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            soc_sand_rc = arad_cnm_queue_mapping_get(soc_sand_dev_id, &cnm_mapping_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in getting CNM VOQ mapping mode\n"), unit, soc_sand_rc));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            switch(SOC_DPP_CONFIG(unit)->tm.cnm_voq_mapping_mode)
            {
            case 0:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_8_CPS;
            break;
            case 1:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_4_CPS;
            cnm_mapping_info.odd_queues_select = 1;
            break;
            case 2:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_4_CPS;
            cnm_mapping_info.odd_queues_select = 0;
            break;
            default:
            cnm_mapping_info.q_set = SOC_TMC_CNM_Q_SET_8_CPS;
            }

            soc_sand_rc = arad_cnm_queue_mapping_set(soc_sand_dev_id, &cnm_mapping_info);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
              rc = translate_sand_success_failure(soc_sand_rc);
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, error (%d) in setting CNM VOQ mapping mode (%d) \n"), unit, soc_sand_rc, SOC_DPP_CONFIG(unit)->tm.cnm_voq_mapping_mode));
              BCMDNX_IF_ERR_EXIT(rc);
            }

            SOC_TMC_CNM_CP_PROFILE_INFO_clear(&profile_info);
            SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
            soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, 0, &cpq_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            rc = _bcm_arad_cosq_cnm_queue_profile_hw_get(unit, cpq_info.profile, &profile_info);
            BCMDNX_IF_ERR_EXIT(rc);
            rc = _bcm_dpp_am_template_pool_cnm_queue_init(unit, &profile_info, cpq_info.profile);
            BCMDNX_IF_ERR_EXIT(rc);

            soc_sand_rc = arad_cnm_cp_options_get(soc_sand_dev_id, &cnm_options);   
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error (%d) in getting CNM options\n"), unit, soc_sand_rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            cnm_options.gen_if_no_pph=0;
            cnm_options.gen_if_no_cn_tag=0;
            cnm_options.add_cn_tag=0;

#if defined(BCM_88650_B0)
            if(SOC_IS_ARAD_B0_AND_ABOVE(unit))
            {
                  /* Handle CNM Fixes for Arad B0 */
                  cnm_options.disable_fabric_crc_calculation = 0;
                  cnm_options.disable_crc_removal = 0;
                  cnm_options.enable_cnm_ocb = 0;
            }
#endif

            soc_sand_rc = arad_cnm_cp_options_set(soc_sand_dev_id, &cnm_options);        
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error (%d) in setting CNM options\n"), unit, soc_sand_rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        
    }
    rc = _bcm_petra_cosq_fc_init(unit);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed fc init, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if ((is_coldboot == TRUE) && SOC_IS_JERICHO(unit))
    {
        /* init ingress packet size compensation profiles feature for CRPS use */
        BCMDNX_IF_ERR_EXIT( _bcm_dpp_cosq_pkt_size_compensation_profiles_crps_init(unit) );
        BCMDNX_IF_ERR_EXIT( _bcm_dpp_cosq_pkt_size_compensation_profiles_stat_interface_init(unit) );
    }
exit:
  if (thresh_info != NULL) {
     BCM_FREE(thresh_info);
  }
  if (uc_thresh_info != NULL) {
     BCM_FREE(uc_thresh_info);
  }
  if (mc_thresh_info != NULL) {
     BCM_FREE(mc_thresh_info);
  }
  if (rate_class_info != NULL) {
     BCM_FREE(rate_class_info);
  }
  if (exact_rate_class_info != NULL) {
     BCM_FREE(exact_rate_class_info);
  }
  if (sys_red_dp_pr_info != NULL) {
     BCM_FREE(sys_red_dp_pr_info);
  }
  if (vsq_rate_class_info != NULL) {
     BCM_FREE(vsq_rate_class_info);
  }
  if (vsq_exact_rate_class_info != NULL) {
     BCM_FREE(vsq_exact_rate_class_info);
  }
  BCMDNX_FUNC_RETURN;
}

/*
*  Tear down local state and related
*/
int
bcm_petra_cosq_detach(int unit)
{
    int result = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    arad_sch_deallocate_cache_for_per1k(unit);

    BCMDNX_IF_ERR_EXIT(result);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    {
      /*
       * If memory has already been allocated for data base then free it
       * at run time to increase free heap size.
       */
      if (Vig_db[unit]) {
        LOG_INFO(BSL_LS_BCM_COSQ,
            (BSL_META_U(unit,
               "%s(): Vig memory has been allocated so free allocated memory.\r\n"),
                  __func__) ) ;
        sal_free(Vig_db[unit]) ;
        Vig_db[unit] = NULL ;
      }
    }
/* } */
#endif
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Set the common status message time in the common status message time mode.
 * Need to set the scan time, if to send a message after 1/2 scans.
 * Need to update the delete times of all the progiles.
 */
STATIC int
_bcm_arad_reconfigure_common_fsm_mode(int unit, int fsm_time_us)
{
    bcm_cosq_range_t watch_dog_range;
    int8 credit_watchdog_mode;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    if (!IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can set common status message time only in common status message mode")));
    }
    switch (fsm_time_us) {
      case 0:
      case ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS     / 1000: /*  125 */
      case 2 * ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /*  250 */
      case 4 * ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /*  500 */
      case 8 * ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS / 1000: /* 1000 */
      case ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS     / 1000: /* 2000 */
      case 2 * ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS / 1000: /* 4000 */
        break;
      default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG(
          "Invalid common status message time %d, must be one of 0, 125, 250, 500, 1000, 2000, 4000"),
          fsm_time_us));
    }
    
    /* do all the work */
    watch_dog_range.is_enabled = BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE;
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_credit_watchdog_range_set(unit, BCM_CORE_ALL, BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_ENABLE, &watch_dog_range, fsm_time_us));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the common status message time in us of the common status message time mode.
 */
STATIC int
_bcm_arad_common_fsm_mode_get_time(int unit, int *fsm_time_us)
{
    SOC_TMC_ITM_CR_WD_INFO crwd_info;
    uint32 exact_credit_watchdog_scan_time_nano;
    int8 credit_watchdog_mode;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    if (!IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can get common status message time only in common status message mode")));
    } else if (fsm_time_us == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("received null pointer")));
    }

    /* get the number of scans till a message is generated */
    SOC_TMC_ITM_CR_WD_INFO_clear(&crwd_info);
    crwd_info.top_queue = crwd_info.bottom_queue = crwd_info.max_flow_msg_gen_rate_nano =
      crwd_info.min_scan_cycle_period_micro = ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, BCM_CORE_ALL, &crwd_info, &crwd_info)));

    BCMDNX_IF_ERR_EXIT(GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
    *fsm_time_us = (exact_credit_watchdog_scan_time_nano / 1000) * crwd_info.min_scan_cycle_period_micro;
    if (exact_credit_watchdog_scan_time_nano % 1000) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Can not get exact common status message time. It looks close to %d"), *fsm_time_us));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*Used to handle delay tolarence MACRO to user q type translation*/
STATIC int
_bcm_petra_cosq_delay_tolerance_to_user_q_type(
    int unit,
    int delay_tolerance_level,
    SOC_TMC_ITM_QT_NDX *user_q_type){
    BCMDNX_INIT_FUNC_DEFS;
    if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) {
        *user_q_type = delay_tolerance_level - BCM_COSQ_DELAY_TOLERANCE_NORMAL;
        if ((delay_tolerance_level < BCM_COSQ_DELAY_TOLERANCE_02 || delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15)) {
            *user_q_type += SOC_TMC_ITM_PREDEFIEND_OFFSET;
        } else {
            *user_q_type += DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit);
        }
    } else if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23) {
        *user_q_type = delay_tolerance_level + DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) - (BCM_COSQ_DELAY_TOLERANCE_NORMAL + (BCM_COSQ_DELAY_TOLERANCE_16 - (BCM_COSQ_DELAY_TOLERANCE_15)));
    } else if (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) {
        *user_q_type = delay_tolerance_level + (SOC_TMC_ITM_PREDEFIEND_OFFSET - BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED);
    } else {
        *user_q_type = SOC_TMC_ITM_QT_NDX_INVALID;
    }
    BCMDNX_FUNC_RETURN;
}

/*Used to handle user q type translation to delay tolarence MACRO*/
STATIC int
_bcm_petra_cosq_user_q_type_to_delay_tolerance(
    int unit,
    SOC_TMC_ITM_QT_NDX user_q_type,
    int *delay_tolerance_level){
    BCMDNX_INIT_FUNC_DEFS;
    if (user_q_type >= SOC_TMC_ITM_PREDEFIEND_OFFSET) {
        if (user_q_type == SOC_TMC_ITM_PREDEFIEND_OFFSET + BCM_COSQ_DELAY_TOLERANCE_15 - BCM_COSQ_DELAY_TOLERANCE_NORMAL) {
            *delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_15;
        } else {
            *delay_tolerance_level = user_q_type + (BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED - SOC_TMC_ITM_PREDEFIEND_OFFSET);
        }
    } else {
        if (user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) < DPP_COSQ_USER_Q_TYPE_NOF_DYNANIC(unit) &&
            user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) >= SOC_TMC_ITM_QT_PUSH_Q_NDX) {
            *delay_tolerance_level = (user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit)) + (BCM_COSQ_DELAY_TOLERANCE_NORMAL + (BCM_COSQ_DELAY_TOLERANCE_16 - (BCM_COSQ_DELAY_TOLERANCE_15 + 1)));
        } else if (user_q_type - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit) < SOC_TMC_ITM_QT_PUSH_Q_NDX){
            *delay_tolerance_level = user_q_type + BCM_COSQ_DELAY_TOLERANCE_NORMAL - DPP_COSQ_USER_Q_TYPE_DYNANIC_OFFSET(unit);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("User Q type is not legal")));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_delay_tolerance_level_get(int unit,
                                         int delay_tolerance_level,
                                         bcm_cosq_delay_tolerance_t *delay_tolerance)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_ITM_QT_NDX dt_level;
    SOC_TMC_ITM_CR_REQUEST_INFO cr_req_info;


    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if (delay_tolerance == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointers not being passed")));
    }
    /* consistency checks */
    if (!((delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23)      ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
         (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid delay_tolerance_level %d"), unit, delay_tolerance_level));
    }

    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)) {
        /* Get the common status message time in the common status message time mode */
        BCMDNX_IF_ERR_EXIT(_bcm_arad_common_fsm_mode_get_time(unit, &delay_tolerance->credit_request_watchdog_status_msg_gen));
        BCM_EXIT;
    }
    rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, delay_tolerance_level, &dt_level);
    BCMDNX_IF_ERR_EXIT(rc);

    /*We cannot configure push queue attributes other than OCB-only and Hight-priority (Jericho-only)*/
    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15 && SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("BCM_COSQ_DELAY_TOLERANCE_15 is reserved for push queues")));
    }

    SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_request_get,(unit, dt_level, &cr_req_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    if (cr_req_info.wd_th.cr_wd_dlt_q_th == SOC_TMC_ITM_CR_WD_Q_TH_OPERATION_FAILED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Could not get the user defined delay tolerance level (queue type) since it was not set")));
    }
    if (delay_tolerance_level != BCM_COSQ_DELAY_TOLERANCE_15) {
        delay_tolerance->credit_request_watchdog_status_msg_gen =
                         cr_req_info.wd_th.cr_wd_stts_msg_gen;
        delay_tolerance->credit_request_watchdog_delete_queue_thresh =
                         cr_req_info.wd_th.cr_wd_dlt_q_th;
        delay_tolerance->credit_request_hungry_off_to_slow_thresh =
                         cr_req_info.hungry_th.off_to_slow_th;
        delay_tolerance->credit_request_hungry_off_to_normal_thresh =
                         cr_req_info.hungry_th.off_to_normal_th;
        delay_tolerance->credit_request_hungry_slow_to_normal_thresh =
                         cr_req_info.hungry_th.slow_to_normal_th;
        delay_tolerance->credit_request_hungry_normal_to_slow_thresh =
                         cr_req_info.hungry_th.normal_to_slow_th;

        delay_tolerance->credit_request_hungry_multiplier =
                 cr_req_info.hungry_th.multiplier;

        delay_tolerance->credit_request_satisfied_backoff_enter_thresh =
                         cr_req_info.satisfied_th.backoff_th.backoff_enter_th;
        delay_tolerance->credit_request_satisfied_backoff_exit_thresh =
                         cr_req_info.satisfied_th.backoff_th.backoff_exit_th;
        delay_tolerance->credit_request_satisfied_backlog_enter_thresh =
                         cr_req_info.satisfied_th.backlog_th.backlog_enter_th;
        delay_tolerance->credit_request_satisfied_backlog_exit_thresh =
                         cr_req_info.satisfied_th.backlog_th.backlog_exit_th;
        delay_tolerance->credit_request_satisfied_backslow_enter_thresh = 
                        cr_req_info.satisfied_th.backslow_th.backslow_enter_th; 
        delay_tolerance->credit_request_satisfied_backslow_exit_thresh = 
            cr_req_info.satisfied_th.backslow_th.backslow_exit_th; 
        delay_tolerance->credit_request_satisfied_empty_queue_thresh =
                         cr_req_info.satisfied_th.empty_queues.satisfied_empty_q_th;
        delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh =
                         cr_req_info.satisfied_th.empty_queues.max_credit_balance_empty_q;
        delay_tolerance->credit_request_satisfied_empty_queue_exceed_thresh =
                         cr_req_info.satisfied_th.empty_queues.exceed_max_empty_q;
        delay_tolerance->flags = (SOC_IS_ARADPLUS(unit) && cr_req_info.is_remote_credit_value) ?
                         BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE : 0;
        if (cr_req_info.is_low_latency) {
            delay_tolerance->flags |= BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY;
        }
        if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
            int slow_level;
            for (slow_level = 0; slow_level < BCM_COSQ_DELAY_TOLERANCE_SLOW_LEVELS; slow_level++) {
                delay_tolerance->slow_level_thresh_down[slow_level] = cr_req_info.slow_level_thresholds.slow_level_thresh_down[slow_level] * DPP_COSQ_SLOW_LEVEL_SCALING_FACTOR;
                delay_tolerance->slow_level_thresh_up[slow_level] = cr_req_info.slow_level_thresholds.slow_level_thresh_up[slow_level] * DPP_COSQ_SLOW_LEVEL_SCALING_FACTOR;
            }
        }
    }
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        delay_tolerance->flags |= (cr_req_info.is_ocb_only) ? BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY : 0;
        delay_tolerance->flags |= (cr_req_info.is_high_priority) ? BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY : 0;
        delay_tolerance->flags |= (cr_req_info.is_high_bandwidth_profile) ? BCM_COSQ_DELAY_TOLERANCE_BANDWIDTH_PROFILE_HIGH : 0;
    }
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_delay_tolerance_level_set(int unit,
                                         int delay_tolerance_level, 
                                         bcm_cosq_delay_tolerance_t *delay_tolerance)
{
    uint32 soc_sand_rc;    
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_QT_NDX dt_level;
    SOC_TMC_ITM_CR_REQUEST_INFO cr_req_info, cr_req_exact_info;
    int8 credit_watchdog_mode;
    uint32 credit_worth_local = 0, credit_worth_remote = 0, max_credit_worth = 0;
    int cr_bal_can_exceed = 0;
    int is_init_sequence = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    rc = bcm_petra_init_check(unit);
    if (rc == BCM_E_UNIT) {/* init */ 
        is_init_sequence = 1;
    }
    else if (rc == BCM_E_NONE) {
        is_init_sequence = 0;
    }
    else {
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (delay_tolerance == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointers not being passed")));
    }
    /* consistency checks */
    if (!((delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_15) ||
         (delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_16 && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_23)      ||
         ( delay_tolerance_level >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && delay_tolerance_level <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
         (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid delay_tolerance_level %d"), unit, delay_tolerance_level));
    }
    /*We cannot configure push queue attributes other than OCB-only and Hight-priority (Jericho-only)*/
    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_15 && SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("BCM_COSQ_DELAY_TOLERANCE_15 is reserved for push queues")));
    }

    if (delay_tolerance_level == BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG && SOC_IS_ARADPLUS(unit)) {
        /* Set the common status message time in the common status message time mode */
        BCMDNX_IF_ERR_EXIT(_bcm_arad_reconfigure_common_fsm_mode(unit, delay_tolerance->credit_request_watchdog_status_msg_gen));
        BCM_EXIT;
    }
    rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, delay_tolerance_level, &dt_level);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    if (delay_tolerance->credit_request_watchdog_delete_queue_thresh &&
        IS_CREDIT_WATCHDOG_FAST_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("delete queue thresholds (aging) are not supported in aggressive status message credit watchdog mode")));
    } else if (IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
        if (delay_tolerance->credit_request_watchdog_status_msg_gen) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("status message generation thresholds are not supported per delay tolerance level in common status message credit watchdog mode\n"
                             "They are set for all the chip using BCM_COSQ_DELAY_TOLERANCE_SET_COMMON_STATUS_MSG")));
        } else if (delay_tolerance->credit_request_watchdog_delete_queue_thresh &&
                   (delay_tolerance->credit_request_watchdog_delete_queue_thresh > 7680 ||
                    delay_tolerance->credit_request_watchdog_delete_queue_thresh < 2)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("A delete queue (aging) threshold should be between 2ms and 7680ms, or 0 for no deletion")));
        } /* we permit 7.68s since with shortest scan (125us) the max scans till delete (15*2^12) give 7.68s */
    }
    if (delay_tolerance->flags) {
        uint32 unsupported_flags = delay_tolerance->flags & ~(BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE | 
                                                              BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY | 
                                                              BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY | 
                                                              BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY | 
                                                              BCM_COSQ_DELAY_TOLERANCE_BANDWIDTH_PROFILE_HIGH);
        if (unsupported_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("None supported flags 0x%x were specified"),
              (unsigned)unsupported_flags));
        } if ((delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) && !SOC_IS_ARADPLUS(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE flag is not supported on this device")));
        }
    }

    SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
    SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_exact_info);


    /* retrieve current information in case we do not set all of it 
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_request_get,(unit, dt_level, &cr_req_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    */
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        cr_req_info.is_ocb_only = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_TOLERANCE_OCB_ONLY ? 1 : 0; 
        cr_req_info.is_high_priority = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_HIGH_Q_PRIORITY ? 1 : 0;
        cr_req_info.is_high_bandwidth_profile = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_BANDWIDTH_PROFILE_HIGH ? 1 : 0;
    }

    /*We cannot configure push queue attributes other than OCB-only and Hight-priority*/
    if (delay_tolerance_level != BCM_COSQ_DELAY_TOLERANCE_15) {
        if (delay_tolerance->credit_request_hungry_slow_to_normal_thresh < 
            delay_tolerance->credit_request_hungry_normal_to_slow_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: SlowToNormal (which is %d) must be equal or higher than NormalToSlow (which is %d), otherwise could result endless toggle between states.\n"),
                                 delay_tolerance->credit_request_hungry_slow_to_normal_thresh,
                      delay_tolerance->credit_request_hungry_normal_to_slow_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backoff_enter_thresh <
            delay_tolerance->credit_request_satisfied_backoff_exit_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackOffEnter (which is %d) must be equal or higher than BackOffExit (which is %d), otherwise could result endless toggle between Backoff states.\n"),
                                 delay_tolerance->credit_request_satisfied_backoff_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backoff_exit_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backlog_enter_thresh <
            delay_tolerance->credit_request_satisfied_backlog_exit_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackLogEnter (which is %d) must be equal or higher than BackLogExit (which is %d), otherwise could result endless toggle between BackLog states.\n"),
                                 delay_tolerance->credit_request_satisfied_backlog_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backlog_exit_thresh));
        }
        if (delay_tolerance->credit_request_satisfied_backoff_enter_thresh <
            delay_tolerance->credit_request_satisfied_backlog_enter_thresh) {
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "warning: BackOffEnter (which is %d) should be equal or higher than BackLogEnter (which is %d)\n"),
                                 delay_tolerance->credit_request_satisfied_backoff_enter_thresh,
                      delay_tolerance->credit_request_satisfied_backlog_enter_thresh));
        }
        /*
         * MaxEmptyQCrBal must be lower than BackoffExitCrBalTh, otherwise the 
         * queue might enter into stuck status.
         * If ExceedMaxEmptyQCrBal is set, credit balance of an empty queue can
         * exceed MaxEmptyQCrBal up to credit_worth. In that case, need to 
         * validate that MaxEmptyQCrBal + credit_worth < BackoffExitCrBalTh.
         */
        if (delay_tolerance->credit_request_satisfied_empty_queue_exceed_thresh == 1) {
            cr_bal_can_exceed = 1;
            BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_credit_worth_get,(unit, &credit_worth_local)));
            max_credit_worth = credit_worth_local;
            if (SOC_IS_ARADPLUS(unit)) {
                BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_credit_worth_remote_get,(unit, &credit_worth_remote)));
                /* Need to take max between the credit profiles, since the queue
                 * potentially can receive credits from different devices with 
                 * different credit profile.
                 */
                max_credit_worth = (credit_worth_local > credit_worth_remote) ? (credit_worth_local) : (credit_worth_remote);
            }
        } else {
            cr_bal_can_exceed = 0;
        }
        if ((delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh + (cr_bal_can_exceed * max_credit_worth) >
            delay_tolerance->credit_request_satisfied_backoff_exit_thresh) && !((DPP_COSQ_CREDIT_SIZE_DEFAULT != max_credit_worth)
            && is_init_sequence)){/* skip this validation if credit size is not the default value during sdk init */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (
              _BSL_BCM_MSG("EmptyQueueMaxBalance (which is %d) [+ is_max_credit_balance_can_exceed (%d) * max_credit_value (%u)] must be equal or lower than backOffExit (which is %d), otherwise could result queue stuck in Off state."),
              delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh,
              cr_bal_can_exceed,
              max_credit_worth,
              delay_tolerance->credit_request_satisfied_backoff_exit_thresh));
        }
        /* Finish of non Petra code performing sanity tests on thresholds */
        cr_req_info.is_low_latency = delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_IS_LOW_LATENCY ? TRUE : FALSE;
        if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
            int slow_level;
            if ((delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("flag BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE does not supported in Jericho")));
            }

           for (slow_level = 0; slow_level < SOC_TMC_ITM_CR_SLOW_LEVELS; slow_level++) {
               if (delay_tolerance->slow_level_thresh_up[slow_level] < 0 ||
                   delay_tolerance->slow_level_thresh_up[slow_level] > DPP_COSQ_SLOW_LEVEL_VAL_MAX) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d out of range %d. \nShould be 0-%d bytes"),
                                                    slow_level, slow_level + 1,
                                                    delay_tolerance->slow_level_thresh_up[slow_level], 
                                                    DPP_COSQ_SLOW_LEVEL_VAL_MAX));

               }
               if (delay_tolerance->slow_level_thresh_down[slow_level] < 0 ||
                   delay_tolerance->slow_level_thresh_down[slow_level] > DPP_COSQ_SLOW_LEVEL_VAL_MAX) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d out of range %d. \nShould be 0-%d bytes"),
                                                    slow_level + 1, slow_level,
                                                    delay_tolerance->slow_level_thresh_down[slow_level], 
                                                    DPP_COSQ_SLOW_LEVEL_VAL_MAX));

               }
           }
           for (slow_level = 0; slow_level < SOC_TMC_ITM_CR_SLOW_LEVELS - 1; slow_level++) {
               /*SfTh12 must be bigger than SfTh 01 and so on.*/
               if (delay_tolerance->slow_level_thresh_up[slow_level + 1] < delay_tolerance->slow_level_thresh_up[slow_level]) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d must be higher than slow level threshold %d-%d.\nBut was %d, %d."),
                                                    slow_level + 1, slow_level + 2,
                                                    slow_level, slow_level + 1,
                                                    delay_tolerance->slow_level_thresh_up[slow_level + 1], 
                                                    delay_tolerance->slow_level_thresh_up[slow_level]));

               }
           }
           for (slow_level = 0; slow_level < SOC_TMC_ITM_CR_SLOW_LEVELS - 1; slow_level++) {
               /*SfTh10 must be smaller than SfTh 21 and so on.*/
               if (delay_tolerance->slow_level_thresh_down[slow_level + 1] < delay_tolerance->slow_level_thresh_down[slow_level]) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d must be higher than slow level threshold %d-%d.\nBut was %d, %d."),
                                                    slow_level + 2, slow_level + 1,
                                                    slow_level + 1, slow_level,
                                                    delay_tolerance->slow_level_thresh_down[slow_level + 1], 
                                                    delay_tolerance->slow_level_thresh_down[slow_level]));

               }
           }
           for (slow_level = 0; slow_level < SOC_TMC_ITM_CR_SLOW_LEVELS; slow_level++) {
               /*SfTh10 must be smaller than SfTh 01 and so on (hysteresys).*/
               if (delay_tolerance->slow_level_thresh_up[slow_level] < delay_tolerance->slow_level_thresh_down[slow_level]) {
                   BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("Slow level threshold %d-%d must be higher than slow level threshold %d-%d.\nBut was %d, %d."),
                                                    slow_level, slow_level + 1,
                                                    slow_level + 1, slow_level,
                                                    delay_tolerance->slow_level_thresh_up[slow_level], 
                                                    delay_tolerance->slow_level_thresh_down[slow_level]));

               }
           }

            for (slow_level = 0; slow_level < BCM_COSQ_DELAY_TOLERANCE_SLOW_LEVELS; slow_level++) {
                cr_req_info.slow_level_thresholds.slow_level_thresh_down[slow_level] = delay_tolerance->slow_level_thresh_down[slow_level] / DPP_COSQ_SLOW_LEVEL_SCALING_FACTOR;
                cr_req_info.slow_level_thresholds.slow_level_thresh_up[slow_level] = delay_tolerance->slow_level_thresh_up[slow_level] / DPP_COSQ_SLOW_LEVEL_SCALING_FACTOR;
            }
        }
    }


    /* update configuration */
    cr_req_info.wd_th.cr_wd_stts_msg_gen =
                     delay_tolerance->credit_request_watchdog_status_msg_gen;
    cr_req_info.wd_th.cr_wd_dlt_q_th =
                     delay_tolerance->credit_request_watchdog_delete_queue_thresh;
    cr_req_info.hungry_th.off_to_slow_th =
                     delay_tolerance->credit_request_hungry_off_to_slow_thresh;
    cr_req_info.hungry_th.off_to_normal_th =
                     delay_tolerance->credit_request_hungry_off_to_normal_thresh;
    cr_req_info.hungry_th.slow_to_normal_th =
                     delay_tolerance->credit_request_hungry_slow_to_normal_thresh;
    cr_req_info.hungry_th.normal_to_slow_th =
                     delay_tolerance->credit_request_hungry_normal_to_slow_thresh;

    /* handle values out of the possible range */
    cr_req_info.hungry_th.multiplier =
                     delay_tolerance->credit_request_hungry_multiplier < DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MIN_SIZE ? 0 : (
                     delay_tolerance->credit_request_hungry_multiplier < DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE ?
                     delay_tolerance->credit_request_hungry_multiplier : DPP_DEVICE_COSQ_DT_HUNGRY_MULTIPLIER_MAX_SIZE );

    cr_req_info.satisfied_th.backoff_th.backoff_enter_th =
                     delay_tolerance->credit_request_satisfied_backoff_enter_thresh;
    cr_req_info.satisfied_th.backoff_th.backoff_exit_th =
                     delay_tolerance->credit_request_satisfied_backoff_exit_thresh;
    cr_req_info.satisfied_th.backlog_th.backlog_enter_th =
                     delay_tolerance->credit_request_satisfied_backlog_enter_thresh;
    cr_req_info.satisfied_th.backlog_th.backlog_exit_th =
                     delay_tolerance->credit_request_satisfied_backlog_exit_thresh;
    cr_req_info.satisfied_th.backslow_th.backslow_enter_th =
                     delay_tolerance->credit_request_satisfied_backslow_enter_thresh;
    cr_req_info.satisfied_th.backslow_th.backslow_exit_th =
                     delay_tolerance->credit_request_satisfied_backslow_exit_thresh;
    cr_req_info.satisfied_th.empty_queues.satisfied_empty_q_th = 
                     delay_tolerance->credit_request_satisfied_empty_queue_thresh;
    cr_req_info.satisfied_th.empty_queues.max_credit_balance_empty_q =
                     delay_tolerance->credit_request_satisfied_empty_queue_max_balance_thresh;
    cr_req_info.satisfied_th.empty_queues.exceed_max_empty_q =
                     delay_tolerance->credit_request_satisfied_empty_queue_exceed_thresh;
    cr_req_info.is_remote_credit_value = (delay_tolerance->flags & BCM_COSQ_DELAY_TOLERANCE_REMOTE_CREDIT_VALUE) ? TRUE : FALSE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_request_set,(unit, dt_level, &cr_req_info, &cr_req_exact_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    if (cr_req_exact_info.wd_th.cr_wd_dlt_q_th == SOC_TMC_ITM_CR_WD_Q_TH_OPERATION_FAILED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FULL, (_BSL_BCM_MSG("Could not allocate the user defined delay tolerance level (queue type) since the available ones are exhausted")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_resource_gport_port_get(int unit, 
                                       bcm_gport_t gport, 
                                       bcm_port_t *port)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_gport_t port_gport = 0;
    int se_id, flow_id, dummy_tc;
    int core, tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, 0, &port_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!BCM_GPORT_IS_SCHEDULER(port_gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("gport given is not scheduler gport")));
    }

    flow_id = BCM_GPORT_SCHEDULER_GET(port_gport) ;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port_gport) ;

    /* Convert scheduler to tm_port id */
    se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));
    rc = _bcm_petra_cosq_se_id2port(unit,core,se_id, &tm_port, &dummy_tc);                       
    if (rc != BCM_E_NONE || tm_port == DPP_COSQ_SCH_PORT_ID_INVALID(unit)) {
        rc = BCM_E_PARAM;
       LOG_ERROR(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit %d, Invalid se 0x%x specified - does not correspond to tm_port\n"), unit, se_id));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, port));


exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_sched_set(int unit,
                               bcm_gport_t gport,
                               bcm_cos_queue_t cosq,
                               int mode,
                               int weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* queues */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) ) {
        rc = _bcm_petra_cosq_gport_ucast_queue_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Egress transmit scheduler */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_petra_cosq_gport_egress_scheduler_port_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Egress UC / MC Queue - same function handle */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_sched_set(unit, gport, cosq, mode, weight);
    }
 
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
        rc = _bcm_petra_cosq_gport_fmq_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_sched_set(unit, gport, mode, weight);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_set(unit, gport, mode, weight);
    }    
    /* E2E hierarchy */
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) || (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) || (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ||
                                                    (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ) {
        rc = _bcm_petra_cosq_gport_e2e_sched_set(unit, gport, cosq, mode, weight);
    }
    /* Port TC / Port TCG */
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_sched_set(unit, gport, cosq, mode, weight);
    }    
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_sched_set(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_INGRESS(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_set, 
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_ingress)); 
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_EGRESS(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_egress));
    } 
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_all));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_GENERIC_PIPE(gport)) {
        if (!(DPP_COSQ_GPORT_FABRIC_PIPE_WFQ_WHIGHT_IS_VALID(weight))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("weight %d is invalid"), weight));
        }
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_set,
                                  (unit, BCM_COSQ_GPORT_FABRIC_RX_QUEUE_GENERIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_generic_pipe));
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("gport type not supported")));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_sched_get(int unit,
                               bcm_gport_t gport,
                               bcm_cos_queue_t cosq,
                               int *mode,
                               int *weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* queues */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) ) {
        rc = _bcm_petra_cosq_gport_ucast_queue_sched_get(unit, gport, cosq, mode, weight);
    }

    /* Egress transmit scheduler */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_petra_cosq_gport_egress_scheduler_port_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Egress UC / MC Queue - same function handle */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_sched_get(unit, gport, cosq, mode, weight);
    }
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
        rc = _bcm_petra_cosq_gport_fmq_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_sched_get(unit, gport, mode, weight);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_get(unit, gport, mode, weight);
    }    
    /* E2E hierarchy */
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) || (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) || (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ||
                                                    (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ) {
        rc = _bcm_petra_cosq_gport_e2e_sched_get(unit, gport, cosq, mode, weight);
    }
    /* Port TC / Port TCG */
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_sched_get(unit, gport, cosq, mode, weight);
    }    
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_sched_get(unit, gport, cosq, mode, weight);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_INGRESS(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_ingress));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE_EGRESS(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_egress));
    } 
    else if (BCM_COSQ_GPORT_IS_FABRIC_PIPE(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cosq_gport_sched_get,(unit, BCM_COSQ_GPORT_FABRIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_fabric_pipe_all));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                (unit, 0, weight, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_GENERIC_PIPE(gport)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_egress_core_cosq_gport_sched_get,
                                  (unit, BCM_COSQ_GPORT_FABRIC_RX_QUEUE_GENERIC_PIPE_PIPE_GET(gport), weight, soc_dpp_cosq_gport_egress_core_fifo_fabric_generic_pipe));
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x)"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int         resource_type_flag;
    uint32      resource_count;
    bcm_cosq_ingress_queue_bundle_gport_config_t config;
    int cosq;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* basic consistency checks */
    resource_type_flag = (flags &
                           (BCM_COSQ_GPORT_SCHEDULER | BCM_COSQ_GPORT_VOQ_CONNECTOR |
                            BCM_COSQ_GPORT_VSQ | BCM_COSQ_GPORT_MCAST_QUEUE_GROUP |
                            BCM_COSQ_GPORT_ISQ | BCM_COSQ_GPORT_UCAST_QUEUE_GROUP));

    resource_count = _bcm_cosq_bit_count_get(resource_type_flag);
    if (resource_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG(
          "unit %d, Invalid resource flags 0x%x - only one resource can be allocated, number resources specified %d"),
          unit, resource_type_flag, resource_count));
    }
    
    /* check for scheduler resource allocation */
    if (flags & BCM_COSQ_GPORT_SCHEDULER) {
        rc = _bcm_petra_cosq_sched_gport_add(unit, port, numq, flags, gport);
    }

    /* check for connector resource allocation */
    else if (flags & BCM_COSQ_GPORT_VOQ_CONNECTOR) {
        if (!(flags & BCM_COSQ_GPORT_WITH_ID) && SOC_DPP_DEFS_GET(unit, nof_cores) > 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Can't determine core ID")));
        } else {
            rc = _bcm_petra_cosq_connector_gport_add(unit, -1, -1, 1, port, numq, flags, gport);
        }
    }  
    /* check for multicast resource allocation */
    else if (flags & BCM_COSQ_GPORT_MCAST_QUEUE_GROUP) {
        config.flags = flags;
        config.port = port;
        config.local_core_id = BCM_CORE_ALL;
        config.numq = numq;
        for (cosq = 0 ; cosq < BCM_COS_COUNT; cosq++) {
            /*setting all of the rate classes zero*/
            config.queue_atrributes[cosq].delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED;
            /*setting all of the credit request profiles to zero*/
            config.queue_atrributes[cosq].rate_class = 0;
        }
        rc = _bcm_petra_cosq_mcast_gport_add(unit, &config, gport);
    }
    /* unicast or ISQ resources */
    else if ((flags & BCM_COSQ_GPORT_UCAST_QUEUE_GROUP) || 
         (flags & BCM_COSQ_GPORT_ISQ)) {
        config.flags = flags;
        config.port = port;
        config.local_core_id = BCM_CORE_ALL;
        config.numq = numq;
        for (cosq = 0 ; cosq < BCM_COS_COUNT; cosq++) {
            /*setting all of the rate classes zero*/
            config.queue_atrributes[cosq].delay_tolerance_level = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED;
            /*setting all of the credit request profiles to default 10 slow enabled mode*/
            config.queue_atrributes[cosq].rate_class = 0;
        }
        rc = _bcm_petra_cosq_ucast_gport_add(unit, &config, gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, add not support for gport(0x%x)"), unit, *gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_voq_connector_gport_add(int unit, 
                                           bcm_cosq_voq_connector_gport_t *config, 
                                           bcm_gport_t *gport)
{
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_core_get(unit, config->port, 0, &core));    

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_connector_gport_add(unit, core, config->remote_modid, config->nof_remote_cores, 0, 
                                                           config->numq, config->flags, gport));
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_get(int unit,
                         bcm_gport_t gport,
                         bcm_gport_t *physical_port,
                         int *num_cos_levels,
                         uint32 *flags)
{
    bcm_error_t   rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    /* consistency cheks */
    if (flags == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flags, must be 0"), unit));
    }

    if (flags != NULL) {
        (*flags) = 0;
    }
    if (num_cos_levels != NULL) {
       (*num_cos_levels) = 0;
    }
    if (physical_port != NULL) {
       (*physical_port) = 0;
    } else {
    /* Not all calls use physical_port,
     * but since that may change, better to 
     * expect it as a valid parameter
     */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, physical port must be valid parameter - not NULL"), unit));
    }

    BCMDNX_NULL_CHECK(num_cos_levels);
    
    if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        rc = _bcm_petra_cosq_connector_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if (BCM_GPORT_IS_SCHEDULER(gport)) {
        rc = _bcm_petra_cosq_sched_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        rc = _bcm_petra_cosq_e2e_gport_get(unit, gport, physical_port, num_cos_levels, flags);
    }
    else if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) || 
         (BCM_COSQ_GPORT_IS_ISQ(gport))) {
        rc = _bcm_petra_cosq_ucast_gport_get(unit, gport, physical_port, (uint32*)num_cos_levels, flags);
    }
    else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_petra_cosq_mcast_gport_get(unit, gport, physical_port, (uint32*)num_cos_levels, flags);
    }
    else {
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_delete(int unit,
                            bcm_gport_t gport)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* consistency checks */
    if (BCM_GPORT_IS_SCHEDULER(gport)) {
        rc = _bcm_petra_cosq_sched_gport_delete(unit, gport);
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        rc = _bcm_petra_cosq_connector_gport_delete(unit, gport);
    }
    else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        rc = _bcm_petra_cosq_mcast_gport_delete(unit, gport);
    }
    else if ((BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) || 
         (BCM_COSQ_GPORT_IS_ISQ(gport))) {
        rc = _bcm_petra_cosq_ucast_gport_delete(unit, gport);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, delete not support for gport(0x%x)"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}
int bcm_petra_cosq_gport_traverse(int unit,
                                  bcm_cosq_gport_traverse_cb cb,
                                  void *user_data)
{
    bcm_error_t rc = BCM_E_NONE;
    int voq = 0, nbr_cos = 0;
    bcm_gport_t gport = 0;
    int is_multicast=FALSE, is_isq=FALSE, is_unicast=FALSE;
    int queue_type = 0;
    int flow_id = 0, flow_id_temp = 0, flow_region;
    int                              is_odd_even;
    int                              is_cl_cir;
    uint8                            is_interdigitated;
    int se_id,
        se_id_start,
        se_id_end,
        se_id_type,
        se_type_iter,
        se_id_loop_start[3] = {DPP_DEVICE_COSQ_CL_SE_ID_MIN_ARAD, DPP_DEVICE_COSQ_FQ_SE_ID_MIN_ARAD, DPP_DEVICE_COSQ_HR_SE_ID_MIN_ARAD},
        se_id_loop_end[3] = {DPP_DEVICE_COSQ_CL_SE_ID_MAX_ARAD, DPP_DEVICE_COSQ_FQ_SE_ID_MAX_ARAD, DPP_DEVICE_COSQ_HR_SE_ID_MAX_ARAD},
        se_ids_types[3] = {DPP_DEVICE_COSQ_CL_MASK, DPP_DEVICE_COSQ_FQ_MASK, DPP_DEVICE_COSQ_HR_MASK};
    int core = 0;
    uint32 sw_state_ref_cnt;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;

    /* walk through all the queues in the system, create gport and call
     * callback function for each unicast or multicast gport, passing 
     * user data to cb function
     */
    /* skip over voq 0 (multicast) - function can be later modified to support multicast as well */
    BCM_DPP_ASSYMETRIC_CORES_ITER(BCM_CORE_ALL, core) {
        for (voq=4;
             voq <  DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit); 
             voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, core, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core, voq), &sw_state_num_cos));
                nbr_cos = sw_state_num_cos;

            /* Queue not in use, go to the next */
            if (nbr_cos == 0) {
                continue;
            }

            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit(%d) voq base(%d) num_cos(%d)\n"), 
                                  unit, voq, nbr_cos));


            rc = _bcm_petra_cosq_qid_type_get(unit, core, voq, &gport, &is_multicast,
                                              &is_unicast, &is_isq, &queue_type);

            if (BCM_FAILURE(rc)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, add not support for gport(0x%x)\n"), unit, gport));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            if (is_unicast) {
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(gport, core, voq);
            } 
            else if (is_multicast) {
                BCM_GPORT_MCAST_QUEUE_GROUP_CORE_QUEUE_SET(gport, core, voq);
            }
            else if (is_isq) {
                BCM_COSQ_GPORT_ISQ_CORE_QUEUE_SET(gport, core, voq);
            }
            rc = cb(unit, 0/*port*/, nbr_cos, 0/*flags*/, gport, user_data);

            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        for (flow_id_temp=0;
             flow_id_temp < DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit); 
             flow_id_temp += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

            flow_id = flow_id_temp;

            if (flow_id> (DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit)/2)) {
                flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(flow_id);
                rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even, &is_cl_cir);
                BCMDNX_IF_ERR_EXIT(rc);
                if (is_interdigitated) {
                    flow_id += 2; /*interdigitated connectors*/
                }
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, flow_id, &sw_state_num_cos));
            nbr_cos = sw_state_num_cos;

            /* Queue not in use, go to the next */
            if (nbr_cos == 0) {
                continue;
            }

            if(SOC_IS_QAX(unit)){
                flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
            }

            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit(%d) connector flow(%d) num_cos(%d)\n"), 
                                  unit, flow_id, nbr_cos));


            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(gport, flow_id, core);

            rc = cb(unit, 0/*port*/, nbr_cos, 0/*flags*/, gport, user_data);

            BCMDNX_IF_ERR_EXIT(rc);
        }
        for (se_type_iter = 0 ; se_type_iter < 3 ; ++se_type_iter) {

            se_id_start = se_id_loop_start[se_type_iter];
            se_id_end = se_id_loop_end[se_type_iter];
            se_id_type = se_ids_types[se_type_iter];

            for (se_id = se_id_start ; se_id <= se_id_end ;  ++se_id) {

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, se_id, &sw_state_ref_cnt));
                /* se not in use, go to the next */
                if (sw_state_ref_cnt == 0) {
                    continue;
                }

                LOG_DEBUG(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit(%d) se base(%d) num_ref(%d)\n"), 
                                      unit, se_id, sw_state_ref_cnt));

                flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
                if (flow_id == DPP_DEVICE_COSQ_SCH_FLOW_ID_INVALID_ARAD) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE,(_BSL_BCM_MSG_STR("unit %d, illegal se %d\n"), unit, se_id));
                }

                if(SOC_IS_QAX(unit)){
                    flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
                }

                BCM_GPORT_SCHEDULER_CORE_SET(gport,flow_id,core);

                rc = cb(unit, 0/*port*/, 1, se_id_type/*flags*/, gport, user_data);

                BCMDNX_IF_ERR_EXIT(rc);

            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_get(int unit, 
                                int start_queue,
                                int end_queue,
                                int *pri_profile_id)
{
    uint32 region = 0, last_region, start_region = 0;
    uint32 first_profile_id = 0, profile_id = 0;
    uint32 soc_sand_rc;
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_* is not supported in Jericho")));
    }

    if (pri_profile_id == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile_id valid pointer required")));        
    }
    if (start_queue > end_queue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) must be less than end queue(%d)"), 
                       unit, start_queue, end_queue));
    }
    if (((end_queue+1)%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0) || 
        (start_queue%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) and end queue(%d)+1 must be multiple of 64"), 
                       unit, start_queue, end_queue));
    }
    
    start_region = start_queue/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    last_region = start_region + (end_queue - start_queue)/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    for (region = start_region;
         region <= last_region;
         region++) {
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_select_get,(unit, region, &profile_id)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_select_get region %d, profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, region, 
                                  profile_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        
        if (region == start_region) {
            first_profile_id = profile_id;
        }
        if (first_profile_id != profile_id) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("template queue range mismatch region(%d)=(%d) doesn't match start (%d)=(%d)"), 
                                        region, profile_id, start_region, first_profile_id));
        }
    }
    *pri_profile_id = profile_id;
    
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_set(int unit,
                                int start_queue,
                                int end_queue,
                                int pri_profile_id)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 region = 0, last_region = 0;
    uint32 soc_sand_rc;
    uint32 start_region;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_* is not supported in Jericho")));
    }

    if (pri_profile_id > DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, maximum profile exceeded (3) number resources specified (%d)\nmaximum profile exceeded"), 
                       unit, pri_profile_id));

    }
    if (start_queue > end_queue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) must be less than end queue(%d)\nstart queue exceeds end queue"), 
                       unit, start_queue, end_queue));
    }
    if (((end_queue+1)%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0) || 
        (start_queue%DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE != 0)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, start queue(%d) and end queue(%d)+1 must be multiple of 64\nparameter error"), 
                       unit, start_queue, end_queue));
    }

    start_region = start_queue/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;
    last_region = start_region + (end_queue - start_queue)/DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;

    for (region = start_region;
         region <= last_region; 
         region++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_select_set,(unit, region, pri_profile_id)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_select_set region %d, profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, region, 
                                  pri_profile_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_profile_get(int unit,
                                        int pri_profile_id,
                                        int *count,
                                        bcm_cosq_gport_priority_profile_t *pri_profile)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_PRIORITY_MAP_TMPLT prm_info;
    uint32 soc_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_profile_* is not supported in Jericho")));
    }

    SOC_TMC_ITM_PRIORITY_MAP_TMPLT_clear(&prm_info);

    if (pri_profile_id > DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, maximum profile exceeded (3) number resources specified (%d)\n"), 
                              unit, pri_profile_id));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("maximum profile exceeded")));

    }
    if (pri_profile == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, parameter pri_profile pointer error\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile error")));

    }
    *count = DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_get,(unit, pri_profile_id, &prm_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_get  profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    pri_profile->pri[0] = prm_info.map[0];
    pri_profile->pri[1] = prm_info.map[1];

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_priority_profile_set(int unit,
                                        int pri_profile_id,
                                        int count,
                                        bcm_cosq_gport_priority_profile_t *pri_profile)

{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_PRIORITY_MAP_TMPLT prm_info;
    uint32 soc_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_ITM_PRIORITY_MAP_TMPLT_clear(&prm_info);

    if (SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_priority_profile_* is not supported in Jericho")));
    }

    if (pri_profile_id > DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_MAX) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, maximum profile exceeded (3) number resources specified (%d)\n"), 
                              unit, pri_profile_id));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("maximum profile exceeded")));

    }
    if (pri_profile == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, parameter pri_profile pointer error\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("pri_profile error")));

    }
    if (count != DPP_DEVICE_INGR_QUEUE_PRI_TEMPLATE_REGION_SIZE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, count(%d) must be (%d) queues per template\n"), 
                              unit, count, BCM_COSQ_PRIORITY_PROFILE_MAX_SIZE));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("count error")));

    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_get,(unit, pri_profile_id, &prm_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_get  profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    

    prm_info.map[0] = pri_profile->pri[0];
    prm_info.map[1] = pri_profile->pri[1];

    soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_priority_map_tmplt_set,(unit, pri_profile_id, &prm_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in mbcm_dpp_itm_priority_map_tmplt_set  profile_id %d, soc_sand error 0x%x, error 0x%x\n"), unit, 
                              pri_profile_id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    BCMDNX_IF_ERR_EXIT(rc);
        
exit:
    BCMDNX_FUNC_RETURN;
}

bcm_dpp_cosq_vsq_rate_class_wred_info_t* 
bcm_dpp_cosq_vsq_rate_class_wred_data_get(int unit, const SOC_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dpp_cosq_vsq_rate_class_info_t* data_rate_cls) {
    int pool_index = 0;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        pool_index = pool_id;
    }

    if (vsq_group < SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        return &(data_rate_cls->queue[vsq_group].wred);
    }
    if (vsq_group == SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        if (pool_index < SOC_TMC_ITM_NOF_RSRC_POOLS) {
            return (void *)&(data_rate_cls->port[pool_index].wred);
        }
    }
    if (vsq_group == SOC_TMC_ITM_VSQ_GROUP_PG) {
        return (void *)&(data_rate_cls->pg.wred);
    }
    return (void *)NULL;
}

bcm_dpp_cosq_vsq_rate_class_taildrop_info_t* 
bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(int unit, const SOC_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, int headroom, bcm_dpp_cosq_vsq_rate_class_info_t* data_rate_cls) {
    int pool_index = 0;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        pool_index = pool_id;
    }
    if (vsq_group < SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        return &(data_rate_cls->queue[vsq_group].taildrop);
    }
    if (vsq_group == SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        if (pool_index < SOC_TMC_ITM_NOF_RSRC_POOLS) {
            if (headroom) {
                return (void *)&(data_rate_cls->port[pool_index].headroom);    
            } else {
                return (void *)&(data_rate_cls->port[pool_index].shared);
            }
        }
    }
    if (vsq_group == SOC_TMC_ITM_VSQ_GROUP_PG) {
        if (headroom) {
            return (void *)&(data_rate_cls->pg.headroom);
        } else {
            return (void *)&(data_rate_cls->pg.shared);
        }
    }
    return (void *)NULL;
}

bcm_dpp_cosq_vsq_rate_class_fc_info_t* 
bcm_dpp_cosq_vsq_rate_class_fc_data_get(int unit, const SOC_TMC_ITM_VSQ_GROUP vsq_group, const int pool_id, bcm_dpp_cosq_vsq_rate_class_info_t* data_rate_cls) {
    int pool_index = 0;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        pool_index = pool_id;
    }
    if (vsq_group < SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        return &(data_rate_cls->queue[vsq_group].fc);
    }
    if (vsq_group == SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        if (pool_index < SOC_TMC_ITM_NOF_RSRC_POOLS) {
            return (void *)&(data_rate_cls->port[pool_index].fc);
        }
    }
    if (vsq_group == SOC_TMC_ITM_VSQ_GROUP_PG) {
        return (void *)&(data_rate_cls->pg.fc);
    }
    return (void *)NULL;
}
/* 
 * Purpose: Commit in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_vsq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      SOC_TMC_ITM_VSQ_GROUP vsq_category_index,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_vsq_rate_class_info_t *exact_rate_class_info)
{
    uint32                soc_sand_rc = 0;    
    bcm_error_t           rc = BCM_E_NONE;
    int dp_index;
    SOC_TMC_ITM_WRED_QT_DP_INFO wred_info, exact_wred_info;
    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO tail_drop_info, exact_tail_drop_info;
    SOC_TMC_ITM_VSQ_WRED_GEN_INFO wred_gen_info;
    SOC_TMC_ITM_VSQ_FC_INFO fc_info, exact_fc_info;
    soc_dpp_config_t *dpp = SOC_DPP_CONFIG(unit);
    int pool_id;
    bcm_dpp_cosq_vsq_rate_class_wred_info_t *wred, *exact_wred;
    bcm_dpp_cosq_vsq_rate_class_taildrop_info_t *taildrop, *exact_taildrop;
    bcm_dpp_cosq_vsq_rate_class_fc_info_t *fc, *exact_fc;
    int is_headroom = 0, rsrc_type = SOC_TMC_INGRESS_THRESHOLD_INVALID;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(rate_class_info);
    BCMDNX_NULL_CHECK(exact_rate_class_info);
    
    SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&exact_wred_info);
    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&exact_tail_drop_info);
    SOC_TMC_ITM_VSQ_FC_INFO_clear(&exact_fc_info);

    
    for (pool_id = 0; 
         pool_id < ((vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) ? DPP_DEVICE_COSQ_VSQ_NOF_RSRC_POOLS(unit) : 1); 
         pool_id++) {
        if (pool_id != 0 && vsq_category_index != SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
            continue;
        }
        wred = bcm_dpp_cosq_vsq_rate_class_wred_data_get(unit, vsq_category_index, pool_id, rate_class_info);
        exact_wred = bcm_dpp_cosq_vsq_rate_class_wred_data_get(unit, vsq_category_index, pool_id, exact_rate_class_info);


        for (dp_index = 0; dp_index < DPP_DEVICE_COSQ_ING_NOF_DP; dp_index++) {
            SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
            SOC_TMC_ITM_VSQ_WRED_GEN_INFO_clear(&wred_gen_info); 
        
            /* WRED */
            rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_get,(unit,vsq_category_index, rate_class, dp_index, pool_id, &wred_info)));
            BCMDNX_IF_ERR_EXIT(rc);

            rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_gen_get,(unit, vsq_category_index, rate_class, pool_id, &wred_gen_info)));
            BCMDNX_IF_ERR_EXIT(rc);

            if (wred->enable[dp_index]) {
                wred_gen_info.wred_en = 1;
            }
            wred_gen_info.exp_wq            = wred->wred_exp_wq;
            wred_info.max_avrg_th           = wred->max_avrg_th[dp_index];
            wred_info.min_avrg_th           = wred->min_avrg_th[dp_index];
            wred_info.max_probability       = wred->max_probability[dp_index];
            wred_info.wred_en               = wred->enable[dp_index];
            wred_info.ignore_packet_size    = (dpp->tm.wred_packet_size == 0) ? 1 : 0;
            wred_info.max_packet_size       = dpp->tm.wred_packet_size;

            rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_set,(unit, vsq_category_index, rate_class, dp_index, pool_id, &wred_info, &exact_wred_info)));
            BCMDNX_IF_ERR_EXIT(rc);
   
            rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_wred_gen_set,(unit, vsq_category_index, rate_class, pool_id, &wred_gen_info)));
            BCMDNX_IF_ERR_EXIT(rc);

            /*  Set exact rate class information according to exact wred information */
            exact_wred->min_avrg_th[dp_index] = exact_wred_info.min_avrg_th;
            exact_wred->max_avrg_th[dp_index] = exact_wred_info.max_avrg_th;
            exact_wred->max_probability[dp_index] = exact_wred_info.max_probability;
            exact_wred->enable[dp_index] = exact_wred_info.wred_en;
            exact_wred->ignore_packet_size[dp_index] = wred_info.max_packet_size;
            exact_wred->wred_exp_wq = wred_gen_info.exp_wq;

            if (!SOC_IS_QAX(unit) || (SOC_IS_QAX(unit) && vsq_category_index < SOC_TMC_ITM_VSQ_GROUP_SRC_PORT)) {
                /* 
                 * For QAX we seperate destination-based VSQs from source-based VSQs.
                 * This part is the destination-based VSQs taildrop 
                 */
                for (is_headroom = 0; is_headroom < 2; is_headroom++) {
                    taildrop = bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(unit, vsq_category_index, pool_id, is_headroom, rate_class_info);
                    exact_taildrop = bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(unit, vsq_category_index, pool_id, is_headroom, exact_rate_class_info);

                    /* Tail drop */                                
                    SOC_TMC_ITM_VSQ_TAIL_DROP_INFO_clear(&tail_drop_info);
                    rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_tail_drop_get,(unit,vsq_category_index, rate_class, dp_index, pool_id, is_headroom, &tail_drop_info)));
                    BCMDNX_IF_ERR_EXIT(rc);

                    /*shalitas: Today we configure the headroom and the pool in the same way*/
                    tail_drop_info.max_inst_q_size     = taildrop->max_size[dp_index];
                    tail_drop_info.max_inst_q_size_bds = taildrop->max_size_bds[dp_index];
                    for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                        tail_drop_info.max_inst_q_size_th[rsrc_type]= taildrop->max_size_th[rsrc_type][dp_index];
                    }

                    if (vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_PG) {
                        tail_drop_info.alpha = rate_class_info->pg.queue_alpha_bds[dp_index];
                    }

                    rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_tail_drop_set,(unit, vsq_category_index, rate_class, dp_index, pool_id, is_headroom, &tail_drop_info, &exact_tail_drop_info)));
                    BCMDNX_IF_ERR_EXIT(rc);

                    exact_taildrop->max_size[dp_index]     = exact_tail_drop_info.max_inst_q_size;
                    exact_taildrop->max_size_bds[dp_index] = exact_tail_drop_info.max_inst_q_size_bds;
                    for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                        exact_taildrop->max_size_th[rsrc_type][dp_index] = exact_tail_drop_info.max_inst_q_size_th[rsrc_type];
                    }

                    if (vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_PG) {
                        exact_rate_class_info->pg.queue_alpha_bds[dp_index] = tail_drop_info.alpha;
                    }
                }
            }
            if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                if (SOC_IS_QAX(unit)) {
                    /* 
                     * For QAX we seperate destination-based VSQs from source-based VSQs.
                     * This part relates to the source-based VSQs. 
                     */
                    bcm_dpp_cosq_src_port_vsq_rate_class_info_t *src_port = &rate_class_info->port[pool_id];
                    bcm_dpp_cosq_src_port_vsq_rate_class_info_t *exact_src_port = &exact_rate_class_info->port[pool_id];
                    SOC_TMC_ITM_VSQ_SRC_PORT_INFO src_port_info, exact_src_port_info;
                    bcm_dpp_cosq_pg_vsq_rate_class_info_t *pg = &rate_class_info->pg;
                    bcm_dpp_cosq_pg_vsq_rate_class_info_t *exact_pg = &exact_rate_class_info->pg;
                    SOC_TMC_ITM_VSQ_PG_INFO pg_info, exact_pg_info;

                    if (vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
                        SOC_TMC_ITM_VSQ_SRC_PORT_INFO_clear(&exact_src_port_info);
                        SOC_TMC_ITM_VSQ_SRC_PORT_INFO_clear(&src_port_info);

                        for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            src_port_info.max_guaranteed[rsrc_type] = src_port->guaranteed_size[rsrc_type][dp_index];
                            src_port_info.max_shared[rsrc_type] = src_port->shared_size[rsrc_type][dp_index];
                            src_port_info.max_headroom[rsrc_type] = src_port->headroom_size[rsrc_type];
                        }

                        rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_src_port_rjct_set, (unit, rate_class, dp_index, pool_id, &src_port_info, &exact_src_port_info));
                        BCMDNX_IF_ERR_EXIT(rc);

                        for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            exact_src_port->guaranteed_size[rsrc_type][dp_index] = exact_src_port_info.max_guaranteed[rsrc_type];
                            exact_src_port->shared_size[rsrc_type][dp_index] = exact_src_port_info.max_shared[rsrc_type];
                            exact_src_port->headroom_size[rsrc_type] = exact_src_port_info.max_headroom[rsrc_type];
                        }
                    }

                    if (vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_PG) {
                        SOC_TMC_ITM_VSQ_PG_INFO_clear(&exact_pg_info);
                        SOC_TMC_ITM_VSQ_PG_INFO_clear(&pg_info);

                        for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            pg_info.max_guaranteed[rsrc_type] = pg->guaranteed_size[rsrc_type][dp_index];
                            pg_info.max_shared[rsrc_type].max_threshold = pg->shared_size[rsrc_type][dp_index].max_threshold;
                            pg_info.max_shared[rsrc_type].min_threshold = pg->shared_size[rsrc_type][dp_index].min_threshold;
                            pg_info.max_shared[rsrc_type].alpha = pg->shared_size[rsrc_type][dp_index].alpha;
                            pg_info.max_headroom[rsrc_type].max_headroom = pg->headroom_size[rsrc_type].max_headroom;
                            pg_info.max_headroom[rsrc_type].max_headroom_nominal = pg->headroom_size[rsrc_type].max_headroom_nominal;
                            pg_info.max_headroom[rsrc_type].max_headroom_extension = pg->headroom_size[rsrc_type].max_headroom_extension;
                        }

                        rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_rjct_set, (unit, rate_class, dp_index, &pg_info, &exact_pg_info));
                        BCMDNX_IF_ERR_EXIT(rc);

                        for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
                            exact_pg->guaranteed_size[rsrc_type][dp_index] = exact_pg_info.max_guaranteed[rsrc_type];
                            exact_pg->shared_size[rsrc_type][dp_index].max_threshold = exact_pg_info.max_shared[rsrc_type].max_threshold;
                            exact_pg->shared_size[rsrc_type][dp_index].min_threshold = exact_pg_info.max_shared[rsrc_type].min_threshold;
                            exact_pg->shared_size[rsrc_type][dp_index].alpha = exact_pg_info.max_shared[rsrc_type].alpha;
                            exact_pg->headroom_size[rsrc_type].max_headroom = exact_pg_info.max_headroom[rsrc_type].max_headroom;
                            exact_pg->headroom_size[rsrc_type].max_headroom_nominal = exact_pg_info.max_headroom[rsrc_type].max_headroom_nominal;
                            exact_pg->headroom_size[rsrc_type].max_headroom_extension = exact_pg_info.max_headroom[rsrc_type].max_headroom_extension;
                        }
                    }
                } else {
                    if (vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
                        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_src_reserve_set, (unit, BCM_CORE_ALL, vsq_category_index, rate_class, dp_index, pool_id, rate_class_info->port[pool_id].min_threshold[dp_index], &exact_rate_class_info->port[pool_id].min_threshold[dp_index])));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                    if (vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_PG) {
                        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_src_reserve_set, (unit, BCM_CORE_ALL, vsq_category_index, rate_class, dp_index, pool_id, rate_class_info->pg.min_threshold[dp_index], &exact_rate_class_info->pg.min_threshold[dp_index])));
                        BCMDNX_IF_ERR_EXIT(rc);
                    }
                }
            }
        }

        fc = bcm_dpp_cosq_vsq_rate_class_fc_data_get(unit, vsq_category_index, pool_id, rate_class_info);
        exact_fc = bcm_dpp_cosq_vsq_rate_class_fc_data_get(unit, vsq_category_index, pool_id, exact_rate_class_info);

        SOC_TMC_ITM_VSQ_FC_INFO_clear(&fc_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_fc_get,(unit, vsq_category_index, rate_class, pool_id, &fc_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        fc_info.q_size_fc    = fc->queue_size;
        fc_info.bd_size_fc    = fc->bd_size;
        for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
            fc_info.size_fc[rsrc_type]   = fc->size[rsrc_type];
            fc_info.fadt_size_fc[rsrc_type] = fc->fadt_size[rsrc_type];
        }

        /* Set information */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_fc_set,(unit, vsq_category_index, rate_class, pool_id, &fc_info,&exact_fc_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        exact_fc->queue_size    = exact_fc_info.q_size_fc;
        exact_fc->bd_size       = exact_fc_info.bd_size_fc;
        for (rsrc_type = 0; rsrc_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; ++rsrc_type) {
            exact_fc->size[rsrc_type]    = exact_fc_info.size_fc[rsrc_type];
            exact_fc->fadt_size[rsrc_type] = exact_fc_info.fadt_size_fc[rsrc_type];
        }
    }

    if (vsq_category_index == SOC_TMC_ITM_VSQ_GROUP_PG && !SOC_IS_ARADPLUS_AND_BELOW(unit) && !SOC_IS_QAX(unit)) {
        /* In QAX PG params are per PG-VSQ and not per rate class, so we don't set them here. */
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_prm_set, (unit, rate_class, &(rate_class_info->pg.prm)))); 
        sal_memcpy(&(exact_rate_class_info->pg.prm), &(rate_class_info->pg.prm), sizeof(SOC_TMC_ITM_VSQ_PG_PRM));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Since there is only 1 counter for reserved DB per VSQE/F, need to find
 * the maximum reserved amount of the VSQ across all colors (and for VSQE
 * also across pools).
 */
STATIC uint32
_bcm_petra_cosq_vsq_max_reserved_get(int unit,
                                     SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type,
                                     bcm_dpp_cosq_vsq_type_t vsq_group_type,
                                     bcm_dpp_cosq_vsq_rate_class_info_t *data_rate_class)
{
    uint32 max_reserved = 0, color_reserved = 0;
    uint8 color = 0, pool_id = 0;

    /* Find maximum reserved size of all colors in VSQ */
    for (color = 0; color < DPP_DEVICE_COSQ_ING_NOF_DP; ++color) {
        if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT) {
            for (pool_id = 0; pool_id < SOC_TMC_ITM_NOF_RSRC_POOLS; ++pool_id) {
                if (SOC_IS_QAX(unit)) {
                    color_reserved = data_rate_class->port[pool_id].guaranteed_size[rsrc_type][color];
                } else {
                    color_reserved = data_rate_class->port[pool_id].min_threshold[color];
                }
                if (color_reserved > max_reserved) {
                    max_reserved = color_reserved;
                }
            }
        } else if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG) {
            if (SOC_IS_QAX(unit)) {
                color_reserved = data_rate_class->pg.guaranteed_size[rsrc_type][color];
            } else {
                color_reserved = data_rate_class->pg.min_threshold[color];
            }
            if (color_reserved > max_reserved) {
                max_reserved = color_reserved;
            }
        }
    }

    return max_reserved;
}

/*
 * Purpose:
 *  Check there are enough resources after reserve_change will be updated,
 *  and then update the new reserved resources in sw_state.
 */
STATIC int
_bcm_petra_cosq_vsq_total_reserve_update(int unit,
                                         int core_id,
                                         uint8 is_ocb_only,
                                         SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type,
                                         int reserve_change)
{
    bcm_error_t rv;
    SOC_TMC_ITM_INGRESS_CONGESTION_MGMT ingress_congestion_mgmt;
    SOC_TMC_ITM_INGRESS_CONGESTION_RESOURCE *ingress_resource = NULL;
    SOC_TMC_ITM_INGRESS_RESERVED_RESOURCE ingress_reserved_resource;
    BCMDNX_INIT_FUNC_DEFS;

    rv = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_global_resource_allocation_get,(unit, core_id, &ingress_congestion_mgmt));
    BCMDNX_IF_ERR_EXIT(rv);

    ingress_resource = (SOC_IS_QAX(unit)) ?
        (&ingress_congestion_mgmt.global[rsrc_type]) :
        (is_ocb_only ? (&ingress_congestion_mgmt.ocb) : (&ingress_congestion_mgmt.dram));

    if (ingress_resource->pool_0 + 
            ingress_resource->pool_1 + 
            (SOC_IS_QAX(unit) ? (ingress_resource->nominal_headroom) : (ingress_resource->headroom)) +
            ingress_resource->reserved +
            reserve_change > ingress_resource->total) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Run out of resource to reserve/guarantee for VSQ. Consider reduce pools size.")));
    }

    /* Update reserved resource in sw_state */
    rv = sw_state_access[unit].dpp.soc.jericho.tm.ingress_reserved_resource.get(unit, core_id, &ingress_reserved_resource);
    BCMDNX_IF_ERR_EXIT(rv);
    if (SOC_IS_QAX(unit)) {
        ingress_reserved_resource.reserved[rsrc_type] += reserve_change;
    } else {
        (is_ocb_only) ? (ingress_reserved_resource.ocb_reserved += reserve_change) : (ingress_reserved_resource.dram_reserved += reserve_change);
    }
    rv = sw_state_access[unit].dpp.soc.jericho.tm.ingress_reserved_resource.set(unit, core_id, &ingress_reserved_resource);
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_category_get(int unit,
                                 int core_id,
                                 int queue_id,
                                 int *vsq_category)
{
    uint32 soc_sand_rc;
    SOC_TMC_ITM_CATEGORY_RNGS info;
    int queue_category = 0;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_CATEGORY_RNGS_clear(&info);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_category_rngs_get,(unit, core_id, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (queue_id <= info.vsq_ctgry0_end) {
        queue_category = 0;
    } else if (queue_id <= info.vsq_ctgry1_end) {
        queue_category = 1;
    } else if (queue_id <= info.vsq_ctgry2_end) {
        queue_category = 2;
    } else {
        queue_category = 3;
    }
    *vsq_category = queue_category;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_vsq_id_range_verify(int unit,
                                    int core_id,
                                    int queue_id,
                                    int vsq_category,
                                    int *is_match)
{
    bcm_error_t rv;
    int queue_category = 0;
    BCMDNX_INIT_FUNC_DEFS;
    
    *is_match = 0;

    rv = _bcm_petra_cosq_vsq_category_get(unit, core_id, queue_id, &queue_category);
    BCMDNX_IF_ERR_EXIT(rv);

    if (queue_category == vsq_category) {
        *is_match = 1;
    } 

    BCMDNX_IF_ERR_EXIT(rv);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_add(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    int queue_id;
    int vsq_category = 0, vsq_connection_cls = -1, vsq_traffic_cls = -1;    
    int is_match;
    int core_queue = BCM_CORE_ALL, core_vsq = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* Validate parameters */
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq gport type 0x%x "), unit, vsq));        
    }

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(queue)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq gport type 0x%x "), unit, queue));        
    }

    if (cosq < 0 || cosq > DPP_DEVICE_COSQ_ING_NOF_TC) {    
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }    
    queue_id = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(queue) + cosq;
    core_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(queue);

    if ((core_queue < 0 || core_queue >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core_queue != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) get uc q gport(0x%08x) failed, core out of range %d"), unit, queue, core_queue));
    }

    if (!(BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, type is no members adding for this type of vsq"), unit, vsq));
    }
    
    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        core_vsq = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq);
        if (core_vsq != core_queue && core_vsq != BCM_CORE_ALL && core_queue != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, vsq and voq cores must be equal. vsq core core id %d, queue core is %d"), unit, vsq, core_vsq, core_queue));
        }
        vsq_category = BCM_COSQ_GPORT_VSQ_CT_GET(vsq);
    }
    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq)) {
        vsq_connection_cls =  BCM_COSQ_GPORT_VSQ_CC_GET(vsq);
    }
    if (BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        vsq_traffic_cls =  BCM_COSQ_GPORT_VSQ_TC_GET(vsq);
    }

    rc = _bcm_petra_cosq_vsq_id_range_verify(unit, core_queue, queue_id, vsq_category, &is_match);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_match) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, voq 0x%x: no match between voq queue category and vsq gport category "), unit, vsq, queue));
    }   

    /* Set new mapping */
    if (vsq_connection_cls != -1) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DPP_COSQ_VSQ_CC, vsq_connection_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (vsq_traffic_cls != -1) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DPP_COSQ_VSQ_TC, vsq_traffic_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_delete(
    int unit, 
    bcm_gport_t vsq, 
    bcm_gport_t queue, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    int queue_id;
    int vsq_category = 0; 
    int is_match;  
    int core_queue = BCM_CORE_ALL, core_vsq = BCM_CORE_ALL;

  
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* Validate parameters */
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq gport type 0x%x "), unit, vsq));        
    }

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(queue)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq gport type 0x%x "), unit, queue));        
    }

    if (cosq < 0 || cosq > DPP_DEVICE_COSQ_ING_NOF_TC) {    
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }    

    queue_id = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(queue) + cosq;
    core_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(queue);

    if ((core_queue < 0 || core_queue >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core_queue != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) get uc q gport(0x%08x) failed, core out of range %d"), unit, queue, core_queue));
    }

    if (!(BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, type is no members adding for this type of vsq"), unit, vsq));
    }

    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq) || BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        core_vsq = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq);
        if (core_vsq != core_queue && core_vsq != BCM_CORE_ALL && core_queue != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, vsq and voq cores must be equal. vsq core core id %d, queue core is %d"), unit, vsq, core_vsq, core_queue));
        }
        vsq_category = BCM_COSQ_GPORT_VSQ_CT_GET(vsq);
    }
    
    rc = _bcm_petra_cosq_vsq_id_range_verify(unit, core_queue, queue_id, vsq_category, &is_match);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_match) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, vsq 0x%x, voq 0x%x: no match between voq queue category and vsq gport category "), unit, vsq, queue));
    }   

    /* Delete by mapping queue to default vsq, which is 0 */
    if (BCM_COSQ_GPORT_IS_VSQ_CTTC(vsq)) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DPP_COSQ_VSQ_TC, 0);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (BCM_COSQ_GPORT_IS_VSQ_CTCC(vsq)) {
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core_queue, queue_id, BCM_DPP_COSQ_VSQ_CC, 0);    
        BCMDNX_IF_ERR_EXIT(rc);
    } 
    BCMDNX_IF_ERR_EXIT(rc);        

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_delete_all(
    int unit, 
    bcm_gport_t vsq)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_get(
    int unit, 
    bcm_gport_t vsq, 
    int queue_max, 
    bcm_gport_t *queue_array, 
    bcm_cos_queue_t *cosq_array, 
    int *queue_count)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_vsq_get_group_type(int unit,
                                         bcm_cosq_vsq_info_t* vsq_info,
                                         bcm_dpp_cosq_vsq_type_t *vsq_group_type)                                 
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_GLOBAL;
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_CT) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTGRY;        
    }
    
    if (vsq_info->flags == BCM_COSQ_VSQ_CTTC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTTC;
    }
    
    if (vsq_info->flags == BCM_COSQ_VSQ_CTCC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_CTCC;
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_PP) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_PP;
    }
    /*Arad only types*/
    /*Src Port VSQ, and PG VSQ are configured in another another API*/
    if (vsq_info->flags == BCM_COSQ_VSQ_PFC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_PFC;
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_LLFC) {
        *vsq_group_type = BCM_DPP_COSQ_VSQ_TYPE_LLFC;
    }

    BCMDNX_IF_ERR_EXIT(rc);        

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * retrieve VSQ information from VSQ GPORT. 
 * When vsq_group_type is of tmc type returns the inner vsq index in tmc type.
 */
int
_bcm_petra_cosq_gport_vsq_gport_get(int unit,
                                    bcm_gport_t vsq_gport,
                                    bcm_cos_queue_t cosq, 
                                    int *core_id,
                                    uint8 *is_ocb_only,
                                    bcm_dpp_cosq_vsq_type_t *vsq_group_type,
                                    int *vsq_index)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 vsq_type_info;
    int src_port = 0;
    int traffic_class = 0;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_LAST_ARAD;
    uint32 soc_sand_rc, internal_id;  
    uint32 index = 0;  
    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG] = {0};

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(core_id);
    BCMDNX_NULL_CHECK(is_ocb_only);
    BCMDNX_NULL_CHECK(vsq_group_type);
    BCMDNX_NULL_CHECK(vsq_index); 

    *is_ocb_only = 0;
    *vsq_group_type = BCM_DPP_COSQ_GPORT_VSQ_TYPE_GET(vsq_gport);

    if (cosq != 0 && cosq != -1) {
        /* cosq must be 0/-1 for all VSQs, even for VSQ-PG,
         * because cosq is not relevant anymore for this function.
         */
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "VSQ 0x%x must have cosq 0 or -1.\n"), vsq_gport));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }

    if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *vsq_index = 0;
    } else if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTGRY) {
        *vsq_index = BCM_COSQ_GPORT_VSQ_CT_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTTC) {
        *vsq_index = (BCM_COSQ_GPORT_VSQ_CT_GET(vsq_gport) * DPP_COSQ_PACKET_NOF_TC) + BCM_COSQ_GPORT_VSQ_TC_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTCC) {
        *vsq_index = ((BCM_COSQ_GPORT_VSQ_CT_GET(vsq_gport) - 2) * DPP_COSQ_VSQ_NOF_CONNECTION_CLASS) + BCM_COSQ_GPORT_VSQ_CC_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PP) {
        src_port = BCM_COSQ_GPORT_VSQ_PP_GET(vsq_gport);
        *vsq_index = src_port;
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
    } else if (SOC_IS_JERICHO(unit) && (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT)) {
        *vsq_index = BCM_COSQ_GPORT_VSQ_SRC_PORT_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);
        if (!SOC_IS_QAX(unit)) {
            *is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(vsq_gport);
        }
    } else if (SOC_IS_JERICHO(unit) && (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG)) {
        *vsq_index = BCM_COSQ_GPORT_VSQ_PG_GET(vsq_gport);
        *core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq_gport);

        if (!SOC_IS_QAX(unit)) {
            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_ocb_get ,(unit, *core_id, *vsq_index, 1, ocb_only_array)));
            BCMDNX_IF_ERR_EXIT(rc);

            *is_ocb_only = ocb_only_array[0];
        }
    } else if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PFC || *vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_LLFC) {
        bcm_dpp_cosq_vsq_type_t vsq_group_type_get = -1;

        *core_id = 0;
        vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq_gport);
        if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PFC) {
           /* retrieve Class based and Src port */
           src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_SRC_PORT_GET(vsq_type_info);
           /* Class based = Traffic class in PB */
           traffic_class = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_TC_GET(vsq_type_info);
        } else {
           /* LLFC */
           src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPF_SRC_PORT_GET(vsq_type_info);
        }

        /* Get internal interface id */
        rc = soc_port_sw_db_first_phy_port_get(unit, src_port, &internal_id /*one based*/);
        BCMDNX_IF_ERR_EXIT(rc);
        internal_id--;
        /* Conclude VSQ Group ID */
        if (*vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PFC) {
            vsq_id = BCM_DPP_VSQ_ID_CBFC_ARAD(internal_id,traffic_class);
        } else {
            /* LLFC */
            vsq_id = BCM_DPP_VSQ_ID_LLFC_ARAD(internal_id);
        }
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_index_global2group,(unit, vsq_id, &soc_tmcvsq_type, &index, is_ocb_only)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in vsq id retrieve %d, vsq gport 0x%x"), unit, vsq_id, vsq_gport));
        }

        *vsq_index = (int)index;
        rc = _bcm_petra_cosq_tmc_vsq_type_to_bcm_vsq_type(soc_tmcvsq_type, &vsq_group_type_get);
        BCMDNX_IF_ERR_EXIT(rc);

        if (*vsq_group_type != vsq_group_type_get) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, VSQ 0x%x: Soc level VSQ group type %d in diffrent from configured type %d."), unit, vsq_gport, *vsq_group_type, vsq_group_type_get));
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq 0x%x group type %d "), unit, vsq_gport, *vsq_group_type));
    }
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_vsq_gport_set(int unit,
                                    bcm_cosq_vsq_info_t* vsq_info,
                                    bcm_dpp_cosq_vsq_type_t vsq_group_type,                                    
                                    bcm_gport_t *vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type;
    int local_port;

    BCMDNX_INIT_FUNC_DEFS;
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PFC || vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_LLFC)
    {
      /* retrieve local port from source port */
      rc = _bcm_petra_cosq_vsq_local_port_from_gport(unit,vsq_info->src_port, &local_port);
      BCMDNX_IF_ERR_EXIT(rc);      
    }
    switch (vsq_group_type) {
    case BCM_DPP_COSQ_VSQ_TYPE_GLOBAL:
        BCM_COSQ_GPORT_VSQ_GL_SET(*vsq_gport, vsq_info->core_id);
        break;
    case BCM_DPP_COSQ_VSQ_TYPE_CTGRY:
        BCM_COSQ_GPORT_VSQ_CT_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->ct_id);
        break;
    case BCM_DPP_COSQ_VSQ_TYPE_CTTC:
        BCM_COSQ_GPORT_VSQ_CTTC_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->ct_id, vsq_info->traffic_class);
        break;
    case BCM_DPP_COSQ_VSQ_TYPE_CTCC:
        BCM_COSQ_GPORT_VSQ_CTCC_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->ct_id, vsq_info->cc_id);
        break;
    case BCM_DPP_COSQ_VSQ_TYPE_PP:
        BCM_COSQ_GPORT_VSQ_PP_SET(*vsq_gport, vsq_info->core_id, 0, vsq_info->pp_vsq_id);
        break;
    case BCM_DPP_COSQ_VSQ_TYPE_PFC: /*Arad legacy type*/
        BCM_COSQ_VSQ_TYPE_INFO_GROUPE_SET(vsq_type, local_port, vsq_info->traffic_class);
        BCM_COSQ_GPORT_VSQ_SET(*vsq_gport, BCM_COSQ_VSQ_PFC, vsq_type); 
        break;
    case BCM_DPP_COSQ_VSQ_TYPE_LLFC: /*Arad legacy type*/
        BCM_COSQ_VSQ_TYPE_INFO_GROUPF_SET(vsq_type, local_port);
        BCM_COSQ_GPORT_VSQ_SET(*vsq_gport, BCM_COSQ_VSQ_LLFC, vsq_type);
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d "), unit, vsq_group_type));        
    }        

    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_local_port_from_gport(int unit,
                                          bcm_gport_t src_port,
                                          int *local_port)
{
  bcm_error_t rv = BCM_E_NONE;

  BCMDNX_INIT_FUNC_DEFS;   
  rv = bcm_petra_cosq_user_port_get(unit, src_port, local_port);
  BCMDNX_IF_ERR_EXIT(rv);


exit:
BCMDNX_FUNC_RETURN;
}



STATIC int 
_bcm_petra_cosq_vsq_info_verify(int unit,
                                bcm_cosq_vsq_info_t *vsq_info)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* consistency checks */
    /* Validate category range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_CT || 
         vsq_info->flags == BCM_COSQ_VSQ_CTTC || 
         vsq_info->flags == BCM_COSQ_VSQ_CTCC) && 
        (vsq_info->ct_id < 0 || vsq_info->ct_id > (SOC_DPP_DEFS_GET(unit, nof_vsq_a) - 1))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ct_id range %d "), unit, vsq_info->ct_id));        
    }
    if ((vsq_info->flags == BCM_COSQ_VSQ_GL || 
        vsq_info->flags == BCM_COSQ_VSQ_CT || 
        vsq_info->flags == BCM_COSQ_VSQ_CTTC || 
        vsq_info->flags == BCM_COSQ_VSQ_CTCC) &&
        (vsq_info->core_id != BCM_CORE_ALL && (vsq_info->core_id < 0 || vsq_info->core_id >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid core id %d"), unit, vsq_info->core_id));
    }
    /* Validate connection class range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_CTCC) && 
        (vsq_info->ct_id < 2 || vsq_info->ct_id > 3 || vsq_info->cc_id > (DPP_COSQ_VSQ_NOF_CONNECTION_CLASS - 1))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Category id or Connection class. CT %d, CC %d, CTCC expect category of 2-3 "), unit, vsq_info->ct_id, vsq_info->cc_id));
    }

    /* Validate source  ports range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_PFC) || (vsq_info->flags == BCM_COSQ_VSQ_LLFC)) {
        int local_port;
        if (SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Jericho does not support type %d"), unit, vsq_info->traffic_class));
        }
        /* Validate traffic class range */
        if ((vsq_info->traffic_class < 0 || vsq_info->traffic_class > (DPP_DEVICE_COSQ_ING_NOF_TC - 1))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid traffic class range %d "), unit, vsq_info->traffic_class));        
        }

        rc = _bcm_petra_cosq_vsq_local_port_from_gport(unit,vsq_info->src_port, &local_port);
        BCMDNX_IF_ERR_EXIT(rc);

        if (local_port < 0 || local_port > (_BCM_PETRA_NOF_TM_PORTS(unit) - 1)) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Source port. Source port %x "), unit, vsq_info->src_port));        
        }
    }
    /* Validate PP range */
    if ((vsq_info->flags == BCM_COSQ_VSQ_PP) && 
        (vsq_info->pp_vsq_id < 0 || vsq_info->pp_vsq_id > SOC_DPP_CONFIG(unit)->pdm_extension.max_st_vsq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid pp vsq id %d "), unit, vsq_info->pp_vsq_id));        
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_vsq_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    int core_id = BCM_CORE_ALL;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    int index, nof_drop_prec;  
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0; 
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    uint8 is_ocb_only;
    bcm_dpp_cosq_vsq_rate_class_wred_info_t *wred;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_group;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));    

    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* Validate Params */
    rc = _bcm_petra_cosq_gport_discard_verify(unit, discard, 1);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retrieve VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);    
    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &soc_tmcvsq_group);
    BCMDNX_IF_ERR_EXIT(rc);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL (unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_group, vsq_index, is_ocb_only, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */

    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change Rate class configuration according to discard structure */
    rc = _bcm_petra_cosq_voq_discard_retrieve_dps(unit, discard->flags, drop_prec, &nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec == 0) {
        /* Nothing to change, just exit */
        BCM_EXIT;
    }

    /* Note: Wred enable is global per rate class, thus if at least one dp is enable, all dps are enable. */
    wred = bcm_dpp_cosq_vsq_rate_class_wred_data_get(unit, soc_tmcvsq_group, 0, &data_rate_class);
    for (index = 0; index < nof_drop_prec; index++) {
        wred->enable[drop_prec[index]] = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? SOC_SAND_TRUE : SOC_SAND_FALSE;
        wred->min_avrg_th[drop_prec[index]] = discard->min_thresh;
        wred->max_avrg_th[drop_prec[index]] = discard->max_thresh;
        wred->max_probability[drop_prec[index]] = discard->drop_probability;
    }

    /* WRED exp wq parameter is same for all dps */
    wred->wred_exp_wq = discard->gain;

    /* Settings WRED parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there are not enough profiles that are free. This can be resolved if all configurations
       are exact */
     

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: retrieve WRED configuration
 */
STATIC int
_bcm_petra_cosq_gport_vsq_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;    
    int core_id = BCM_CORE_ALL;
    int nof_drop_prec;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    uint32 relevant_flags;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    int dp_index;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = 0; 
    int vsq_index;
    uint8 is_ocb_only;
    bcm_dpp_cosq_vsq_rate_class_wred_info_t *wred;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));    

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* retrieve VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                              BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK);

    if (!relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x"), unit, discard->flags));
    }

    relevant_flags = discard->flags & (BCM_COSQ_DISCARD_BYTES);

    if (!relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no discard type 0x%x"), unit, discard->flags));
    }

    rc = _bcm_petra_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec != 1) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color"), unit, discard->flags));
    }

    dp_index = drop_prec[0];

    /* Wred settings is defined by Rate Class profile */
    /* Get Rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    wred = bcm_dpp_cosq_vsq_rate_class_wred_data_get(unit, soc_tmcvsq_type, 0, &data_rate_class);
    discard->drop_probability = wred->max_probability[dp_index];
    discard->gain = wred->wred_exp_wq;
    discard->min_thresh = wred->min_avrg_th[dp_index];
    discard->max_thresh = wred->max_avrg_th[dp_index];
    if (wred->enable[dp_index] == SOC_SAND_TRUE) {
        discard->flags |= BCM_COSQ_DISCARD_ENABLE;
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    uint32 relevant_flags, tail_drop_types_flags;   
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    int index, tail_drop_count;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = 0;
    int vsq_index;
    uint8 is_ocb_only;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    int pool_id, headroom;
    bcm_dpp_cosq_vsq_rate_class_taildrop_info_t* taildrop;

    bcm_color_t start_color;
    bcm_color_t end_color;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));

    BCMDNX_NULL_CHECK(gport_size);

    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* Validate params */
    if (SOC_IS_QAX(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC));
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC));
    } else {
        tail_drop_types_flags = flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC;
    }
    /*shalitas: add flag for headroom and shared*/
    tail_drop_count = _bcm_cosq_bit_count_get(tail_drop_types_flags);
    if (tail_drop_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid tail drop flags 0x%x - only one drop can be allocated, number resources specified %d"), unit, tail_drop_types_flags, tail_drop_count));
    }

    if (SOC_IS_QAX(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND);
    } else {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    }

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }    

    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && ((color < 0) || (color >= DPP_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    /* retrieve VSQ ID */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    if (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1 && vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Only source port VSQs can be configured for pool 1, the type given is %d"), unit, vsq_group_type));
    }
    pool_id = (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1) ? 1 : 0;

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    /* Get old rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change related information */
    start_color = flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND ? 0 : color;
    end_color = flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND ? DPP_DEVICE_COSQ_ING_NOF_DP : color + 1;
    headroom = 0;   /* headroom is relevant only for source bases VSQs (VSQE-F) */
    taildrop = bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(unit, soc_tmcvsq_type, pool_id, headroom, &data_rate_class); 
    for (index = start_color; index < end_color; index++) {
        if (SOC_IS_QAX(unit)) {
            if (flags & BCM_COSQ_GPORT_SIZE_SRAM) {
                if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                    taildrop->max_size_th[SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][index] = gport_size->size_max;
                } else if (flags & BCM_COSQ_GPORT_SIZE_PACKET_DESC) {
                    taildrop->max_size_th[SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS][index] = gport_size->size_max;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
                }
            } else if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
                taildrop->max_size_th[SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][index] = gport_size->size_max;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }
        } else {
            if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
                taildrop->max_size[index] = gport_size->size_max;
            } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                taildrop->max_size_bds[index] = gport_size->size_max;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }

            if (!SOC_IS_ARADPLUS_AND_BELOW(unit) && 
                (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) && 
                (soc_tmcvsq_type == SOC_TMC_ITM_VSQ_GROUP_PG)) {
                if (gport_size->size_alpha_max < ARAD_PLUS_MIN_ALPHA || gport_size->size_alpha_max > ARAD_PLUS_MAX_ALPHA) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Illegal size_alpha_max value %d, must be in range %d..%d"),
                      gport_size->size_alpha_max, ARAD_PLUS_MIN_ALPHA, ARAD_PLUS_MAX_ALPHA));
                }
                data_rate_class.pg.queue_alpha_bds[index] = gport_size->size_alpha_max;
            }
        }
    }

    /* Settings Tail drop parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Note: This process might lead to a false confirm, when configuration is not exact
       and there are not enough profiles that are free. This can be resolved if all configurations
       are exact */

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_gport_vsq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq, 
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    uint32 relevant_flags, tail_drop_types_flags;    
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;    
    int tail_drop_count;   
    uint32 soc_sand_rc; 
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = 0;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    int vsq_index;
    uint8 is_ocb_only;
    int pool_id;
    bcm_dpp_cosq_vsq_rate_class_taildrop_info_t* taildrop;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    
    if (!BCM_COSQ_GPORT_IS_VSQ(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
    /* Validate params */
    if (SOC_IS_QAX(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC));
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        tail_drop_types_flags = (flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC));
    } else {
        tail_drop_types_flags = flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC;
    }
    tail_drop_count = _bcm_cosq_bit_count_get(tail_drop_types_flags);
    if (tail_drop_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid tail drop flags 0x%x - only one drop can be allocated, number resources specified %d"), unit, tail_drop_types_flags, tail_drop_count));
    }

    if (SOC_IS_QAX(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_PACKET_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    } else if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND);
    } else {
        relevant_flags = flags & (BCM_COSQ_GPORT_SIZE_BUFFER_DESC | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1);
    }

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && ((color < 0) || (color >= DPP_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    /* retrieve VSQ id */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    if (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1 && vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Only source port VSQs can be configured for pool 1, the type given is %d"), unit, vsq_group_type));
    }
    pool_id = (flags & BCM_COSQ_GPORT_SIZE_SRC_VSQ_POOL1) ? 1 : 0;

    /* The API should not take into account VSQ Global type, return error*/
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq group type %d"), unit, vsq_group_type));
    }
    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_DPP_UNIT_CHECK(unit);

    /* Get old rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    taildrop = bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(unit, soc_tmcvsq_type, pool_id, 0, &data_rate_class); 
    if (flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND) {
        color = 0;
    }

    if (SOC_IS_QAX(unit)) {
        if (flags & BCM_COSQ_GPORT_SIZE_SRAM) {
            if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                 gport_size->size_max = taildrop->max_size_th[SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][color];
            } else if (flags & BCM_COSQ_GPORT_SIZE_PACKET_DESC) {
                 gport_size->size_max = taildrop->max_size_th[SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS][color];
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
            }
        } else if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
             gport_size->size_max = taildrop->max_size_th[SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][color];
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));
        }
    } else {
        if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
            gport_size->size_max = taildrop->max_size[color];
        } else if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
            gport_size->size_max = taildrop->max_size_bds[color];
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n . Missing size flag"), unit, flags));
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_DROP_TH drop_info,exact_drop_info;
    uint32 relevant_flags, threshold_type_flags, soc_sand_rc;
    int threshold_count;
    int core_id = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(gport);
    BCM_DPP_UNIT_CHECK(unit);/* not really needed. just to aviod coverity defect */

    /* Validate threshold types */
    if (!(threshold->type == bcmCosqThresholdDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
          || threshold->type == bcmCosqThresholdFullDbuffs
          || threshold->type == bcmCosqThresholdMiniDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptors 
          || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdBytes)) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    /* bcmCosqThresholdBufferDescriptors is not a valid threshold type for Jericho and Jericho Plus - no reason to change this threshold */
    else if((threshold->type == bcmCosqThresholdBufferDescriptors) && (SOC_IS_JERICHO(unit)) && (SOC_IS_JERICHO_PLUS_AND_BELOW(unit)))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    /* The BCM_COSQ_THRESHOLD_OCB flag is used to configure One Way Bypass thresholds.
       This feature is supported only from aradplus */
    if(SOC_IS_ARAD_B1_AND_BELOW(unit)){
        if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, using flag BCM_COSQ_THRESHOLD_OCB is supported only for aradplus and above\n"), unit));
        }
    }

    /* Validate flags */
    relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | 
                                         BCM_COSQ_THRESHOLD_INGRESS | 
                                         BCM_COSQ_THRESHOLD_UNICAST |
                                         BCM_COSQ_THRESHOLD_MULTICAST | 
                                         BCM_COSQ_THRESHOLD_SET | 
                                         BCM_COSQ_THRESHOLD_CLEAR | 
                                         BCM_COSQ_THRESHOLD_DROP | 
                                         BCM_COSQ_THRESHOLD_OCB | 
                                         BCM_COSQ_THRESHOLD_POOL0 | 
                                         BCM_COSQ_THRESHOLD_POOL1);
    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    threshold_type_flags = (threshold->flags & 
                           (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR));

    threshold_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (threshold_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - only one flag between set, clear can be on"), unit, threshold->flags));
    }

    /* Validate param */
    if (threshold->dp < 0 || threshold->dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    SOC_TMC_ITM_GLOB_RCS_DROP_TH_clear(&drop_info);

    /* retrieve information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_drop_get,(unit, core_id, &drop_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (SOC_IS_QAX(unit)) {
        switch (threshold->type) {
            case bcmCosqThresholdBytes:
                if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
                    /* Set global Bytes for VSQ shared pool 0 */
                    DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_shrd_pool_0[SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][threshold->dp],threshold->flags,threshold->value);
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
                    /* Set global Bytes for VSQ shared pool 1 */
                    DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_shrd_pool_1[SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][threshold->dp],threshold->flags,threshold->value);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdBytes must come with flag BCM_COSQ_THRESHOLD_POOL0/1"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdDbuffs:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
                        /* Set global SRAM-Buffers for VSQ shared pool 0 */
                        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_shrd_pool_0[SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][threshold->dp],threshold->flags,threshold->value);
                    } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
                        /* Set global SRAM-Buffers for VSQ shared pool 1 */
                        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_shrd_pool_1[SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][threshold->dp],threshold->flags,threshold->value);
                    } else {
                        /* Set global free SRAM-Buffers */
                        /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram[1][threshold->dp],threshold->flags,threshold->value);
                        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram_only[1][threshold->dp],threshold->flags,threshold->value);
                    }
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdDbuffs must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdPacketDescriptors:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
                        /* Set global SRAM-PDs for VSQ shared pool 0 */
                        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_shrd_pool_0[SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS][threshold->dp],threshold->flags,threshold->value);
                    } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
                        /* Set global SRAM-PDs for VSQ shared pool 1 */
                        DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_shrd_pool_1[SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS][threshold->dp],threshold->flags,threshold->value);
                    } else {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptors must come with flag BCM_COSQ_THRESHOLD_POOL0/1"), unit, threshold->flags));
                    }
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptors must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdPacketDescriptorBuffers:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    /* Set global free SRAM-PDBs */
                    /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                    DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram[0][threshold->dp],threshold->flags,threshold->value);
                    DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_sram_only[0][threshold->dp],threshold->flags,threshold->value);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptorsBuffers must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdBundleDescriptorBuffers:
                /* Set global free DRAM-BDBs */
                DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.global_free_dram[threshold->dp],threshold->flags,threshold->value);
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }

    } else {
        /* Jericho2 TBD: delete all lines under 'else' - not relevant */
        if ((threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && threshold->type == bcmCosqThresholdDbuffs) {
            /* Set unicast dbuffs thresholds */
            if (SOC_IS_JERICHO(unit)) {
                /* GET OUT - in jericho all ocb dbuffs are MC */
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("unit %d, in Jericho all Dram data buffers are MC - setting threshold for unicast Dram data buffers is redundant"), unit));
            }

            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.unicast[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdFullDbuffs) {
            /* Set full multicast dbuffs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.full_mc[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdMiniDbuffs) {
            /* Set mini multicast dbuffs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.mini_mc[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Set bds thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.ocb_bds[threshold->dp],threshold->flags,threshold->value);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Set bds thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.bds[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Set bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.ocb_bdbs[threshold->dp],threshold->flags,threshold->value);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Set bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.bdbs[threshold->dp],threshold->flags,threshold->value);
        }

        if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->flags & BCM_COSQ_THRESHOLD_OCB && 
            threshold->type == bcmCosqThresholdBytes) {
            /* Set bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.ocb_mem_excess[threshold->dp],threshold->flags,threshold->value);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
                   !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
                   threshold->type == bcmCosqThresholdBytes) {
            /* Set bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_SET(unit,drop_info.mem_excess[threshold->dp],threshold->flags,threshold->value);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdDbuffs))
        {
            if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
            {
                if (SOC_IS_JERICHO(unit)) 
                {
                    /* GET OUT - in jericho all ocb dbuffs are MC */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("unit %d, in Jericho all OCB data buffers are MC - setting threshold for unicast OCB data buffers is redundant"), unit));
                }

                /* Set OCB unicast dbuffs thresholds */
                DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_uc[threshold->dp], threshold->flags, threshold->value);
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                /* Set OCB full multicast dbuffs thresholds */
                DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_mc[threshold->dp], threshold->flags, threshold->value);
            }
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0)) {
            DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_shrd_pool[0][threshold->dp], threshold->flags, threshold->value);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
            DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.mix_shrd_pool[0][threshold->dp], threshold->flags, threshold->value);
        }
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1)) {
            DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.ocb_shrd_pool[1][threshold->dp], threshold->flags, threshold->value);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
            DPP_COSQ_THRESHOLD_HYST_SET(unit, drop_info.mix_shrd_pool[1][threshold->dp], threshold->flags, threshold->value);
        }
    }

    /* Set information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_drop_set,(unit, core_id, &drop_info, &exact_drop_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_drop_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_DROP_TH drop_info;
    uint32 relevant_flags, threshold_type_flags, soc_sand_rc;
    int threshold_count;
    int core_id = BCM_CORE_ALL;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(gport);
    BCM_DPP_UNIT_CHECK(unit);/* not really needed. just to aviod coverity defect */

    /* Validate threshold types */
    if (!(threshold->type == bcmCosqThresholdDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
          || threshold->type == bcmCosqThresholdFullDbuffs
          || threshold->type == bcmCosqThresholdMiniDbuffs
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors
          || threshold->type == bcmCosqThresholdBytes)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    /* Validate flags */
    relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | 
                                         BCM_COSQ_THRESHOLD_INGRESS | 
                                         BCM_COSQ_THRESHOLD_UNICAST |
                                         BCM_COSQ_THRESHOLD_MULTICAST | 
                                         BCM_COSQ_THRESHOLD_SET | 
                                         BCM_COSQ_THRESHOLD_CLEAR | 
                                         BCM_COSQ_THRESHOLD_DROP | 
                                         BCM_COSQ_THRESHOLD_OCB |
                                         BCM_COSQ_THRESHOLD_POOL0 | 
                                         BCM_COSQ_THRESHOLD_POOL1);
    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    threshold_type_flags = (threshold->flags & 
                           (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR));

    threshold_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (threshold_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - only one flag between set, clear can be on"), unit, threshold->flags));
    }

    /* Validate param */
    if (threshold->dp < 0 || threshold->dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    SOC_TMC_ITM_GLOB_RCS_DROP_TH_clear(&drop_info);

    /* retrieve information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_drop_get,(unit, core_id, &drop_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
         
    if (SOC_IS_QAX(unit)) {
        switch (threshold->type) {
            case bcmCosqThresholdBytes:
                if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
                    /* Get global Bytes for VSQ shared pool 0 */
                    DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_shrd_pool_0[SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][threshold->dp]);
                } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
                    /* Get global Bytes for VSQ shared pool 1 */
                    DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_shrd_pool_1[SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES][threshold->dp]);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdBytes must come with flag BCM_COSQ_THRESHOLD_POOL0/1"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdDbuffs:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
                        /* Get global SRAM-Buffers for VSQ shared pool 0 */
                        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_shrd_pool_0[SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][threshold->dp]);
                    } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
                        /* Get global SRAM-Buffers for VSQ shared pool 1 */
                        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_shrd_pool_1[SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS][threshold->dp]);
                    } else {
                        /* Get global free SRAM-Buffers */
                        /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram[1][threshold->dp]);
                        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram_only[1][threshold->dp]);
                    }
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdDbuffs must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdPacketDescriptors:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
                        /* Get global SRAM-PDs for VSQ shared pool 0 */
                        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_shrd_pool_0[SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS][threshold->dp]);
                    } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
                        /* Get global SRAM-PDs for VSQ shared pool 1 */
                        DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_shrd_pool_1[SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS][threshold->dp]);
                    } else {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptors must come with flag BCM_COSQ_THRESHOLD_POOL0/1"), unit, threshold->flags));
                    }
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptors must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdPacketDescriptorBuffers:
                if (threshold->flags & BCM_COSQ_THRESHOLD_OCB) {
                    /* Get global free SRAM-PDBs */
                    /* Currently we set SRAM-Only thresholds and DRAM-mix thresholds the same */
                    DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram[0][threshold->dp]);
                    DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_sram_only[0][threshold->dp]);
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold flags 0x%x - type bcmCosqThresholdPacketDescriptorsBuffers must come with flag BCM_COSQ_THRESHOLD_OCB"), unit, threshold->flags));
                }
                break;
            case bcmCosqThresholdBundleDescriptorBuffers:
                DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.global_free_dram[threshold->dp]);
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }

    } else {
        /* Jericho2 TBD: delete all lines under 'else' - not relevant */
        if ((threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && threshold->type == bcmCosqThresholdDbuffs) {
            /* Get unicast dbuffs thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.unicast[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdFullDbuffs) {
            /* Get full multicast dbuffs thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.full_mc[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && threshold->type == bcmCosqThresholdMiniDbuffs) {
            /* Get mini multicast dbuffs thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.mini_mc[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Get bds thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.ocb_bds[threshold->dp]);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptors) {
            /* Get bds thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.bds[threshold->dp]);
        }
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) &&
            !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Get bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.ocb_bdbs[threshold->dp]);
        } else if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
                   !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
                   threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
            /* Get bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.bdbs[threshold->dp]);
        }
        if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) &&
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) &&
            threshold->flags & BCM_COSQ_THRESHOLD_OCB &&
            threshold->type == bcmCosqThresholdBytes){
            /* Get OCB bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.ocb_mem_excess[threshold->dp]);
        } else  if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
            !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && 
            threshold->type == bcmCosqThresholdBytes) {
            /* Get bdbs thresholds */
            DPP_COSQ_THRESHOLD_HYST_GET(unit,threshold->value,threshold->flags,drop_info.mem_excess[threshold->dp]);
        }

        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdDbuffs))
        {
            if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
            {
                if (SOC_IS_JERICHO(unit)) 
                {
                    /* GET OUT - in jericho all ocb dbuffs are MC */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("unit %d, in Jericho all OCB data buffers are MC - can't get threshold for unicast OCB data buffers"), unit));
                }

                /* Set OCB unicast dbuffs thresholds */
                DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_uc[threshold->dp]);
            } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
                /* Set OCB full multicast dbuffs thresholds */
                DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_mc[threshold->dp]);
            }
        }
        
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0)) {
            DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->value, threshold->flags, drop_info.ocb_shrd_pool[0][threshold->dp]);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) {
            DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->flags, threshold->value, drop_info.mix_shrd_pool[0][threshold->dp]);
        }
        if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1)) {
            DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->flags, threshold->value, drop_info.ocb_shrd_pool[1][threshold->dp]);
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) {
            DPP_COSQ_THRESHOLD_HYST_GET(unit, threshold->flags, threshold->value, drop_info.mix_shrd_pool[1][threshold->dp]);
        }
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* Verify params given to APIs configuring scheduled voq ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint8 is_set,
                                                    bcm_cosq_threshold_t *threshold)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    if (SOC_IS_QAX(unit) && (threshold->flags & BCM_COSQ_THRESHOLD_OCB)) { 
        /* 
           OCB eligibility doesn't exist is QAX.
           Return UNAVAIL when calling the following with the flag BCM_COSQ_THRESHOLD_OCB:
           bcm_cosq_gport_threshold_set(unit,voq_gport, cosq, threshold);
        */
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("BCM_COSQ_THRESHOLD_OCB flag is not supported")));
        
    }
    if (!(threshold->type == bcmCosqThresholdBytes
        || threshold->type == bcmCosqThresholdDbuffs)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS
        | BCM_COSQ_THRESHOLD_OCB | BCM_COSQ_THRESHOLD_UNICAST))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    if (is_set){
        if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) &&
            (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Both of the flags SET and CLEAR are set"), unit));
        }
    }
    if (!(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    /*verify vsq_category if it is specified directly*/
    if (threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC){
        if (threshold->tc < 0 || threshold->tc > DPP_DEVICE_COSQ_ING_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid tc parameter %d"), threshold->flags ));
        }
    } 
    /*verify tc if it is specified directly*/
    if (threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY){
        if (threshold->vsq_category < 0 || threshold->vsq_category >= DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid vsq_category parameter %d"), threshold->vsq_category));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
* Purpose: 
* Set scheduled voq ocb thresholds (per rate class)
*/
STATIC int
_bcm_petra_cosq_rate_class_ocb_threshold_set(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int rate_class;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls, exact_data_rate_cls;
    BCMDNX_INIT_FUNC_DEFS;
    if (!(BCM_GPORT_IS_PROFILE(gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API, gport %d"), unit, gport));
    }   
    rate_class = BCM_GPORT_PROFILE_GET(gport);
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    rc = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rc);
   
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    BCMDNX_NULL_CHECK(threshold);

    rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,TRUE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Old data get */
    rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    /*set relevant data int the rate class data*/
    rc = _bcm_petra_cosq_ocb_threshold_to_rate_class(unit, threshold, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    /*2. configure HW*/
    rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit,rate_class,&data_rate_cls,&exact_data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);        


    /* 
     * Note: No SW Update of ocb voq eligible 
     * This udate is done by passing a queue gport type with flags BCM_COSQ_THRESHOLD_IGNORE_VALUE, since we must know what qid should be configured                                                                                                                                                                             );
     * soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[threshold->tc][threshold->vsq_category].voq_eligible)));
     * BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
     */
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* ignore value only of a voq (per port)
*/
STATIC int
_bcm_petra_cosq_voq_ocb_threshold_ignore_value_set(int unit,
                                                   int qid,
                                                   int tc,
                                                   int vsq_category) 
{
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls;
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    int rate_class;
    int core = BCM_CORE_ALL;
    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("OCB eligiblity is not configured in Jericho.")));
    }
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    /*verify tc and vaq_category if they are specified directly*/
    if (tc < 0 || tc >= DPP_DEVICE_COSQ_ING_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid tc parameter %d"), tc));
    }
    if (vsq_category < 0 || vsq_category >= DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid vsq_category parameter %d"), vsq_category));
    }
    rc = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[tc][vsq_category].voq_eligible)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
* Purpose: 
* Set scheduled voq ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_voq_ocb_threshold_set(int unit,
                                      bcm_gport_t gport,
                                      bcm_cos_queue_t cosq,
                                      bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls, exact_data_rate_cls;
    int is_allocated, is_last;
    int new_rate_cls, old_rate_cls;
    int base_queue, qid;
    int tc, vsq_category;
    uint32 soc_sand_rc;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED) {
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));
    }

    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport); 
    } else /* BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) */
    {
        base_queue = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    }
    core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) VOQ gport(0x%08x) core out of range %d"), unit, gport, core));
    }
    /* Verify */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));
    if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
    }
    qid = base_queue + cosq;

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC)) {
        tc = threshold->tc;
    } else {
        tc = cosq;
        threshold->tc = tc;
    }

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY)) {
        vsq_category = threshold->vsq_category;
    } else 
    {
        /* get vsq category */
        rc = _bcm_petra_cosq_vsq_category_get(unit, core, qid, &vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
        threshold->vsq_category = vsq_category;
    }

    if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_ADVANCED) {
        rc = _bcm_petra_cosq_voq_ocb_threshold_ignore_value_set(unit, qid, tc, vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        /* SW Update */
        /* Old data get */
        rc = _bcm_dpp_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        /*if !queue_to_rate_class_mapping_is_simple only configure ocb_voq_eligible_dynamic_set ignoring threshold->value, else reconfigure the OCB using threshold->value*/
        rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,TRUE,threshold);
        BCMDNX_IF_ERR_EXIT(rc);


        /*set relevant data int the rate class data*/
        rc = _bcm_petra_cosq_ocb_threshold_to_rate_class(unit, threshold, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Update information in SW */
        rc = _bcm_dpp_am_template_queue_rate_cls_exchange(unit,core,qid,&data_rate_cls,&old_rate_cls,&is_last,&new_rate_cls,&is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Commit Changes in HW according to given thresholds */
        if (is_allocated) {
            rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit,new_rate_cls,&data_rate_cls,&exact_data_rate_cls);
            BCMDNX_IF_ERR_EXIT(rc);        
        }
        /* Set new mapping */
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,qid,BCM_DPP_COSQ_RATE_CLS,new_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);

        if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_ocb_voq_eligible_dynamic_set,(unit, qid, data_rate_cls.ocb_info[tc][vsq_category].voq_eligible)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* Get scheduled voq rate class ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_rate_class_ocb_threshold_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int rate_class;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls;
    int tc;
    int vsq_category;
    int index;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    if (!(BCM_GPORT_IS_PROFILE(gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API, gport %d"), unit, gport));
    }   
    rate_class = BCM_GPORT_PROFILE_GET(gport);
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
    rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,FALSE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    /* data get */
    rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit,rate_class,&data_rate_cls);
    BCMDNX_IF_ERR_EXIT(rc);

    tc = threshold->tc;
    vsq_category = threshold->vsq_category;

    if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1)
    {
        index = 1;
    }
    else
    {
        index = 0;
    }
    switch(threshold->type) {
        case bcmCosqThresholdBytes:
                threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_words[index];
            break;     
        case bcmCosqThresholdDbuffs:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_buffers[index];
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if(data_rate_cls.ocb_info[tc][vsq_category].voq_eligible == TRUE)
    {
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_CLEAR);
        threshold->flags |= BCM_COSQ_THRESHOLD_SET;
    } else {
        threshold->flags |= BCM_COSQ_THRESHOLD_CLEAR;
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_SET);
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/*
* Purpose: 
* Get scheduled voq ocb thresholds (per port)
*/
STATIC int
_bcm_petra_cosq_voq_ocb_threshold_get(int unit,
                                      bcm_gport_t gport,
                                      bcm_cos_queue_t cosq,
                                      bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_cls;
    int base_queue, qid;
    int tc;
    int vsq_category;
    int rate_class;
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int core = BCM_CORE_ALL;
    uint32 is_voq_eligible = 0;
    int index;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    sal_memset(&data_rate_cls,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));

    /* Verify */
    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    rc =_bcm_petra_cosq_voq_rate_class_ocb_threshold_verify(unit,gport,cosq,FALSE,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport); 
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else /* BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) */
    {
        base_queue = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
        core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport);
    }
    qid = base_queue + cosq;

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_TC)) {
        tc = threshold->tc;
    } else 
    {
        tc = cosq;
    }

    if ((threshold->valid & BCM_COSQ_THRESHOLD_VALID_VSQ_CATEGORY)) {
        vsq_category = threshold->vsq_category;
    } else 
    {
        /* get vsq category */
        rc = _bcm_petra_cosq_vsq_category_get(unit, core, qid, &vsq_category);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (queue_to_rate_class_mapping_is_simple != ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
        rc = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        /* data get */
        rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    } else 
    {
        /* data get */
        rc = _bcm_dpp_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_cls);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1)
    {
        index = 1;
    }
    else
    {
        index = 0;
    }
    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_words[index];
            break;     
        case bcmCosqThresholdDbuffs:
            threshold->value = data_rate_cls.ocb_info[tc][vsq_category].th_buffers[index];
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if (SOC_IS_JERICHO(unit)) {
        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_voq_is_ocb_eligible_get,(unit, core, qid, &is_voq_eligible));
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        is_voq_eligible = data_rate_cls.ocb_info[tc][vsq_category].voq_eligible;
    }

    if (is_voq_eligible) {
        threshold->flags |= BCM_COSQ_THRESHOLD_SET;
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_CLEAR);
    } else {
        threshold->flags |= BCM_COSQ_THRESHOLD_CLEAR;
        threshold->flags &= ~(BCM_COSQ_THRESHOLD_SET);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * VSQ rate class exchange set commit includes allocation management and HW.
 */
STATIC int
_bcm_petra_cosq_vsq_rate_class_exchange_set(int unit,
                                            int core_id,
                                            SOC_TMC_ITM_VSQ_NDX vsq_id,
                                            bcm_dpp_cosq_vsq_rate_class_info_t *data_rate_class)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    bcm_dpp_cosq_vsq_rate_class_info_t *exact_data_rate_class = NULL, cleared_data_rate;
    int new_rate_class,is_allocated,old_rate_class,is_last;   
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type = SOC_TMC_ITM_VSQ_GROUP_LAST_ARAD;    
    uint32 vsq_index = 0;
    uint8 is_ocb_only;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_ALLOC(exact_data_rate_class, sizeof(*exact_data_rate_class), "_bcm_petra_cosq_vsq_rate_class_exchange_set.exact_data_rate_class");
    if (exact_data_rate_class == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }
    sal_memset(exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
    sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));    

    /* Convert global2group */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_index_global2group,(unit, vsq_id, &soc_tmcvsq_type, &vsq_index, &is_ocb_only)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_DPP_UNIT_CHECK(unit);

    /* Update information in SW */
    rc = _bcm_dpp_am_template_vsq_rate_cls_exchange(unit, core_id, vsq_id, data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Commit Changes in HW according to given thresholds */
    if (is_allocated) {
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit, new_rate_class, soc_tmcvsq_type, data_rate_class, exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);        
    } else {
        sal_memcpy(exact_data_rate_class, data_rate_class, sizeof(*exact_data_rate_class));
    }

    /* Set new mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_qt_rt_cls_set,(unit, core_id, is_ocb_only, soc_tmcvsq_type, vsq_index, new_rate_class)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* last profile data */
    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit, old_rate_class, soc_tmcvsq_type, &cleared_data_rate, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

    /* Step 2: Allocate according to exact */
    /* Update information in SW according to exact thresholds */
    /* We have enough profiles here since or data was not exact and we allocated already new profile */
    /* or data was exact thus info is same */
    rc = _bcm_dpp_am_template_vsq_rate_cls_exchange(unit, core_id, vsq_id, exact_data_rate_class, &old_rate_class,&is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit, new_rate_class, soc_tmcvsq_type, exact_data_rate_class,&cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);        
    }
    
    /* Set new mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_qt_rt_cls_set,(unit, core_id, is_ocb_only, soc_tmcvsq_type, vsq_index, new_rate_class)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* last profile data */
    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&cleared_data_rate,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit, old_rate_class, soc_tmcvsq_type, &cleared_data_rate, &cleared_data_rate);
        BCMDNX_IF_ERR_EXIT(rc);    
    }    

    BCM_EXIT;
exit:
    BCM_FREE(exact_data_rate_class);
    BCMDNX_FUNC_RETURN;
}


/*
 * Convert Flow Control flags to resource type FC threshold
 */
STATIC int
_bcm_petra_cosq_flags_to_fc_threshold(
    int unit,
    uint32 flags,
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E *fc_threshold)
{
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E threshold_type = SOC_TMC_INGRESS_THRESHOLD_INVALID;
    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        switch (flags) {
            case BCM_COSQ_PFC_BYTES:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES;
                break;
            case BCM_COSQ_PFC_OCB | BCM_COSQ_PFC_BUFFERS:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS;
                break;
            case BCM_COSQ_PFC_OCB | BCM_COSQ_PFC_PACKET_DESC:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG
                   ("flags of bcm_cosq_pfc_config_set should be %s or (%s | %s) or (%s | %s) on this device."),
                     "BCM_COSQ_PFC_BYTES", "BCM_COSQ_PFC_OCB", "BCM_COSQ_PFC_BUFFERS",
                     "BCM_COSQ_PFC_OCB", "BCM_COSQ_PFC_PACKET_DESC"));
        }
    }

    *fc_threshold = threshold_type;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_fc_threshold_set(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq, 
                                     uint32 flags,
                                     bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    SOC_TMC_ITM_VSQ_FC_INFO fc_info,exact_fc_info;
    uint32 threshold_type_flags, soc_sand_rc;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0; 
    int flag_count;   
    uint8 is_ocb_only = FALSE;
    bcm_dpp_cosq_vsq_rate_class_fc_info_t* fc;
    int pool_id = 0, nof_pools = 0;
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type = SOC_TMC_INGRESS_THRESHOLD_INVALID;
    uint32 fc_byte_size_max = SOC_DPP_DEFS_GET(unit, itm_glob_rcs_fc_p0_byte_size_max);
    uint32 fc_buffer_size_max = SOC_DPP_DEFS_GET(unit, itm_glob_rcs_fc_p0_size_max);
    uint32 fc_pd_size_max = SOC_DPP_DEFS_GET(unit, itm_glob_rcs_fc_p0_pd_size_max);

    int use_fadt_params = 0;

    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_ITM_VSQ_FC_INFO_clear(&fc_info);
    SOC_TMC_ITM_VSQ_FC_INFO_clear(&exact_fc_info);

    if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
        use_fadt_params = flags & BCM_COSQ_PFC_USE_FADT_PARAMS;
    }

    if (SOC_IS_QAX(unit)) {
        rc = _bcm_petra_cosq_flags_to_fc_threshold(unit, flags, &rsrc_type);
        BCMDNX_IF_ERR_EXIT(rc);

        if ((rsrc_type == SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES)
            && ((pfc_threshold->xon_threshold > fc_byte_size_max)
                || (pfc_threshold->xoff_threshold > fc_byte_size_max))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                (_BSL_BCM_MSG("unit %d, SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES xon_threshold %d  and xoff_threshold %d must not larger than %d"),
                unit, pfc_threshold->xon_threshold, pfc_threshold->xoff_threshold, fc_byte_size_max));
        }

        if ((rsrc_type == SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS)
            && ((pfc_threshold->xon_threshold > fc_buffer_size_max)
                || (pfc_threshold->xoff_threshold > fc_buffer_size_max))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                (_BSL_BCM_MSG("unit %d, SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS xon_threshold %d  and xoff_threshold %d must not larger than %d"),
                unit, pfc_threshold->xon_threshold, pfc_threshold->xoff_threshold, fc_buffer_size_max));
        }

        if ((rsrc_type == SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS)
            && ((pfc_threshold->xon_threshold > fc_pd_size_max)
                || (pfc_threshold->xoff_threshold > fc_pd_size_max))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                (_BSL_BCM_MSG("unit %d, SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS xon_threshold %d  and xoff_threshold %d must not larger than %d"),
                unit, pfc_threshold->xon_threshold, pfc_threshold->xoff_threshold, fc_pd_size_max));
        }

        if ((pfc_threshold->xon_threshold_bd != 0) || (pfc_threshold->xoff_threshold_bd != 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, xon_threshold_bd %d and xoff_threshold_bd %d can be only 0"), unit,
                pfc_threshold->xon_threshold_bd, pfc_threshold->xoff_threshold_bd));
        }
    } else {
        /* basic consistency checks */
        threshold_type_flags = (flags & (BCM_COSQ_PFC_BYTES | BCM_COSQ_PFC_OCB | BCM_COSQ_PFC_PACKET_DESC | BCM_COSQ_PFC_BUFFERS));
        flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
        if (flag_count != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - none of threshold type flags should be set"), unit, threshold_type_flags));
        }

        /* Validate params */
        if (SOC_IS_JERICHO(unit)) {
            if ((pfc_threshold->xon_threshold != 0) || (pfc_threshold->xoff_threshold != 0)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, xon_threshold %d  and xoff_threshold %d can be only 0"), unit,
                    pfc_threshold->xon_threshold, pfc_threshold->xoff_threshold));
            }
            if ((pfc_threshold->xon_threshold_bd > SOC_TMC_ITM_VSQ_FC_BD_SIZE_MAX)
                || (pfc_threshold->xoff_threshold_bd > SOC_TMC_ITM_VSQ_FC_BD_SIZE_MAX)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, xon_threshold_bd %d  and xoff_threshold_bd %d must not larger than %d"),
                    unit, pfc_threshold->xon_threshold_bd, pfc_threshold->xoff_threshold_bd, SOC_TMC_ITM_VSQ_FC_BD_SIZE_MAX));
            }
        }
    }

    /* Convert to VSQ type & VSQ ID */
    /* retrieve vsq index */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x"), unit, gport, rc));
    }

     /* QAX support four CTCCs, but only CT2CC and CT3CC can be used for flow control */
     if(SOC_IS_QAX(unit) && (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTCC)){
        vsq_index = (BCM_COSQ_GPORT_VSQ_CT_GET(gport) * DPP_COSQ_VSQ_NOF_CONNECTION_CLASS)
                     + BCM_COSQ_GPORT_VSQ_CC_GET(gport);
     }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    /* Get Rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    if (soc_tmcvsq_type == SOC_TMC_ITM_VSQ_GROUP_SRC_PORT) {
        /* VSQ-E need to run on all pools */
        nof_pools = SOC_TMC_ITM_NOF_RSRC_POOLS;
    } else {
        /* pool_id is relevant only for VSQ-E */
        nof_pools = 1;
    }

    for (pool_id = 0; pool_id < nof_pools; ++pool_id) {
        fc = bcm_dpp_cosq_vsq_rate_class_fc_data_get(unit, soc_tmcvsq_type, pool_id, &data_rate_class);

        if (SOC_IS_QAX(unit)) {
            if (soc_tmcvsq_type == SOC_TMC_ITM_VSQ_GROUP_PG) {
                /* FC thresholds for VSQ-F */
                fc->fadt_size[rsrc_type].set.max_threshold = pfc_threshold->xoff_fadt_threshold.thresh_max;
                fc->fadt_size[rsrc_type].set.min_threshold = pfc_threshold->xoff_fadt_threshold.thresh_min;
                fc->fadt_size[rsrc_type].set.alpha = pfc_threshold->xoff_fadt_threshold.alpha;
                fc->fadt_size[rsrc_type].clear_offset = pfc_threshold->xon_fadt_offset;
            } else {
                /* FC thresholds for VSQs A-E */
                fc->size[rsrc_type].set = pfc_threshold->xoff_threshold;
                fc->size[rsrc_type].clear = pfc_threshold->xon_threshold;
            }
        } else {
            /* Set unicast dbuffs thresholds */
            fc->queue_size.set = pfc_threshold->xoff_threshold;
            fc->queue_size.clear = pfc_threshold->xon_threshold;

            /* Set bdbs thresholds */
            fc->bd_size.set = pfc_threshold->xoff_threshold_bd;
            fc->bd_size.clear = pfc_threshold->xon_threshold_bd;

            /** set FADT params - jericho only */
            if (use_fadt_params && soc_tmcvsq_type == SOC_TMC_ITM_VSQ_GROUP_PG)
            {
                data_rate_class.pg.prm.fadt_fc.sign = (pfc_threshold->xoff_fadt_threshold.alpha >= 0); /** 1 for shift left - positive power */
                data_rate_class.pg.prm.fadt_fc.exp = (pfc_threshold->xoff_fadt_threshold.alpha >= 0 ? 
                                                    pfc_threshold->xoff_fadt_threshold.alpha : 
                                                    -pfc_threshold->xoff_fadt_threshold.alpha);
                data_rate_class.pg.prm.fadt_fc.offset = pfc_threshold->xon_fadt_offset;
                data_rate_class.pg.prm.fadt_fc.floor = pfc_threshold->xon_fadt_floor;
            }
        }
    }

    /* Find new profile according to given settings and commit changes */
    rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_fc_threshold_get(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq, 
                                     uint32 flags,
                                     bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;    
    int core_id = BCM_CORE_ALL;
    uint32 threshold_type_flags, soc_sand_rc;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    uint8 is_ocb_only;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;     
    int flag_count;       
    bcm_dpp_cosq_vsq_rate_class_fc_info_t* fc;
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type = SOC_TMC_INGRESS_THRESHOLD_INVALID;

    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        rc = _bcm_petra_cosq_flags_to_fc_threshold(unit, flags, &rsrc_type);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        /* basic consistency checks */
        threshold_type_flags = (flags);

        flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
        if (flag_count != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - none flags should be set"), unit, threshold_type_flags));
        }
    }

    /* Validate params */
    /* Convert to VSQ type & VSQ ID */
    /* retrieve vsq index */
    rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, gport, cosq, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x"), unit, gport, rc));
    }

    /* QAX support four CTCCs, but only CT2CC and CT3CC can be used for flow control */
    if(SOC_IS_QAX(unit) && (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTCC)){
        vsq_index = (BCM_COSQ_GPORT_VSQ_CT_GET(gport) * DPP_COSQ_VSQ_NOF_CONNECTION_CLASS)
                      + BCM_COSQ_GPORT_VSQ_CC_GET(gport);
    }

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, vsq_index, is_ocb_only, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    /* Get Rate class data */
    rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
    fc = bcm_dpp_cosq_vsq_rate_class_fc_data_get(unit, soc_tmcvsq_type, 0, &data_rate_class);
         
    if (SOC_IS_QAX(unit)) {
        if (soc_tmcvsq_type == SOC_TMC_ITM_VSQ_GROUP_PG) {
            /* FC thresholds for VSQ-F */
            pfc_threshold->xoff_fadt_threshold.thresh_max = fc->fadt_size[rsrc_type].set.max_threshold;
            pfc_threshold->xoff_fadt_threshold.thresh_min = fc->fadt_size[rsrc_type].set.min_threshold;
            pfc_threshold->xoff_fadt_threshold.alpha = fc->fadt_size[rsrc_type].set.alpha;
            pfc_threshold->xon_fadt_offset = fc->fadt_size[rsrc_type].clear_offset;
        } else {
            /* FC thresholds for VSQs A-E */
            pfc_threshold->xoff_threshold = fc->size[rsrc_type].set;
            pfc_threshold->xon_threshold = fc->size[rsrc_type].clear;
        }
    } else {
        /* Get unicast dbuffs thresholds */
        pfc_threshold->xoff_threshold = fc->queue_size.set;
        pfc_threshold->xon_threshold =  fc->queue_size.clear;

        /* Get bds thresholds */
        pfc_threshold->xoff_threshold_bd = fc->bd_size.set;
        pfc_threshold->xon_threshold_bd =  fc->bd_size.clear;

        if (soc_tmcvsq_type == SOC_TMC_ITM_VSQ_GROUP_PG) {
            pfc_threshold->xoff_fadt_threshold.alpha = (data_rate_class.pg.prm.fadt_fc.sign ? /** 1 for shift left - positive power */
                                                        data_rate_class.pg.prm.fadt_fc.exp : 
                                                        -data_rate_class.pg.prm.fadt_fc.exp);
            pfc_threshold->xon_fadt_offset = data_rate_class.pg.prm.fadt_fc.offset;
            pfc_threshold->xon_fadt_floor = data_rate_class.pg.prm.fadt_fc.floor;
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_fc_thresh_set(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq,
                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_FC_TH fc_info, exact_fc_info;
    uint32 relevant_flags, soc_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    if(SOC_IS_ARADPLUS_AND_BELOW(unit)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, function is supported only for jericho\n"), unit));
    }

    /* Validate threshold types */
    if(SOC_IS_QAX(unit)) {
        /* Validate each threshold types */
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdPacketDescriptors
            || threshold->type == bcmCosqThresholdPacketDescriptorBuffers
            || threshold->type == bcmCosqThresholdBytes)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    } else {
        /* Validate each threshold types */
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdFullDbuffs
            || threshold->type == bcmCosqThresholdMiniDbuffs 
            || threshold->type == bcmCosqThresholdBufferDescriptors )) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    }

    /* Validate threshold flags */
    if(SOC_IS_QAX(unit)) {
        /* Validate each threshold flags */
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_HEADROOM | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    } else {
        /* Validate each threshold flags */
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_MULTICAST | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    }

    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    /* Validate threshold param */
    if (threshold->priority != BCM_COSQ_HIGH_PRIORITY && threshold->priority != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }

    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);

    /* Retreive information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_get,(unit, &fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        /* Set bdbs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdMiniDbuffs) {
        /* Set mini multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.mini_mc, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdFullDbuffs) {
        /* Set full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
        (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set OCB dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdPacketDescriptorBuffers)) {
        /* Set OCB pdbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb_pdb, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set OCB pool 0 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb_p0, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set OCB pool 1 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.ocb_p1, threshold->priority, threshold->flags, threshold->value);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set MIX pool 0 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.mix_p0, threshold->priority, threshold->flags, threshold->value);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Set MIX pool 1 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.mix_p1, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 0 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p0, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 0 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p1, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 0 packet descriptors thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p0_pd, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 1 packet descriptors thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p1_pd, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 0 bytes thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p0_byte, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 1 bytes thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.p1_byte, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->type & bcmCosqThresholdDbuffs)) { 
        /* Set sram headroom dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.hdrm, threshold->priority, threshold->flags, threshold->value);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->type & bcmCosqThresholdPacketDescriptors)) { 
        /* Set sram headroom packet descritpors thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.hdrm_pd, threshold->priority, threshold->flags, threshold->value);
    }

    /* Set information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_set,(unit, &fc_info, &exact_fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_fc_thresh_get(int unit,
                                     bcm_gport_t gport,
                                     bcm_cos_queue_t cosq,
                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_FC_TH fc_info;
    uint32 relevant_flags, soc_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);

    if(SOC_IS_ARADPLUS_AND_BELOW(unit)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, function is supported only for jericho\n"), unit));
    }

    /* Validate threshold types */
    if(SOC_IS_QAX(unit)) {
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdPacketDescriptors
            || threshold->type == bcmCosqThresholdPacketDescriptorBuffers
            || threshold->type == bcmCosqThresholdBytes)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    } else {
        if (!(threshold->type == bcmCosqThresholdDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptorBuffers
            || threshold->type == bcmCosqThresholdFullDbuffs
            || threshold->type == bcmCosqThresholdMiniDbuffs
            || threshold->type == bcmCosqThresholdBufferDescriptors)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }
    }

    /* Validate flags */
    if(SOC_IS_QAX(unit)) {
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_HEADROOM | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    } else {
        relevant_flags = threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL|
                                             BCM_COSQ_THRESHOLD_MULTICAST | 
                                             BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR | 
                                             BCM_COSQ_THRESHOLD_OCB |
                                             BCM_COSQ_THRESHOLD_POOL0 | BCM_COSQ_THRESHOLD_POOL1);
    }

    if (threshold->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_INGRESS | BCM_COSQ_THRESHOLD_FLOW_CONTROL))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) && (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_SET and BCM_COSQ_THRESHOLD_CLEAR cannot be used together\n"), 
            unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    /* Validate threshold param */
    if (threshold->priority != BCM_COSQ_HIGH_PRIORITY && threshold->priority != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }

    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);

    /* Retreive information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_get,(unit, &fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST)
        && threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        /* Get bdbs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.bdbs);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdMiniDbuffs) {
        /* Get mini multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.mini_mc);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) && 
        threshold->type == bcmCosqThresholdFullDbuffs) {
        /* Get full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.full_mc);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && 
        (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Get OCB dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->type == bcmCosqThresholdPacketDescriptorBuffers)) {
        /* Set OCB pdbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb_pdb);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get OCB pool 0 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb_p0);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get OCB pool 1 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.ocb_p1);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get MIX pool 0 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.mix_p0);
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_OCB) && (threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && 
        (threshold->type == bcmCosqThresholdBufferDescriptors)) { 
        /* Get MIX pool 1 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.mix_p1);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 0 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p0);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdDbuffs)) { 
        /* Set pool 1 dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p1);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 0 packet descriptors thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p0_pd);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdPacketDescriptors)) { 
        /* Set pool 1 packet descriptors thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p1_pd);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL0) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 0 bytes thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p0_byte);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_POOL1) && (threshold->type == bcmCosqThresholdBytes)) { 
        /* Set pool 1 bytes thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.p1_byte);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->type & bcmCosqThresholdDbuffs)) { 
        /* Set sram headroom dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.hdrm);
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_HEADROOM) && (threshold->type & bcmCosqThresholdPacketDescriptors)) { 
        /* Set sram headroom packet descritpors thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit, threshold->value, threshold->priority, threshold->flags, fc_info.hdrm_pd);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_FC_TH fc_info,exact_fc_info;
    uint32 relevant_flags, threshold_type_flags, soc_sand_rc;
    int flag_count;       

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);
    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&exact_fc_info);

    /* Validate flags */
    relevant_flags = flags & (BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* basic consistency checks */
    threshold_type_flags = (flags & 
                           (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_MULTICAST));

    flag_count = _bcm_cosq_bit_count_get(threshold_type_flags);
    if (flag_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag can be set"), unit, threshold_type_flags));
    }

    /* Validate params */
    if (cosq != BCM_COSQ_HIGH_PRIORITY && cosq != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }
        
    /* retrieve information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_get,(unit,&fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
         
    if ((flags & BCM_COSQ_THRESHOLD_UNICAST)) {
        /* Set unicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.unicast,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold );
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.unicast,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold );
    }

    if ((flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        /* Set full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold );
        DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.full_mc,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold );
    }

    /* Set bdbs thresholds */
    DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs,cosq,BCM_COSQ_THRESHOLD_SET,pfc_threshold->xoff_threshold_bd);
    DPP_COSQ_THRESHOLD_FC_HYST_SET(unit,fc_info.bdbs,cosq,BCM_COSQ_THRESHOLD_CLEAR,pfc_threshold->xon_threshold_bd);

    /* Set information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_set,(unit,&fc_info,&exact_fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_vsq_gl_fc_threshold_get(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_queue_t cosq,
                                           uint32 flags,
                                           bcm_cosq_pfc_config_t *pfc_threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_GLOB_RCS_FC_TH fc_info;
    uint32 relevant_flags, soc_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(pfc_threshold);

    /* Validate flags */
    relevant_flags = flags & (BCM_COSQ_THRESHOLD_UNICAST |
                              BCM_COSQ_THRESHOLD_MULTICAST);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* Validate params */
    if (cosq != BCM_COSQ_HIGH_PRIORITY && cosq != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d, can be either BCM_COSQ_HIGH_PRIORITY, BCM_COSQ_LOW_PRIORITY"), unit,cosq));
    }
        
    SOC_TMC_ITM_GLOB_RCS_FC_TH_clear(&fc_info);

    /* retrieve information */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_glob_rcs_fc_get,(unit,&fc_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
         
    if ((flags & BCM_COSQ_THRESHOLD_UNICAST)) {
        /* Get unicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.unicast);
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.unicast);
    }

    if ((flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        /* Get full multicast dbuffs thresholds */
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.full_mc);
        DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.full_mc);
    }

    /* Get bdbs thresholds */
    DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xoff_threshold_bd,cosq,BCM_COSQ_THRESHOLD_SET,fc_info.bdbs);
    DPP_COSQ_THRESHOLD_FC_HYST_GET(unit,pfc_threshold->xon_threshold_bd,cosq,BCM_COSQ_THRESHOLD_CLEAR,fc_info.bdbs);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int bcm_petra_cosq_gport_vsq_create(
    int unit, 
    bcm_cosq_vsq_info_t *vsq_info, 
    bcm_gport_t *vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;    


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(vsq_info);
    BCMDNX_NULL_CHECK(vsq_gport);

    /* basic consistency checks */
    if (SOC_IS_JERICHO(unit) && (vsq_info->flags == BCM_COSQ_VSQ_LLFC || vsq_info->flags == BCM_COSQ_VSQ_PFC)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq flags 0x%x for VSQ types BCM_COSQ_VSQ_LLFC and BCM_COSQ_VSQ_PFC are not supported in Jericho"), unit, vsq_info->flags));
    }
    if (vsq_info->flags > BCM_COSQ_VSQ_PFC) {
        /* No information required */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid vsq flags 0x%x"), unit, vsq_info->flags));
    }
    if (vsq_info->flags == BCM_COSQ_VSQ_PP || vsq_info->flags == BCM_COSQ_VSQ_LLFC || vsq_info->flags == BCM_COSQ_VSQ_PFC) {
        if (!SOC_IS_QAX(unit)) {
            /* PDM extended mode is mandatory for ST-VSQ, LLFC-VSQ, PFC-VSQ */
            if (SOC_DPP_CONFIG(unit)->arad->init.dram.pdm_mode != ARAD_INIT_PDM_MODE_REDUCED) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, 
                                    (_BSL_BCM_MSG("PDM extended mode must be set in order to use ST-VSQ, LLFC-VSQ, PFC-VSQ.\n")));
            }
        }
    }
    if (vsq_info->flags == BCM_COSQ_VSQ_PP) {
        if (vsq_info->pp_vsq_id > SOC_DPP_CONFIG(unit)->pdm_extension.max_st_vsq) {
            LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit,
                    "ST-VSQ ID %d is higher than the maximum ST-VSQ ID %d in the PDM extension.\n"), vsq_info->pp_vsq_id, SOC_DPP_CONFIG(unit)->pdm_extension.max_st_vsq));
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
        }
    }

    /* Validate VSQ Info */
    rc = _bcm_petra_cosq_vsq_info_verify(unit, vsq_info);
    BCMDNX_IF_ERR_EXIT(rc);
        
    /* retrieve VSQ group */
    rc = _bcm_petra_cosq_gport_vsq_get_group_type(unit, vsq_info, &vsq_group_type);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Set VSQ gport */
    rc = _bcm_petra_cosq_gport_vsq_gport_set(unit, vsq_info, vsq_group_type, vsq_gport);
    BCMDNX_IF_ERR_EXIT(rc);  
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_src_vsqs_gport_add(
    int unit, 
    bcm_gport_t port, 
    bcm_cosq_src_vsqs_gport_config_t *config, 
    bcm_gport_t *src_port_vsq_gport, 
    bcm_gport_t *pg_base_vsq_gport)
{
    int pg_base = 0, src_port = 0;
    uint32 src_pp_port = 0;
    int core_id, core_index, pg_core_id;
    int src_port_vsq_index, src_port_vsq_core_id;
    int cosq = 0;
    uint32 tc_mapping = 0, found_tc_mapping[BCM_COSQ_VSQ_NOF_PG];
    uint32 pg_tc_bitmap = 0, default_pg_tc_bitmap = 0;
    bcm_error_t rc = BCM_E_NONE;
    int default_pg_tc_profile = 0, is_last = 0, new_pg_tc_profile = 0, is_allocated = 0;

    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG] = {0};

    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    SOC_TMC_ITM_VSQ_NDX vsq_id;
    SOC_TMC_ITM_VSQ_PG_PRM pg_prm;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    uint8 allocate = TRUE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(src_port_vsq_gport);
    BCMDNX_NULL_CHECK(pg_base_vsq_gport);
    BCMDNX_NULL_CHECK(config);

    if (!SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("API bcm_petra_cosq_src_vsqs_gport_add() is not supported for this device type.")));
    }

    if (!SOC_IS_QAX(unit)) {
        /* Jericho2 TBD: remove this - not relevant anymore */
        if (SOC_DPP_CONFIG(unit)->arad->init.dram.pdm_mode != ARAD_INIT_PDM_MODE_REDUCED) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, 
                                (_BSL_BCM_MSG("PDM extended mode must be set in order to use SRC-VSQs.\n")));
        }
    }

    if (config->numq <= 0 || config->numq > BCM_COSQ_VSQ_NOF_PG) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                            (_BSL_BCM_MSG("The numq %d value is out of range, valid range is 1-%d."), config->numq, BCM_COSQ_VSQ_NOF_PG));
    }

    if (!SOC_IS_QAX(unit)) {
        /* Jericho2 TBD: remove this - not relevant anymore */
        for (cosq = 0; cosq < config->numq; cosq++) {
            if (config->pg_attributes[cosq].ocb_only > 1) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                        "Invalid OCB Only value %d, PG offset %d.\n"), config->pg_attributes[cosq].ocb_only, cosq));

                SOCDNX_IF_ERR_EXIT(SOC_E_PARAM);
            }
        }
    }

    if (BCM_GPORT_IS_LOCAL(port)) {
        src_port = BCM_GPORT_LOCAL_GET(port);
    } else if (SOC_PORT_VALID(unit, port)) {
        src_port = port;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, 
                            (_BSL_BCM_MSG("Invalid port type %d."), port));
    }
    sal_memset(found_tc_mapping, 0xffffffff, sizeof(uint32[BCM_COSQ_VSQ_NOF_PG]));
    for (cosq = 0; cosq < config->numq; cosq++) {
        for (tc_mapping = 0; tc_mapping < SOC_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++) {
            if (config->pg_attributes[cosq].cosq_bitmap & (0x1 << tc_mapping)) {
                if (found_tc_mapping[tc_mapping] != 0xffffffff) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "Invalid cosq bitmap configuration. TC %d, Cannot be mapped to %d, and to %d.\n"), tc_mapping, found_tc_mapping[tc_mapping], cosq));
                    BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);

                }
                found_tc_mapping[tc_mapping] = cosq;
            }
        }
    }
    for (tc_mapping = 0; tc_mapping < SOC_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++) {
        if (found_tc_mapping[tc_mapping] == 0xffffffff) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "Invalid cosq bitmap configuration. TC %d is not mapped.\n"), tc_mapping));
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
        }
    }
    for (cosq = 0; cosq < config->numq; cosq++) {
        if (config->pg_attributes[cosq].pool_id != 0 && config->pg_attributes[cosq].pool_id != 1) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "Invalid pool ID, PG offset %d, pool ID %d.\n"), cosq, config->pg_attributes[cosq].pool_id));
            BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
        }
    }
    /*Get the relavent core ID from the src_port*/
    rc = soc_port_sw_db_local_to_pp_port_get(unit, src_port, &src_pp_port, &core_id);
    BCMDNX_IF_ERR_EXIT(rc);
   
    if (src_pp_port > SOC_DPP_CONFIG(unit)->pdm_extension.max_pp_port) {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit,
                "Source PP-port %d is higher than the maximum PP-Port %d in the PDM extension.\n"), src_pp_port, SOC_DPP_CONFIG(unit)->pdm_extension.max_pp_port));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
    
    if (SOC_IS_QAX(unit)) {
        /* 
         * No need to use alloc manager or WITH_ID flag, since VSQ-E/F gports
         * are mapped 1-1 to phy_port/phy_lane respectively.
         */
        uint32 phy_port = 0;
        uint32 phy_lane = 0;

        /* VSQ-E index is mapped 1-1 to NIF port */
        rc = soc_port_sw_db_first_phy_port_get(unit, src_port, &phy_port);
        BCMDNX_IF_ERR_EXIT(rc);
        src_port_vsq_index = phy_port - 1; /* phy_port is one based */
        BCM_COSQ_GPORT_VSQ_SRC_PORT_SET(*src_port_vsq_gport, core_id, 0, src_port_vsq_index);

        /* PG-VSQ base is mapped 1-1 to serdes (multiplied by nof PGs) */
        SOCDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_qsgmii_offsets_remove, (unit, phy_port, &phy_lane)));
        if (SOC_IS_QUX(unit) && (phy_lane > 8)) {
            /*
            In QUX we have 8 SerDes that can run up to 10G and 28 SerDes up to 3.125G.
            The 10G SerDes can run 10GE; total of 8 ports of 10GE.
            The 3.125G can run 2.5GE/1GE on each SerDes or 10GE over 4 SerDes; total of 28x 1GE ports.
            Each of the first 8 10GE ports can support 8 priorities. Each of the 1GE port  (running on 3.125G SerDes) can support 2 priorities.
            In case that a quad of 3.125G SerDes is working as 10GE port (XAUI) it has total of 8 priorities.
            */
            pg_base = (BCM_COSQ_VSQ_NOF_PG * 8) + (DPP_COSQ_VSQ_NOF_PG_VIPER * (phy_lane - 8 - 1));
        } else {
            pg_base = BCM_COSQ_VSQ_NOF_PG * (phy_lane - 1);
        }
        BCM_DPP_CORES_ITER(core_id, core_index) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.pg_numq.set(unit, core_index, pg_base, config->numq));
        }
        BCM_COSQ_GPORT_VSQ_PG_SET(*pg_base_vsq_gport, core_id, pg_base);
    } else {
        /* Jericho2 TBD: delete this section. not relevant anymore */
        /*If with ID - validate that the VSQ gport handles are legel*/
        if (config->flags & BCM_COSQ_GPORT_WITH_ID) {
            if (!BCM_COSQ_GPORT_IS_VSQ_SRC_PORT(*src_port_vsq_gport)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("src_port_vsq_gport (%d) is not a VSQ src port handle"), *src_port_vsq_gport));
            }
            if (!BCM_COSQ_GPORT_IS_VSQ_PG(*pg_base_vsq_gport)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("pg_base_vsq_gport (%d) is not a VSQ PG handle"), *pg_base_vsq_gport));
            }
            src_port_vsq_index = BCM_COSQ_GPORT_VSQ_SRC_PORT_GET(*src_port_vsq_gport);
            src_port_vsq_core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(*src_port_vsq_gport);
            if (src_port_vsq_core_id != core_id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("src-port-VSQ-Core ID(%d) must be equal to source port core ID(%d)."), src_port_vsq_core_id, core_id));
            }
            pg_base = BCM_COSQ_GPORT_VSQ_PG_GET(*pg_base_vsq_gport);
            if (pg_base + config->numq >= SOC_DPP_DEFS_GET(unit, nof_vsq_f)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("PG-base(%d) with size (%d) is out of range."), pg_base, config->numq));
            }
            pg_core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(*pg_base_vsq_gport);
            if (pg_core_id != core_id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("PG-Core ID(%d) must be equal to source port core ID(%d)."), pg_core_id, core_id));
            }
            if (bcm_dpp_am_pg_check(unit, core_id, pg_base) == BCM_E_NOT_FOUND) {
                allocate = TRUE;
                /*Allocation management PG*/
                rc = bcm_dpp_am_pg_alloc(unit, core_id, SHR_TEMPLATE_MANAGE_SET_WITH_ID, config->numq, &pg_base);
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                int allocated_numq = 0;
                allocate = FALSE;
                /*validate numq*/
                rc = bcm_dpp_am_pg_get(unit, core_id, pg_base, &allocated_numq);
                BCMDNX_IF_ERR_EXIT(rc);

                if (config->numq != allocated_numq) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                        (_BSL_BCM_MSG("Cannot allocate pg_base(%d) numq(%d), since it is allready allocated with numq(%d)."), 
                                         pg_base, config->numq, allocated_numq));
                }
            }
            /*configure a VSQ src port*/
            rc = bcm_dpp_am_vsq_src_port_alloc(unit, core_id, SHR_TEMPLATE_MANAGE_SET_WITH_ID, src_pp_port, &src_port_vsq_index);
            BCMDNX_IF_ERR_EXIT(rc);

        } else {
            allocate = TRUE;
            /*Allocation management PG*/
            rc = bcm_dpp_am_pg_alloc(unit, core_id, 0, config->numq, &pg_base);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_COSQ_GPORT_VSQ_PG_SET(*pg_base_vsq_gport, core_id, pg_base);

            rc = bcm_dpp_am_vsq_src_port_alloc(unit, core_id, 0, src_pp_port, &src_port_vsq_index);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_COSQ_GPORT_VSQ_SRC_PORT_SET(*src_port_vsq_gport, core_id, 0, src_port_vsq_index);
        }
    }
    /*mapping tc cosq_bitmaps to profile*/
    for (pg_tc_bitmap = 0, tc_mapping = 0; tc_mapping < SOC_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++) {
        SHR_BITCOPY_RANGE(&pg_tc_bitmap, tc_mapping * 3, &found_tc_mapping[tc_mapping], 0, 3);
    }
    BCM_DPP_CORES_ITER(core_id, core_index) {
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_mapping_get ,(unit, core_index, src_pp_port, &default_pg_tc_profile)));
        BCMDNX_IF_ERR_EXIT(rc);

        if (allocate) {
            rc = _bcm_dpp_am_template_vsq_pg_tc_mapping_exchange(unit, core_index, pg_tc_bitmap, default_pg_tc_profile, &is_last, &new_pg_tc_profile, &is_allocated);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_mapping_set ,(unit, core_index, src_pp_port, new_pg_tc_profile)));
            BCMDNX_IF_ERR_EXIT(rc); 

            if (is_allocated) {
                rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_set, (unit, core_index, new_pg_tc_profile, pg_tc_bitmap)));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        } else {
            /*validate consistency*/
            rc = _bcm_dpp_am_template_vsq_pg_tc_mapping_profile_data_get(unit, core_id, default_pg_tc_profile, &default_pg_tc_bitmap);
            BCMDNX_IF_ERR_EXIT(rc);
            if (pg_tc_bitmap != default_pg_tc_bitmap) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                    (_BSL_BCM_MSG("pg_base(%d) PG TC bitmap allready configured 0x%x, connot configure it to be 0x%x."), 
                                     pg_base, default_pg_tc_bitmap, pg_tc_bitmap));

            }
        }
    }

    if (!SOC_IS_QAX(unit)) {
        /* Jericho2 TBD: remove this section. ocb_only is not relevant anymore */
        if (allocate) {
            /*Configure*/
            for (cosq = 0; cosq < config->numq; cosq++) {
                ocb_only_array[cosq] = config->pg_attributes[cosq].ocb_only;
            }

            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_ocb_set ,(unit, core_id, pg_base, config->numq, ocb_only_array)));
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            /*validate consistency*/
            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_ocb_get ,(unit, core_id, pg_base, config->numq, ocb_only_array)));
            BCMDNX_IF_ERR_EXIT(rc);

            for (cosq = 0; cosq < config->numq; cosq++) {
                if (ocb_only_array[cosq] != config->pg_attributes[cosq].ocb_only) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                        (_BSL_BCM_MSG("pg_base(%d) OCB-only value for ofsset %d is %d, cannot set it to be %d."), 
                                         pg_base, 
                                         cosq, 
                                         ocb_only_array[cosq],
                                         config->pg_attributes[cosq].ocb_only));
                }
            }
        }
    }

    /*configure a VSQ src port to VSQ PG mapping*/
    for (cosq = 0; cosq < config->numq; cosq++) {
        BCM_DPP_CORES_ITER(core_id, core_index) {
            SOC_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);

            if (SOC_IS_QAX(unit)) {
                /* In QAX PG-params are per PG-VSQ */
                pg_prm.pool_id = config->pg_attributes[cosq].pool_id;
                pg_prm.is_lossles = config->pg_attributes[cosq].is_lossles;
                pg_prm.use_min_port = TRUE;

                rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pb_prm_set, (unit, pg_base + cosq, &pg_prm));
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                /* Jericho2 TBD: delete this section */
                /* In Jericho and below PG params are per rate class */
                rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(BCM_DPP_COSQ_VSQ_TYPE_PG,&soc_tmcvsq_type);
                BCMDNX_IF_ERR_EXIT(rc);

                BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL (unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, pg_base + cosq, config->pg_attributes[cosq].ocb_only, &vsq_id)));

                /* Get Rate class data */
                rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_index, vsq_id, &data_rate_class);
                BCMDNX_IF_ERR_EXIT(rc);

                if (allocate) {
                    /*Configure*/
                    data_rate_class.pg.prm.pool_id = config->pg_attributes[cosq].pool_id;
                    data_rate_class.pg.prm.is_lossles = config->pg_attributes[cosq].is_lossles;
                    data_rate_class.pg.prm.use_min_port = TRUE;

                    /* Find new profile according to given settings and commit changes */
                    rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit, core_index, vsq_id, &data_rate_class);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else {
                    /*validate consistency*/
                    if (data_rate_class.pg.prm.pool_id != config->pg_attributes[cosq].pool_id) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                            (_BSL_BCM_MSG("pg_base(%d) Pool-ID for ofsset %d is %d, cannot set it to be %d."), 
                                             pg_base,
                                             cosq,
                                             data_rate_class.pg.prm.pool_id,
                                             config->pg_attributes[cosq].pool_id));
                    }
                    if (data_rate_class.pg.prm.is_lossles != config->pg_attributes[cosq].is_lossles) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                            (_BSL_BCM_MSG("pg_base(%d) Pool-ID for ofsset %d is %d, cannot set it to be %d."), 
                                             pg_base,
                                             cosq,
                                             data_rate_class.pg.prm.is_lossles,
                                             config->pg_attributes[cosq].is_lossles));
                    }
                }
            }
        }
    }

    /*Map port to PG*/
    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_src_vsqs_mapping_set ,(unit, core_id, src_pp_port, src_port_vsq_index, pg_base, TRUE)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int 
_bcm_petra_cosq_src_vsqs_gport_destroy(
    int unit, 
    bcm_gport_t vsq_gport)
{
    int pg_base = -1;
    uint32 src_pp_port = 0;
    int src_local_port = 0;
    int core_id, core_index;
    int cosq = 0, numq = 0;
    uint32 pg_tc_bitmap = 0;
    bcm_error_t rc = BCM_E_NONE;
    int old_pg_tc_profile = 0, is_last = 0, new_pg_tc_profile = 0, is_allocated = 0;
    int src_port_vsq_index;
    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG], ocb_only;
    bcm_cosq_vsq_info_t vsq_info;
    uint8 enable;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
	
    sal_memset(&vsq_info,0x0,sizeof(bcm_cosq_vsq_info_t));

    if (!SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("_bcm_petra_cosq_src_vsqs_gport_destroy() is not supported for this device type.")));
    }

    if (BCM_GPORT_IS_LOCAL(vsq_gport)) { 
        src_local_port = BCM_GPORT_LOCAL_GET(vsq_gport);
    } else if (SOC_PORT_VALID(unit, vsq_gport)) {
        src_local_port = vsq_gport;
    } else if (BCM_COSQ_GPORT_IS_VSQ_SRC_PORT(vsq_gport) || BCM_COSQ_GPORT_IS_VSQ_PG(vsq_gport)) {
        rc = _bcm_petra_cosq_vsq_info_get(unit, vsq_gport, &vsq_info);
        BCMDNX_IF_ERR_EXIT(rc);
        src_local_port = vsq_info.src_port;
    } else {   
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                            (_BSL_BCM_MSG("Invalid VSQ type %d."), vsq_gport));
    }
    rc = soc_port_sw_db_local_to_pp_port_get(unit, src_local_port, &src_pp_port, &core_id);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_src_vsqs_mapping_get ,(unit, core_id, src_pp_port, &src_port_vsq_index, &pg_base, &enable)));
    BCMDNX_IF_ERR_EXIT(rc);
    if (!enable) {
        BCM_EXIT;
    }

    /* In QAX we didn't allocate, so no need to deallocate */
    if (!SOC_IS_QAX(unit)) {
        rc = bcm_dpp_am_vsq_src_port_free(unit, core_id, src_port_vsq_index);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    for (ocb_only = 0; ocb_only <= !SOC_IS_QAX(unit); ocb_only++) { /* QAX has no ocb_only notion */
        /*Map to default rate class*/
        rc = _bcm_petra_cosq_gport_vsq_rate_class_destroy(unit, core_id, src_port_vsq_index, BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT, ocb_only);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Destroy VSQ, src_pp_port==-1 indicates to destroy */
    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_src_vsqs_mapping_set ,(unit, core_id, src_pp_port, src_port_vsq_index, pg_base, FALSE)));
    BCMDNX_IF_ERR_EXIT(rc);

    /* In QAX we didn't allocate, so no need to deallocate */
    if (SOC_IS_QAX(unit)) {
        uint8 numq_get = 0;
        core_index = (core_id == BCM_CORE_ALL) ? 0 : core_id;
        SOCDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.pg_numq.get(unit, core_index, pg_base, &numq_get));
        numq = numq_get;
    } else {
        rc = bcm_dpp_am_pg_get(unit, core_id, pg_base, &numq);
        BCMDNX_IF_ERR_EXIT(rc);

        /*Allocation management PG*/
        rc = bcm_dpp_am_pg_free(unit, core_id, pg_base);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (!SOC_IS_QAX(unit)) {
        /*
         * In jericho, when no DRAM is available, 
         * all PGs must be defined as OCB only
         */
        for (pg_tc_bitmap = 0, cosq = 0; cosq < numq; cosq++) {
            ocb_only_array[cosq] = (SOC_DPP_CONFIG(unit)->arad->init.dram.nof_drams == 0 ? TRUE : FALSE);
        }
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_ocb_set ,(unit, core_id, pg_base, numq, ocb_only_array)));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    for (cosq = 0; cosq < numq; cosq++) {
        rc = _bcm_petra_cosq_gport_vsq_rate_class_destroy(unit, core_id, pg_base + cosq, BCM_DPP_COSQ_VSQ_TYPE_PG, FALSE);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /*All TCs are mapped to offset 0, by defalt*/
    pg_tc_bitmap = 0;
    BCM_DPP_CORES_ITER(core_id, core_index) {
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_mapping_get ,(unit, core_index, src_pp_port, &old_pg_tc_profile)));
        BCMDNX_IF_ERR_EXIT(rc);

        rc = _bcm_dpp_am_template_vsq_pg_tc_mapping_exchange(unit, core_index, pg_tc_bitmap, old_pg_tc_profile, &is_last, &new_pg_tc_profile, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_mapping_set ,(unit, core_index, src_pp_port, new_pg_tc_profile)));
        BCMDNX_IF_ERR_EXIT(rc); 

        if (is_allocated) {
            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_set, (unit, core_index, new_pg_tc_profile, pg_tc_bitmap)));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (SOC_IS_QAX(unit)) {
        /* In QAX PG-params are per PG-VSQ */
        SOC_TMC_ITM_VSQ_PG_PRM pg_prm;
        SOC_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);

        for (cosq = 0; cosq < numq; cosq++) {
            rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pb_prm_set, (unit, pg_base + cosq, &pg_prm));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_src_vsqs_gport_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cosq_src_vsqs_gport_config_t *config, 
    bcm_gport_t *src_port_vsq_gport, 
    bcm_gport_t *pg_base_vsq_gport)
{
    int pg_base = 0, src_port = 0;
    uint32 src_pp_port = 0;
    int core_id, core_index;
    int cosq = 0;
    uint32 tc_mapping = 0, mapped_too;
    uint32 pg_tc_bitmap = 0;
    bcm_error_t rc = BCM_E_NONE;
    int pg_tc_profile = 0;
    int src_port_vsq_index = 0;
    uint8 ocb_only_array[BCM_COSQ_VSQ_NOF_PG];

    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_type;
    SOC_TMC_ITM_VSQ_NDX vsq_id;
    SOC_TMC_ITM_VSQ_PG_PRM pg_prm;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    uint8 enable;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(src_port_vsq_gport);
    BCMDNX_NULL_CHECK(pg_base_vsq_gport);
    BCMDNX_NULL_CHECK(config);

    if (!SOC_IS_JERICHO(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("API bcm_petra_cosq_src_vsqs_gport_get() is not supported for this device type.")));
    }

    if (BCM_GPORT_IS_LOCAL(port)) {
        src_port = BCM_GPORT_LOCAL_GET(port);
    } else if (SOC_PORT_VALID(unit, port)) {
        src_port = port;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, 
                            (_BSL_BCM_MSG("Invalid port type %d."), port));
    }
    /*Get the relavent core ID from the src_port*/
    rc = soc_port_sw_db_local_to_pp_port_get(unit, src_port, &src_pp_port, &core_id);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_src_vsqs_mapping_get ,(unit, core_id, src_pp_port, &src_port_vsq_index, &pg_base, &enable)));
    BCMDNX_IF_ERR_EXIT(rc);
    if (!enable) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT,  (_BSL_BCM_MSG("Source VSQs for core %d, PP port %d, do not exist."), core_id, src_pp_port));
    }
    /*configure a VSQ src port*/
    BCM_COSQ_GPORT_VSQ_SRC_PORT_SET(*src_port_vsq_gport, core_id, 0, src_port_vsq_index);
    BCM_COSQ_GPORT_VSQ_PG_SET(*pg_base_vsq_gport, core_id, pg_base);

    rc = bcm_dpp_am_pg_get(unit, core_id, pg_base, &(config->numq));
    BCMDNX_IF_ERR_EXIT(rc);

    /*mapping tc cosq_bitmaps to profile*/
    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_tc_profile_mapping_get ,(unit, core_id, src_pp_port, &pg_tc_profile)));
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dpp_am_template_vsq_pg_tc_mapping_profile_data_get(unit, core_id, pg_tc_profile, &pg_tc_bitmap);
    BCMDNX_IF_ERR_EXIT(rc);

    for (mapped_too = 0, tc_mapping = 0; tc_mapping < SOC_TMC_NOF_TRAFFIC_CLASSES; tc_mapping++, mapped_too = 0) {
        SHR_BITCOPY_RANGE(&mapped_too, 0, &pg_tc_bitmap, tc_mapping * 3, 3);
        config->pg_attributes[mapped_too].cosq_bitmap |= (0x1 << tc_mapping);
    }
    if (!SOC_IS_QAX(unit)) {
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_ocb_get ,(unit, core_id, pg_base, config->numq, ocb_only_array)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    for (pg_tc_bitmap = 0, cosq = 0; cosq < config->numq; cosq++) {
        if (SOC_IS_QAX(unit)) {
            config->pg_attributes[cosq].ocb_only = 0;
        } else {
            config->pg_attributes[cosq].ocb_only = ocb_only_array[cosq];
        }
    }
    for (cosq = 0; cosq < config->numq; cosq++) {
        BCM_DPP_CORES_ITER(core_id, core_index) {
            SOC_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);

            if (SOC_IS_QAX(unit)) {
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pb_prm_get, (unit, pg_base + cosq, &pg_prm));
                BCMDNX_IF_ERR_EXIT(rc);
            } else {
                rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(BCM_DPP_COSQ_VSQ_TYPE_PG,&soc_tmcvsq_type);
                BCMDNX_IF_ERR_EXIT(rc);

                BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL (unit,mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, pg_base + cosq, config->pg_attributes[cosq].ocb_only, &vsq_id)));

                /* Get Rate class data */
                rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_index, vsq_id, &data_rate_class);
                BCMDNX_IF_ERR_EXIT(rc);

                sal_memcpy(&pg_prm, &data_rate_class.pg.prm, sizeof(SOC_TMC_ITM_VSQ_PG_PRM));
            }

            config->pg_attributes[cosq].pool_id = pg_prm.pool_id;
            config->pg_attributes[cosq].is_lossles = pg_prm.is_lossles;            
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_vsq_destroy(
    int unit, 
    bcm_gport_t vsq_gport)
{
    bcm_error_t rc = BCM_E_NONE;
    int core_id = BCM_CORE_ALL;
    bcm_dpp_cosq_vsq_rate_class_info_t vsq_rate_class_info;
    bcm_dpp_cosq_vsq_type_t vsq_group_type = BCM_DPP_COSQ_VSQ_NOF_TYPES;
    int vsq_index;
    uint8 is_ocb_only_dummy /*It isn't relevent if the destroyed VSQ is ocb-only of dram-mixed, we destroy them together*/, 
        is_ocb_only, 
        use_ocb_only = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    /* 
     * Upon deleting VSQ, the following configuration taking place: 
     * 1. Remove WRED and tail drop settings, this is done by moving to default profile. 
     * 2. Remove from allocation management 
     */
     
    /* 1. Remove WRED and tail drop settings */
    sal_memset(&vsq_rate_class_info,0x0,sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));

    if (!(BCM_COSQ_GPORT_IS_VSQ(vsq_gport) || BCM_GPORT_IS_LOCAL(vsq_gport) || SOC_PORT_VALID(unit, vsq_gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport type")));
    }
    if (!(BCM_GPORT_IS_LOCAL(vsq_gport) || SOC_PORT_VALID(unit, vsq_gport))) {
        /* retrieve VSQ id */
        rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, vsq_gport, 0, &core_id, &is_ocb_only_dummy, &vsq_group_type, &vsq_index);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTCC || 
        vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTTC || 
        vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTGRY || 
        vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PP) {
        use_ocb_only = (1 + SOC_DPP_DEFS_GET(unit, vsq_ocb_only_support));
        for (is_ocb_only = 0; is_ocb_only < use_ocb_only; is_ocb_only++) {
            rc = _bcm_petra_cosq_gport_vsq_rate_class_destroy(unit, core_id, vsq_index, vsq_group_type, is_ocb_only);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    } else if (SOC_IS_JERICHO(unit) && 
              (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT || 
               vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG || 
               BCM_GPORT_IS_LOCAL(vsq_gport) || 
               SOC_PORT_VALID(unit, vsq_gport))) {
        rc = _bcm_petra_cosq_src_vsqs_gport_destroy(unit, vsq_gport);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_vsq_rate_class_destroy(
   int unit, 
   int core_id,
   int vsq_index,
   bcm_dpp_cosq_vsq_type_t vsq_group_type,
   uint8 ocb_only) 
{
    SOC_TMC_ITM_VSQ_GROUP 
        soc_tmcvsq_type;
    SOC_TMC_ITM_VSQ_NDX 
        vsq_id = 0;
    bcm_error_t 
        rc = BCM_E_NONE;
    uint32 
        soc_sand_rc;
    bcm_dpp_cosq_vsq_rate_class_info_t 
        vsq_rate_class_info,
        *exact_vsq_rate_class_info = NULL;
    int 
        new_rate_class,
        is_allocated,
        old_rate_class,
        is_last;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    if (core_id != BCM_CORE_ALL &&
       (core_id < 0 || core_id >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }

    if (!(vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTCC || 
          vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTTC || 
          vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_CTGRY || 
          vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PP || 
          vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT ||
          vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG)) {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "Cannot Configure rate class for VSQ group type %d."), vsq_group_type));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);

    }
    sal_memset(&vsq_rate_class_info, 0x0, sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));

    rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &soc_tmcvsq_type);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_index_group2global,(unit, soc_tmcvsq_type, vsq_index, ocb_only, &vsq_id)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* 
     * shalitas: use funtion, _bcm_petra_cosq_vsq_rate_class_exchange_set(int unit,int core_id,SOC_TMC_ITM_VSQ_NDX vsq_id,bcm_dpp_cosq_vsq_rate_class_info_t *data_rate_class); 
     * to reset rate class info, and use valid default values.
     */
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_vsq_rate_cls_tdata_get(unit, 0, soc_tmcvsq_type, &vsq_rate_class_info));

    rc = _bcm_dpp_am_template_vsq_rate_cls_exchange(unit, core_id, vsq_id, &vsq_rate_class_info, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_allocated) {
        BCMDNX_ALLOC(exact_vsq_rate_class_info, sizeof(*exact_vsq_rate_class_info), "_bcm_petra_cosq_gport_vsq_rate_class_destroy.exact_vsq_rate_class_info");
        if (exact_vsq_rate_class_info == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
        }
        /* Set new profile data */
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit, new_rate_class, soc_tmcvsq_type, &vsq_rate_class_info, exact_vsq_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Set new mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_qt_rt_cls_set, (unit, core_id, ocb_only, soc_tmcvsq_type, vsq_index, new_rate_class)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (is_last && new_rate_class != old_rate_class) {
        /* clear profile data */
        sal_memset(&vsq_rate_class_info, 0x0, sizeof(bcm_dpp_cosq_vsq_rate_class_info_t));
        if(exact_vsq_rate_class_info == NULL) {
            BCMDNX_ALLOC(exact_vsq_rate_class_info, sizeof(*exact_vsq_rate_class_info), "_bcm_petra_cosq_gport_vsq_rate_class_destroy.exact_vsq_rate_class_info");
            if (exact_vsq_rate_class_info == NULL) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
            }
        }
        rc = _bcm_petra_cosq_vsq_rate_class_hw_set(unit, old_rate_class, soc_tmcvsq_type, &vsq_rate_class_info, exact_vsq_rate_class_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

exit:
    BCM_FREE(exact_vsq_rate_class_info);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_flags_to_ingress_threshold(
    int unit,
    uint32 flags,
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E *ingress_threshold)
{
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E threshold_type = SOC_TMC_INGRESS_THRESHOLD_INVALID;
    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        switch (flags) {
            case BCM_COSQ_GPORT_SIZE_BYTES:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES;
                break;
            case BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_BYTES:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES;
                break;
            case BCM_COSQ_GPORT_SIZE_SRAM | BCM_COSQ_GPORT_SIZE_PACKET_DESC:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unknown resource type.")));
        }
    } else {
        threshold_type = SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES;
    }

    *ingress_threshold = threshold_type;

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_resource_to_ingress_threshold(
    int unit,
    bcm_cosq_resource_t resource,
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E *ingress_threshold)
{
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E threshold_type = SOC_TMC_INGRESS_THRESHOLD_INVALID;
    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        switch (resource) {
            case bcmReservationResourceBytes:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES;
                break;
            case bcmReservationResourceOcbBuffers:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS;
                break;
            case bcmResourceOcbPacketDescriptors:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unknown resource type.")));
        }
    } else {
        switch (resource) {
            case bcmReservationResourceBufferDescriptors:
                threshold_type = SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Resource must be bcmReservationResourceBufferDescriptors")));
        }
    }

    *ingress_threshold = threshold_type;

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_resource_allocation_get(
    int unit, 
    uint32 flags, 
    bcm_cosq_resource_t resource, 
    bcm_cosq_allocation_entity_t *target, 
    bcm_cosq_resource_amounts_t *amounts)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_vsq_type_t vsq_group_type;
    SOC_TMC_ITM_VSQ_GROUP   soc_tmcvsq_group;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    int vsq_index;
    uint8 is_ocb_only;
    int core_id;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    SOC_TMC_ITM_INGRESS_CONGESTION_MGMT ingress_congestion_mgmt;
    SOC_TMC_ITM_INGRESS_CONGESTION_RESOURCE *ingress_resource = NULL;
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type;
    int lossless_pool = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(target);
    BCMDNX_NULL_CHECK(amounts);

    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_resource_allocation_get() is not supported for this device type.")));
    }
    if (!SOC_IS_QAX(unit) && resource != bcmReservationResourceBufferDescriptors) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Resource must be bcmReservationResourceBufferDescriptors")));
    }
    if (target->color >= bcmColorPreserve) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target color(%d) out of range."), target->color));
    }
    if (target->pool_id >= SOC_TMC_ITM_NOF_RSRC_POOLS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target pool_id(%d) is out of range."), target->pool_id));
    }
    /*get mapping between VSQE and VSQF*/
    rc =_bcm_petra_cosq_gport_vsq_gport_get(unit, target->gport, 0, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    if (vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT && vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_PG && vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("VSQ(%d) must be souce-port-VSQ or PG-VSQ"), target->gport));
    }

    rc = _bcm_petra_cosq_resource_to_ingress_threshold(unit, resource, &rsrc_type);
    BCMDNX_IF_ERR_EXIT(rc);

    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_global_resource_allocation_get,(unit, core_id, &ingress_congestion_mgmt));
        BCMDNX_IF_ERR_EXIT(rc);

        ingress_resource = (SOC_IS_QAX(unit)) ?
            (&ingress_congestion_mgmt.global[rsrc_type]) :
            (target->is_ocb_only ? (&ingress_congestion_mgmt.ocb) : (&ingress_congestion_mgmt.dram));
        amounts->reserved = ingress_resource->reserved;
        amounts->max_shared_pool = (target->pool_id == 0) ? (ingress_resource->pool_0) : (ingress_resource->pool_1);
        if (SOC_IS_QAX(unit)) {
            /* 
             * In QAX only 1 pool can be associated with lossless traffic,
             * so Headroom is associated only with lossless_pool. 
             */
            rc = sw_state_access[unit].dpp.soc.qax.tm.lossless_pool_id.get(unit, core_id, &lossless_pool);
            SOCDNX_IF_ERR_EXIT(rc);

            if (target->pool_id == lossless_pool) {
                amounts->max_headroom = ingress_resource->headroom;
                amounts->nominal_headroom = ingress_resource->nominal_headroom;
            } else {
                amounts->max_headroom = 0;
                amounts->nominal_headroom = 0;
            }
        } else {
            amounts->max_headroom = ingress_resource->headroom;
        }

    } else { /* VSQE-F */
        rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &soc_tmcvsq_group);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_index_group2global, (unit, soc_tmcvsq_group, vsq_index, target->is_ocb_only, &vsq_id));
        BCM_SAND_IF_ERR_EXIT(rc);

        rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Get reserved */
        if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT) {
            if (SOC_IS_QAX(unit)) {
                amounts->reserved = data_rate_class.port[target->pool_id].guaranteed_size[rsrc_type][target->color];
                amounts->max_shared_pool = data_rate_class.port[target->pool_id].shared_size[rsrc_type][target->color];
                amounts->max_headroom = data_rate_class.port[target->pool_id].headroom_size[rsrc_type];
                amounts->nominal_headroom = amounts->max_headroom;
            } else {
                amounts->reserved = data_rate_class.port[target->pool_id].min_threshold[target->color];
                amounts->max_shared_pool = data_rate_class.port[target->pool_id].shared.max_size_bds[target->color];
                amounts->max_headroom = data_rate_class.port[target->pool_id].headroom.max_size_bds[target->color];
            }
        } else if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG) {
            if (SOC_IS_QAX(unit)) {
                amounts->reserved = data_rate_class.pg.guaranteed_size[rsrc_type][target->color];
                amounts->shared_pool_fadt.thresh_min = data_rate_class.pg.shared_size[rsrc_type][target->color].min_threshold;
                amounts->shared_pool_fadt.thresh_max = data_rate_class.pg.shared_size[rsrc_type][target->color].max_threshold;
                amounts->shared_pool_fadt.alpha = data_rate_class.pg.shared_size[rsrc_type][target->color].alpha;
                amounts->max_headroom = data_rate_class.pg.headroom_size[rsrc_type].max_headroom;
                amounts->nominal_headroom = data_rate_class.pg.headroom_size[rsrc_type].max_headroom_nominal;
            } else {
                amounts->reserved = data_rate_class.pg.min_threshold[target->color];
                amounts->max_shared_pool = data_rate_class.pg.shared.max_size_bds[target->color];
                amounts->max_headroom = data_rate_class.pg.headroom.max_size_bds[target->color];
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* Validate resource_allocation_set input params */
STATIC int
bcm_cosq_resource_allocation_amounts_verify(
    int unit,
    int core_id,
    bcm_dpp_cosq_vsq_type_t vsq_group_type,
    uint32 flags,
    bcm_cosq_resource_t resource, 
    bcm_cosq_allocation_entity_t *target, 
    bcm_cosq_resource_amounts_t *amounts)
{
    int rv = BCM_E_NONE;
    SOC_TMC_ITM_INGRESS_CONGESTION_MGMT ingress_congestion_mgmt;
    SOC_TMC_ITM_INGRESS_CONGESTION_RESOURCE *ingress_resource = NULL;
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type;
    uint32 max_threshold = 0;
    BCMDNX_INIT_FUNC_DEFS;

    if (flags && !(flags & BCM_COSQ_RSRC_ALLOC_COLOR_BLIND)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be 0 or BCM_COSQ_RSRC_ALLOC_COLOR_BLIND")));
    }
    if (target->color >= bcmColorPreserve) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target color(%d) out of range."), target->color));
    }
    if (target->pool_id >= SOC_TMC_ITM_NOF_RSRC_POOLS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target pool_id(%d) is out of range."), target->pool_id));
    }
    if (vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT && vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_PG && vsq_group_type != BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("VSQ(%d) must be souce-port-VSQ, PG-VSQ or global-VSQ"), target->gport));
    }

    rv = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_global_resource_allocation_get,(unit, core_id, &ingress_congestion_mgmt));
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_petra_cosq_resource_to_ingress_threshold(unit, resource, &rsrc_type);
    BCMDNX_IF_ERR_EXIT(rv);

    /* Validate thresholds */
    ingress_resource = (SOC_IS_QAX(unit)) ?
        (&ingress_congestion_mgmt.global[rsrc_type]) :
        (target->is_ocb_only ? (&ingress_congestion_mgmt.ocb) : (&ingress_congestion_mgmt.dram));

    max_threshold = ingress_resource->total;

    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        if (amounts->max_shared_pool > max_threshold) {
            BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_BCM_MSG("shared_pool size (%u) is too high"), 
                        amounts->max_shared_pool));
        }
        if (amounts->max_headroom > max_threshold) {
            BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_BCM_MSG("headroom size (%u) is too high"), 
                        amounts->max_headroom));
        }
        if (SOC_IS_QAX(unit)) {
            if (amounts->nominal_headroom > max_threshold) {
                BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_BCM_MSG("headroom size (%u) is too high"), 
                            amounts->nominal_headroom));
            }
            if (amounts->nominal_headroom > amounts->max_headroom) {
                BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_BCM_MSG("Nominal Headroom size (%u) can't be larger than Max Headroom size (%u)"),
                                amounts->nominal_headroom, amounts->max_headroom));
            }
        }
    } else {
        if (amounts->reserved > max_threshold) {
            BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_BCM_MSG("reserved size (%u) is too high"), 
                        amounts->reserved));
        }
        if (amounts->max_shared_pool > max_threshold) {
            BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_BCM_MSG("shared_pool size (%u) is too high"), 
                        amounts->max_shared_pool));
        }
        if (amounts->max_headroom > max_threshold) {
            BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_BCM_MSG("headroom size (%u) is too high"), 
                        amounts->max_headroom));
        }
    }
    if (SOC_IS_QAX(unit) && vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG) {
        if (amounts->shared_pool_fadt.thresh_max > max_threshold) {
            SOCDNX_EXIT_WITH_ERR(SOC_E_PARAM, (_BSL_SOCDNX_MSG("shared_pool FADT max threshold size (%u) is too high"), 
                        amounts->shared_pool_fadt.thresh_max));
        }
        if (amounts->shared_pool_fadt.thresh_min > max_threshold) {
            SOCDNX_EXIT_WITH_ERR(SOC_E_PARAM, (_BSL_SOCDNX_MSG("shared_pool FADT max threshold size (%u) is too high"), 
                        amounts->shared_pool_fadt.thresh_min));
        }
        if (amounts->shared_pool_fadt.alpha > SOC_TMC_ITM_FADT_ALPHA_MAX ||
                amounts->shared_pool_fadt.alpha < SOC_TMC_ITM_FADT_ALPHA_MIN ) {
            SOCDNX_EXIT_WITH_ERR(SOC_E_PARAM, (_BSL_SOCDNX_MSG("shared_pool FADT alpha size (%d) must be between %d and %d"), 
                        amounts->shared_pool_fadt.alpha, SOC_TMC_ITM_FADT_ALPHA_MIN, SOC_TMC_ITM_FADT_ALPHA_MAX));
        }
        if (amounts->nominal_headroom > max_threshold) {
            SOCDNX_EXIT_WITH_ERR(SOC_E_PARAM, (_BSL_SOCDNX_MSG("nominal headroom size (%u) is too high"), 
                        amounts->nominal_headroom));
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_resource_allocation_set(
    int unit, 
    uint32 flags,
    bcm_cosq_resource_t resource, 
    bcm_cosq_allocation_entity_t *target, 
    bcm_cosq_resource_amounts_t *amounts)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_vsq_type_t vsq_group_type;
    SOC_TMC_ITM_VSQ_GROUP   soc_tmcvsq_group;
    SOC_TMC_ITM_VSQ_NDX vsq_id = 0;
    int vsq_index;
    uint8 is_ocb_only;
    int core_id;
    bcm_dpp_cosq_vsq_rate_class_info_t data_rate_class;
    bcm_dpp_cosq_vsq_rate_class_taildrop_info_t *headroom = NULL, *shared_pool = NULL;
    bcm_color_t color, start_color, end_color;
    SOC_TMC_ITM_INGRESS_CONGESTION_MGMT ingress_congestion_mgmt;
    SOC_TMC_ITM_INGRESS_CONGESTION_RESOURCE *ingress_resource = NULL;
    uint32 old_max_reserved = 0, new_max_reserved = 0;
    int reserve_change = 0;
    int32 reserve_change_array[SOC_DPP_DEFS_MAX(NOF_CORES)][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type;
    int lossless_pool = 0;
    SOC_TMC_ITM_VSQ_PG_PRM pg_prm;
    uint8 pg_prm_pool_id = 0;
    uint8 pg_prm_is_lossles = 0;
    uint32 guaranteed = 0;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(target);
    BCMDNX_NULL_CHECK(amounts);
    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_resource_allocation_set() is not supported for this device type.")));
    }

    sal_memset(&reserve_change_array, 0x0, sizeof(reserve_change_array));

    rc = _bcm_petra_cosq_resource_to_ingress_threshold(unit, resource, &rsrc_type);
    BCMDNX_IF_ERR_EXIT(rc);

    /*get mapping between VSQE and VSQF*/
    rc =_bcm_petra_cosq_gport_vsq_gport_get(unit, target->gport, 0, &core_id, &is_ocb_only, &vsq_group_type, &vsq_index);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Input validation */
    rc = bcm_cosq_resource_allocation_amounts_verify(unit, core_id, vsq_group_type, flags, resource, target, amounts);
    BCMDNX_IF_ERR_EXIT(rc);

    if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
        /* Get existing global configurations */
        rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_global_resource_allocation_get,(unit, core_id, &ingress_congestion_mgmt));
        BCMDNX_IF_ERR_EXIT(rc);

        /* target->is_ocb_only is used for GL-VSQ. is_ocb_only is used for VSQE-F */
        ingress_resource = (SOC_IS_QAX(unit)) ?
            (&ingress_congestion_mgmt.global[rsrc_type]) :
            (target->is_ocb_only ? (&ingress_congestion_mgmt.ocb) : (&ingress_congestion_mgmt.dram));

        if (amounts->max_shared_pool + 
                ((target->pool_id == 0) ? (ingress_resource->pool_1) : (ingress_resource->pool_0)) + 
                ((SOC_IS_QAX(unit)) ? (amounts->nominal_headroom) : (amounts->max_headroom)) + 
                ingress_resource->reserved > ingress_resource->total) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Not enough free memory for new amounts in core %d"), core_id));
        }

        if (SOC_IS_QAX(unit)) {
            /* 
             * Don't let the user configure something he didn't want to,
             * so force him to set max_headroom and nominal_headroom the same.
             */
            if (rsrc_type == SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES &&
                    amounts->max_headroom != amounts->nominal_headroom) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("max_headroom must be equal to nominal_headroom when allocating total Words.")));
            }

            /* 
             * In QAX only 1 pool can be associated with lossless traffic. 
             * The first pool to allocate Headroom will be the lossless pool.
             */
            if ( (0 == ingress_resource->headroom) && (0 == ingress_resource->nominal_headroom) &&
                    ((0 != amounts->max_headroom) || (0 != amounts->nominal_headroom)) ) {
                rc = sw_state_access[unit].dpp.soc.qax.tm.lossless_pool_id.set(unit, core_id, target->pool_id);
                SOCDNX_IF_ERR_EXIT(rc);
            }

            /* validate headroom is allocated only for the lossless pool */
            rc = sw_state_access[unit].dpp.soc.qax.tm.lossless_pool_id.get(unit, core_id, &lossless_pool);
            SOCDNX_IF_ERR_EXIT(rc);
            if ( ((0 != amounts->max_headroom) || (0 != amounts->nominal_headroom)) &&
                    (target->pool_id != lossless_pool) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can't allocate headroom to pool %d. Headroom is already assigned to Pool %d."), target->pool_id, lossless_pool));
            }
        }

        /*
         * If headroom is configured then the dynamic thresholds of VOQs
         * should be changed accordingly, because headroom resources
         * should be guaranteed.
         */
        reserve_change_array[core_id][rsrc_type] = (SOC_IS_QAX(unit)) ?
            (amounts->nominal_headroom - ingress_resource->nominal_headroom) :
            (amounts->max_headroom - ingress_resource->headroom);
        if (reserve_change_array[core_id][rsrc_type] != 0) {
            rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, core_id, target->is_ocb_only, reserve_change_array));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* update pool and headroom in hw */
        if (SOC_IS_QAX(unit)) {
            /* Update HW via mbcm_dpp_itm_global_resource_allocation_set() which is less specific */
            (target->pool_id == 0) ? (ingress_resource->pool_0 = amounts->max_shared_pool): (ingress_resource->pool_1 = amounts->max_shared_pool);
            ingress_resource->headroom = amounts->max_headroom;
            ingress_resource->nominal_headroom = amounts->nominal_headroom;
            rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_global_resource_allocation_set,(unit, core_id, &ingress_congestion_mgmt));
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_resource_allocation_set, (unit, core_id, target->pool_id, target->is_ocb_only, amounts->max_shared_pool, amounts->max_headroom));
            BCMDNX_IF_ERR_EXIT(rc);
        }

    } else { /* VSQE-F */
        /* target->is_ocb_only is used for GL-VSQ. is_ocb_only is used for VSQE-F */
        if (target->is_ocb_only != is_ocb_only) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("target->is_ocb_only(%d) doesn't match the configured VSQ(0x%x) is_ocb_only(%d)"), target->is_ocb_only, target->gport, is_ocb_only));
        }

        rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type, &soc_tmcvsq_group);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_index_group2global, (unit, soc_tmcvsq_group, vsq_index, is_ocb_only, &vsq_id));
        BCM_SAND_IF_ERR_EXIT(rc);

        rc = _bcm_dpp_am_template_vsq_rate_cls_data_get(unit, core_id, vsq_id, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG) {
            SOC_TMC_ITM_VSQ_PG_PRM_clear(&pg_prm);

            if (SOC_IS_QAX(unit)) {
                /* In QAX, PG params are per PG-VSQ */
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pb_prm_get, (unit, vsq_index, &pg_prm));
                BCMDNX_IF_ERR_EXIT(rc);

                pg_prm_pool_id = pg_prm.pool_id;
                pg_prm_is_lossles = pg_prm.is_lossles;
            } else {
                /* In Jericho, PG params are per rate class (profile) */
                pg_prm_pool_id = data_rate_class.pg.prm.pool_id;
                pg_prm_is_lossles = data_rate_class.pg.prm.is_lossles;
            }
            if (pg_prm_pool_id != target->pool_id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Target's pool_id(%d) must be equal to the allocated PG-VSQ(0x%x) pool_id(%d)"),
                            target->pool_id, target->gport, pg_prm_pool_id));
            }

            if (pg_prm_is_lossles == FALSE && (SOC_IS_QAX(unit) ? (amounts->nominal_headroom != 0) : (amounts->max_headroom != 0))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("PG-VSQ(0x%x) must be lossles in order to configure headroom"), target->gport));
            }

            /*
             * If reservation is configured, it needs to be taken from VSQF (i.e. use_min_port=FALSE).
             * If reservation is NOT configured, it needs to be taken from VSQE (i.e. use_min_port=TRUE).
             */
            if (SOC_IS_QAX(unit)) {
                /* In QAX, PG params are per PG-VSQ */
                pg_prm.use_min_port = (amounts->reserved == 0) ? TRUE : FALSE;
            } else {
                /* In Jericho, PG params are per rate class (profile) */
                data_rate_class.pg.prm.use_min_port = (amounts->reserved == 0) ? TRUE : FALSE;
            }
        }

        if (flags & BCM_COSQ_RSRC_ALLOC_COLOR_BLIND) {
            /* Configure all colors the same */
            start_color = 0;
            end_color = DPP_DEVICE_COSQ_ING_NOF_DP;
        } else {
            /* Configure only specific color */
            start_color = target->color;
            end_color = target->color + 1;
        }

        /* Configure max_headroom and max_shared_pool */
        for (color = start_color; color < end_color; ++color) {
            if (SOC_IS_QAX(unit)) {
                /* In QAX, shared_pool and headroom params are different than Jericho */
                if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT) {
                    data_rate_class.port[target->pool_id].shared_size[rsrc_type][color] = amounts->max_shared_pool;
                    data_rate_class.port[target->pool_id].headroom_size[rsrc_type] = amounts->max_headroom;
                } else if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG) {
                    if (amounts->shared_pool_fadt.thresh_max == 0 &&
                        amounts->shared_pool_fadt.thresh_min == 0 &&
                        amounts->shared_pool_fadt.alpha == 0) {

                        /* In case user didn't fill shared pool FADT struct, use max_shared_pool
                         * to configure taildrop */
                        data_rate_class.pg.shared_size[rsrc_type][color].max_threshold = amounts->max_shared_pool;
                        data_rate_class.pg.shared_size[rsrc_type][color].min_threshold = amounts->max_shared_pool;
                        data_rate_class.pg.shared_size[rsrc_type][color].alpha = 0;
                    } else {
                        /* Configure shared pool FADT */
                        data_rate_class.pg.shared_size[rsrc_type][color].max_threshold = amounts->shared_pool_fadt.thresh_max;
                        data_rate_class.pg.shared_size[rsrc_type][color].min_threshold = amounts->shared_pool_fadt.thresh_min;
                        data_rate_class.pg.shared_size[rsrc_type][color].alpha = amounts->shared_pool_fadt.alpha;
                    }

                    data_rate_class.pg.headroom_size[rsrc_type].max_headroom = amounts->max_headroom;
                    data_rate_class.pg.headroom_size[rsrc_type].max_headroom_nominal = amounts->nominal_headroom;
                    data_rate_class.pg.headroom_size[rsrc_type].max_headroom_extension = amounts->max_headroom - amounts->nominal_headroom;
                }
            } else {
                headroom = bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(unit, soc_tmcvsq_group, target->pool_id, 1, &data_rate_class); 
                shared_pool = bcm_dpp_cosq_vsq_rate_class_taildrop_data_get(unit, soc_tmcvsq_group, target->pool_id, 0, &data_rate_class); 

                /* if (resource == bcmReservationResourceBufferDescriptors) */
                shared_pool->max_size_bds[color] = amounts->max_shared_pool;
                headroom->max_size_bds[color] = amounts->max_headroom;
            }
        }

        /* Find old maximum reserved size of all colors in VSQ */
        old_max_reserved = _bcm_petra_cosq_vsq_max_reserved_get(unit, rsrc_type, vsq_group_type, &data_rate_class);

        if (SOC_IS_QAX(unit)) {
            if (rsrc_type == SOC_TMC_INGRESS_THRESHOLD_TOTAL_BYTES) {
                /* User value is in Bytes resolution, and need to be converted into Words resolution */
                guaranteed = DPP_COSQ_BYTES_TO_WORDS(amounts->reserved);
            } else {
                guaranteed = amounts->reserved;
            }
        } else {
            guaranteed = amounts->reserved;
        }

        /* Configure reserved (guaranteed) size */
        for (color = start_color; color < end_color; ++color) {
            if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_SRC_PORT) {
                if (SOC_IS_QAX(unit)) {
                    data_rate_class.port[target->pool_id].guaranteed_size[rsrc_type][color] = guaranteed;
                } else {
                    data_rate_class.port[target->pool_id].min_threshold[color] = guaranteed;
                }
            } else if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG) {
                if (SOC_IS_QAX(unit)) {
                    data_rate_class.pg.guaranteed_size[rsrc_type][color] = guaranteed;
                } else {
                    data_rate_class.pg.min_threshold[color] = guaranteed;
                }
            }
        }

        /* Find the new maximum reserved size of all colors in VSQ */
        new_max_reserved = _bcm_petra_cosq_vsq_max_reserved_get(unit, rsrc_type, vsq_group_type, &data_rate_class);

        /* update total reserved resources */
        reserve_change = new_max_reserved - old_max_reserved;
        rc = _bcm_petra_cosq_vsq_total_reserve_update(unit, core_id, is_ocb_only, rsrc_type, reserve_change);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Find new profile according to given settings and commit changes */
        rc = _bcm_petra_cosq_vsq_rate_class_exchange_set(unit, core_id, vsq_id, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

        if (SOC_IS_QAX(unit)) {
            if (vsq_group_type == BCM_DPP_COSQ_VSQ_TYPE_PG) {
                /* In QAX, PG params are configured per PG and not per rate class */
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pb_prm_set, (unit, vsq_index, &pg_prm));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }

        /* In STRICT mode need to change also VOQ dynamic thresholds */
        if (SOC_DPP_CONFIG(unit)->jer->tm.cgm_mgmt_guarantee_mode == SOC_TMC_ITM_CGM_MGMT_GUARANTEE_STRICT) {
            if (SOC_IS_QAX(unit)) {
                /* for QAX and later, translate SRAM buffers to SRAM bytes */
                if (rsrc_type == SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS) {
                    reserve_change = DPP_COSQ_BUFFERS_TO_BYTES(reserve_change);
                }
            }
            /*
             *VOQ use SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES and 
             *VSQ uses SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS, 
             *but both have the same numeric value 
            */
            reserve_change_array[core_id][rsrc_type] = reserve_change;
            if (reserve_change_array[core_id][rsrc_type] != 0) {
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, core_id, is_ocb_only, reserve_change_array));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Following are the symantics of this call
 *    - sched_port => parent element
 *    - input_port => child element
 *    - cosq       => child element cosq
 */
int
bcm_petra_cosq_gport_attach(int unit,
                            bcm_gport_t sched_port,
                            bcm_gport_t input_port,
                            bcm_cos_queue_t cosq)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t        *child_info ;
    bcm_dpp_cosq_gport_info_t        *parent_info ;
    int                              child_mode = 0, flow_id_index, flow_id, i, orig_sub_flow0_id, orig_sub_flow1_id;
    bcm_dpp_cosq_class_info_t        info;
    int                              weight = 0, updated_type;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    SOC_TMC_SCH_FLOW                     exact_flow_config;
    uint32                           soc_sand_rc, region, nof_remote_cores;   
    bcm_gport_t                      parent_port;
    int                              is_parent_reserved_res = FALSE;
    int                              parent_se_port, dummy_tc;
    int                             core ;
    SOC_TMC_SCH_SE_ID               sw_state_default_se;
    uint32                          sw_state_ref_cnt;

    
    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    parent_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, sched_port, 0, &core);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for sched_port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)sched_port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on QAX*/
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &sched_port, core);
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &input_port, core);
    }
    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, sched_port, 0, &parent_port);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    /* 
     * Note: API does not support parent of type Port-TC. User that wants
     * to attach Port-TC object. Call first handle_get and receieve scheduler gport.
     */
    if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(parent_port)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, API does not support Port-TC obejects gport: 0x%x \n"), unit, parent_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* Validate parent and child elements are not exact. In that case we cant attach parent to input when parent = input */
    if (parent_port == input_port) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, attach cant be done when parent 0x%x equals input port 0x%x\n"), unit, parent_port,input_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* validate parent element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, parent_port, -1, dpp_device_cosq_gport_parent_element, &parent_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (parent_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* validate child element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, input_port, cosq, dpp_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* make sure the parent is a SE */
    if ( !(parent_info->is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, sched_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if parent scheduler element is a reserved resource       */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    if (parent_info->is_se) {
        rc = _bcm_petra_cosq_se_id2port(unit,core,parent_info->se_id,&parent_se_port, &dummy_tc);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving port id from SE %d, error 0x%x\n"), unit, parent_info->se_id, rc));
            goto err;
        }
    }
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if ( (parent_info->is_se) &&
                        ( (parent_se_port != DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (parent_info->se_id == sw_state_default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.get(unit, core, child_info->actual_flow_id, &child_mode));

    /* get parent element information for child hookup corresponding to child scheduling mode */
    rc = _bcm_petra_cosq_credit_class_info_get(unit, core, parent_info->se_config, child_mode, &info);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d core %d, error in retreiving parent info corresponding to child element scheduling mode, error 0x%x\n"), unit, core, rc));
        goto err;
    }

    /* retrieve child element weight */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, child_info->actual_flow_id, &weight));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "Unit(%d) flow_id(%d), Weight(%d)\n"),
                         unit, child_info->actual_flow_id, weight));
    
    weight = (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW) ? weight :
                       ((info.weight_mode == SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) ? 0 : weight);

    rc = _bcm_petra_cosq_credit_class_weight_validate(unit, weight, &info, &updated_type);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in adjusting flow type for weight/weight mode, error 0x%x\n"), unit, rc));
        goto err;
    }

    /* hookup hierarchy */
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    cs_info->se_type = parent_info->se_config->type;
    cs_info->id = parent_info->se_config->id;
    switch (cs_info->se_type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            cs_info->se_info.hr.sp_class = updated_type;
            cs_info->se_info.hr.weight = weight;
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
            cs_info->se_info.cl.sp_class = updated_type;
            cs_info->se_info.cl.weight = weight;
            break;

        default:
            break;
    }

    /* set all symmetric connections */
    if (child_info->is_connector) {
        region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(child_info->flow_id);
        nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = child_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = child_info->flow_config->sub_flow[1].id;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(child_info->flow_id, nof_remote_cores, i);

        child_info->flow_config->sub_flow[0].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        child_info->flow_config->sub_flow[1].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id, child_info->flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif

    if(!child_info->is_connector) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_group_set,(unit, core, child_info->se_id, child_info->se_config, child_info->flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting se %d group, soc_sand error 0x%x, error 0x%x\n"), unit, child_info->se_id, soc_sand_rc, rc));
             goto err;
        }
    }

    /* increment reference count of parent */
    if (is_parent_reserved_res == FALSE) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, (parent_info->se_config)->id, &sw_state_ref_cnt));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, (parent_info->se_config)->id, sw_state_ref_cnt + 1));
    }
    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (parent_info) {
            BCM_FREE(parent_info->flow_config);
            BCM_FREE(parent_info->se_config);
            BCM_FREE(parent_info) ;
        }
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info) ;
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (parent_info) {
        BCM_FREE(parent_info->flow_config);
        BCM_FREE(parent_info->se_config);
        BCM_FREE(parent_info) ;
    }
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info) ;
    }
/* } */
#endif
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}
int
bcm_petra_cosq_gport_detach(int unit,
                            bcm_gport_t sched_port,
                            bcm_gport_t input_port,
                            bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    /* consistency checks */
    if (!(BCM_COSQ_GPORT_IS_E2E_PORT(sched_port) || BCM_GPORT_IS_SCHEDULER(sched_port) ||
          BCM_COSQ_GPORT_IS_SCHED_CIR(sched_port) || BCM_COSQ_GPORT_IS_SCHED_PIR(sched_port))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected parent gport type, 0x%x"), sched_port));
    }

    if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(input_port) ||
          BCM_COSQ_GPORT_IS_COMPOSITE_SF2(input_port) || BCM_GPORT_IS_SCHEDULER(input_port) ||
          BCM_COSQ_GPORT_IS_SCHED_CIR(input_port) || BCM_COSQ_GPORT_IS_SCHED_PIR(input_port))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected child gport type, 0x%x"), input_port));
    }


    rc = _bcm_petra_cosq_sched_connector_gport_detach(unit, sched_port, input_port, cosq);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_parent_get(int unit,
                                    bcm_gport_t child_port,
                                    bcm_cos_queue_t cos,
                                    bcm_gport_t *parent_port)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t        *child_info ;
    bcm_dpp_cosq_gport_info_t        *parent_info;
    int                              flow_id_index;
    int                              flow_id, base_flow_id, flow_region;
    uint8                            is_non_contiguous; 
    int                              is_cl_cir, is_odd_even;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE   *cs_info;
    SOC_TMC_SCH_SE_ID                    se_id;
    int                              is_parent_reserved_res = FALSE;
    int                              parent_se_port, tc;
    bcm_gport_t                      parent_tmp, fap_port;
    int                              core ;
    SOC_TMC_SCH_SE_ID                sw_state_default_se;
    uint32                           sw_state_ref_cnt;

    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    parent_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, child_port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for child_port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)child_port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on QAX*/
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &child_port, core);
    }

    /* validate child element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, child_port, cos, dpp_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* Retrieve hierarchy parent */
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;  
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    se_id = cs_info->id;
    flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));

    /* Retrieve scheduler information */
    BCM_GPORT_SCHEDULER_CORE_SET(parent_tmp,flow_id,core);

    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, parent_tmp, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &parent_info);
    if (rc != BCM_E_NONE) {
         goto err;
    }
    if (parent_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    /* Get port id in case SE is parent */
    rc = _bcm_petra_cosq_se_id2port(unit, core, se_id, &parent_se_port, &tc);
    if (rc != BCM_E_NONE) {
      LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, Error retreving port id from SE %d\n"), unit,se_id));          
      goto err;
    } 

    /* Validate SE is parent */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if ( ( (parent_se_port != DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (se_id == sw_state_default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }

    /* In case SE is not parent: validate someone is referenced to it */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, se_id, &sw_state_ref_cnt));
    if ((!is_parent_reserved_res) && sw_state_ref_cnt <= DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Parent SE(%d) reference count is 0\n"),
                              unit, se_id));
        rc = BCM_E_INTERNAL;
        goto err;
    }

    /* Default se is not attached to anyone */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id == sw_state_default_se) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) not attached\n"), unit, cs_info->id));
        rc = BCM_E_PARAM;
        goto err;
    }


    /* In case SE is parent return different gport */
    if (!is_parent_reserved_res) {
        /* Validated parent scheduler. Set parent gport */
        flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
        base_flow_id = (flow_id - (flow_id & 0x3));
        flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
            rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
            BCMDNX_IF_ERR_EXIT(rc);  

        if (SOC_IS_QAX(unit)) { /*set out_gport to lower 64k on QAX (32k on QUX) flow range, as the user would expect*/
            flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
        }
        if (parent_info->is_dual == FALSE) {
            /* Non dual, just set scheduler gport */
            BCM_GPORT_SCHEDULER_CORE_SET((*parent_port), flow_id, core);
        } else {
            /* return base flow id with either CIR gport (CL) or PIR gport (FQ) */
            base_flow_id = (flow_id - (flow_id & 0x3));
            if(is_cl_cir)
            {
                if ( (parent_info->se_config->type == SOC_TMC_SCH_SE_TYPE_FQ) ||
                       (parent_info->se_config->type == SOC_TMC_SCH_SE_TYPE_HR) ) {
                    BCM_COSQ_GPORT_SCHED_PIR_CORE_SET((*parent_port), base_flow_id, core);
                } else if (parent_info->se_config->type == SOC_TMC_SCH_SE_TYPE_CL) {
                    BCM_COSQ_GPORT_SCHED_CIR_CORE_SET((*parent_port), base_flow_id, core);
                }
            } else {
                if ( (parent_info->se_config->type == SOC_TMC_SCH_SE_TYPE_FQ) ||
                       (parent_info->se_config->type == SOC_TMC_SCH_SE_TYPE_HR) ) {
                    BCM_COSQ_GPORT_SCHED_CIR_CORE_SET((*parent_port), base_flow_id, core);
                } else if (parent_info->se_config->type == SOC_TMC_SCH_SE_TYPE_CL) {
                    BCM_COSQ_GPORT_SCHED_PIR_CORE_SET((*parent_port), base_flow_id, core);
                }
            }
            
        }
    } else {
        /* Set parent gport to be Port gport */
        if (tc == DPP_COSQ_PB_DEFAULT_PORT_TC) {
            /* In case of TC = 0 or Petra-B compatible TC returns E2E */
            rc = bcm_petra_tm_port_get(unit, core, parent_se_port, &fap_port);
            if (rc != BCM_E_NONE) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                                    "unit %d, Error retreving port id from SE %d\n"), unit,parent_se_port));          
              goto err;
            }
            BCM_COSQ_GPORT_E2E_PORT_SET(*parent_port, fap_port);
        } else {
            /* In case of Port-TC return SCHEDULER gport */
            flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
            if (SOC_IS_QAX(unit)) { /*set out_gport to lower 64k on QAX (32k on QUX) flow range, as the user would expect*/
                flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
            }
            BCM_GPORT_SCHEDULER_CORE_SET((*parent_port), flow_id, core);  
        }
    }   

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);

exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info);
        }
        if (parent_info) {
            BCM_FREE(parent_info->flow_config);
            BCM_FREE(parent_info->se_config);
            BCM_FREE(parent_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info);
    }
    if (parent_info) {
        BCM_FREE(parent_info->flow_config);
        BCM_FREE(parent_info->se_config);
        BCM_FREE(parent_info);
    }
/* } */
#endif
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_link_fc_shaper_verify(int unit,
                                   bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (cosq != 0)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid cosq parameter 0x%x\n"), unit, cosq));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
 

int
_bcm_petra_link_fc_shaper_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    uint32 soc_sand_rc;
    bcm_error_t rc = BCM_E_NONE;
    uint32 link_ndx;
    SOC_TMC_FABRIC_FC_SHAPER info;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO shaper;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO_clear(&shaper); 
    SOC_TMC_FABRIC_FC_SHAPER_clear(&info);
    
    link_ndx = SOC_DPP_FABRIC_PORT_TO_LINK(unit, gport);

    _bcm_petra_link_fc_shaper_verify(unit, cosq);  
    BCMDNX_IF_ERR_EXIT(rc);        

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_shaper_get,(unit, link_ndx, &shaper, &info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get link %d flow control shaper parameters, soc_sand error 0x%x\n"), unit, link_ndx, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }  
        
    if (*flags & BCM_COSQ_BW_LLFC)
    {
        /* LLFC shaper */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_BYTES_MODE) {
            *kbits_sec_max = info.fc_shaper.bytes;
            *kbits_sec_min = 0;
        }    
        /* Currently cell mode is not supported */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_CELLS_MODE) {
            *kbits_sec_max = info.fc_shaper.cells;
            *kbits_sec_min = 0;            
        }
    }
    else
    {
        /* Data shaper */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_BYTES_MODE) {
            *kbits_sec_max = info.data_shaper.bytes;
            *kbits_sec_min = 0;
        }
        /* Currently cell mode is not supported */
        if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_CELLS_MODE) {
            *kbits_sec_max = info.data_shaper.cells;
            *kbits_sec_min = 0;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_link_fc_shaper_add(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 kbits_sec_min,
                                   uint32 kbits_sec_max,
                                   uint32 flags)
{
    uint32 soc_sand_rc;
    bcm_error_t rc = BCM_E_NONE;
    uint32 link_ndx;
    SOC_TMC_FABRIC_FC_SHAPER info;
    SOC_TMC_FABRIC_FC_SHAPER exact_info;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO shaper;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_SHAPER_MODE_INFO_clear(&shaper);
    SOC_TMC_FABRIC_FC_SHAPER_clear(&info);
    SOC_TMC_FABRIC_FC_SHAPER_clear(&exact_info);

    link_ndx = SOC_DPP_FABRIC_PORT_TO_LINK(unit, gport);

    _bcm_petra_link_fc_shaper_verify(unit, cosq);
    BCMDNX_IF_ERR_EXIT(rc);        

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_shaper_get,(unit, link_ndx, &shaper, &info)));
    
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get link %d flow control shaper parameters, soc_sand error 0x%x\n"), unit, link_ndx, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    

    if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_BYTES_MODE) 
    {
        if (flags & BCM_COSQ_BW_LLFC) 
        {
            info.fc_shaper.bytes = kbits_sec_max;
        } 
        else 
        {
            info.data_shaper.bytes = kbits_sec_max;
        }
    }
    /* Currently shaper cell mode is not supported */
    if (shaper.shaper_mode == SOC_TMC_FABRIC_SHAPER_CELLS_MODE) 
    {        
        if (flags & BCM_COSQ_BW_LLFC) 
        {
            info.fc_shaper.cells = kbits_sec_max;
        } 
        else
        {
            info.data_shaper.cells = kbits_sec_max;
        }
    }
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_shaper_set,(unit, link_ndx, &shaper, &info, &exact_info)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
       LOG_ERROR(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit %d, failed to set link %d flow control shaper parameters, soc_sand error 0x%x\n"), unit, link_ndx, soc_sand_rc));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(int unit, int core, uint32 pps, uint32 *kbps)
{
    uint32 num_of_bytes_per_packet;

    BCMDNX_INIT_FUNC_DEFS;

    /* get num of bytes per packet */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_packet_mode_packet_size_get,(unit, core, &num_of_bytes_per_packet)));

    *kbps = pps*num_of_bytes_per_packet*8/1000;

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(int unit, int core, uint32 kbps, uint32 *pps)
{
    uint32 num_of_bytes_per_packet;

    BCMDNX_INIT_FUNC_DEFS;

    /* get num of bytes per packet */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_packet_mode_packet_size_get,(unit, core, &num_of_bytes_per_packet)));

    *pps = (kbps*1000)/(8*num_of_bytes_per_packet);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_bandwidth_set(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 kbits_sec_min,
                                   uint32 kbits_sec_max,
                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_port_t port;
    bcm_gport_t parent_port;
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, 1, &parent_port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* link shaper configuration */
    if (!BCM_GPORT_IS_SET(gport) && SOC_PORT_VALID(unit, gport) && IS_SFI_PORT(unit,gport)) {       
        rc =  _bcm_petra_link_fc_shaper_add(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        BCMDNX_IF_ERR_EXIT(rc);
    } 
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(parent_port) 
        || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(parent_port)
        || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(parent_port)) {
        rc = _bcm_petra_cosq_gport_fmq_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    } 
    else if (BCM_COSQ_GPORT_IS_ISQ_ROOT(gport)) {
      rc = _bcm_petra_cosq_gport_isq_bandwidth_set(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }    
    /* Ingress scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_set(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_set(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    /* E2E scheduler */
    else if ((BCM_GPORT_IS_SCHEDULER(parent_port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(parent_port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(parent_port))) {   
        rc = _bcm_petra_cosq_gport_flow_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(parent_port)) {

        port = BCM_COSQ_GPORT_E2E_PORT_GET(parent_port);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            rc = _bcm_petra_cosq_gport_e2e_interface_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            rc = _bcm_petra_cosq_gport_e2e_port_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(parent_port)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(parent_port)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }

    /* Egress transmit scheduler */

    else if (BCM_GPORT_IS_LOCAL(parent_port) || BCM_GPORT_IS_MODPORT(parent_port)) {
        if (BCM_GPORT_IS_LOCAL(parent_port)) {
            port = BCM_GPORT_LOCAL_GET(parent_port);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(parent_port);
        }        


        if (BCM_DPP_PORT_IS_INTERFACE(port)) {        
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            /* Egress scheduler port */
            rc = _bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);           
        }
    } 
    else if (BCM_COSQ_GPORT_IS_PORT_TC(parent_port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(parent_port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_bandwidth_set(unit, parent_port, cosq, kbits_sec_min, kbits_sec_max, flags);
    }

    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, gport(0x%08x) not supported \n"), unit, gport));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int port = 0;
    bcm_gport_t res_gport;
    

    BCMDNX_INIT_FUNC_DEFS;

    /* determine if gport refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, 1, &res_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Link shaper configuration */
    if (!BCM_GPORT_IS_SET(gport) && SOC_PORT_VALID(unit, gport) && IS_SFI_PORT(unit,gport)) {
        rc =  _bcm_petra_link_fc_shaper_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        BCMDNX_IF_ERR_EXIT(rc);
    }  

    /* Egress transmit scheduler */
    else if (BCM_GPORT_IS_LOCAL(res_gport) ||
         BCM_GPORT_IS_MODPORT(res_gport)) {

        if (BCM_GPORT_IS_LOCAL(res_gport)) {
            port = BCM_GPORT_LOCAL_GET(res_gport);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(res_gport);
        }        
        
        if (BCM_DPP_PORT_IS_INTERFACE(port)) {  
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            /* Egress scheduler port */
            rc = _bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }   

    else if (BCM_COSQ_GPORT_IS_PORT_TC(res_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tc_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(res_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_gport_egress_port_tcg_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
        rc = _bcm_petra_cosq_gport_fmq_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    } 
    else if (BCM_COSQ_GPORT_IS_ISQ_ROOT(gport)) {
        rc = _bcm_petra_cosq_gport_isq_bandwidth_get(unit, gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    
    /* Ingress Scheduler */
    else if (BCM_GPORT_IS_FABRIC_CLOS(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_get(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_GPORT_IS_FABRIC_MESH(gport)) {
        rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_get(unit, gport, kbits_sec_min, kbits_sec_max, flags);
    }

    /* E2E scheduler */
    else if ( (BCM_GPORT_IS_SCHEDULER(res_gport)) ||
              (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_PIR(res_gport)) ||
              (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(res_gport)) ) {
            rc = _bcm_petra_cosq_gport_flow_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(res_gport)) {

        port = BCM_COSQ_GPORT_E2E_PORT_GET(res_gport);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            rc = _bcm_petra_cosq_gport_e2e_interface_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        } else {
            rc = _bcm_petra_cosq_gport_e2e_port_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(res_gport)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tc_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(res_gport)) {
        rc = _bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_get(unit, res_gport, cosq, kbits_sec_min, kbits_sec_max, flags);
    }
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, gport(0x%08x) not supported \n"), unit, gport));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_size_set(int unit,
                        bcm_gport_t gport,
                        bcm_cos_queue_t cosq,
                        uint32 bytes_min,
                        uint32 bytes_max)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_size_get(int unit,
                        bcm_gport_t gport,
                        bcm_cos_queue_t cosq,
                        uint32 *bytes_min,
                        uint32 *bytes_max)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_color_size_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    bcm_color_t color,
                                    uint32 flags,
                                    bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) ||
        BCM_GPORT_IS_PROFILE(gport) ) {
        rc = _bcm_petra_cosq_gport_voq_color_size_get(unit, gport, cosq, color, flags, gport_size);
    }   
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            rc = _bcm_petra_cosq_gport_vsq_color_size_get(unit, gport, cosq, color, flags, gport_size);
    }
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_color_size_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    bcm_color_t color,
                                    uint32 flags,
                                    bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) {
            rc = _bcm_petra_cosq_gport_voq_color_size_set(unit, gport, cosq, color, flags, gport_size);
    }
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
            rc = _bcm_petra_cosq_gport_vsq_color_size_set(unit, gport, cosq, color, flags, gport_size);
    } 
    if (BCM_GPORT_IS_PROFILE(gport)) {
        rc = _bcm_petra_cosq_gport_rate_class_color_size_set(unit,gport,color,flags,gport_size);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_discard_set(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_PORT;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_PROFILE(gport) ) {
        rc = _bcm_petra_cosq_gport_voq_discard_set(unit, gport, cosq, discard);
    }
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        rc = _bcm_petra_cosq_gport_vsq_discard_set(unit, gport, cosq, discard);
    }
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_discard_get(int unit, 
                                 bcm_gport_t gport, 
                                 bcm_cos_queue_t cosq, 
                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_PORT;

    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_PROFILE(gport)) {
        rc = _bcm_petra_cosq_gport_voq_discard_get(unit, gport, cosq, discard);
    }

    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        rc = _bcm_petra_cosq_gport_vsq_discard_get(unit, gport, cosq, discard);
    } 
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_petra_cosq_gport_ingress_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{

    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;


    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        int vsq_type;
        
        vsq_type = BCM_DPP_COSQ_GPORT_VSQ_TYPE_GET(gport);
        if (vsq_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
            if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flag BCM_COSQ_THRESHOLD_NOT_COMMIT is not supported. flags 0x%x"), unit,threshold->flags));
            }
            
            /* Drop Threshold set */
            if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) { 
                /* VSQ gl tail drop thresholds */
                rc = _bcm_petra_cosq_vsq_gl_drop_threshold_set(unit, gport, cosq, threshold);    
                BCMDNX_IF_ERR_EXIT(rc);                
            }
            
            /* Flow control set */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {                    
                /* VSQ gl fc thresholds */
                rc = _bcm_petra_cosq_vsq_gl_fc_thresh_set(unit, gport, cosq, threshold);    
                BCMDNX_IF_ERR_EXIT(rc);
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported vsq gport type 0x%x"), unit,vsq_type));
        }        
    } else if (threshold->flags & BCM_COSQ_THRESHOLD_QSIZE_RECOVERY) {
        rc = _bcm_petra_cosq_dram_bound_recovery_set(unit,gport,cosq,threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    } else if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)){
        /* OCB eligibility */
        if((threshold->flags & (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_OCB))){
            rc = _bcm_petra_cosq_voq_ocb_threshold_set(unit, gport, cosq, threshold);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    } else if (BCM_GPORT_IS_PROFILE(gport)) { 
        rc = _bcm_petra_cosq_rate_class_ocb_threshold_set(unit,gport,cosq,threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport for ingress thresholds 0x%x"), unit,gport));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_egress_drop_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* null gport or core gport */
    if (gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) 
    {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
        {
            if(cosq == -1) 
            {
                rc = _bcm_petra_cosq_gport_egress_device_uc_drop_threshold_set(unit, gport, cosq, threshold); 
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }

        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) 
        {
            if(cosq == -1)
            {
                /* Device wide flow control mci threshold */                
                rc = _bcm_petra_cosq_gport_egress_device_mc_drop_threshold_set(unit, gport, cosq, threshold);           
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) {

            if(cosq == -1) {
                rc = _bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_set(unit, gport, cosq, 0, threshold); 
            }
            else
            {
                rc = _bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(unit, gport, cosq, 0, threshold); 
            }         
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1) {

            if(cosq == -1) {
                rc = _bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_set(unit, gport, cosq, 1, threshold); 
            }
            else
            {
                rc = _bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(unit, gport, cosq, 1, threshold); 
            }
            
        } else { /* i.e. set all */
            if(cosq == -1) {
                rc = _bcm_petra_cosq_gport_egress_device_all_drop_threshold_set(unit, gport, cosq, threshold); 
            }
            else
            {
              BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc);
         
    /* else - using specific gport */
    } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) { /* Egress UC Queue drop thresholds */
        rc = _bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_set(unit, gport, cosq, threshold); 
        BCMDNX_IF_ERR_EXIT(rc);
    
    } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) { /* Egress MC Queue drop thresholds*/
        rc = _bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {

        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DPP_PORT_IS_INTERFACE(gport_lcl)) {       
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_interface_egress_threshold_set(unit, gport, cosq, threshold);
            BCMDNX_IF_ERR_EXIT(rc);
        }
                
        
    }
    else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d , Unsupported gport for the type BCM_COSQ_THRESHOLD_DROP \n"), unit));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_egress_sp_reserved_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc= BCM_E_NONE;

    int core_iterator, core, sp;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */
    
    if (!( threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    } 

    sp = (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) ? 0:1;  

    if (!(gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)))
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected core gport %x"), gport));
      

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_core_get(unit,gport, 1, &core_iterator));

    SOC_DPP_CORES_ITER(core_iterator, core)
    {      
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_sp_reserved_set ,(unit, core, cosq, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_service_pool_0 +  sp)));
        BCMDNX_IF_ERR_EXIT(rc); 
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_petra_cosq_gport_egress_sp_reserved_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc= BCM_E_NONE;
    int core, sp;
        
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */
    
    if (!( threshold->type == bcmCosqThresholdAvailablePacketDescriptors
           || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    } 

    if (!(gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)))
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected core gport %x"), gport));

    sp = (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) ? 0 : 1; 
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_core_get(unit,gport,0,&core));

    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_sp_reserved_get ,(unit, core, cosq, (soc_dpp_cosq_threshold_type_t)threshold->type, &threshold->value, soc_dpp_cosq_threshold_global_type_service_pool_0 +  sp)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_petra_cosq_gport_egress_fc_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    
    /* Egress device wide flow control */
    /* null gport equals 0 */
    if (gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
            /* Device wide flow control sheduled threshold */
            rc = _bcm_petra_cosq_gport_egress_device_uc_fc_threshold_set(unit, gport, cosq, threshold); 
            
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {           
            /* Device wide flow control unscheduled threshold */                   
            rc = _bcm_petra_cosq_gport_egress_device_mc_fc_threshold_set(unit, gport, cosq, threshold);   
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0){
            /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(unit, gport, cosq, 0, threshold); 
                  
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1){
            /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(unit, gport, cosq, 1, threshold);                
        }
        else {
            /* Device wide flow control global threshold */
            rc = _bcm_petra_cosq_gport_egress_device_all_fc_threshold_set(unit, gport, cosq, threshold); 
        }
    }
    /* Egress scheduler port, channelized issues: */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DPP_PORT_IS_INTERFACE(gport_lcl)) {
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_interface_egress_threshold_set(unit, gport, cosq, threshold);
        }
    }
    /* Egress UC Queue fc thresholds */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_set(unit, gport, cosq, threshold);
    }
    else {
        rc = BCM_E_PARAM;
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_FLOW_CONTROL \n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_petra_cosq_gport_egress_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint8   traffic_en = 0;
    uint32  soc_sand_rc = SOC_SAND_OK;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid flags %d"), unit ,threshold->flags));
    }

    /* Traffic Enabled Restriction */
    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors ||
       threshold->type == bcmCosqThresholdAvailableDataBuffers)
    {
      soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_enable_traffic_get,(unit, &traffic_en)));
      BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
      if(traffic_en == TRUE)
      {
        /* Check the override flag for allowing modifications during traffic */
        if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "allow_modifications_during_traffic", 0) == 0)
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, changing thresholds of %d is not allowed while traffic is enabled"), 
                                            unit ,threshold->type));
        }
      }
    }

    /* verify types per device */

    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_threshold_types_verify, (unit, (soc_dpp_cosq_threshold_type_t)threshold->type)));
    BCMDNX_IF_ERR_EXIT(rc);

    /*check cosq validity*/

    rc = _bcm_petra_egress_cosq_validate(unit, cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Drop Threshold set */
    if (threshold->flags & BCM_COSQ_THRESHOLD_DROP)
    {
       rc = _bcm_petra_cosq_gport_egress_drop_threshold_set(unit, gport, cosq, threshold);
       BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* Flow control set */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) 
    {
        rc = _bcm_petra_cosq_gport_egress_fc_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    /* MC SP Reserved */
    else if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) || (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1))
    {
        rc = _bcm_petra_cosq_gport_egress_sp_reserved_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_system_red_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO info;
    
    BCMDNX_INIT_FUNC_DEFS;
  
    SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO_clear(&info);    
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_glob_rcs_get,(unit, &info)));
    
    /* Set system RED Dbuff Thresholds/Values */
    if (threshold->type == bcmCosqThresholdDbuffs && !SOC_IS_QAX(unit)) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.unicast_rng_ths[0] = threshold->value;
            info.values.unicast_rng_vals[0]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.unicast_rng_ths[1] = threshold->value;
            info.values.unicast_rng_vals[1]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.unicast_rng_ths[2] = threshold->value;
            info.values.unicast_rng_vals[2]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.unicast_rng_vals[3]    = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdFullDbuffs && !SOC_IS_QAX(unit)) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.multicast_rng_ths[0] = threshold->value;
            info.values.multicast_rng_vals[0]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.multicast_rng_ths[1] = threshold->value;
            info.values.multicast_rng_vals[1]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.multicast_rng_ths[2] = threshold->value;
            info.values.multicast_rng_vals[2]    = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.multicast_rng_vals[3]    = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.bds_rng_ths[0] = threshold->value;
            info.values.bds_rng_vals[0]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.bds_rng_ths[1] = threshold->value;
            info.values.bds_rng_vals[1]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.bds_rng_ths[2] = threshold->value;
            info.values.bds_rng_vals[2]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.bds_rng_vals[3]   = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdOcbDbuffs) {
        if      (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.ocb_rng_ths[0] = threshold->value;
            info.values.ocb_rng_vals[0]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.ocb_rng_ths[1] = threshold->value;
            info.values.ocb_rng_vals[1]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.ocb_rng_ths[2] = threshold->value;
            info.values.ocb_rng_vals[2]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.ocb_rng_vals[3]   = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdOcbPacketDescriptorBuffers && SOC_IS_QAX(unit)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            info.thresholds.ocb_pdbs_rng_ths[0] = threshold->value;
            info.values.ocb_pdbs_rng_vals[0]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            info.thresholds.ocb_pdbs_rng_ths[1] = threshold->value;
            info.values.ocb_pdbs_rng_vals[1]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            info.thresholds.ocb_pdbs_rng_ths[2] = threshold->value;
            info.values.ocb_pdbs_rng_vals[2]   = threshold->dp;
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            info.values.ocb_pdbs_rng_vals[3]   = threshold->dp;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else {
        /* Must use one of these threshold type  */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter\n"), unit));
    } 
    
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_glob_rcs_set,(unit, &info)));      
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_rci_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_set, 
                                      (unit, gport, threshold->value, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_set, 
                                      (unit, gport, threshold->value, soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
        }
    
    }
    
exit:
    BCMDNX_FUNC_RETURN;

}

int
_bcm_petra_cosq_gport_per_dp_drop_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        soc_cosq_threshold_t soc_threshold;
        soc_threshold.value = threshold->value;
        soc_threshold.dp = threshold->dp;
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_set,
                                      (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_set, 
                                      (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_set, 
                                      (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
       }
   }
   
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_gport_eth_port_threshold_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_port_t port = 0;
    SOC_TMC_FC_PORT_FIFO_TH fc_fifo_th;

    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        if (BCM_GPORT_IS_LOCAL(gport)) {
            port = BCM_GPORT_LOCAL_GET(gport);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(gport);
        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport(0x%x) for BCM_COSQ_THRESHOLD_ETH_PORT_LLFC/PFC"), unit, port));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_port_fifo_threshold_get,(unit, port, &fc_fifo_th)));

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) {
        /* set RX PORT FIFO Link Level Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) { 
            fc_fifo_th.llfc.set = threshold->value;
        }
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            fc_fifo_th.llfc.clear = threshold->value;
        }
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC) {
        /* set RX PORT FIFO Priority Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) { 
            fc_fifo_th.pfc.set = threshold->value;
        }
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            fc_fifo_th.pfc.clear = threshold->value;
        }
    }

    /* Set information */
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_port_fifo_threshold_set, (unit, port, &fc_fifo_th)));
   
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_cosq_gport_threshold_set(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_NULL_CHECK(threshold);
    /* Ingress tresholds */
    if (threshold-> flags & BCM_COSQ_THRESHOLD_INGRESS) 
    {
        rc = _bcm_petra_cosq_gport_ingress_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Egress configuration */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_EGRESS)
    {
        rc = _bcm_petra_cosq_gport_egress_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_COLOR_SYSTEM_RED)
    {
        rc = _bcm_petra_cosq_gport_system_red_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);

    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_RCI) 
    {
        rc = _bcm_petra_cosq_gport_rci_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);

    }

    else if (threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP)) 
    {
        rc =  _bcm_petra_cosq_gport_per_dp_drop_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    } 
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_ETH_PORT_LLFC | BCM_COSQ_THRESHOLD_ETH_PORT_PFC))
    {
        rc = _bcm_petra_cosq_gport_eth_port_threshold_set(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else 
    {/* i.e. invalid parameter*/
        rc = BCM_E_PARAM;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_petra_cosq_gport_ingress_threshold_get(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        int vsq_type;
        
        vsq_type = BCM_DPP_COSQ_GPORT_VSQ_TYPE_GET(gport);
        if (vsq_type == BCM_DPP_COSQ_VSQ_TYPE_GLOBAL) {
            if (threshold->flags & BCM_COSQ_THRESHOLD_NOT_COMMIT) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported flags 0x%x"), unit,threshold->flags));
            }
                    
            /* Drop Threshold get */
            if (threshold->flags & BCM_COSQ_THRESHOLD_DROP) { 
                /* VSQ gl tail drop thresholds */
                rc = _bcm_petra_cosq_vsq_gl_drop_threshold_get(unit, gport, cosq, threshold);    
                BCMDNX_IF_ERR_EXIT(rc);                
            }

            /* Flow control get */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {                    
                /* vsq gl flow control thresholds */
                rc = _bcm_petra_cosq_vsq_gl_fc_thresh_get(unit, gport, cosq, threshold);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported vsq gport type 0x%x"), unit,gport));
        }        
    } 
    else if (threshold->flags & BCM_COSQ_THRESHOLD_QSIZE_RECOVERY) {
        rc = _bcm_petra_cosq_dram_bound_recovery_get(unit,gport,cosq,threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)){
        if((threshold->flags & (BCM_COSQ_THRESHOLD_UNICAST | BCM_COSQ_THRESHOLD_OCB))){
            rc = _bcm_petra_cosq_voq_ocb_threshold_get(unit, gport, cosq, threshold);
            BCMDNX_IF_ERR_EXIT(rc);
        } 
    } else if (BCM_GPORT_IS_PROFILE(gport)) {
        rc = _bcm_petra_cosq_rate_class_ocb_threshold_get(unit,gport,cosq,threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport for ingress thresholds 0x%x"), unit,gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);  

exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_egress_drop_threshold_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
  
    if (gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
            if(cosq == -1) 
            {
                rc = _bcm_petra_cosq_gport_egress_device_uc_drop_threshold_get(unit, gport, cosq, threshold); 
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) {
            if(cosq == -1) 
            {
                rc = _bcm_petra_cosq_gport_egress_device_mc_drop_threshold_get(unit, gport, cosq, threshold); 
            }
            else
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }
        } else if(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0){            
            if(cosq == -1) 
            {
                rc = _bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_get(unit, gport, cosq, 0, threshold);
            }
            else
            {
                rc = _bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(unit, gport, cosq, 0, threshold); 
            }
        } else if(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1){     
                if(cosq == -1) 
                {
                    rc = _bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_get(unit, gport, cosq, 1, threshold); 
                }
                else
                {
                    rc = _bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(unit, gport, cosq, 1, threshold); 
                }
        }
        else
        {/* i.e all*/ 
            if(cosq == -1) 
            {
                rc = _bcm_petra_cosq_gport_egress_device_all_drop_threshold_get(unit, gport, cosq, threshold);
            }
            else {
               BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d Unsupported for drop thresholds with cosq %d\n"), unit,cosq));
            }

        } 
    /* Egress UC Queue drop thresholds */
    } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_get(unit, gport, cosq, threshold);         
    /* Egress MC Queue drop thresholds*/
    } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_get(unit, gport, cosq, threshold); 
        BCMDNX_IF_ERR_EXIT(rc);
    } else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DPP_PORT_IS_INTERFACE(gport_lcl)) {
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_interface_egress_threshold_get(unit, gport, cosq, threshold);
        }
    } else {
        rc = BCM_E_PARAM;
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_DROP \n"), unit));
    }
    
    BCMDNX_IF_ERR_EXIT(rc);  
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_egress_fc_threshold_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    /* Egress device wide flow control */
    /* gport 0 equals gport null */
    if (gport == 0  || BCM_COSQ_GPORT_IS_CORE(gport)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) 
        {
            /* Device wide flow control sheduled threshold */
            rc = _bcm_petra_cosq_gport_egress_device_uc_fc_threshold_get(unit, gport, cosq, threshold); 
        } 
        else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST) 
        {
                /* Device wide flow control unscheduled threshold */
            rc = _bcm_petra_cosq_gport_egress_device_mc_fc_threshold_get(unit, gport, cosq, threshold);                       
        } 
        else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0)
        {
                /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(unit, gport, cosq, 0, threshold);   
        } 
        else if (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1)
        {
                /* Device wide flow control unscheduled threshold per service pool */
            rc = _bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(unit, gport, cosq, 1, threshold);
        }       
        else 
        {
            /* Device wide flow control global threshold */
            rc = _bcm_petra_cosq_gport_egress_device_all_fc_threshold_get(unit, gport, cosq, threshold);
        }
    }
    /* Egress scheduler port, channelized issues */
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        bcm_port_t gport_lcl;
        if (BCM_GPORT_IS_LOCAL(gport)) {
            gport_lcl = BCM_GPORT_LOCAL_GET(gport);
        } else {
            gport_lcl = BCM_GPORT_MODPORT_PORT_GET(gport);
        }        
        if (BCM_DPP_PORT_IS_INTERFACE(gport_lcl)) {
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_gport_interface_egress_threshold_get(unit, gport, cosq, threshold);
        }
        else
        {
            /* Egress scheduler port */
        }
     }
        
    /* Egress UC Queue fc thresholds */
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_get(unit, gport, cosq, threshold);
    }

    else {
        rc = BCM_E_PARAM;
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Unsupported gport for the type BCM_COSQ_THRESHOLD_FLOW_CONTROL \n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_egress_threshold_get(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    /*check cosq validity*/

    rc = _bcm_petra_egress_cosq_validate(unit, cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    /*verify types per device */

    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_threshold_types_verify, (unit, (soc_dpp_cosq_threshold_type_t)threshold->type)));
    BCMDNX_IF_ERR_EXIT(rc);

    /* Drop Threshold get */
    if (threshold->flags & BCM_COSQ_THRESHOLD_DROP)
    {
        rc = _bcm_petra_cosq_gport_egress_drop_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Flow control get */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) 
    {
        rc = _bcm_petra_cosq_gport_egress_fc_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* MC SP Reserved */
    else if ((threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP0) || (threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST_SP1))
    {
        rc = _bcm_petra_cosq_gport_egress_sp_reserved_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }        
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_gport_system_red_threshold_get(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               bcm_cosq_threshold_t *threshold)
{
    SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO info;
   
    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_ITM_SYS_RED_GLOB_RCS_INFO_clear(&info);

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_glob_rcs_get,(unit, &info)));

    /* Set system RED Dbuff Thresholds/Values */
    if (threshold->type == bcmCosqThresholdDbuffs && !SOC_IS_QAX(unit)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.unicast_rng_ths[0];
            threshold->dp    = info.values.unicast_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.unicast_rng_ths[1];
            threshold->dp    = info.values.unicast_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.unicast_rng_ths[2];
            threshold->dp    = info.values.unicast_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.unicast_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdFullDbuffs && !SOC_IS_QAX(unit)) {
        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.multicast_rng_ths[0];
            threshold->dp    = info.values.multicast_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.multicast_rng_ths[1];
            threshold->dp    = info.values.multicast_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.multicast_rng_ths[2];
            threshold->dp    = info.values.multicast_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.multicast_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdBufferDescriptorBuffers) {

        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.bds_rng_ths[0];
            threshold->dp    = info.values.bds_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.bds_rng_ths[1];
            threshold->dp    = info.values.bds_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.bds_rng_ths[2];
            threshold->dp    = info.values.bds_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.bds_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdOcbDbuffs) {

        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.ocb_rng_ths[0];
            threshold->dp    = info.values.ocb_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.ocb_rng_ths[1];
            threshold->dp    = info.values.ocb_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.ocb_rng_ths[2];
            threshold->dp    = info.values.ocb_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.ocb_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else if (threshold->type == bcmCosqThresholdOcbPacketDescriptorBuffers && SOC_IS_QAX(unit)) {

        if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) {
            threshold->value = info.thresholds.ocb_pdbs_rng_ths[0];
            threshold->dp    = info.values.ocb_pdbs_rng_vals[0];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1) {
            threshold->value = info.thresholds.ocb_pdbs_rng_ths[1];
            threshold->dp    = info.values.ocb_pdbs_rng_vals[1];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_2) {
            threshold->value = info.thresholds.ocb_pdbs_rng_ths[2];
            threshold->dp    = info.values.ocb_pdbs_rng_vals[2];
        } else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_3) {
            threshold->dp    = info.values.ocb_pdbs_rng_vals[3];
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_THRESHOLD_RANGE_0\1\2\3\n"), unit, threshold->flags));
        }
    } else {
        /* Must use one of these threshold type  */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter\n"), unit));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_rci_threshold_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_get, 
                                      (unit, gport, &(threshold->value), soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_UCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_rci_threshold_get, 
                                      (unit, gport, &(threshold->value), soc_dpp_cosq_gport_egress_core_fifo_local_ucast));
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_per_dp_drop_threshold_get(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    if (threshold->type == bcmCosqThresholdPackets) {
        soc_cosq_threshold_t soc_threshold;
        sal_memset(&soc_threshold, 0x0, sizeof(soc_threshold));
        soc_threshold.dp = threshold->dp;
        if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_get, 
                                      (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_get, 
                                      (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
        }
        else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(gport)) {
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_gport_priority_drop_threshold_get, 
                                      (unit, gport, &soc_threshold, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
        }
        else {
            /* Must use one of these gport types  */
            BCMDNX_ERR_EXIT_MSG( BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport type parameter\n"), unit));
        }
        threshold->value = soc_threshold.value;
    }

    BCMDNX_IF_ERR_EXIT(rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_eth_port_threshold_get(int unit,
                                                 bcm_gport_t gport,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_threshold_t *threshold)
{
    bcm_port_t port = 0;
    SOC_TMC_FC_PORT_FIFO_TH fc_fifo_th;
    BCMDNX_INIT_FUNC_DEFS;

    if ((threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) && (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_ETH_PORT_LLFC and BCM_COSQ_THRESHOLD_ETH_PORT_PFC cannot be used together\n"), 
            unit, threshold->flags));
    }

    if ((threshold->flags & BCM_COSQ_THRESHOLD_SET) && (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags(0x%x) : BCM_COSQ_THRESHOLD_SET and BCM_COSQ_THRESHOLD_CLEAR cannot be used together\n"), 
            unit, threshold->flags));
    }

    if (!(threshold->flags & (BCM_COSQ_THRESHOLD_SET | BCM_COSQ_THRESHOLD_CLEAR))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Need to set at least one of flags BCM_COSQ_THRESHOLD_SET BCM_COSQ_THRESHOLD_CLEAR\n"), unit));
    }

    if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        if (BCM_GPORT_IS_LOCAL(gport)) {
            port = BCM_GPORT_LOCAL_GET(gport);
        } else {
            port = BCM_GPORT_MODPORT_PORT_GET(gport);
        }
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported gport(0x%x) for BCM_COSQ_THRESHOLD_ETH_PORT_LLFC/PFC"), unit, gport));
    }

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_port_fifo_threshold_get,(unit, port, &fc_fifo_th)));

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_LLFC) {
        /* get RX PORT FIFO Link Level Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) {
            threshold->value = fc_fifo_th.llfc.set;
        }
        
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            threshold->value = fc_fifo_th.llfc.clear;
        }
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_ETH_PORT_PFC) {
        /* get RX PORT FIFO Priority Flow Control geneeration thresholds */
        if (threshold->flags & BCM_COSQ_THRESHOLD_SET) {
            threshold->value = fc_fifo_th.pfc.set;
        }
        
        if (threshold->flags & BCM_COSQ_THRESHOLD_CLEAR) { 
            threshold->value = fc_fifo_th.pfc.clear;
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}



int
bcm_petra_cosq_gport_threshold_get(int unit,
                             bcm_gport_t gport,
                             bcm_cos_queue_t cosq,
                             bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    
    if (threshold-> flags & BCM_COSQ_THRESHOLD_INGRESS) 
    {
        rc = _bcm_petra_cosq_gport_ingress_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Egress configuration */
    else if (threshold->flags & BCM_COSQ_THRESHOLD_EGRESS)  
    {
        rc = _bcm_petra_cosq_gport_egress_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_COLOR_SYSTEM_RED) 
    {
        rc = _bcm_petra_cosq_gport_system_red_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_RCI)
    {
        rc = _bcm_petra_cosq_gport_rci_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_PER_DP | BCM_COSQ_THRESHOLD_DROP))
    {
        rc = _bcm_petra_cosq_gport_per_dp_drop_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (threshold->flags & (BCM_COSQ_THRESHOLD_ETH_PORT_LLFC | BCM_COSQ_THRESHOLD_ETH_PORT_PFC))
    {
        rc = _bcm_petra_cosq_gport_eth_port_threshold_get(unit, gport, cosq, threshold);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else
    {/*i.e. invalid parameter*/
        rc = BCM_E_PARAM;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_cosq_gport_egress_map_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_t ingress_pri,
                              bcm_color_t ingress_dp,
                              bcm_cos_queue_t offset)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;


    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_map_set(unit, gport, ingress_pri, ingress_dp, offset);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG( BCM_E_PORT, (_BSL_BCM_MSG("Unsupported gport type parameter 0x%x"), gport));
    }

    

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_egress_map_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_t ingress_pri,
                              bcm_color_t ingress_dp,
                              bcm_cos_queue_t *offset)
{
    bcm_error_t rc;
    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        rc = _bcm_petra_cosq_gport_egress_queue_map_get(unit, gport, ingress_pri, ingress_dp, offset);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG( BCM_E_PORT, (_BSL_BCM_MSG("Unsupported gport type parameter 0x%x"), gport));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_egress_multicast_config_set(int unit, 
                                           bcm_gport_t gport, 
                                           bcm_cos_t ingress_pri, 
                                           bcm_color_t ingress_dp, 
                                           uint32 flags, 
                                           bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    uint8   traffic_en = 0;
    uint32  soc_sand_rc = SOC_SAND_OK;

    BCMDNX_INIT_FUNC_DEFS;

    /* Traffic Enabled Restriction */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mgmt_enable_traffic_get,(unit, &traffic_en)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    if(traffic_en == TRUE)
    {
        /* Check the override flag for allowing modifications during traffic */
        if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "allow_modifications_during_traffic", 0) == 0)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, changing MC TC mapping is not allowed while traffic is enabled"), unit));
        }
    }


    if((gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) && (flags & BCM_COSQ_MULTICAST_UNSCHEDULED )) {
        rc = _bcm_petra_cosq_device_egress_multicast_config_set(unit, gport, ingress_pri, ingress_dp, flags, config); 
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if ((BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) && (flags & BCM_COSQ_MULTICAST_SCHEDULED )) {
        rc = _bcm_petra_cosq_gport_egress_multicast_config_set(unit, gport, ingress_pri, ingress_dp, flags, config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port parameter")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_egress_multicast_config_get(int unit, 
                                           bcm_gport_t gport, 
                                           bcm_cos_t ingress_pri, 
                                           bcm_color_t ingress_dp, 
                                           uint32 flags, 
                                           bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if((gport == 0 || BCM_COSQ_GPORT_IS_CORE(gport)) && (flags & BCM_COSQ_MULTICAST_UNSCHEDULED )) {
        rc = _bcm_petra_cosq_device_egress_multicast_config_get(unit, gport, ingress_pri, ingress_dp, flags, config); 
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else if (BCM_GPORT_IS_LOCAL(gport) || BCM_GPORT_IS_MODPORT(gport)) {
        rc = _bcm_petra_cosq_gport_egress_multicast_config_get(unit, gport, ingress_pri, ingress_dp, flags, config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port parameter")));
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_connection_set(int unit,
                                    bcm_cosq_gport_connection_t *gport_connect)
{
    bcm_error_t rc = BCM_E_NONE;
    int is_ingress = FALSE, is_egress = FALSE, is_remove = FALSE;
    int my_modid;
    int nbr_cos = 0, nbr_quads = 0, cur_quad, i;
    int base_qid, egress_base_cid, ingress_base_cid, base_cid_i, queue_region, flow_id, flow_id_i, flow_region, is_odd_even;
    int                              is_cl_cir;
    uint8 sw_state_flags;

    uint8 is_non_contiguous, is_composite;
    SOC_TMC_IPQ_QUARTET_MAP_INFO queue_map_info;
    SOC_TMC_SCH_FLOW sch_flow;
    SOC_TMC_SCH_QUARTET_MAPPING_INFO quartet_flow_info;
    uint32 soc_sand_rc, nof_remote_cores;
    int nbr_flow_quartets;
    int updated_base_cid;
    uint8 sw_state_num_cos;
    /*
     * Just load some initial value to be on the safe side. Overwritten below.
     */
    int ingress_core = 0 ;
    int egress_core = 0 ;
    int core_id = 0;

    int modid_override = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* consistency checks */
    if (gport_connect == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport_connect parameter needs to be specified"), unit));
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "  DBG, flags (0x%x), remoteModid (%d)\n"), gport_connect->flags, gport_connect->remote_modid));

    if (gport_connect->flags & ~(BCM_COSQ_GPORT_CONNECTION_INGRESS | BCM_COSQ_GPORT_CONNECTION_EGRESS | BCM_COSQ_GPORT_CONNECTION_INVALID | BCM_COSQ_GPORT_CONNECTION_MODID_OVERRIDE)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, gport_connect->flags));
    }

    is_ingress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INGRESS) ? TRUE : FALSE;
    is_egress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_EGRESS) ? TRUE : FALSE;
    is_remove = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INVALID) ? TRUE : FALSE; 
    modid_override = ((gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_MODID_OVERRIDE) && is_ingress) ? TRUE : FALSE; 

    if ( (is_ingress == FALSE) && (is_egress == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flags parameter(0x%x) need to specify ingresss/egress"), unit, gport_connect->flags));
    }

    if ( (is_ingress == TRUE) && (is_egress == TRUE) ) {
        rc = bcm_petra_stk_my_modid_get(unit, &my_modid);
        if (rc) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "my modid invalid bcm_petra_stk_my_modid_get() rc=%s\n"), bcm_errmsg(rc)));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        if (gport_connect->remote_modid != my_modid) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, modid specified (%d) needs to be the local modid when ingress & egress are specified"), unit, gport_connect->remote_modid));
        }
    }

    if ( !(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq) ||
       BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq) ||
       BCM_COSQ_GPORT_IS_ISQ(gport_connect->voq)) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ucast/mcast/isq gport 0x%x"), unit, gport_connect->voq));
    }
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq)) {
        base_qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_connect->voq);
        ingress_core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_connect->voq);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(gport_connect->voq);
        ingress_core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_connect->voq);
    } else {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport_connect->voq);
        ingress_core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_connect->voq);
    }
    if ((ingress_core < 0 || ingress_core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && ingress_core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) VOQ gport(0x%08x) core out of range %d"), unit, gport_connect->voq, ingress_core));
    }
    if (ingress_core == BCM_CORE_ALL && !SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) VOQ gport(0x%08x), connot map both VOQs in assymetric mode."), unit, gport_connect->voq));
    }
    if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_connect->voq_connector)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid connector gport 0x%x"), unit, gport_connect->voq_connector));
    }
    egress_core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_connect->voq_connector) ;
    ingress_base_cid = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport_connect->voq_connector);
    if (SOC_IS_QAX(unit)) {
        egress_base_cid = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, ingress_base_cid);
    } else {
        egress_base_cid = ingress_base_cid;
    }
    LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "  DBG, Base_CID (0x%x)\n"), ingress_base_cid));

    if (is_ingress) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,ingress_core , base_qid), &sw_state_num_cos));
        nbr_cos = sw_state_num_cos;    
        if (nbr_cos > 8) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) cid(%d) internal state get error\n"), unit, ingress_base_cid));
            BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
        }       
        nbr_quads = BCM_DEVICE_PETRA_COSQ_QUEUE_QUAD_GET(nbr_cos);
        SOC_DPP_CORES_ITER(ingress_core, core_id) {
            /* determine queue region mode */
            queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_qid);
            rc = _bcm_petra_queue_region_config_get(unit, core_id, queue_region, &is_non_contiguous);
            BCMDNX_IF_ERR_EXIT(rc);

            SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_queue_to_flow_mapping_get,(unit, core_id, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_qid), &queue_map_info)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            is_composite = queue_map_info.is_composite;


            LOG_DEBUG(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "  DBG, isNonContiguous %s, isComposite %s, nbrQuads(%d)\n"), 
                                  ((is_non_contiguous) ? "True" : "False"), ((is_composite) ? "True" : "False"), nbr_quads));

        
            updated_base_cid = ingress_base_cid;

            if (modid_override) {
                uint32 dest_fap_id, dest_port_id;
                ARAD_SYSPORT     dest_sysport;
                
                /* BCM_COSQ_GPORT_CONNECTION_MODID_OVERRIDE  works only if VOQ is created  with BCM_COSQ_GPORT_TM_FLOW_ID flag */
                SOCDNX_SAND_IF_ERR_RETURN (arad_sw_db_sysport2modport_get(unit, queue_map_info.system_physical_port, &dest_fap_id, &dest_port_id));
                SOCDNX_SAND_IF_ERR_RETURN (arad_sw_db_modport2sysport_get(unit, gport_connect->remote_modid, dest_port_id, &dest_sysport));
                queue_map_info.system_physical_port = dest_sysport;
            }

            for (cur_quad = 0; cur_quad < nbr_quads; cur_quad++) {
                _bcm_petra_flow_id_get(unit, core_id, updated_base_cid, cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET,
                                       is_non_contiguous, is_composite, is_remove, &flow_id);

                flow_id_i = ((SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) && (!modid_override) && (!is_remove) && (ingress_core == BCM_CORE_ALL)) ?
                    _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(flow_id, SOC_DPP_DEFS_GET(unit, nof_cores), core_id) :
                    flow_id;
                queue_map_info.flow_quartet_index = SOC_TMC_SCH_FLOW_TO_QRTT_ID(flow_id_i); 
                
                LOG_DEBUG(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "  DBG, qQuartet %d, QueueMap (fQuartet %d, isComposite %d)\n"), 
                           SOC_TMC_IPQ_Q_TO_QRTT_ID((base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET))),
                           queue_map_info.flow_quartet_index, queue_map_info.is_composite));
                queue_map_info.is_modport = 1; /* In direct mapping mode, we should use the retrieved modport and not the sysport. Does not affect indirect mode. */

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_set,
                                                    (unit, core_id, SOC_TMC_IPQ_Q_TO_QRTT_ID((base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET))), &queue_map_info)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in setting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET), soc_sand_rc, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                    BCM_EXIT;
                }
            }
        }
    }

    if (is_egress) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, egress_core, egress_base_cid, &sw_state_num_cos));
        nbr_cos = sw_state_num_cos;    
        if (nbr_cos > 8) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) cid(%d) internal state get error\n"), unit, egress_base_cid));
            BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
        }       
        nbr_quads = BCM_DEVICE_PETRA_COSQ_QUEUE_QUAD_GET(nbr_cos);
        flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(egress_base_cid);
        rc = _bcm_petra_flow_region_config_get(unit, egress_core, flow_region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
        BCMDNX_IF_ERR_EXIT(rc);

        SOC_TMC_SCH_FLOW_clear(unit, &sch_flow);
        SOC_TMC_SCH_QUARTET_MAPPING_INFO_clear(&quartet_flow_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, egress_core, egress_base_cid, &sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving sch flow (%d), soc_sand error 0x%x, error 0x%x\n"), unit, egress_base_cid, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        if ( (sch_flow.sub_flow[0].is_valid == FALSE) && (sch_flow.sub_flow[1].is_valid == FALSE) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, ino sub flow enabled for sch flow (%d), soc_sand error 0x%x, error 0x%x"), unit, egress_base_cid, soc_sand_rc, rc));
        } 

        is_composite = ((sch_flow.sub_flow[0].is_valid == TRUE) && (sch_flow.sub_flow[1].is_valid == TRUE)) ? TRUE : FALSE;

        _bcm_petra_nbr_flow_quartets_for_queue_quartet(unit, is_non_contiguous, is_composite,
                                                                            &nbr_flow_quartets);

        nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[egress_core][flow_region];

        for (cur_quad = 0; cur_quad < nbr_quads; cur_quad++) {
            /* set all symmetric connections*/
            for (i = 0; i < nof_remote_cores; i++) {

                int local_cid, local_cid_quartet ;
                int other_cid, other_cid_quartet ;

                quartet_flow_info.base_q_qrtt_id = SOC_TMC_IPQ_Q_TO_QRTT_ID(base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET));
                quartet_flow_info.is_composite = is_composite;
                if (is_remove) {
                    quartet_flow_info.fip_id = SOC_TMC_MAX_FAP_ID; /* set to invalid modid */
                } else {
                    quartet_flow_info.fip_id = gport_connect->remote_modid + i; 
                }


                LOG_DEBUG(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "  DBG, fQuartet %d, nbrQuartets %d, FlowMap (qQuartet %d, isComposite %d, remoteModid %d)\n"), 
                                      SOC_TMC_SCH_FLOW_TO_QRTT_ID(egress_base_cid) + (cur_quad * nbr_flow_quartets), nbr_flow_quartets,
                           
                           quartet_flow_info.base_q_qrtt_id, quartet_flow_info.is_composite, quartet_flow_info.fip_id));

                local_cid = egress_base_cid + SOC_TMC_SCH_QRTT_TO_FLOW_ID(cur_quad * nbr_flow_quartets) ;
                /*
                 * Mark 'other' quartet as valid or not. See remark on 'other_quartet_is_valid'
                 * element in SOC_TMC_SCH_QUARTET_MAPPING_INFO.
                 */
                local_cid_quartet = SOC_TMC_SCH_FLOW_TO_QRTT_ID(local_cid) ;
                if (local_cid_quartet % 2) {
                    /*
                     * Odd cid quartet. Other should be the even one.
                     */
                    other_cid_quartet = local_cid_quartet - 1 ;
                } else {
                    /*
                     * Even cid quartet. Other should be the odd one.
                     */
                    other_cid_quartet = local_cid_quartet + 1 ;
                }
                other_cid = SOC_TMC_SCH_QRTT_TO_FLOW_ID(other_cid_quartet) ;
                quartet_flow_info.other_quartet_is_valid = 0 ;

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, egress_core, other_cid, &sw_state_flags));
                    if (sw_state_flags & CONNECTION_IS_VALID_MASK) {
                        quartet_flow_info.other_quartet_is_valid = 1 ; ;
                    }
                /*
                 * Mark connectors group as invalid to start with. Update to 'valid'
                 * when operation succeeds.
                 */

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, egress_core, local_cid, &sw_state_flags));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.set(unit, egress_core, local_cid, sw_state_flags & ~CONNECTION_IS_VALID_MASK));

                base_cid_i = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(egress_base_cid, nof_remote_cores, i);
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_flow_to_queue_mapping_set,
                             (unit, egress_core, SOC_TMC_SCH_FLOW_TO_QRTT_ID(base_cid_i) + (cur_quad * nbr_flow_quartets),
                             nbr_flow_quartets, &quartet_flow_info)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in setting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid + (cur_quad * DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET), soc_sand_rc, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                    BCM_EXIT;
                }
                /*
                 * Mapping was completed successfully. Mark connectors group as valid
                 * by reloading 'num_cos' by its original value.
                 */
                if (!is_remove) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, egress_core, local_cid, &sw_state_flags));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.set(unit, egress_core, local_cid, sw_state_flags | CONNECTION_IS_VALID_MASK));
                }
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_connection_get(int unit,
                              bcm_cosq_gport_connection_t *gport_connect)
{
    bcm_error_t                       rc = BCM_E_NONE;
    uint32                            soc_sand_rc;
    int                               flag_count;       
    int                               is_ingress, is_egress;
    
    int                               base_qid=0, base_cid=0;
    SOC_TMC_IPQ_QUARTET_MAP_INFO          queue_map_info;
    bcm_gport_t                       modport_gport, sysport_gport;
    SOC_TMC_SCH_QUARTET_MAPPING_INFO      quartet_flow_info;
    SOC_SAND_U32_RANGE                    queue_range;
    int                               queue_region;
    int                               is_multicast = FALSE, is_unicast = FALSE;
    int                               is_isq = FALSE, egress_core;
    int                               ingress_core = 0, core_id;
    SOC_TMC_ITM_INGRESS_SHAPE_INFO    isp_info;
    uint8                             sw_state_num_cos;
    uint8                             is_interdigitated;

    /*
     * Initialize, Just to have some value. Overwritten below.
     */
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* consistency checks */
    if (gport_connect == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport_connect"), unit));
    }
 
    flag_count = _bcm_cosq_bit_count_get(gport_connect->flags);
    if (flag_count != 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag settting valid"), unit, gport_connect->flags));
    }
    if ((gport_connect->flags &
            (BCM_COSQ_GPORT_CONNECTION_INGRESS | BCM_COSQ_GPORT_CONNECTION_EGRESS)) == 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags 0x%x - only one flag settting valid"), unit, gport_connect->flags));
    }

    is_ingress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_INGRESS) ? TRUE : FALSE;
    is_egress = (gport_connect->flags & BCM_COSQ_GPORT_CONNECTION_EGRESS) ? TRUE : FALSE;
   
    if (is_ingress) {
        unsigned indirect_mode = 1;
        if (ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
            indirect_mode = 0;
        }
        if ( !(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq) ||
                         BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)
                          || BCM_COSQ_GPORT_IS_ISQ(gport_connect->voq))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid ucast/mcast gport 0x%x"), unit, gport_connect->voq));
        }

        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_connect->voq)) {
            base_qid =  BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_connect->voq);
            ingress_core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_connect->voq) ;
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_connect->voq)) {
            base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_GET(gport_connect->voq);
            ingress_core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_connect->voq);
        } else {
            base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport_connect->voq);
            ingress_core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_connect->voq);
        }
        /*
         * If extracted core is out of bounds then return with error.
         */
        if (ingress_core < 0 || ingress_core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) {
            int is_core_err = 1;
            if (SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) {
                if (ingress_core == BCM_CORE_ALL) { /* In symmetric mode core CAN be SOC_CORE_ALL */
                    is_core_err = 0;
                }
            }
            if (is_core_err) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Core (%d) is out of bounds"), unit, ingress_core));
            }
        }
        core_id = (ingress_core == BCM_CORE_ALL) ? 0 : ingress_core;
        /*
         * At this point, 'core' contains the right value for 'ingress' device.
         */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core_id , base_qid), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) voq(%d) internal state get error\n"), unit, base_qid));
            BCM_RETURN_VAL_EXIT(BCM_E_RESOURCE);
        }

        SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
            (unit, core_id, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_qid), &queue_map_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in getting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /*
         * Get 'core' (on egress device) from 'gport_connect->voq_connector'. It is not
         * supposed to contain any info (since it is the output of this procedure (in
         * this 'ingress' case) except for the 'core' of the egress device (which is
         * known to the caller but not to this procedure).
         */
        egress_core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_connect->voq_connector) ;

        queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_qid);
        rc = _bcm_petra_queue_region_config_get(unit, core_id, queue_region, &is_interdigitated);
        BCMDNX_IF_ERR_EXIT(rc);
  
        if (is_interdigitated) {
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(gport_connect->voq_connector, SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue_map_info.flow_quartet_index)+2, egress_core);
        } else {
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(gport_connect->voq_connector, SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue_map_info.flow_quartet_index), egress_core);
        }


        if (indirect_mode) {
            BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, queue_map_info.system_physical_port);

            rc = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, &modport_gport);
            BCMDNX_IF_ERR_EXIT(rc);

            gport_connect->remote_modid = BCM_GPORT_MODPORT_MODID_GET(modport_gport);
        } else { /* direct mapping mode */
            gport_connect->remote_modid = queue_map_info.fap_id; /* fap_id is actually mod_id */
        }
    }


    if (is_egress) {
        if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_connect->voq_connector)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid voq connector 0x%x"), unit, gport_connect->voq_connector));
        }
        base_cid = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport_connect->voq_connector);
        if (SOC_IS_QAX(unit)) {
            base_cid = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, base_cid);
        }
        /*
         * Get 'core' (on egress device) from 'gport_connect->voq_connector'. Caller is
         * assumed to have it set properly.
         */
        core_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_connect->voq_connector) ;
        /*
         * If extracted core is out of bounds then return with error.
         */
        if ((core_id >= SOC_DPP_DEFS_GET(unit, nof_cores)) || (core_id < 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, Core (%d) is out of bounds"), unit, core_id)) ;
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core_id, base_cid, &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }

        SOC_TMC_SCH_QUARTET_MAPPING_INFO_clear(&quartet_flow_info);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_flow_to_queue_mapping_get,
            (unit, core_id, SOC_TMC_SCH_FLOW_TO_QRTT_ID(base_cid), &quartet_flow_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in getting queue (%d) flow mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_qid, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        base_qid = SOC_TMC_IPQ_QRTT_TO_Q_ID(quartet_flow_info.base_q_qrtt_id);

        /* Get multicast queue id range */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_get,(unit, core_id, &queue_range)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if ( (base_qid >= queue_range.start) && (base_qid <= queue_range.end) ) {
            is_multicast = TRUE;
        }
        else {
            /* Get ISQ queue range */
            SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, core_id, &isp_info)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            if ((base_qid >= isp_info.q_range.q_num_low) && (base_qid<=isp_info.q_range.q_num_high)) {
                is_isq = TRUE;
            } else {
                is_unicast = TRUE;
            }
        }

        if (is_multicast) {
            BCM_GPORT_MCAST_QUEUE_GROUP_SET(gport_connect->voq, base_qid);
        }
        if (is_unicast) {
            BCM_GPORT_UNICAST_QUEUE_GROUP_SET(gport_connect->voq, base_qid);
        }
        if (is_isq) {
            BCM_COSQ_GPORT_ISQ_SET(gport_connect->voq, base_qid);
        }

        gport_connect->remote_modid = quartet_flow_info.fip_id;
    
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_port_mapping_multi_get(int unit, 
                                    bcm_port_t port,
                                    int count,
                                    bcm_cos_t *priority, 
                                    bcm_cos_queue_t *cosq)
{
    BCMDNX_INIT_FUNC_DEFS;

    if ((BCM_GPORT_IS_SYSTEM_PORT(port) || 
         BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
         BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
         BCM_COSQ_GPORT_IS_ISQ(port))){
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_ingress_tc_mapping_get(unit,port, count, priority, cosq));
    }
    else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid port (0x%x) "), unit, port));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_port_mapping_multi_set(int unit, 
                                    bcm_port_t port,
                                    int count,
                                    bcm_cos_t *priority, 
                                    bcm_cos_queue_t *cosq)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    if ((BCM_GPORT_IS_SYSTEM_PORT(port) || 
         BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
         BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
         BCM_COSQ_GPORT_IS_ISQ(port))){
        
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_ingress_tc_mapping_set(unit, port, count, priority, cosq));
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid Port")));
    }
    
exit:

    BCMDNX_FUNC_RETURN;
}
int
bcm_petra_cosq_port_mapping_set(int unit, 
                                bcm_port_t port,
                                bcm_cos_t priority, 
                                bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_cos_t priority_arr[1];
    bcm_cos_queue_t cosq_arr[1];

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    priority_arr[0] = priority;
    cosq_arr[0] = cosq;

    /* FMQ mapping */
    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        rc = _bcm_petra_cosq_fmq_mapping_set(unit, port, 1, priority_arr, cosq_arr);
#ifndef BCM_WARM_BOOT_SUPPORT /* With this flag the check has been already done */
    } else if(unit >= SOC_MAX_NUM_DEVICES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid soc unit")));
#endif
    } else if (
        (BCM_GPORT_IS_SYSTEM_PORT(port) || 
         BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
         BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
         BCM_COSQ_GPORT_IS_ISQ(port))){
        
        rc = _bcm_petra_cosq_ingress_tc_mapping_set(unit, port, 1, priority_arr, cosq_arr);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Invalid Port")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_port_mapping_get(int unit,
                                bcm_port_t port,
                                bcm_cos_t priority,
                                bcm_cos_queue_t *cosq)
{
    bcm_cos_t priority_arr[1];
    bcm_cos_queue_t cosq_arr[1];

    BCMDNX_INIT_FUNC_DEFS;

    /* FMQ mappin */
    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        priority_arr[0] = priority;
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_fmq_mapping_get(unit, port, 1, priority_arr, cosq_arr));
        *cosq = cosq_arr[0];
        
    } else if(unit >= SOC_MAX_NUM_DEVICES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid soc unit")));
    } else if( 
              (BCM_GPORT_IS_SYSTEM_PORT(port) || 
               BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) || 
               BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) || 
               BCM_COSQ_GPORT_IS_ISQ(port))){
        priority_arr[0] = priority;
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_ingress_tc_mapping_get(unit, port, 1, priority_arr, cosq_arr));
        *cosq = cosq_arr[0];
    }
    else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid port (0x%x) "), unit, port));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_mapping_set(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* Validate */
    if (priority < 0 || priority >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d parameter, range 0-7"), unit, priority));
    }

    if (cosq < 0 || cosq > DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d parameter, range 0-7"), unit, cosq));
    }

    /* Global mapping between PP TC and Ingress TC */
    /* By default: mapping is 1:1 */

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_map_set,(unit,priority,cosq)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_mapping_get(
    int unit, 
    bcm_cos_t priority, 
    bcm_cos_queue_t *cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_IPQ_TR_CLS ipq_tr_cls = 0;
        
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(cosq);    

    /* Validate */
    if (priority < 0 || priority >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d parameter, range 0-7"), unit, priority));
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_map_get,(unit,priority,&ipq_tr_cls)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *cosq = ipq_tr_cls;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_stat_config_set(int unit,
                               bcm_gport_t gport,
                               bcm_gport_t lgl_gport,
                               bcm_cos_queue_t cosq,
                               uint32 flags,
                               bcm_cosq_gport_stat_profile_t profile)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_stat_config_get(int unit,
                               bcm_gport_t gport,
                               bcm_gport_t lgl_gport,
                               bcm_cos_queue_t cosq,
                               uint32 flags,
                               bcm_cosq_gport_stat_profile_t *profile)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_statistic_set(int unit,
                             bcm_gport_t gport,
                             bcm_gport_t lgl_gport,
                             bcm_cos_queue_t cosq,
                             uint32 flags,
                             bcm_cosq_gport_stats_t stat,
                             uint64 value)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_gport_statistic_get(int unit,
                             bcm_gport_t gport,
                             bcm_gport_t lgl_gport,
                             bcm_cos_queue_t cosq,
                             uint32 flags,
                             bcm_cosq_gport_stats_t stat,
                             uint64 *value)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_cosq_gport_statistic_multi_set(int unit,
                                   bcm_gport_t gport,
                                   bcm_gport_t lgl_gport,
                                   bcm_cos_queue_t cosq,
                                   int stat_count,
                                   bcm_cosq_gport_stats_t *stats_array,
                                   uint64 value)
{
    bcm_error_t rc = BCM_E_UNAVAIL;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
_bcm_cosq_petra_vsq_category_set(int unit,                                   
                                 int core_id,
                                 int range_type,
                                 SOC_SAND_U32_RANGE* queue_range)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rv;
    int vsq_category_id;
    SOC_TMC_ITM_CATEGORY_RNGS info;
    int mode;
    BCMDNX_INIT_FUNC_DEFS;


    /* Clear */
    SOC_TMC_ITM_CATEGORY_RNGS_clear(&info);
    switch (range_type) {
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRangeMulticastQueue:
        vsq_category_id = 0;
        break;
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRangeShaperQueue:
        vsq_category_id = 1;
        break;
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRangeFabricQueue:
        vsq_category_id = 2;
        break;
    /* coverity[unterminated_case:FALSE] */
    case bcmCosqRecycleQueue:
        vsq_category_id = 3;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid for vsq categories"), range_type));
    }
    
    /* Set new VSQ category range */ 
    rc = bcm_petra_fabric_control_get(unit, bcmFabricVsqCategory, &mode);
    BCMDNX_IF_ERR_EXIT(rc); 

    if (mode == bcmFabricVsqCatagoryModeNone) {
        /* All VOQs are in the same category 2 except VOQs 0-3. */
        info.vsq_ctgry0_end = 3;
        info.vsq_ctgry1_end = 3;
        info.vsq_ctgry2_end = DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit);        
    } else if (mode == bcmFabricVsqCatagoryMode1 || mode == bcmFabricVsqCatagoryMode2) {

        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_category_rngs_get,(unit, core_id, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    
        if (mode == bcmFabricVsqCatagoryMode2 && vsq_category_id != 2 && vsq_category_id != 0) {
            /* Nothing to do */
            BCM_EXIT;
        }

        BCM_DPP_UNIT_CHECK(unit);
        /* validate parameters */        
        if (queue_range->start > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("start of given range %d is out of range"), queue_range->start));
        }
        if (queue_range->end > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("end of given range %d is out of range"), queue_range->end));
        }
        if (queue_range->end < queue_range->start) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid vsq range given, range end %d is lower than start %d"),range_type, queue_range->start, queue_range->end));
        }

        switch (vsq_category_id) {
        case 0:
            info.vsq_ctgry0_end = queue_range->end;
            /* Align other categories accordingly */
            info.vsq_ctgry1_end = SOC_SAND_MAX(info.vsq_ctgry0_end, info.vsq_ctgry1_end);
            info.vsq_ctgry2_end = SOC_SAND_MAX(info.vsq_ctgry1_end, info.vsq_ctgry2_end);
            break;
        case 1:
            /* Take as previous end the range.start-1 only if different to zero, otherwise start-1 returns -1 */
            info.vsq_ctgry0_end = SOC_SAND_MAX(SOC_SAND_MAX(queue_range->start, 1) - 1, 0);
            info.vsq_ctgry1_end = queue_range->end;
            /* Align other categories accordingly */            
            info.vsq_ctgry2_end = SOC_SAND_MAX(info.vsq_ctgry1_end, info.vsq_ctgry2_end);   
            /* update new range */
            queue_range->start = info.vsq_ctgry0_end + 1; 
            queue_range->end = info.vsq_ctgry1_end; 
            break;        
        case 2:
            info.vsq_ctgry1_end = SOC_SAND_MAX(SOC_SAND_MAX(queue_range->start, 1) - 1, info.vsq_ctgry0_end);
            info.vsq_ctgry2_end = queue_range->end;
            /* update new range */
            queue_range->start = info.vsq_ctgry1_end + 1; 
            break;
        case 3:
            info.vsq_ctgry2_end = SOC_SAND_MAX(SOC_SAND_MAX(queue_range->start, 1) - 1, info.vsq_ctgry1_end);
            /* update new range */
            queue_range->start = info.vsq_ctgry2_end + 1; 
            break;
        /* coverity[dead_error_begin:FALSE] */
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("fabric control mode %d invalid vsq category id %d "), range_type,vsq_category_id));
        }
    } else {
        /* Not valid category modes */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("VSQ Category invalid %d"),mode)); 
    }

    /* Set new ranges */
    soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_category_rngs_set,(unit, core_id, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    
exit:
    BCMDNX_FUNC_RETURN;
}
int 
_bcm_cosq_petra_vsq_category_get(int unit,
                                 int core_id,
                                 int range_type,
                                 SOC_SAND_U32_RANGE* queue_range)
{
    bcm_error_t rc = BCM_E_NONE;
    int mode;
    uint32 soc_sand_rv;
    SOC_TMC_ITM_CATEGORY_RNGS info;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Clear */
    SOC_TMC_ITM_CATEGORY_RNGS_clear(&info);

    BCMDNX_NULL_CHECK(queue_range);

    rc = bcm_petra_fabric_control_get(unit, bcmFabricVsqCategory, &mode);
    BCMDNX_IF_ERR_EXIT(rc); 

    soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_category_rngs_get,(unit, core_id, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    if (mode == bcmFabricVsqCatagoryModeNone) {
        /* All VOQs are in the same category 2 and being mapped to 4-96K. Multicast Queues 0-3 */
        switch (range_type) {
        case bcmCosqRangeMulticastQueue:
            queue_range->start = 0;
            queue_range->end = 3;
            break;
        case bcmCosqRangeFabricQueue:
            queue_range->start = 4;
            queue_range->end = DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit);
            break;
        default:
            queue_range->start = 0;
            queue_range->end = 0;
        }
        /* Nothing to do */        
        BCM_EXIT;   
    }
     
    switch (range_type) {
    case bcmCosqRangeMulticastQueue:
        queue_range->start = 0;
        queue_range->end = info.vsq_ctgry0_end;
        break;
    case bcmCosqRangeShaperQueue:
        queue_range->start = SOC_SAND_MIN(info.vsq_ctgry0_end + 1, info.vsq_ctgry1_end);
        queue_range->end = info.vsq_ctgry1_end;
        break;
    case bcmCosqRangeFabricQueue:
        queue_range->start = SOC_SAND_MIN(info.vsq_ctgry1_end + 1, info.vsq_ctgry2_end);
        queue_range->end = info.vsq_ctgry2_end;
        break;
    case bcmCosqRecycleQueue:
        queue_range->start = SOC_SAND_MIN(info.vsq_ctgry2_end + 1, DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit));
        queue_range->end = DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit);
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid for vsq categories"), range_type));
    }

    if (mode == bcmFabricVsqCatagoryMode2 && range_type != bcmCosqRangeFabricQueue) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("fabric control mode %d invalid for vsq categories mode %d"), range_type, mode));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}
int
_bcm_petra_cosq_queue_range_get(int unit,
                                int core_id,
                                int type,
                                SOC_SAND_U32_RANGE* queue_range)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(queue_range);
    if (core_id != BCM_CORE_ALL &&
       (core_id < 0 || core_id >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }
    if (type == bcmCosqRangeMulticastQueue) {
        /* Get queue id range */
        SOCDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_get,(unit, core_id, queue_range)));
    } else if (type == bcmCosqRangeShaperQueue) {
        SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
        rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, core_id, &isp_info)));
        BCMDNX_IF_ERR_EXIT(rc);
        queue_range->start = isp_info.q_range.q_num_low;
        queue_range->end = isp_info.q_range.q_num_high;
    } else if (type == bcmCosqRangeFabricQueue) {
        rc = _bcm_cosq_petra_vsq_category_get(unit, core_id, type, queue_range);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid range type %d"), type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}


int
_bcm_petra_cosq_queue_range_set(int unit,
                                int core_id,
                                int type,
                                int configuration_type,
                                int sw_only,
                                SOC_SAND_U32_RANGE* queue_range) {
    bcm_error_t rc = BCM_E_NONE;    
    int *queue_region_config = NULL;
    int queue_config_type = -1;
    int core_index = 0;
    int region;
    int is_run_allocation;
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;
    SOC_SAND_U32_RANGE queue_range_copy;
    uint32 hr_port;
    bcm_gport_t sw_state_isq_port;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(queue_range);
    sal_memcpy(&queue_range_copy, queue_range, sizeof(SOC_SAND_U32_RANGE));

    if (core_id != BCM_CORE_ALL &&
       (core_id < 0 || core_id >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }

    if (queue_range->start > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("queue min %d invalid"), queue_range->start));
    }    

    if (queue_range->end > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("queue max %d invalid"), queue_range->end));
    }    
    /* Validate queue id */
    if ((queue_range->start % 1024) && configuration_type != BCM_PETRA_COSQ_QUEUE_RANGE_SET_MAX) {
        if ((queue_range->start % 1024) != 4) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue ID min %d must be a multiple of 1024"), queue_range->start));
        } 
        queue_range->start = 0;
    }
    if (((queue_range->end + 1) % 1024) != 0 && queue_range->end != 3 && configuration_type != BCM_PETRA_COSQ_QUEUE_RANGE_SET_MIN) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue ID max %d must be a multiple of 1024 then - 1"),queue_range->end));
    }
    if ((type != bcmCosqRangeFabricQueue) && (type != bcmCosqRangeShaperQueue) && (type != bcmCosqRangeMulticastQueue)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid range type"), type));
    }
    if (!sw_only) {
        rc = _bcm_cosq_petra_vsq_category_set(unit, core_id, type, &queue_range_copy); 
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (type == bcmCosqRangeMulticastQueue) {
        queue_config_type = DPP_DEVICE_COSQ_QUEUE_REGION_MULTICAST;
        if (!sw_only) {
            rc = bcm_petra_fabric_multicast_scheduler_mode_get(unit, core_id, &is_run_allocation);
            BCMDNX_IF_ERR_EXIT(rc);

            if (is_run_allocation) {
                /* 
                 * 1. Currently Range defined for the enhance FMQs is execpted to be of 1Ks This can be changed on a later release
                 * 2. Validate queue id: for FMQs the start region must be in multiples of 1024 
                 */ 
                if ((queue_range->start % 1024) != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Queue ID min %d must be a multiple of 1024"), queue_range->start));
                }
            }
        } else {
            is_run_allocation = TRUE;
        }
    } else if (type == bcmCosqRangeShaperQueue) {
        if (SOC_IS_QAX(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("type %d unsupported on this device"), type));
        }
        
        queue_config_type = DPP_DEVICE_COSQ_QUEUE_REGION_ISQ;
        is_run_allocation = TRUE;
    } else if (type == bcmCosqRangeFabricQueue) {
        queue_config_type = DPP_DEVICE_COSQ_QUEUE_REGION_UNICAST;
        is_run_allocation = TRUE;
    }
    if (!sw_only && type == bcmCosqRangeMulticastQueue) {
        sal_memcpy(queue_range,&queue_range_copy, sizeof(SOC_SAND_U32_RANGE));
        /* Set queue id range */
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_set,(unit, core_id, queue_range)));

    } else if (!sw_only && type == bcmCosqRangeShaperQueue) {
        BCM_DPP_CORES_ITER(core_id, core_index) {
            SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);

            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_ingress_shape_get, (unit, core_index, &isp_info)));
            BCMDNX_IF_ERR_EXIT(rc);
            hr_port = isp_info.sch_port;

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.isq_port.get(unit, core_index, &sw_state_isq_port));
            if ((queue_range->start / 1024) <= ((queue_range->end + 1) / 1024)) {
                if (sw_state_isq_port == BCM_GPORT_INVALID) {
                    /* Allocate hr resource only in case of not MAX*/
                    rc = bcm_petra_cosq_isq_hr_allocate(unit, core_index, &hr_port);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                isp_info.enable = TRUE; /* must be enabled to set q range */
            } else {
                /* deallocate hr resource */
                if (sw_state_isq_port != BCM_GPORT_INVALID) {
                    rc = bcm_petra_cosq_isq_hr_deallocate(unit, core_index, &hr_port);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                isp_info.enable = FALSE;
            }
            isp_info.sch_port = hr_port;
            isp_info.q_range.q_num_low = queue_range->start;
            isp_info.q_range.q_num_high = queue_range->end;
            rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_set,(unit, core_index, &isp_info)));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    } else if (type == bcmCosqRangeFabricQueue) {
        sal_memcpy(queue_range,&queue_range_copy, sizeof(SOC_SAND_U32_RANGE));
        /* update state */
        rc = _bcm_petra_cosq_ucast_qid_range_set(unit, core_id, queue_range->start, queue_range->end);
        BCMDNX_IF_ERR_EXIT(rc);
    }


    if (is_run_allocation) {
        BCMDNX_ALLOC(queue_region_config, sizeof(int) * DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit)*SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores , "queue_region");

        if (queue_region_config == NULL) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("resource memory allocation failur")));
        }
        sal_memset(queue_region_config, 0, sizeof(int) * DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit)*SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores);
        BCM_DPP_ASSYMETRIC_CORES_ITER(core_id, core_index) {
            for (region = (queue_range->start / 1024); region < ((queue_range->end + 1) / 1024); region++) {
                queue_region_config[region + (core_index * DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit))] = queue_config_type;
            }
        }
        rc = _bcm_dpp_am_cosq_process_queue_region(unit, core_id, queue_config_type, queue_region_config);
        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
    if (queue_region_config != NULL) {
       BCM_FREE(queue_region_config);
    }
    BCMDNX_FUNC_RETURN;
}
/* test a credit request profile for conditions needed for moving to a different credit request mode */
STATIC int
_bcm_petra_cosq_credit_watchdog_test_profile(int unit, int profile, int cr_wd_mode)
{
    bcm_cosq_delay_tolerance_t profile_data;
    int rc = bcm_petra_cosq_delay_tolerance_level_get(unit, profile, &profile_data);
    BCMDNX_INIT_FUNC_DEFS;
    if (rc != BCM_E_UNAVAIL) {
        BCMDNX_IF_ERR_EXIT(rc);
        if (profile_data.credit_request_watchdog_delete_queue_thresh) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Can not enter the %s credit watchdog mode when a credit watchdog delete queue threshold is set.\n"
              "You may want to disable it for user defined credit request profile number %d (tolerance level %d)"),
              cr_wd_mode == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE ? "common status message" : "aggressive status message",
              profile - (BCM_COSQ_DELAY_TOLERANCE_02 - 2), profile));
        } else if (cr_wd_mode == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE &&
                   profile_data.credit_request_watchdog_status_msg_gen) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Can not enter the common status message credit watchdog mode when a credit watchdog status message threshold is set.\n"
              "You may want to disable it for user defined credit request profile number %d (tolerance level %d)"),
              profile - (BCM_COSQ_DELAY_TOLERANCE_02 - 2), profile));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_watchdog_range_set(
        int unit, 
        int core_id, 
        uint32 flags,
        bcm_cosq_range_t *range, 
        int common_message_time) 
{

    int8 orig_crwd_mode = 0;
    uint32 orig_scan_time_ns = 0, exact_credit_watchdog_scan_time_nano = 0;
    int fail = 0;
    int8 credit_watchdog_mode;
    SOC_TMC_ITM_CR_WD_INFO info, info2;
    int enabled, profile;
    int changed_mode = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);
    if (core_id != BCM_CORE_ALL && (core_id < 0 || core_id >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core %d out of range"), core_id));
    }
    BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, orig_crwd_mode));
    if (range->is_enabled && (flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_ENABLE)) {
        if (/*range->is_enabled < (uint32)BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MIN ||*/ range->is_enabled > BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MAX) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid enable value: %d, should be between %d - %d"), range->is_enabled,
              BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MIN, BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_MAX));
        } 
        if (range->is_enabled == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_COMMON_STATUS_MESSAGE && !(SOC_IS_ARADPLUS(unit) || SOC_IS_JERICHO(unit))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("common FSM mode is only supported in 86660\n")));
        }
        if (common_message_time >= 0 && (!IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, orig_crwd_mode) || 
            (range->is_enabled != CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("common message time can only be set in common message time mode")));
        }
    } else if (common_message_time >= 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("can only set common message time using bcmCosqWatchdogQueue")));
    }

    if ((flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MIN) && 
        (range->range_start > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit) || range->range_start < 0)) { /* Validate queue id */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid start queue number: %d, is not between 0 - %d"), range->range_start, DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)));
    } 
    if ((flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MAX) && 
        (range->range_end > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit) || range->range_end < 0)) { /* Validate queue id */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid end queue number: %d, is not between 0 - %d"), range->range_end, DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)));
    } 
    if ((flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MIN) && (flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MAX) && 
        range->range_start > range->range_end) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue range: %d - %d, is not between 0 - %d"), range->range_start, range->range_end, DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)));
    } 
    SOC_TMC_ITM_CR_WD_INFO_clear(&info);
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_get, (unit, core_id, &info)));
    fail = 1; /* get credit watchdog configuration if error happens from here on */
    BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, orig_crwd_mode));
    BCMDNX_IF_ERR_EXIT(GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, orig_scan_time_ns));

    /* The MBCM_DPP_DRIVER_CALL initializing the required variable */ 
    /* coverity[uninit_use:FALSE] */
    enabled = info.min_scan_cycle_period_micro;
    if (common_message_time >= 0) {
        if (common_message_time == 2 * ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS / 1000) {
            /* If over max scan time, use max scan time and mark mode to use two scans */
            range->is_enabled = CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE + 1;
            common_message_time = ARAD_CREDIT_WATCHDOG_COMMON_MAX_SCAN_TIME_NS / 1000;
        }
        if (!enabled) { /* If changing common message time, do not change enabled or not */
            BCMDNX_IF_ERR_EXIT(SET_CREDIT_WATCHDOG_MODE(unit, range->is_enabled)); /* update the stored mode */
            range->is_enabled = BCM_FABRIC_WATCHDOG_QUEUE_DISABLE;
        }
    }
    if (flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_ENABLE) {
        if (range->is_enabled == BCM_FABRIC_WATCHDOG_QUEUE_DISABLE) {
            enabled = 0;
        } else {
            BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
            changed_mode = !IS_CREDIT_WATCHDOG_MODE(unit, range->is_enabled, credit_watchdog_mode);
            if (credit_watchdog_mode == CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE + 1 &&
                range->is_enabled == CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE && common_message_time < 0) {
                range->is_enabled = CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE + 1; /* do not change common FSM sub mode if not requested to do so */
            }
            enabled = 1;
                /* if moving to a different credit watchdog mode, check if allowed to move to the new mode */
            if (changed_mode &&
               (range->is_enabled != BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_NORMAL || IS_CREDIT_WATCHDOG_FAST_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode))) {
                /* check that no profile with aging exists */
                for (profile = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED; profile <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY; ++profile) {
                    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_credit_watchdog_test_profile(unit, profile, range->is_enabled));
                }
                for (profile = BCM_COSQ_DELAY_TOLERANCE_02; profile <= BCM_COSQ_DELAY_TOLERANCE_14; ++profile) {
                    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_credit_watchdog_test_profile(unit, profile, range->is_enabled));
                }
                if (SOC_IS_JERICHO(unit)) {
                    for (profile = BCM_COSQ_DELAY_TOLERANCE_16; profile <= BCM_COSQ_DELAY_TOLERANCE_23; ++profile) {
                        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_credit_watchdog_test_profile(unit, profile, range->is_enabled));
                    } 
                }
            }
            BCMDNX_IF_ERR_EXIT(SET_CREDIT_WATCHDOG_MODE(unit, range->is_enabled)); /* update the stored mode */
        }
    }
    if (flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MIN) {
        info.bottom_queue = range->range_start;
        if (info.top_queue < range->range_start) {
            info.top_queue = range->range_start;
        }
    }
    if (flags & BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MAX) {
        info.top_queue = range->range_end;
        if (info.bottom_queue > range->range_end) {
            info.bottom_queue = range->range_end;
        }
    }
    if (enabled) {
        /* The MBCM_DPP_DRIVER_CALL initializing the required variable */ 
        /* coverity[uninit_use:FALSE] */
        uint32 queue_number = info.top_queue + 1 - info.bottom_queue;
        uint32 nof_ns_in_20_ticks, scan_time_ns;
        BCM_SAND_IF_ERR_EXIT(arad_ticks_to_time((unit), 20, TRUE, 1, &nof_ns_in_20_ticks));
        /* Get the default watchdog scan time for the mode (or the one given in common_message_time) and set it in SW */
        SOC_TMC_ITM_CR_WD_INFO_clear(&info2);

        BCMDNX_IF_ERR_EXIT(GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
        BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));

        info2.min_scan_cycle_period_micro = (common_message_time >= 0) ? common_message_time : (
            (changed_mode || !IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) ? 0 : exact_credit_watchdog_scan_time_nano / 1000);
        info2.top_queue = info2.bottom_queue = info2.max_flow_msg_gen_rate_nano = ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, core_id, &info2, &info2)));

        BCMDNX_IF_ERR_EXIT(GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
        scan_time_ns = info2.min_scan_cycle_period_micro; /* exact scan time */
        info.min_scan_cycle_period_micro = exact_credit_watchdog_scan_time_nano / 1000; /* rounded scan time in common FSM mode */

        /* Set the time in nanoseconds to scan each queue, may be later limited by the range of the hardware field.
         * time = max{0.5*full_scan/nof_queues, full_scan/nof_queues - 20*clock_cycle}
         * We try to be precise (not have scans longer than the declared scan time, and not have burstiness.
         */
        info.max_flow_msg_gen_rate_nano = (scan_time_ns / 2) / queue_number;
        queue_number = scan_time_ns / queue_number;
        if (queue_number > nof_ns_in_20_ticks) {
            queue_number -= nof_ns_in_20_ticks;
            if (info.max_flow_msg_gen_rate_nano < queue_number ) {
                info.max_flow_msg_gen_rate_nano = queue_number;
            }
        }

        /* if moving to a different credit watchdog mode, adjust existing profiles */
        BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        if (changed_mode && !IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
            bcm_cosq_delay_tolerance_t profile_data;
            int status_msg_threshold = range->is_enabled == BCM_FABRIC_WATCHDOG_QUEUE_ENABLE_FAST_STATUS_MESSAGE ?
              SOC_TMC_ITM_CREDIT_WATCHDOG_AGGRESSIVE_WD_STATUS_MSG_MESSAGE_THRESHOLD :
              SOC_TMC_ITM_CREDIT_WATCHDOG_NORMAL_STATUS_MSG_THRESHOLD;
            /* Change existing credit watchdog status message thresholds to the default for the new mode */
            for (profile = BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED; profile <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY; ++profile) {
                BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_get(unit, profile, &profile_data));
                if (profile_data.credit_request_watchdog_status_msg_gen && 
                    profile_data.credit_request_watchdog_status_msg_gen != status_msg_threshold) {
                    profile_data.credit_request_watchdog_status_msg_gen = status_msg_threshold;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, profile, &profile_data));
                }
            }
            for (profile = BCM_COSQ_DELAY_TOLERANCE_02; profile <= BCM_COSQ_DELAY_TOLERANCE_14; ++profile) {
                int rc = bcm_petra_cosq_delay_tolerance_level_get(unit, profile, &profile_data);
                if (rc == BCM_E_UNAVAIL) {
                    continue;
                }
                BCMDNX_IF_ERR_EXIT(rc);
                if (profile_data.credit_request_watchdog_status_msg_gen && 
                    profile_data.credit_request_watchdog_status_msg_gen != status_msg_threshold) {
                    profile_data.credit_request_watchdog_status_msg_gen = status_msg_threshold;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_delay_tolerance_level_set(unit, profile, &profile_data));
                }
            }
        }
    } else {
        if (common_message_time >= 0) {
            /* Set the scan time for the common mode in SW, and not in HW */
            SOC_TMC_ITM_CR_WD_INFO_clear(&info2);
            info2.min_scan_cycle_period_micro = common_message_time;
            info2.top_queue = info2.bottom_queue = info2.max_flow_msg_gen_rate_nano = ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
            BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, core_id, &info2, &info2)));
        }
        info.min_scan_cycle_period_micro = 0;
        BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
        if (IS_CREDIT_WATCHDOG_COMMON_STATUS_MESSAGE_MODE(unit, credit_watchdog_mode)) {
            uint32 exp = 0; /* find the (negative) exponent of the scan time compared to the max scan time */
            BCMDNX_IF_ERR_EXIT(GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
            for (; exp <= ARAD_CREDIT_WATCHDOG_COMMON_SCAN_TIME_MAX_HALVES &&
                 exact_credit_watchdog_scan_time_nano != ARAD_CREDIT_WATCHDOG_COMMON_MIN_SCAN_TIME_NS << exp;
                 ++exp);
            if  (exp > ARAD_CREDIT_WATCHDOG_COMMON_SCAN_TIME_MAX_HALVES) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Invalid scan time for common message time mode: %uns"), exact_credit_watchdog_scan_time_nano));
            }
            /* store data the (disabled) credit watchdog mode and scan time in HW for warm boot */
            info.max_flow_msg_gen_rate_nano = credit_watchdog_mode + exp;
        } else {
            /* store data the (disabled) credit watchdog mode in HW for warm boot */
            info.max_flow_msg_gen_rate_nano = credit_watchdog_mode;
        }
    }
    BCMDNX_IF_ERR_EXIT(GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
    /* If the scan time of the common message time mode was changed, change the delete time exponents to match new scan time */
    if (common_message_time >= 0 && !changed_mode && orig_scan_time_ns != exact_credit_watchdog_scan_time_nano) {
        uint32 bigger, smaller, *shift;
        info2.min_scan_cycle_period_micro = info2.max_flow_msg_gen_rate_nano = 0;
        info2.top_queue = info2.bottom_queue = ARAD_CREDIT_WATCHDOG_Q_COMMON_FSM_ADJUST_EXP;
        if (exact_credit_watchdog_scan_time_nano > orig_scan_time_ns) {
            bigger = exact_credit_watchdog_scan_time_nano;
            smaller = orig_scan_time_ns;
            shift = &info2.min_scan_cycle_period_micro;
        } else {
            bigger = orig_scan_time_ns;
            smaller = exact_credit_watchdog_scan_time_nano;
            shift = &info2.max_flow_msg_gen_rate_nano;
        }
        for (*shift = 1; smaller << *shift != bigger; ++*shift) {
            if (*shift >= ARAD_CREDIT_WATCHDOG_COMMON_SCAN_TIME_MAX_HALVES) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Can not adjust delete times moving from scan time %u to scan time %u"),
                  (unsigned)orig_scan_time_ns, (unsigned)exact_credit_watchdog_scan_time_nano));
            }
        }
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, core_id, &info2, &info2)));
    }

    /* Change the credit watchdog scan configuration */
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_wd_set, (unit, core_id, &info, &info2)));
    fail = 0;

exit:
    if (fail) { /* If failed, restore the original credit watchdog mode */
        BCMDNX_IF_ERR_CONT(SET_CREDIT_WATCHDOG_MODE(unit, orig_crwd_mode));
        BCMDNX_IF_ERR_EXIT(GET_EXACT_CREDIT_WATCHDOG_SCAN_TIME_NANO(unit, exact_credit_watchdog_scan_time_nano));
    }
    BCMDNX_FUNC_RETURN;
}

/*
 * Get queue range or enable/disable for credit watchdog
 * Set VOQ range
 */
int
_bcm_petra_cosq_credit_watchdog_range_get(
        int unit, 
        int core_id, 
        bcm_cosq_range_t *range)
{
    int8 credit_watchdog_mode;
    SOC_TMC_ITM_CR_WD_INFO info;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);       


    SOC_TMC_ITM_CR_WD_INFO_clear(&info);
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_wd_get,(unit, core_id, &info)));
    range->range_start = info.bottom_queue;
    range->range_end = info.top_queue;
    BCMDNX_IF_ERR_EXIT(GET_CREDIT_WATCHDOG_MODE(unit, credit_watchdog_mode));
    range->is_enabled = (info.min_scan_cycle_period_micro) ? GET_CREDIT_WATCHDOG_MODE_BASE(credit_watchdog_mode) : BCM_FABRIC_WATCHDOG_QUEUE_DISABLE;

exit:
    BCMDNX_FUNC_RETURN;
}
int 
bcm_petra_cosq_control_range_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    bcm_cosq_control_range_type_t type, 
    bcm_cosq_range_t *range)
{
    SOC_SAND_U32_RANGE queue_range;
    uint32 index;
    int core = 0;

    BCMDNX_INIT_FUNC_DEFS;

    /* Parameters Check */
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);

    /*
     * Not all lower function update this field.
     * set range as enabled by default, it can be updated later by called functions
     */
    range->is_enabled = TRUE;

    switch (type) 
    {
        case bcmCosqThresholdDramMixDbuff :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "getting Dram mixed dbuff thresholds\n")));
            /* check validity of Gport */
            if(0 == BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_dram_mix_dbuff_threshold_get, (unit, core, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbCommittedMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_committed_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbCommittedMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_committed_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbEligibleMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_eligible_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;

        case bcmCosqOcbEligibleMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_eligible_multicast_get, (unit, index, &(range->range_end), &(range->range_start))));
            break;
        case bcmCosqRangeMulticastQueue:
        case bcmCosqRangeShaperQueue:
        case bcmCosqRangeFabricQueue:
        case bcmCosqRecycleQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_queue_range_get(unit, core, type, &queue_range));
            range->range_start = queue_range.start;
            range->range_end = queue_range.end;
            range->is_enabled = TRUE;
            break;
        case bcmCosqWatchdogQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_credit_watchdog_range_get(unit, core, range));
            break;
        case bcmCosqStatIfQueues:
        case bcmCosqStatIfScrubberQueues:
            if (!BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_stat_if_queue_range_get, (unit, core, (type == bcmCosqStatIfScrubberQueues) ? 1:0, &(range->range_start), &(range->range_end))));
            break;
        default :
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given type %d is invalid\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_control_range_set(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    bcm_cosq_control_range_type_t type, 
    bcm_cosq_range_t *range)
{
    SOC_SAND_U32_RANGE queue_range;
    uint32 index = 0;
    int core = 0;
    uint32 watchdog_flags = BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MAX | BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_MIN | BCM_PETRA_COSQ_CREDIT_WATHDOG_USE_ENABLE;
    BCMDNX_INIT_FUNC_DEFS;

    /* Parameters Check */
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(range);

    switch (type) {
        case bcmCosqThresholdDramMixDbuff :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Dram mixed dbuff thresholds\n")));
            /* check validity of Gport */
            if(0 == BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_dram_mix_dbuff_threshold_set, (unit, core, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbCommittedMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_committed_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbCommittedMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Committed Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_committed_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbEligibleMulticast_1 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 1\n")));
            index = 0;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_eligible_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;

        case bcmCosqOcbEligibleMulticast_2 :
            LOG_VERBOSE(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "setting Cosq Ocb Eligible Multicast Range 2\n")));
            index = 1;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ocb_control_range_ocb_eligible_multicast_set, (unit, index, range->range_end, range->range_start)));
            break;
        case bcmCosqRangeMulticastQueue:
        case bcmCosqRangeShaperQueue:
        case bcmCosqRangeFabricQueue:
        case bcmCosqRecycleQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            queue_range.start = range->range_start;
            queue_range.end = range->range_end;
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_queue_range_set(unit, core, type, BCM_PETRA_COSQ_QUEUE_RANGE_SET_BOTH, FALSE, &queue_range));
            break;
        case bcmCosqWatchdogQueue:
            if(!BCM_COSQ_GPORT_IS_CORE(port)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            /* get core from gport */
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_credit_watchdog_range_set(unit, core, watchdog_flags, range, 0));
            break;

        case bcmCosqStatIfQueues:
        case bcmCosqStatIfScrubberQueues:
            if (!BCM_COSQ_GPORT_IS_CORE(port))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given gport %d is invalid\n"), unit, port));
            }
            core = BCM_COSQ_GPORT_CORE_GET(port);
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_stat_if_queue_range_set, (unit, core, (type == bcmCosqStatIfScrubberQueues) ? 1:0, range->range_start, range->range_end)));
            break;
        default :
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, given type %d is invalid\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_cosq_control_set(int unit,
                           bcm_gport_t port,
                           bcm_cos_queue_t cosq,
                           bcm_cosq_control_t type,
                           int arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    int port_index;
    bcm_gport_t sysport;


    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* device wide settings */ 
    if (port == 0 || BCM_COSQ_GPORT_IS_CORE(port)) {
        rc = _bcm_petra_cosq_control_device_set(unit, port, cosq, type, arg);
    } else if (!BCM_GPORT_IS_SET(port)) {
        rc = _bcm_petra_cosq_ingress_port_set(unit, port, type, arg);
    }
    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
        rc = _bcm_petra_cosq_control_fmq_set(unit, port, cosq, type, arg);
    }

    /* E2E scheduler */
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(port)) {
        rc = _bcm_petra_cosq_control_e2e_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tc_set(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tcg_set(unit, port, cosq, type, arg);
    }
    /* Egress transmit scheduler */
    /* Egress scheduler port */
    else if (BCM_GPORT_IS_LOCAL(port)) {
        port_index = BCM_GPORT_LOCAL_GET(port);

        if (BCM_DPP_PORT_IS_INTERFACE(port_index)) {  
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_control_egress_interface_scheduler_set(unit, port, cosq, type, arg);
        } else {
            /* Egress scheduler port */
            rc = _bcm_petra_cosq_control_egress_port_scheduler_set(unit, port, cosq, type, arg);
        }        
    }
    /* Egress Queues */
    else if ((BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port)) ||
             (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port))) {
        rc = _bcm_petra_cosq_control_egress_queue_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_PORT_TC(port)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tc_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_COSQ_GPORT_IS_PORT_TCG(port)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tcg_set(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_TDM(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_tdm));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_set, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
    }
    /* Ingress Queues */
    else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) ||
             BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) ||
             BCM_COSQ_GPORT_IS_ISQ(port)) {
        rc = _bcm_petra_cosq_control_ingress_queue_set(unit, port, cosq, type, arg);
    }
    else if ((BCM_GPORT_IS_SCHEDULER(port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port))) {
 
        rc = _bcm_petra_cosq_control_flow_set(unit, port, cosq, type, arg);
    } 
    else if (BCM_GPORT_IS_CONGESTION(port)) { 
        rc = _bcm_petra_cosq_control_congestion_port_set(unit, port, cosq, type, arg);
    }
    else if (BCM_GPORT_IS_PROFILE(port)) { 
        rc = _bcm_petra_cosq_control_profile_set(unit, port, cosq, type, arg);
    }
    /* System port */
    else if (BCM_GPORT_IS_SYSTEM_PORT(port))
    {
        rc = _bcm_petra_cosq_control_system_port_set(unit, port, cosq, type, arg);
    }
    /* modport  */
    else if (BCM_GPORT_IS_MODPORT(port))
    {
        rc = bcm_petra_stk_gport_sysport_get(unit, port, &sysport); /* get system port from gport */
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped"), unit, port));
        }
        rc = _bcm_petra_cosq_control_system_port_set(unit, sysport, cosq, type, arg);
    }    
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d,port(0x%08x) not supported \n"), unit, port));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:

    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_control_get(int unit,
                     bcm_gport_t port,
                     bcm_cos_queue_t cosq,
                     bcm_cosq_control_t type,
                     int *arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    int port_index;
    bcm_gport_t sysport;


    BCMDNX_INIT_FUNC_DEFS;

    /* device wide settings */ 
    if (port == 0 || BCM_COSQ_GPORT_IS_CORE(port)) {
        rc = _bcm_petra_cosq_control_device_get(unit, port, cosq, type, arg);
    } else if (!BCM_GPORT_IS_SET(port)) {
        rc = _bcm_petra_cosq_ingress_port_get(unit, port, type, arg);
    }

    /* FMQ */
    else if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
        rc = _bcm_petra_cosq_control_fmq_get(unit,port,cosq,type,arg);
    } 
   
    /* E2E scheduler */
    else if ((BCM_GPORT_IS_SCHEDULER(port)) || 
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_CIR(port)) ||
             (BCM_COSQ_GPORT_IS_SCHED_PIR(port)) ||
             (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port))) {
 
        rc = _bcm_petra_cosq_control_flow_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(port)) {
        rc = _bcm_petra_cosq_control_e2e_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tc_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_e2e_port_tcg_get(unit, port, cosq, type, arg);
    }
    /* Egress transmit scheduelr */
    /* Egress scheudler port */
    else if (BCM_GPORT_IS_LOCAL(port)) {
        port_index = BCM_GPORT_LOCAL_GET(port);

        if (BCM_DPP_PORT_IS_INTERFACE(port_index)) {
            /* Egress scheduler interface */
            rc = _bcm_petra_cosq_control_egress_interface_scheduler_get(unit, port, cosq, type, arg);
        }
        else {
            rc = _bcm_petra_cosq_control_egress_port_scheduler_get(unit, port, cosq, type, arg);
        }
    } 
    else if (BCM_COSQ_GPORT_IS_PORT_TC(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tc_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(port) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
        rc = _bcm_petra_cosq_control_egress_port_tcg_get(unit, port, cosq, type, arg);
    }
    /* Egress Queues */
    else if ((BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port)) ||
             (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port)))
    {
        rc = _bcm_petra_cosq_control_egress_queue_get(unit, port, cosq, type, arg);
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_UCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_ucast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_mcast));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_TDM(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_fabric_tdm));
    }
    else if (BCM_COSQ_GPORT_IS_FABRIC_RX_QUEUE_LOCAL_MCAST(port)) {
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fabric_cosq_control_backward_flow_control_get, 
                                  (unit, port, arg, soc_dpp_cosq_gport_egress_core_fifo_local_mcast));
    }
    /* Ingress queues */
    else if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) ||
             BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) ||
             BCM_COSQ_GPORT_IS_ISQ(port)) {
        rc = _bcm_petra_cosq_control_ingress_queue_get(unit, port, cosq, type, arg);
    } 
    else if (BCM_GPORT_IS_CONGESTION(port)) { 
        rc = _bcm_petra_cosq_control_congestion_port_get(unit, port, cosq, type, arg);
    }
    else if (BCM_GPORT_IS_PROFILE(port)) { 
        rc = _bcm_petra_cosq_control_profile_get(unit, port, cosq, type, arg);
    }
    /* System port */
    else if (BCM_GPORT_IS_SYSTEM_PORT(port))
    {
        rc = _bcm_petra_cosq_control_system_port_get(unit, port, cosq, type, arg);
    }
    /* modport  */
    else if (BCM_GPORT_IS_MODPORT(port))
    {
        rc = bcm_petra_stk_gport_sysport_get(unit, port, &sysport); /* get system port from gport */
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped"), unit, port));
        }
        rc = _bcm_petra_cosq_control_system_port_get(unit, sysport, cosq, type, arg);
    }     
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, port(0x%08x) not supported \n"), unit, port));
        rc = BCM_E_PORT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* consider adding support gettting the requested gport. given different input gport types */
int
bcm_petra_cosq_gport_handle_get(int unit,
                                bcm_cosq_gport_type_t gport_type,
                                bcm_cosq_gport_info_t *gport_info)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_cosq_gport_info_core_t gport_core_info;
    uint32     tm_port;
    int core;
    soc_port_t port;

    BCMDNX_INIT_FUNC_DEFS;
    
    if (gport_info == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("gport info needs specified, cannot be NULL")));
    }

    switch (gport_type) {
        case bcmCosqGportTypeE2EPort:
            BCM_COSQ_GPORT_E2E_PORT_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeUnicastEgress:
            BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeMulticastEgress:
            BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_SET(gport_info->out_gport, gport_info->in_gport);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeCompositeFlow2:
            if(BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                core = BCM_GPORT_SCHEDULER_CORE_GET(gport_info->in_gport);
            } else if(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport_info->in_gport)) {
                core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport_info->in_gport);
            } else {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler/VoQ Connector gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }
            BCM_COSQ_GPORT_COMPOSITE_SF2_CORE_SET(gport_info->out_gport, gport_info->in_gport, core);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            } 
            break;

        case bcmCosqGportTypeSchedCIR:
            if (!BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }
            core = BCM_GPORT_SCHEDULER_CORE_GET(gport_info->in_gport) ;
            BCM_COSQ_GPORT_SCHED_CIR_CORE_SET(gport_info->out_gport, gport_info->in_gport, core);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;

        case bcmCosqGportTypeSchedPIR:
            if (!BCM_GPORT_IS_SCHEDULER(gport_info->in_gport)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Gport (0x%x) of incorrect type, Expect Scheduler gport\n"), gport_info->in_gport));
                rc = BCM_E_PARAM;
                break;
            }
            core = BCM_GPORT_SCHEDULER_CORE_GET(gport_info->in_gport) ;
            BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(gport_info->out_gport, gport_info->in_gport, core);
            if (gport_info->out_gport == -1) {
                rc = BCM_E_PARAM;
                break;
            }
            break;
          case bcmCosqGportTypeLocalPort:
            {
              int my_modid;

              rc = bcm_petra_stk_my_modid_get(unit, &my_modid);
              BCMDNX_IF_ERR_EXIT(rc);

              if (BCM_GPORT_IS_LOCAL(gport_info->in_gport)) {
                  gport_info->out_gport = gport_info->in_gport;                
              }
              else if (BCM_GPORT_IS_MODPORT(gport_info->in_gport)) {
                  {
                      core = SOC_DPP_MODID_TO_CORE(unit, my_modid, BCM_GPORT_MODPORT_MODID_GET(gport_info->in_gport));
                      tm_port = BCM_GPORT_MODPORT_PORT_GET(gport_info->in_gport);
                      rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
                      BCMDNX_IF_ERR_EXIT(rc);
      
                      BCM_GPORT_LOCAL_SET(gport_info->out_gport,port);
                  }
              }
              else if (BCM_GPORT_IS_SYSTEM_PORT(gport_info->in_gport)) {
                  {
                      bcm_gport_t modport_gport;

                      rc = bcm_petra_stk_sysport_gport_get(unit,gport_info->in_gport,&modport_gport);
                      BCMDNX_IF_ERR_EXIT(rc);

                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(modport_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), gport_info->in_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }
                      
                      /* Returns modport gport, translate it as local gport */
                      BCM_GPORT_LOCAL_SET(gport_info->out_gport,BCM_GPORT_MODPORT_PORT_GET(modport_gport));
                  }                
              }
              else if (SOC_PORT_VALID(unit,gport_info->in_gport)) {
                  /* Assuming other type its only port */
                  BCM_GPORT_LOCAL_SET(gport_info->out_gport,gport_info->in_gport);                
              } else {
                  rc = BCM_E_PORT;           
              }
            }
            break;            
        case bcmCosqGportTypeLocalPortTC: 
        case bcmCosqGportTypeLocalPortTCG:
        case bcmCosqGportTypeE2EPortTC: 
        case bcmCosqGportTypeE2EPortTCG:
          {
              bcm_gport_t local_port = -1;
              bcm_port_t temp_port;
              int my_modid;

              rc = bcm_petra_stk_my_modid_get(unit, &my_modid);
              BCMDNX_IF_ERR_EXIT(rc);

              /* Supported only in case of not Port-TC enable */
              if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "Gport (0x%x) Port-TC is not supported for this device \n"), gport_info->in_gport));
                  rc = BCM_E_UNAVAIL;
                  break;
              }
              rc = BCM_E_NONE;   
              if (BCM_GPORT_IS_LOCAL(gport_info->in_gport)) {
                  local_port = gport_info->in_gport;                
              }
              else if (BCM_GPORT_IS_MODPORT(gport_info->in_gport)) {
                  {                      
                      core = SOC_DPP_MODID_TO_CORE(unit, my_modid, BCM_GPORT_MODPORT_MODID_GET(gport_info->in_gport));
                      tm_port = BCM_GPORT_MODPORT_PORT_GET(gport_info->in_gport);
                      rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
                      BCMDNX_IF_ERR_EXIT(rc);
      
                      BCM_GPORT_LOCAL_SET(local_port,port);
                  }
              }
              else if (BCM_GPORT_IS_SYSTEM_PORT(gport_info->in_gport)) {
                  {
                      bcm_gport_t modport_gport;

                      rc = bcm_petra_stk_sysport_gport_get(unit,gport_info->in_gport,&modport_gport);
                      BCMDNX_IF_ERR_EXIT(rc);
                      
                      if (my_modid != BCM_GPORT_MODPORT_MODID_GET(modport_gport)) {
                          LOG_ERROR(BSL_LS_BCM_COSQ,
                                    (BSL_META_U(unit,
                                                "Gport (0x%x) of incorrect mod_id, Expect mod_id = my_modid\n"), modport_gport));
                          rc = BCM_E_PARAM;
                          break;
                      }

                      /* Returns modport gport, translate it as local gport */
                      BCM_GPORT_LOCAL_SET(local_port,BCM_GPORT_MODPORT_PORT_GET(modport_gport));
                  }                
              }
              else if (SOC_PORT_VALID(unit,gport_info->in_gport)) {
                  /* Assuming other type its only port */
                  BCM_GPORT_LOCAL_SET(local_port,gport_info->in_gport);                
                  
              } else {
                  rc = BCM_E_PORT;           
              }
              if (rc == BCM_E_NONE) {              
                temp_port = BCM_GPORT_LOCAL_GET(local_port);
                switch (gport_type)
                {
                case bcmCosqGportTypeLocalPortTC: 
                  BCM_COSQ_GPORT_PORT_TC_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeLocalPortTCG:
                  BCM_COSQ_GPORT_PORT_TCG_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeE2EPortTC: 
                  BCM_COSQ_GPORT_E2E_PORT_TC_SET(gport_info->out_gport,temp_port);
                  break;
                case bcmCosqGportTypeE2EPortTCG:
                  BCM_COSQ_GPORT_E2E_PORT_TCG_SET(gport_info->out_gport,temp_port);
                  break;
                /* must have default. Otherwise, compilation error */
                /* coverity[dead_error_begin : FALSE] */
                default:
                  rc = BCM_E_INTERNAL;      
                  break;
                }
              }
          }
            break;
        case bcmCosqGportTypeGlobalFmqRoot:
            BCM_COSQ_GPORT_FMQ_ROOT_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqGuaranteed:
            BCM_COSQ_GPORT_FMQ_GUARANTEED_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffortAggregate:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT_AGR_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort0:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT0_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort1:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT1_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort2:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT2_SET(gport_info->out_gport);
            break;
        case bcmCosqGportTypeGlobalFmqClass1:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 1);
            break;
        case bcmCosqGportTypeGlobalFmqClass2:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 2);
            break;
        case bcmCosqGportTypeGlobalFmqClass3:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 3);
            break;
        case bcmCosqGportTypeGlobalFmqClass4:
            BCM_COSQ_GPORT_FMQ_CLASS_SET(gport_info->out_gport, 4);
            break;
        case bcmCosqGportTypeGlobalIsqRoot:
            BCM_COSQ_GPORT_ISQ_ROOT_SET(gport_info->out_gport);
            break;
    case bcmCosqGportTypeGlobalFabricMeshLocal:
        case bcmCosqGportTypeGlobalFabricMeshDev0:
        case bcmCosqGportTypeGlobalFabricMeshDev1:
        case bcmCosqGportTypeGlobalFabricMeshDev2:
        case bcmCosqGportTypeGlobalFabricMeshDev3:
        case bcmCosqGportTypeGlobalFabricMeshDev4:
        case bcmCosqGportTypeGlobalFabricMeshDev5:
        case bcmCosqGportTypeGlobalFabricMeshDev6:
        case bcmCosqGportTypeGlobalFabricMeshDev7:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocal:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalLow:
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalHigh:
        case bcmCosqGportTypeGlobalFabricClosFabric:
        case bcmCosqGportTypeGlobalFabricClosFabricHigh:
        case bcmCosqGportTypeGlobalFabricClosFabricLow:
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricHigh:
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricLow:
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteed:
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffort:
        case bcmCosqGportTypeGlobalFabricMeshMc:
        {
            gport_core_info.gport_type = gport_type;
            gport_core_info.flags = 0;
            gport_core_info.cosq = 0;
            gport_core_info.in_gport = 0;
            rc = bcm_petra_cosq_gport_handle_core_get(unit, BCM_CORE_ALL, &gport_core_info, &gport_info->out_gport);
            BCMDNX_IF_ERR_EXIT(rc);            
            break;
        }
        case bcmCosqGportTypeSched:
            {
              uint32 fap_port;
              bcm_cos_t priority;
              SOC_TMC_SCH_SE_ID se_id;
              int flow_id ;
              bcm_gport_t port_gport;

              rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport_info->in_gport, 0, &port_gport);
              BCMDNX_IF_ERR_EXIT(rc);

              if (BCM_GPORT_IS_SCHEDULER(port_gport)) {
                  /* Nothing to do */
                  gport_info->out_gport = port_gport;
                  break;
              }

              /* API is releavant for port TC or other Port physical gports */              
              rc = _bcm_petra_cosq_fap_port_get(unit, port_gport, &fap_port, &core, NULL);
              if (rc != BCM_E_NONE) {
                   LOG_ERROR(BSL_LS_BCM_COSQ,
                             (BSL_META_U(unit,
                                         "failed to get fap port for gport: 0x%x, error(0x%x)\n"), gport_info->in_gport, rc));
                  BCMDNX_IF_ERR_EXIT(rc);
              }
              if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
                  BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid fap port %d,  for gport (0x%x)"), unit, fap_port, gport_info->in_gport));
              }

              if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport) || BCM_COSQ_GPORT_IS_PORT_TC(port_gport)) {
                  /* Port-TC */
                  /* validate priority */
                  rc = _bcm_petra_cosq_port_priority_validate(unit,gport_info->in_gport,gport_info->cosq);
                  if (rc != BCM_E_NONE) {
                      LOG_ERROR(BSL_LS_BCM_COSQ,
                                (BSL_META_U(unit,
                                            "verify for gport: 0x%x cosq %d failed, error(0x%x)\n"), gport_info->in_gport, gport_info->cosq, rc));
                      BCMDNX_IF_ERR_EXIT(rc);
                  }
                  priority = gport_info->cosq;
              } else {
                  priority = DPP_COSQ_PB_DEFAULT_PORT_TC;
              }
              
              rc = _bcm_petra_cosq_port2se_id(unit,core,fap_port,priority,&se_id);            
              if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                  BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
              }
              flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
              if (SOC_IS_QAX(unit)) { /*set out_gport to lower 64k on QAX (32k on QUX) flow range, as the user would expect*/
                  flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
              }
              BCM_GPORT_SCHEDULER_CORE_SET(gport_info->out_gport, flow_id, core); 
            }
            break;
        case bcmCosqGportTypeFabricPipe:
            BCM_COSQ_GPORT_FABRIC_PIPE_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        case bcmCosqGportTypeFabricPipeEgress:
            BCM_COSQ_GPORT_FABRIC_PIPE_EGRESS_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        case bcmCosqGportTypeFabricPipeIngress:
            BCM_COSQ_GPORT_FABRIC_PIPE_INGRESS_SET(gport_info->out_gport, gport_info->in_gport, gport_info->cosq);
            break;
        default :
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid Handle type (%d) requested\n"), gport_type));
            rc = BCM_E_PARAM;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    _DCMN_BCM_WARM_BOOT_API_TEST_MODE_SKIP_WB_SEQUENCE(unit);
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_handle_core_get( 
    int unit, 
    int core, 
    bcm_cosq_gport_info_core_t *gport_info, 
    bcm_gport_t *out_gport)
{

    int my_modid;

    BCMDNX_INIT_FUNC_DEFS;

    switch (gport_info->gport_type) 
    {
        /* mesh scheme */
        case bcmCosqGportTypeGlobalFabricMeshLocal:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL_SET(*out_gport);
            break;
    case bcmCosqGportTypeGlobalFabricMeshDev0:
            BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid)); 
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                if (my_modid == 0) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            /* dest dev 0 should address current fap id */
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, my_modid);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 1) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 1);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 2) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 2);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 3) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 3);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev4:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 4) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 4);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev5:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 5) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 5);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev6:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 6) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 6);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev7:
            if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
                /* if my_moid == dest_dev, then set local context */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &my_modid));
                if (my_modid == 7) {
                    gport_info->gport_type = bcmCosqGportTypeGlobalFabricMeshLocal;
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_handle_core_get(unit, core, gport_info, out_gport));
                }
            }
            BCM_COSQ_GPORT_FABRIC_MESH_DEV_SET(*out_gport, 7);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonLocal0:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonLocal1:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev1:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev2:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV2_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonDev3:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_DEV3_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshCommonMc:
            BCM_COSQ_GPORT_FABRIC_MESH_COMMON_MC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev1MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev2MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV2_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3OcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3OcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3MixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshDev3MixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_DEV3_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcOcbHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcOcbLow:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcMixHigh:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMcMixLow:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal0:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshLocal1:
            BCM_COSQ_GPORT_FABRIC_MESH_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMeshMc:
            BCM_COSQ_GPORT_FABRIC_MESH_MC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricMesh:
            BCM_COSQ_GPORT_FABRIC_MESH_SCOPE_SET(*out_gport);
            break;

        /*close scheme */
        case bcmCosqGportTypeGlobalFabricClosUnicastLocal:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastLocalHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_LOCAL_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabricHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFabricLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_FABRIC_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteed:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffort:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BESTEFFORT_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonLocal0:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonLocal1:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonUnicastFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_UNICAST_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosCommonMulticastFabric:
            BCM_COSQ_GPORT_FABRIC_CLOS_COMMON_MULTICAST_FABRIC_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0OcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0OcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0MixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0MixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1OcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1OcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1MixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1MixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricOcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricMixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosUnicastFabricMixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_UNICAST_FABRIC_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteedOcb:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_OCB_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffortOcb:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BEST_EFFORT_OCB_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqGuaranteedMix:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_GUARANTEED_MIX_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosFmqBestEffortMix:
            BCM_COSQ_GPORT_FABRIC_CLOS_FMQ_BEST_EFFORT_MIX_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0High:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal0Low:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL0_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1High:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosLocal1Low:
            BCM_COSQ_GPORT_FABRIC_CLOS_LOCAL1_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosOcbHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_OCB_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosMixHigh:
            BCM_COSQ_GPORT_FABRIC_CLOS_MIX_HIGH_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosOcbLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_OCB_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClosMixLow:
            BCM_COSQ_GPORT_FABRIC_CLOS_MIX_LOW_SET(*out_gport);
            break;
        case bcmCosqGportTypeGlobalFabricClos:
            BCM_COSQ_GPORT_FABRIC_CLOS_SCOPE_SET(*out_gport);
            break;
        case bcmCosqGportTypeFabricRxUnicast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_UCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxMulticast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_MCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxTdm:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_TDM_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalUnicast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_UCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalMulticast:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_MCAST_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeFabricRxLocalTdm:
            BCM_COSQ_GPORT_FABRIC_RX_QUEUE_LOCAL_TDM_SET(*out_gport, core);
            break;
        /* FMQ/ISQ handle */
        case bcmCosqGportTypeGlobalFmqRoot:
            BCM_COSQ_GPORT_FMQ_ROOT_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqGuaranteed:
            BCM_COSQ_GPORT_FMQ_GUARANTEED_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffortAggregate:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT_AGR_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort0:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT0_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort1:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT1_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqBestEffort2:
            BCM_COSQ_GPORT_FMQ_BESTEFFORT2_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeGlobalFmqClass1:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 1);
            break;
        case bcmCosqGportTypeGlobalFmqClass2:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 2);
            break;
        case bcmCosqGportTypeGlobalFmqClass3:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 3);
            break;
        case bcmCosqGportTypeGlobalFmqClass4:
            BCM_COSQ_GPORT_FMQ_CLASS_CORE_SET(*out_gport, core, 4);
            break;
        case bcmCosqGportTypeGlobalIsqRoot:
            BCM_COSQ_GPORT_ISQ_ROOT_CORE_SET(*out_gport, core);
            break;
        case bcmCosqGportTypeCore:
            BCM_COSQ_GPORT_CORE_SET(*out_gport, core);
            break;
        default:
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
            break;
    }

    /* set core */
    if (BCM_GPORT_IS_FABRIC_MESH(*out_gport) || BCM_GPORT_IS_FABRIC_CLOS(*out_gport))
    {
        BCM_DPP_SCHEDULER_ONLY_CORE_SET(*out_gport, core);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_path_add(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* Common implementation with the remove function */
    rc = _bcm_petra_cosq_fc_path_add_remove(unit,
                                            FALSE /* is_for_delete */,
                                            fc_direction,
                                            source,
                                            target);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;

    /* Input Validation */
    if (source == NULL) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, flow control source not specified\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("flow control source not specified")));
    }
    if ((target == NULL) || (target_count == NULL)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, flow control target is NULL\n"), unit));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("flow control target is NULL")));
    }

    /* Different functions for Generation/Reception */
    if (fc_direction == bcmCosqFlowControlGeneration) {
        rc = _bcm_petra_cosq_generation_fc_path_get(unit, fc_direction, source, target_max, target, target_count);
    }
    else if (fc_direction == bcmCosqFlowControlReception) {
        rc = _bcm_petra_cosq_reception_fc_path_get(unit, fc_direction, source, target_max, target, target_count);
    }
    else {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, invalid flow control direction %d\n"), unit, fc_direction));
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("invalid flow control direction")));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* Common implementation with the remove function */
    rc = _bcm_petra_cosq_fc_path_add_remove(unit,
                                            TRUE /* is_for_delete */,
                                            fc_direction,
                                            source,
                                            target);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_pfc_config_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              uint32 flags,
                              bcm_cosq_pfc_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    if (config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid config parameter %p"), unit, config));
    }
    
    /* PFC FC settings include the following:
     * 1. Global thresholds (VSQ global) 
     * 2. PFC VSQ FC thresholds (VSQ PFC)
     * 3. LLFC VSQ FC thresholds (VSQ LLFC)                              
     */
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        if (BCM_COSQ_GPORT_IS_VSQ_GL(gport)) {
           rc = _bcm_petra_cosq_vsq_gl_fc_threshold_set(unit, gport, cosq, flags, config);
        } else {
           rc = _bcm_petra_cosq_vsq_fc_threshold_set(unit, gport, cosq, flags, config);
        } 
    } else {
      /* not supported gport */
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_pfc_config_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              uint32 flags,
                              bcm_cosq_pfc_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_COSQ_GPORT_IS_VSQ(gport)) {
        /* 1. vsq gl flow control thresholds */
        if (BCM_COSQ_GPORT_IS_VSQ_GL(gport)) {
           rc = _bcm_petra_cosq_vsq_gl_fc_threshold_get(unit, gport, cosq, flags, config);
        } else { /* FC thresholds for VSQs A-F */
           rc = _bcm_petra_cosq_vsq_fc_threshold_get(unit, gport, cosq, flags, config); 
        }
    } else {
      /* not supported gport */
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport 0x%x not supported gport"), unit, gport));
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int 
bcm_petra_cosq_qcn_config_set(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    rc = bcm_arad_cosq_qcn_config_set(unit, port, cosq, flags, config);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_qcn_config_get(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    rc = bcm_arad_cosq_qcn_config_get(unit, port, cosq, flags, config);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}



int 
bcm_arad_cosq_qcn_config_set(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    int base_qid, qid, cpq_index, cnm_queue_base;
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 
    int new_mapping_profile_id, is_allocated;
    int i, valid_samples;
    SOC_TMC_CNM_CPQ_INFO cpq_info;
    SOC_TMC_CNM_CP_PROFILE_INFO profile_info;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
    SOC_TMC_CNM_CP_PROFILE_INFO_clear(&profile_info);

    /* Validation */
    if(!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)))
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN settings only apply to GPORT of type UNICAST_QUEUE (VOQ)")));
    }
    if(config == NULL)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN config structure is NULL")));
    }

    /* Calcule CPQ index out of VOQ index and CPQ base queue */
    base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    qid = base_qid + cosq;

    rc = _bcm_petra_cosq_control_device_get(unit, BCM_CORE_ALL, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
    BCMDNX_IF_ERR_EXIT(rc);

    cpq_index = qid - cnm_queue_base;

    /* Translate the config into DPP structure */
    profile_info.q_eq = config->size;
    profile_info.cpw_power = config->weight;
    profile_info.max_neg_fb_value = config->max_feedback;
    profile_info.quant_div = config->quantization;
    profile_info.is_sampling_th_random = config->randomize_sample_threshold;
    valid_samples = SOC_SAND_MIN(config->nbr_samples, BCM_COS_COUNT);
    for(i = 0; i < valid_samples; i++)
    {
      profile_info.sampling_base[i] = config->sample_bytes[i];
    }

    /* Get current profile id */
    soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Exchange profile info */
    rc = _bcm_dpp_am_template_pool_cnm_queue_profile_exchange(unit, cpq_info.profile, &profile_info, &new_mapping_profile_id, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Update HW if needed */
    if(is_allocated)
    {
        rc = _bcm_arad_cosq_cnm_queue_profile_hw_set(unit, new_mapping_profile_id, &profile_info);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* Update the profile id of the CPQ */
    cpq_info.profile = new_mapping_profile_id;
    soc_sand_rc = arad_cnm_cpq_set(soc_sand_dev_id, cpq_index, &cpq_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
   BCMDNX_FUNC_RETURN;
}

int 
bcm_arad_cosq_qcn_config_get(int unit, 
                        bcm_gport_t port, 
                        bcm_cos_queue_t cosq, 
                        uint32 flags, 
                        bcm_cosq_qcn_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    int base_qid, qid, cpq_index, cnm_queue_base;
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 
    int i;
    SOC_TMC_CNM_CPQ_INFO cpq_info;
    SOC_TMC_CNM_CP_PROFILE_INFO profile_info;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);
    SOC_TMC_CNM_CP_PROFILE_INFO_clear(&profile_info);

    /* Validation */
    if(!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)))
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN settings only apply to GPORT of type UNICAST_QUEUE (VOQ)")));
    }
    if(config == NULL)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("QCN config structure is NULL")));
    }

    /* Calcule CPQ index out of VOQ index and CPQ base queue */
    base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    qid = base_qid + cosq;

    rc = _bcm_petra_cosq_control_device_get(unit, BCM_CORE_ALL, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
    BCMDNX_IF_ERR_EXIT(rc);

    cpq_index = qid - cnm_queue_base;

    /* Get current profile id */
    soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Get profile info */
    soc_sand_rc = arad_cnm_cp_profile_get(soc_sand_dev_id, cpq_info.profile, &profile_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Translate the DPP structure into config */
    config->size = profile_info.q_eq;
    config->weight = profile_info.cpw_power;
    config->max_feedback = profile_info.max_neg_fb_value;
    config->quantization = profile_info.quant_div;
    config->randomize_sample_threshold = profile_info.is_sampling_th_random;
    config->nbr_samples = BCM_COS_COUNT;
    for(i = 0; i < BCM_COS_COUNT; i++)
    {
      config->sample_bytes[i] = profile_info.sampling_base[i];
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
   BCMDNX_FUNC_RETURN;}

STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_set(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info)
{
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);

    soc_sand_rc = arad_cnm_cp_profile_set(soc_sand_dev_id, profile_id, profile_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_arad_cosq_cnm_queue_profile_hw_get(int unit, int profile_id, SOC_TMC_CNM_CP_PROFILE_INFO *profile_info)
{
    uint32 soc_sand_rc = 0, soc_sand_dev_id; 

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_dev_id = (unit);

    soc_sand_rc = arad_cnm_cp_profile_get(soc_sand_dev_id, profile_id, profile_info);
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;

}

int
_bcm_petra_cosq_fc_port_threshold_init(int unit, soc_port_t port, int *mc_reserved_pds, int is_dynamic)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int                     is_allocated, is_last, core;
    int                     template, old_template, tc;  
    uint32                  nof_priorities, num_of_channels, port_rate, tm_port;
    soc_port_if_t           interface_type;
    SOC_TMC_EGR_QUEUING_CGM_INIT_THRESHOLDS cgm_init_thresholds;

    BCMDNX_INIT_FUNC_DEFS;

    SOCDNX_IF_ERR_EXIT(soc_port_sw_db_interface_type_get(unit, port, &interface_type));
    if (interface_type == SOC_PORT_IF_NULL) {
        *mc_reserved_pds = 0;
        return BCM_E_NONE;
    }

    /* IF rate mbps */
    rc = soc_port_sw_db_interface_rate_get(unit, port, &port_rate);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    if(nof_priorities == 0)
    {
      rc = BCM_E_INTERNAL;
      BCMDNX_IF_ERR_EXIT(rc);
    }

    SOCDNX_IF_ERR_EXIT(soc_port_sw_db_num_of_channels_get(unit, port, &num_of_channels));

    SOCDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core));

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_init_thresholds, (unit, port_rate, nof_priorities,num_of_channels, &cgm_init_thresholds)));
    /* override in case of dynamic port */
    if(is_dynamic) {
        cgm_init_thresholds.mc_reserved_pds = 0;
    }
    *mc_reserved_pds = cgm_init_thresholds.mc_reserved_pds;
 
    /* Old data get */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit, core, port, &thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    /* PORT */
    thresh_key.port_fc_packet_descriptors = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_packet_descriptors_min = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_packet_descriptors_alpha = 0;
    thresh_key.port_fc_data_buffers = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_data_buffers_min = cgm_init_thresholds.threshold_port;
    thresh_key.port_fc_data_buffers_alpha = 0;
    thresh_key.unsch_drop_packet_descriptors = cgm_init_thresholds.port_mc_drop_pds;
    thresh_key.unsch_drop_packet_descriptors_min = cgm_init_thresholds.port_mc_drop_pds;
    thresh_key.unsch_drop_packet_descriptors_alpha = 0;
    thresh_key.unsch_drop_data_buffers = cgm_init_thresholds.port_mc_drop_dbs;

    /* PORT UC DROP (Device)  */
    thresh_key.sch_drop_packet_descriptors = cgm_init_thresholds.drop_pds_th;
    thresh_key.sch_drop_data_buffers = cgm_init_thresholds.drop_dbs_th;

    /* QUEUE */
    for(tc = 0; tc < nof_priorities; tc++)
    {
      thresh_key.sch_fc_packet_descriptors_tc[tc] = cgm_init_thresholds.threshold_queue;
      thresh_key.sch_fc_packet_descriptors_min_tc[tc] = cgm_init_thresholds.threshold_queue;
      thresh_key.sch_fc_packet_descriptors_alpha_tc[tc] = 0;
      thresh_key.sch_fc_data_buffers_tc[tc] = cgm_init_thresholds.threshold_queue;
      thresh_key.sch_fc_data_buffers_min_tc[tc] = cgm_init_thresholds.threshold_queue;
      thresh_key.sch_fc_data_buffers_alpha_tc[tc] = 0;
      thresh_key.sch_drop_data_buffers_tc[tc] = cgm_init_thresholds.drop_dbs_th;
      thresh_key.sch_drop_packet_descriptors_tc[tc] = cgm_init_thresholds.drop_pds_th_tc;
    }

    /* MC per TC/DP */
    if((!SOC_IS_JERICHO(unit)) && (cgm_init_thresholds.port_mc_drop_pds > DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH))
    {
      /* This value is now used for queue thresholds */
      cgm_init_thresholds.port_mc_drop_pds = 4050;
      
      for(tc = 0; tc < nof_priorities; tc++) {
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;

        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;

        thresh_key.unsch_drop_data_buffers_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_dbs;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_dbs / 10;

      }
    }
    else if (SOC_IS_QUX(unit))
    {
      for(tc = 0; tc < nof_priorities; tc++) {
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds * 4 / 5;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds * 3 / 5;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds * 2 / 5;

        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds * 4 / 5;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds * 3 / 5;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds * 2 / 5;
    
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_dbs;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_dbs * 4 / 5;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_dbs * 3 / 5;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_dbs * 2 / 5;
      }
    }
    else
    {
      for(tc = 0; tc < nof_priorities; tc++) {
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;

        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_pds;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_pds / 2;
        thresh_key.unsch_drop_packet_descriptors_min_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_pds / 10;
    
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][0] = cgm_init_thresholds.port_mc_drop_dbs;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][1] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][2] = cgm_init_thresholds.port_mc_drop_dbs / 2;
        thresh_key.unsch_drop_data_buffers_tc_dp[tc][3] = cgm_init_thresholds.port_mc_drop_dbs / 10;
      }
    }

    /* Reserved MC PDs */
    for (tc = 0; tc < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); tc++) {
        thresh_key.unsch_drop_packet_descriptors_available_tc[tc] = *mc_reserved_pds;
    }

    /* Set new object */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_exchange(unit,core,port,&thresh_key,&old_template,&is_last,&template,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (old_template != template) {
        /* Set new profile */
        rc = _bcm_petra_cosq_egress_thresh_profile_set(unit,port,template);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_allocated) {
        /* Set new data for a specific profile */
        rc = _bcm_arad_cosq_egress_thresh_profile_data_set(unit,core,template,&thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
  BCMDNX_FUNC_RETURN;
}

/*
 * initialization corresponding to the configuration indicated via SOC properties
 * All consistency checks and ressetting the configuration to be consistent has been
 * already done during soc_init(). Reference drv.c. Thus no consistency checks are
 * done during bcm_petra_init()/cosq_init().
 */
STATIC int
_bcm_petra_cosq_fc_init(int unit)
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    SOC_TMC_FC_CAL_IF_INFO        cal_if_info;
    SOC_TMC_FC_REC_CALENDAR      *cal_buff = NULL;
    SOC_TMC_FC_CAL_MODE           cal_mode_ndx = 0;
    SOC_TMC_FC_DIRECTION       direction_ndx;
    SOC_TMC_FC_GEN_CALENDAR      *gen_cal_buff = NULL;
    int                      oob_if, ilkn_if, core;
    uint32                   soc_sand_rc = SOC_SAND_OK, dev_id, flags;
    int                      cal_index /*rx_cal_len, tx_cal_len*/;
    int                      is_coldboot = TRUE;
    SOC_TMC_FC_ILKN_LLFC_INFO     llfc_info;
    pbmp_t                  ports_map;
    soc_port_t              port_i;
    int                     fc_mode;
    uint32                  phy_port;
    int                     any_port_with_1_priority = 0;
    int total_mc_reserved_pds_sp0[2], total_mc_reserved_pds_sp1[2];
    soc_port_if_t           interface_type;
    uint32                  nof_priorities, tm_port;
    int                     tc, dp;
    int                     mc_reserved_pds;    
    bcm_cosq_egress_multicast_config_t sp_config;
    int                     nof_tc_to_sp0;
    ARAD_FC_ILKN_RETRANSMIT_CAL_CFG ilkn_rt_cal;
    SOC_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int                           priority = 0;
    bcm_gport_t             gport;

    uint32 profile;
    bcm_dpp_cosq_egress_queue_mapping_info_t *mapping_info = NULL;
    uint32 offset;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    
    dev_id =  (unit);

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        is_coldboot = FALSE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    BCMDNX_ALLOC(mapping_info, sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t), "egress queue mapping info handle memory");
    if (mapping_info == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate egress queue mapping info handle memory\n"), unit));
    }
    sal_memset(mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_REC_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    BCMDNX_ALLOC(gen_cal_buff, (sizeof(SOC_TMC_FC_GEN_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "gen fc calender");
    if (gen_cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory\n"), unit));
    }

    if (is_coldboot) {
        /* By default all zeros */
        if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
            for (priority = 0; priority < SOC_TMC_EGR_NOF_Q_PRIO_ARAD; priority++) {
                SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_fc_generic_pfc_mapping_init(unit, priority, SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps), &generic_bm));
            }
        }
        else {
            SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
            BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_fc_generic_pfc_mapping_init(unit, 0, SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps), &generic_bm));
        }
    }

    /* process OOB configuration */
    for (oob_if = 0; oob_if < SOC_DPP_CONFIG(unit)->tm.max_oob_ports; oob_if++) {
        if (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] == SOC_DPP_FC_CAL_MODE_DISABLE) {
            continue;
        }

        if (SOC_DPP_CONFIG(unit)->tm.fc_oob_type[oob_if] == SOC_TMC_FC_CAL_TYPE_NONE) {
            continue;
        }

        if ((SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_RX_ENABLE) ||
            (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_TX_ENABLE) ) {
            if (SOC_IS_QAX(unit)) {
                if(SOC_DPP_CONFIG(unit)->tm.fc_oob_type[oob_if] == SOC_TMC_FC_CAL_TYPE_ILKN) {
                    cal_mode_ndx = SOC_TMC_FC_CAL_MODE_ILKN_OOB;
                } else if (SOC_DPP_CONFIG(unit)->tm.fc_oob_type[oob_if] == SOC_TMC_FC_CAL_TYPE_SPI) {
                    cal_mode_ndx = SOC_TMC_FC_CAL_MODE_SPI_OOB;
                } else {
                    cal_mode_ndx = SOC_TMC_FC_CAL_MODE_IHB_OOB;
                }
            } else {
                cal_mode_ndx = (SOC_DPP_CONFIG(unit)->tm.fc_oob_type[oob_if] == SOC_TMC_FC_CAL_TYPE_ILKN || 
                                SOC_DPP_CONFIG(unit)->tm.fc_oob_type[oob_if] == SOC_TMC_FC_CAL_TYPE_COE || 
                                SOC_DPP_CONFIG(unit)->tm.fc_oob_type[oob_if] == SOC_TMC_FC_CAL_TYPE_E2E) ? 
                                SOC_TMC_FC_CAL_MODE_ILKN_OOB : SOC_TMC_FC_CAL_MODE_SPI_OOB;
            }
        }

        if (is_coldboot) {
            /* OOB interfaces can only be uni-directional */
            if (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_RX_ENABLE) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.rx.valid.set(unit, oob_if, TRUE));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.rx.intf.set(unit, oob_if, oob_if));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.rx.cal_mode_ndx.set(unit, oob_if, cal_mode_ndx));
            }

            if (SOC_DPP_CONFIG(unit)->tm.fc_oob_mode[oob_if] & SOC_DPP_FC_CAL_MODE_TX_ENABLE) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.tx.valid.set(unit, oob_if, TRUE));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.tx.intf.set(unit, oob_if, oob_if));
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.tx.cal_mode_ndx.set(unit, oob_if, cal_mode_ndx));
            }
        }
    }

    /* process Inband configuration */
    if (is_coldboot) {
        BCM_PBMP_ASSIGN(ports_map, PBMP_ALL(unit));
        BCM_PBMP_REMOVE(ports_map, PBMP_SFI_ALL(unit));
        BCM_PBMP_ITER(ports_map, port_i) 
        {
            /* skip stat ports */
            soc_rc = soc_port_sw_db_flags_get(unit, port_i, &flags);
            SOCDNX_IF_ERR_EXIT(soc_rc);
            if (SOC_PORT_IS_STAT_INTERFACE(flags)) {
                continue;
            }

            soc_rc = soc_port_sw_db_interface_type_get(unit, port_i, &interface_type);        
            SOCDNX_IF_ERR_EXIT(soc_rc);

            if (interface_type == SOC_PORT_IF_NULL || interface_type == SOC_PORT_IF_CPU ||
                interface_type == SOC_PORT_IF_OLP || interface_type == SOC_PORT_IF_RCY ||
                interface_type == SOC_PORT_IF_SAT || interface_type == SOC_PORT_IF_IPSEC ||
                interface_type == SOC_PORT_IF_ERP || interface_type == SOC_PORT_IF_OAMP ||
                interface_type == SOC_PORT_IF_ILKN || interface_type == SOC_PORT_IF_TM_INTERNAL_PKT) {
                continue;
            }

            soc_rc = soc_port_sw_db_first_phy_port_get(unit, port_i, &phy_port);
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error retreiving phy_port for port (0x%x)\n"), unit, port_i));
            }

            if (!SOC_IS_QAX(unit)) {
                fc_mode = SOC_DPP_CONFIG(unit)->tm.fc_inband_mode[port_i][SOC_TMC_CONNECTION_DIRECTION_RX];
                /* 0=DISABLE (TX default), 1=LLFC (RX default), 2=PFC, 3=SAFC */
                switch(fc_mode)
                {
                case 0:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCReceive, 0);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 1:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCReceive, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 2:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlPFCReceive, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 3:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlSAFCReceive, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                default:
                    break;
                }

                fc_mode = SOC_DPP_CONFIG(unit)->tm.fc_inband_mode[port_i][SOC_TMC_CONNECTION_DIRECTION_TX];
                /* 0=DISABLE (TX default), 1=LLFC (RX default), 2=PFC, 3=SAFC */
                switch(fc_mode)
                {
                case 0:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCTransmit, 0);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 1:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlLLFCTransmit, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 2:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlPFCTransmit, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlPFCRefreshTime, -1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                case 3:
                    rc = bcm_petra_port_control_set(unit, port_i, bcmPortControlSAFCTransmit, 1);
                    if(rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in setting port fc mode %d\n"), unit, rc, port_i));
                    }
                    break;
                default:
                    break;
                }
            }
        }
    }

    /* Process ILKN In-band configuration */
    if (!SOC_IS_QUX(unit)) {
        for (ilkn_if = 0; ilkn_if < SOC_DPP_CONFIG(unit)->tm.max_interlaken_ports; ilkn_if++) {
            if ((SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_type[ilkn_if] != SOC_TMC_FC_CAL_INB_TYPE_ILKN)
                && (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_type[ilkn_if] != SOC_TMC_FC_CAL_INB_TYPE_COE)) {
                continue;
            }

            SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
            if ((SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DPP_FC_CAL_MODE_RX_ENABLE) ||
               (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DPP_FC_CAL_MODE_TX_ENABLE)) {
               if(SOC_IS_QAX(unit) && (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_type[ilkn_if] == SOC_TMC_FC_CAL_INB_TYPE_COE)) {
                   cal_mode_ndx = SOC_TMC_FC_CAL_MODE_IHB_INBND;
               } else {
                   cal_mode_ndx = SOC_TMC_FC_CAL_MODE_ILKN_INBND;
               }
            }

            /* inband interfaces can be bi-directional */
            if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DPP_FC_CAL_MODE_RX_ENABLE) {
                if (is_coldboot)
                {
                    cal_if_info.enable = TRUE;
                    cal_if_info.cal_len = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX];

                    for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                        SOC_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
                        (cal_buff + cal_index)->destination = SOC_TMC_FC_REC_CAL_DEST_NONE;
                        (cal_buff + cal_index)->id = 0;
                    }

                    cal_if_info.cal_reps = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_rep_count[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX];
            
                    soc_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_set,(unit, cal_mode_ndx, ilkn_if, &cal_if_info, cal_buff)));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Inband(Rx) calender(%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }

                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.rx.valid.set(unit, ilkn_if, TRUE));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.rx.intf.set(unit, ilkn_if, ilkn_if));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.rx.cal_mode_ndx.set(unit, ilkn_if, cal_mode_ndx));
                }
            }

            if (is_coldboot) {
                /* inband-llfc configuration */
                SOC_TMC_FC_ILKN_LLFC_INFO_clear(&llfc_info);

                if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[ilkn_if] != SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE_DISABLE) {
                    llfc_info.cal_channel = (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[ilkn_if] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE1) ?
                                   SOC_TMC_FC_ILKN_CAL_LLFC_CH_0 : SOC_TMC_FC_ILKN_CAL_LLFC_CH_16N;
                    llfc_info.multi_use_mask = 0;
                }
                else if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_llfc_mub_enable_mask[ilkn_if] != SOC_DPP_FC_INBAND_INTLKN_LLFC_MUB_DISABLE) {
                    llfc_info.cal_channel = SOC_TMC_FC_ILKN_CAL_LLFC_NONE;
                    llfc_info.multi_use_mask = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_llfc_mub_enable_mask[ilkn_if];
                } else {
                    llfc_info.cal_channel = SOC_TMC_FC_ILKN_CAL_LLFC_NONE;
                    llfc_info.multi_use_mask = 0;
                }

                direction_ndx = SOC_TMC_FC_DIRECTION_REC;      
                if (!SOC_IS_ARDON(unit)) {
                    soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_ilkn_llfc_set,(dev_id, ilkn_if, direction_ndx, &llfc_info));
                    if (SOC_FAILURE(soc_rc)) {
                       rc = soc_rc;
                       BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Rx) llfc (%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }                
                }

                direction_ndx = SOC_TMC_FC_DIRECTION_GEN;
                flags = 0;
                PBMP_IL_ITER(unit, port_i)  {
                    SOCDNX_IF_ERR_EXIT(soc_port_sw_db_protocol_offset_get(unit, port_i, 0, &offset));
                    if (offset == ilkn_if) {
                        SOCDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, port_i, &flags));
                        break;
                    }
                }

                /* Disable LLFC TX on ELK interface */
                if (SOC_DPP_IS_ELK_ENABLE(unit) && SOC_PORT_IS_ELK_INTERFACE(flags)) {
                    llfc_info.cal_channel = SOC_TMC_FC_ILKN_CAL_LLFC_NONE;
                }

                if (!SOC_IS_ARDON(unit)) {
                    soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_ilkn_llfc_set, (dev_id, ilkn_if, direction_ndx, &llfc_info));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Tx) llfc (%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }                
                }

                /* mub channel configuration */
                direction_ndx = SOC_TMC_FC_DIRECTION_REC;
                if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX] != SOC_DPP_FC_INBAND_INTLKN_CHANNEL_MUB_DISABLE) {
                    soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_ilkn_mub_channel_set,(unit, ilkn_if, direction_ndx, SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX]));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Rx)(%d) MUB channel setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }
                }
                direction_ndx = SOC_TMC_FC_DIRECTION_GEN;
                if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX] != SOC_DPP_FC_INBAND_INTLKN_CHANNEL_MUB_DISABLE) {
                    soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_ilkn_mub_channel_set,(unit, ilkn_if, direction_ndx, SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_channel_mub_enable_mask[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX]));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Interlaken(Tx)(%d) MUB channel setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }
                }
            }

            if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_mode[ilkn_if] & SOC_DPP_FC_CAL_MODE_TX_ENABLE) {
                if (is_coldboot)
                {
                    cal_if_info.enable = TRUE;
                    cal_if_info.cal_len = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX];

                    for (cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++) {
                        SOC_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
                        (gen_cal_buff + cal_index)->source = SOC_TMC_FC_GEN_CAL_SRC_CONST;
                        (gen_cal_buff + cal_index)->id = 0;
                    }

                    cal_if_info.cal_reps = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_rep_count[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX];
        
                    soc_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_set,(unit, cal_mode_ndx, ilkn_if, &cal_if_info, gen_cal_buff)));
                    if (SOC_FAILURE(soc_rc)) {
                        rc = soc_rc;
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in Inband(Tx) calender(%d) setting, error 0x%x\n"), unit, ilkn_if, rc));
                    }

                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.tx.valid.set(unit, ilkn_if, TRUE));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.tx.intf.set(unit, ilkn_if, ilkn_if));
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.tx.cal_mode_ndx.set(unit, ilkn_if, cal_mode_ndx));
                }
            }
        }
    }

    if (is_coldboot) 
    {
        if (SOC_IS_ARADPLUS_AND_BELOW(unit) && 
            SOC_IS_ARAD_B0_AND_ABOVE(unit))
        {
            /* Handle ILKN Retransmit calendars for Arad B0 */
            for (ilkn_if = 0; ilkn_if < SOC_DPP_CONFIG(unit)->tm.max_interlaken_ports; ilkn_if++) {
                ARAD_FC_ILKN_RETRANSMIT_CAL_CFG_clear(&ilkn_rt_cal);
                switch(SOC_DPP_CONFIG(unit)->tm.fc_ilkn_rt_calendar_mode[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_RX])
                {
                case 0:
                    ilkn_rt_cal.enable = 0;
                    break;
                case 1:
                    /* The RX calendar is hard coded in the HW */
                    /* It needs 1 entry to support Retransmit on one interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 1;
                    break;
                case 2:
                    /* The RX calendar is hard coded in the HW */
                    /* It needs 3 entries to support Retransmit for both interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 3; 
                    break;
                default:
                    ilkn_rt_cal.enable = 0;
                    break;
                }
                soc_sand_rc = arad_fc_ilkn_retransmit_cal_set(dev_id, (ilkn_if == 0 ? ARAD_NIF_ILKN_ID_A : ARAD_NIF_ILKN_ID_B), ARAD_FC_DIRECTION_REC, &ilkn_rt_cal);        
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in ILKN Retransmit RX calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
                }

                ARAD_FC_ILKN_RETRANSMIT_CAL_CFG_clear(&ilkn_rt_cal);
                switch(SOC_DPP_CONFIG(unit)->tm.fc_ilkn_rt_calendar_mode[ilkn_if][SOC_TMC_CONNECTION_DIRECTION_TX])
                {
                case 0:
                    ilkn_rt_cal.enable = 0;
                    break;
                case 1:
                    /* The TX calendar is hard coded in the SW */
                    /* It needs 1 entry to support Retransmit on one interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 1;
                    break;
                case 2:
                    /* The TX calendar is hard coded in the SW */
                    /* It needs 2 entries to support Retransmit for both interfaces */
                    ilkn_rt_cal.enable = 1;
                    ilkn_rt_cal.length = 2; 
                    break;
                default:
                    ilkn_rt_cal.enable = 0;
                    break;
                }
                soc_sand_rc = arad_fc_ilkn_retransmit_cal_set(dev_id, (ilkn_if == 0 ? ARAD_NIF_ILKN_ID_A : ARAD_NIF_ILKN_ID_B), ARAD_FC_DIRECTION_GEN, &ilkn_rt_cal);        
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in ILKN Retransmit TX calender(%d) setting, soc_sand error 0x%x, error 0x%x\n"), unit, ilkn_if, soc_sand_rc, rc));
                }
            }
        }

        if (SOC_IS_ARDON(unit)) {
            rc = arad_fc_init_shr_mapping(unit);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_init_pfc_mapping,(unit));
        if (SOC_FAILURE(soc_rc)) {
            rc = soc_rc;
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to set PFC/TC mapping, error 0x%x\n"), unit, rc));
        }

        profile = DPP_COSQ_PB_EGR_QUEUE_DEFAULT_PROFILE_MAP;

        /* Set default configuration */
        SOC_DPP_CORES_ITER(BCM_CORE_ALL, core) {
            rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_get(unit, profile, core, mapping_info);
            BCMDNX_IF_ERR_EXIT(rc);

            /* state restored during warmboot */
            rc = _bcm_dpp_am_template_egress_queue_mapping_init(unit, profile, core, mapping_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        total_mc_reserved_pds_sp0[0] = 0;
        total_mc_reserved_pds_sp0[1] = 0;
        total_mc_reserved_pds_sp1[0] = 0;
        total_mc_reserved_pds_sp1[1] = 0;

        /* EGQ Threshold Settings */

        SOCDNX_IF_ERR_EXIT(soc_port_sw_db_valid_ports_get(unit, 0, &ports_map)); 

        BCM_PBMP_ITER(ports_map, port_i) {

            SOCDNX_IF_ERR_EXIT(soc_port_sw_db_interface_type_get(unit, port_i, &interface_type));
            SOCDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, port_i, &flags));
                          
            if ((SOC_PORT_IS_NOT_VALID_FOR_EGRESS_TM(flags) || 
                 (interface_type == SOC_PORT_IF_ERP) || (interface_type == SOC_PORT_IF_NOCXN))) {
                continue;
            }
            rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
            if(rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting port nof_priorities %d\n"), unit, rc, port_i));
            }

            if(nof_priorities == 1) {
                any_port_with_1_priority = 1;
                break;
            }
        }

        BCM_PBMP_ITER(ports_map, port_i) {

            SOCDNX_IF_ERR_EXIT(soc_port_sw_db_interface_type_get(unit, port_i, &interface_type));
            SOCDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, port_i, &flags));
            if (!(SOC_PORT_IS_NOT_VALID_FOR_EGRESS_TM(flags) || 
                  (interface_type == SOC_PORT_IF_ERP) || (interface_type == SOC_PORT_IF_NOCXN))) {

                /* init tc/dp map table */
                rc = _bcm_petra_cosq_gport_egress_map_init(unit, port_i);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set fc port thresholds */
                rc = _bcm_petra_cosq_fc_port_threshold_init(unit, port_i, &mc_reserved_pds, 0);
                if(rc != BCM_E_NONE) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting port rate %d\n"), unit, rc, port_i));
                }

                rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
                if(rc != BCM_E_NONE) {
                  BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting parent nif for port %d\n"), unit, rc, port_i));
                }

                rc = soc_port_sw_db_local_to_tm_port_get(unit, port_i, &tm_port, &core);
                if (rc != BCM_E_NONE)
                {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error (%d) in getting tm port and core for port %d\n"), unit, rc, port_i));
                }
             
                if (SOC_IS_ARDON(unit) || SOC_IS_QUX(unit)) {
                      total_mc_reserved_pds_sp0[core] += (mc_reserved_pds * nof_priorities);
                } else {
                    if(any_port_with_1_priority == 1 || SOC_DPP_CONFIG(unit)->arad->init.dynamic_port_enable) {
                           total_mc_reserved_pds_sp0[core] += (mc_reserved_pds * nof_priorities);
                    } else {
                           total_mc_reserved_pds_sp0[core] += ((mc_reserved_pds * nof_priorities) / 2);
                           total_mc_reserved_pds_sp1[core] += ((mc_reserved_pds * nof_priorities) / 2);
                    }
                }
            }
        }

        SOC_DPP_CORES_ITER(SOC_CORE_ALL, core)
        {
            soc_sand_rc = _bcm_petra_cosq_default_thresholds_set(unit,core, (any_port_with_1_priority == 1 || SOC_DPP_CONFIG(unit)->arad->init.dynamic_port_enable),\
                                                                  total_mc_reserved_pds_sp0[core], total_mc_reserved_pds_sp1[core]);
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
            }
        }

        BCM_COSQ_GPORT_CORE_SET(gport, BCM_CORE_ALL);
        /* MC TC to SP Mapping */
        if (SOC_IS_ARDON(unit) || SOC_IS_QUX(unit)) {
            /* TC0-TC7 to SP0 */
            nof_tc_to_sp0 = 8;
        } else {
            /* TC0-TC3 to SP0 */
            nof_tc_to_sp0 = 4;
        }
        sp_config.unscheduled_se = 1;   /* Pool eligibility */
        sp_config.unscheduled_sp = bcmCosqEgressMulticastServicePool0;   /* Pool ID */
        for(tc = 0; tc < nof_tc_to_sp0 ; tc++)
        {
            sp_config.priority = tc;         /* TC group */
            for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++)
            {
              rc = bcm_petra_cosq_gport_egress_multicast_config_set(unit, gport, tc, dp, BCM_COSQ_MULTICAST_UNSCHEDULED, &sp_config);
              BCMDNX_IF_ERR_EXIT(rc);
            }
        }

        /* TC4-TC7 to SP0\SP1 */
        sp_config.unscheduled_se = 1;   /* Pool eligibility */
        sp_config.unscheduled_sp = ((any_port_with_1_priority == 1 || SOC_DPP_CONFIG(unit)->arad->init.dynamic_port_enable == 1) ? bcmCosqEgressMulticastServicePool0 : bcmCosqEgressMulticastServicePool1);   /* Pool ID */
        for(tc = nof_tc_to_sp0; tc < 8; tc++)
        {
            sp_config.priority = tc;         /* TC group */
            for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++)
            {
                rc = bcm_petra_cosq_gport_egress_multicast_config_set(unit, gport, tc, dp, BCM_COSQ_MULTICAST_UNSCHEDULED, &sp_config);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
     
        /* Enable device-level flow control */
        rc = bcm_petra_cosq_control_set(unit, 0, 0, bcmCosqControlFlowControlEnable, 1);
        if(rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error(%d) in enabling device-level flow control\n"), unit, rc));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

exit:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    if (gen_cal_buff != NULL) {
       BCM_FREE(gen_cal_buff);
    }

    BCM_FREE(cal_buff);
    BCM_FREE(gen_cal_buff);
    BCM_FREE(mapping_info);

    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_default_thresholds_set(int unit, int core, int any_port_with_1_priority, int total_mc_reserved_pds_sp0, int total_mc_reserved_pds_sp1)
{
    SOC_TMC_EGR_QUEUING_DEV_TH  *dev_thresh = NULL;
    ARAD_EGR_FC_DEVICE_THRESH dev_fc_thresh, dev_fc_thresh_exact;
    ARAD_EGR_FC_OFP_THRESH  fc_mc_thresh, exact_fc_mc_thresh;
    uint32  soc_sand_rc=0;
    bcm_error_t              rc = BCM_E_NONE;
    int tc;
    BCMDNX_INIT_FUNC_DEFS;

    /* Global Drop Thresholds */
    BCMDNX_ALLOC(dev_thresh, sizeof(SOC_TMC_EGR_QUEUING_DEV_TH), "_bcm_petra_cosq_fc_init.dev_thresh");
    if (dev_thresh == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }
    SOC_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, core,dev_thresh)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
    }

    if (unit >= BCM_LOCAL_UNITS_MAX){
        BCM_ERR_EXIT_NO_MSG(BCM_E_UNIT);
    }
    if (SOC_IS_ARDON(unit)) { 
        dev_thresh->global.uc.descriptors = 6000;
        dev_thresh->global.mc.descriptors = 10000;
        dev_thresh->global.total.descriptors = 16000;
        dev_thresh->pool[0].mc.descriptors = 10000;
        dev_thresh->pool[1].mc.descriptors = 10000;
          
        dev_thresh->global.uc.buffers = 6000;
        dev_thresh->global.mc.buffers = 3000;
        dev_thresh->global.total.buffers = 6000;
        dev_thresh->pool[0].mc.buffers = 3000;
        dev_thresh->pool[1].mc.buffers = 3000;
          
        dev_thresh->pool[0].reserved.buffers = 400;
        dev_thresh->pool[1].reserved.buffers = 0;
    }
    else if (SOC_IS_QUX(unit)) {
        dev_thresh->global.uc.descriptors = 4090;
        dev_thresh->global.mc.descriptors = 9723;
        dev_thresh->global.total.descriptors = 11768;
        dev_thresh->pool[0].mc.descriptors = 9723;
        dev_thresh->pool[1].mc.descriptors = 0;

        dev_thresh->global.uc.buffers = 4090;
        dev_thresh->global.mc.buffers = 2045;
        dev_thresh->global.total.buffers = 4090;
        dev_thresh->pool[0].mc.buffers = 2045;
        dev_thresh->pool[1].mc.buffers = 0;
        
        dev_thresh->pool[0].reserved.buffers = 600;
        dev_thresh->pool[1].reserved.buffers = 0;
    }
    else {
        dev_thresh->global.uc.descriptors = SOC_DPP_IMP_DEFS_GET(unit, egr_total_uc_pd);
        dev_thresh->global.mc.descriptors = SOC_DPP_IMP_DEFS_GET(unit, egr_total_mc_pd);
        dev_thresh->global.total.descriptors = SOC_DPP_IMP_DEFS_GET(unit, egr_total_pd);
        dev_thresh->pool[0].mc.descriptors = (dev_thresh->global.mc.descriptors /2);
        dev_thresh->pool[1].mc.descriptors = (dev_thresh->global.mc.descriptors /2);
          
        dev_thresh->global.uc.buffers = SOC_DPP_IMP_DEFS_GET(unit, egr_total_uc_db);
        dev_thresh->global.mc.buffers = SOC_DPP_IMP_DEFS_GET(unit, egr_total_mc_db);
        dev_thresh->global.total.buffers = SOC_DPP_IMP_DEFS_GET(unit, egr_total_db);
        dev_thresh->pool[0].mc.buffers = (dev_thresh->global.mc.buffers/2);
        dev_thresh->pool[1].mc.buffers = (dev_thresh->global.mc.buffers/2);
        
        dev_thresh->pool[0].reserved.buffers = any_port_with_1_priority ? 1200 : 600;
        dev_thresh->pool[1].reserved.buffers = any_port_with_1_priority ? 0    : 600;
    }

    if((total_mc_reserved_pds_sp0 + total_mc_reserved_pds_sp1) > (2*DPP_COSQ_MAX_SP_PD_THRESH) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Allocated more Reserved Packet Descriptors than allowed by the device.")));
    }
      dev_thresh->pool[0].reserved.descriptors = total_mc_reserved_pds_sp0;
      dev_thresh->pool[1].reserved.descriptors = total_mc_reserved_pds_sp1;


    if (SOC_IS_ARDON(unit)) {
        if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
        {
            /* Discrete Partition */
                dev_thresh->pool_tc[0][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][5].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][6].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][7].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][0].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][1].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][2].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][3].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][6].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][7].mc.descriptors = 6500;

                dev_thresh->pool_tc[0][0].mc.buffers = 1500;
                dev_thresh->pool_tc[0][1].mc.buffers = 1500;
                dev_thresh->pool_tc[0][2].mc.buffers = 1500;
                dev_thresh->pool_tc[0][3].mc.buffers = 1500;
                dev_thresh->pool_tc[0][4].mc.buffers = 1500;
                dev_thresh->pool_tc[0][5].mc.buffers = 1500;
                dev_thresh->pool_tc[0][6].mc.buffers = 1500;
                dev_thresh->pool_tc[0][7].mc.buffers = 1500;
                dev_thresh->pool_tc[1][0].mc.buffers = 1500;
                dev_thresh->pool_tc[1][1].mc.buffers = 1500;
                dev_thresh->pool_tc[1][2].mc.buffers = 1500;
                dev_thresh->pool_tc[1][3].mc.buffers = 1500;
                dev_thresh->pool_tc[1][4].mc.buffers = 1500;
                dev_thresh->pool_tc[1][5].mc.buffers = 1500;
                dev_thresh->pool_tc[1][6].mc.buffers = 1500;
                dev_thresh->pool_tc[1][7].mc.buffers = 1500;

                dev_thresh->pool_tc[0][0].reserved.buffers = 50;
                dev_thresh->pool_tc[0][1].reserved.buffers = 50;
                dev_thresh->pool_tc[0][2].reserved.buffers = 50;
                dev_thresh->pool_tc[0][3].reserved.buffers = 50;
                dev_thresh->pool_tc[0][4].reserved.buffers = 50;
                dev_thresh->pool_tc[0][5].reserved.buffers = 50;
                dev_thresh->pool_tc[0][6].reserved.buffers = 50;
                dev_thresh->pool_tc[0][7].reserved.buffers = 50;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;

        } else {

                /* Strict Priority */
                dev_thresh->pool_tc[0][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[0][1].mc.descriptors = 10400;
                dev_thresh->pool_tc[0][2].mc.descriptors = 9100;
                dev_thresh->pool_tc[0][3].mc.descriptors = 7800;
                dev_thresh->pool_tc[0][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[0][5].mc.descriptors = 5200;
                dev_thresh->pool_tc[0][6].mc.descriptors = 3900;
                dev_thresh->pool_tc[0][7].mc.descriptors = 13000;
                dev_thresh->pool_tc[1][0].mc.descriptors = 13000;
                dev_thresh->pool_tc[1][1].mc.descriptors = 10400;
                dev_thresh->pool_tc[1][2].mc.descriptors = 9100;
                dev_thresh->pool_tc[1][3].mc.descriptors = 7800;
                dev_thresh->pool_tc[1][4].mc.descriptors = 6500;
                dev_thresh->pool_tc[1][5].mc.descriptors = 5200;
                dev_thresh->pool_tc[1][6].mc.descriptors = 3900;
                dev_thresh->pool_tc[1][7].mc.descriptors = 13000;

                dev_thresh->pool_tc[0][0].mc.buffers = 3000;
                dev_thresh->pool_tc[0][1].mc.buffers = 2400;
                dev_thresh->pool_tc[0][2].mc.buffers = 2100;
                dev_thresh->pool_tc[0][3].mc.buffers = 1800;
                dev_thresh->pool_tc[0][4].mc.buffers = 1500;
                dev_thresh->pool_tc[0][5].mc.buffers = 1200;
                dev_thresh->pool_tc[0][6].mc.buffers = 900;
                dev_thresh->pool_tc[0][7].mc.buffers = 600;
                dev_thresh->pool_tc[1][0].mc.buffers = 3000;
                dev_thresh->pool_tc[1][1].mc.buffers = 2400;
                dev_thresh->pool_tc[1][2].mc.buffers = 2100;
                dev_thresh->pool_tc[1][3].mc.buffers = 1800;
                dev_thresh->pool_tc[1][4].mc.buffers = 1500;
                dev_thresh->pool_tc[1][5].mc.buffers = 1200;
                dev_thresh->pool_tc[1][6].mc.buffers = 900;
                dev_thresh->pool_tc[1][7].mc.buffers = 600;

                dev_thresh->pool_tc[0][0].reserved.buffers = 50;
                dev_thresh->pool_tc[0][1].reserved.buffers = 50;
                dev_thresh->pool_tc[0][2].reserved.buffers = 50;
                dev_thresh->pool_tc[0][3].reserved.buffers = 50;
                dev_thresh->pool_tc[0][4].reserved.buffers = 50;
                dev_thresh->pool_tc[0][5].reserved.buffers = 50;
                dev_thresh->pool_tc[0][6].reserved.buffers = 50;
                dev_thresh->pool_tc[0][7].reserved.buffers = 50;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;
        }
    } else if (SOC_IS_QUX(unit)) {
        if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
        {
                /* Discrete Partition */
                dev_thresh->pool_tc[0][0].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][1].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][2].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][3].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][4].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][5].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][6].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][7].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][0].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][1].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][2].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][3].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][4].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][5].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][6].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][7].mc.descriptors = 4862;

                dev_thresh->pool_tc[0][0].mc.buffers = 1023;
                dev_thresh->pool_tc[0][1].mc.buffers = 1023;
                dev_thresh->pool_tc[0][2].mc.buffers = 1023;
                dev_thresh->pool_tc[0][3].mc.buffers = 1023;
                dev_thresh->pool_tc[0][4].mc.buffers = 1023;
                dev_thresh->pool_tc[0][5].mc.buffers = 1023;
                dev_thresh->pool_tc[0][6].mc.buffers = 1023;
                dev_thresh->pool_tc[0][7].mc.buffers = 1023;
                dev_thresh->pool_tc[1][0].mc.buffers = 1023;
                dev_thresh->pool_tc[1][1].mc.buffers = 1023;
                dev_thresh->pool_tc[1][2].mc.buffers = 1023;
                dev_thresh->pool_tc[1][3].mc.buffers = 1023;
                dev_thresh->pool_tc[1][4].mc.buffers = 1023;
                dev_thresh->pool_tc[1][5].mc.buffers = 1023;
                dev_thresh->pool_tc[1][6].mc.buffers = 1023;
                dev_thresh->pool_tc[1][7].mc.buffers = 1023;

                dev_thresh->pool_tc[0][0].reserved.buffers = 75;
                dev_thresh->pool_tc[0][1].reserved.buffers = 75;
                dev_thresh->pool_tc[0][2].reserved.buffers = 75;
                dev_thresh->pool_tc[0][3].reserved.buffers = 75;
                dev_thresh->pool_tc[0][4].reserved.buffers = 75;
                dev_thresh->pool_tc[0][5].reserved.buffers = 75;
                dev_thresh->pool_tc[0][6].reserved.buffers = 75;
                dev_thresh->pool_tc[0][7].reserved.buffers = 75;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;

        } else {

                /* Strict Priority */
                dev_thresh->pool_tc[0][0].mc.descriptors = 9723;
                dev_thresh->pool_tc[0][1].mc.descriptors = 8751;
                dev_thresh->pool_tc[0][2].mc.descriptors = 7778;
                dev_thresh->pool_tc[0][3].mc.descriptors = 6806;
                dev_thresh->pool_tc[0][4].mc.descriptors = 5834;
                dev_thresh->pool_tc[0][5].mc.descriptors = 4862;
                dev_thresh->pool_tc[0][6].mc.descriptors = 4375;
                dev_thresh->pool_tc[0][7].mc.descriptors = 3889;
                dev_thresh->pool_tc[1][0].mc.descriptors = 9723;
                dev_thresh->pool_tc[1][1].mc.descriptors = 8751;
                dev_thresh->pool_tc[1][2].mc.descriptors = 7778;
                dev_thresh->pool_tc[1][3].mc.descriptors = 6806;
                dev_thresh->pool_tc[1][4].mc.descriptors = 5834;
                dev_thresh->pool_tc[1][5].mc.descriptors = 4862;
                dev_thresh->pool_tc[1][6].mc.descriptors = 4375;
                dev_thresh->pool_tc[1][7].mc.descriptors = 3889;

                dev_thresh->pool_tc[0][0].mc.buffers = 2045;
                dev_thresh->pool_tc[0][1].mc.buffers = 1841;
                dev_thresh->pool_tc[0][2].mc.buffers = 1636;
                dev_thresh->pool_tc[0][3].mc.buffers = 1432;
                dev_thresh->pool_tc[0][4].mc.buffers = 1227;
                dev_thresh->pool_tc[0][5].mc.buffers = 1023;
                dev_thresh->pool_tc[0][6].mc.buffers = 920;
                dev_thresh->pool_tc[0][7].mc.buffers = 818;
                dev_thresh->pool_tc[1][0].mc.buffers = 2045;
                dev_thresh->pool_tc[1][1].mc.buffers = 1841;
                dev_thresh->pool_tc[1][2].mc.buffers = 1636;
                dev_thresh->pool_tc[1][3].mc.buffers = 1432;
                dev_thresh->pool_tc[1][4].mc.buffers = 1227;
                dev_thresh->pool_tc[1][5].mc.buffers = 1023;
                dev_thresh->pool_tc[1][6].mc.buffers = 920;
                dev_thresh->pool_tc[1][7].mc.buffers = 818;

                dev_thresh->pool_tc[0][0].reserved.buffers = 75;
                dev_thresh->pool_tc[0][1].reserved.buffers = 75;
                dev_thresh->pool_tc[0][2].reserved.buffers = 75;
                dev_thresh->pool_tc[0][3].reserved.buffers = 75;
                dev_thresh->pool_tc[0][4].reserved.buffers = 75;
                dev_thresh->pool_tc[0][5].reserved.buffers = 75;
                dev_thresh->pool_tc[0][6].reserved.buffers = 75;
                dev_thresh->pool_tc[0][7].reserved.buffers = 75;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = 0;
                dev_thresh->pool_tc[1][5].reserved.buffers = 0;
                dev_thresh->pool_tc[1][6].reserved.buffers = 0;
                dev_thresh->pool_tc[1][7].reserved.buffers = 0;

        }
    } else {
        if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
        {
            /* Discrete Partition */
                dev_thresh->pool_tc[0][0].mc.descriptors = dev_thresh->pool[0].mc.descriptors/2;
                dev_thresh->pool_tc[0][1].mc.descriptors = dev_thresh->pool[0].mc.descriptors/2;
                dev_thresh->pool_tc[0][2].mc.descriptors = dev_thresh->pool[0].mc.descriptors/2;
                dev_thresh->pool_tc[0][3].mc.descriptors = dev_thresh->pool[0].mc.descriptors/2;
                dev_thresh->pool_tc[0][4].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors/2:0 ;
                dev_thresh->pool_tc[0][5].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors/2:0 ;
                dev_thresh->pool_tc[0][6].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors/2:0 ;
                dev_thresh->pool_tc[0][7].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors/2:0 ;
                dev_thresh->pool_tc[1][0].mc.descriptors = 0;
                dev_thresh->pool_tc[1][1].mc.descriptors = 0;
                dev_thresh->pool_tc[1][2].mc.descriptors = 0;
                dev_thresh->pool_tc[1][3].mc.descriptors = 0;
                dev_thresh->pool_tc[1][4].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors/2;
                dev_thresh->pool_tc[1][5].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors/2;
                dev_thresh->pool_tc[1][6].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors/2;
                dev_thresh->pool_tc[1][7].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors/2;

                dev_thresh->pool_tc[0][0].mc.buffers = dev_thresh->pool[0].mc.buffers/2;
                dev_thresh->pool_tc[0][1].mc.buffers = dev_thresh->pool[0].mc.buffers/2;
                dev_thresh->pool_tc[0][2].mc.buffers = dev_thresh->pool[0].mc.buffers/2;
                dev_thresh->pool_tc[0][3].mc.buffers = dev_thresh->pool[0].mc.buffers/2;
                dev_thresh->pool_tc[0][4].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers/2:0;
                dev_thresh->pool_tc[0][5].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers/2:0;
                dev_thresh->pool_tc[0][6].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers/2:0;
                dev_thresh->pool_tc[0][7].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers/2:0;
                dev_thresh->pool_tc[1][0].mc.buffers = 0;
                dev_thresh->pool_tc[1][1].mc.buffers = 0;
                dev_thresh->pool_tc[1][2].mc.buffers = 0;
                dev_thresh->pool_tc[1][3].mc.buffers = 0;
                dev_thresh->pool_tc[1][4].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers/2;
                dev_thresh->pool_tc[1][5].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers/2;
                dev_thresh->pool_tc[1][6].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers/2;
                dev_thresh->pool_tc[1][7].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers/2;

                dev_thresh->pool_tc[0][0].reserved.buffers = 150;
                dev_thresh->pool_tc[0][1].reserved.buffers = 150;
                dev_thresh->pool_tc[0][2].reserved.buffers = 150;
                dev_thresh->pool_tc[0][3].reserved.buffers = 150;
                dev_thresh->pool_tc[0][4].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][5].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][6].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][7].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][5].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][6].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][7].reserved.buffers = any_port_with_1_priority ? 0:150;

        } else {

                /* Strict Priority - if 1 priority, then set thresholds in spaces of 12.5%, otherwise - 25% */
                dev_thresh->pool_tc[0][0].mc.descriptors = dev_thresh->pool[0].mc.descriptors;
                dev_thresh->pool_tc[0][1].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors*875/1000:dev_thresh->pool[0].mc.descriptors*75/100;
                dev_thresh->pool_tc[0][2].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors*750/1000:dev_thresh->pool[0].mc.descriptors*50/100;
                dev_thresh->pool_tc[0][3].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors*625/1000:dev_thresh->pool[0].mc.descriptors*25/100;
                dev_thresh->pool_tc[0][4].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors*500/1000:0;
                dev_thresh->pool_tc[0][5].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors*375/1000:0;
                dev_thresh->pool_tc[0][6].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors*250/1000:0;
                dev_thresh->pool_tc[0][7].mc.descriptors = any_port_with_1_priority ? dev_thresh->pool[0].mc.descriptors*125/1000:0;
                dev_thresh->pool_tc[1][0].mc.descriptors = 0;
                dev_thresh->pool_tc[1][1].mc.descriptors = 0;
                dev_thresh->pool_tc[1][2].mc.descriptors = 0;
                dev_thresh->pool_tc[1][3].mc.descriptors = 0;
                dev_thresh->pool_tc[1][4].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors;
                dev_thresh->pool_tc[1][5].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors*75/100;
                dev_thresh->pool_tc[1][6].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors*50/100;
                dev_thresh->pool_tc[1][7].mc.descriptors = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.descriptors*25/100;

                dev_thresh->pool_tc[0][0].mc.buffers = dev_thresh->pool[0].mc.buffers;
                dev_thresh->pool_tc[0][1].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers*875/1000:dev_thresh->pool[0].mc.buffers*75/100;
                dev_thresh->pool_tc[0][2].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers*750/1000:dev_thresh->pool[0].mc.buffers*50/100;
                dev_thresh->pool_tc[0][3].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers*625/1000:dev_thresh->pool[0].mc.buffers*25/100;
                dev_thresh->pool_tc[0][4].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers*500/1000:0;
                dev_thresh->pool_tc[0][5].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers*375/1000:0;
                dev_thresh->pool_tc[0][6].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers*250/1000:0;
                dev_thresh->pool_tc[0][7].mc.buffers = any_port_with_1_priority ? dev_thresh->pool[0].mc.buffers*125/1000:0;
                dev_thresh->pool_tc[1][0].mc.buffers = 0;
                dev_thresh->pool_tc[1][1].mc.buffers = 0;
                dev_thresh->pool_tc[1][2].mc.buffers = 0;
                dev_thresh->pool_tc[1][3].mc.buffers = 0;
                dev_thresh->pool_tc[1][4].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers;
                dev_thresh->pool_tc[1][5].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers*75/100;
                dev_thresh->pool_tc[1][6].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers*50/100;
                dev_thresh->pool_tc[1][7].mc.buffers = any_port_with_1_priority ? 0:dev_thresh->pool[1].mc.buffers*25/100;

                dev_thresh->pool_tc[0][0].reserved.buffers = 150;
                dev_thresh->pool_tc[0][1].reserved.buffers = 150;
                dev_thresh->pool_tc[0][2].reserved.buffers = 150;
                dev_thresh->pool_tc[0][3].reserved.buffers = 150;
                dev_thresh->pool_tc[0][4].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][5].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][6].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[0][7].reserved.buffers = any_port_with_1_priority ? 150:0;
                dev_thresh->pool_tc[1][0].reserved.buffers = 0;
                dev_thresh->pool_tc[1][1].reserved.buffers = 0;
                dev_thresh->pool_tc[1][2].reserved.buffers = 0;
                dev_thresh->pool_tc[1][3].reserved.buffers = 0;
                dev_thresh->pool_tc[1][4].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][5].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][6].reserved.buffers = any_port_with_1_priority ? 0:150;
                dev_thresh->pool_tc[1][7].reserved.buffers = any_port_with_1_priority ? 0:150;
        }
    }
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_set,(unit, core,dev_thresh)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
    rc = translate_sand_success_failure(soc_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
    }

#ifdef BCM_88675_SUPPORT
    if (SOC_IS_JERICHO(unit))
    {
        BCMDNX_IF_ERR_EXIT(soc_jer_sp_tc_init(unit, core, dev_thresh));
    }
#endif /* BCM_88675_SUPPORT */
    
    /* Global FC Thresholds */
    arad_ARAD_EGR_FC_DEVICE_THRESH_clear(&dev_fc_thresh);
    arad_ARAD_EGR_FC_DEVICE_THRESH_clear(&dev_fc_thresh_exact);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_get,(unit, core, &dev_fc_thresh)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
    }
     
    if (SOC_IS_ARDON(unit)) {
          dev_fc_thresh.scheduled.buffers = 3200;
          dev_fc_thresh.scheduled.descriptors = 3200;
          dev_fc_thresh.global.descriptors = 15700;
          dev_fc_thresh.global.buffers = 5800;
          dev_fc_thresh.unscheduled.descriptors = 9500;
          dev_fc_thresh.unscheduled.buffers = 2700;
          dev_fc_thresh.unscheduled_pool[0].descriptors = 9500;
          dev_fc_thresh.unscheduled_pool[1].descriptors = 9500;
          dev_fc_thresh.unscheduled_pool[0].buffers = 2700;
          dev_fc_thresh.unscheduled_pool[1].buffers = 2700;

    } else if (SOC_IS_QUX(unit)) {
 
          dev_fc_thresh.scheduled.buffers = 2045;
          dev_fc_thresh.scheduled.descriptors = 2045;
          dev_fc_thresh.global.descriptors = 11180;
          dev_fc_thresh.global.buffers = 3886;
          dev_fc_thresh.unscheduled.descriptors = 9237;
          dev_fc_thresh.unscheduled.buffers = 1943;
          dev_fc_thresh.unscheduled_pool[0].descriptors = 9237;
          dev_fc_thresh.unscheduled_pool[1].descriptors = 0;
          dev_fc_thresh.unscheduled_pool[0].buffers = 1943;
          dev_fc_thresh.unscheduled_pool[1].buffers = 0;
    }else {
          
          dev_fc_thresh.scheduled.buffers = SOC_DPP_IMP_DEFS_GET(unit, egr_total_uc_fc_db);
          dev_fc_thresh.scheduled.descriptors = SOC_DPP_IMP_DEFS_GET(unit, egr_total_uc_fc_pd);
          dev_fc_thresh.global.descriptors = SOC_DPP_IMP_DEFS_GET(unit, egr_total_pd) - 500;
          dev_fc_thresh.global.buffers = SOC_DPP_IMP_DEFS_GET(unit, egr_total_db) - 200;
          dev_fc_thresh.unscheduled.descriptors = SOC_DPP_IMP_DEFS_GET(unit, egr_total_mc_pd) - 1000;
          dev_fc_thresh.unscheduled.buffers = SOC_DPP_IMP_DEFS_GET(unit, egr_total_mc_db) - 500;
          dev_fc_thresh.unscheduled_pool[0].descriptors = dev_fc_thresh.unscheduled.descriptors/2;
          dev_fc_thresh.unscheduled_pool[1].descriptors = dev_fc_thresh.unscheduled.descriptors/2;
          dev_fc_thresh.unscheduled_pool[0].buffers = dev_fc_thresh.unscheduled.buffers/2;
          dev_fc_thresh.unscheduled_pool[1].buffers = dev_fc_thresh.unscheduled.buffers/2;
    }
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_dev_fc_set,(unit, core, &dev_fc_thresh, &dev_fc_thresh_exact)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
    }

    /* Global MC FC Thresholds */
    arad_ARAD_EGR_FC_OFP_THRESH_clear(&fc_mc_thresh);
    arad_ARAD_EGR_FC_OFP_THRESH_clear(&exact_fc_mc_thresh);
    for(tc = 0; tc < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); tc++)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit,core,ARAD_EGR_Q_PRIO_ALL,tc,&fc_mc_thresh)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
        }
        
        if (SOC_IS_ARDON(unit)) {
            if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE) {
                /* Discrete Partition */
                fc_mc_thresh.mc.descriptors = 6250;
                fc_mc_thresh.mc.buffers = 1375;
            } else {
                /* Strict Priority */
                switch(tc) {
                case 0:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                case 1:
                    fc_mc_thresh.mc.descriptors = 10000;
                    fc_mc_thresh.mc.buffers = 2200;
                    break;
                case 2:
                    fc_mc_thresh.mc.descriptors = 8750;
                    fc_mc_thresh.mc.buffers = 1925;
                    break;
                case 3:
                    fc_mc_thresh.mc.descriptors = 7500;
                    fc_mc_thresh.mc.buffers = 1650;
                    break;
                case 4:
                    fc_mc_thresh.mc.descriptors = 6250;
                    fc_mc_thresh.mc.buffers = 1375;
                    break;
                case 5:
                    fc_mc_thresh.mc.descriptors = 5000;
                    fc_mc_thresh.mc.buffers = 1100;
                    break;
                case 6:
                    fc_mc_thresh.mc.descriptors = 3750;
                    fc_mc_thresh.mc.buffers = 825;
                    break;
                case 7:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                }
            }
        } else if (SOC_IS_QUX(unit)) {
            if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
            {
                /* Discrete Partition */
                fc_mc_thresh.mc.descriptors = 4619;
                fc_mc_thresh.mc.buffers = 972;
            } else {
                /* Strict Priority */
                switch(tc)
                {
                case 0:
                    fc_mc_thresh.mc.descriptors = 9237;
                    fc_mc_thresh.mc.buffers = 1943;
                    break;
                case 1:
                    fc_mc_thresh.mc.descriptors = 8313;
                    fc_mc_thresh.mc.buffers = 1749;
                    break;
                case 2:
                    fc_mc_thresh.mc.descriptors = 7390;
                    fc_mc_thresh.mc.buffers = 1554;
                    break;
                case 3:
                    fc_mc_thresh.mc.descriptors = 6466;
                    fc_mc_thresh.mc.buffers = 1360;
                    break;
                case 4:
                    fc_mc_thresh.mc.descriptors = 5542;
                    fc_mc_thresh.mc.buffers = 1166;
                    break;
                case 5:
                    fc_mc_thresh.mc.descriptors = 4619;
                    fc_mc_thresh.mc.buffers = 972;
                    break;
                case 6:
                    fc_mc_thresh.mc.descriptors = 4157;
                    fc_mc_thresh.mc.buffers = 874;
                    break;
                case 7:
                    fc_mc_thresh.mc.descriptors = 3695;
                    fc_mc_thresh.mc.buffers = 777;
                    break;
                }
            }
        } else {
            if(SOC_DPP_CONFIG(unit)->arad->init.eg_cgm_scheme == ARAD_EGR_QUEUING_PARTITION_SCHEME_DISCRETE)
            {
                /* Discrete Partition */
                fc_mc_thresh.mc.descriptors = 6250;
                fc_mc_thresh.mc.buffers = 1375;
            } else {
                /* Strict Priority */
                switch(tc)
                {
                case 0:
                case 4:
                    fc_mc_thresh.mc.descriptors = 12500;
                    fc_mc_thresh.mc.buffers = 2750;
                    break;
                case 1:
                case 5:
                    fc_mc_thresh.mc.descriptors = 9375;
                    fc_mc_thresh.mc.buffers = 2062;
                    break;
                case 2:
                case 6:
                    fc_mc_thresh.mc.descriptors = 6250;
                    fc_mc_thresh.mc.buffers = 1375;
                    break;
                case 3:
                case 7:
                    fc_mc_thresh.mc.descriptors = 3125;
                    fc_mc_thresh.mc.buffers = 687;
                    break;
                } 
            }
        }
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_set,(unit, core ,ARAD_EGR_Q_PRIO_ALL,tc,&fc_mc_thresh,&exact_fc_mc_thresh)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Failed to call driver, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
        }
    }
exit:
    BCM_FREE(dev_thresh);
    BCMDNX_FUNC_RETURN;
}

int
_bcm_arad_cosq_get_queue_mc_sp(int unit, int local_port_id, int cosq, int* sp)
{
    uint32  soc_sand_rc = SOC_SAND_OK;
    int tc_ndx, dp_ndx, found, rv;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    ARAD_EGR_QUEUING_MC_COS_MAP mc_tc_map;
    int profile = 0;
    uint32 tm_port;
    int core;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if(sp == NULL)
    {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("SP cannot be NULL")));
    }
    *sp = -1;

    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_tm_port_get(unit, local_port_id, &tm_port, &core));

    /* PORT --> PROFILE */
    rv = (MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_get,(unit, core, tm_port, (uint32*)&profile)));
    BCMDNX_IF_ERR_EXIT(rv);
   
    found = FALSE;
    for(tc_ndx = 0; tc_ndx < DPP_DEVICE_COSQ_EGR_NOF_TC; tc_ndx++) {
      for(dp_ndx = 0; dp_ndx < DPP_DEVICE_COSQ_EGR_NOF_DP; dp_ndx++) {
        /* PROFILE/QUEUE --> TC/DP */
        rv = (MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_prio_get,(unit,core,ARAD_EGR_MCAST_TO_UNSCHED,tc_ndx,dp_ndx,profile,&egr_prio)));
        BCMDNX_IF_ERR_EXIT(rv);
        
        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if(cosq == egr_prio.tc) { 
          /* TC/DP --> MC SP */
          soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_get,(unit, core, tc_ndx, dp_ndx, &mc_tc_map)));
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
          
          if(found == TRUE)
          {
            if(*sp != mc_tc_map.pool_id)
            {
              BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Egress queue (Port %d TC %d) cannot be mapped to use more than one service pool"), local_port_id, cosq));
            }
          }
          else
          {
            /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
            /* coverity[uninit_use:FALSE] */
            *sp = mc_tc_map.pool_id;
          }

          found = TRUE;
        }
      }
    }

    if(!found){
      /* Couldnt find service pool mapping */
      *sp = -1;
    }

exit:
    BCMDNX_FUNC_RETURN;  
}

int
_bcm_arad_cosq_update_reserved_pd_threshold_all_sps(int unit)
{
    int     rc = BCM_E_NONE;
    int     total_pd_sp0[SOC_DPP_DEFS_MAX(NOF_CORES)] = {0}, total_pd_sp1[SOC_DPP_DEFS_MAX(NOF_CORES)] = {0}, core;
    SOC_TMC_EGR_QUEUING_DEV_TH  *dev_thresh[SOC_DPP_DEFS_MAX(NOF_CORES)] = {NULL};
    uint32  soc_sand_rc = SOC_SAND_OK;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int pool_id = 0, tc;
    bcm_port_t               port_i = 0;
    soc_port_if_t interface;  
    uint32  nof_priorities, tm_port, flags;
    pbmp_t ports_bm;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        BCMDNX_ALLOC(dev_thresh[core], sizeof(SOC_TMC_EGR_QUEUING_DEV_TH), "_bcm_arad_cosq_update_reserved_pd_threshold_all_sps.dev_thresh");
        if (dev_thresh[core] == NULL) {        
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
        }
        SOC_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh[core]);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, core, dev_thresh[core])));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
    /* Recalculate both Service Pools values */
    rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_bm);
    BCMDNX_IF_ERR_EXIT(rc);

    PBMP_ITER(ports_bm, port_i)
    {  
      /* skip non real ports (NOCXN)*/
      BCMDNX_IF_ERR_EXIT(soc_port_sw_db_interface_type_get(unit, port_i, &interface));
      if((interface == SOC_PORT_IF_ERP) || (interface == SOC_PORT_IF_NOCXN) || (port_i >= SOC_DPP_DEFS_GET(unit, nof_logical_ports))) {
        continue;
      }

      SOCDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, port_i, &flags));
      if (SOC_PORT_IS_NOT_VALID_FOR_EGRESS_TM(flags)) {
          continue;
      }

      rc = soc_port_sw_db_local_to_tm_port_get(unit, port_i, &tm_port, &core);
      BCMDNX_IF_ERR_EXIT(rc);
     
      rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities);
      BCMDNX_IF_ERR_EXIT(rc);

      for (tc = 0; tc < nof_priorities; tc++) 
      {
        /* Validate that only one SP is used */
        /* Return the used SP ID */
        rc = _bcm_arad_cosq_get_queue_mc_sp(unit, port_i, tc, &pool_id);
        BCMDNX_IF_ERR_EXIT(rc);

        if(pool_id == -1) continue;

        /* PORT --> RESERVED MC PD */
        rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit,core,port_i,&thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);

        if(thresh_key.unsch_drop_packet_descriptors_available_tc[tc] > DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH)
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Egress queue (Port %d TC %d) reserved PD value (%d) is above max (%d)"), 
                                            port_i, tc, thresh_key.unsch_drop_packet_descriptors_available_tc[tc], DPP_COSQ_ARAD_MAX_QUEUE_PD_THRESH));
        }

        if(pool_id == 0) {
          total_pd_sp0[core] += thresh_key.unsch_drop_packet_descriptors_available_tc[tc];
        }
        else if(pool_id == 1) {
          total_pd_sp1[core] += thresh_key.unsch_drop_packet_descriptors_available_tc[tc];
        }
      }
    } /* End of BCM_PBMP_ITER */

    SOC_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        if(total_pd_sp0[core] > dev_thresh[core]->pool[0].reserved.descriptors )
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 0 max reserved PD value (%d) is above max (%d) core (%d)"),
                                            total_pd_sp0[core], dev_thresh[core]->pool[0].reserved.descriptors, core));
        }
        if(total_pd_sp1[core] > dev_thresh[core]->pool[1].reserved.descriptors ) 
        {
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Service Pool 1 max reserved PD value (%d) is above max (%d) core (%d)"),
                                            total_pd_sp1[core], dev_thresh[core]->pool[1].reserved.descriptors, core));
        }
    }

    
exit:
    SOC_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        BCM_FREE(dev_thresh[core]);
    }

    BCMDNX_FUNC_RETURN;
}


int
_bcm_petra_cosq_qid_type_get(int unit, int core, int base_qid, int *gport,
                             int *is_multicast, int *is_unicast, int *is_isq, int *queue_type)
{
    int                 rc = BCM_E_NONE;
    int                 soc_sand_rc;
    SOC_SAND_U32_RANGE      queue_range;
    int is_run_allocation;
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_multicast != NULL) {
        (*is_multicast) = FALSE;
    }
    if (is_unicast != NULL) {
        (*is_unicast) = FALSE;
    }
    if (is_isq != NULL) {
        (*is_isq) = FALSE;
    }

    if (queue_type != NULL) {
        (*queue_type) = 0;
    }
    rc = bcm_petra_fabric_multicast_scheduler_mode_get(unit, core, &is_run_allocation);
    BCMDNX_IF_ERR_EXIT(rc);
    if (is_run_allocation) {
        /* Get multicast queue id range */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_get,(unit, core, &queue_range)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    } else {
        queue_range.end = DPP_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MAX;
        queue_range.start = DPP_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MIN;
    }

    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    if ( (base_qid >= queue_range.start) && (base_qid <= queue_range.end) ) {
        BCM_GPORT_MCAST_QUEUE_GROUP_SET((*gport), base_qid);
        if (is_multicast != NULL) {
            (*is_multicast) = TRUE;
        }
        if (queue_type != NULL) {
            (*queue_type) = DPP_DEVICE_COSQ_QUEUE_REGION_MULTICAST;
        }
    }
    else {
        /* Get ISQ queue range */
        SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, core, &isp_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        if ((base_qid >= isp_info.q_range.q_num_low) && (base_qid<=isp_info.q_range.q_num_high)) {
            BCM_COSQ_GPORT_ISQ_SET((*gport), base_qid);
            if (is_isq != NULL) {
                (*is_isq) = TRUE;
            }
            if (queue_type != NULL) {
                (*queue_type) = DPP_DEVICE_COSQ_QUEUE_REGION_ISQ;
            }
        } 
        else {
            BCM_GPORT_UNICAST_QUEUE_GROUP_SET((*gport), base_qid);
            if (is_unicast != NULL) {
                (*is_unicast) = TRUE;
            }
            if (queue_type != NULL) {
                (*queue_type) = DPP_DEVICE_COSQ_QUEUE_REGION_UNICAST;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * local Functions
 */
STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_QUEUE_INFO queue_info, queue_info_original;    
    SOC_TMC_ITM_QT_NDX sched_mode;
    uint32 base_queue, queue;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);

    /* consistency checks */
    rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, mode, &sched_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    if (sched_mode == SOC_TMC_ITM_QT_NDX_INVALID){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid mode %d"), unit, mode));
    }

    if (weight != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid weight %d"), unit, weight));
    }

    /* consistency check to determine if {gport, cosq} is valid */  
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "Invalid gport 0x%x type.\n"), gport));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
    
    /* consistency check to determine if {gport, cosq} is valid */    
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));
    if (sw_state_num_cos == 0) {
        /* Not initalized VOQ */
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid VOQ 0x%x parameter\n"),
                              unit, gport));
        rc = BCM_E_NOT_FOUND;
        BCMDNX_IF_ERR_EXIT(rc);     
    }
    if (cosq < 0 || cosq >= sw_state_num_cos) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "Unit(%d) Invalid cosq %d parameter\n"),
                                unit, cosq));
          rc = BCM_E_PARAM;
          BCMDNX_IF_ERR_EXIT(rc);     
    }
    if (SOC_IS_ARADPLUS(unit) && !SOC_IS_JERICHO(unit)) { /* check if the base queue is mapped to a module using the same credit module as the requested profile */
        uint32 credit_value_type = SOC_TMC_FAP_CREDIT_VALUE_LOCAL, found_type;
        int perform_check = 1;
        if (!BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) { /* FMQs who use local credit */
            /* find the credit value used according to the fap mapped to the queue */
            SOC_TMC_IPQ_QUARTET_MAP_INFO queue_map_info;
            uint32 fap_id;
            int local_fap_id;

            SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_map_info);
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
                (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_queue), &queue_map_info)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                perform_check = 0;
            } else {
                if (ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
                    fap_id = queue_map_info.fap_id;
                } else { /* direct mapping mode */
                    bcm_gport_t sysport_gport, modport_gport;
                    BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, queue_map_info.system_physical_port);
                    BCMDNX_IF_ERR_EXIT(bcm_petra_stk_sysport_gport_get(unit, sysport_gport, &modport_gport));
                    fap_id = BCM_GPORT_MODPORT_MODID_GET(modport_gport);
                }
                /* We found the mapped FAP ID, now find the credit value type from it, if it is not the local fap */
                BCMDNX_IF_ERR_EXIT(bcm_petra_stk_my_modid_get(unit, &local_fap_id));
                if (local_fap_id != fap_id) {
                    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_module_to_credit_worth_map_get, (unit, fap_id, &credit_value_type)));
                }
            }
            if (perform_check) {
                SOC_TMC_ITM_CR_REQUEST_INFO cr_req_info;
                SOC_TMC_ITM_CR_REQUEST_INFO_clear(&cr_req_info);
                BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_cr_request_get, (unit, sched_mode, &cr_req_info)));
                found_type = cr_req_info.is_remote_credit_value ? SOC_TMC_FAP_CREDIT_VALUE_REMOTE : SOC_TMC_FAP_CREDIT_VALUE_LOCAL;
                if (credit_value_type != found_type) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The credit size of the selected profile is not of the type expected for unit %u mapped to the queue: %s."
                      "\nThe credit size of a unit can be set using bcm_cosq_credit_size_set()"),
                      (unsigned)fap_id, credit_value_type == SOC_TMC_FAP_CREDIT_VALUE_LOCAL ? "local" : "remote"));
                } 
            }
        }
    }
    queue = base_queue + cosq;

    /* retrieve current configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, queue, &queue_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    sal_memcpy(&queue_info_original, &queue_info, sizeof(SOC_TMC_ITM_QUEUE_INFO));
    /* update configuration */
    queue_info.cr_req_type_ndx = sched_mode;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit, core, queue, &queue_info_original, &queue_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_e2e_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight)
{
    bcm_error_t rc = BCM_E_NONE;    
    uint32 soc_sand_rc, nof_remote_cores, region;
    bcm_dpp_cosq_gport_info_t *child_info;
    int flow_id_index, orig_sub_flow0_id, orig_sub_flow1_id;
    bcm_dpp_cosq_class_info_t info;
    int updated_type;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info;
    SOC_TMC_SCH_FLOW exact_flow_config;
    SOC_TMC_SCH_SE_INFO *parent_se = NULL;
    SOC_TMC_SCH_FLOW *parent_flow_config = NULL;
    int                        core, i, flow_id;
    SOC_TMC_SCH_SE_ID          sw_state_default_se;

    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    /* Consitency checks */

    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_ALLOC(parent_flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_se, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (parent_flow_config == NULL) ||(parent_se == NULL) ) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    SOC_TMC_SCH_SE_INFO_clear(parent_se);
    SOC_TMC_SCH_FLOW_clear(unit, parent_flow_config);

    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on QAX*/
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &gport, core);
    }
    /* validate child element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, dpp_device_cosq_gport_child_element, &child_info); 
    BCMDNX_IF_ERR_EXIT(rc);
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* validate hookup */
    /* get parent element scheduling mode */
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, cs_info->id, parent_se, parent_flow_config)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, child_info->actual_flow_id, weight));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, child_info->actual_flow_id, mode));

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id != sw_state_default_se) {

       /* get parent element information for child hookup corresponding to child scheduling mode */
       rc = _bcm_petra_cosq_credit_class_info_get(unit, core, parent_se, mode, &info);
       if (rc != BCM_E_NONE) {
           BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving parent info corresponding to child element scheduling mode, error 0x%x"), unit, rc));
       }

       rc = _bcm_petra_cosq_credit_class_weight_validate(unit, weight, &info, &updated_type);
       if (rc != BCM_E_NONE) {
           BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in adjusting flow type for weight/weight mode, error 0x%x"), unit, rc));
       }
       
       /* hookup hierarchy */
       cs_info->se_type = parent_se->type;
       cs_info->id = parent_se->id;
       switch (cs_info->se_type) {
       case SOC_TMC_SCH_SE_TYPE_HR:
           cs_info->se_info.hr.sp_class = updated_type;
           cs_info->se_info.hr.weight = weight;
           break;
           
       case SOC_TMC_SCH_SE_TYPE_CL:
            cs_info->se_info.cl.sp_class = updated_type;
            cs_info->se_info.cl.weight = weight;
            break;
            
       default:
           break;
       }
    }

    /* set all symmetric connections */
    if (child_info->is_connector) {
        region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(child_info->flow_id);
        nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = child_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = child_info->flow_config->sub_flow[1].id;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(child_info->flow_id, nof_remote_cores, i);
        child_info->flow_config->sub_flow[0].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        child_info->flow_config->sub_flow[1].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id, child_info->flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(parent_flow_config);
    BCM_FREE(parent_se);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info);
    }
/* } */
#endif

    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_e2e_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight)
{
    bcm_error_t                      rc = BCM_E_NONE;    
    uint32                           soc_sand_rc;
    bcm_dpp_cosq_gport_info_t        *gport_info;
    SOC_TMC_SCH_SE_INFO              *parent_se = NULL;
    SOC_TMC_SCH_FLOW                 *parent_flow_config = NULL;
    int                              flow_id_index, gport_mode;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    bcm_dpp_cosq_class_info_t        info;
    int                             core ;
    SOC_TMC_SCH_SE_ID               sw_state_default_se;

    BCMDNX_INIT_FUNC_DEFS;

    /* Consitency checks */
    gport_info = NULL ;   
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }


    BCMDNX_ALLOC(parent_flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
    BCMDNX_ALLOC(parent_se, sizeof(SOC_TMC_SCH_SE_INFO), "se");

    if ( (parent_flow_config == NULL) ||(parent_se == NULL)  ) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    SOC_TMC_SCH_SE_INFO_clear(parent_se);
    SOC_TMC_SCH_FLOW_clear(unit, parent_flow_config);


    if (SOC_IS_QAX(unit)) { /*add 64k flow_id offset on QAX*/
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &gport, core);
    }
    /* validate child element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, dpp_device_cosq_gport_child_element, &gport_info);
    BCMDNX_IF_ERR_EXIT(rc);
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* get child element scheduling mode */
    rc = _bcm_petra_cosq_mode_get(unit, core, gport_info->flow_config, gport_info->is_sf2, &gport_mode);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retrieving child element scheduling mode, error 0x%x"), unit, rc));
    }

    (*mode) = gport_mode;

    /* retrieve weight */
    /* get parent element scheduling mode */
    flow_id_index = (gport_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(gport_info->flow_config->sub_flow[flow_id_index].credit_source);

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id == sw_state_default_se) {
        /* retrieve element weight from state */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, gport_info->actual_flow_id, weight));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.get(unit, core, gport_info->actual_flow_id, mode));
    }
    else {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, cs_info->id, parent_se, parent_flow_config)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        /* get parent element information for child hookup corresponding to child scheduling mode */
        rc = _bcm_petra_cosq_credit_class_info_get(unit, core, parent_se, gport_mode, &info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retrieving parent info corresponding to child element scheduling mode, error 0x%x"), unit, rc));
        }

        /* determine parent weight mode */
        if (info.weight_mode == SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) {
            (*weight) = 0;
        }
        else if (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW) {
            switch (cs_info->se_type) {
                case SOC_TMC_SCH_SE_TYPE_HR:
                    (*weight) = cs_info->se_info.hr.weight;
                    break;

                case SOC_TMC_SCH_SE_TYPE_CL:
                    (*weight) = cs_info->se_info.cl.weight;
                    break;

                default:
                    (*weight) = 0;
                    break;
            }
        }
        else if (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) {
            rc = _bcm_petra_cosq_cl_sched_weight_get(unit, cs_info, &info, weight);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else if (info.weight_mode == SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) {
            rc = _bcm_petra_cosq_cl_sched_weight_get(unit, cs_info, &info, weight);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(parent_flow_config);
    BCM_FREE(parent_se);

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif

    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_ucast_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_ITM_QUEUE_INFO queue_info;    
    uint32 base_queue, queue;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;


    BCMDNX_INIT_FUNC_DEFS;
    /* consistency checks */
    if (mode == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - required pointer(mode) not being passed")));
    }
    SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);

    /* consistency check to determine if {gport, cosq} is valid */  
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "Invalid gport 0x%x type.\n"), gport));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }
 
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));
    if (sw_state_num_cos == 0) {
        /* Not initalized VOQ */
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) Invalid VOQ 0x%x parameter\n"),
                              unit, gport));
        rc = BCM_E_NOT_FOUND;
        BCMDNX_IF_ERR_EXIT(rc);     
    }

    if (cosq < 0 || cosq >= sw_state_num_cos) {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "Unit(%d) Invalid cosq %d parameter\n"),
                                unit, cosq));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);     
    }    

    if (weight != NULL) {
        (*weight) = 0;
    }    
    
    queue = base_queue + cosq;

    /* retrieve current configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, queue, &queue_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_DPP_UNIT_CHECK(unit);
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */

    rc = _bcm_petra_cosq_user_q_type_to_delay_tolerance(unit, queue_info.cr_req_type_ndx, mode);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Schedule mode for Channelized NIF port and CPU interface. 
 * Choose Strict priority to Connect to. SP range: H/L and  
 * Medium (PB only)
 */
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port, rate;    
    int core;
    SOC_TMC_EGR_OFP_SCH_INFO info;    

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);

    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }
      
    /* valid */
    if (!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP2)) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range is SP0-SP2")));
    }

    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Set egress ofp scheduler info */
    rc = _bcm_petra_cosq_mode_sp_to_egr_ofp_interface_prio(unit, mode,&(info.nif_priority));
    BCMDNX_IF_ERR_EXIT(rc);
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_set,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* update port sw rate to mark calendar as modified */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_sw_get,(unit, core, tm_port, &rate)));  
    BCM_SAND_IF_ERR_EXIT(bcm_petra_cosq_gport_bandwidth_set(unit, gport, 0, 0, rate, BCM_COSQ_BW_NOT_COMMIT));

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Schedule mode for Channelized NIF port and CPU interface. 
 * Get the strict priority that the port is connected to. 
 * SP range: H/L and Medium (PB only)
 */
STATIC int
_bcm_petra_cosq_gport_egress_scheduler_port_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;
    int core, is_high_priority;
    SOC_TMC_EGR_OFP_SCH_INFO info;       

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }

    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);
      
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_is_high_priority_port_get,(unit, core, tm_port, &is_high_priority)));

    if (is_high_priority) {
        *mode = BCM_COSQ_SP0;
    } else {
        *mode = BCM_COSQ_SP1;
    }

    *weight = -1;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Fill in the structure of wfq scheduler given
 * bcm mode (SP) and weight
 */
STATIC int
_bcm_petra_cosq_egress_fill_ofp_wfq_sch_from_mode_weight(uint8 is_ucast_egress_queue,
                                                        int mode,
                                                        int weight,
                                                        SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    BCMDNX_NULL_CHECK(sch_wfq_p);

    if (mode != -1) {
        /* SP */
        /* 0 - indicate SP High */
        /* > 0 - indicate lower priority */
        if (is_ucast_egress_queue == SOC_SAND_TRUE) {
            sch_wfq_p->sched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 0:1;
            sch_wfq_p->unsched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 1:0;
        } else {
            sch_wfq_p->sched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 1:0;  
            sch_wfq_p->unsched_weight = (mode == DPP_COSQ_EGR_OFP_SCH_SP_HIGH) ? 0:1;  
        }
    } else {
        /* Take weight into consideration */
        if (is_ucast_egress_queue == SOC_SAND_TRUE) {
            sch_wfq_p->sched_weight = weight;
        } else {
            sch_wfq_p->unsched_weight = weight;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Fill in the bcm mode (SP) and weight from structure of wfq scheduler
 */
STATIC int
_bcm_petra_cosq_egress_fill_mode_weight_from_ofp_wfq_sch(uint8 is_ucast_egress_queue,
                                                        SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p,
                                                        int *mode,
                                                        int *weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS_NO_UNIT;
    BCMDNX_NULL_CHECK(sch_wfq_p);
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);

    if (is_ucast_egress_queue == SOC_SAND_TRUE) {
        if (sch_wfq_p->sched_weight == 0) {
            *mode = DPP_COSQ_EGR_OFP_SCH_SP_HIGH;
            *weight = -1;
        } else {
            if (sch_wfq_p->unsched_weight == 0) {
                *mode = DPP_COSQ_EGR_OFP_SCH_SP_LOW;
                *weight = -1;
            } else {
                /* Take weight into consideration */
                *mode = -1;
                *weight = sch_wfq_p->sched_weight;
            }
        }
    } else {
        if (sch_wfq_p->unsched_weight == 0) {
            *mode = DPP_COSQ_EGR_OFP_SCH_SP_HIGH;
            *weight = -1;
        } else {
            if (sch_wfq_p->sched_weight == 0) {
                *mode = DPP_COSQ_EGR_OFP_SCH_SP_LOW;
                *weight = -1;
            } else {
                /* Take weight into consideration */
                *mode = -1;
                *weight = sch_wfq_p->unsched_weight;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Attach Port-Priority of a given port priority TC-X to the TCG-Y
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_set(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int mode,
                                               int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_QUEUING_TCG_INFO info;
    SOC_TMC_EGR_Q_PRIO prio;
    SOC_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);


    if ((!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP7)) &&
        (!(mode >= SOC_TMC_TCG_MIN && mode <= SOC_TMC_TCG_MAX))) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range must be tcg_ndx (0-7) or SP0-SP7")));
    }
   
    tcg = (mode >= BCM_COSQ_SP0) ? (mode-BCM_COSQ_SP0):mode;
    /* Clear */
    SOC_TMC_EGR_QUEUING_TCG_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_ofp_tcg_get,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_ndx[prio] = tcg;
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_ofp_tcg_set,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get TCG-Y Port-Priority of a given port priority TC-X.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_sched_get(int unit,
                                               bcm_gport_t gport,
                                               bcm_cos_queue_t cosq,
                                               int *mode,
                                               int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_QUEUING_TCG_INFO info;
    SOC_TMC_EGR_Q_PRIO prio;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);


    /* Clear */
    SOC_TMC_EGR_QUEUING_TCG_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_ofp_tcg_get,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = info.tcg_ndx[prio] + BCM_COSQ_SP0;
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Attach Port-Priority of a given port priority (HR) TC-X to the TCG-Y
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_SCH_PORT_INFO info;
    SOC_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);


    if ((!(mode >=BCM_COSQ_SP0 && mode <= BCM_COSQ_SP7)) &&
        (!(mode >= SOC_TMC_TCG_MIN && mode <= SOC_TMC_TCG_MAX))) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode range must be tcg_ndx (0-7) or SP0-SP7")));
    }
   
    tcg = (mode >= BCM_COSQ_SP0) ? (mode-BCM_COSQ_SP0):mode;

    /* Clear */
    SOC_TMC_SCH_PORT_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_ndx[cosq] = tcg;
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit,core,tm_port,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get TCG-Y Port-Priority of a given port priority TC-X.
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_SCH_PORT_INFO info;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear */
    SOC_TMC_SCH_PORT_INFO_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = info.tcg_ndx[cosq] + BCM_COSQ_SP0;
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_egress_fill_tcg_weight_from_mode_weight(int unit,
                                                        int mode,
                                                        int weight,
                                                        uint32* tcg_weight)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    if (mode == BCM_COSQ_SP0) {
      *tcg_weight = 0; /* SP */
    } else if (mode == -1) {
      /* Take weight into consideration */
      *tcg_weight = weight;
    } else if (mode == BCM_COSQ_NONE) {
      *tcg_weight = -1;
    } else {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - invalid mode given. mode: %d, weight: %d"), mode, weight));
    }
    

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose: 
 * Set EIR Weight for Egress Port TCG
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int mode,
                                                int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_SCH_TCG_WEIGHT info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */
    if (!((mode == -1) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or NONE ")));
    }

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 0 && ((weight) <= (DPP_COSQ_E2E_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
   
    /* Clear */
    SOC_TMC_SCH_TCG_WEIGHT_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tcg_weight_get,(unit, core, tm_port, tcg_ndx, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_weight_valid = (mode == BCM_COSQ_NONE) ? FALSE:TRUE;
    if (info.tcg_weight_valid) {
      info.tcg_weight = weight;
    }
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tcg_weight_set,(unit, core, tm_port, tcg_ndx, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get EIR Weight for Egress Port TCG.
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_sched_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int *mode,
                                                int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_SCH_TCG_WEIGHT info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);
   
    /* Clear */
    SOC_TMC_SCH_TCG_WEIGHT_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tcg_weight_get,(unit, core, tm_port, tcg_ndx, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = (info.tcg_weight_valid) ? -1:BCM_COSQ_NONE;
    if (info.tcg_weight_valid) {
      *weight = info.tcg_weight;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set EIR Weight for Egress Port TCG
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                int mode,
                                                int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_TCG_SCH_WFQ info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */
    if (!((mode == -1) || (mode == BCM_COSQ_SP0) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or BCM_COSQ_SP0 or NONE ")));
    }
    if (!((mode == -1) || (mode == BCM_COSQ_NONE))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or NONE ")));
    }

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 0 && ((weight) <= (DPP_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
   
    /* Clear */
    SOC_TMC_EGR_TCG_SCH_WFQ_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_tcg_weight_get,(unit,core,tm_port,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    info.tcg_weight_valid  = (mode == BCM_COSQ_NONE) ? FALSE:TRUE;
    
    rc = _bcm_petra_cosq_egress_fill_tcg_weight_from_mode_weight(unit,mode,weight,&info.tcg_weight);
    BCMDNX_IF_ERR_EXIT(rc);
   
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_tcg_weight_set,(unit,core,tm_port,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get EIR Weight for Egress Port TCG.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_sched_get(int unit,
                                             bcm_gport_t gport,
                                             bcm_cos_queue_t cosq,
                                             int *mode,
                                             int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_TCG_SCH_WFQ info;
    SOC_TMC_TCG_NDX tcg_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);    
    BCMDNX_NULL_CHECK(weight);    

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - function support only port tc gport. gport: 0x%x"), gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,tcg_ndx);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Clear */
    SOC_TMC_EGR_TCG_SCH_WFQ_clear(&info);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_tcg_weight_get,(unit,core,tm_port,tcg_ndx,&info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *mode = info.tcg_weight_valid ? -1:BCM_COSQ_NONE;
    if (info.tcg_weight_valid) {
      *weight = info.tcg_weight;
    }
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Schedule mode in OTM port scheduler. 
 * UC and MC Egress queues are handled here.
 * Configure the SP to connect to and the weighted distribution 
 * between the other queue on the same priority. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int mode,
                                            int weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_OFP_SCH_INFO info;
    SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p;    
    uint8 is_ucast_egress_queue;
    int queue_id;
    int max_cosq_num;        

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
        
    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);
          
    max_cosq_num = DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);

    if (!((mode == -1) || (mode >= BCM_COSQ_SP0 && mode <= BCM_COSQ_SP1))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("parameter error - mode can be -1 or BCM_COSQ_SP0-1 ")));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!((queue_id >= 0 && queue_id <= max_cosq_num))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue_id parameter %d, max_cosq_num for this ofp: %d"), queue_id,max_cosq_num));
    }    

    if (mode == -1) {
        /* Weight is taken into consideration */
        if (!((weight) >= 1 && ((weight) <= (DPP_COSQ_EGR_OFP_SCH_WFQ_WEIGHT_MAX)))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
        }   
    }
        
    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    sch_wfq_p = &(info.ofp_wfq_q_pair[queue_id]);

    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        /* UC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_TRUE;       
    } else {
        /* MC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_FALSE;
    }

    /* Fill WFQ SCH structure */
    rc = _bcm_petra_cosq_egress_fill_ofp_wfq_sch_from_mode_weight(is_ucast_egress_queue,mode,weight,sch_wfq_p);
    BCMDNX_IF_ERR_EXIT(rc);
            
    /* Set configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_set,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : Set weight, sp between FMQ class
 */
STATIC int
_bcm_petra_cosq_gport_fmq_sched_set(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int mode,
                                    int weight)
{
    bcm_error_t rc = BCM_E_NONE;  
    int index, core, gport_cores;
    SOC_TMC_MULT_FABRIC_INFO info;            

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (mode == -1 && (weight < 0 || weight > DPP_COSQ_FMQ_MAX_BE_WEIGHT)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid weight given %d"), weight));
    }
      
    /* clear */
    SOC_TMC_MULT_FABRIC_INFO_clear(&info);

    /* Get cores */
    gport_cores = BCM_GPORT_SCHEDULER_CORE_GET(gport);
    SOC_DPP_CORE_VALIDATE(unit, gport_cores, TRUE);

    BCM_DPP_CORES_ITER(gport_cores, core) {
        /* Get configuration */
        rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);

        if (mode != -1) {
            /* Mode is not disable, Mode is SP only. i.e. MC2 > MC1 > MC0 */
            info.best_effort.wfq_enable = SOC_SAND_FALSE;
            for (index = 0; index < DPP_COSQ_FMQ_NOF_BE; index++) {
                info.best_effort.be_sch_port[index].weight = 0;
            }
        } else {
            /* Set weight configuration */
            info.best_effort.wfq_enable = SOC_SAND_TRUE;

            if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)) {
                info.best_effort.be_sch_port[0].weight = weight;
            } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)) {
                info.best_effort.be_sch_port[1].weight = weight;
            } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
                info.best_effort.be_sch_port[2].weight = weight;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport given (0x%08x) "), gport));
            }
        }

        /* Set configuration */
        rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_set,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : Retrieve weight, sp between FMQ class
 */
STATIC int
_bcm_petra_cosq_gport_fmq_sched_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_cos_queue_t cosq,
                                    int *mode,
                                    int *weight)
{
    bcm_error_t rc = BCM_E_NONE;  
    SOC_TMC_MULT_FABRIC_INFO info;            
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate */
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);
      
    /* Get core */
    core = BCM_GPORT_SCHEDULER_CORE_GET(gport);

    /* Get with BCM_CORE_ALL assumes symetric configuration,
       in this case use core 0 to get information */
    if(core == BCM_CORE_ALL) {
        core = 0;
    }
          
    /* Get configuration */
    rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, core, &info)));
    BCMDNX_IF_ERR_EXIT(rc);

    if (!(info.best_effort.wfq_enable)) {
        /* Mode is not disable, Mode is SP only. i.e. MC2 > MC1 > MC0 */
        *mode = 0;
        *weight = -1;
    } else {
        *mode = -1;

        /* weight configuration */
        if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(gport)) {
            *weight = info.best_effort.be_sch_port[0].weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(gport)) {
            *weight = info.best_effort.be_sch_port[1].weight;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(gport)) {
            *weight = info.best_effort.be_sch_port[2].weight;
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid gport given (0x%08x) "), gport));
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Schedule mode in OTM port scheduler. 
 * UC and MC Egress queues are handled here.
 * Get the SP that the port connect to and the weighted distribution 
 * between the other queue on the same priority. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_sched_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int *mode,
                                            int *weight)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc, tm_port;    
    int core;
    SOC_TMC_EGR_OFP_SCH_WFQ* sch_wfq_p;    
    SOC_TMC_EGR_OFP_SCH_INFO info;
    uint8 is_ucast_egress_queue;
    int max_cosq_num, queue_id;        

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(mode);
    BCMDNX_NULL_CHECK(weight);
    BCM_DPP_UNIT_CHECK(unit);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* clear */
    SOC_TMC_EGR_OFP_SCH_INFO_clear(&info);

    max_cosq_num = DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);
    
    rc = _bcm_petra_egress_queue_from_cosq(unit,&queue_id,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!((queue_id >= 0 && queue_id <= max_cosq_num))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid queue_id parameter %d, queue_id can be in range of 0-1 or High/Low priorities"), queue_id));
    }

    /* Get existed configuration. */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_scheduling_get,(unit, core, tm_port, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Fill mode, weight */
    sch_wfq_p = &(info.ofp_wfq_q_pair[queue_id]);


    if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        /* UC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_TRUE;       
    } else {
        /* MC Egress queue fill */
        is_ucast_egress_queue = SOC_SAND_FALSE;
    }

    rc = _bcm_petra_cosq_egress_fill_mode_weight_from_ofp_wfq_sch(is_ucast_egress_queue,sch_wfq_p,mode,weight);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure OFP shaping rate, set single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 kbits_sec_min,
                                                          uint32 kbits_sec_max,
                                                          uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32          tm_port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    soc_port_t      port;
    uint32          is_alt_calc = 0;
    int core;          

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    
    
    /* Verify */
    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (kbits_sec_max > SOC_TMC_IF_MAX_RATE_KBPS_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_sw_set,(unit, core, tm_port, kbits_sec_max));   
    BCMDNX_IF_ERR_EXIT(rc);

    if ((flags & BCM_COSQ_BW_ALT_CALC) || SOC_IS_QAX(unit)) {
        is_alt_calc = 1;
    }

    if (!(flags & BCM_COSQ_BW_NOT_COMMIT)) {
        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_hw_set,(unit, core, tm_port, is_alt_calc));   
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* currently only BCM_COSQ_BW_NOT_COMMIT and BCM_COSQ_BW_ALT_CALC flag is supported */
    if ((flags & ~(BCM_COSQ_BW_NOT_COMMIT | BCM_COSQ_BW_ALT_CALC)) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: ?%d\nFlags must be set to 0"), flags)); 
    }

exit:
BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get OFP shaping rate, get single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_scheduler_bandwidth_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          uint32 *kbits_sec_min,
                                                          uint32 *kbits_sec_max,
                                                          uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;  
    uint32 tm_port;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;

    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);
    BCM_DPP_UNIT_CHECK(unit);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_single_port_rate_hw_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    *kbits_sec_min = 0;
    *flags = 0;

    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure Port-TC (q-pair) shaping rate, set single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    SOC_TMC_EGR_Q_PRIO prio;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);
                
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc); 

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    if (kbits_sec_max > SOC_TMC_IF_MAX_RATE_KBPS_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }       

    /* Set configuration */
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_rate_sw_set,(unit, core, tm_port ,prio, kbits_sec_max));                   
    BCMDNX_IF_ERR_EXIT(rc);    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_rate_hw_set,(unit));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TC (q-pair) shaping rate
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tc_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port; 
    int core; 
    SOC_TMC_EGR_Q_PRIO prio;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);
                
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_rate_hw_get,(unit, core, tm_port ,prio, kbits_sec_max));                 
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }        

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure Port-TC (HR) shaping rate, set single port rate.
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tc"), unit, gport));
    }
          
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (kbits_sec_max > SOC_TMC_SCH_MAX_RATE_KBPS_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Set configuration */    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_rate_set,(unit, core, tm_port ,cosq, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TC (HR) shaping rate
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tc_bandwidth_get(int unit,
                                                bcm_gport_t gport,
                                                bcm_cos_queue_t cosq,
                                                uint32 *kbits_sec_min,
                                                uint32 *kbits_sec_max,
                                                uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tc"), unit, gport));
    }
          
    /* Validate gport */
    rc = _bcm_petra_cosq_port_priority_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_rate_get,(unit, core, tm_port, cosq, kbits_sec_max));                  
    BCMDNX_IF_ERR_EXIT(rc);    

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_bcm_cosq_to_tcg(int unit,
                                int cosq,
                                SOC_TMC_TCG_NDX *tcg)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (cosq < SOC_TMC_TCG_MIN || cosq > SOC_TMC_TCG_MAX) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq));
    }
    *tcg = cosq;
    
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure TCG shaping rate
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    SOC_TMC_TCG_NDX tcg;
    int core;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit,gport,&tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_pps_to_kbps(unit, core, kbits_sec_max, &kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (kbits_sec_max > SOC_TMC_IF_MAX_RATE_KBPS_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    /* Set configuration */    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_rate_sw_set,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);   
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_rate_hw_set,(unit));
    BCMDNX_IF_ERR_EXIT(rc);   

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get Port-TCG shapring rate
 */
STATIC int
_bcm_petra_cosq_gport_egress_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port; 
    int core; 
    SOC_TMC_TCG_NDX tcg;
    soc_port_t port;
    SOC_TMC_EGR_PORT_SHAPER_MODE shaper_mode;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_rate_hw_get,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.shaper_mode.get(unit, port, &shaper_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* in case of packe shaping, rate is given in packets per second */
    if (shaper_mode == SOC_TMC_EGR_PORT_SHAPER_PACKET_MODE) {
        /* translate from pakcets per send to kbps */
        rc = _bcm_petra_cosq_egress_port_scheduler_kbps_to_pps(unit, core, *kbits_sec_max, kbits_sec_max);
        BCMDNX_IF_ERR_EXIT(rc);
    }            

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Configure TCG shaping rate - E2E
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_set(int unit,
                                                    bcm_gport_t gport,
                                                    bcm_cos_queue_t cosq,
                                                    uint32 kbits_sec_min,
                                                    uint32 kbits_sec_max,
                                                    uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    SOC_TMC_TCG_NDX tcg;
    int core;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only e2e port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (kbits_sec_max > SOC_TMC_SCH_MAX_RATE_KBPS_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d"), kbits_sec_max));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Set configuration */    
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_rate_set,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get E2E Port-TCG shapring rate
 */
STATIC int
_bcm_petra_cosq_gport_e2e_port_tcg_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    SOC_TMC_TCG_NDX tcg;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only E2E port tcg"), unit, gport));
    }

    rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_port_tcg_validate(unit,gport,cosq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);    

    /* Get existing configuration */  
    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_rate_get,(unit, core, tm_port ,tcg, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    /* fill rates */
    *kbits_sec_min = 0;
    *flags = 0;
    
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Configure OFP shaping rate, set configuration per interface.
 */
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_set(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 kbits_sec_min,
                                                               uint32 kbits_sec_max,
                                                               uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"),flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_interface_shaper_set,(unit, core, tm_port, SOC_TMC_OFP_SHPR_UPDATE_MODE_OVERRIDE,kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get configuration of OFP shaping rate, get configuration per interface.
 */
STATIC int
_bcm_petra_cosq_gport_egress_interface_scheduler_bandwidth_get(int unit,
                                                               bcm_gport_t gport,
                                                               bcm_cos_queue_t cosq,
                                                               uint32 *kbits_sec_min,
                                                               uint32 *kbits_sec_max,
                                                               uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of interface gport"), cosq));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_interface_shaper_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;
    *flags = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_MULT_FABRIC_INFO info;   
    int core, gport_cores; 

    BCMDNX_INIT_FUNC_DEFS;
    
    /* Validate */
    if (!(BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport))) {

        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit(%d) invalid gport type (0x%08x)"), unit, gport));
    }
    if (cosq != 0 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
    }
    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid minimum kbits per second parameter %d\n"), unit, kbits_sec_min));
    }
    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter %d\n"), unit, flags));
    }

    /* Get cores */
    gport_cores = BCM_GPORT_SCHEDULER_CORE_GET(gport);
    SOC_DPP_CORE_VALIDATE(unit, gport_cores, TRUE);

    BCM_DPP_CORES_ITER(gport_cores, core) {
        /* Get existing configuration */
        rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);

        if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport)) {
            info.max_rate = kbits_sec_max;
        } else if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)) {
            info.guaranteed.gr_shaper.rate = kbits_sec_max;
        } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
            info.best_effort.be_shaper.rate = kbits_sec_max;
        }
        
        /* Set configuration */
        rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_set,(unit, core, &info)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_gport_fmq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_MULT_FABRIC_INFO info;  
    int core;  

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    
    /* Validate */
    if (!(BCM_COSQ_GPORT_IS_FMQ_ROOT(gport) 
             || BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)
             || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport))) {

        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit(%d) invalid gport type (0x%08x)"), unit, gport));
    }
    if (cosq != 0 ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
    }

    /* Get core */
    core = BCM_GPORT_SCHEDULER_CORE_GET(gport);

    /* Get with BCM_CORE_ALL assumes symetric configuration,
       in this case use core 0 to get information */
    if(core == BCM_CORE_ALL) {
        core = 0;
    }

    /* Get existing configuration */
    rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, core, &info)));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;

    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(gport)) {
        *kbits_sec_max = info.max_rate;
    } else if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(gport)) {
        *kbits_sec_max = info.guaranteed.gr_shaper.rate;
    } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(gport)) {
        *kbits_sec_max = info.best_effort.be_shaper.rate;
    }      

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 kbits_sec_min,
                                        uint32 kbits_sec_max,
                                        uint32 flags)
{
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;
    uint32 soc_sand_rc;
    int core;

    BCMDNX_INIT_FUNC_DEFS;
 
    /* Set ISQ range in hardware (symmetric configuration for all cores)*/
    BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
     
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, core, &isp_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        BCM_DPP_UNIT_CHECK(unit);

        isp_info.rate = kbits_sec_max;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_set,(unit, core, &isp_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

 exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_isq_bandwidth_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        uint32 *kbits_sec_min,
                                        uint32 *kbits_sec_max,
                                        uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_ITM_INGRESS_SHAPE_INFO isp_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);
 
    /* Set ISQ range in hardware */
    SOC_TMC_ITM_INGRESS_SHAPE_INFO_clear(&isp_info);
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_ingress_shape_get,(unit, BCM_CORE_ALL, &isp_info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *kbits_sec_max = isp_info.rate;
    *kbits_sec_min = 0;
    *flags = 0;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;

}

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         uint32 kbits_sec_min,
                                         uint32 kbits_sec_max,
                                         uint32 flags)
{
    bcm_error_t               rc = BCM_E_NONE;
    int                       soc_sand_rc = 0;
    bcm_dpp_cosq_gport_info_t *port_info;
    SOC_TMC_SCH_FLOW          exact_flow_config;
    int                       flow_id_index, i, flow_id, orig_sub_flow0_id, orig_sub_flow1_id;
    int                       orig_sub_flow0_update_bw_only, orig_sub_flow1_update_bw_only;
    int                       core ;
    uint32                    nof_remote_cores, region;

    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (kbits_sec_min != 0) {
        /* no guaranteed rate supported for this type */
        LOG_WARN(BSL_LS_BCM_COSQ,
                 (BSL_META_U(unit,
                             "unit(%d) kbits_sec_min(%d > 0) unsupported gport(0x%08x)\n"),
                             unit, kbits_sec_min, gport));
    }

    if (SOC_IS_QAX(unit)) {
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &gport, core);
    }
    /* validate port element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, 0, &port_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (port_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
    /*
     * Note that we are changing here, intentionally, the actual data on 'port_info->flow_config'.
     * If OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is non-zero and 'spn_COSQ_RUNTIME_PERFORMANCE_OPTIMIZE_ENABLE' is non-zero,
     * this block is on the tree and reading it will result in the (correct) new data.
     */
    (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_rate = kbits_sec_max;

    /* set all symmetric connections */
    if (port_info->is_connector) {
        region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
        nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = port_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = port_info->flow_config->sub_flow[1].id;

    orig_sub_flow0_update_bw_only = port_info->flow_config->sub_flow[0].update_bw_only ;
    orig_sub_flow1_update_bw_only = port_info->flow_config->sub_flow[1].update_bw_only ;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(port_info->flow_id, nof_remote_cores, i);

        port_info->flow_config->sub_flow[0].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        port_info->flow_config->sub_flow[1].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        port_info->flow_config->sub_flow[0].update_bw_only = 1;
        port_info->flow_config->sub_flow[1].update_bw_only = 1;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id, port_info->flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
            port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif
    port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
    port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_flow_bandwidth_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_cos_queue_t cosq,
                                   uint32 *kbits_sec_min,
                                   uint32 *kbits_sec_max,
                                   uint32 *flags)
{
    bcm_error_t                       rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t         *port_info;
    int                               flow_id_index;
    int                               base_flow_id = 0, is_connector, gport_sf2_type = 0, numq = 0;
    int                              core ;
    uint8                            sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* consistency check to determine if cosq is valid */
    is_connector = (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) ? TRUE : FALSE;
    if (is_connector == TRUE) {
        /* determine flow id */
        base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    }
    if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        /* determine if associated with  connector or se */
        BCM_INT_DPP_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
        is_connector = (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) ? TRUE : FALSE;

        if (is_connector == TRUE) {
            /* determine flow id */
            base_flow_id = BCM_COSQ_GPORT_COMPOSITE_SF2_GET(gport);
        }
    }

    if (is_connector) {
        if (SOC_IS_QAX(unit)) {
            base_flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, base_flow_id);
        }
        /* retrieve connector group state */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) has an invalid num_cos of %d"), unit, base_flow_id, sw_state_num_cos));
        }
        numq = sw_state_num_cos;
    }

    if (is_connector) {
        if (cosq >= numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
        }
    }
    else if ( (BCM_GPORT_IS_SCHEDULER(gport)) ||
              (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) ||
              (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ) {
        if ( (cosq != 0) && (cosq != -1) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
        }
    }
    else { /* should never reach here */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x), gport type should be connector or scheduler"), unit, gport));
    }
    
    /* misc consistency checks */
    if (kbits_sec_max == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, kbits_sec_max parameter"), unit));
    }
    if (kbits_sec_min != NULL) {
        (*kbits_sec_min) = 0;
    }
    if (flags != NULL) {
        (*flags) = 0;
    }

    if (SOC_IS_QAX(unit)) {
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &gport, core);
    }
    /* validate port element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, gport, cosq, 0, &port_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (port_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
    (*kbits_sec_max) = (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_rate;

    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_set(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 kbits_sec_min,
                                              uint32 kbits_sec_max,
                                              uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;
    uint32              is_alt_calc = 0;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Verify */

    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    if (kbits_sec_max > SOC_TMC_SCH_MAX_RATE_KBPS_ARAD(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_max: %d out of range max %d"), kbits_sec_max, SOC_TMC_SCH_MAX_RATE_KBPS_ARAD(unit)));
    }    

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_single_port_rate_sw_set,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    if ((flags & BCM_COSQ_BW_ALT_CALC)) {
        is_alt_calc = 1;
    }

    if (!(flags & BCM_COSQ_BW_NOT_COMMIT)) {
        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_single_port_rate_hw_set,(unit, core, tm_port, is_alt_calc));  
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* currently only BCM_COSQ_BW_NOT_COMMIT and BCM_COSQ_BW_ALT_CALC flag is supported */
    if ((flags & ~(BCM_COSQ_BW_NOT_COMMIT | BCM_COSQ_BW_ALT_CALC)) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: ?%d\nFlags must be set to 0"), flags)); 
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e port(%d) core(%d) sched rate to (%d)kbps\n"), 
                          unit, gport, tm_port, core, kbits_sec_max));


exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
 _bcm_petra_cosq_gport_e2e_port_bandwidth_get(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              uint32 *kbits_sec_min,
                                              uint32 *kbits_sec_max,
                                              uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port;  
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    if(cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid cosq %d"), unit, cosq));
    } 

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_single_port_rate_hw_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;/*always 0*/
    *flags = 0;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) get e2e port(%d) core(%d) sched rate to (%d)kbps\n"), 
                          unit, gport, tm_port, core, *kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_set(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 kbits_sec_min,
                                                   uint32 kbits_sec_max,
                                                   uint32 flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    if (kbits_sec_min != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d\nkbits_sec_min must be set to 0"), kbits_sec_min));
    }

    if (flags != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: flags: %d\nFlags must be set to 0"), flags));
    }

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_if_shaper_rate_set,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e interface sched rate to (%d)kbps\n"), unit, gport, kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
 _bcm_petra_cosq_gport_e2e_interface_bandwidth_get(int unit,
                                                   bcm_gport_t gport,
                                                   bcm_cos_queue_t cosq,
                                                   uint32 *kbits_sec_min,
                                                   uint32 *kbits_sec_max,
                                                   uint32 *flags)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(kbits_sec_min);
    BCMDNX_NULL_CHECK(kbits_sec_max);
    BCMDNX_NULL_CHECK(flags);

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_if_shaper_rate_get,(unit, core, tm_port, kbits_sec_max));
    BCMDNX_IF_ERR_EXIT(rc);

    *kbits_sec_min = 0;
    *flags = 0;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) e2e gport(0x%08x) set e2e interface sched rate to (%d)kbps\n"), 
                          unit, gport, *kbits_sec_max));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_sched_cl_weight_get(int                        unit,
                                            bcm_gport_t                port,
                                            bcm_cos_queue_t            cosq,
                                            bcm_cosq_control_t         type,
                                            int                       *weight,
                                            bcm_dpp_cosq_gport_info_t *port_info)
{
    bcm_error_t                rc = BCM_E_NONE;
    bcm_dpp_cosq_class_info_t  class_info;
    int                        weight_ap;
    uint32                     soc_sand_rc;
    SOC_TMC_SCH_SE_CL_CLASS_INFO  *class_type = NULL;
    int                        core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    (*weight) = 0;

    if (port_info->is_se == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information must be schedule element"), unit));
    }
    if (port_info->se_config->type != SOC_TMC_SCH_SE_TYPE_CL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information schedule element must be of CL type"), unit));
    }
    if ((cosq != 0) && (cosq != -1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d, must be 0 or -1"), unit, cosq));
    }

    switch (type) {
        case bcmCosqControlDiscreteWeightLevel0:
            weight_ap = 0;
            break;
        case bcmCosqControlDiscreteWeightLevel1:
            weight_ap = 1;
            break;
        case bcmCosqControlDiscreteWeightLevel2:
            weight_ap = 2;
            break;
        case bcmCosqControlDiscreteWeightLevel3:
            weight_ap = 3;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
            break;
    }

    rc = _bcm_petra_cosq_credit_class_info_get(unit, core, port_info->se_config, -1, &class_info);
    BCMDNX_IF_ERR_EXIT(rc);

    if ( (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) &&
         (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid weight mode 0x%x"), unit, class_info.weight_mode));
    }

    if (weight_ap > class_info.max_discrete_class) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
    }

    BCMDNX_ALLOC(class_type, sizeof(SOC_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    if (class_type == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d,could not allocate class type"),unit));
    }

    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(class_type);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, core, port_info->se_config->type_info.cl.id, class_type)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, port_info->se_config->type_info.cl.id, soc_sand_rc, rc));
        goto err;
    }
    
    switch (class_type->mode) {
        case SOC_TMC_SCH_CL_MODE_2:
            weight_ap +=2;  /* in mode 2 AF2 & AF3 are in use */
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            weight_ap +=1;  /* in mode 4 AF1,AF2 & AF3 are in use */
            break;

        default:
            break;
    }

    if (weight_ap > SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "unit %d, invalid control type 0x%x"), unit, type));
        rc = BCM_E_PARAM;
        goto err;
    }

    (*weight) = class_type->weight[weight_ap];

   BCM_FREE(class_type);

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (class_type != NULL) {
       BCM_FREE(class_type);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_flow_get(int unit,
                            bcm_gport_t port,
                            bcm_cos_queue_t cosq,
                            bcm_cosq_control_t type,
                            int *arg)
{
    bcm_error_t                rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t  *port_info;
    int                        flow_id_index, core;
    uint8                     is_non_contiguous; 
    int                       region, is_cl_cir, is_odd_even;    

    
    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;

    if(!BCM_GPORT_IS_FABRIC_CLOS(port) && !BCM_GPORT_IS_FABRIC_MESH(port)) {
        rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    switch(type) {

        case bcmCosqControlBandwidthBurstMax:
            if (BCM_GPORT_IS_FABRIC_CLOS(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_burst_get(unit, port, arg);
                flow_id_index = 0;
                break;
            }
            else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_get(unit, port, arg);
                flow_id_index = 0;
                break;
            }      
            else if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) ||
                  BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port) ||
                  BCM_COSQ_GPORT_IS_SCHED_PIR(port))) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                rc = BCM_E_PARAM;
                goto err;
            }

            if (SOC_IS_QAX(unit)) {
                _bcm_petra_cosq_gport_qax_flow_id_add(unit, &port, core);
            }

            /* validate port element */
            rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, 0, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
            (*arg) = (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_burst;

            break;

        case bcmCosqControlFlowSlowRate:
            if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port)  || BCM_GPORT_IS_FABRIC_CLOS(port) || BCM_GPORT_IS_FABRIC_MESH(port))) {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }

            if (BCM_GPORT_IS_FABRIC_CLOS(port))
            {
                /*Configure CLOS FMQs Slow Start Mechanism*/
                /* Ingress Scheduler */
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

            } else if(BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else {
                /*VOQs connector slow rate*/

                if (SOC_IS_QAX(unit)) {
                    _bcm_petra_cosq_gport_qax_flow_id_add(unit, &port, core);
                }

                /* validate port element */
                rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_connector_element, &port_info);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
                if (port_info == NULL) {
                     LOG_ERROR(BSL_LS_BCM_COSQ,
                               (BSL_META_U(unit,
                                           "unit %d, resource memory allocation failure\n"), unit));
                    rc = BCM_E_MEMORY;
                    goto err;
                }

                flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;

                if ((port_info->flow_config)->is_slow_enabled == FALSE) {
                    (*arg) = 0;
                }
                else {
                    (*arg) = ((port_info->flow_config)->sub_flow[flow_id_index].slow_rate_ndx == 0)? 1:2 ;
                }

            }
            break;
       case bcmCosqControlFlowSlowRate1:
       case bcmCosqControlFlowSlowRate2:
            if (!(BCM_GPORT_IS_FABRIC_CLOS(port) || BCM_GPORT_IS_FABRIC_MESH(port)))
            {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            /*Configure FMQs Slow Start Mechanism*/
            /* Ingress Scheduler */
            if (BCM_GPORT_IS_FABRIC_CLOS(port))
            {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else if(BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_get(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            }
            break;

        case bcmCosqControlDiscreteWeightLevel0:
        case bcmCosqControlDiscreteWeightLevel1:
        case bcmCosqControlDiscreteWeightLevel2:
        case bcmCosqControlDiscreteWeightLevel3:

            if (SOC_IS_QAX(unit)) {
                _bcm_petra_cosq_gport_qax_flow_id_add(unit, &port, core);
            }
            /* validate port element */
            rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_parent_element, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
            rc = _bcm_petra_flow_region_config_get(unit, core, region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
            BCMDNX_IF_ERR_EXIT(rc); 

            if (!(BCM_GPORT_IS_SCHEDULER(port) ||
                 ((BCM_COSQ_GPORT_IS_SCHED_CIR(port) && is_cl_cir) || (BCM_COSQ_GPORT_IS_SCHED_PIR(port) && !is_cl_cir)) ) ) {
                rc = BCM_E_PARAM;
                goto err;
            }

            rc = _bcm_petra_cosq_control_sched_cl_weight_get(unit, port, cosq, type, arg, port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case bcmCosqControlSpLevelMax:
            break;

        case bcmCosqControlSp0WeightMax:
            break;
        case bcmCosqControlSp1WeightMax:
            break;
        case bcmCosqControlSp2WeightMax:
            break;
        case bcmCosqControlSp3WeightMax:
            break;
        case bcmCosqControlSp4WeightMax:
            break;
        case bcmCosqControlSp5WeightMax:
            break;
        case bcmCosqControlSp6WeightMax:
            break;
        case bcmCosqControlSp7WeightMax:
            break;
        case bcmCosqControlSp8WeightMax:
            break;
        case bcmCosqControlSp9WeightMax:
            break;
        case bcmCosqControlSp10WeightMax:
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            goto err;
            break;
    }

err:
    BCMDNX_IF_ERR_EXIT(rc);

exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_hr_fc_validate_info_get(int unit, int hr_mode, bcm_cos_queue_t cosq, int arg, int *hr_class)
{
    bcm_error_t rc = BCM_E_NONE;
    int cos;
   
    
    BCMDNX_INIT_FUNC_DEFS;
    cos = (cosq == -1) ? arg : cosq;

    if (cosq != -1) {
        if (arg != BCM_COSQ_HIGH_PRIORITY) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Flow control not supported for cos %d and arg 0x%x\n"), unit, cosq, arg));
        }
    }

    switch (hr_mode) {
        case SOC_TMC_SCH_HR_MODE_SINGLE_WFQ:
            switch (cos) {
                case 0: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 3: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_SINGLE_CLASS_AF1_WFQ; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case SOC_TMC_SCH_HR_MODE_DUAL_WFQ:
            switch (cos) {
                case 0: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 3: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_DUAL_OR_ENHANCED; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
            switch (cos) {
                case 0: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF1; break;
                case 1: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF2; break;
                case 2: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3; break;
                case 8: (*hr_class) = SOC_TMC_SCH_PORT_LOWEST_HP_HR_DUAL_OR_ENHANCED; break;
                default:
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Flow control not supported for cos %d\n"), unit, cosq));
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Unknown HR mode %d\n"), unit, hr_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_hr_fc_update(int unit, int profile, int hr_class)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_SCH_PORT_HP_CLASS_INFO class_info;
    uint32 soc_sand_rc;           

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_SCH_PORT_HP_CLASS_INFO_clear(&class_info);

    /* retrieve profile */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_hp_class_conf_get,(unit, &class_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving HR Flow Control CLass Info, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    /* update profile */
    class_info.lowest_hp_class[profile] = hr_class;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_hp_class_conf_set,(unit, &class_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving HR Flow Control CLass Info, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petrs_cosq_port_hr_flow_control_set(int unit, bcm_gport_t port, bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type, int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    int hr_mode, hr_class;
    int old_profile, profile, is_last, is_allocated;
    int core;
    SOC_TMC_SCH_PORT_INFO port_info;
    uint32 soc_sand_rc, tm_port;        

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_SCH_PORT_INFO_clear(&port_info);

    /* determine fap port */
    rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
    if (rc != BCM_E_NONE) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (tm_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, got invalid fap port %d,  for port (0x%x)"), unit, tm_port, port));
    }

    /* get associated configuration */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit, core, tm_port, &port_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retrieving scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, tm_port, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    hr_mode = port_info.hr_mode;

    /* consistency checks and new class info */
    rc = _bcm_petra_cosq_hr_fc_validate_info_get(unit, hr_mode, cosq, arg, &hr_class);
    BCMDNX_IF_ERR_EXIT(rc);

    /* get new profile */
    rc = _bcm_dpp_am_template_cosq_port_hr_fc_exchange(unit, core, tm_port, &hr_class, &old_profile, &is_last, &profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* if required update device configuration */
    if (is_allocated == TRUE) {
        rc = _bcm_petra_cosq_hr_fc_update(unit, profile, hr_class);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* if required update port configuration */
    if ( (old_profile != profile) || (port_info.lowest_hp_class != hr_class) ) {
        port_info.lowest_hp_class = hr_class;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, tm_port, &port_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, tm_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_e2e_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowControlPriority:
            /* Supported only in case of not Port-TC enable */
            if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
                rc = _bcm_petrs_cosq_port_hr_flow_control_set(unit, port, cosq, type, arg);
            }
            break;
        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_control_e2e_get(int unit,
                            bcm_gport_t port,
                            bcm_cos_queue_t cosq,
                            bcm_cosq_control_t type,
                            int *arg)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(arg);

    switch(type) {
        case bcmCosqControlFlowControlPriority:
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_sched_cl_weight_set(int                        unit,
                                            bcm_gport_t                port,
                                            bcm_cos_queue_t            cosq,
                                            bcm_cosq_control_t         type,
                                            int                        weight,
                                            bcm_dpp_cosq_gport_info_t *port_info)
{
    bcm_error_t                      rc = BCM_E_NONE;
    bcm_dpp_cosq_class_info_t        class_info;
    int                              weight_ap;
    uint32                           soc_sand_rc;
    SOC_TMC_SCH_SE_CL_CLASS_INFO        *class_type = NULL, *exact_class_type = NULL;
    bcm_dpp_cosq_sched_class_data_t  class_data;
    int                              *weights, flags = 0;
    int                              is_last, class_template, is_allocated;
    SOC_TMC_SCH_FLOW                 *exact_flow_config = NULL;
    int                              core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    if (port_info->is_se == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information must be schedule element"), unit));
    }
    if (port_info->se_config->type != SOC_TMC_SCH_SE_TYPE_CL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port information schedule element must be of CL type"), unit));
    }
    if ((cosq != 0) && (cosq != -1)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cosq %d"), unit, cosq));
    }
    if(weight < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Weight must be positive %d\n"), unit, weight));
    }

    /* determine if the attachment point is valid */
    switch (type) {
        case bcmCosqControlDiscreteWeightLevel0:
            weight_ap = 0;
            break;
        case bcmCosqControlDiscreteWeightLevel1:
            weight_ap = 1;
            break;
        case bcmCosqControlDiscreteWeightLevel2:
            weight_ap = 2;
            break;
        case bcmCosqControlDiscreteWeightLevel3:
            weight_ap = 3;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
            break;
    }

    rc = _bcm_petra_cosq_credit_class_info_get(unit, core, port_info->se_config, -1, &class_info);
    BCMDNX_IF_ERR_EXIT(rc);

    if ( (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW) &&
         (class_info.weight_mode != SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid weight mode 0x%x"), unit, class_info.weight_mode));
    }
   
    if (weight_ap > class_info.max_discrete_class) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
    }

    /* retrieve class data */
    BCMDNX_ALLOC(class_type, sizeof(SOC_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    BCMDNX_ALLOC(exact_class_type, sizeof(SOC_TMC_SCH_SE_CL_CLASS_INFO), "class type");
    if ( (class_type == NULL) || (exact_class_type == NULL) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("memory allocation failed")));
    }

    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(class_type);
    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(exact_class_type);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, core, port_info->se_config->type_info.cl.id, class_type)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, port_info->se_config->type_info.cl.id, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    weights = (int *)class_type->weight;
    DPP_DEVICE_COSQ_CL_CLASS_DATA_INIT(class_data, class_type->mode, class_type->enhanced_mode, class_type->weight_mode, weights);
    
    switch (class_type->mode) {
        case SOC_TMC_SCH_CL_MODE_2:
            weight_ap +=2;  /* in mode 2 AF2 & AF3 are in use */
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            weight_ap +=1;  /* in mode 4 AF1,AF2 & AF3 are in use */
            break;

        default:
            break;
    }

    if (weight_ap > SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid control type 0x%x"), unit, type));
    }

    /* update the new template data */
    class_data.weights[weight_ap] = weight;

    /* get new template */
    rc = _bcm_dpp_am_template_cosq_sched_class_exchange(unit, core, flags, (int *)&class_data, port_info->se_config->type_info.cl.id, &is_last, &class_template, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);
   
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "  DBG, template Sched(cl), Allocated(%s), is_last(%s), oldTemplate(%d), Template(%d)\n"), ((is_allocated == TRUE) ? "TRUE" : "FALSE"), ((is_last == TRUE) ? "TRUE" : "FALSE"), port_info->se_config->type_info.cl.id, class_template));

    /* if required update h/w with template */
    if (is_allocated == TRUE) {
        /* update class information */
        class_type->weight[weight_ap] = weight;
        class_type->id = class_template;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_set,(unit, core, class_template, class_type, exact_class_type)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in class type for class index(%d)\n"), unit, class_template));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }

    /* map the new CL profile */
    port_info->se_config->type_info.cl.id = class_template;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, port_info->se_id, port_info->se_config, port_info->flow_config, exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type cl\n"), unit, port_info->se_id));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(class_type);
    BCM_FREE(exact_class_type);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_flow_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg)
{
    bcm_error_t               rc = BCM_E_NONE;
    int                       soc_sand_rc = 0;    
    bcm_dpp_cosq_gport_info_t *port_info;
    SOC_TMC_SCH_FLOW          exact_flow_config;
    int                       flow_id_index, is_slow_enabled, slow_rate_index;
    int                       core = 0, i, flow_id, orig_sub_flow0_id, orig_sub_flow1_id;
    uint32                    region, nof_remote_cores;
    uint8                     is_non_contiguous; 
    int                       is_cl_cir, is_odd_even;

    BCMDNX_INIT_FUNC_DEFS;
    port_info = NULL ;
    {
        if(!BCM_GPORT_IS_FABRIC_CLOS(port) && !BCM_GPORT_IS_FABRIC_MESH(port)) {
            rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                        "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    switch(type) {

        /* Set burst max for flow shaper */
        case bcmCosqControlBandwidthBurstMax:
        {
            if (BCM_GPORT_IS_FABRIC_CLOS(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_burst_set(unit, port, arg);
                flow_id_index = 0;
                break;
            }
            else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_set(unit, port, arg);
                flow_id_index = 0;
                break;
            }  
            else if (!(BCM_GPORT_IS_SCHEDULER(port) || BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) ||
                  BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_COSQ_GPORT_IS_SCHED_CIR(port) ||
                  BCM_COSQ_GPORT_IS_SCHED_PIR(port))) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                rc = BCM_E_PARAM;
                goto err;
            }

            if (SOC_IS_QAX(unit)) {
                _bcm_petra_cosq_gport_qax_flow_id_add(unit, &port, core);
            }

            /* validate port element */
            rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, 0, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            /* Validate arg */
            if (arg < 0) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, arg %d invalid\n"), unit, arg));
                rc = BCM_E_PARAM;
                goto err;
            }

            flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;
            /*
             * Note that we are changing here, intentionally, the actual data on 'port_info->flow_config'.
             * If OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is non-zero and 'spn_COSQ_RUNTIME_PERFORMANCE_OPTIMIZE_ENABLE' is non-zero,
             * this block is on the tree and reading it will result in the (correct) new data.
             */
            (port_info->flow_config)->sub_flow[flow_id_index].shaper.max_burst = arg;

            /* set all symmetric connections */
            if (port_info->is_connector) {
                region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
                nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][region];
            } else {
                nof_remote_cores = 1;
            }

            orig_sub_flow0_id = port_info->flow_config->sub_flow[0].id;
            orig_sub_flow1_id = port_info->flow_config->sub_flow[1].id;

            for (i = 0; i < nof_remote_cores; i++) {           
                flow_id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(port_info->flow_id, nof_remote_cores, i);

                port_info->flow_config->sub_flow[0].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                               nof_remote_cores, i);
                port_info->flow_config->sub_flow[1].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                              nof_remote_cores, i);

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id, port_info->flow_config, &exact_flow_config)));

                if(SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
                    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
                    {
                        port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                        port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
                    }
/* } */
#endif
                    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
                }
            }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
        }
        break;

        case bcmCosqControlFlowSlowRate:
            if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(port) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(port) || BCM_GPORT_IS_FABRIC_CLOS(port) || BCM_GPORT_IS_FABRIC_MESH(port))) {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            if (BCM_GPORT_IS_FABRIC_CLOS(port))
            {
                /*Configure CLOS FMQs Slow Start Mechanism*/
                /* Ingress Scheduler */
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

            } else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else {
                /*VOQs connector slow rate*/
                int  orig_sub_flow0_update_bw_only, orig_sub_flow1_update_bw_only;

                if ( (arg != 0) && (arg != 1) && (arg != 2) ) {
                    rc = BCM_E_PARAM;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid arg %d for type %d\n"), unit, arg, type));
                    goto err;
                }

                if (SOC_IS_QAX(unit)) {
                    _bcm_petra_cosq_gport_qax_flow_id_add(unit, &port, core);
                }
                /* validate port element */
                rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_connector_element, &port_info);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
                if (port_info == NULL) {
                     LOG_ERROR(BSL_LS_BCM_COSQ,
                               (BSL_META_U(unit,
                                           "unit %d, resource memory allocation failure\n"), unit));
                    rc = BCM_E_MEMORY;
                    goto err;
                }

                is_slow_enabled = (arg == 0) ? FALSE : TRUE;
                slow_rate_index = 1;
                if (is_slow_enabled) {
                    slow_rate_index = (arg == 1) ? 0 : 1;
                }

                flow_id_index = (port_info->is_sf2 == TRUE) ? 1 : 0;

                (port_info->flow_config)->is_slow_enabled = is_slow_enabled;
                if (is_slow_enabled == FALSE) {
                    /* set to default value */
                    (port_info->flow_config)->sub_flow[0].slow_rate_ndx = slow_rate_index;
                    if (port_info->is_composite) {
                        (port_info->flow_config)->sub_flow[1].slow_rate_ndx = slow_rate_index;
                    }
                }
                else {
                    (port_info->flow_config)->sub_flow[flow_id_index].slow_rate_ndx = slow_rate_index;
                }

                /* set all symmetric connections */
                if (port_info->is_connector) {
                    region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
                    nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][region];
                } else {
                    nof_remote_cores = 1;
                }

                orig_sub_flow0_id = port_info->flow_config->sub_flow[0].id;
                orig_sub_flow1_id = port_info->flow_config->sub_flow[1].id;

                orig_sub_flow0_update_bw_only = port_info->flow_config->sub_flow[0].update_bw_only ;
                orig_sub_flow1_update_bw_only = port_info->flow_config->sub_flow[1].update_bw_only ;

                for (i = 0; i < nof_remote_cores; i++) {           
                    flow_id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(port_info->flow_id, nof_remote_cores, i);

                    port_info->flow_config->sub_flow[0].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                                   nof_remote_cores, i);
                    port_info->flow_config->sub_flow[1].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                                   nof_remote_cores, i);
                    port_info->flow_config->sub_flow[0].update_bw_only = 0;
                    port_info->flow_config->sub_flow[1].update_bw_only = 0;
                    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id, port_info->flow_config, &exact_flow_config)));
                    if(SOC_SAND_FAILURE(soc_sand_rc)) {
                        rc = translate_sand_success_failure(soc_sand_rc);
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
                        if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
                        {
                            port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                            port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
                        }
/* } */
#endif
                        port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
                        port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;
                        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
                    }
                }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
                if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
                {
                    port_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                    port_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
                }
/* } */
#endif
                port_info->flow_config->sub_flow[0].update_bw_only = orig_sub_flow0_update_bw_only ;
                port_info->flow_config->sub_flow[1].update_bw_only = orig_sub_flow1_update_bw_only ;
            }

            break;
       case bcmCosqControlFlowSlowRate1:
       case bcmCosqControlFlowSlowRate2:
            if (!(BCM_GPORT_IS_FABRIC_CLOS(port) || BCM_GPORT_IS_FABRIC_MESH(port)))
            {
                rc = BCM_E_PARAM;
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, type %d not supported for gport: 0x%x\n"), unit, type, port));
                goto err;
            }
            /*Configure FMQs Slow Start Mechanism*/
            /* Ingress Scheduler */
            if (BCM_GPORT_IS_FABRIC_CLOS(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            } else if (BCM_GPORT_IS_FABRIC_MESH(port)) {
                rc = _bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_set(unit, port, cosq, type, arg);
                if (rc != BCM_E_NONE) {
                    goto err;
                }
            }
           break;

        case bcmCosqControlDiscreteWeightLevel0:
        case bcmCosqControlDiscreteWeightLevel1:
        case bcmCosqControlDiscreteWeightLevel2:
        case bcmCosqControlDiscreteWeightLevel3:

            if (SOC_IS_QAX(unit)) {
                _bcm_petra_cosq_gport_qax_flow_id_add(unit, &port, core);
            }

            /* validate port element */
            rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, port, cosq, dpp_device_cosq_gport_parent_element, &port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }
            if (port_info == NULL) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(port_info->flow_id);
            rc = _bcm_petra_flow_region_config_get(unit, core, region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
            BCMDNX_IF_ERR_EXIT(rc); 
            
            if (!(BCM_GPORT_IS_SCHEDULER(port) ||
                 ((BCM_COSQ_GPORT_IS_SCHED_CIR(port) && is_cl_cir) || (BCM_COSQ_GPORT_IS_SCHED_PIR(port) && !is_cl_cir)) ) ) {
                rc = BCM_E_PARAM;
                goto err;
            }

            rc = _bcm_petra_cosq_control_sched_cl_weight_set(unit, port, cosq, type, arg, port_info);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            goto err;
            break;
    }


err:
    BCMDNX_IF_ERR_EXIT(rc);

exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
/* } */
#endif

    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_congestion_port_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg)
{  
    soc_error_t               rv = SOC_E_NONE;
    bcm_port_t                congestion_port = 0;
    SOC_TMC_FC_HCFC_WATCHDOG  hcfc_watchdog;

    BCMDNX_INIT_FUNC_DEFS;

    congestion_port = BCM_GPORT_CONGESTION_GET(port);
    sal_memset(&hcfc_watchdog, 0x0, sizeof(SOC_TMC_FC_HCFC_WATCHDOG));

    switch(type) {
        /* Set watchdog period */
        case bcmCosqControlFlowControlErrWatchdog:
            {
                rv = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting hcfc watchdog for port %d, error 0x%x\n"), unit, congestion_port, rv));

                hcfc_watchdog.enable = arg ? TRUE : FALSE;
                hcfc_watchdog.period = arg;

                rv = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_hcfc_watchdog_set,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in setting hcfc watchdog for port %d, error 0x%x\n"), unit, congestion_port, rv));
            }
            break;
        /* Set fc indication that will be sent when watch-dog error is reported */
        case bcmCosqControlFlowControlErrHandle:
            {  
                rv = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting fc indication that will be sent when watch-dog error is reported for port %d, error 0x%x\n"), unit, congestion_port, rv));

                hcfc_watchdog.error_status = arg ? 1 : 0;

                rv = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_hcfc_watchdog_set,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in setting fc indication that will be sent when watch-dog error is reported for port %d, error 0x%x\n"), unit, congestion_port, rv));
            }
            break;
        default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_congestion_port_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg)
{  
    soc_error_t               rv = SOC_E_NONE;
    bcm_port_t                congestion_port = 0;
    SOC_TMC_FC_HCFC_WATCHDOG  hcfc_watchdog;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    congestion_port = BCM_GPORT_CONGESTION_GET(port);
    sal_memset(&hcfc_watchdog, 0x0, sizeof(SOC_TMC_FC_HCFC_WATCHDOG));

    switch(type) {
        /* Get watchdog period */
        case bcmCosqControlFlowControlErrWatchdog:
            {
                rv = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting hcfc watchdog for port %d, error 0x%x\n"), unit, congestion_port, rv));

                (*arg) = hcfc_watchdog.period;

            }
            break;
        /* Get fc indication that will be sent when watch-dog error is reported */
        case bcmCosqControlFlowControlErrHandle:
            {  
                rv = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_hcfc_watchdog_get,(unit, congestion_port, &hcfc_watchdog)));
                BCMDNX_IF_ERR_EXIT_MSG(rv, (_BSL_BCM_MSG("unit %d, error in getting fc indication that will be sent when watch-dog error is reported for port %d, error 0x%x\n"), unit, congestion_port, rv));

                (*arg) = hcfc_watchdog.error_status;
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_control_profile_set(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int arg)
{
    BCMDNX_INIT_FUNC_DEFS;

    switch(type) {
        /* set ocb only */
        case bcmCosqControlOCBOnly:
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_rate_class_ocb_only_set(unit,port, cosq, arg));
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_profile_get(int unit,
                                 bcm_gport_t port,
                                 bcm_cos_queue_t cosq,
                                 bcm_cosq_control_t type,
                                 int *arg)
{
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    switch(type) {
        /* get ocb only */
        case bcmCosqControlOCBOnly:
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_rate_class_ocb_only_get(unit,port, cosq, arg));
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_arad_cosq_control_multicast_ingress_priority_scheduler_set(int unit, 
                                                                int cosq, 
                                                                int arg)
{

    uint32 soc_sand_rc;
    uint8 enable;
    BCMDNX_INIT_FUNC_DEFS;

    if(!DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    if(arg != BCM_COSQ_HIGH_PRIORITY && arg != BCM_COSQ_LOW_PRIORITY) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter %d"), arg));
    }
    enable = (arg == BCM_COSQ_HIGH_PRIORITY)?TRUE:FALSE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_multicast_priority_map_set,(unit, cosq, enable)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;

}

STATIC int
_bcm_arad_cosq_control_multicast_ingress_priority_scheduler_get(int unit, 
                                                                int cosq, 
                                                                int *arg)
{
    uint32 soc_sand_rc;
    uint8 enable = 0;
    BCMDNX_INIT_FUNC_DEFS; 
    BCMDNX_NULL_CHECK(arg);

    if(!DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_traffic_class_multicast_priority_map_get,(unit, cosq, &enable)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *arg = (enable) ? 
        BCM_COSQ_HIGH_PRIORITY : 
        BCM_COSQ_LOW_PRIORITY;
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;

}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_set(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;

    if (cosq != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: cosq: %d\n"), cosq)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Cosq must be set to 0 in case of Local gport")));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Verify */
                if (arg < 0) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "Invalid arg parameter: negative parameter\n")));
                    rc = BCM_E_PARAM;
                }
                if (arg > DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "Invalid arg parameter: more than max burst\n")));
                    rc = BCM_E_PARAM;
                }
                BCM_IF_ERROR_RETURN(rc);

                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_single_port_max_burst_set,(unit, core, tm_port, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        if(!SOC_IS_ARAD_B1_AND_BELOW(unit)){
            rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_max_credit_empty_port_set,(unit, arg)));
            BCM_SAND_IF_ERR_EXIT(rc);
        } else {
           BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
        }
            break;
        

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tc_set(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, port));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;
                SOC_TMC_EGR_Q_PRIO prio;

                /* Validating device type*/
                if ((type == bcmCosqControlBandwidthBurstMaxEmptyQueue || type == bcmCosqControlBandwidthBurstMaxFlowControlledQueue)
                    &&
                    SOC_IS_ARAD_B1_AND_BELOW(unit)
                    ){
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
                }

                
                rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit, cosq, &prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,prio);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst\n")));
                }

                /* Set Port-TC rate Info */
                switch (type) {
                    case bcmCosqControlBandwidthBurstMax:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_max_burst_set,(unit,core,tm_port,prio,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_empty_queues_set,(unit,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_fc_queues_set, (unit,arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    /* coverity[dead_error_begin:FALSE] */
                    default:
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, Invalid type %d\n"), unit, type));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                }
            }
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }
 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the e2e port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;
                SOC_TMC_TCG_NDX tcg;
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT || arg < 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst %d\n"), arg));                    
                }

                /* Set Port-TC rate Info */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_max_burst_set,(unit, core, tm_port, tcg, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
    case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port; 
                SOC_TMC_TCG_NDX tcg;
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_EGR_OFP_RATE_MAX_BURST_LIMIT || arg < 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst, %d\n") , arg));                    
                }

                /* Set conifguration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_max_burst_set,(unit, core, tm_port, tcg, arg));                      
                BCMDNX_IF_ERR_EXIT(rc);
                
            break;
            }
        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the e2e port tc scheduler 
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tc_set(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int arg)
{
    
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,cosq);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                if (arg > DPP_COSQ_PB_E2E_OFP_RATE_MAX_BURST_LIMIT) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: more than max burst\n"))); 
                }

                /* Set conifguration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_max_burst_set,(unit, core, tm_port, cosq, arg));                 
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;
        case bcmCosqControlPrioritySelect: 
            {
                soc_port_t local_port;
                if ((arg != BCM_COSQ_HIGH_PRIORITY) && (arg != BCM_COSQ_LOW_PRIORITY))
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: need to specific high/low priority \n")));
                }
                local_port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(port);
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_prio_propagation_port_set, (unit, local_port, cosq, arg==BCM_COSQ_HIGH_PRIORITY ? 1:0));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress port pc 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tc_get(int unit,
                                           bcm_gport_t port,
                                           bcm_cos_queue_t cosq,
                                           bcm_cosq_control_t type,
                                           int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
      
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, port));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
        case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
            /* Get burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port; 
                SOC_TMC_EGR_Q_PRIO prio;

                /* Validating device type*/
                if ((type == bcmCosqControlBandwidthBurstMaxEmptyQueue || type == bcmCosqControlBandwidthBurstMaxFlowControlledQueue)
                    &&
                    SOC_IS_ARAD_B1_AND_BELOW(unit)
                    ){
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
                }

                rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,prio);
                BCMDNX_IF_ERR_EXIT(rc);
                
                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Set arg*/
                switch (type) {
                    case bcmCosqControlBandwidthBurstMax:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_port_priority_max_burst_get,(unit,core,tm_port,prio,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_empty_queues_get,(unit,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    case bcmCosqControlBandwidthBurstMaxFlowControlledQueue:
                        rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_port_priority_max_burst_for_fc_queues_get,(unit,(uint32*)arg));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                    /* coverity[dead_error_begin:FALSE] */
                    default:
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, Invalid type %d\n"), unit, type));
                        BCMDNX_IF_ERR_EXIT(rc);
                        break;
                }
            }

            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tc_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TC(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;
                /* Validate gport */
                rc = _bcm_petra_cosq_port_priority_validate(unit,port,cosq);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_port_priority_max_burst_get,(unit, core, tm_port, cosq, (uint32*) arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;
        case bcmCosqControlPrioritySelect: 
            {
                soc_port_t local_port;
                int val = 0;
                local_port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(port);
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_prio_propagation_port_get, (unit, local_port, cosq, &val));
                *arg = (val == 1)? BCM_COSQ_HIGH_PRIORITY:BCM_COSQ_LOW_PRIORITY;
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
STATIC int
_bcm_petra_cosq_control_e2e_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_E2E_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tc"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;
                uint32 tm_port; 
                SOC_TMC_TCG_NDX tcg; 
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_sch_tcg_max_burst_get,(unit, core, tm_port, tcg, (uint32*)arg));                              
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the e2e port tc
 */
STATIC int
_bcm_petra_cosq_control_egress_port_tcg_get(int unit,
                                        bcm_gport_t port,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_control_t type,
                                        int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    if (!BCM_COSQ_GPORT_IS_PORT_TCG(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port parameter 0x%x, function support only port tcg"), unit, type));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core; 
                uint32 tm_port;
                SOC_TMC_TCG_NDX tcg; 
                
                /* Validate gport */
                rc = _bcm_petra_cosq_bcm_cosq_to_tcg(unit,cosq,&tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_port_tcg_validate(unit,port,tcg);
                BCMDNX_IF_ERR_EXIT(rc);

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Get existing configuration */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_egq_tcg_max_burst_get,(unit, core, tm_port, tcg, (uint32*)arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

        default:
            rc = BCM_E_PARAM;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress port scheduler 
 */
STATIC int
_bcm_petra_cosq_control_egress_port_scheduler_get(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int *arg)
{
    bcm_error_t rc = BCM_E_NONE;    

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);
  
    if (cosq != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: cosq: %d\nCosq must be set to 0 in case of Local gport"), cosq));
    }

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Get burst max for egq rate shaper */
            {
                int core;  
                uint32 tm_port;

                rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Verify */
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ofp_rates_single_port_max_burst_get,(unit, core, tm_port,(uint32*)arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            break;

    case bcmCosqControlBandwidthBurstMaxEmptyQueue:
        if (!SOC_IS_ARAD_B1_AND_BELOW(unit)) {
            rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ofp_rates_max_credit_empty_port_get, (unit, arg))); 
                BCM_SAND_IF_ERR_EXIT(rc);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid arg parameter: device is below Arad Plus\n")));
        }
            break;
        

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set various features depnded control type
 * for the egress interface scheduler (father of port)
 */
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_set(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    soc_port_t  local_port;
    bcm_gport_t local_gport;
    soc_port_t  port_i;
    bcm_gport_t gport_i;
    uint32      tm_port;
    soc_pbmp_t  ports_bm;
    int         core, local_mode, mode_i, weight, is_channelized;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL));
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &local_port));
      
    switch(type) {
        case bcmCosqControlSingleCalendarMode:
            BCM_GPORT_LOCAL_SET(local_gport, local_port);

            /* calendar mode is supported only for channelized nif */
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_channelized_port_get(unit, local_port, &is_channelized));
            if (!is_channelized) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Changing calendar mode is allowed only for channelized interfaces")));
            }

            /* changing calendar mode is allowed only when all ports that belong to the NIF are at the same priority */
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_ports_to_same_interface_get(unit, local_port, &ports_bm));
            BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_sched_get(unit, local_gport, 0, &local_mode, &weight));

            SOC_PBMP_ITER(ports_bm, port_i) {
                    BCM_GPORT_LOCAL_SET(gport_i,port_i);
                    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_gport_sched_get(unit, gport_i, 0, &mode_i, &weight));
                    if (local_mode != mode_i) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("Changing calendar mode is allowed only when all ports on the interface are at the same priority")));
                        break;
                    }
            }
            if (arg == 1) {
                /* single calendar per NIF */
                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_single_cal_mode_set(unit, local_port, TRUE));
            } else {
                /* two calendars per nif (low and high priority calendars) */
                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_is_single_cal_mode_set(unit, local_port, FALSE));
            }
            break;

        default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get various features depnded control type
 * for the egress interface scheduler (father of port)
 */
STATIC int
_bcm_petra_cosq_control_egress_interface_scheduler_get(int unit,
                                                 bcm_gport_t port,
                                                 bcm_cos_queue_t cosq,
                                                 bcm_cosq_control_t type,
                                                 int *arg)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;

    switch(type) {
         default:
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid type %d\n"), unit, type));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_fmq_set(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int arg)
{
    bcm_error_t rc = BCM_E_NONE;    
    SOC_TMC_MULT_FABRIC_INFO info;  
    int core, gport_cores;
    
    BCMDNX_INIT_FUNC_DEFS;

    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set max burst */
            {
                /* Validate */
                if (!(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
                      || BCM_COSQ_GPORT_IS_FMQ_ROOT(port)
                      || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port))) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d for this gport(0x%08x) "), unit, type,port));
                }
                if (cosq != 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
                }

                if (arg > DPP_COSQ_FMQ_MAX_BURST_LIMIT || arg < 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid max_burst %d \n"), unit, arg));  
                }

                /* Get cores */
                gport_cores = BCM_GPORT_SCHEDULER_CORE_GET(port);
                SOC_DPP_CORE_VALIDATE(unit, gport_cores, TRUE);

                BCM_DPP_CORES_ITER(gport_cores, core) {

                    /* Get existing configuration */
                    rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, core, &info)));
                    BCMDNX_IF_ERR_EXIT(rc);
                    
                    if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
                        info.guaranteed.gr_shaper.max_burst = arg;
                    } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) { /* Best effort */
                        info.best_effort.be_shaper.max_burst = arg;
                    } else {
                        if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) { /* root */
                            info.max_burst = arg;
                        } else {
                            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Internal error in max burst. Not supposed to come here")));
                        }
                    }

                    /* Set configuration */
                    rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_set,(unit, core, &info)));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
            break;

        default:
            SOCDNX_EXIT_WITH_ERR(BCM_E_PARAM, (_BSL_SOC_MSG("Invalid type %d"), type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_control_fmq_get(int unit,
                                bcm_gport_t port,
                                bcm_cos_queue_t cosq,
                                bcm_cosq_control_t type,
                                int *arg)
{
    bcm_error_t rc = BCM_E_NONE;   
    SOC_TMC_MULT_FABRIC_INFO info;
    int core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(arg);    
    
    switch(type) {
        case bcmCosqControlBandwidthBurstMax:
            /* Set max burst */
            {
                /* Validate */
                if (!(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)
                      || BCM_COSQ_GPORT_IS_FMQ_ROOT(port)
                      || BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port))) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d for this gport(0x%08x) "), unit, type,port));
                }
                if (cosq != 0 ) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d\n"), unit, cosq));
                }

                /* Get core */
                core = BCM_GPORT_SCHEDULER_CORE_GET(port);

                /* Get with BCM_CORE_ALL assumes symetric configuration,
                   in this case use core 0 to get information */
                if(core == BCM_CORE_ALL) {
                    core = 0;
                }

                /* Get existing configuration */
                rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_credit_source_get,(unit, core, &info)));
                BCMDNX_IF_ERR_EXIT(rc);

                if (BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
                    *arg = info.guaranteed.gr_shaper.max_burst;
                } else if (BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT_AGR(port)) {
                    /* Best effort */
                    *arg = info.best_effort.be_shaper.max_burst;
                } else {
                    if (BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) { /* root */
                        *arg = info.max_burst;
                    } else {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Internal error in max burst. Not supposed to come here")));
                    }
                }
            }
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d\n"), type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_ingress_port_set(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int arg)
{
    int rc;
    uint32 flags = 0;
    soc_dpp_port_prd_config_t config;
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlIngressPortDropUntaggedPCP:
            if ((IS_IL_PORT(unit,port) && !SOC_IS_QAX(unit)) || IS_QSGMII_PORT(unit, port) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invallid for this port"), unit ,port));
            }
            config.untagged_pcp = arg;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_prd_config_set,(unit, port, flags, &config)));
            break;
        case bcmCosqControlIngressPortDropTpid1:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_set, (unit, port, flags, 0, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid2:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_set, (unit, port, flags, 1 , arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid3:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_set, (unit, port, flags, 2 , arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid4:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_set, (unit, port, flags, 3 , arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreIpDscp:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_ip_dscp_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreMplsExp:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_mpls_exp_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreInnerTag:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_inner_tag_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgonreOuterTag:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_outer_tag_set, (unit, port, flags, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_ingress_port_get(int unit,
                                   bcm_gport_t port,
                                   bcm_cosq_control_t type,
                                   int *arg)
{
    bcm_error_t           rc = BCM_E_NONE;    
    uint32 flags = 0;
    soc_dpp_port_prd_config_t config;
    BCMDNX_INIT_FUNC_DEFS;
    if ((IS_IL_PORT(unit,port) && !SOC_IS_QAX(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invallid for this port"), unit ,port));
    }
    switch(type) {
        case bcmCosqControlIngressPortDropUntaggedPCP:
            if ((IS_IL_PORT(unit,port) && !SOC_IS_QAX(unit)) || IS_QSGMII_PORT(unit, port) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invallid for this port"), unit ,port));
            }
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_prd_config_get,(unit, port, flags, &config)));
            *arg = config.untagged_pcp;
            break;
        case bcmCosqControlIngressPortDropTpid1:
            rc =  MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_get, (unit, port, flags, 0, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid2:
            rc =  MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_get, (unit, port, flags, 1, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid3:
            rc =  MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_get, (unit, port, flags, 2, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid4:
            rc =  MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_get, (unit, port, flags, 3, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreIpDscp:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_ip_dscp_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreMplsExp:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_mpls_exp_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgnoreInnerTag:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_inner_tag_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropIgonreOuterTag:
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_ignore_outer_tag_get, (unit, port, flags, (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_device_set(int unit,
                                   bcm_gport_t port,
                                   bcm_cos_queue_t cosq,
                                   bcm_cosq_control_t type,
                                   int arg)
{
    bcm_error_t           rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;
    uint32                flags = 0;
    soc_error_t           rv;
    int core_id;
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowSlowRate1:
        case bcmCosqControlFlowSlowRate2:

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_slow_max_rates_set,(unit, (type == bcmCosqControlFlowSlowRate1) ? 1:2 , arg)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in configuring device slow rates (0x%x) soc_sand error 0x%x, error 0x%x\n"), unit, arg, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            break;
        case bcmCosqControlAdmissionTestProfileA:
            {
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;              
                if (SOC_IS_JERICHO(unit) && BCM_COSQ_GPORT_IS_CORE(port)) {
                    core_id = BCM_COSQ_GPORT_CORE_GET(port);
                } else {
                    core_id = BCM_CORE_ALL;
                }

                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_admit_test_tmplt_get, (unit, core_id, SOC_TMC_ITM_ADMIT_TST_00, &info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                info.test_a.ctgry_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CT)) ? 1:0;
                info.test_a.ctgry_trffc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTTC)) ? 1:0;
                info.test_a.ctgry2_3_cnctn_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTCC)) ? 1:0;
                info.test_a.sttstcs_tag_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_ST)) ? 1:0;
                info.test_a.pfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_PFC)) ? 1:0;
                info.test_a.llfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_LLFC)) ? 1:0;

                /* Set new admission test */
                /* For now: assume only admission test 00 is used */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_set,(unit, core_id, SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            }
            break;
        case bcmCosqControlAdmissionTestProfileB:
            {
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;               
                if (SOC_IS_JERICHO(unit) && BCM_COSQ_GPORT_IS_CORE(port)) {
                    core_id = BCM_COSQ_GPORT_CORE_GET(port);
                } else {
                    core_id = BCM_CORE_ALL;
                }
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_get,(unit, core_id, SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                info.test_b.ctgry_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CT)) ? 1:0;
                info.test_b.ctgry_trffc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTTC)) ? 1:0;
                info.test_b.ctgry2_3_cnctn_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_CTCC)) ? 1:0;
                info.test_b.sttstcs_tag_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_ST)) ? 1:0;
                info.test_b.pfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_PFC)) ? 1:0;
                info.test_b.llfc_test_en = ((arg & BCM_COSQ_CONTROL_ADMISSION_LLFC)) ? 1:0;

                /* Set new admission test */
                /* For now: assume only admission test 00 is used */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_set,(unit, core_id, SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
            }            
            break;
        case bcmCosqControlFlowControlEnable:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rv = soc_dpp_dbg_flow_control_enable_set(unit, arg);
            BCMDNX_IF_ERR_EXIT(rv);
            break;
        case bcmCosqControlEgressBandwidthEnable:
            if(arg != 0 && arg != 1)/* i.e. invalid value */
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid set argument %d, should be 0 or 1"), unit, arg));
            }
            rv = soc_dpp_dbg_egress_shaping_enable_set(unit, arg);
            BCMDNX_IF_ERR_EXIT(rv);
            break;
        /* Congestion handling (CNM) */
        case bcmCosqControlCongestionManagedQueueMin:
        case bcmCosqControlCongestionManagedQueueMax:
            rc = _bcm_arad_cosq_control_congestion_queue_range_set(unit, type, arg);
            BCMDNX_IF_ERR_EXIT(rc);
          break;
        case bcmCosqControlMulticastPriorityIngressScheduling:
              rc = _bcm_arad_cosq_control_multicast_ingress_priority_scheduler_set(unit, cosq, arg);
              BCMDNX_IF_ERR_EXIT(rc);
        break;

        case bcmCosqControlDropLimitAlpha: /* enable/disable fair adaptive tail drop */
            if (SOC_IS_QAX(unit)) {
                /* Feature is not supported for QAX. */
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha type is not supported")));
            }
            if (cosq) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha requires a cosq value of zero")));
            }
            BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_fair_adaptive_tail_drop_enable_set, (unit, arg)));
            break;
        case bcmCosqControlPriorityPropagationEnable:
            rc =  MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_prio_propagation_enable_set, (unit, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid1:
        case bcmCosqControlIngressPortDropTpid2:
            if (SOC_IS_JERICHO_PLUS_ONLY(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("port %d is invalid. configuration of TPID is per port."), port));
            }
            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_set, (unit, port, flags,(type == bcmCosqControlIngressPortDropTpid1 ? 0 : 1), arg)); 
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlOcbFadtDropEnable:
            if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                BCMDNX_IF_ERR_EXIT(jer_itm_ocb_fadt_enable_set(unit, arg));
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            }
            break;
        case bcmCosqControlPgVsqFadtFcEnable:
            if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                BCMDNX_IF_ERR_EXIT(jer_itm_vsq_pg_fadt_fc_enable_set(unit, arg));
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            }
            break;
        case bcmCosqControlOcbRangeSelectThreshold:
            if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                BCMDNX_IF_ERR_EXIT(jer_itm_ocb_range_select_set(unit, arg));
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_control_device_get(int unit,
                                   bcm_gport_t port,
                                   bcm_cos_queue_t cosq,
                                   bcm_cosq_control_t type,
                                   int *arg)
{
    bcm_error_t           rc = BCM_E_NONE;
    uint32                flags = 0, soc_sand_rc = 0;
    soc_error_t           rv;
    int                   core_id;
    SOC_TMC_SCH_SLOW_RATE   slow_max_rates;
    
    BCMDNX_INIT_FUNC_DEFS;
    switch(type) {
        case bcmCosqControlFlowSlowRate1:
        case bcmCosqControlFlowSlowRate2:
            SOC_TMC_SCH_SLOW_RATE_clear(&slow_max_rates);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_slow_max_rates_get,(unit, (type == bcmCosqControlFlowSlowRate1)? 1:2 , arg)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving device slow rates soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            break;
        case bcmCosqControlAdmissionTestProfileA:
        case bcmCosqControlAdmissionTestProfileB:
            {
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO info;
                if (SOC_IS_JERICHO(unit) && BCM_COSQ_GPORT_IS_CORE(port)) {
                    core_id = BCM_COSQ_GPORT_CORE_GET(port);
                } else {
                    core_id = BCM_CORE_ALL;
                }
                
                SOC_TMC_ITM_ADMIT_TEST_TMPLT_INFO_clear(&info);

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_admit_test_tmplt_get,(unit, core_id, SOC_TMC_ITM_ADMIT_TST_00,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                *arg = 0;
                if (type == bcmCosqControlAdmissionTestProfileA)
                {
                  DPP_COSQ_ADMISSION_TEST_ADD(*arg,info.test_a);
                } else {
                  DPP_COSQ_ADMISSION_TEST_ADD(*arg,info.test_b);
                }                             
            }
            break;
        case bcmCosqControlFlowControlEnable:
            {   
                uint8   enable;
                rv = soc_dpp_dbg_flow_control_enable_get(unit, &enable);
                BCMDNX_IF_ERR_EXIT(rv);
                *arg = enable ? 1 : 0;
            }
            break;
        case bcmCosqControlEgressBandwidthEnable:
            {
                uint8   enable;
                rv = soc_dpp_dbg_egress_shaping_enable_get(unit, &enable);
                BCMDNX_IF_ERR_EXIT(rv);
                *arg = enable ? 1: 0;
            }
            break;  
        /* Congestion handling (CNM) */
        case bcmCosqControlCongestionManagedQueueMin:
        case bcmCosqControlCongestionManagedQueueMax:
          rc = _bcm_arad_cosq_control_congestion_queue_range_get(unit, type, arg);
          BCMDNX_IF_ERR_EXIT(rc);
          break;
        case bcmCosqControlMulticastPriorityIngressScheduling:
          rc = _bcm_arad_cosq_control_multicast_ingress_priority_scheduler_get(unit, cosq, arg);
          BCMDNX_IF_ERR_EXIT(rc);
          break;

        case bcmCosqControlDropLimitAlpha: /* check if fair adaptive tail drop is enabled */
            if (SOC_IS_QAX(unit)) {
                /* Feature is not supported for QAX. */
                BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha type is not supported")));
            }
            if (cosq) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("bcmCosqControlDropLimitAlpha requires a cosq value of zero")));
            } else {
                uint8 enabled = 0;
                BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_fair_adaptive_tail_drop_enable_get, (unit, &enabled)));
                *arg = enabled;
            }
            break;
        case bcmCosqControlPriorityPropagationEnable:
            rc =  MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_prio_propagation_enable_get, (unit, arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlIngressPortDropTpid1:
        case bcmCosqControlIngressPortDropTpid2:
            if (SOC_IS_JERICHO_PLUS_ONLY(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("port %d is invalid. configuration of TPID is per port."), port));
            }
            rc =  MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_tpid_get, (unit, port, flags, (type == bcmCosqControlIngressPortDropTpid1 ? 0 : 1), (uint32*)arg));
            BCMDNX_IF_ERR_EXIT(rc);
            break;
        case bcmCosqControlOcbFadtDropEnable:
            if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                BCMDNX_IF_ERR_EXIT(jer_itm_ocb_fadt_enable_get(unit, arg));
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            }
            break;
        case bcmCosqControlPgVsqFadtFcEnable:
            if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                BCMDNX_IF_ERR_EXIT(jer_itm_vsq_pg_fadt_fc_enable_get(unit, arg));
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            }
            break;
        case bcmCosqControlOcbRangeSelectThreshold:
            if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
                BCMDNX_IF_ERR_EXIT(jer_itm_ocb_range_select_get(unit, (uint32*)arg));
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid type %d"), type));
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set system port cosq control
 */
STATIC int
_bcm_petra_cosq_control_system_port_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg)
{
    bcm_error_t rc = BCM_E_NONE;       
    int base_qid, qid;
    int core = BCM_CORE_ALL;
    uint8 valid;
    uint8 sw_only; 
    uint32 base_qid_temp;

    BCMDNX_INIT_FUNC_DEFS;
 
    SOC_DPP_CORES_ITER(BCM_CORE_ALL, core)
    {
        /* obtaining queue from system port */
        rc = arad_sw_db_sysport2queue_get(unit, core, BCM_GPORT_SYSTEM_PORT_ID_GET(port), &valid, &sw_only, &base_qid_temp);
        BCMDNX_IF_ERR_EXIT(rc);
        
        if (valid != TRUE)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, system port %d have no valid queue"), unit, port));
        }
        base_qid = base_qid_temp;
        qid = base_qid + cosq;

        switch(type) {
            case bcmCosqControlDefaultInvalidQueue:
            {
                if (qid >= SOC_DPP_DEFS_GET(unit, nof_queues_per_pipe)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid queue id %d"), unit, qid));
                }

                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_default_invalid_queue_set, (unit, core, qid, arg));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;
            
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
        }


    }
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: retrieve system port cosq control
 */
STATIC int
_bcm_petra_cosq_control_system_port_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 base_qid, qid = 0;
    int core = BCM_CORE_ALL;
    uint8 valid;
    uint8 sw_only; 
    uint32 base_qid_temp;


    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    SOC_DPP_CORES_ITER(BCM_CORE_ALL, core)
    {

        /* obtaining queue from system port */
        rc =arad_sw_db_sysport2queue_get(unit, core, BCM_GPORT_SYSTEM_PORT_ID_GET(port), &valid, &sw_only, &base_qid_temp);
        BCMDNX_IF_ERR_EXIT(rc);
        if (valid != TRUE)
        {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, system port %d have no valid queue"), unit, port));
        }

        base_qid = base_qid_temp;
        qid = base_qid + cosq;
        
        switch(type) {
            case bcmCosqControlDefaultInvalidQueue:
            {
               
                rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_default_invalid_queue_get,(unit, core, &qid, arg));
                BCMDNX_IF_ERR_EXIT(rc);

            }
            break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
        }

    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set ingress queue control
 */
STATIC int
_bcm_petra_cosq_control_ingress_queue_set(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;        
    int base_qid, qid;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;
    uint32    soc_sand_dev_id;
    int       cnm_queue_base;
    int       cpq_index;
    ARAD_CNM_CPQ_INFO cpq_info;
    bcm_cosq_qcn_config_t qcn_config;

    BCMDNX_INIT_FUNC_DEFS;
    
    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);

    /* Validate Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)){
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_COSQ_GPORT_IS_ISQ(port) && (type == bcmCosqControlPacketLengthAdjust)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(port);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected port type, 0x%x, and control type, 0x%x"), port, type));
    }

    if (!(type == bcmCosqControlDefaultInvalidQueue && arg == 0)) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, base_qid, &sw_state_num_cos));

        if (sw_state_num_cos <= 0) {      
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"), unit, base_qid, sw_state_num_cos));
        }

        if (cosq < 0 || cosq >= sw_state_num_cos) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter"), unit, cosq));     
        }
    }

    qid = base_qid + cosq;

    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Set Packet length */
            {
                SOC_TMC_ITM_CR_DISCOUNT_INFO discount_data;
                int new_discount_cls, is_allocated, old_discount_cls;
                
                SOC_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_data);
                if (SOC_TMC_ITM_COMPENSATION_LEGACY_MODE(unit)) {
                    bcm_cosq_pkt_size_adjust_info_t adjust_info; 

                    adjust_info.source_info.source_type = bcmCosqPktSizeAdjustSourceScheduler;
                    adjust_info.source_info.source_id = 0;

                    adjust_info.gport = port;
                    adjust_info.cosq = cosq;
                    adjust_info.flags = 0;
                    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_set(unit, &adjust_info, arg));
                } else {
                    /* in wide PDM mode with compensation tag there is a new mechanism for scheduler compensation */             
                    if (SOC_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit))
                    {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, scheduler compensation has a new mechanism"), unit));
                    }
                    
                    if (arg < DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL || arg > DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument discount %d parameter"), unit, arg));    
                    }

                    /* Get old data */
                    
                    /* Set data configuration */
                    discount_data.discount = arg;
                    
                    /* Exchange SW Data */
                    rc = _bcm_dpp_am_template_queue_discount_cls_exchange(unit, 0 , qid,&discount_data,&old_discount_cls,NULL,&new_discount_cls,&is_allocated);
                    BCMDNX_IF_ERR_EXIT(rc);
                    
                    if (is_allocated) {
                   /* Set new profile data */
                        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_cr_discount_set,(unit,new_discount_cls,&discount_data)));
                        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                   
                    }
                    
                    /* Set new mapping */
                    rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,qid,BCM_DPP_COSQ_DISCOUNT_CLS,new_discount_cls);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
            break;
        case bcmCosqControlHeaderUpdateField:
            {
                if (SOC_IS_QAX(unit)) {
                    /* Feature is not supported for QAX. */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("bcmCosqControlHeaderUpdateField type is not supported")));
                }
                
                if (arg < 0 || arg > SOC_TMC_MAX_SIGNATURE) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument signature %d parameter"), unit, arg));    
                }

                rc = _bcm_petra_cosq_voq_class_mapping_set(unit,core,qid,BCM_DPP_COSQ_QUEUE_SIGNATURE,arg);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            break;

        /* Handle CNM - Congestion Managed Queues */
        case bcmCosqControlCongestionManagedQueue:
          rc = _bcm_petra_cosq_control_device_get(unit, BCM_CORE_ALL, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
          BCMDNX_IF_ERR_EXIT(rc);

          cpq_index = qid - cnm_queue_base;

          soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

          cpq_info.is_cp_enabled = arg;

          soc_sand_rc = arad_cnm_cpq_set(soc_sand_dev_id, cpq_index, &cpq_info);
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
          break;

        case bcmCosqControlCongestionThresholdRandom:
        case bcmCosqControlCongestionFeedbackMax:
        case bcmCosqControlCongestionFeedbackWeight:
        case bcmCosqControlCongestionSetPoint:
            rc = bcm_arad_cosq_qcn_config_get(unit, port, cosq, 0 /* no flags */, &qcn_config);
            BCMDNX_IF_ERR_EXIT(rc);

            switch(type) {
              case bcmCosqControlCongestionThresholdRandom:
                qcn_config.randomize_sample_threshold = arg;
                break;
              case bcmCosqControlCongestionFeedbackMax:
                qcn_config.max_feedback = arg;
                break;
              case bcmCosqControlCongestionFeedbackWeight:
                qcn_config.weight = arg;
                break;
              case bcmCosqControlCongestionSetPoint:
                qcn_config.size = arg;
                break;
              /* Must default. Otherwise, compilation error */
              /* coverity[dead_error_begin : FALSE]*/
              default:
                break;
            }

            rc = bcm_arad_cosq_qcn_config_set(unit, port, cosq, 0 /* no flags */, &qcn_config);
            BCMDNX_IF_ERR_EXIT(rc);
          break;
        case bcmCosqControlDefaultInvalidQueue:
        {
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
            } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport type %d"), unit, port));
            }

            if (qid >= SOC_DPP_DEFS_GET(unit, nof_queues_per_pipe)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid queue id %d"), unit, qid));
            }

            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_default_invalid_queue_set, (unit, core, qid, arg));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        break;
    case bcmCosqControlOCBOnly:
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_rate_class_ocb_only_set(unit, port, cosq, arg));
        break;
    case bcmCosqControlFlush:
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_flush_set(unit, port, cosq, arg));
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: retrieve ingress queue control
 */
STATIC int
_bcm_petra_cosq_control_ingress_queue_get(int unit,
                                          bcm_gport_t port,
                                          bcm_cos_queue_t cosq,
                                          bcm_cosq_control_t type,
                                          int *arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 base_qid, qid = 0;
    uint32 soc_sand_rc;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;
    uint32    soc_sand_dev_id;
    int       cnm_queue_base;
    int       cpq_index;
    ARAD_CNM_CPQ_INFO cpq_info;
    bcm_cosq_qcn_config_t qcn_config;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    soc_sand_dev_id = (unit);
    SOC_TMC_CNM_CPQ_INFO_clear(&cpq_info);

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)){
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
    } else if (BCM_COSQ_GPORT_IS_ISQ(port) && (type == bcmCosqControlPacketLengthAdjust)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(port);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected port type, 0x%x, and control type, 0x%x"), port, type));
    }

    if (type != bcmCosqControlDefaultInvalidQueue) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_qid), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"), unit, base_qid, sw_state_num_cos));     
        }

        if (cosq < 0 || cosq >= sw_state_num_cos) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter"), unit, cosq));     
        } 
    }

    qid = base_qid + cosq;
    
    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Get Packet length */
            {
                SOC_TMC_ITM_CR_DISCOUNT_INFO discount_data;
                
                if (SOC_TMC_ITM_COMPENSATION_LEGACY_MODE(unit)) {
                    bcm_cosq_pkt_size_adjust_info_t adjust_info; 

                    adjust_info.source_info.source_type = bcmCosqPktSizeAdjustSourceScheduler;
                    adjust_info.source_info.source_id = 0;

                    adjust_info.gport = port;
                    adjust_info.cosq = cosq;
                    adjust_info.flags = 0;
                    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_get(unit, &adjust_info, arg));
                } else {
                    /* in wide PDM mode with compensation tag there is a new mechanism for scheduler compensation */             
                    if (SOC_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit)) 
                    {
                        *arg = 0;
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, scheduler compensation has a new mechanism"), unit));
                    }

                    /* Get old data */
                    rc = _bcm_dpp_am_template_queue_discount_cls_data_get(unit,0,qid,&discount_data);
                    BCMDNX_IF_ERR_EXIT(rc);
                    
                    *arg = discount_data.discount;
                }
            }
            break;
        case bcmCosqControlHeaderUpdateField:
            {
                SOC_TMC_ITM_QUEUE_INFO info;

                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit,core,qid,&info)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
/*
 * COVERITY
 *
 * The variable info is assigned inside MBCM_DPP_DRIVER_CALL.
 */
/* coverity[uninit_use : FALSE] */
                *arg = info.signature;
            }
            break;
        /* Handle CNM - Congestion Managed Queues */
        case bcmCosqControlCongestionManagedQueue:
              rc = _bcm_petra_cosq_control_device_get(unit, BCM_CORE_ALL, 0, bcmCosqControlCongestionManagedQueueMin, &cnm_queue_base);
            BCMDNX_IF_ERR_EXIT(rc);

            cpq_index = qid - cnm_queue_base;

            soc_sand_rc = arad_cnm_cpq_get(soc_sand_dev_id, cpq_index, &cpq_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            *arg = cpq_info.is_cp_enabled;
          break;

        case bcmCosqControlCongestionThresholdRandom:
        case bcmCosqControlCongestionFeedbackMax:
        case bcmCosqControlCongestionFeedbackWeight:
        case bcmCosqControlCongestionSetPoint:
            rc = bcm_arad_cosq_qcn_config_get(unit, port, cosq, 0 /* no flags */, &qcn_config);
            BCMDNX_IF_ERR_EXIT(rc);

            switch(type) {
              case bcmCosqControlCongestionThresholdRandom:
                *arg = qcn_config.randomize_sample_threshold;
                break;
              case bcmCosqControlCongestionFeedbackMax:
                *arg = qcn_config.max_feedback;
                break;
              case bcmCosqControlCongestionFeedbackWeight:
                *arg = qcn_config.weight;
                break;
              case bcmCosqControlCongestionSetPoint:
                *arg = qcn_config.size;
                break;
              /* Must default. Otherwise, compilation error */
              /* coverity[dead_error_begin : FALSE]*/
              default:
                break;
            }
          break;
        case bcmCosqControlDefaultInvalidQueue:
        {
            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
            } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
                core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport type %d"), unit, port));
            }

            rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_default_invalid_queue_get,(unit, core, &qid, arg));
            BCMDNX_IF_ERR_EXIT(rc);

            if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(port)) {
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(port, core, qid);
            } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) {
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(port, core, qid);
            }
        }
        break;
        case bcmCosqControlOCBOnly:
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_rate_class_ocb_only_get(unit, port, cosq, arg));
            break;
        case bcmCosqControlFlush:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("bcmCosqControlFlush is only supported in 'set' context")));
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: COSQ control settings for egress queues gport 
 */
STATIC int
_bcm_petra_cosq_control_egress_queue_set(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int arg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32      soc_sand_rc = 0, tm_port = 0;        
    int         core;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Set Packet length */
            {                

                SOC_TMC_PORT_HEADER_TYPE header_type = 0, header_type_incoming;
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_TYPE cr_discnt_type_ndx = 0, discount_type = 0;
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO discount_data, discount_data_complement;
                int new_discount_cls, is_allocated, old_discount_cls, discount_profile_complement;
                uint32 ref_count_complement;
                
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data);
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data_complement);

                if (cosq != -1 && cosq != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter, should be general -1 or 0 cosq. This type is per port "), unit, cosq));     
                }

                if (arg < DPP_COSQ_EGRESS_CR_DISCOUNT_MIN_VAL || arg > DPP_COSQ_EGRESS_CR_DISCOUNT_MAX_VAL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid argument discount %d parameter"), unit, arg));    
                }

                /* Get old data */
                rc = _bcm_dpp_am_template_egress_port_discount_cls_data_get(unit, core, tm_port, &discount_data);
                BCMDNX_IF_ERR_EXIT(rc);
                
                /* Set data configuration */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port))
                {
                    discount_data.uc_credit_discount = arg;
                }
                else
                {
                    discount_data.mc_credit_discount = arg;
                }
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_egr_hdr_credit_discount_select_get,(unit, core, tm_port,&discount_type)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc); 

                discount_profile_complement = (discount_type == 0) ? 1 : 0;
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_header_type_get,(unit, core, tm_port, &header_type_incoming, &header_type)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc); 

                rc = _bcm_dpp_am_template_egress_port_discount_cls_per_header_type_ref_get(unit, core, discount_profile_complement, header_type, &ref_count_complement);
                BCMDNX_IF_ERR_EXIT(rc);

                if(ref_count_complement != 0) 
                {
                    rc = _bcm_dpp_am_template_egress_port_discount_cls_per_header_type_tdata_get(unit, core, discount_profile_complement, header_type, &discount_data_complement);
                    BCMDNX_IF_ERR_EXIT(rc);
                    if(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port) && discount_data.uc_credit_discount == discount_data_complement.uc_credit_discount) 
                    {
                        discount_data.mc_credit_discount = discount_data_complement.mc_credit_discount;
                    } 
                    else if(BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(port) && discount_data.mc_credit_discount == discount_data_complement.mc_credit_discount)
                    {
                        discount_data.uc_credit_discount = discount_data_complement.uc_credit_discount;
                    }
                }
                /* Exchange SW Data */
                rc = _bcm_dpp_am_template_egress_port_discount_cls_exchange(unit, core, tm_port,&discount_data,&old_discount_cls,NULL,&new_discount_cls,&is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                cr_discnt_type_ndx = new_discount_cls;

                if (is_allocated) {
                   soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_header_type_get,(unit,core,tm_port,&header_type_incoming,&header_type)));
                   BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                   /* Set new profile data, data is being set from header type and discount type */                   
                   soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_egr_hdr_credit_discount_type_set,(unit,core,header_type,cr_discnt_type_ndx,&discount_data)));
                   BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                                                 
                }                

                /* Set new mapping port to discount type */
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_port_egr_hdr_credit_discount_select_set,(unit,core,tm_port,cr_discnt_type_ndx)));
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);          

            }
            break;      
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:

    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: COSQ control settings for egress queues gport 
 */
STATIC int
_bcm_petra_cosq_control_egress_queue_get(int unit,
                                         bcm_gport_t port,
                                         bcm_cos_queue_t cosq,
                                         bcm_cosq_control_t type,
                                         int *arg)
{
    bcm_error_t rc = BCM_E_NONE;      
    int         core;
    uint32      tm_port = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(arg);

    rc = _bcm_petra_cosq_fap_port_get(unit, port, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);
    
    switch(type) {
        case bcmCosqControlPacketLengthAdjust:
            /* Get Packet length */
            {
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO discount_data;                
                
                SOC_TMC_PORT_EGR_HDR_CR_DISCOUNT_INFO_clear(&discount_data);

                if (cosq != -1 && cosq != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid cosq %d parameter, should be general -1 or 0 cosq. This type is per port "), unit, cosq));     
                }

                /* Get old data */
                rc = _bcm_dpp_am_template_egress_port_discount_cls_data_get(unit, core, tm_port, &discount_data);
                BCMDNX_IF_ERR_EXIT(rc);
                                            
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(port))
                {
                    *arg = discount_data.uc_credit_discount;
                }
                else
                {
                    *arg = discount_data.mc_credit_discount;                    
                }                  
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid type %d"), unit, type));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_profile_mapping_get(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
    bcm_error_t rv = BCM_E_NONE;
    int qid, base_queue, profile_id;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(profile_mapping);
    switch(profile_mapping->profile_type) {
    case bcmCosqIngressQueueToRateClass:
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_COSQ_GPORT_IS_ISQ(gport_to_map)) {
            base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport_to_map);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_to_map);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport_to_map));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));

        if (sw_state_num_cos <= 0) {      
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"),
                         unit, base_queue, sw_state_num_cos));
        }
        if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
        }
        qid = base_queue + cosq;
        rv = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &profile_id);
        BCMDNX_IF_ERR_EXIT(rv);
        BCM_GPORT_PROFILE_SET(profile_mapping->mapped_profile, profile_id);
        break;
    case bcmCosqIngressQueuesToLatencyProfile:
    case bcmCosqPortToEndToEndLatencyProfile:
        break;
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_profile_mapping_set(
    int unit, 
    bcm_gport_t gport_to_map, 
    bcm_cos_queue_t cosq, 
    uint32 flags, 
    bcm_switch_profile_mapping_t *profile_mapping)
{
    bcm_error_t rv = BCM_E_NONE;
    int base_queue, qid, profile_id;
    int core = BCM_CORE_ALL;
    uint8 sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(profile_mapping);
    if (BCM_GPORT_IS_PROFILE(profile_mapping->mapped_profile)){
        profile_id = BCM_GPORT_PROFILE_GET(profile_mapping->mapped_profile);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of mapped profile must be BCM_GPORT_PROFILE_TYPE. gport %d is not supported."), profile_mapping->mapped_profile));
    }
    switch(profile_mapping->profile_type) {
    case bcmCosqIngressQueueToRateClass:
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport_to_map)) {
            base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport_to_map);
            core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport_to_map);
        } else if (BCM_COSQ_GPORT_IS_ISQ(gport_to_map)) {
            base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(gport_to_map);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport_to_map);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport_to_map));
        }

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core , base_queue), &sw_state_num_cos));

        if (sw_state_num_cos <= 0) {      
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) voq(%d) invalid cos %d"),
                         unit, base_queue, sw_state_num_cos));
        }
        if ((cosq < 0) || (cosq >= sw_state_num_cos)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, cosq));
        }
        qid = base_queue + cosq;

        rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set(unit,core,qid,profile_id);
        BCMDNX_IF_ERR_EXIT(rv);
        break;
    case bcmCosqIngressQueuesToLatencyProfile:
    case bcmCosqPortToEndToEndLatencyProfile:
        break;
    }
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: 
 * Verify that mapping queues from a rate class with attributes as in data_rate_class_old, 
 * to a rate class with attributes as in data_rate_class_new is legal. 
 * number of queues to be mapped is nof_queues_mapped
 * 
 * Note: Actually the only constrains we have is validating for the tail drop resources  
 */
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(int unit,
                                                               int core,
                                                               uint8 is_ocb_only,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_old,
                                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_new,
                                                               int nof_queues_mapped, 
                                                               int32 reservation_change[][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES])
{
    bcm_error_t rv = BCM_E_NONE;
    int32 old_guaranteed = 0, new_guaranteed = 0;
    soc_dpp_guaranteed_q_resource_t guaranteed_q_resource;  /* legacy -- used for Jericho and earlier */
    SOC_TMC_ITM_GUARANTEED_RESOURCE guaranteed_resources; /* used for QAX and later */
    soc_dpp_guaranteed_pair_t *guaranteed_pair;
    int core_index;
    int thresh_type, thresh_type_begin, thresh_type_end;

    BCMDNX_INIT_FUNC_DEFS;
    /* 
     *  calculte: for tail drop in bds and byts:
     *  (unused guaranteed size) + old_rate_class.min_size - new_rate_class.min_size <
     *  (used guaranteed size / 50)
     */
    if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != SOC_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core ID %d out of range\n"), core));
    }
    if (nof_queues_mapped < 0){
        /*Illegal nof_queues_mapped*/
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number of queues mapped(%d) into rate class"), unit, nof_queues_mapped));
    }

    if (!SOC_IS_QAX(unit) || !is_ocb_only) {
        /* do nothing for is_ocb_only=TRUE on QAX */

        if (SOC_IS_QAX(unit)) {
            thresh_type_begin = 0;
            thresh_type_end = DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES;
        } else {
            thresh_type_begin = 0;
            thresh_type_end = 1;
        }
        
        
        for (thresh_type = thresh_type_begin; thresh_type < thresh_type_end; thresh_type++) {
            BCM_DPP_CORES_ITER(core, core_index) {
                if (SOC_IS_QAX(unit)) {

                    int scale;

                    /*
                     * All thresholds in BCM layer are managed in user units, 
                     * including Rate Class thresholds.
                     * Managing total guaranteed in QAX is done in SOC units (words vs. bytes)
                     * unlike other thresholds.
                     * This is done to allow signed calculation on total Bytes/words.
                     * QAX has 3G Bytes total memory. This number does not allow 
                     * doing signed arithmetics in 32 bit.
                     * Working in SOC units takes us to 3G/16=192M words, 
                     * and this number is small enough for signed arithmetics.
 */
                    
                    BCMDNX_IF_ERR_EXIT(soc_tmc_itm_voq_threshold_resolution_get(unit, thresh_type, &scale));

                    rv = sw_state_access[unit].dpp.soc.qax.tm.guaranteed_info.get(unit, core_index, &guaranteed_resources);
                    BCMDNX_IF_ERR_EXIT(rv);
                    
                    guaranteed_pair = &guaranteed_resources.guaranteed[thresh_type];
                    
                    old_guaranteed = data_rate_class_old->queue_quaranteed_size[thresh_type];
                    new_guaranteed = data_rate_class_new->queue_quaranteed_size[thresh_type];

                    /*
                     * Important: queue_quaranteed_size might represent negative number (but it is of type uint32).
                     * We can not do arithmetic on queue_quaranteed_size without assigning it to signed variable.
                     */
                    old_guaranteed /= scale;
                    new_guaranteed /= scale;
                } else {
                    /* Jericho and earlier */
                    rv = sw_state_access[unit].dpp.soc.arad.tm.guaranteed_q_resource.get(unit, core_index, &guaranteed_q_resource);
                    BCMDNX_IF_ERR_EXIT(rv);
                    guaranteed_pair = is_ocb_only ? &guaranteed_q_resource.ocb : &guaranteed_q_resource.dram;
                    
                    if (SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode == SOC_DPP_GUARANTEED_Q_RESOURCE_MEMORY) {
                        old_guaranteed = data_rate_class_old->queue_quaranteed_size[DPP_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];
                        new_guaranteed = data_rate_class_new->queue_quaranteed_size[DPP_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];
                    } else if (SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode == SOC_DPP_GUARANTEED_Q_RESOURCE_BDS){
                        old_guaranteed = data_rate_class_old->queue_min_size_bds;
                        new_guaranteed = data_rate_class_new->queue_min_size_bds;
                    } else {
                        /*Illegal guaranteed_q_mode*/
                        BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("unit %d, Invalid guaranteed queue mode 0x%x"), unit, SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode));
                    }
                }
                reservation_change[core_index][thresh_type] = (new_guaranteed - old_guaranteed) * nof_queues_mapped;
                
                if (((int32)(guaranteed_pair->total - (guaranteed_pair->used))) - reservation_change[core_index][thresh_type] < guaranteed_pair->used / 50) { 
                    /* This check can be later changed to verify against a configurable threshold */
                    BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Ran out of resource to reserve/guarantee for queue")));
                }
                if (reservation_change[core_index][thresh_type] > 0) {
                    int32 resource_left_calc =  ((int32)(guaranteed_pair->total -
                                                         (guaranteed_pair->used))) - reservation_change[core_index][thresh_type] ;
                    if (resource_left_calc < 0) { 
                        /* check if we are out of the resource */
                        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Ran out of resource to reserve/guarantee for queue")));
                    }
                }
            }
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: Remapp an ingres queue to a rate class directly.
 * stages: 
 * 1. Validate that remapping the queue is legal for all dependent features. (taildrop) 
 * 2. Update SW state: template maneger
 * 3. Update HW: remp queue (qid)
 */
STATIC int
_bcm_petra_cosq_gport_ingress_queue_mapping_profile_set(int unit,
                                                        int core, 
                                                        int qid,
                                                        int rate_class)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class_new, data_rate_class_old;
    int old_rate_class;
    int32 reservation_change[SOC_DPP_DEFS_MAX(NOF_CORES)][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    uint8 is_ocb_only;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&data_rate_class_new, 0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&data_rate_class_old, 0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
    }
     rv = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
     BCMDNX_IF_ERR_EXIT(rv);

     /* 1. Validate that remapping the queue is legal for all dependent features. */
     /* 1.1 Get old and new rate class attributes. */
     rv = _bcm_petra_cosq_voq_class_mapping_get(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, &old_rate_class);
     BCMDNX_IF_ERR_EXIT(rv);
     if (old_rate_class != rate_class) {

         rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit, old_rate_class, &data_rate_class_old);
         BCMDNX_IF_ERR_EXIT(rv);

         rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &data_rate_class_new);
         BCMDNX_IF_ERR_EXIT(rv);
      
         rv = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_queue_is_ocb_only_get, (unit, core, qid, &is_ocb_only)); 
         BCMDNX_IF_ERR_EXIT(rv);

         /*1.2 Validate that expected tail drop configuration is legal, and get the expected tail drop reservation change */
         rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, is_ocb_only, &data_rate_class_old, &data_rate_class_new, 1, reservation_change);
         BCMDNX_IF_ERR_EXIT(rv);
         
         /* 
          * 3. Update HW, Update SW state, map queue to new rate class 
          */
         /* update mapping:*/
         rv = _bcm_petra_cosq_voq_class_mapping_set(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, rate_class);
         BCMDNX_IF_ERR_EXIT(rv);
         /* update tail drop reservation */
         BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, core, is_ocb_only, reservation_change))); 
     }
exit:
    BCMDNX_FUNC_RETURN;

}
/* 
 * Purpose: Set mapping between voq and rate class
 */ 
STATIC int
_bcm_petra_cosq_voq_class_mapping_set(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int profile)
{
    uint32                soc_sand_rc = 0;    
    SOC_TMC_ITM_QUEUE_INFO info, info_original;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_QUEUE_INFO_clear(&info);    

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, voq, &info))); 
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    sal_memcpy(&info_original, &info, sizeof(SOC_TMC_ITM_QUEUE_INFO));
    switch(profile_type) {
        case BCM_DPP_COSQ_RATE_CLS:
            info.rate_cls = profile;
            break;
        case BCM_DPP_COSQ_DISCOUNT_CLS:
            info.credit_cls = profile;
            break;
        case BCM_DPP_COSQ_VSQ_CC:
            info.vsq_connection_cls = profile;
            break;
        case BCM_DPP_COSQ_VSQ_TC:
            info.vsq_traffic_cls = profile;
            break;
      case BCM_DPP_COSQ_QUEUE_SIGNATURE:
            info.signature = profile;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid profile type (0x%x)"), unit, profile_type));
    }    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit, core, voq, &info_original, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Get mapping between voq and rate class
 */ 
STATIC int
_bcm_petra_cosq_voq_class_mapping_get(int unit,
                                      int core,
                                      int voq,
                                      bcm_dpp_cosq_queue_profile_type_t profile_type,
                                      int* profile)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32                soc_sand_rc = 0;    
    SOC_TMC_ITM_QUEUE_INFO info;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_ITM_QUEUE_INFO_clear(&info);    

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit,core,voq,&info)));
    SOC_SAND_IF_ERR_EXIT(soc_sand_rc);

    switch(profile_type) {
        case BCM_DPP_COSQ_RATE_CLS:
            *profile = info.rate_cls;
            break;
        case BCM_DPP_COSQ_DISCOUNT_CLS:
            *profile = info.credit_cls;
            break;
        case BCM_DPP_COSQ_VSQ_CC:
            *profile = info.vsq_connection_cls;
            break;
        case BCM_DPP_COSQ_VSQ_TC:
            *profile = info.vsq_traffic_cls;
            break;
      case BCM_DPP_COSQ_QUEUE_SIGNATURE:
            *profile = info.signature;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid profile type (0x%x)"), unit, profile_type));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int _bcm_petra_cosq_dram_bounds_default_set(int unit, SOC_TMC_ITM_DRAM_BOUND_INFO* dram_bound_info)
{
    uint32 dram_bound_buffer_factor =  3;
    uint32 dram_recovery_failure_dividor = 2; /* divide by 2 --  0.5 */
    uint32 min_free_buffer = 1000*256;
    uint32 min_free_pd =  1000;
    uint32 dram_recovery_multiplier =  4;
    uint32 min_packet_size =  64; /* in bytes */
    uint32 q_on_threshold = 38 * 1024; /* in bytes -- for 100G port */
    uint32 bundle_size = 4 *1024; /* in bytes */

    SOC_TMC_ITM_DRAM_BOUND_THRESHOLD* dram_threshold;

    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_DPP_CONFIG(unit)->arad->init.fabric.connect_mode == SOC_TMC_FABRIC_CONNECT_MODE_SINGLE_FAP) {
            q_on_threshold = q_on_threshold/5; /* for single fap device only */
    }
    
    /*      DRAM bound FADT Buffers */
    dram_threshold = SOC_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info, SOC_TMC_INGRESS_DRAM_BOUND, SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES);

    dram_threshold->free_max_threshold = 16 * 1024 * 256 / 4 ; /* 16K * 0.25 */
    dram_threshold->free_min_threshold = min_free_buffer; 
    dram_threshold->min_threshold = bundle_size;
    dram_threshold->max_threshold = SOC_SAND_MAX(dram_bound_buffer_factor * q_on_threshold, 2*dram_threshold->min_threshold); 
    dram_threshold->alpha = -5; /* Alpha DP  -- Approximate a line to Max threshold -- Log(Max_Threshold/Max_Free) */
    
    /* DRAM bound FADT PD */
    dram_threshold = SOC_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info, SOC_TMC_INGRESS_DRAM_BOUND, SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS);

    dram_threshold->free_max_threshold = 32 * 1024 / 4; /* 32K x 0.25 */
    dram_threshold->free_min_threshold =  min_free_pd;
    dram_threshold->min_threshold = bundle_size / min_packet_size; 
    dram_threshold->max_threshold = SOC_SAND_MAX(dram_bound_buffer_factor * q_on_threshold / min_packet_size, 2*dram_threshold->min_threshold);
    /* Alpha DP --  Approximate a line to Max threshold -- Log(Max-Threshold/Max-Free) */
    dram_threshold->alpha = -4;


    /*      Recovery Failure  FADT  Buffers */
    dram_threshold = SOC_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info,
                                                            SOC_TMC_INGRESS_DRAM_BOUND_RECOVERY_FAILURE, SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES);

    dram_threshold->free_max_threshold = 16 * 1024 * 256 / 2; /* 16K * 0.5 */
    dram_threshold->free_min_threshold = SOC_SAND_MIN( min_free_buffer * 2, dram_threshold->free_max_threshold);
    dram_threshold->min_threshold = bundle_size;
    dram_threshold->max_threshold = SOC_SAND_MAX(dram_bound_buffer_factor * q_on_threshold / dram_recovery_failure_dividor, 2 * dram_threshold->min_threshold);
    /* Alpha DP 0= Approximate a line to Max threshold -- Log(Max-Threshold/Max-Free) */
    dram_threshold->alpha = -7;

    /*     Recovery Failure  FADT PDs */
    dram_threshold = SOC_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, dram_bound_info,
                                                            SOC_TMC_INGRESS_DRAM_BOUND_RECOVERY_FAILURE, SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS);

    dram_threshold->free_max_threshold = 32 * 1024 / 2; /* 32K x 0.5 */
    dram_threshold->free_min_threshold = 
            SOC_SAND_MIN(min_free_pd * 2, dram_threshold->free_max_threshold); 
    
    dram_threshold->max_threshold = SOC_SAND_MAX(dram_bound_buffer_factor * q_on_threshold / dram_recovery_failure_dividor / min_packet_size, 2 * dram_threshold->min_threshold);
    dram_threshold->min_threshold = bundle_size / min_packet_size;
    /* Alpha DP 0= Approximate a line to Max threshold -- Log(Max-Threshold/Max-Free) */
    dram_threshold->alpha = -6;
    
   
   dram_bound_info->qsize_recovery_th = SOC_SAND_MIN( bundle_size* dram_recovery_multiplier, 
                                                      dram_bound_info->sram_words_dram_threshold[SOC_TMC_INGRESS_DRAM_BOUND].max_threshold / dram_recovery_failure_dividor);

    BCMDNX_FUNC_RETURN;
}
                                      

/* 
 * Purpose: Configure default values in HW rate class information 
 */
int
_bcm_petra_cosq_voq_rate_class_default_set(int unit,
                                           int rate_class,
                                           bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t *exact_rate_class_info = NULL;
    int tc, ocb_voq_threshold_id;
    int index;
    bcm_dpp_cosq_ingress_threshold_type_e thresh_type;
    
    SOC_TMC_MGMT_OCB_VOQ_INFO ocb_info;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(rate_class_info);

    /* 
     * exact_rate_class_info is not being used, but it takes a lot of space in the stack.
     * So we allocate it on the heap and free it at the end of the function
     */
    BCMDNX_ALLOC(exact_rate_class_info, (sizeof(bcm_dpp_cosq_ingress_rate_class_info_t)), "exact rate class info");
    if (exact_rate_class_info == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }

    sal_memset(rate_class_info,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    SOC_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);

    BCMDNX_IF_ERR_EXIT(arad_mgmt_ocb_voq_info_defaults_set(unit, &ocb_info));

    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        /* max queue size */
        rate_class_info->queue_max_size_bds[index] = DPP_COSQ_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL;
        rate_class_info->queue_alpha_bds[index] = 0;
        
        if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
            /* supported for jericho devices only */
            rate_class_info->min_free_ocb_buffers[index] = 0;

            /* set regular tail drop: max=min and alpha = 0 */
            rate_class_info->queue_ocb_fadt_tail_drop[index].max = DPP_COSQ_JER_ING_QUEUE_OCB_MAX_SIZE_BUFFERS_DEFAULT_VAL;
            rate_class_info->queue_ocb_fadt_tail_drop[index].min = DPP_COSQ_JER_ING_QUEUE_OCB_MAX_SIZE_BUFFERS_DEFAULT_VAL;
            rate_class_info-> queue_ocb_fadt_tail_drop[index].alpha = 0;
        }

        for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
            /* we might need to set different default values for words/sram words/ sram pds */
            rate_class_info->queue_fadt_tail_drop[index][thresh_type].max = 
                (thresh_type == DPP_COSQ_INGRESS_THRESHOLD_SRAM_PDS) ? DPP_COSQ_PB_ING_QUEUE_MAX_SRAM_PDS_DEFAULT_VAL : 
                    (DPP_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL); 
            rate_class_info->queue_fadt_tail_drop[index][thresh_type].min = rate_class_info->queue_fadt_tail_drop[index][thresh_type].max;
            /* 
               for devices prior to qax, alpha should be explicitely turn on.
               for QAX, alpha is always effective.
               for QAX, set alpha to 0 to achieve regular tail drop behaviour
            */
            rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha = SOC_IS_QAX(unit) ? 0 : ARAD_PLUS_MAX_ALPHA; 
        
        }

        /* WRED */
        rate_class_info->wred_enable[index] = 0;  
    }
    
    /* ECN configuration */
    rate_class_info->ecn_wred_enable = 0;              
    rate_class_info->ecn_queue_max_size = SOC_IS_ARADPLUS(unit) ? 
            (DPP_COSQ_PB_ING_QUEUE_MAX_SIZE_DEFAULT_VAL) / 2 : ARAD_MAX_QUEUE_SIZE_BYTES;
    rate_class_info->ecn_queue_max_size_bds = DPP_COSQ_ARAD_ING_QUEUE_MAX_SIZE_BDS_DEFAULT_VAL / 2;


    /* Guaranteed queue size */
    for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
            rate_class_info->queue_quaranteed_size[thresh_type] = 0;
    }
    rate_class_info->queue_min_size_bds = 0;

    rate_class_info->wred_exp_wq = DPP_COSQ_PB_ING_WRED_EXP_WQ_DEFAULT_VAL;

    /* ocb information */
    for(tc = 0; tc < DPP_DEVICE_COSQ_ING_NOF_TC; ++tc){
        for(index = 0; index < DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){                  
            rate_class_info->ocb_info[tc][index].voq_eligible = ocb_info.voq_eligible;
            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_info.th_buffers[ocb_voq_threshold_id];
                rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_info.th_words[ocb_voq_threshold_id];
            }
        }
    }
   
    /* system RED rate class */
    SOC_TMC_ITM_SYS_RED_QT_INFO_clear(&rate_class_info->sys_red_qt);
    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&rate_class_info->sys_red_qt_dp[index]);
    }

    /* Set OCB-only mode */
    if (SOC_IS_QAX(unit)) {
        /* QAX and later only */
        rate_class_info->ocb_only = ((SOC_DPP_CONFIG(unit)->arad->init.dram.nof_drams == 0) ? 1 : 0);
    }
    
    /* DRAM bounds */
    if (SOC_IS_QAX(unit)) {
        /* DRAM bound is a new feature available on QAX only */
        rv = _bcm_petra_cosq_dram_bounds_default_set(unit,&rate_class_info->dram_bound_info);
        BCMDNX_IF_ERR_EXIT(rv);
    }

    
    rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit, rate_class, rate_class_info, exact_rate_class_info);
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    if (exact_rate_class_info != NULL) {
        BCM_FREE(exact_rate_class_info);
    }
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Get in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_get(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info)
{
    uint32                soc_sand_rc = 0;    
    int index;
    int tc, ocb_voq_threshold_id;
    SOC_TMC_MGMT_OCB_VOQ_INFO ocb_info;
    SOC_TMC_ITM_TAIL_DROP_INFO tail_drop_info;
    SOC_TMC_ITM_FADT_DROP_INFO fadt_drop_info;
    SOC_TMC_ITM_WRED_QT_DP_INFO wred_info;
    SOC_TMC_ITM_SYS_RED_QT_INFO sys_red_qt_info;
    SOC_TMC_ITM_SYS_RED_QT_DP_INFO sys_red_qt_dp_info;
    SOC_TMC_ITM_GUARANTEED_INFO guaranteed_info;
    bcm_dpp_cosq_ingress_threshold_type_e thresh_type;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_NULL_CHECK(rate_class_info);
    
    SOC_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);


    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);

        {
            /* FADT / tail drop */
            
            SOC_TMC_ITM_FADT_DROP_INFO_clear(&fadt_drop_info);

            SOCDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_fadt_tail_drop_get,(unit,rate_class,index,&fadt_drop_info)));

            /* set the values */
            for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                rate_class_info->queue_fadt_tail_drop[index][thresh_type].max = fadt_drop_info.max_threshold[thresh_type];
                rate_class_info->queue_fadt_tail_drop[index][thresh_type].min = fadt_drop_info.min_threshold[thresh_type];
                rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha = fadt_drop_info.adjust_factor[thresh_type];

            }
            /* not in use for QAX and later */
            rate_class_info->queue_max_size_bds[index] = fadt_drop_info.max_inst_q_size_bds;
            rate_class_info->queue_alpha_bds[index] = fadt_drop_info.adjust_factor_bds;
            

        }

       if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
           SOC_TMC_ITM_OCB_FADT_DROP_THRESHOLD ocb_fadt_info;

            /* supported for jericho devices only */
            BCMDNX_IF_ERR_EXIT(jer_itm_ocb_fadt_drop_get(unit, rate_class, index, &ocb_fadt_info));

            rate_class_info->min_free_ocb_buffers[index] = ocb_fadt_info.free_min_threshold;

            rate_class_info->queue_ocb_fadt_tail_drop[index].max = ocb_fadt_info.max_threshold;
            rate_class_info->queue_ocb_fadt_tail_drop[index].min = ocb_fadt_info.min_threshold;
            rate_class_info-> queue_ocb_fadt_tail_drop[index].alpha = ocb_fadt_info.alpha;
            
        }

        /* WRED */
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_get,(unit,rate_class,index,&wred_info)));

        rate_class_info->wred_min_avrg_th[index] = wred_info.min_avrg_th;
        rate_class_info->wred_max_avrg_th[index] = wred_info.max_avrg_th;
        rate_class_info->wred_max_probability[index] = wred_info.max_probability;
        rate_class_info->wred_enable[index] = wred_info.wred_en;              

    }

    if (!SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        /* ECN configuration */
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_get,(unit, rate_class, BCM_DPP_ECN_DP, &wred_info)));
        rate_class_info->ecn_wred_min_avrg_th = wred_info.min_avrg_th;
        rate_class_info->ecn_wred_max_avrg_th = wred_info.max_avrg_th;
        rate_class_info->ecn_wred_max_probability = wred_info.max_probability;
        rate_class_info->ecn_wred_enable = wred_info.wred_en;              

        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_get,(unit, rate_class, BCM_DPP_ECN_DP, &tail_drop_info)));
        /* The mbcm call initializes the variable tail_drop_info */
        /* coverity[uninit_use:FALSE] */
        rate_class_info->ecn_queue_max_size = tail_drop_info.max_inst_q_size;
        /* coverity[uninit_use:FALSE] */
        rate_class_info->ecn_queue_max_size_bds = tail_drop_info.max_inst_q_size_bds;
    }

    /* Guaranteed queue size */
    sal_memset(&guaranteed_info, 0x0, sizeof(guaranteed_info));
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_committed_q_size_get,(unit, rate_class, &guaranteed_info)));
    rate_class_info->queue_min_size_bds = guaranteed_info.guaranteed_size_bds;
    for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        rate_class_info->queue_quaranteed_size[thresh_type] = guaranteed_info.guaranteed_size[thresh_type];
    }

    /* wred exp */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_exp_wq_get,(unit,rate_class,&(rate_class_info->wred_exp_wq))));

    /* ocb information */
    for(tc = 0; tc < DPP_DEVICE_COSQ_ING_NOF_TC; ++tc){
        for(index = 0; index < DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){
            soc_sand_rc = arad_mgmt_ocb_voq_eligible_get(unit, index, rate_class, tc, &ocb_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                        
            rate_class_info->ocb_info[tc][index].voq_eligible = ocb_info.voq_eligible;
            rate_class_info->ocb_info[tc][index].dram_admission_exempt = ocb_info.dram_admission_exempt;
            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_info.th_buffers[ocb_voq_threshold_id];
                rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_info.th_words[ocb_voq_threshold_id];
            }
        }
    }

    if (SOC_IS_QAX(unit)) {
        /* QAX and later only */
        BCMDNX_IF_ERR_EXIT (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_profile_ocb_only_get,(unit, rate_class, &rate_class_info->ocb_only)));
    }

    /* System RED */
    SOC_TMC_ITM_SYS_RED_QT_INFO_clear(&sys_red_qt_info);
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_queue_size_boundaries_get,(unit, rate_class, &sys_red_qt_info)));
    for (index = 0; index < SOC_TMC_ITM_SYS_RED_Q_SIZE_RANGES; index++) {
         rate_class_info->sys_red_qt.queue_size_boundaries[index] = sys_red_qt_info.queue_size_boundaries[index];
    }

    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&sys_red_qt_dp_info);
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_q_based_get,(unit, rate_class, index, &sys_red_qt_dp_info)));
        rate_class_info->sys_red_qt_dp[index].adm_th = sys_red_qt_dp_info.adm_th;
        rate_class_info->sys_red_qt_dp[index].drp_prob_high = sys_red_qt_dp_info.drp_prob_high;
        rate_class_info->sys_red_qt_dp[index].drp_prob_low  = sys_red_qt_dp_info.drp_prob_low;
        rate_class_info->sys_red_qt_dp[index].drp_th = sys_red_qt_dp_info.drp_th;
        rate_class_info->sys_red_qt_dp[index].enable = sys_red_qt_dp_info.enable;
        rate_class_info->sys_red_qt_dp[index].prob_th = sys_red_qt_dp_info.prob_th;
    }

    /* DRAM bounds */
    if (SOC_IS_QAX(unit)) {
        /* DRAM bound is a new feature available on QAX only */
        /* call the driver */
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_dram_bound_get,(unit,rate_class,&rate_class_info->dram_bound_info))); 
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Commit in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_voq_rate_class_hw_set(int unit,
                                      int rate_class,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info,
                                      bcm_dpp_cosq_ingress_rate_class_info_t *exact_rate_class_info)
{
    uint32                soc_sand_rc = 0;    
    int index;
    int tc, ocb_voq_threshold_id;
    SOC_TMC_MGMT_OCB_VOQ_INFO ocb_info, ocb_exact_info;
    SOC_TMC_ITM_TAIL_DROP_INFO tail_drop_info, exact_tail_drop_info;
    SOC_TMC_ITM_WRED_QT_DP_INFO wred_info, exact_wred_info;
    soc_dpp_config_t *dpp = SOC_DPP_CONFIG(unit);
    SOC_TMC_ITM_SYS_RED_QT_INFO sys_red_qt_info;
    SOC_TMC_ITM_SYS_RED_QT_DP_INFO sys_red_qt_dp_info;
    SOC_TMC_ITM_GUARANTEED_INFO guaranteed_info, exact_guaranteed_info;

    SOC_TMC_ITM_FADT_DROP_INFO fadt_info, exact_fadt_info;
    bcm_dpp_cosq_ingress_threshold_type_e thresh_type;

    uint8 wred_gen_enable = FALSE;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(rate_class_info);    
    
    SOC_TMC_ITM_TAIL_DROP_INFO_clear(&exact_tail_drop_info);
    SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&exact_wred_info);

    SOC_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_info);
    SOC_TMC_MGMT_OCB_VOQ_INFO_clear(&ocb_exact_info);

    dpp = SOC_DPP_CONFIG(unit);

    sal_memcpy(exact_rate_class_info, rate_class_info, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);

        /* tail drop + FADT */
        {
            
            SOC_TMC_ITM_FADT_DROP_INFO_clear(&fadt_info);
            SOC_TMC_ITM_FADT_DROP_INFO_clear(&exact_fadt_info);

            /* set the values */
            for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                fadt_info.max_threshold[thresh_type] = rate_class_info->queue_fadt_tail_drop[index][thresh_type].max;
                fadt_info.min_threshold[thresh_type] = rate_class_info->queue_fadt_tail_drop[index][thresh_type].min;
                fadt_info.adjust_factor[thresh_type] = rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha;

            }
            fadt_info.max_inst_q_size_bds = rate_class_info->queue_max_size_bds[index];
            fadt_info.adjust_factor_bds = rate_class_info->queue_alpha_bds[index];

            /* call the driver */
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_fadt_tail_drop_set,(unit,rate_class,index,&fadt_info, &exact_fadt_info)));
            /* copy actual settings */
            for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                exact_rate_class_info->queue_fadt_tail_drop[index][thresh_type].max = exact_fadt_info.max_threshold[thresh_type];
                exact_rate_class_info->queue_fadt_tail_drop[index][thresh_type].min = exact_fadt_info.min_threshold[thresh_type];
                exact_rate_class_info->queue_fadt_tail_drop[index][thresh_type].alpha = exact_fadt_info.adjust_factor[thresh_type];

            }
            exact_rate_class_info->queue_max_size_bds[index] = exact_fadt_info.max_inst_q_size_bds;
            exact_rate_class_info->queue_alpha_bds[index] = exact_fadt_info.adjust_factor_bds;

        }

        if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
            SOC_TMC_ITM_OCB_FADT_DROP_THRESHOLD ocb_fadt_info, exact_ocb_fadt_info;

            sal_memset(&exact_ocb_fadt_info, 0x0, sizeof(exact_ocb_fadt_info));
    
            /* supported for jericho devices only */
            ocb_fadt_info.free_min_threshold = rate_class_info->min_free_ocb_buffers[index];

            ocb_fadt_info.max_threshold = rate_class_info->queue_ocb_fadt_tail_drop[index].max;
            ocb_fadt_info.min_threshold = rate_class_info->queue_ocb_fadt_tail_drop[index].min;
            ocb_fadt_info.alpha = rate_class_info-> queue_ocb_fadt_tail_drop[index].alpha;

            BCMDNX_IF_ERR_EXIT(jer_itm_ocb_fadt_drop_set(unit, rate_class, index, &ocb_fadt_info, &exact_ocb_fadt_info));

            exact_rate_class_info->min_free_ocb_buffers[index] = exact_ocb_fadt_info.free_min_threshold;

            exact_rate_class_info->queue_ocb_fadt_tail_drop[index].max = exact_ocb_fadt_info.max_threshold;
            exact_rate_class_info->queue_ocb_fadt_tail_drop[index].min = exact_ocb_fadt_info.min_threshold;
            exact_rate_class_info-> queue_ocb_fadt_tail_drop[index].alpha = exact_ocb_fadt_info.alpha;
            
        }

        /* WRED */
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_get,(unit,rate_class,index,&wred_info)));

        wred_info.max_avrg_th = rate_class_info->wred_max_avrg_th[index];
        wred_info.min_avrg_th = rate_class_info->wred_min_avrg_th[index];
        wred_info.max_probability = rate_class_info->wred_max_probability[index];
        wred_info.wred_en = rate_class_info->wred_enable[index];
        wred_info.ignore_packet_size = (dpp->tm.wred_packet_size == 0) ? 1:0;
        wred_info.max_packet_size = dpp->tm.wred_packet_size;
        
        BCMDNX_IF_ERR_EXIT (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_set,(unit,rate_class,index,&wred_info,&exact_wred_info)));

        /* Set exact rate class information according to exact wred information */
        exact_rate_class_info->wred_min_avrg_th[index] = exact_wred_info.min_avrg_th;
        exact_rate_class_info->wred_max_avrg_th[index] = exact_wred_info.max_avrg_th;
        exact_rate_class_info->wred_max_probability[index] = exact_wred_info.max_probability;
        exact_rate_class_info->wred_enable[index] = exact_wred_info.wred_en;
        wred_gen_enable = exact_wred_info.wred_en ? TRUE : wred_gen_enable;
    }

    if (!SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        /* ECN configuration */
        SOC_TMC_ITM_WRED_QT_DP_INFO_clear(&wred_info);
        wred_info.max_avrg_th = rate_class_info->ecn_wred_max_avrg_th;
        wred_info.min_avrg_th = rate_class_info->ecn_wred_min_avrg_th;
        wred_info.max_probability = rate_class_info->ecn_wred_max_probability;
        wred_info.wred_en = rate_class_info->ecn_wred_enable;
        wred_info.ignore_packet_size = (dpp->tm.wred_packet_size == 0) ? 1:0;
        wred_info.max_packet_size = dpp->tm.wred_packet_size;
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_set,(unit, rate_class, BCM_DPP_ECN_DP, &wred_info, &exact_wred_info)));
        exact_rate_class_info->ecn_wred_min_avrg_th = exact_wred_info.min_avrg_th;
        exact_rate_class_info->ecn_wred_max_avrg_th = exact_wred_info.max_avrg_th;
        exact_rate_class_info->ecn_wred_max_probability = exact_wred_info.max_probability;
        exact_rate_class_info->ecn_wred_enable = exact_wred_info.wred_en;              
        wred_gen_enable = exact_wred_info.wred_en ? TRUE : wred_gen_enable;

        SOC_TMC_ITM_TAIL_DROP_INFO_clear(&tail_drop_info);
        tail_drop_info.max_inst_q_size = rate_class_info->ecn_queue_max_size;
        tail_drop_info.max_inst_q_size_bds = rate_class_info->ecn_queue_max_size_bds;
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_tail_drop_set,(unit, rate_class, BCM_DPP_ECN_DP, &tail_drop_info, &exact_tail_drop_info)));
        exact_rate_class_info->ecn_queue_max_size = exact_tail_drop_info.max_inst_q_size;
        exact_rate_class_info->ecn_queue_max_size_bds = exact_tail_drop_info.max_inst_q_size_bds;
    }

    /* Guaranteed queue size */
    sal_memset(&exact_guaranteed_info, 0x0, sizeof(exact_guaranteed_info));
    guaranteed_info.guaranteed_size_bds = rate_class_info->queue_min_size_bds;

    for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        guaranteed_info.guaranteed_size[thresh_type] = rate_class_info->queue_quaranteed_size[thresh_type];
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_committed_q_size_set,(unit, rate_class, &guaranteed_info, &exact_guaranteed_info)));

    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    exact_rate_class_info->queue_min_size_bds = exact_guaranteed_info.guaranteed_size_bds;
    for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        exact_rate_class_info->queue_quaranteed_size[thresh_type] = exact_guaranteed_info.guaranteed_size[thresh_type];
    }

    /* wred exp */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_wred_exp_wq_set,(unit,rate_class,rate_class_info->wred_exp_wq, wred_gen_enable)));
    exact_rate_class_info->wred_exp_wq = rate_class_info->wred_exp_wq;

    /* ocb information */
    for(tc = 0; tc < DPP_DEVICE_COSQ_ING_NOF_TC; ++tc){
        for(index = 0; index < DPP_DEVICE_COSQ_QUEUE_NOF_CATEGORY; ++index){
            soc_sand_rc = arad_mgmt_ocb_voq_eligible_get(unit, index, rate_class, tc, &ocb_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                        
            ocb_info.voq_eligible = rate_class_info->ocb_info[tc][index].voq_eligible;
            ocb_info.dram_admission_exempt = rate_class_info->ocb_info[tc][index].dram_admission_exempt;

            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                ocb_info.th_buffers[ocb_voq_threshold_id] = rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id];
                ocb_info.th_words[ocb_voq_threshold_id] = rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id];
            }
            soc_sand_rc = arad_mgmt_ocb_voq_eligible_set(unit, index, rate_class, tc, &ocb_info, &ocb_exact_info);
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                        
            for(ocb_voq_threshold_id = 0; ocb_voq_threshold_id < SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS; ++ocb_voq_threshold_id)
            {
                exact_rate_class_info->ocb_info[tc][index].th_buffers[ocb_voq_threshold_id] = ocb_exact_info.th_buffers[ocb_voq_threshold_id];
                exact_rate_class_info->ocb_info[tc][index].th_words[ocb_voq_threshold_id] = ocb_exact_info.th_words[ocb_voq_threshold_id];
            }
            exact_rate_class_info->ocb_info[tc][index].voq_eligible = rate_class_info->ocb_info[tc][index].voq_eligible;
            exact_rate_class_info->ocb_info[tc][index].dram_admission_exempt = rate_class_info->ocb_info[tc][index].dram_admission_exempt;
        }
    }

    if (SOC_IS_QAX(unit)) {
        /* QAX and later only */
        BCMDNX_IF_ERR_EXIT (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_profile_ocb_only_set,(unit, rate_class, rate_class_info->ocb_only)));
        exact_rate_class_info->ocb_only = rate_class_info->ocb_only;
    }
    

    /* System RED */
    SOC_TMC_ITM_SYS_RED_QT_INFO_clear(&sys_red_qt_info);
    for (index = 0; index < SOC_TMC_ITM_SYS_RED_Q_SIZE_RANGES; index++) {
        sys_red_qt_info.queue_size_boundaries[index] = rate_class_info->sys_red_qt.queue_size_boundaries[index];
    }
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_queue_size_boundaries_set,(unit, rate_class, &sys_red_qt_info, &exact_rate_class_info->sys_red_qt)));

    SOC_TMC_ITM_SYS_RED_QT_DP_INFO_clear(&sys_red_qt_dp_info);
    for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
        sys_red_qt_dp_info.adm_th        = rate_class_info->sys_red_qt_dp[index].adm_th;
        sys_red_qt_dp_info.drp_prob_high = rate_class_info->sys_red_qt_dp[index].drp_prob_high;
        sys_red_qt_dp_info.drp_prob_low  = rate_class_info->sys_red_qt_dp[index].drp_prob_low;
        sys_red_qt_dp_info.drp_th        = rate_class_info->sys_red_qt_dp[index].drp_th;
        sys_red_qt_dp_info.enable        = rate_class_info->sys_red_qt_dp[index].enable;
        sys_red_qt_dp_info.prob_th       = rate_class_info->sys_red_qt_dp[index].prob_th;
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_q_based_set,(unit, rate_class, index, &sys_red_qt_dp_info)));
    }

    /* DRAM bounds */
    if (SOC_IS_QAX(unit)) {
        /* DRAM bound is a new feature available on QAX only */
        /* call the driver */
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_itm_dram_bound_set,(unit,rate_class,&rate_class_info->dram_bound_info, 
                                                                                      &exact_rate_class_info->dram_bound_info)));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Commit in HW rate class information 
 */
STATIC int
_bcm_petra_cosq_sys_red_dp_pr_hw_set(int unit,
                                     int dp_pr,
                                     bcm_dpp_cosq_ingress_system_red_dp_pr_info_t *rate_sys_red_dp_pr_info)
{
    bcm_error_t rv = BCM_E_NONE;
    SOC_TMC_ITM_SYS_RED_DROP_PROB prob_info;

    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_ITM_SYS_RED_DROP_PROB_clear(&prob_info);

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_drop_prob_get,(unit, &prob_info)));
    prob_info.drop_probs[dp_pr] = rate_sys_red_dp_pr_info->sys_red_dp_pr_val;
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_sys_red_drop_prob_set,(unit, &prob_info)));

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC bcm_dpp_cosq_ingress_threshold_type_e _bcm_petra_cosq_gport_flags_to_ingress_threshold_type(uint32 flags)
{
    bcm_dpp_cosq_ingress_threshold_type_e threshold_type = DPP_COSQ_INGRESS_THRESHOLD_INVALID;

    if (flags & BCM_COSQ_GPORT_SIZE_BYTES) {
        if (flags & BCM_COSQ_GPORT_SIZE_SRAM) {
            threshold_type = DPP_COSQ_INGRESS_THRESHOLD_SRAM_BYTES;
        } else {
            threshold_type = DPP_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES;
        }
    } else if ((flags & BCM_COSQ_GPORT_SIZE_PACKET_DESC) && (flags & BCM_COSQ_GPORT_SIZE_SRAM)) {
        threshold_type = DPP_COSQ_INGRESS_THRESHOLD_SRAM_PDS;
    }

    return threshold_type;
}
/* 
 * Purpose: retrieve queue maximal & guaranteed from gport size structure to a rate class data structure 
 */
STATIC int
_bcm_petra_cosq_gport_gport_size_to_rate_class(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t* gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                               int set_alpha)
{
    int index = 0;
    bcm_dpp_cosq_ingress_threshold_type_e threshold_type;
    int color_start, color_end;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    BCMDNX_NULL_CHECK(data_rate_class);


    threshold_type = _bcm_petra_cosq_gport_flags_to_ingress_threshold_type(flags);

    /* Change related information */        
    if (flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED) {
        data_rate_class->sys_red_qt.queue_size_boundaries[color] = gport_size->size_max;
    } else {
        if (flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND) {
            /* Set all dp information */
            color_start = 0;
            color_end = DPP_DEVICE_COSQ_ING_NOF_DP -1;
        }
        else {
            /* Set specific dp */
            color_start = color;
            color_end = color;
        }
        for (index = color_start; index <= color_end; index++) {
            if (threshold_type == DPP_COSQ_INGRESS_THRESHOLD_INVALID) {
                if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
                    /* not is use for QAX and later */
                    data_rate_class->queue_max_size_bds[index] = gport_size->size_max;
                    if (set_alpha) {
                        data_rate_class->queue_alpha_bds[index] = gport_size->size_alpha_max;
                    }
                } else if ((flags & BCM_COSQ_GPORT_SIZE_BUFFERS) && (flags & BCM_COSQ_GPORT_SIZE_OCB)) {
                    /* For Jericho devices only (not QAX) */
                    data_rate_class->queue_ocb_fadt_tail_drop[index].max = gport_size->size_max;
                    data_rate_class->queue_ocb_fadt_tail_drop[index].min = gport_size->size_fadt_min;
                    data_rate_class->queue_ocb_fadt_tail_drop[index].alpha = gport_size->size_alpha_max;
                    data_rate_class->min_free_ocb_buffers[index] = gport_size->size_min;
                    
                }
                else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));

                }
            } else {
            
                data_rate_class->queue_fadt_tail_drop[index][threshold_type].max =  gport_size->size_max;
                data_rate_class->queue_fadt_tail_drop[index][threshold_type].min =  gport_size->size_fadt_min;
                data_rate_class->queue_fadt_tail_drop[index][threshold_type].alpha =  gport_size->size_alpha_max;
            }
            
        }        
    }
    /* The concept of guaranteed is not supported by hardware for ingress replicated copies. We do not check that such queues are not guaranteed here */
    if (threshold_type == DPP_COSQ_INGRESS_THRESHOLD_INVALID) {
        if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
            /* not is use for QAX and later */
            data_rate_class->queue_min_size_bds = gport_size->size_min;
        } 
    } else {
        data_rate_class->queue_quaranteed_size[threshold_type] = gport_size->size_min;
    }

exit:
    BCMDNX_FUNC_RETURN;
 
}

/* 
 * Purpose: retrieve queue maximal & guaranteed from rate class data structure to a gport size structure 
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_to_gport_size(int unit, 
                                               bcm_color_t color,
                                               uint32 flags,
                                               bcm_cosq_gport_size_t *gport_size,
                                               bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class)
{
    bcm_dpp_cosq_ingress_threshold_type_e threshold_type;
    int dummy;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);
    BCMDNX_NULL_CHECK(data_rate_class);

    /* Validate params */
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_color_size_verify(unit, color, flags, gport_size, 0 /*is_set*/, &dummy));

    threshold_type = _bcm_petra_cosq_gport_flags_to_ingress_threshold_type(flags);

    if (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) {
        gport_size->size_min = data_rate_class->queue_min_size_bds;

        gport_size->size_max = data_rate_class->queue_max_size_bds[color];
        gport_size->size_fadt_min = 0; /* not supported */
        gport_size->size_alpha_max = SOC_IS_ARADPLUS(unit) ? data_rate_class->queue_alpha_bds[color] : ARAD_PLUS_ALPHA_NOT_SUPPORTED;
    } else if ((flags & BCM_COSQ_GPORT_SIZE_BUFFERS) && (flags & BCM_COSQ_GPORT_SIZE_OCB)) {
        /* For Jericho devices only (not QAX) */
        gport_size->size_max = data_rate_class->queue_ocb_fadt_tail_drop[color].max;
        gport_size->size_fadt_min = data_rate_class->queue_ocb_fadt_tail_drop[color].min;
        gport_size->size_alpha_max = data_rate_class->queue_ocb_fadt_tail_drop[color].alpha;
        gport_size->size_min = data_rate_class->min_free_ocb_buffers[color];
        
    }
    else if (flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED) {
        gport_size->size_max = data_rate_class->sys_red_qt.queue_size_boundaries[color];
        gport_size->size_min = 0;
        gport_size->size_alpha_max = ARAD_PLUS_ALPHA_NOT_SUPPORTED;
    } else {
        if (threshold_type != DPP_COSQ_INGRESS_THRESHOLD_INVALID) {
            /* guaranteed */
            gport_size->size_min = data_rate_class->queue_quaranteed_size[threshold_type];

            /* tail drop / FADT */
            gport_size->size_max = data_rate_class->queue_fadt_tail_drop[color][threshold_type].max;
            gport_size->size_fadt_min = data_rate_class->queue_fadt_tail_drop[color][threshold_type].min;
            gport_size->size_alpha_max = data_rate_class->queue_fadt_tail_drop[color][threshold_type].alpha;
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x no flag specified for maximum size"), unit, flags));       
        }
    }        

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Verify param given to a gport color size API, 
 * maximal & guaranteed size
 */
STATIC int
_bcm_petra_cosq_gport_voq_color_size_verify(int unit, 
                                            bcm_color_t color,
                                            uint32      flags,
                                            bcm_cosq_gport_size_t* gport_size,
                                            int is_set,
                                            int*        set_alpha) 
{
    uint32 relevant_flags;
    uint32 flags_mask = BCM_COSQ_GPORT_SIZE_BYTES | BCM_COSQ_GPORT_SIZE_COLOR_BLIND | BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED;

    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        /* QAX specific flags */
        flags_mask |= BCM_COSQ_GPORT_SIZE_OCB | BCM_COSQ_GPORT_SIZE_PACKET_DESC;
    } else {
        /* Arad and Jericho flags */
        flags_mask |= BCM_COSQ_GPORT_SIZE_BUFFER_DESC;
        if (SOC_IS_JERICHO(unit)) {
            /* Jericho specific flags */
            flags_mask |=   BCM_COSQ_GPORT_SIZE_OCB | BCM_COSQ_GPORT_SIZE_BUFFERS; 

        }
    }

    relevant_flags = flags & flags_mask;
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((!(flags & BCM_COSQ_GPORT_SIZE_COLOR_BLIND)) && 
        (!(flags & BCM_COSQ_GPORT_SIZE_COLOR_SYSTEM_RED)) && 
        ((color < 0) || (color >= DPP_DEVICE_COSQ_ING_NOF_DP))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid color levels specified %d"), unit, color));
    } 

    if (((flags & BCM_COSQ_GPORT_SIZE_BYTES) && (flags & (BCM_COSQ_GPORT_SIZE_BUFFER_DESC|BCM_COSQ_GPORT_SIZE_BUFFERS|BCM_COSQ_GPORT_SIZE_PACKET_DESC))) ||
        ((flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) && (flags & (BCM_COSQ_GPORT_SIZE_BYTES|BCM_COSQ_GPORT_SIZE_BUFFERS|BCM_COSQ_GPORT_SIZE_PACKET_DESC))) ||
        ((flags & BCM_COSQ_GPORT_SIZE_BUFFERS) && (flags & (BCM_COSQ_GPORT_SIZE_BYTES|BCM_COSQ_GPORT_SIZE_BUFFER_DESC|BCM_COSQ_GPORT_SIZE_PACKET_DESC))) ||
        ((flags & BCM_COSQ_GPORT_SIZE_PACKET_DESC) && (flags & (BCM_COSQ_GPORT_SIZE_BYTES|BCM_COSQ_GPORT_SIZE_BUFFERS|BCM_COSQ_GPORT_SIZE_BUFFER_DESC)))
        ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));

    }
    if ((flags & BCM_COSQ_GPORT_SIZE_BUFFERS) && !(flags & BCM_COSQ_GPORT_SIZE_OCB)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }


    if (is_set) {
        /* parameters validation -- should be done for set function only */

        /* check that size_min is only used with the resource configured to be guaranteed for the device */
        if (gport_size->size_min) {
            if ((flags & BCM_COSQ_GPORT_SIZE_BYTES) && !SOC_IS_QAX(unit) && SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode != SOC_DPP_GUARANTEED_Q_RESOURCE_MEMORY) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d is not configured for minimal/guaranteed queue size by memory/bytes"), unit));
            }
            if ((flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC) && SOC_DPP_CONFIG(unit)->tm.guaranteed_q_mode != SOC_DPP_GUARANTEED_Q_RESOURCE_BDS) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d is not configured for minimal/guaranteed queue size by BDs"), unit));
            }
        }
        if (SOC_IS_ARADPLUS(unit) && (flags & BCM_COSQ_GPORT_SIZE_BUFFER_DESC)) {
            if (gport_size->size_alpha_max < ARAD_PLUS_MIN_ALPHA || gport_size->size_alpha_max > ARAD_PLUS_MAX_ALPHA) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Illegal size_alpha_max value %d, must be in range %d..%d"),
                                                  gport_size->size_alpha_max, ARAD_PLUS_MIN_ALPHA, ARAD_PLUS_MAX_ALPHA));
            }
            *set_alpha = 1;
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Set queue maximal & guaranteed size of a rate class
 * if we called the function in advance mode queue to rate class mapping mode then 
 *    1. if the advance mode is not set then set it
 *    2. configure the rate class directly
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_color_size_set(int unit,
                                                bcm_gport_t gport,
                                                bcm_color_t color,
                                                uint32 flags,
                                                bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t 
        data_rate_class, 
        data_rate_class_old, 
        exact_data_rate_class;
    uint32 
        ref_count[2]; /* for ocb_only and dram_mix */
    int set_alpha = 0;
    int32 reservation_change[SOC_DPP_DEFS_MAX(NOF_CORES)][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int rate_class;
    int core_index, core_id = BCM_CORE_ALL; /*Rate classes are configured symmetrically between cores.*/
    int ocb_only;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&data_rate_class_old,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    /* 
     * Check that the system is in advance queue to rate class mapping mode, 
     *    if not set it to advance mode.
     */
    rv = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_petra_cosq_gport_voq_color_size_verify(unit, color, flags, gport_size, 1 /* is_set */, &set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    /* Get rate class */
    rv = _bcm_petra_cosq_gport_rate_class_get(unit, gport, &rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    /* Get rate class data */
    rv = _bcm_petra_cosq_gport_voq_rate_class_data_get(unit, gport, 0 /*cosq - not relevant when gport is rate class */, &data_rate_class_old);
    BCMDNX_IF_ERR_EXIT(rv);

    sal_memcpy(&data_rate_class, &data_rate_class_old, sizeof(data_rate_class));

    /* Change related information */        
    rv = _bcm_petra_cosq_gport_gport_size_to_rate_class(unit, color, flags, gport_size, &data_rate_class, set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    for (ocb_only = FALSE; ocb_only <= (SOC_IS_QAX(unit) ? FALSE : TRUE); ocb_only++) {
        /* ocb only (TRUE) is not relavant for QAX and above */
        rv = arad_sw_db_rate_class_ref_count_get(unit, core_id, ocb_only, rate_class, &ref_count[ocb_only]); 
        BCMDNX_IF_ERR_EXIT(rv);

        /* check that the remaining resource level is not too low - currently 2% */
        /* reservation_change is calculated by this function */
        rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core_id, ocb_only, &data_rate_class_old, &data_rate_class, ref_count[ocb_only], reservation_change);
        BCMDNX_IF_ERR_EXIT(rv);
    }

    /*2. configure HW*/
    rv = _bcm_petra_cosq_voq_rate_class_hw_set(unit, rate_class, &data_rate_class, &exact_data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    for (ocb_only = FALSE; ocb_only <= (SOC_IS_QAX(unit) ? FALSE : TRUE); ocb_only++) {
        /* ocb only (TRUE) is not relavant for QAX and above */

        /*recalculate the reservation_change*/
        rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core_id, ocb_only, &data_rate_class_old, &exact_data_rate_class, ref_count[ocb_only], reservation_change);
        BCMDNX_IF_ERR_EXIT(rv);

        /*Update HW: total reservation*/
        rv = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, core_id, ocb_only, reservation_change)); /* update reservation */
        BCMDNX_IF_ERR_EXIT(rv);

        /* In STRICT mode need to change also total VSQ reserved resource */
        if (SOC_IS_JERICHO(unit) && SOC_DPP_CONFIG(unit)->jer->tm.cgm_mgmt_guarantee_mode == SOC_TMC_ITM_CGM_MGMT_GUARANTEE_STRICT) {
            SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type;
            rv = _bcm_petra_cosq_flags_to_ingress_threshold(unit, flags, &rsrc_type);
            BCMDNX_IF_ERR_EXIT(rv);
            BCM_DPP_CORES_ITER(core_id, core_index) {
                if (SOC_IS_QAX(unit)) {
                    /* for QAX and later, translate SRAM bytes to SRAM buffers */
                    if (rsrc_type == SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES) {
                        reservation_change[core_index][rsrc_type] = DPP_COSQ_BYTES_TO_BUFFERS(reservation_change[core_index][rsrc_type]);
                    }
                }
                /*
                 *VOQ use SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES and 
                 *VSQ uses SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS, 
                 *but both have the same numeric value 
                */
                rv = _bcm_petra_cosq_vsq_total_reserve_update(unit, core_index, ocb_only, rsrc_type, reservation_change[core_index][rsrc_type]);
                BCMDNX_IF_ERR_EXIT(rv);
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;

}

/*
 * Purpose: Set queue maximal & guaranteed size
 */
int
_bcm_petra_cosq_gport_voq_color_size_set(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class_old, data_rate_class, exact_data_rate_class;
    int qid; 
    int set_alpha = 0;
    int32 reservation_change[SOC_DPP_DEFS_MAX(NOF_CORES)][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int core = BCM_CORE_ALL, core_index;
    uint8 is_ocb_only;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(gport_size);

    rv = _bcm_petra_cosq_gport_voq_color_size_verify(unit, color, flags, gport_size, 1 /* is_set */, &set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    /* get core and qid */
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_validate_and_get(unit, gport, cosq, &core, &qid));

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));

    /*1.1 Get old rate class data */
    rv = _bcm_dpp_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_class_old);
    BCMDNX_IF_ERR_EXIT(rv);

    /*1.2 copy data to use as the new */
    sal_memcpy(&data_rate_class, &data_rate_class_old, sizeof(data_rate_class));

    /*1.3 Change related information */
    rv = _bcm_petra_cosq_gport_gport_size_to_rate_class(unit, color, flags, gport_size, &data_rate_class, set_alpha);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_queue_is_ocb_only_get, (unit, core, qid, &is_ocb_only)); 
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, is_ocb_only, &data_rate_class_old, &data_rate_class, 1, reservation_change);
    BCMDNX_IF_ERR_EXIT(rv);

    /* set the updated data to the HW and sw_state */
    rv = _bcm_petra_cosq_voq_rate_class_set(unit, core, qid, &data_rate_class, &exact_data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    /*recalculate the reservation_change*/
    rv = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, is_ocb_only, &data_rate_class_old, &exact_data_rate_class, 1, reservation_change);
    BCMDNX_IF_ERR_EXIT(rv);

    /*Update HW: total reservation*/
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, core, is_ocb_only, reservation_change)));

    /* In STRICT mode need to change also total VSQ reserved resource */
    if (SOC_IS_JERICHO(unit) && SOC_DPP_CONFIG(unit)->jer->tm.cgm_mgmt_guarantee_mode == SOC_TMC_ITM_CGM_MGMT_GUARANTEE_STRICT) {
        SOC_TMC_INGRESS_THRESHOLD_TYPE_E rsrc_type;
        rv = _bcm_petra_cosq_flags_to_ingress_threshold(unit, flags, &rsrc_type);
        BCMDNX_IF_ERR_EXIT(rv);
        BCM_DPP_CORES_ITER(core, core_index) {
            if (SOC_IS_QAX(unit)) {
                /* for QAX and later, translate SRAM bytes to SRAM buffers */
                if (rsrc_type == SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES) {
                    reservation_change[core_index][rsrc_type] = DPP_COSQ_BYTES_TO_BUFFERS(reservation_change[core_index][rsrc_type]);
                }
            }
            /*
             *VOQ use SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES and 
             *VSQ uses SOC_TMC_INGRESS_THRESHOLD_SRAM_BUFFERS, 
             *but both have the same numeric value 
            */
            rv = _bcm_petra_cosq_vsq_total_reserve_update(unit, core_index, is_ocb_only, rsrc_type, reservation_change[core_index][rsrc_type]);
            BCMDNX_IF_ERR_EXIT(rv);
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: retrieve queue maximal & guaranteed size
 */
STATIC int
_bcm_petra_cosq_gport_voq_color_size_get(int unit,
                                         bcm_gport_t gport,
                                         bcm_cos_queue_t cosq,
                                         bcm_color_t color,
                                         uint32 flags,
                                         bcm_cosq_gport_size_t *gport_size)
{
    bcm_error_t rv = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(gport_size);

    rv = _bcm_petra_cosq_gport_voq_rate_class_data_get(unit, gport, cosq, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

    rv = _bcm_petra_cosq_gport_rate_class_to_gport_size(unit, color, flags, gport_size, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_voq_discard_retrieve_dps(int unit,
                                         uint32 flags,
                                         int *dps,
                                         int *nof_dps)
{
    int index = 0;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(dps);
    BCMDNX_NULL_CHECK(nof_dps);

    if ((flags & BCM_COSQ_DISCARD_COLOR_ALL) == BCM_COSQ_DISCARD_COLOR_ALL) {
        /* The configuration is relevanat for all dps */
        for (index = 0; index < DPP_DEVICE_COSQ_ING_NOF_DP; index++) {
            dps[index] = index;
        }
        *nof_dps = DPP_DEVICE_COSQ_ING_NOF_DP;
        BCM_EXIT;        
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_GREEN) {
        dps[index++] = 0;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_YELLOW) {
        dps[index++] = 1;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_RED) {
        dps[index++] = 2;
    }
    if (flags & BCM_COSQ_DISCARD_COLOR_BLACK) {
        dps[index++] = 3;
    }

    *nof_dps = index;

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * System RED discard/drop probability set
 */
STATIC int 
_bcm_petra_cosq_sys_red_dp_pr_set(int unit,
                                  bcm_dpp_cosq_ingress_rate_class_info_t *data_rate_class,
                                  bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int index = 0, is_last = 0, is_allocated = 0, dp_pr_idx = 0;
    int nof_drop_prec = 0;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];

    bcm_dpp_cosq_ingress_system_red_dp_pr_info_t data_sys_red_dp_pr;
    int new_sys_red_dp_pr_ndx, old_sys_red_dp_pr_ndx;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    /* update rate_class with new drop_probability*/
    rc = _bcm_petra_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec == 0) {
        /* Nothing to change, just exit */
        BCM_EXIT;
    }

    for (index = 0; index < nof_drop_prec; index++) {
        /* check if discard->drop_probability already exist in am */
        data_sys_red_dp_pr.sys_red_dp_pr_val = discard->drop_probability;

        /* Stage 1: Find new profile according to given settings */

        /* Update information in SW */
        if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
            dp_pr_idx = data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_low;
        } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
            dp_pr_idx = data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_high;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
        }

        if (!SOC_IS_QAX(unit))
        {
            rc = _bcm_dpp_am_template_system_red_dp_pr_exchange(unit, dp_pr_idx, &data_sys_red_dp_pr, &old_sys_red_dp_pr_ndx, 
                                                                &is_last, &new_sys_red_dp_pr_ndx, &is_allocated);
            BCMDNX_IF_ERR_EXIT(rc);
            
            /* Commit Changes in HW according to given thresholds */
            if (is_allocated) {
                rc = _bcm_petra_cosq_sys_red_dp_pr_hw_set(unit,new_sys_red_dp_pr_ndx,&data_sys_red_dp_pr);
                BCMDNX_IF_ERR_EXIT(rc);        
            } 
            
            /* Clear old profile */
            if (is_last && new_sys_red_dp_pr_ndx != old_sys_red_dp_pr_ndx) {
                sal_memset(&data_sys_red_dp_pr, 0x0, sizeof(bcm_dpp_cosq_ingress_system_red_dp_pr_info_t));
                rc = _bcm_petra_cosq_sys_red_dp_pr_hw_set(unit, old_sys_red_dp_pr_ndx, &data_sys_red_dp_pr);
                BCMDNX_IF_ERR_EXIT(rc);    
            }
        }
        else
        {
            /*
             * QAX configures probablity directly on the rate class
             * without additional profile
             */
            new_sys_red_dp_pr_ndx = discard->drop_probability;

        }
       
        if (discard->flags & BCM_COSQ_DISCARD_ENABLE) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].enable = 0x1;
        } else {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].enable = 0x0;
        }

        if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].adm_th       = discard->min_thresh;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_low = new_sys_red_dp_pr_ndx;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].prob_th      = discard->max_thresh;
        } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
            data_rate_class->sys_red_qt_dp[drop_prec[index]].prob_th       = discard->min_thresh;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_prob_high = new_sys_red_dp_pr_ndx;
            data_rate_class->sys_red_qt_dp[drop_prec[index]].drp_th        = discard->max_thresh;
        } else {
            /* Must use one of these flags */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
        }
    }
   
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_sys_red_dp_pr_get(int unit,
                                  bcm_dpp_cosq_ingress_rate_class_info_t *data_rate_class,
                                  bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int dp_pr_idx = 0x0, dp_index = 0x0;
    int nof_drop_prec = 0x0;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];

    bcm_dpp_cosq_ingress_system_red_dp_pr_info_t data_sys_red_dp_pr;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    /* update rate_class with new drop_probability*/
    rc = _bcm_petra_cosq_voq_discard_retrieve_dps(unit, discard->flags, drop_prec, &nof_drop_prec);
    BCMDNX_IF_ERR_EXIT(rc);

    if (nof_drop_prec != 1) {
        /* Can get only one color value */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color\n"), unit, discard->flags));
    }

    dp_index = drop_prec[0];

    if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY1) {
        discard->min_thresh = data_rate_class->sys_red_qt_dp[dp_index].adm_th;
        dp_pr_idx = data_rate_class->sys_red_qt_dp[dp_index].drp_prob_low;
        discard->max_thresh = data_rate_class->sys_red_qt_dp[dp_index].prob_th;            
    } else if (discard->flags & BCM_COSQ_DISCARD_PROBABILITY2) {
        discard->min_thresh = data_rate_class->sys_red_qt_dp[dp_index].prob_th;
        dp_pr_idx = data_rate_class->sys_red_qt_dp[dp_index].drp_prob_high;
        discard->max_thresh = data_rate_class->sys_red_qt_dp[dp_index].drp_th;
    } else {
        /* Must use one of these flags */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, Must define  BCM_COSQ_DISCARD_PROBABILITY1\2\n"), unit, discard->flags));
    }

    if (!SOC_IS_QAX(unit))
    {
        rc = _bcm_dpp_am_template_system_red_dp_pr_data_get(unit, dp_pr_idx, &data_sys_red_dp_pr);
        BCMDNX_IF_ERR_EXIT(rc);
        
        discard->drop_probability = data_sys_red_dp_pr.sys_red_dp_pr_val;
    }
    else
    {
        /** QAX does not have additional profile */
        discard->drop_probability = dp_pr_idx;
    }

    if (data_rate_class->sys_red_qt_dp[dp_index].enable == 0x1) {
        discard->flags |= BCM_COSQ_DISCARD_ENABLE;
    } else {
        discard->flags &= BCM_COSQ_DISCARD_ENABLE;
    }

    discard->gain = 0;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_discard_verify(int unit,
                                     bcm_cosq_gport_discard_t *discard,
                                     int is_vsq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 relevant_flags, max_drop_probability, max_discard_gain;

    BCMDNX_INIT_FUNC_DEFS;
    
    if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) {
        max_drop_probability = BCM_DPP_COSQ_DISCARD_SYSTEM_RED_FROP_PROB;
        relevant_flags = discard->flags;
        max_discard_gain = 0x0;
    } else {
        relevant_flags = discard->flags & (is_vsq ?
        (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
        BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_ALL |
        BCM_COSQ_DISCARD_BYTES) :
        (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
        BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_ALL |
        BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_MARK_CONGESTION | BCM_COSQ_DISCARD_BUFFER_DESC) );

        max_drop_probability = BCM_DPP_COSQ_DISCARD_FROP_PROB;
        max_discard_gain = DPP_COSQ_PB_WRED_WQ_MAX;
    }
    if (SOC_IS_QAX(unit)) {
        /* BCM_COSQ_DISCARD_BUFFER_DESC is not available in QAX and later */
        relevant_flags &= ~BCM_COSQ_DISCARD_BUFFER_DESC;

    }

    if (discard->flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, discard->flags));
    }

    if (discard->drop_probability < 0 || discard->drop_probability > max_drop_probability) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid drop probability parameter %d"), unit, discard->drop_probability));
    }

    if (discard->gain < 0 || discard->gain > max_discard_gain) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gain parameter %d"), unit, discard->drop_probability));
    }
    
    if (discard->min_thresh > discard->max_thresh) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Min threshold %d is over Max threshold %d"), 
                       unit, discard->min_thresh,discard->max_thresh));
    }

    if (discard->min_thresh < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Min threshold %d is invalid"), 
                       unit, discard->min_thresh));
    }

    if (discard->max_thresh < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Max threshold %d is invalid"), 
                       unit, discard->max_thresh));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: retrieve WRED configuration from discard structure to a rate class data structure 
 */
STATIC int
_bcm_petra_cosq_gport_discard_to_rate_class_data(int unit, 
                                                 bcm_cosq_gport_discard_t *discard,
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class)
{
    bcm_error_t rc = BCM_E_NONE;
    int nof_drop_prec, index;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    /* Change Rate class configuration according to discard structure */
    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* ECN */
        if (SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }

        data_rate_class->ecn_wred_enable = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? SOC_SAND_TRUE:SOC_SAND_FALSE;
        data_rate_class->ecn_wred_min_avrg_th = discard->min_thresh;
        data_rate_class->ecn_wred_max_avrg_th = discard->max_thresh;
        data_rate_class->ecn_wred_max_probability = discard->drop_probability;
        if (discard->flags & BCM_COSQ_DISCARD_BYTES) {
            data_rate_class->ecn_queue_max_size = discard->ecn_thresh;

            if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid flags parameter 0x%x specified for maximum ECN size.\n"
                  "Both of BCM_COSQ_DISCARD_BYTES and BCM_COSQ_DISCARD_BUFFER_DESC cannot be used together."), discard->flags));
            }
            if (!SOC_IS_ARADPLUS(unit) && discard->ecn_thresh > ARAD_B0_MAX_ECN_QUEUE_BYTES && discard->ecn_thresh < ARAD_MAX_QUEUE_SIZE_BYTES) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Arad B0/B1 ECN queue size limit in bytes can not be in the range of 0x%x-0x%lx.\n"),ARAD_B0_MAX_ECN_QUEUE_BYTES+1 ,ARAD_MAX_QUEUE_SIZE_BYTES-1));
            }
        } else if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
            data_rate_class->ecn_queue_max_size_bds = discard->ecn_thresh;

        }
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) { 
        /* system RED */
        rc = _bcm_petra_cosq_sys_red_dp_pr_set(unit, data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        rc = _bcm_petra_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
        BCMDNX_IF_ERR_EXIT(rc);
        
        if (nof_drop_prec == 0) {
            /* Nothing to change, just exit */
            BCM_EXIT;
        }

        for (index = 0; index < nof_drop_prec; index++) {
            data_rate_class->wred_enable[drop_prec[index]] = (discard->flags & BCM_COSQ_DISCARD_ENABLE) ? SOC_SAND_TRUE:SOC_SAND_FALSE;
            data_rate_class->wred_min_avrg_th[drop_prec[index]] = discard->min_thresh;
            data_rate_class->wred_max_avrg_th[drop_prec[index]] = discard->max_thresh;
            data_rate_class->wred_max_probability[drop_prec[index]] = discard->drop_probability;
        }

        /* WRED exp wq parameter is same for all dps and ECN */
        data_rate_class->wred_exp_wq = discard->gain;
    }
exit:
    BCMDNX_FUNC_RETURN;

}
/* 
 * Purpose: retrieve WRED configuration from a rate class data structure to a discard structure
 */
STATIC int
_bcm_petra_cosq_gport_rate_class_data_to_discard(int unit, 
                                                 bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                                 bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    int nof_drop_prec;
    uint32 relevant_flags;
    int drop_prec[DPP_DEVICE_COSQ_ING_NOF_DP];
    int dp_index;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(data_rate_class);
    BCMDNX_NULL_CHECK(discard);

    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* ECN */
        if (SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        if ((discard->flags & (BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_BUFFER_DESC)) ==
            (BCM_COSQ_DISCARD_BYTES | BCM_COSQ_DISCARD_BUFFER_DESC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid flags parameter 0x%x specified for maximum ECN size.\n"
              "Both of BCM_COSQ_DISCARD_BYTES and BCM_COSQ_DISCARD_BUFFER_DESC cannot be used together."), discard->flags));
        }
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) { 
        /* System RED */
        relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                                           BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK |
                                           BCM_COSQ_DISCARD_PROBABILITY1 | BCM_COSQ_DISCARD_PROBABILITY2 |
                                           BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_SYSTEM | BCM_COSQ_DISCARD_COLOR_ALL);

        if (discard->flags != relevant_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x\n"), unit, discard->flags));
        }

    } else { /* not ECN not system RED */
        relevant_flags = discard->flags & (BCM_COSQ_DISCARD_COLOR_GREEN | BCM_COSQ_DISCARD_COLOR_YELLOW | 
                              BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_BLACK);

        if (!relevant_flags) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no dp 0x%x\n"), unit, discard->flags));
        }

        if (!(discard->flags & BCM_COSQ_DISCARD_BYTES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter no discard type 0x%x\n"), unit, discard->flags));
        }
    }

    if (discard->flags & BCM_COSQ_DISCARD_MARK_CONGESTION) { /* get ECN WRED */
        discard->drop_probability = data_rate_class->ecn_wred_max_probability;
        discard->min_thresh = data_rate_class->ecn_wred_min_avrg_th;
        discard->max_thresh = data_rate_class->ecn_wred_max_avrg_th;
        if (data_rate_class->ecn_wred_enable == SOC_SAND_TRUE) {
            discard->flags |= BCM_COSQ_DISCARD_ENABLE;
        } else {
            discard->flags &= ~BCM_COSQ_DISCARD_ENABLE;
        }
        if (discard->flags & BCM_COSQ_DISCARD_BYTES) {
            discard->ecn_thresh = data_rate_class->ecn_queue_max_size;
        } else if (discard->flags & BCM_COSQ_DISCARD_BUFFER_DESC) {
            discard->ecn_thresh = data_rate_class->ecn_queue_max_size_bds;
        }
        discard->gain = data_rate_class->wred_exp_wq;
    } else if (discard->flags & BCM_COSQ_DISCARD_SYSTEM) {
        /* system RED */
        rc = _bcm_petra_cosq_sys_red_dp_pr_get(unit, data_rate_class, discard);
        BCMDNX_IF_ERR_EXIT(rc);

    } else { /* get regular WRED */
        rc = _bcm_petra_cosq_voq_discard_retrieve_dps(unit,discard->flags,drop_prec,&nof_drop_prec);
        BCMDNX_IF_ERR_EXIT(rc);

        if (nof_drop_prec != 1) {
            /* Nothing to change, just exit */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x, get defined only by one color\n"), unit, discard->flags));
        }
        dp_index = drop_prec[0];

        /* Wred settings is defined by Rate Class profile */
        discard->drop_probability = data_rate_class->wred_max_probability[dp_index];
        discard->min_thresh = data_rate_class->wred_min_avrg_th[dp_index];
        discard->max_thresh = data_rate_class->wred_max_avrg_th[dp_index];
        if (data_rate_class->wred_enable[dp_index] == SOC_SAND_TRUE) {
            discard->flags |= BCM_COSQ_DISCARD_ENABLE;
        }
        discard->gain = data_rate_class->wred_exp_wq;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set WRED configuration
 */

STATIC int
_bcm_petra_cosq_gport_voq_discard_set(int unit, 
                                      bcm_gport_t gport, 
                                      bcm_cos_queue_t cosq, 
                                      bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t exact_data_rate_class;
    bcm_dpp_cosq_rate_class_threshold_info_t update_info;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_PROFILE(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }
 
    rc = _bcm_petra_cosq_gport_discard_verify(unit, discard, 0);
    BCMDNX_IF_ERR_EXIT(rc);

    /* store update information */
    sal_memset(&update_info,0x0,sizeof(update_info));
    sal_memcpy(&update_info.discard, discard,sizeof(*discard));
    update_info.valid_element = BCM_DPP_COSQ_RATE_CLASS_ELEMENT_WRED;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_rate_class_threshold_set(unit, gport, cosq, 
                                                                          &update_info, &exact_data_rate_class));

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Retrieve WRED configuration
 */
STATIC int
_bcm_petra_cosq_gport_voq_discard_get(int unit, 
                                      bcm_gport_t gport, 
                                      bcm_cos_queue_t cosq, 
                                      bcm_cosq_gport_discard_t *discard)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(discard);

    /* Get Rate class data */
    rc = _bcm_petra_cosq_gport_voq_rate_class_data_get(unit, gport, cosq, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_gport_rate_class_data_to_discard(unit, &data_rate_class, discard);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get mapping port to thresh_type
 */
int
_bcm_petra_cosq_egress_thresh_map_get(int unit,
                                      int port,
                                      uint32 *profile)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_PORT_THRESH_TYPE thresh_type = SOC_TMC_EGR_PORT_NOF_THRESH_TYPES;    
    uint32 soc_sand_rc;    
    int    core=0;
    uint32 tm_port;
    BCMDNX_INIT_FUNC_DEFS;

    rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_thresh_type_get,(unit,core,port,&thresh_type)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    *profile = thresh_type;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh entry from hw by profile for ARAD
 */

STATIC int
_bcm_arad_cosq_egress_thresh_entry_get(int unit,
                                       int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    uint32 soc_sand_rc;
    int prio,
        dp,
        threshold_type = profile;
    SOC_TMC_EGR_FC_OFP_THRESH
        fc_ofp_thresh,
        fc_ofp_exact_thresh;
    SOC_TMC_EGR_QUEUING_DEV_TH
        dev_thresh;
    SOC_TMC_EGR_DROP_THRESH
        drop_thresh,
        exact_drop_thresh;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Clear */
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_exact_thresh);
    SOC_TMC_EGR_QUEUING_DEV_TH_clear(&dev_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&exact_drop_thresh);

    /* Get scheduled fc */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit, core, prio, threshold_type, &fc_ofp_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        thresh_info->sch_fc_packet_descriptors_tc[prio] = fc_ofp_thresh.packet_descriptors;
        thresh_info->sch_fc_data_buffers_tc[prio] = fc_ofp_thresh.words;/* queue_words_consumed parameter used for Data buffers in Arad */
        thresh_info->sch_fc_packet_descriptors_min_tc[prio] = fc_ofp_thresh.packet_descriptors_min;
        thresh_info->sch_fc_packet_descriptors_alpha_tc[prio] = fc_ofp_thresh.packet_descriptors_alpha;
        thresh_info->sch_fc_data_buffers_min_tc[prio] = fc_ofp_thresh.data_buffers_min;
        thresh_info->sch_fc_data_buffers_alpha_tc[prio] = fc_ofp_thresh.data_buffers_alpha;
    }
    
    /* Get scheduled drop and unscheduled drop with cosq == -1 */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_dev_get,(unit, core ,&dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* get special values (min, alpha)*/
    if (SOC_IS_JERICHO(unit)) {
        soc_sand_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_sch_unsch_drop_get_unsafe, (unit, core, threshold_type,&dev_thresh));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

    thresh_info->sch_drop_packet_descriptors = dev_thresh.thresh_type[threshold_type].uc.descriptors;
    thresh_info->sch_drop_data_buffers = dev_thresh.thresh_type[threshold_type].uc.buffers;
    thresh_info->unsch_drop_packet_descriptors = dev_thresh.thresh_type[threshold_type].mc_shared.descriptors;
    thresh_info->unsch_drop_packet_descriptors_min = dev_thresh.thresh_type[threshold_type].mc_shared.descriptors_min;
    thresh_info->unsch_drop_packet_descriptors_alpha = dev_thresh.thresh_type[threshold_type].mc_shared.descriptors_alpha;
    thresh_info->unsch_drop_data_buffers = dev_thresh.thresh_type[threshold_type].mc_shared.buffers;
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        thresh_info->unsch_drop_packet_descriptors_available_tc[prio] = dev_thresh.thresh_type[threshold_type].reserved[prio].descriptors;
    }

    /* Port FC Thresholds */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_fc_get,(unit, core, ARAD_EGR_Q_PRIO_ALL, threshold_type, &fc_ofp_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    thresh_info->port_fc_packet_descriptors = fc_ofp_thresh.packet_descriptors;
    thresh_info->port_fc_data_buffers = fc_ofp_thresh.data_buffers;
    thresh_info->port_fc_packet_descriptors_min = fc_ofp_thresh.packet_descriptors_min;
    thresh_info->port_fc_packet_descriptors_alpha = fc_ofp_thresh.packet_descriptors_alpha;
    thresh_info->port_fc_data_buffers_min = fc_ofp_thresh.data_buffers_min;
    thresh_info->port_fc_data_buffers_alpha = fc_ofp_thresh.data_buffers_alpha;


    /* Get scheduled drop */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_get,(unit, prio, &drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        thresh_info->sch_drop_data_buffers_tc[prio] = drop_thresh.queue_words_consumed[threshold_type]; /* queue_words_consumed parameter used for Data buffers in Arad */
        thresh_info->sch_drop_packet_descriptors_tc[prio] = drop_thresh.queue_pkts_consumed[threshold_type];
    } 

    /* Get unscheduled drop */

    for (prio = 0; prio < SOC_TMC_EGR_NOF_Q_PRIO_ARAD; prio++) {
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_get,(unit, core, prio, dp, &drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

            thresh_info->unsch_drop_data_buffers_tc_dp[prio][dp] = drop_thresh.queue_words_consumed[threshold_type];/* queue_words_consumed parameter used for Data buffers in Arad */
            thresh_info->unsch_drop_packet_descriptors_tc_dp[prio][dp] = drop_thresh.queue_pkts_consumed[threshold_type];

            thresh_info->unsch_drop_packet_descriptors_min_tc_dp[prio][dp] = drop_thresh.queue_pkts_consumed_min[threshold_type];
            thresh_info->unsch_drop_packet_descriptors_alpha_tc_dp[prio][dp] = drop_thresh.queue_pkts_consumed_alpha[threshold_type];
        }
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh entry from hw by profile
 */
int
_bcm_petra_cosq_egress_thresh_entry_get(int unit,
                                        int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_arad_cosq_egress_thresh_entry_get(unit, core, profile, thresh_info);
    BCM_IF_ERROR_RETURN(rc);
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_egress_thresh_to_exact_thresh(int unit,
                                         uint32 thresh,
                                         uint32 *exact_thresh)
{
    BCMDNX_INIT_FUNC_DEFS;
    
    BCMDNX_NULL_CHECK(exact_thresh);

    *exact_thresh = thresh;
exit:
BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
STATIC int
_bcm_petra_cosq_egress_thresh_profile_set(int unit,
                                      int port,
                                      int profile)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_PORT_THRESH_TYPE thresh_type;
    uint32 soc_sand_rc;    
    uint32 tm_port;
    int core;

    BCMDNX_INIT_FUNC_DEFS;
    thresh_type = profile;

    rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_ofp_thresh_type_set,(unit, core, tm_port, thresh_type)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data in hw
 */
STATIC int
_bcm_petra_cosq_egress_thresh_profile_data_set(int unit,
                                               int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_arad_cosq_egress_thresh_profile_data_set(unit, core, profile, thresh_info);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data in hw for ARAD
 */
STATIC int
_bcm_arad_cosq_egress_thresh_profile_data_set(int unit,
                                              int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_thresh_key_info_t *thresh_info)
{
    uint32 soc_sand_rc;
    int prio,
        dp,
        threshold_type = profile;
    SOC_TMC_EGR_FC_OFP_THRESH
        fc_ofp_thresh,
        fc_ofp_exact_thresh;
    SOC_TMC_EGR_QUEUING_DEV_TH
        *dev_thresh = NULL;
    SOC_TMC_EGR_DROP_THRESH
        drop_thresh,
        exact_drop_thresh;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_ALLOC(dev_thresh, sizeof(SOC_TMC_EGR_QUEUING_DEV_TH), "_bcm_arad_cosq_egress_thresh_profile_data_set.dev_thresh");
    if (dev_thresh == NULL) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
    }
    /* Clear */
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_thresh);
    SOC_TMC_EGR_FC_OFP_THRESH_clear(&fc_ofp_exact_thresh);
    SOC_TMC_EGR_QUEUING_DEV_TH_clear(dev_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&drop_thresh);
    SOC_TMC_EGR_DROP_THRESH_clear(&exact_drop_thresh);

    /* Set scheduled fc - per Q */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {

            
        fc_ofp_thresh.packet_descriptors = thresh_info->sch_fc_packet_descriptors_tc[prio];
        fc_ofp_thresh.packet_descriptors_min = thresh_info->sch_fc_packet_descriptors_min_tc[prio];
        fc_ofp_thresh.packet_descriptors_alpha = thresh_info->sch_fc_packet_descriptors_alpha_tc[prio];

        fc_ofp_thresh.data_buffers = thresh_info->sch_fc_data_buffers_tc[prio];/* queue_words_consumed parameter used for Data buffers in Arad */
        fc_ofp_thresh.data_buffers_min = thresh_info->sch_fc_data_buffers_min_tc[prio];
        fc_ofp_thresh.data_buffers_alpha = thresh_info->sch_fc_data_buffers_alpha_tc[prio];

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_sched_q_fc_thresh_set, (unit, core, prio, threshold_type, &fc_ofp_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  
    }
    
    /* Port FC Thresholds - flow control*/

    fc_ofp_thresh.packet_descriptors = thresh_info->port_fc_packet_descriptors;
    fc_ofp_thresh.packet_descriptors_min = thresh_info ->port_fc_packet_descriptors_min;
    fc_ofp_thresh.packet_descriptors_alpha = thresh_info->port_fc_packet_descriptors_alpha;

    fc_ofp_thresh.data_buffers = thresh_info->port_fc_data_buffers;
    fc_ofp_thresh.data_buffers_min = thresh_info -> port_fc_data_buffers_min;
    fc_ofp_thresh.data_buffers_alpha = thresh_info -> port_fc_data_buffers_alpha;


    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_sched_port_fc_thresh_set, (unit, core, threshold_type, &fc_ofp_thresh))); 
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    /* Port&Queue Drop thresholds */
     
    dev_thresh->thresh_type[threshold_type].uc.descriptors = thresh_info->sch_drop_packet_descriptors;
    dev_thresh->thresh_type[threshold_type].uc.buffers = thresh_info->sch_drop_data_buffers;
    dev_thresh->thresh_type[threshold_type].mc_shared.descriptors = thresh_info->unsch_drop_packet_descriptors;
    dev_thresh->thresh_type[threshold_type].mc_shared.descriptors_min = thresh_info->unsch_drop_packet_descriptors_min;
    dev_thresh->thresh_type[threshold_type].mc_shared.descriptors_alpha = thresh_info->unsch_drop_packet_descriptors_alpha;
    dev_thresh->thresh_type[threshold_type].mc_shared.buffers = thresh_info->unsch_drop_data_buffers;
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {
        dev_thresh->thresh_type[threshold_type].reserved[prio].descriptors = thresh_info->unsch_drop_packet_descriptors_available_tc[prio];
    }
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_sch_unsch_drop_set, (unit, core, threshold_type, dev_thresh)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* Set scheduled drop */
    for (prio = 0; prio < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO(unit); prio++) {

        drop_thresh.queue_words_consumed[threshold_type] = thresh_info->sch_drop_data_buffers_tc[prio]; 
        drop_thresh.queue_pkts_consumed[threshold_type] = thresh_info->sch_drop_packet_descriptors_tc[prio];

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_sched_drop_set,(unit, core, threshold_type ,prio, &drop_thresh, &exact_drop_thresh)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    } 

    /* Set unscheduled drop */

    for (prio = 0; prio < SOC_TMC_EGR_NOF_Q_PRIO_ARAD; prio++) {
        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++) {

            drop_thresh.queue_words_consumed[threshold_type] = thresh_info->unsch_drop_data_buffers_tc_dp[prio][dp];
            drop_thresh.queue_pkts_consumed[threshold_type] = thresh_info->unsch_drop_packet_descriptors_tc_dp[prio][dp];
            drop_thresh.queue_pkts_consumed_min[threshold_type] = thresh_info->unsch_drop_packet_descriptors_min_tc_dp[prio][dp];
            drop_thresh.queue_pkts_consumed_alpha[threshold_type] = thresh_info->unsch_drop_packet_descriptors_alpha_tc_dp[prio][dp];

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_unsched_drop_set,(unit, core, threshold_type, prio, dp, &drop_thresh, &exact_drop_thresh)));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }

    BCM_EXIT;
exit:
    BCM_FREE(dev_thresh);
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
STATIC int
_bcm_petra_cosq_egress_interface_uc_thresh_profile_set(int unit,
                                                       int core,
                                      soc_port_if_t interface_type,
                                      uint32 internal_interface_id,
                                      int profile)
{
    uint32 soc_sand_rc;    
    
    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_if_uc_map_set, (unit, core, interface_type,internal_interface_id, profile)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data for flow control unicast in hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(int unit,
                                               int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    SOC_TMC_EGR_QUEUING_IF_UC_FC info;
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_QUEUING_IF_UC_FC_clear(&info);

    info.pd_th = thresh_profile->fc_packet_descriptors; 
    info.pd_th_min = thresh_profile->fc_packet_descriptors_min;
    info.pd_th_alpha = thresh_profile->fc_packet_descriptors_alpha;
    info.size256_th = thresh_profile->fc_words_consumed;
    info.size256_th_min = thresh_profile->fc_words_consumed_min;
    info.size256_th_alpha = thresh_profile->fc_packet_descriptors_alpha;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_uc_set,(unit, core, profile, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh_type data for flow control unicast from the hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_uc_thresh_entry_get(int unit,
                                                        int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    SOC_TMC_EGR_QUEUING_IF_UC_FC info;
    
    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_EGR_QUEUING_IF_UC_FC_clear(&info);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_uc_get,(unit, core, profile, &info)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    thresh_profile->fc_packet_descriptors = info.pd_th;
    thresh_profile->fc_packet_descriptors_min = info.pd_th_min;
    thresh_profile->fc_packet_descriptors_alpha = info.pd_th_alpha;    
    thresh_profile->fc_words_consumed = info.size256_th;
    thresh_profile->fc_words_consumed_min = info.size256_th_min;
    thresh_profile->fc_words_consumed_alpha = info.size256_th_alpha;
    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set mapping port to thresh_type in hw
 */
STATIC int
_bcm_petra_cosq_egress_interface_mc_thresh_profile_set(int unit,
                                                       int core,
                                      soc_port_if_t interface_type,
                                      uint32 internal_interface_id,
                                      int profile)
{
    uint32 soc_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_if_mc_map_set, (unit, core, interface_type,internal_interface_id, profile)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get thresh_type data for flow control multicast from the hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_entry_get(int unit,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_mc_get,(unit, profile, &thresh_profile->packet_descriptors)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set thresh_type data for flow control multicast in hw
 */
STATIC int
_bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(int unit,
                                                               int core,
                                               int profile,
                                               bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t *thresh_profile)
{
    uint32  soc_sand_rc;
    
    BCMDNX_INIT_FUNC_DEFS;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_if_fc_mc_set,(unit, core, profile, thresh_profile->packet_descriptors)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose:
 * Add egress thresh information to multiset, 
 * Information by gport,cosq and threshold type. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_thresh_set(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int is_allocated, is_last;
    int template, old_template;
    int core, port;
    SOC_TMC_EGR_Q_PRIO prio;   
    uint32 exact_value, ofp_ndx;
    int start_prio, end_prio;
    soc_port_t lcl_port;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, ofp_ndx, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Old data get */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit, core, port,&thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change data */     
    rc = _bcm_petra_egress_thresh_to_exact_thresh(unit,threshold->value,&exact_value); 
    BCMDNX_IF_ERR_EXIT(rc);

    /* if cosq = -1 then prio is SOC_TMC_EGR_Q_PRIO_ALL */
    /* in this case need to go over all priorities from SOC_TMC_EGR_Q_PRIO_0 to SOC_TMC_EGR_Q_PRIO_7 */
    /* otherwise, need just to configure the selected priority */
    if(prio == SOC_TMC_EGR_Q_PRIO_ALL)
    {
      start_prio = SOC_TMC_EGR_Q_PRIO_0;
      end_prio = SOC_TMC_EGR_Q_PRIO_7;
    }
    else
    {
      start_prio = prio;
      end_prio = prio;
    }
    
    for(prio = start_prio; prio <= end_prio; prio++)
    {
      switch(threshold->type) {
          case bcmCosqThresholdBytes:
              /* FC or drop */
              if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                  thresh_key.sch_fc_words_consumed[prio] = exact_value;
              } else {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      thresh_key.sch_drop_words_consumed[prio] = exact_value;
                  } else {
                      thresh_key.unsch_drop_words_consumed[prio][threshold->dp] = exact_value;
                  }
              }
              break;     
          case bcmCosqThresholdPackets:
              /* Schedule or Unschedule */
              if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                  thresh_key.sch_drop_pkts_consumed[prio] = exact_value;
              } else {
                  thresh_key.unsch_drop_pkts_consumed[prio][threshold->dp] = exact_value;
              }
              break;
          case bcmCosqThresholdPacketDescriptors    :
              /* FC or drop */
              if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                  if(cosq == -1) { /* PORT LEVEL */
                      thresh_key.port_fc_packet_descriptors = exact_value;
                      thresh_key.port_fc_packet_descriptors_min = exact_value;
                      thresh_key.port_fc_data_buffers_alpha = 0;
                  }
                  else
                  { /* QUEUE */
                      thresh_key.sch_fc_packet_descriptors_tc[cosq] = exact_value;
                      thresh_key.sch_fc_packet_descriptors_min_tc[cosq] = exact_value;
                      thresh_key.sch_fc_packet_descriptors_alpha_tc[cosq] = 0;
                  }
              } else {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      if(cosq == -1) {
                          thresh_key.sch_drop_packet_descriptors = exact_value;
                      }
                      else
                      {
                          thresh_key.sch_drop_packet_descriptors_tc[cosq] = exact_value;
                      }
                  } 
                  else /* Multicast queue, drop */
                  {
                      if(cosq == -1) {
                          thresh_key.unsch_drop_packet_descriptors = exact_value;
                          thresh_key.unsch_drop_packet_descriptors_min = exact_value; /* Legacy in jericho */
                          thresh_key.unsch_drop_packet_descriptors_alpha = 0; /* Legacy in jericho */
                      }
                      else
                      {                         
                          
                          thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp] = exact_value;
                          thresh_key.unsch_drop_packet_descriptors_min_tc_dp[cosq][threshold->dp] = exact_value; /* Legacy in jericho */
                          thresh_key.unsch_drop_packet_descriptors_alpha_tc_dp[cosq][threshold->dp] = 0; /* Legacy in jericho */
                      }
                  }
              }
              break;
          case bcmCosqThresholdDataBuffers:
              /* FC or drop */
              if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                  if(cosq == -1) {
                      thresh_key.port_fc_data_buffers = exact_value;
                      thresh_key.port_fc_data_buffers_min = exact_value;
                      thresh_key.port_fc_data_buffers_alpha = 0;
                  }
                  else
                  {
                      thresh_key.sch_fc_data_buffers_tc[cosq] = exact_value;
                      thresh_key.sch_fc_data_buffers_min_tc[cosq] = exact_value;
                      thresh_key.sch_fc_data_buffers_alpha_tc[cosq] = 0;
                  }
              } 
              else
              {
                  /* Schedule or Unschedule */
                  if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                      if(cosq == -1) { 
                          thresh_key.sch_drop_data_buffers = exact_value;
                         
                      }
                      else
                      {
                          thresh_key.sch_drop_data_buffers_tc[cosq] = exact_value;
                      }
                  }
                  else
                  {
                      if(cosq == -1) {
                          thresh_key.unsch_drop_data_buffers = exact_value;
                      }
                      else
                      {
                          thresh_key.unsch_drop_data_buffers_tc_dp[cosq][threshold->dp] = exact_value;
                      }
                  }
              }
              break;
          case bcmCosqThresholdAvailablePacketDescriptors:
              if(cosq < 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("For type bcmCosqThresholdAvailablePacketDescriptors the cosq must be greater or equal to 0\n\r")));
              }
              thresh_key.unsch_drop_packet_descriptors_available_tc[cosq] = exact_value;
              break;
          case bcmCosqThresholdPacketDescriptorsMin:
              if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) 
              {
                  if (cosq == -1)
                  {
                      thresh_key.unsch_drop_packet_descriptors_min = exact_value;
                  }
                  else
                  {
                      thresh_key.unsch_drop_packet_descriptors_min_tc_dp[cosq][threshold->dp] = exact_value;
                  }
              }
              else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.port_fc_packet_descriptors_min = exact_value;
                  }
                  else
                  {
                      thresh_key.sch_fc_packet_descriptors_min_tc[cosq] = exact_value;
                  }
              }
              break;
          case bcmCosqThresholdPacketDescriptorsMax:
              if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.unsch_drop_packet_descriptors = exact_value;
                  }
                  else
                  {
                      thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp] = exact_value;
                  }
              }
              else if (((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)))
              {
                  if (cosq == -1)
                  {
                      thresh_key.port_fc_packet_descriptors = exact_value;
                  }
                  else
                  {
                      thresh_key.sch_fc_packet_descriptors_tc[cosq] = exact_value;
                  }
              }
              break;
          case bcmCosqThresholdPacketDescriptorsAlpha:
              if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.unsch_drop_packet_descriptors_alpha = exact_value;
                  }
                  else
                  {
                      thresh_key.unsch_drop_packet_descriptors_alpha_tc_dp[cosq][threshold->dp] = exact_value;
                  }
              }
              else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
              {
                  if (cosq == -1)
                  {
                      thresh_key.port_fc_packet_descriptors_alpha = exact_value;
                  }
                  else
                  {
                      thresh_key.sch_fc_packet_descriptors_alpha_tc[cosq] = exact_value;
                  }
              }
              break;

        case bcmCosqThresholdDataBuffersMin:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    thresh_key.port_fc_data_buffers_min = exact_value;
                }
                else
                {
                    thresh_key.sch_fc_data_buffers_min_tc[cosq] = exact_value;
                }
            }
            break;
        case bcmCosqThresholdDataBuffersMax:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    thresh_key.port_fc_data_buffers = exact_value;
                }
                else
                {
                    thresh_key.sch_fc_data_buffers_tc[cosq] = exact_value;
                }
            }
            break;
        case bcmCosqThresholdDataBuffersAlpha:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    thresh_key.port_fc_data_buffers_alpha = exact_value;
                }
                else
                {
                    thresh_key.sch_fc_data_buffers_alpha_tc[cosq] = exact_value;
                }
            }
            break;
        default:
              BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
      }
    }

    /* Set new object */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_exchange(unit, core, port,&thresh_key,&old_template,&is_last,&template,&is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if (old_template != template) {
        BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, ofp_ndx, &lcl_port));
        /* Set new profile */
        rc = _bcm_petra_cosq_egress_thresh_profile_set(unit,lcl_port,template);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_allocated) {
        /* Set new data for a specific profile */
        rc = _bcm_petra_cosq_egress_thresh_profile_data_set(unit, core, template,&thresh_key); 
        BCMDNX_IF_ERR_EXIT(rc);
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * get egress thresh information from multiset, 
 * Information by gport,cosq and threshold type. 
 */
STATIC int
_bcm_petra_cosq_gport_egress_thresh_get(int unit,
                                        bcm_gport_t gport,
                                        bcm_cos_queue_t cosq,
                                        bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_thresh_key_info_t thresh_key;
    int core;
    int port;
    SOC_TMC_EGR_Q_PRIO prio;
    uint32 ofp_ndx;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &ofp_ndx, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_tm_to_local_port_get(unit, core, ofp_ndx, &port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit,cosq,&prio);
    BCMDNX_IF_ERR_EXIT(rc);

    if (prio == SOC_TMC_EGR_Q_PRIO_ALL) 
    {
        prio = SOC_TMC_EGR_Q_PRIO_0; /* read just prio 0*/
    }

    /* Data get */
    rc = _bcm_dpp_am_template_cosq_egr_thresh_data_get(unit, core, port ,&thresh_key);
    BCMDNX_IF_ERR_EXIT(rc);

    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                threshold->value = thresh_key.sch_fc_words_consumed[prio];
            } else {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    threshold->value = thresh_key.sch_drop_words_consumed[prio];
                } else {
                    threshold->value = thresh_key.unsch_drop_words_consumed[prio][threshold->dp];
                }
            }
            break;     
        case bcmCosqThresholdPackets:
            /* Schedule or Unschedule */
            if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                threshold->value = thresh_key.sch_drop_pkts_consumed[prio];
            } else {
                threshold->value = thresh_key.unsch_drop_pkts_consumed[prio][threshold->dp];
            }
            break;
        case bcmCosqThresholdPacketDescriptors     :
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                if(cosq == -1) {
                    threshold->value = thresh_key.port_fc_packet_descriptors;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_tc[cosq];
                }
            } else {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    if(cosq == -1) {
                        threshold->value = thresh_key.sch_drop_packet_descriptors;
                    }
                    else
                    {
                        threshold->value = thresh_key.sch_drop_packet_descriptors_tc[cosq];
                    }
                } 
                else
                {
                    if(cosq == -1) {
                        threshold->value = thresh_key.unsch_drop_packet_descriptors;
                    }
                    else
                    {
                        threshold->value = thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp];
                    }
                }
            }
            break;
        case bcmCosqThresholdDataBuffers:
            /* FC or drop */
            if (threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) {
                if(cosq == -1) {
                    threshold->value = thresh_key.port_fc_data_buffers;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_tc[cosq];
                }
            } 
            else
            {
                /* Schedule or Unschedule */
                if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
                    if(cosq == -1) {
                        threshold->value = thresh_key.sch_drop_data_buffers;
                    }
                    else
                    {
                        threshold->value = thresh_key.sch_drop_data_buffers_tc[cosq];
                    }
                }
                else
                {
                    if(cosq == -1) {
                        threshold->value = thresh_key.unsch_drop_data_buffers;
                    }
                    else
                    {
                        threshold->value = thresh_key.unsch_drop_data_buffers_tc_dp[cosq][threshold->dp];
                    }
                }
            }
            break;
        case bcmCosqThresholdAvailablePacketDescriptors:
            threshold->value = thresh_key.unsch_drop_packet_descriptors_available_tc[cosq];
            break;
        case bcmCosqThresholdPacketDescriptorsMin:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_min;
                }
                else
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_min_tc_dp[cosq][threshold->dp];
                }
            }
            else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_packet_descriptors_min;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_min_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdPacketDescriptorsMax:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
            {
                  if (cosq == -1)
                  {
                      threshold->value = thresh_key.unsch_drop_packet_descriptors;
                  }
                  else
                  {
                      threshold->value = thresh_key.unsch_drop_packet_descriptors_tc_dp[cosq][threshold->dp];
                  }
            }
            else if (((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_packet_descriptors;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdPacketDescriptorsAlpha:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_DROP) && BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_alpha;
                }
                else
                {
                    threshold->value = thresh_key.unsch_drop_packet_descriptors_alpha_tc_dp[cosq][threshold->dp];
                }
            }
            else if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_packet_descriptors_alpha;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_packet_descriptors_alpha_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdDataBuffersMin:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_data_buffers_min;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_min_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdDataBuffersMax:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_data_buffers;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_tc[cosq];
                }
            }
            break;
        case bcmCosqThresholdDataBuffersAlpha:
            if ((threshold->flags & BCM_COSQ_THRESHOLD_FLOW_CONTROL) && BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))
            {
                if (cosq == -1)
                {
                    threshold->value = thresh_key.port_fc_data_buffers_alpha;
                }
                else
                {
                    threshold->value = thresh_key.sch_fc_data_buffers_alpha_tc[cosq];
                }
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
STATIC int
_bcm_petra_cosq_ocb_threshold_to_rate_class(int unit, 
                                            bcm_cosq_threshold_t *threshold,
                                            bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_cls)
{
    int tc = threshold->tc;
    int vsq_category = threshold->vsq_category;
    int index, start_index, end_index;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(threshold);
    BCMDNX_NULL_CHECK(data_rate_cls);

    if ((threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0) && (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1))
    {
        start_index = 0;
        end_index = SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS;
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_0)
    {
        start_index = 0;
        end_index = 1;
    }
    else if (threshold->flags & BCM_COSQ_THRESHOLD_RANGE_1)
    {
        start_index = 1;
        end_index = SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS;
    }
    else
    {
        /** if no flag provided - configure both thresholds */
        start_index = 0;
        end_index = SOC_TMC_MGMT_OCB_VOQ_NOF_THRESHOLDS;
    }
 
    switch(threshold->type) {
        case bcmCosqThresholdBytes:
            for (index = start_index; index < end_index; ++index) {
                data_rate_cls->ocb_info[tc][vsq_category].th_words[index] = 
                        threshold->value;
            }
            break;     
        case bcmCosqThresholdDbuffs:
            for (index = start_index; index < end_index; ++index) {
                data_rate_cls->ocb_info[tc][vsq_category].th_buffers[index] = threshold->value;
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));
    }

    if(threshold->flags & BCM_COSQ_THRESHOLD_SET)
    {
        data_rate_cls->ocb_info[tc][vsq_category].voq_eligible = TRUE;
    }
    else if(threshold->flags & BCM_COSQ_THRESHOLD_CLEAR)
    {
        data_rate_cls->ocb_info[tc][vsq_category].voq_eligible = FALSE;
    }

exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: 
 * Set Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    uint32 soc_sand_rc; 
    int core, core_iterator;
       
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_fc_set,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_unicast)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control unscheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    uint32 soc_sand_rc; 
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        if (cosq == -1) /* global */
        {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_fc_set,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_multicast)));
        }
        else /* specific TC */
        {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_tc_fc_set,(unit, core, cosq, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value)));
        }
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control unscheduled pool thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     int pool,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_global_fc_set, (unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_service_pool_0 + pool)));
        BCM_SAND_IF_ERR_EXIT(rc);
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set Egress device wide flow control global thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_all_fc_threshold_set(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
   
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_global_fc_set, (unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_total)));
        BCM_SAND_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    int core, core_iterator;
    uint32 soc_sand_rc;       
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Verify */
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
 
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_fc_get,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_unicast)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }   

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    uint32 soc_sand_rc;       
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Verify */
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        if (cosq == -1) /* global */
        {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_fc_get,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_multicast)));
        }
        else /* specific TC */
        {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_tc_fc_get,(unit, core, cosq, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value))));
        }
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control scheduled thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_pool_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     int pool,
                                                     bcm_cosq_threshold_t *threshold)
{
 
    uint32 soc_sand_rc; 
    int core, core_iterator;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Verify */
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers 
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
 
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_global_fc_get, (unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_service_pool_0 + pool)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
        

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get Egress device wide flow control global thresholds 
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_all_fc_threshold_get(int unit,
                                                     bcm_gport_t gport,
                                                     bcm_cos_queue_t cosq,
                                                     bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdBufferDescriptors)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_global_fc_get, (unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_total)));
        BCM_SAND_IF_ERR_EXIT(rc);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set FC threshold for scheduled traffic per {port,priority}
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersAlpha)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (threshold->flags &  
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    if (cosq != -1 && !(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    /* Make the Update */
    rc = _bcm_petra_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get FC threshold for scheduled traffic per {port,priority}
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_fc_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API\n"), unit));
    }

    if (cosq != -1 && !(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersAlpha)){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (threshold->flags & 
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    /* Get information from SW */
    rc = _bcm_petra_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Set threshold for traffic per interface
 */
STATIC int
_bcm_petra_cosq_gport_interface_egress_threshold_set(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t uc_thresh_key;
    bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t mc_thresh_key;
    int is_allocated, is_last;
    int template, old_template;
    uint32 exact_value;
    uint32 tm_port;
    soc_port_t lcl_port;
    uint32 interface_id_internal;
    soc_port_if_t interface_type;
    int core;      

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdBytes

          || threshold->type == bcmCosqThresholdDataBuffers  
          || threshold->type == bcmCosqThresholdDataBuffersMin 
          || threshold->type == bcmCosqThresholdDataBuffersMax 
          || threshold->type == bcmCosqThresholdDataBuffersAlpha

          || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha    )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if (!(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }


    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL));

    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &lcl_port));

    /*tm port and core to egq interface*/
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port2egress_offset, (unit, core, tm_port, &interface_id_internal)));

    /*port interface type*/
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_interface_type_get(unit, lcl_port, &interface_type));


    /* Change data */     
    rc = _bcm_petra_egress_thresh_to_exact_thresh(unit,threshold->value,&exact_value);
    BCMDNX_IF_ERR_EXIT(rc);

    if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
      if (!(threshold->flags &  BCM_COSQ_THRESHOLD_FLOW_CONTROL )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
      }

      /* Old data get */
        rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_data_get(unit,core ,interface_id_internal,&uc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
        
        switch(threshold->type) {   
          case bcmCosqThresholdBufferDescriptors:
          case bcmCosqThresholdPacketDescriptors     :
            /* Schedule or Unschedule */
            uc_thresh_key.fc_packet_descriptors = exact_value;
            uc_thresh_key.fc_packet_descriptors_min = exact_value;
            uc_thresh_key.fc_packet_descriptors_alpha = 0;

            break;

          case bcmCosqThresholdPacketDescriptorsMin:
            uc_thresh_key.fc_packet_descriptors_min = exact_value;
            break;
          case bcmCosqThresholdPacketDescriptorsMax:
            uc_thresh_key.fc_packet_descriptors = exact_value;
            break;
          case bcmCosqThresholdPacketDescriptorsAlpha:
            uc_thresh_key.fc_packet_descriptors_alpha = exact_value;
            break;
          case bcmCosqThresholdDataBuffers:
          case bcmCosqThresholdBytes:
            uc_thresh_key.fc_words_consumed = exact_value;
            uc_thresh_key.fc_words_consumed_min = exact_value;
            uc_thresh_key.fc_words_consumed_alpha = 0;
            break;
          case bcmCosqThresholdDataBuffersMin:
            uc_thresh_key.fc_words_consumed_min = exact_value;
            break;
          case bcmCosqThresholdDataBuffersMax:
            uc_thresh_key.fc_words_consumed = exact_value;
            break;
          case bcmCosqThresholdDataBuffersAlpha:
            uc_thresh_key.fc_words_consumed_alpha = exact_value;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field\n")));             
        }

        /* Set new object */
        rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_exchange(unit, core, interface_id_internal,&uc_thresh_key,&old_template,&is_last,&template,&is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        if (old_template != template) {
          /* Set new profile */
          rc = _bcm_petra_cosq_egress_interface_uc_thresh_profile_set(unit,core, interface_type, interface_id_internal,template); 
          BCMDNX_IF_ERR_EXIT(rc);
        }

        if (is_allocated) {
          /* Set new data for a specific profile */
          rc = _bcm_petra_cosq_egress_fc_interface_uc_thresh_profile_data_set(unit,core, template,&uc_thresh_key);
          BCMDNX_IF_ERR_EXIT(rc);
        }

    }
    else
    {
      /* Multicast */
      if (!(threshold->flags & BCM_COSQ_THRESHOLD_DROP)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
      }
        rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_data_get(unit,core ,interface_id_internal,&mc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);

        switch(threshold->type) {   
          case bcmCosqThresholdPacketDescriptors     :
            mc_thresh_key.packet_descriptors = exact_value;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
        }

        /* Set new object */
        rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_exchange(unit, core ,interface_id_internal,&mc_thresh_key,&old_template,&is_last,&template,&is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);

        if (old_template != template) {
          /* Set new profile */
          rc = _bcm_petra_cosq_egress_interface_mc_thresh_profile_set(unit,core, interface_type, interface_id_internal, template); 
          BCMDNX_IF_ERR_EXIT(rc);
        }

        if (is_allocated) {
        /* Set new data for a specific profile */
          rc = _bcm_petra_cosq_egress_fc_interface_mc_thresh_profile_data_set(unit,core, template,&mc_thresh_key);
          BCMDNX_IF_ERR_EXIT(rc);
        }

    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get threshold traffic per interface
 */
STATIC int
_bcm_petra_cosq_gport_interface_egress_threshold_get(int unit,
                                                          bcm_gport_t gport,
                                                          bcm_cos_queue_t cosq,
                                                          bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_egress_interface_unicast_thresh_key_info_t uc_thresh_key;
    bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t mc_thresh_key;
    int core;
    soc_port_t lcl_port;
    uint32 tm_port;
    uint32 interface_id_internal;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mc_thresh_key,0x0,sizeof(bcm_dpp_cosq_egress_interface_multicast_thresh_key_info_t));
    /* Verify */
    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    if (!( threshold->type == bcmCosqThresholdDataBuffers  
          || threshold->type == bcmCosqThresholdDataBuffersMin 
          || threshold->type == bcmCosqThresholdDataBuffersMax 
          || threshold->type == bcmCosqThresholdDataBuffersAlpha

          || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha     )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    if (!(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) && !(threshold->flags & BCM_COSQ_THRESHOLD_MULTICAST)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x\n"), unit, threshold->flags));
    }


    if(cosq != -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Cosq should be -1\n"), unit));
    }

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL));

    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, tm_port, &lcl_port));

    /*tm port and core to egq interface*/
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port2egress_offset, (unit, core, tm_port, &interface_id_internal)));

    /* Get information from SW */
    if(threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
      if (!(threshold->flags &  BCM_COSQ_THRESHOLD_FLOW_CONTROL )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
      }
        rc = _bcm_dpp_am_template_cosq_egr_interface_unicast_thresh_data_get(unit, core , interface_id_internal,&uc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
        threshold->value = mc_thresh_key.packet_descriptors;

        switch(threshold->type) {   
          case bcmCosqThresholdBufferDescriptors:
          case bcmCosqThresholdPacketDescriptors     :
            /* Schedule or Unschedule */
            threshold->value = uc_thresh_key.fc_packet_descriptors;
            break;
          case bcmCosqThresholdPacketDescriptorsMin: 
            threshold->value = uc_thresh_key.fc_packet_descriptors_min;
            break;
          case bcmCosqThresholdPacketDescriptorsMax:
            threshold->value = uc_thresh_key.fc_packet_descriptors;
            break;
          case bcmCosqThresholdPacketDescriptorsAlpha:
            threshold->value = uc_thresh_key.fc_packet_descriptors_alpha;
            break;
          case bcmCosqThresholdDataBuffers:
          case bcmCosqThresholdBytes:
            threshold->value = uc_thresh_key.fc_words_consumed;
            break;
          case bcmCosqThresholdDataBuffersMin:
            threshold->value = uc_thresh_key.fc_words_consumed_min;
            break;
          case bcmCosqThresholdDataBuffersMax:
            threshold->value= uc_thresh_key.fc_words_consumed;
            break;
          case bcmCosqThresholdDataBuffersAlpha:
            threshold->value = uc_thresh_key.fc_words_consumed_alpha;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field")));
        }
    }
    else
      {
        if (!(threshold->flags &  BCM_COSQ_THRESHOLD_DROP )) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x\n"), unit, threshold->flags));
        }
        rc = _bcm_dpp_am_template_cosq_egr_interface_multicast_thresh_data_get(unit, core ,interface_id_internal,&mc_thresh_key);
        BCMDNX_IF_ERR_EXIT(rc);
        switch(threshold->type) {   
          case bcmCosqThresholdBufferDescriptors:
          case bcmCosqThresholdPacketDescriptors     :
            threshold->value = mc_thresh_key.packet_descriptors;
            break;
          default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("internal error, no specific field")));
        }
   }


exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of scheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 soc_sand_rc = SOC_SAND_OK;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    /* Check correct threshold types */
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
   
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;
    
    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_drop_set,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_unicast)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);      
    }
          
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 soc_sand_rc = SOC_SAND_OK;
    bcm_error_t rc = BCM_E_NONE;
    int core, core_iterator;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
   
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_drop_set,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_multicast)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of all traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc = SOC_SAND_OK;
    int core_iterator, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }
    
    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_global_drop_set, (unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_total)));     
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);   
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 0 traffic drop threshold set per TC.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc = SOC_SAND_OK;
    int core_iterator, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersAlpha))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if(cosq < 0 || cosq >= ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_sp_tc_drop_set ,(unit, core, cosq, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_service_pool_0 +  sp)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);       
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_tc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc = SOC_SAND_OK;
    int core_iterator, core;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdDataBuffersMin
          || threshold->type == bcmCosqThresholdDataBuffersMax
          || threshold->type == bcmCosqThresholdDataBuffersAlpha))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    if(cosq < 0 || cosq >= ARAD_NOF_TRAFFIC_CLASSES) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid cosq %d\n"), unit, cosq));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_sp_tc_drop_get ,(unit, core, cosq, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_service_pool_0 +  sp)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);       
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
    
/* 
 * Purpose: 
 * Set global configuration of unscheduled service pool 0 traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_set(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{

    uint32 soc_sand_rc = SOC_SAND_OK;
    bcm_error_t rc = BCM_E_NONE;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */
    
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }   

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {      
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_drop_set,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, threshold->value, soc_dpp_cosq_threshold_global_type_service_pool_0 +  sp)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);       
    }

    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_gport_egress_device_mc_sp_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         int sp,
                                                         bcm_cosq_threshold_t *threshold)
{

    uint32 soc_sand_rc = SOC_SAND_OK;
    bcm_error_t rc = BCM_E_NONE;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */
    
    if (!(threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }   

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):BCM_CORE_ALL;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {      
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_drop_get,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_service_pool_0 +  sp)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);       
    }

    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of scheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_uc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 soc_sand_rc = SOC_SAND_OK;
    int core_iterator, core=0;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_drop_get,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_unicast)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);      
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of unscheduled traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_mc_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    uint32 soc_sand_rc = SOC_SAND_OK;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptors     ))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_global_drop_get,(unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_multicast)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);      
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get global configuration of all traffic drop threshold set.
 */
STATIC int
_bcm_petra_cosq_gport_egress_device_all_drop_threshold_get(int unit,
                                                         bcm_gport_t gport,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc = SOC_SAND_OK;
    int core_iterator, core;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    /* Verify */

    if (!(threshold->type == bcmCosqThresholdDataBuffers 
          || threshold->type == bcmCosqThresholdPacketDescriptors     ))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x\n"), unit, threshold->type));
    }

    core_iterator = BCM_COSQ_GPORT_IS_CORE(gport)? BCM_COSQ_GPORT_CORE_GET(gport):0;

    SOC_DPP_CORES_ITER(core_iterator, core)
    {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_egr_queuing_global_drop_get, (unit, core, (soc_dpp_cosq_threshold_type_t)threshold->type, &(threshold->value), soc_dpp_cosq_threshold_global_type_total)));     
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);   
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Purpose: 
 * Set unscheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold-> type == bcmCosqThresholdPacketDescriptorsAlpha)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST ) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unexpected threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    
    if (threshold->flags & (BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unexpected threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    if(cosq != -1 && threshold->type != bcmCosqThresholdAvailablePacketDescriptors && !(threshold->flags & BCM_COSQ_THRESHOLD_PER_DP)){
        /** threshold on available packet descriptors is per queue (cosq != -1) but not per dp */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    if (cosq != -1 && threshold->dp > DPP_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    if (cosq != -1 && !(DPP_COSQ_PB_EGR_PRIO_IS_IN_RANGE(cosq))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d"), cosq));
    }

    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors && cosq == -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("-1 is not valid cosq for the type bcmCosqThresholdAvailablePacketDescriptors")));
    }
    /* SW multiset Update */
    rc = _bcm_petra_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Get scheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (threshold->flags & 
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    /* Get information from SW */
    rc = _bcm_petra_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Purpose: 
 * Set scheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_ucast_egress_queue_drop_threshold_set(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    if (threshold->flags & 
        (BCM_COSQ_THRESHOLD_MULTICAST | BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invald threshold flag %x in this API"), threshold->flags));
    }

    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors || threshold->type == bcmCosqThresholdPacketDescriptors    
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdPacketDescriptors    )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    /* SW multiset Update */
    rc = _bcm_petra_cosq_gport_egress_thresh_set(unit,gport,cosq,threshold);
   
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * Purpose: Conversion from cosq parameter to egress queue id
 */
STATIC int
_bcm_petra_egress_queue_from_cosq(int unit,
                                  int *queue_id,
                                  int cosq)
{
    bcm_error_t rv = BCM_E_NONE;
    
    BCMDNX_INIT_FUNC_DEFS;
    switch (cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *queue_id = 0;
            break;
        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *queue_id = 1;
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            *queue_id = cosq;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }
    
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_egress_cosq_validate(int unit, int cosq)
{
    bcm_error_t rv = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (!( ((cosq >= -1) && (cosq <= 7)) || (cosq == BCM_COSQ_HIGH_PRIORITY) || (cosq == BCM_COSQ_LOW_PRIORITY)))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }
    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_dpp_cosq_internal_priority_get(int unit,
                                    int cosq,
                                    int *priority)
{
    bcm_error_t rv = BCM_E_NONE;
    

    BCMDNX_INIT_FUNC_DEFS;
    switch (cosq) {
        case BCM_COSQ_HIGH_PRIORITY:
        case 0:
            *priority = 0;
            break;

        case BCM_COSQ_LOW_PRIORITY:
        case 1:
            *priority = 1;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported cosq: %d in this API"), unit,cosq));
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:
    BCMDNX_FUNC_RETURN;
}


/*
 * Purpose: 
 * Get unscheduled traffic drop thresholds per port
 */
STATIC int
_bcm_petra_cosq_gport_mcast_egress_queue_drop_threshold_get(int unit,
                                                           bcm_gport_t gport,
                                                           bcm_cos_queue_t cosq,
                                                           bcm_cosq_threshold_t *threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    int max_cosq_num; 

    BCMDNX_INIT_FUNC_DEFS;
    /* Verify */
    if (!(BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Not supported gport in this API"), unit));
    }

    max_cosq_num = DPP_COSQ_PB_EGR_OFP_COSQ_NUM_MAX(unit);

    if (!((cosq >= -1 && cosq <= max_cosq_num) ||
          (cosq >= BCM_COSQ_HIGH_PRIORITY && cosq <= BCM_COSQ_LOW_PRIORITY))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid cosq parameter %d, cosq can be in range of 0-1 or High/Low priorities"), cosq));
    }
    
    if (!(threshold->type == bcmCosqThresholdBytes
          || threshold->type == bcmCosqThresholdPackets
          || threshold->type == bcmCosqThresholdBufferDescriptors 
          || threshold->type == bcmCosqThresholdPacketDescriptors     
          || threshold->type == bcmCosqThresholdDataBuffers
          || threshold->type == bcmCosqThresholdAvailablePacketDescriptors
          || threshold->type == bcmCosqThresholdAvailableDataBuffers 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMin 
          || threshold->type == bcmCosqThresholdPacketDescriptorsMax 
          || threshold->type == bcmCosqThresholdPacketDescriptorsAlpha )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold type parameter 0x%x"), unit, threshold->type));
    }

    if (threshold->flags & BCM_COSQ_THRESHOLD_UNICAST) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unexpected threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    if (threshold->flags & (BCM_COSQ_THRESHOLD_MULTICAST_SP0 | BCM_COSQ_THRESHOLD_MULTICAST_SP1)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unexpected threshold flags parameter 0x%x"), unit, threshold->flags));
    }
    
    if(cosq != -1 && threshold->type != bcmCosqThresholdAvailablePacketDescriptors && !(threshold->flags & BCM_COSQ_THRESHOLD_PER_DP)){
        /** threshold on available packet descriptors is per queue (cosq != -1) but not per dp */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Missing threshold flags parameter 0x%x"), unit, threshold->flags));
    }

    if (threshold->dp > DPP_COSQ_EGR_DP_NUM_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid dp parameter %d"), threshold->dp));
    }

    if(threshold->type == bcmCosqThresholdAvailablePacketDescriptors && cosq == -1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("-1 is not valid cosq for the type bcmCosqThresholdAvailablePacketDescriptors")));
    }

    /* Get information from SW */
    rc = _bcm_petra_cosq_gport_egress_thresh_get(unit,gport,cosq,threshold);
    BCMDNX_IF_ERR_EXIT(rc);
                                                 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Get all info for a specific profile from hw
 */
int
_bcm_petra_cosq_gport_egress_queue_mapping_hw_get(int unit,
                                                  int profile,
                                                  int core,
                                                  bcm_dpp_cosq_egress_queue_mapping_info_t* mapping_info)
{
    bcm_error_t rc = BCM_E_NONE;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE index_type;
    bcm_cos_t index_pri; 
    bcm_color_t index_dp;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    
    BCMDNX_INIT_FUNC_DEFS;

    for (index_type = 0; index_type < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO_MAPPING_TYPES; index_type++) {
        for (index_pri = 0; index_pri < DPP_DEVICE_COSQ_ING_NOF_TC; index_pri++) {
            for (index_dp = 0; index_dp < DPP_DEVICE_COSQ_ING_NOF_DP; index_dp++) {
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_prio_get,(unit, core, index_type, index_pri, index_dp, profile, &egr_prio));
                BCMDNX_IF_ERR_EXIT(rc);

                mapping_info->queue_mapping[index_type][index_pri][index_dp].dp = egr_prio.dp;
                mapping_info->queue_mapping[index_type][index_pri][index_dp].tc = egr_prio.tc;                
            }
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: 
 * Set new profile for egress queue mapping
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_mapping_hw_set(int unit,
                                                  int profile,
                                                  int core,
                                                  CONST bcm_dpp_cosq_egress_queue_mapping_info_t* mapping_info)
{   
    bcm_error_t rc = BCM_E_NONE;
    int index_dp,index_pri,index_type;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;      
    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Run over all data and commit to hw */
    for (index_type = 0; index_type < DPP_DEVICE_COSQ_EGR_NOF_Q_PRIO_MAPPING_TYPES; index_type++) {
        for (index_pri = 0; index_pri < DPP_DEVICE_COSQ_ING_NOF_TC; index_pri++) {
            for (index_dp = 0; index_dp < DPP_DEVICE_COSQ_ING_NOF_DP; index_dp++) {
                egr_prio.dp = mapping_info->queue_mapping[index_type][index_pri][index_dp].dp;
                egr_prio.tc = mapping_info->queue_mapping[index_type][index_pri][index_dp].tc;

                rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_prio_set,(unit, core, index_type, index_pri, index_dp, profile, &egr_prio));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Get mapping egress queue
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_get(int unit,
                                          bcm_gport_t gport,
                                          bcm_cos_t ingress_pri,
                                          bcm_color_t ingress_dp,
                                          bcm_cos_queue_t *offset)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    uint32 tm_port;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));
    SOC_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Validate input params */
    BCMDNX_NULL_CHECK(offset);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Unicast type */
    map_type = SOC_TMC_EGR_UCAST_TO_SCHED;
    *offset = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * init egress port to a specific configuration (out_tc,out_dp)
 */
int
_bcm_petra_cosq_gport_egress_map_init(int unit, bcm_port_t port)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port, nof_priorities;
    int is_last, is_allocated, core;
    int old_profile, new_profile;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    int tc, dp, priority;

    BCMDNX_INIT_FUNC_DEFS;

    rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    /* Get Old data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    for(tc = 0; tc < DPP_DEVICE_COSQ_EGR_NOF_TC ; tc++)
    {
        /*select Q*/
        switch(nof_priorities) {
            case 1:
              priority = 0;
              break;
            case 2:
              priority = (tc<4 ? 0 : 1);
              break;
            case 8:
            default:
              priority = tc;
              break;
        }


        for (dp = 0; dp < DPP_DEVICE_COSQ_EGR_NOF_DP; dp++)
        {
            /* set unsched traffic mapping */
            mapping_info.queue_mapping[SOC_TMC_EGR_MCAST_TO_UNSCHED][tc][dp].dp = dp;
            mapping_info.queue_mapping[SOC_TMC_EGR_MCAST_TO_UNSCHED][tc][dp].tc = priority;

            /* set sched traffic mapping*/
            mapping_info.queue_mapping[SOC_TMC_EGR_UCAST_TO_SCHED][tc][dp].dp = dp;
            mapping_info.queue_mapping[SOC_TMC_EGR_UCAST_TO_SCHED][tc][dp].tc = priority;
        }
    }

    /* Exchange data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Map port to new profile */   
    rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;

}

/* 
 * Purpose:
 * Map egress queue to a specific priority (offset)
 */
STATIC int
_bcm_petra_cosq_gport_egress_queue_map_set(int unit,
                                           bcm_gport_t gport,
                                           bcm_cos_t ingress_pri,
                                           bcm_color_t ingress_dp,
                                           bcm_cos_queue_t offset)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    int is_last,is_allocated;
    int old_profile, new_profile;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    uint32 tm_port;
    SOC_TMC_EGR_Q_PRIO tc;
    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Validate input params */
    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (offset < 0 || offset >= SOC_TMC_EGR_NOF_Q_PRIO_ARAD) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid offset parameter %d"), offset));
    }

    /* Get Old data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change specific entry - preserve dp, change new tc (offset) */
    /* Unicast type and Scheduled to Multicast */
    map_type = SOC_TMC_EGR_UCAST_TO_SCHED;

    rc =  _bcm_petra_cosq_bcm_cosq_to_egr_q_prio(unit, offset, &tc);
    BCMDNX_IF_ERR_EXIT(rc);

    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc = tc;

    /* Exchange data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile,& is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
        }

    /* Map port to new profile */   
    rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);    
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Map egress port to a specific multicast configuration (out_tc,out_dp)
 */
STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 tm_port, nof_priorities;
    int is_last, is_allocated, core;
    int old_profile, new_profile;
    bcm_port_t logical_port;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    int queue_id;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }
  
    if (!(flags == BCM_COSQ_MULTICAST_SCHEDULED)) {        
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (config->scheduled_dp < 0 || config->scheduled_dp > DPP_DEVICE_COSQ_EGR_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid scheduled_dp parameter %d"), config->scheduled_dp));
    }

    rc = _bcm_petra_egress_queue_from_cosq(unit, &queue_id, config->priority);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(bcm_petra_cosq_user_port_get(unit, gport, &logical_port));
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, logical_port, &nof_priorities));
    if (queue_id < 0 || queue_id >= nof_priorities) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid config->priority parameter %d"), queue_id));
    }

    /* Get Old data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Change specific entry - change new tc, new dp (scheduled_tc,scheduled_dp) */
    /* Schedule Multicast type */
    map_type = SOC_TMC_EGR_MCAST_TO_UNSCHED;

    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].dp = config->scheduled_dp;
    mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc = queue_id;

    /* Exchange data */
    rc = _bcm_dpp_am_template_egress_queue_mapping_exchange(unit, tm_port, core, &mapping_info, &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    if(is_allocated) {
        /* Create new profile */    
        rc = _bcm_petra_cosq_gport_egress_queue_mapping_hw_set(unit, new_profile, core, &mapping_info);
        BCMDNX_IF_ERR_EXIT(rc);        
    }

    /* Map port to new profile */   
    rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_egr_q_profile_map_set,(unit, core, tm_port, new_profile));
    BCMDNX_IF_ERR_EXIT(rc);     

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Retrieve specific multicast configuration (out_dp) from port
 */
STATIC int
_bcm_petra_cosq_gport_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    bcm_error_t rc = BCM_E_NONE;
    int core;
    bcm_dpp_cosq_egress_queue_mapping_info_t mapping_info;
    SOC_TMC_EGR_Q_PRIO_MAPPING_TYPE map_type;
    SOC_TMC_EGR_Q_PRIORITY egr_prio;
    uint32 tm_port;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(&mapping_info,0x0,sizeof(bcm_dpp_cosq_egress_queue_mapping_info_t));
    SOC_TMC_EGR_Q_PRIORITY_clear(&egr_prio);

    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (flags & BCM_COSQ_MULTICAST_UNSCHEDULED) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_dpp_am_template_egress_queue_mapping_data_get(unit, tm_port, core, &mapping_info);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Multicast type */
    map_type = SOC_TMC_EGR_MCAST_TO_UNSCHED;
    config->scheduled_dp = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].dp;
    config->priority = mapping_info.queue_mapping[map_type][ingress_pri][ingress_dp].tc;
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Map egress device to a specific multicast configuration (out_tc,out_dp)
 */
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_set(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    uint32 soc_sand_rv;   
    SOC_TMC_EGR_QUEUING_MC_COS_MAP info;
    int core , core_iterator;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate input params */
    BCMDNX_NULL_CHECK(config);
    BCM_DPP_UNIT_CHECK(unit);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (!(flags & BCM_COSQ_MULTICAST_UNSCHEDULED)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (config->unscheduled_se < 0 || config->unscheduled_se > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid unscheduled_se parameter %d"), config->unscheduled_se));
    }

    if (config->unscheduled_sp < 0 || config->unscheduled_sp > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid unscheduled_sp parameter %d"), config->unscheduled_sp));
    }

    if (gport == 0)
    {
        core_iterator = 0;
    }
    else if (BCM_COSQ_GPORT_IS_CORE(gport))
    {
        core_iterator = BCM_COSQ_GPORT_CORE_GET(gport);
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalide gport type %d"), gport));
    }
      
    BCM_DPP_CORES_ITER(core_iterator, core)
    {
        /* Get Old data */
        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_get,(unit, core, ingress_pri, ingress_dp, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

    
        info.tc_group = config->priority;
        info.pool_eligibility = config->unscheduled_se;
        info.pool_id = config->unscheduled_sp;

        /* Set data */
        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_set,(unit, core, ingress_pri, ingress_dp, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose:
 * Retrieve specific multicast configuration (out_dp) from port
 */
STATIC int
_bcm_petra_cosq_device_egress_multicast_config_get(int unit,
                                                  bcm_gport_t gport,
                                                  bcm_cos_t ingress_pri,
                                                  bcm_color_t ingress_dp,
                                                  uint32 flags,
                                                  bcm_cosq_egress_multicast_config_t *config)
{
    uint32 soc_sand_rv;   
    SOC_TMC_EGR_QUEUING_MC_COS_MAP info;
    int core, core_iterator;

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate input params */
    BCMDNX_NULL_CHECK(config);

    if (ingress_pri < 0 || ingress_pri >= DPP_DEVICE_COSQ_ING_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_pri parameter %d"), ingress_pri));
    }

    if (ingress_dp < 0 || ingress_dp >= DPP_DEVICE_COSQ_ING_NOF_DP) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid ingress_dp parameter %d"), ingress_dp));
    }

    if (!(flags == BCM_COSQ_MULTICAST_UNSCHEDULED)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag parameter %08X"), flags));
    }

    if (gport == 0)
    {
        core_iterator = 0;
    }
    else if (BCM_COSQ_GPORT_IS_CORE(gport))
    {
        core_iterator = BCM_COSQ_GPORT_IS_CORE(gport);
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalide gport type %d"), gport));
    }

    BCM_DPP_CORES_ITER(core_iterator, core)
    {

        /* Get Old data */
        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_egr_queuing_mc_cos_map_get,(unit, core, ingress_pri, ingress_dp, &info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->priority = info.tc_group;
        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->unscheduled_se = info.pool_eligibility;
        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        config->unscheduled_sp = info.pool_id;
        BCM_EXIT;
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose: Set tc packet to FMQ queue mapping
 * Valid when enhance is disable 
 */
STATIC int
_bcm_petra_cosq_fmq_mapping_set(int unit, 
                                bcm_port_t port,
                                int count,
                                bcm_cos_t *priority, 
                                bcm_cos_queue_t *cosq)
{
    SOC_TMC_TR_CLS tc;
    SOC_TMC_MULT_FABRIC_CLS fabric_cls;
    uint32 soc_sand_rv; 
    int i;
    int used_priority[DPP_COSQ_PACKET_NOF_TC] = {0};

    BCMDNX_INIT_FUNC_DEFS;
    /* Validate */
    if (!BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
    }

    if (count <= 0 || count > DPP_COSQ_PACKET_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid count parameter %d"), unit, count));
    }

    for (i = 0; i < count; i++)
    {
        if (priority[i] < 0 || priority[i] >= DPP_COSQ_PACKET_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority[i]));
        }
        tc = priority[i];

      if (used_priority[tc])
      {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Priority %d is mapped several times"), unit, tc));

      }
      used_priority[tc] = 1;

      if (cosq[i] < 0 || cosq[i] > DPP_COSQ_FMQ_MAX_CLS_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq[i]));
        }
    }

    for (i = 0; i < count; i++)
    {
        tc = priority[i];
        fabric_cls = cosq[i];

        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_traffic_class_to_multicast_cls_map_set,(unit,tc,fabric_cls)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * Purpose : retrieve FMQ queue mapping from packet TC.
 * Valid when enhance is disable 
 */
STATIC int
_bcm_petra_cosq_fmq_mapping_get(int unit,
                                bcm_port_t port,
                                int count,
                                bcm_cos_t *priority,
                                bcm_cos_queue_t *cosq)
{
    SOC_TMC_TR_CLS tc;
    SOC_TMC_MULT_FABRIC_CLS fabric_cls = 0;
    uint32 soc_sand_rv;
    int i;

    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(cosq);

    /* Validate */
    if (!BCM_COSQ_GPORT_IS_FMQ_ROOT(port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
    }

    if (count <= 0 || count > DPP_COSQ_PACKET_NOF_TC) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid count parameter %d"), unit, count));
    }

    for (i = 0; i < count; i++)
    {
        if (priority[i] < 0 || priority[i] >= DPP_COSQ_PACKET_NOF_TC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority[i]));
        }
    }
 
    for (i = 0; i < count; i++)
    {
        tc = priority[i];
        soc_sand_rv = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_traffic_class_to_multicast_cls_map_get,(unit,tc,&fabric_cls)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rv);

        cosq[i] = fabric_cls;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_e2e_hr_modify(int unit, bcm_gport_t port, int numq, uint32 flags, bcm_gport_t *gport, int is_composite, int is_dual, int hr_mode)
{
    bcm_error_t              rc = BCM_E_NONE;
    bcm_gport_t              port_gport;
    uint32                   fap_port;
    SOC_TMC_SCH_SE_ID        se_id;
    uint32                   soc_sand_rc;    
    SOC_TMC_SCH_PORT_INFO    port_info;
    SOC_TMC_SCH_SE_INFO      se_info;
    SOC_TMC_SCH_FLOW         sch_flow, exact_sch_flow;
    int                      hr_class, old_profile, is_last, profile, is_allocated, flow_id, core;
    bcm_cos_queue_t          cosq;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_SCH_PORT_INFO_clear(&port_info);
    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(unit,&sch_flow);
    SOC_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);


    if ( !( BCM_COSQ_GPORT_IS_E2E_PORT((*gport)) || BCM_COSQ_GPORT_IS_FMQ_CLASS((*gport)) || BCM_COSQ_GPORT_IS_ISQ_ROOT((*gport)) ||
            (BCM_COSQ_GPORT_IS_E2E_PORT_TC((*gport)) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) )) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport 0x%x, modify only supported for e2e ports"), unit, (*gport)));
    }

    if ( (is_composite) || (is_dual) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, is not supported for dual and composite, is_composite: %d, is_dual: %d"), unit,is_composite, is_dual));
    }

    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, (*gport), 0, &port_gport);
    BCMDNX_IF_ERR_EXIT(rc);
    if ( !(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport) || BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) ) {
         BCMDNX_IF_ERR_EXIT(rc); /* does nothing */
    }

    /* Verify PORT-TC */
    if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) {
        rc = _bcm_petra_cosq_port_priority_validate(unit,port_gport,numq);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        /* Verify numq */
        if (numq != 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
        }
    }

    /* numq determine cosq index.
     * In case of E2E gport - numq = 0 (Petra-B compatbility).
     * In case of Port TC: numq = priority_ndx
     */
    cosq = (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) ? DPP_COSQ_PB_DEFAULT_PORT_TC:numq;

    if (BCM_COSQ_GPORT_IS_FMQ_CLASS((*gport)) || BCM_COSQ_GPORT_IS_ISQ_ROOT((*gport))) {
        {
            rc = _bcm_petra_cosq_core_get(unit, *gport, 0, &core) ;
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                      "failed to get core for *gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)*gport, (unsigned long)rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
            fap_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);
            rc = _bcm_petra_cosq_port2se_id(unit,core,fap_port,cosq,&se_id);            
            if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(port_gport)) {          
            fap_port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(port_gport);
            rc = _bcm_petra_cosq_port2se_id(unit,core,fap_port,cosq,&se_id);            
            if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving seId for fapPort(%d)\n"), unit, fap_port));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        } else {
            flow_id = BCM_GPORT_SCHEDULER_GET(port_gport);
            se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));
            if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
                BCMDNX_IF_ERR_EXIT(BCM_E_INTERNAL);
            }
        }

        /* configure scheduler element */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }

        se_info.type_info.hr.mode = hr_mode;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }
    else {
        rc = _bcm_petra_cosq_fap_port_get(unit, port_gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, got invalid fap port %d,  for port (0x%x)"), unit, fap_port, port));
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_get,(unit, core, fap_port, &port_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retreiving scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
        if (SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.hr_modes[cosq] = hr_mode;
        } else {
            port_info.hr_mode = hr_mode;
        }

        /* Port-TC feature: no need to support HR flow control class. since for each HR there is respective flow control priority */
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.hr_fc_default_template_data.get(unit, &hr_class));
            port_info.lowest_hp_class = hr_class;

            /* set default flow control mapping. It is a default profile that is always allocated */
            rc = _bcm_dpp_am_template_cosq_port_hr_fc_exchange(unit, core, fap_port, &hr_class, &old_profile, &is_last, &profile, &is_allocated);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler info port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_EXIT;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_hr_mode_get(int unit, uint32 flags, int *hr_mode)
{
    bcm_error_t              rc = BCM_E_NONE;
    int                      hr_mode_mask;


    BCMDNX_INIT_FUNC_DEFS;

    hr_mode_mask = flags & DPP_DEVICE_COSQ_HR_MASK;
    switch (hr_mode_mask) {
        case BCM_COSQ_GPORT_SCHEDULER_HR_DUAL_WFQ:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_DUAL_WFQ;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_HR_ENHANCED:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_HR_SINGLE_WFQ:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;
            break;
        default:
            (*hr_mode) = SOC_TMC_SCH_HR_MODE_NONE;
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid hr mode flags parameter 0x%x\n"), unit, hr_mode_mask));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_hr_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual)
{
    bcm_error_t              rc = BCM_E_NONE;
    uint32                   soc_sand_rc;
    SOC_TMC_SCH_FLOW           flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO        se_config;
    SOC_TMC_SCH_SE_ID          se_index;    
    uint32                   relevant_flags, res_flags = 0;
    int                      hr_mode, core ;
    int                      flow_id = -1, comp_flow_id;


    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    {
        rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_HR_MASK | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    rc = _bcm_petra_cosq_sched_hr_mode_get(unit, relevant_flags, &hr_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* handle BCM_COSQ_GPORT_REPLACE - for e2e ports only */
    if (flags & BCM_COSQ_GPORT_REPLACE) {
        rc = _bcm_petra_cosq_sched_e2e_hr_modify(unit, port, numq, flags, gport, is_composite, is_dual, hr_mode);
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }
    
    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DPP_AM_FLAG_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, flow_id);
        }
        se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));
        if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, flow_id));
        }

        /* validate flow id */
        if (!ARAD_SCH_SE_IS_HR(se_index)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE-HR"), unit, flow_id));
        }
    }

    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, 1, res_flags, is_composite, FALSE, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_composite) { /* adjustment for low level allocation of 2 resources */
        rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_HR, FALSE, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* initialize se */
    se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit %d, hr resource gport_add, flow_id (%d/0x%x) se_index(%d/0x%x\n"), 
                          unit, flow_id, flow_id, se_index, se_index));

    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, hr resource gport_add, is_composite(%s) is_dual(%s)\n"), unit, 
                            (is_composite==1) ? "TRUE":"FALSE",
                 (is_dual==1) ? "TRUE":"FALSE"));

    SOC_TMC_SCH_FLOW_clear(unit,&flow_config);

    flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[0].credit_source.id)));

    LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                            "unit %d, hr resource gport_add, subflow 0 credit source se_type(%d) sp_class(%d) id(%d))\n"), unit,
                            flow_config.sub_flow[0].credit_source.se_type, flow_config.sub_flow[0].credit_source.se_info.hr.sp_class,
                 flow_config.sub_flow[0].credit_source.id));

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[1].credit_source.id)));
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = SOC_TMC_SCH_SE_TYPE_HR;
    se_config.type_info.hr.mode = hr_mode;
    se_config.is_dual = FALSE;
    se_config.group = SOC_TMC_SCH_GROUP_AUTO;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "hr", soc_sand_rc, rc));
        goto err;
    }

    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_GPORT_SCHEDULER_CORE_SET((*gport), flow_id, core);
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
       if(unit >=0 && unit < BCM_LOCAL_UNITS_MAX) {
            bcm_dpp_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, FALSE, is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_cl_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual,
                         int is_cl_hr)
{
    bcm_error_t                      rc = BCM_E_NONE;
    uint32                           soc_sand_rc;
    SOC_TMC_SCH_FLOW                     flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO                  se_config;
    SOC_TMC_SCH_SE_ID                    se_index, dual_se_index = 0;    
    int                              is_enhanced = FALSE, hr_mode;
    uint32                           relevant_flags, res_flags = 0, enhanced_mask;
    int                              flow_id = -1, comp_flow_id, dual_flow_id, flow_region;
    int                              cl_mode = 0, enhanced_mode = 0, weight_mode = 0, cid;
    bcm_dpp_cosq_sched_class_data_t  class_data;
    int                              class_flags = BCM_DPP_AM_TEMPLATE_FLAG_ALLOC_WITH_ID;
    int                              is_allocated, class_template;
    int                              is_odd_even;
    int                              is_cl_cir;
    uint8                            is_interdigitated;
    int                              core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    relevant_flags = flags & ( (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_CL_MASK | BCM_COSQ_GPORT_COMPOSITE |
        DPP_DEVICE_COSQ_CL_ENHANCED_MASK | DPP_DEVICE_COSQ_DUAL_SHAPER_MASK |
        DPP_DEVICE_COSQ_CL_WFQ_MASK | BCM_COSQ_GPORT_WITH_ID) | (DPP_DEVICE_COSQ_FQ_MASK) | (DPP_DEVICE_COSQ_HR_MASK) );

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    enhanced_mask = flags & DPP_DEVICE_COSQ_CL_ENHANCED_MASK;
    switch (enhanced_mask) {
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ:
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ:
            is_enhanced = TRUE;
            break; 
        default:
            is_enhanced = FALSE;
            break; 
    }

    if ( (is_enhanced == TRUE) && ( (is_composite == TRUE) || (is_dual == TRUE) ) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Enhanced cl configuration and composite/dual can not be together specified"), unit));
    }

    /* consistency checks */
    rc = _bcm_petra_cosq_sched_cl_verify_flags_mode_get(unit, flags, &cl_mode, &enhanced_mode, &weight_mode);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, cl element flags not correct, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (is_cl_hr) {
        rc = _bcm_petra_cosq_sched_hr_mode_get(unit, relevant_flags, &hr_mode);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DPP_AM_FLAG_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, flow_id);
        }
        se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit, mbcm_dpp_sch_flow2se_id, (unit, flow_id))); 
        if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }
        /* validate flow id */
        /* The macro ARAD_SCH_SE_IS_CL may be used for signed varibles also */
        /* coverity[unsigned_compare : FALSE] */
        if (!ARAD_SCH_SE_IS_CL(se_index)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE-CL\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }
    }

    if (is_cl_hr) {
        rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, 1, res_flags, is_composite, FALSE, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    else {
        /* allocate flow */
        rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, SOC_TMC_COSQ_ANY_NOF_REMOTE_CORES, res_flags, is_composite, is_enhanced, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_CL, NULL, &flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    if (is_composite) {
        flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(flow_id);
        rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even, &is_cl_cir);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, connector region configuration get, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_CL, is_odd_even, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    if (is_dual) {
        rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_CL, TRUE, &dual_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl se failure in getting dual flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* get cid */
    rc = _bcm_petra_sched_cl_profile_get(unit, cl_mode, enhanced_mode, weight_mode, TRUE, &cid);
    if (rc != BCM_E_NONE) {
        goto err;
    }

    /* initialize se */
    se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));
    if (is_dual) {
        dual_se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, dual_flow_id)));
    }

    SOC_TMC_SCH_FLOW_clear(unit, &flow_config);

    flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[0].credit_source.id)));

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit,core, &(flow_config.sub_flow[1].credit_source.id)));
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = SOC_TMC_SCH_SE_TYPE_CL;
    se_config.type_info.cl.id = cid;
    se_config.is_dual = is_dual;
    se_config.group = SOC_TMC_SCH_GROUP_AUTO;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "cl", soc_sand_rc, rc));
        goto err;
    }

    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_GPORT_SCHEDULER_CORE_SET((*gport), flow_id, core);

    /* Update reference count */
    /* retrieve current template data */
    rc = _bcm_dpp_am_template_cosq_sched_class_data_get(unit, core, cid, (int *)&class_data);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving SE(%d) class data cid(%d), error 0x%x\n"), unit, se_index, cid, rc));
        goto err;
    }

    class_template = cid;
    rc = _bcm_dpp_am_template_cosq_sched_class_allocate(unit, core, class_flags, (int *)&class_data, &is_allocated, &class_template);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in incrementing reference count for class template cid(%d), error 0x%x\n"), unit, cid, rc));
        goto err;
    }

    if (is_dual) {
        flow_config.sub_flow[0].id = dual_flow_id;

        se_config.id = dual_se_index;
        se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
        if (is_cl_hr) {
            se_config.type = SOC_TMC_SCH_SE_TYPE_HR;
            se_config.type_info.hr.mode = hr_mode;
        }
        else {
            se_config.type = SOC_TMC_SCH_SE_TYPE_FQ;
            se_config.type_info.fq.no_info = 0;
        }
        se_config.is_dual = is_dual;
        se_config.group = SOC_TMC_SCH_GROUP_AUTO;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, dual_se_index, &se_config, &flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "fq", soc_sand_rc, rc));
            goto err;
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
        bcm_dpp_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, is_enhanced, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_CL, flow_id);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_fq_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport,
                         int is_composite,
                         int is_dual)
{
    bcm_error_t              rc = BCM_E_NONE;
    uint32                   soc_sand_rc;
    SOC_TMC_SCH_FLOW           flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO        se_config;
    SOC_TMC_SCH_SE_ID          se_index;    
    uint32                   relevant_flags, res_flags = 0;
    int                      flow_id = -1, comp_flow_id, core ;

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_FQ_MASK | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DPP_AM_FLAG_ALLOC_WITH_ID;
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, flow_id);
        }
        se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));
        if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }

        /* validate flow id */
        if (!ARAD_SCH_SE_IS_FQ(se_index)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid flow 0x%x specified - does not correspond to SE-FQ\n"), unit, flow_id));
            BCM_ERR_EXIT_NO_MSG(BCM_E_PARAM);
        }

    }

    /* allocate flow */
    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, SOC_TMC_COSQ_ANY_NOF_REMOTE_CORES, res_flags, is_composite, FALSE, is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_FQ, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, fq se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (is_composite) { /* adjustment for low level allocation of 2 resources */
        rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_FQ, FALSE, &comp_flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, fq se failure in getting composite flow, error 0x%x\n"), unit, rc));
            goto err;
        }
    }

    /* initialize se */
    se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));

    SOC_TMC_SCH_FLOW_clear(unit, &flow_config);

    flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
    flow_config.is_slow_enabled = FALSE;
    flow_config.sub_flow[0].is_valid = TRUE;
    flow_config.sub_flow[0].id = flow_id;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit,core, &(flow_config.sub_flow[0].credit_source.id)));

    if (is_composite == TRUE) {
        flow_config.sub_flow[1].is_valid = TRUE;
        flow_config.sub_flow[1].id = comp_flow_id;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[1].credit_source.id)));
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_config);
    se_config.id = se_index;
    se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_config.type = SOC_TMC_SCH_SE_TYPE_FQ;
    se_config.type_info.fq.no_info = 0;
    se_config.is_dual = FALSE; /* Always set with CL element */
    se_config.group = SOC_TMC_SCH_GROUP_AUTO;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "fq", soc_sand_rc, rc));
        goto err;
    }

    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_GPORT_SCHEDULER_CORE_SET((*gport), flow_id, core);
    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (flow_id != -1) {
        bcm_dpp_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, FALSE, is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_FQ, flow_id);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_gport_add(int unit,
                         bcm_gport_t port,
                         int numq,
                         uint32 flags,
                         bcm_gport_t *gport)
{
    bcm_error_t                 rc = BCM_E_NONE;
    uint32                      resource_count = 0;
    int                         is_hr = FALSE, is_cl = FALSE, is_fq = FALSE, is_cl_fq = FALSE, is_cl_hr = FALSE;
    uint32                      relevant_flags, fap_port;
    int                         shaper_mask;
    int                         is_composite, is_dual = FALSE;
    int                         flow_id = 0, sf2_id = 0, se_index, core;
    SOC_TMC_SCH_SE_ID           se_id;
    int                         dual_flow_id, dual_se_index;
    bcm_gport_t                 alternate_gport;
    bcm_cos_queue_t             cosq = 0;
    int                         is_reserved;
    int                         sched_id = 0;

    BCMDNX_INIT_FUNC_DEFS;

    rc = _bcm_petra_cosq_core_get(unit, port, 0, &core) ;
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
            (BSL_META_U(unit,
                "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* basic consistency checks */

    if (gport == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error gport is NULL"), unit));
    }

    relevant_flags = flags & (BCM_COSQ_GPORT_SCHEDULER | DPP_DEVICE_COSQ_HR_MASK | DPP_DEVICE_COSQ_CL_MASK | DPP_DEVICE_COSQ_FQ_MASK | BCM_COSQ_GPORT_COMPOSITE | DPP_DEVICE_COSQ_CL_ENHANCED_MASK | DPP_DEVICE_COSQ_DUAL_SHAPER_MASK | DPP_DEVICE_COSQ_CL_WFQ_MASK | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);

    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    
    if (flags & DPP_DEVICE_COSQ_CL_MASK) {
        is_cl = TRUE;
        resource_count++;
    }
    if (flags & DPP_DEVICE_COSQ_FQ_MASK) {
        is_fq = TRUE;
        resource_count++;
    }
    if (flags & DPP_DEVICE_COSQ_HR_MASK) {
        is_hr = TRUE;
        resource_count++;
    }
    if ((resource_count == 2) && (is_cl == TRUE) && (is_fq == TRUE)) {
        is_cl_fq = TRUE;
        resource_count--; /* consider it one resource of a cl_fq type */
    }
    else if ((resource_count == 2) && (is_cl == TRUE) && (is_hr == TRUE)) {
        is_cl_hr = TRUE;
        resource_count--; /* consider it one resource of a cl_hr type */
    }

    if (resource_count > 1) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid resource flags 0x%x - only one resource can be allocated, number resources specified %d"), unit, flags, resource_count));
    }
                 
    is_composite = (relevant_flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
    shaper_mask = relevant_flags & DPP_DEVICE_COSQ_DUAL_SHAPER_MASK;
    if (shaper_mask) {
        switch (shaper_mask) {
            case BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER:
                is_dual = TRUE;
                break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid Shaper flags 0x%x\n"), unit, shaper_mask));
                break;
        }
    }

    if ( (is_dual) && (is_cl == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, dual Shaper configuration requires specifing a CL scheduler element\n"), unit));
    }

    /* if cl and fq were both specified make sure that dual shaper is specified */
    if ( (is_cl_fq) && (is_dual == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, specifing both CL and FQ scheduling element also requires specifing dual Shaper configuration\n"), unit));
    }

    /* if cl and hr were both specified make sure that dual shaper is specified */
    /* In order to support {cl, hr} configuration it is necessary to specify    */
    /* {sched, cl, hr, dual} flags. This s unlike {cl, fq} configuration where  */
    /* {fq} flag need not be specified. Thus fq is assumed to be default mode   */
    /* for dual configuration and fq scheduler does not require any additional  */
    /* qualifier.                                                               */
    if ( (is_cl_hr) && (is_dual == FALSE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, specifing both CL and HR scheduling element also requires specifing dual Shaper configuration\n"), unit));
    }

    if ( (is_composite == TRUE) && (is_dual == TRUE) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, composite and dual Shaper configuration cannot be specified at same time\n"), unit));
    }

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        if (!(BCM_GPORT_IS_SCHEDULER(*gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport (0x%x) corresponding to _WITH_ID flags specified \n"), unit, (*gport)));
        }

    }
    /* Verify numq for other scheduler elements other than HRs */
    if ((is_cl_fq) || (is_cl) || (is_fq) || (is_cl_hr)) {
        if (numq != 1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d\n"), unit, flags));
        }
    }

    if ((is_cl_fq) || (is_cl) || (is_cl_hr)) {
        rc = _bcm_petra_cosq_sched_cl_add(unit, port, numq, flags, gport, is_composite, is_dual, is_cl_hr);
    }
    else if (is_fq) {
        rc = _bcm_petra_cosq_sched_fq_add(unit, port, numq, flags, gport, is_composite, is_dual);
    }
    else if (is_hr) {
        rc = _bcm_petra_cosq_sched_hr_add(unit, port, numq, flags, gport, is_composite, is_dual);
    }
    else {
        rc = BCM_E_PARAM;
    }

    if (rc != BCM_E_NONE) {
        goto err;
    }

    /* allocate resource for flow */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, (*gport), 0, &alternate_gport);
    BCMDNX_IF_ERR_EXIT(rc);

    if (BCM_GPORT_IS_SCHEDULER(alternate_gport)) {
        flow_id = BCM_GPORT_SCHEDULER_GET(alternate_gport);
        if (SOC_IS_QAX(unit)) {
            /*
             * If sched_id > max_flows it means that it is a fmq_class,
             * so no need to add offset to flow_id, because flow_id already
             * comes with the offset.
             */
            sched_id = BCM_GPORT_SCHEDULER_GET(*gport);
            if (sched_id < DPP_COSQ_SCH_MAX_FLOW_ID(unit)) {
                flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, flow_id);
            }
        }
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(alternate_gport) ||
             (BCM_COSQ_GPORT_IS_E2E_PORT_TC(alternate_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable)) {

        /* numq determine cosq index.
         * In case of E2E gport - numq = 1 (Petra-B compatbility) => cosq = 0.
         * In case of Port TC: cosq = numq 
         */
        cosq = (BCM_COSQ_GPORT_IS_E2E_PORT(alternate_gport)) ? DPP_COSQ_PB_DEFAULT_PORT_TC:numq;

        rc = _bcm_petra_cosq_fap_port_get(unit, alternate_gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), alternate_gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* verify priority */
        if (BCM_COSQ_GPORT_IS_PORT_TC(alternate_gport) && SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            rc = _bcm_petra_cosq_port_priority_validate(unit,alternate_gport,cosq);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "verify failed for gport: 0x%x, cosq %d error(0x%x)\n"), alternate_gport, cosq, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
       
        rc = _bcm_petra_cosq_port2se_id(unit,core,fap_port,cosq,&se_id);
        if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE for port %d"), unit, fap_port));
        }

        flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation) {
        /*
         * If this is a 'replace' operation then delete flow id from data base (if
         * it is there).
         */
        if (flags & BCM_COSQ_GPORT_REPLACE) {
            bcm_petra_vig_delete_this_flow(unit, core, Vig_db[unit], flow_id) ;
        }
    }
/* } */
#endif

    se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));
    if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, flow_id));
    }

    rc = _bcm_petra_cosq_is_se_reserved(unit,core,se_index,&is_reserved);
    if (rc != BCM_E_NONE){
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "failed to get reserved se: 0x%x, error(0x%x)\n"), se_index, rc));
         goto err;
    }

    if (!(flags & BCM_COSQ_GPORT_REPLACE ) || (!is_reserved)) { /* Allocate SW DB in case of REPLACE is unset (allocate new SE) or SE is not a reserved SE. */
        /* initialize SE state */

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, se_index, DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));

        /* need to take care of dual shaper allocation case */
        if (is_dual) {
            rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &dual_flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, cl se failure in getting dual flow(%d), error 0x%x\n"), unit, flow_id, rc));
                goto err;
            }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation) {
                /*
                 * If this is a 'replace' operation then delete flow id from data base (if
                 * it is there).
                 */
                if (flags & BCM_COSQ_GPORT_REPLACE) {
                    bcm_petra_vig_delete_this_flow(unit, core, Vig_db[unit], dual_flow_id) ;
                }
            }
/* } */
#endif
            dual_se_index = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, dual_flow_id)));
            if (dual_se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flow 0x%x specified - does not correspond to SE"), unit, dual_flow_id));
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, dual_se_index, DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));

        }

        /* initialize coresponding flow state */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));


        /* allocate resource for sub-flow 2 */
        if ( (is_composite) || (is_dual) ) {
            if (is_composite) {
                rc = _bcm_petra_se_composite_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            }
            if (is_dual) {
                rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            }


            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Unit(%d) failed to get sub-flow 2 for flow_id(%d)\n"), unit, sf2_id));
                goto err;
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, sf2_id, 0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, sf2_id, BCM_COSQ_SP0));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    BCMDNX_IF_ERR_EXIT(rc);
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_connector_gport_add(int unit,
                                    int core,
                                    int src_modid,
                                    uint32 nof_remote_cores,
                                    bcm_gport_t port,
                                    int numq,
                                    uint32 flags,
                                    bcm_gport_t *gport)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    uint32 relevant_flags;
    int is_non_contiguous;
    int is_composite;
    int flow_id = -1;
    int res_flags = 0;
    int cur_flow_id, cur_connector, cur_comp_flow_id, flow_id_i;   
    SOC_TMC_SCH_FLOW flow_config, exact_flow_config;
    bcm_gport_t ingr_port;
    uint8 src_modid_uint8[sizeof(int)];
    uint32 byte_data;
    int i;
    uint8 flow_cleanup = 0, connector_cleanup = 0;

    BCMDNX_INIT_FUNC_DEFS;
    if (core == -1)
    {
        rc = _bcm_petra_cosq_core_get(unit, *gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    /* basic consistency checks */
    relevant_flags = flags & (BCM_COSQ_GPORT_VOQ_CONNECTOR | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR | BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }
    if ((numq < 0) || (numq > DPP_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
    }
    if ((numq % DPP_DEVICE_COSQ_COS_ALLOC_SZ) != 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number cos levels (%d) should be multiplier of %d"), unit, numq, DPP_DEVICE_COSQ_COS_ALLOC_SZ));
    }

    is_non_contiguous = (relevant_flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
    is_composite = (relevant_flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;

    /* validate flow (if specified by user) */
    if (flags & BCM_COSQ_GPORT_WITH_ID) {
        res_flags |= BCM_DPP_AM_FLAG_ALLOC_WITH_ID;

        if (!BCM_COSQ_GPORT_IS_VOQ_CONNECTOR((*gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport (0x%x) corresponding to _WITH_ID flags specified "), unit, (*gport)));
        }

        flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET((*gport));
        if (SOC_IS_QAX(unit)) { /*HW limits flow ids to upper 64k for QAX (32k for QUX)*/
            flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, flow_id); 
        }
        rc = _bcm_petra_cosq_validate_connector_id(unit, is_non_contiguous, is_composite, numq, flow_id); 
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid connector id %d"), unit, flow_id));
        }
    }

    /* Get modid of source */
    if (src_modid == -1) {
        if (BCM_GPORT_IS_SYSTEM_PORT(port)) {
            rc = bcm_petra_stk_sysport_gport_get(unit, port, &ingr_port);
            
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped, gport add for connector cannot be performed"), unit, port));
            }
            /* get system port to mod/port mapping */
            src_modid = BCM_GPORT_MODPORT_MODID_GET(ingr_port);
        } else if (BCM_GPORT_IS_MODPORT(port)) {
            src_modid = BCM_GPORT_MODPORT_MODID_GET(port);
        } else if (BCM_GPORT_IS_LOCAL(port)) {
            int modid;
            /* Get my modid since it is local */
            rc = bcm_petra_stk_my_modid_get(unit, &modid);
            src_modid = (uint8)modid;
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("my modid wasnt set correctly")));
            }
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) ingress port parameter not initialized"), unit));
        }
    }

    /* cast from int to uint8[sizeof(int)] */
    for (i=0; i < sizeof(int); i++) {
        SHR_BITCOPY_RANGE(&byte_data, 0 , (uint32*)&src_modid, i*8 , 8);
        src_modid_uint8[i] = byte_data & 0xFF;
    }

    
    /* allocate resource */
    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, nof_remote_cores, res_flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, src_modid_uint8, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, connector resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }    

    /* configure resources */
    for (cur_connector = 0, cur_flow_id = flow_id; cur_connector < numq; cur_connector++) {
        _bcm_petra_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite, FALSE, &cur_flow_id);

        SOC_TMC_SCH_FLOW_clear(unit, &flow_config);

        flow_config.flow_type = SOC_TMC_FLOW_SIMPLE;
        flow_config.is_slow_enabled = FALSE;

        flow_config.sub_flow[0].is_valid = TRUE;

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[0].credit_source.se_type)));
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit,core, &(flow_config.sub_flow[0].credit_source.id)));

        if (is_composite) {
            rc = _bcm_petra_composite_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
           
            flow_config.sub_flow[1].is_valid = TRUE;

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.get(unit, &(flow_config.sub_flow[1].credit_source.se_type)));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &(flow_config.sub_flow[1].credit_source.id)));
        }
        
        /* set all symmetric connections */
        for (i = 0; i < nof_remote_cores; i++) {
            flow_id_i = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(cur_flow_id, nof_remote_cores, i);
            flow_config.sub_flow[0].id = flow_id_i;
            if (is_composite) {
                flow_config.sub_flow[1].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(cur_comp_flow_id, nof_remote_cores, i);
            }

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id_i, &flow_config, &exact_flow_config)));
            if(SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, flow_id_i, soc_sand_rc, rc));
                goto err;
            }
        }

        /* set flow weight and mode */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, cur_flow_id, 0));
        flow_cleanup = 1;
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, cur_flow_id, BCM_COSQ_SP0));

        if (is_composite) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, cur_comp_flow_id, 0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, cur_comp_flow_id, BCM_COSQ_SP0));
        }
    }

    /* data structure for connector group */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.set(unit, core, flow_id, numq));
    connector_cleanup = 1;
#ifdef BCM_DPP_COSQ_CONN_NO_MODID_OPTIMIZATION
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.src_modid.set(unit, core, flow_id, src_modid));
#endif /* BCM_DPP_COSQ_CONN_NO_MODID_OPTIMIZATION */

    /* update handle */
    if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_QAX_SUB_OFFSET(unit, flow_id);
    }
    BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET((*gport), flow_id, core); 

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "  DBG, Connector Gport(%d:0x%x)\n"), (*gport), (*gport)));


    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:

    if (flow_id != -1) {
        bcm_dpp_am_cosq_scheduler_deallocate(unit, core, res_flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, flow_id);

        if (connector_cleanup) {
           bcm_dpp_cosq_connector_config_t zero = {0};
           BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, flow_id, &zero));
        }

        if (flow_cleanup) {
            bcm_dpp_cosq_connector_config_t zero = {0};
            for (cur_connector = 0, cur_flow_id = flow_id; cur_connector < numq; cur_connector++) {
                _bcm_petra_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite,FALSE, &cur_flow_id);
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_flow_id, &zero));
                if (is_composite) {
                    rc = _bcm_petra_composite_flow_id_get(unit, core, flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
                    BCMDNX_IF_ERR_EXIT(rc);
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_comp_flow_id, &zero));
                }
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_ingress_queue_bundle_gport_add(int unit, 
                                              bcm_cosq_ingress_queue_bundle_gport_config_t *config, 
                                              bcm_gport_t *gport)
{

    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;

    if (config == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Null config pointer")));
    }
    if (config->flags & BCM_COSQ_GPORT_UCAST_QUEUE_GROUP || config->flags & BCM_COSQ_GPORT_ISQ) {
        rc = _bcm_petra_cosq_ucast_gport_add(unit,config,gport);
        BCMDNX_IF_ERR_EXIT(rc);
    } else if (config->flags & BCM_COSQ_GPORT_MCAST_QUEUE_GROUP) {
        rc = _bcm_petra_cosq_mcast_gport_add(unit,config,gport);
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Ingress queues add bundle not support for flags(0x%x)"), unit, config->flags));
    }
exit:
    BCMDNX_FUNC_RETURN;
    
}
/*
 * Get the system port destination according to different destination types, 
 * If the destination is in a different TM domain in a stacking configuration than stk_exist == 1, and base queue should be mapped to it. 
 */ 
STATIC int
_bcm_petra_cosq_ingress_queue_get_sysport_destination(
   int unit, 
   int core,
   uint8 is_ucast,
   uint8 is_flow,
   bcm_gport_t port, 
   int *sysport,
   int *stk_exist)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_gport_t sysport_gport = 0xffffffff; /* Assigning all 1s, in case we accidently access it without assigning real value */
    bcm_gport_t port_gport;
    int         tmp_port;
    BCMDNX_INIT_FUNC_DEFS;

   /* When recieve ISQ Class HR , return port accordingly */
    if (is_ucast)
    {
        if (BCM_COSQ_GPORT_IS_ISQ_ROOT(port)) {
           rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, port, 0, &port_gport);
           if (rc != BCM_E_NONE) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }
           if (!(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport)) ) {
               BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }

           if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
                tmp_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);            
           } else {
                rc = bcm_petra_cosq_resource_gport_port_get(unit, port, &tmp_port);
                if (rc != BCM_E_NONE) {
                    rc = BCM_E_PARAM;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
           BCM_GPORT_LOCAL_SET(port,tmp_port);
        }
    }
    else /*(!is_ucast)*/
    {
        /* When recieve FMQ Class HR , return port accordingly */
        if (BCM_COSQ_GPORT_IS_FMQ_CLASS(port)) {
           rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, port, 0, &port_gport);
           if (rc != BCM_E_NONE) {
             BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }
           if ( !(BCM_COSQ_GPORT_IS_E2E_PORT(port_gport) || BCM_GPORT_IS_SCHEDULER(port_gport)) ) {
               BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q port(0x%08x) not allocated enhance HR"), unit, port));
           }

           if (BCM_COSQ_GPORT_IS_E2E_PORT(port_gport)) {
                tmp_port = BCM_COSQ_GPORT_E2E_PORT_GET(port_gport);            
           } else {
                rc = bcm_petra_cosq_resource_gport_port_get(unit, port, &tmp_port);
                if (rc != BCM_E_NONE ) {
                    rc = BCM_E_PARAM;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
           BCM_GPORT_LOCAL_SET(port,tmp_port);
        }    
    }
    /* retrieve system port from port */
    if (BCM_GPORT_IS_SYSTEM_PORT(port)) {
        sysport_gport = port;
    } else {
        rc = bcm_petra_stk_gport_sysport_get(unit, port, &sysport_gport); /* get system port from gport */
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) not mapped, gport add for unicast queue group cannot be performed"), unit, port));
        }
    }    
    /* get system port to mod/port mapping */
    *sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add gport (0x%08x) dest sysport(%d)\n"), unit, port, *sysport));
    /* Handle stacking sysport, removed: || (BCM_COSQ_GPORT_WITH_ID & flags) */
    if (!(is_flow) && is_ucast) {
        rc = _bcm_petra_cosq_stk_sysport_set(unit, core, sysport_gport, stk_exist);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("Unit(%d) sysport(0x%08x) Fail to handle Stacking (%d)"), unit, *sysport, rc));
        }
    } else {
        *stk_exist = 0;
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
 * This function is used updates the rate classes ref_count, and tail drop reservation.
 * The input struct bcm_dpp_cosq_queue_attributes_verify_t is used too:
 * 1. Update the reference count for rate classes.
 * 2. Updating tail drop reservation. 
 * 3. Update delay tolerence level ref count in case of deletion. 
 */
STATIC int
_bcm_petra_cosq_ingress_queue_bundle_ref_count_update(
   int unit,
   int core_id,
   uint8 is_add,
   bcm_dpp_cosq_queue_attributes_verify_t *queue_attributes_verify)
{
    uint32    
        ref_count;
    uint8 
        queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int 
        index, 
        is_allocated;
    bcm_dpp_cosq_ingress_rate_class_info_t 
        data_rate_cls;
    SOC_TMC_ITM_QT_NDX
        user_q_type;
    int
        hw_q_type;
    int 
        core_index;
    int32 
        reservation_change[SOC_DPP_DEFS_MAX(NOF_CORES)][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES],
        ocb_reservation_change[SOC_DPP_DEFS_MAX(NOF_CORES)][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    int thresh_type;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(reservation_change, 0, sizeof(reservation_change));
    sal_memset(reservation_change, 0, sizeof(ocb_reservation_change));

    BCM_DPP_CORES_ITER(core_id, core_index) {
        /*Update delay tolerence level in case of deletion*/
        if (SOC_IS_JERICHO(unit)) {
            if (!is_add) {
                for (index = 0; index < queue_attributes_verify[core_index].nof_delay_tolerance; index++) {
                    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, queue_attributes_verify[core_index].queue_attributes[index].delay_tolerance_level, &user_q_type));
                    DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.q_type_ref_count.get(unit, hw_q_type, &ref_count));
                    ref_count += queue_attributes_verify[core_index].delay_tolerance_nof_additions[index];
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.q_type_ref_count.set(unit, hw_q_type, ref_count));
                }
            }
        }
        /*Update rate class mapping*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
        for (index = 0; index < queue_attributes_verify[core_index].nof_rate_class; index++) {
            if (!is_add) {
                BCMDNX_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_exchange(
                   unit,
                   core_index, 
                   FALSE, 
                   SOC_TMC_ITM_NOF_RATE_CLASSES, 
                   queue_attributes_verify[core_index].queue_attributes[index].rate_class, 
                   queue_attributes_verify[core_index].nof_dram_mixed_queues_per_rate_class[index]));

                if (!SOC_IS_QAX(unit)) {
                        /* ocb_only should not be called on QAX */
                        BCMDNX_IF_ERR_EXIT(arad_sw_db_tm_queue_to_rate_class_mapping_ref_count_exchange(
                                                   unit,
                                                   core_index, 
                                                   TRUE, 
                                                   SOC_TMC_ITM_NOF_RATE_CLASSES, 
                                                   queue_attributes_verify[core_index].queue_attributes[index].rate_class, 
                                                   queue_attributes_verify[core_index].nof_ocb_only_queues_per_rate_class[index]));
                }
            }
            if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
                sal_memset(&data_rate_cls, 0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
                BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_queue_rate_cls_ref_get(unit, 
                                                                               queue_attributes_verify[core_index].queue_attributes[index].rate_class, 
                                                                               &ref_count));
                if (ref_count == 0) {
                    /*If ref_count == 0 - retrive configuration from HW*/
                    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_rate_class_hw_get(unit, 
                                                                             queue_attributes_verify[core_index].queue_attributes[index].rate_class,
                                                                             &data_rate_cls));
                } else {
                    /*If ref_count == 0 - retrive configuration from allocation manager*/
                    BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_queue_rate_cls_tdata_get(unit, 
                                                                                     queue_attributes_verify[core_index].queue_attributes[index].rate_class,
                                                                                     &data_rate_cls));
                }
                BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_queue_rate_cls_allocate_group(unit, 
                                                                                      BCM_DPP_AM_TEMPLATE_FLAG_ALLOC_WITH_ID, 
                                                                                      &data_rate_cls, 
                                                                                      queue_attributes_verify[core_index].rate_class_nof_additions[index],
                                                                                      &is_allocated, 
                                                                                      (int*)&(queue_attributes_verify[core_index].queue_attributes[index].rate_class)));
            }
        }
        if (!SOC_IS_QAX(unit)) {
            /* ocb_only is not relevant for QAX and above */
            ocb_reservation_change[core_index][0] = queue_attributes_verify[core_index].ocb_reservation_change;
        }
    }

    for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
        BCM_DPP_CORES_ITER(core_id, core_index) {
            reservation_change[core_index][thresh_type] = queue_attributes_verify[core_index].reservation_change[thresh_type];
        }
    }
    /* update tail drop reservation */
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, core_id, FALSE, reservation_change))); 
    if (!SOC_IS_QAX(unit)) {
        /* ocb_only is not relevant for QAX and above */
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dyn_total_thresh_set,(unit, core_id, TRUE, ocb_reservation_change))); 
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}
/* 
 * This function is used for:
 * 1. Verifing that a created/deleted queue bundle's attribues are valid. 
 * 1.1. Credit request profiles and rate classes are in valid range. 
 * 1.2. Filling an struct to be used for updating the ref count for each queue in the bundle.
 * 1.2. Updating the reference count for both of them will not result out of range values. 
 * 2. Filling an struct to be used for updating the ref count for each queue in the bundle.
 * 3. Calculation and verifying the validity of tail drop reservation update.
 */
STATIC int 
_bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(
   int unit, 
   int core_id,
   int base_queue,
   uint8 is_add,
   bcm_cosq_ingress_queue_bundle_gport_config_t *config,
   bcm_dpp_cosq_queue_attributes_verify_t *queue_attributes_verify)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32      credit_request_profile_nof_additions_mapping[SOC_DPP_DEFS_MAX(NOF_CREDIT_REQUEST_PROFILES)];
    uint32      rate_class_nof_additions_mapping[SOC_TMC_ITM_NOF_RATE_CLASSES];
    uint32      ref_count;
    int         cosq = 0;

    SOC_TMC_ITM_QT_NDX user_q_type;
    int hw_q_type;
    /* Need to use it as pointer in order to aviod stack use coverity defect */
    bcm_dpp_cosq_ingress_rate_class_info_t *rate_class_info_dummy = NULL;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info_sum;
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_info_ocb_sum;
    int32 reservation_change[SOC_DPP_DEFS_MAX(NOF_CORES)][DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES];
    uint8 is_ocb_only;
    int core;
    int         addition = is_add ? 1 : -1;
    uint8       queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int thresh_type;


    /*verify rate classes*/
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(queue_attributes_verify, 0, SOC_DPP_DEFS_MAX(NOF_CORES) * sizeof(bcm_dpp_cosq_queue_attributes_verify_t));
    BCMDNX_ALLOC(rate_class_info_dummy, sizeof(*rate_class_info_dummy), "_bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify.rate_class_info_dummy");
    if(rate_class_info_dummy == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("Memory allocation failue\n")));
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
    BCM_DPP_CORES_ITER(core_id, core) {
        int         nof_rate_class = 0;
        int         rate_class = 0;
        int         rate_class_nof_additions = 0;
        int         nof_ocb_only_queues_per_rate_class = 0;
        int         nof_dram_mixed_queues_per_rate_class = 0;

        int         nof_credit_request_profile = 0;
        int         credit_request_profile = 0;
        int         credit_request_profile_nof_additions = 0;

        int         numq = config->numq;

        sal_memset(&rate_class_nof_additions_mapping, 0xff, sizeof(rate_class_nof_additions_mapping));
        sal_memset(&credit_request_profile_nof_additions_mapping, 0xff, sizeof(credit_request_profile_nof_additions_mapping));

        sal_memset(rate_class_info_dummy, 0, sizeof(*rate_class_info_dummy));
        sal_memset(&rate_class_info, 0, sizeof(rate_class_info));
        sal_memset(&rate_class_info_sum, 0, sizeof(rate_class_info_sum));
        sal_memset(&rate_class_info_ocb_sum, 0, sizeof(rate_class_info_ocb_sum));
        
        /*verify credit request profiles*/
        if (!is_add) {
            for (cosq = 0; cosq < config->numq; cosq++){
                int weight;
                bcm_gport_t gport;
                BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(gport, core, base_queue);
                rc = _bcm_petra_cosq_gport_ucast_queue_sched_get(unit, gport, cosq, &(config->queue_atrributes[cosq].delay_tolerance_level) ,&weight);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        for (credit_request_profile = config->queue_atrributes[0].delay_tolerance_level, nof_credit_request_profile = 0, cosq = 0;
             cosq <= numq;
             cosq++, credit_request_profile_nof_additions += addition) {
            if (cosq != numq && credit_request_profile == config->queue_atrributes[cosq].delay_tolerance_level) {
                continue;
            }
            /*Verify the delay tolerance level validity*/
            if (!((credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_NORMAL && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_15) ||
                  (credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_10G_SLOW_ENABLED && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_200G_LOW_DELAY) ||
                  (credit_request_profile >= BCM_COSQ_DELAY_TOLERANCE_16 && credit_request_profile <= BCM_COSQ_DELAY_TOLERANCE_23))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The delay tolerance level %d is not legal."),unit, credit_request_profile)); 
            }
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, credit_request_profile, &user_q_type));
            DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

            /*Verify the HW q type translated form the delay tolerance level*/
            if (!(0 <= hw_q_type && hw_q_type < SOC_DPP_DEFS_GET(unit, nof_credit_request_profiles))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The credit request profile %d is not legal."),unit, credit_request_profile)); 
            }
            /* 
             * If we didn't see this profile before (credit_request_profile_nof_additions_mapping[credit_request_profile] == 0xffffffff) 
             * Then update the credit_request_profile_nof_additions_mapping array and increas the nof_credit_request_profile counter.
             */
            if (credit_request_profile_nof_additions_mapping[hw_q_type] == 0xffffffff) {
                credit_request_profile_nof_additions_mapping[hw_q_type] = nof_credit_request_profile;
                queue_attributes_verify[core].queue_attributes[credit_request_profile_nof_additions_mapping[hw_q_type]].delay_tolerance_level = credit_request_profile;
                nof_credit_request_profile++;
            }
            queue_attributes_verify[core].delay_tolerance_nof_additions[credit_request_profile_nof_additions_mapping[hw_q_type]] += credit_request_profile_nof_additions;
            credit_request_profile_nof_additions = 0;
            credit_request_profile = config->queue_atrributes[cosq].delay_tolerance_level;
        }
        queue_attributes_verify[core].nof_delay_tolerance = nof_credit_request_profile;

        /*if jericho verify that the expected ref count is legel.*/
        if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)) {
            for (cosq = 0; cosq < queue_attributes_verify[core].nof_rate_class; cosq++) {
                credit_request_profile = queue_attributes_verify[core].queue_attributes[cosq].delay_tolerance_level;
                credit_request_profile_nof_additions = queue_attributes_verify[core].delay_tolerance_nof_additions[cosq];

                BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, credit_request_profile, &user_q_type));
                DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.q_type_ref_count.get(unit, hw_q_type, &ref_count));
                ref_count += credit_request_profile_nof_additions;
                if (ref_count > SOC_DPP_DEFS_GET(unit, nof_queues))
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the credit request profile %d, the ref_count %d is out of range."),unit, credit_request_profile, ref_count));
                }
            }
        }

        if (!is_add) {
            for (cosq = 0; cosq < config->numq; cosq++){
                 rc = _bcm_petra_cosq_voq_class_mapping_get(unit, core, base_queue + cosq, BCM_DPP_COSQ_RATE_CLS, &(config->queue_atrributes[cosq].rate_class));
                 BCMDNX_IF_ERR_EXIT(rc);
            }
        } 
        for (rate_class = config->queue_atrributes[0].rate_class, nof_rate_class = 0, cosq = 0, is_ocb_only = FALSE;
             cosq <= numq;
             cosq++, 
             rate_class_nof_additions += addition,
             nof_ocb_only_queues_per_rate_class += is_ocb_only ? addition : 0,
             nof_dram_mixed_queues_per_rate_class += is_ocb_only ? 0 :addition) {
            if (!SOC_IS_ARADPLUS_AND_BELOW(unit) && !SOC_IS_QAX(unit)) {
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_queue_is_ocb_only_get, (unit, core, base_queue + cosq, &is_ocb_only)); 
                BCMDNX_IF_ERR_EXIT(rc);
            }
            if (cosq != numq && rate_class == config->queue_atrributes[cosq].rate_class) {
                continue;
            }
            /* 
             * If we didn't see this rate class before (rate_class_nof_additions_mapping[rate_class] == 0xffffffff) 
             * Then update the rate_class_nof_additions_mapping array and increas the nof_rate_class counter.
             */
            if (rate_class_nof_additions_mapping[rate_class] == 0xffffffff) {
                rate_class_nof_additions_mapping[rate_class] = nof_rate_class;
                queue_attributes_verify[core].queue_attributes[rate_class_nof_additions_mapping[rate_class]].rate_class = rate_class;
                nof_rate_class++;
            }
            queue_attributes_verify[core].nof_ocb_only_queues_per_rate_class[rate_class_nof_additions_mapping[rate_class]]+= nof_ocb_only_queues_per_rate_class;
            queue_attributes_verify[core].nof_dram_mixed_queues_per_rate_class[rate_class_nof_additions_mapping[rate_class]]+= nof_dram_mixed_queues_per_rate_class;
            queue_attributes_verify[core].rate_class_nof_additions[rate_class_nof_additions_mapping[rate_class]] += rate_class_nof_additions;
            nof_ocb_only_queues_per_rate_class = 0;
            nof_dram_mixed_queues_per_rate_class = 0;
            rate_class_nof_additions = 0;
            rate_class = config->queue_atrributes[cosq].rate_class;
        }
        queue_attributes_verify[core].nof_rate_class = nof_rate_class;

        /*verify rate class attributes*/
        for (cosq = 0; cosq < queue_attributes_verify[core].nof_rate_class; cosq++) {
            rate_class = queue_attributes_verify[core].queue_attributes[cosq].rate_class;
            if(rate_class < 0 || rate_class > SOC_TMC_ITM_RATE_CLASS_MAX) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, rate_class)); 
            }
            sal_memset(&rate_class_info_sum, 0, sizeof(rate_class_info_sum));
            sal_memset(&rate_class_info_ocb_sum, 0, sizeof(rate_class_info_ocb_sum));

            rate_class_nof_additions = queue_attributes_verify[core].rate_class_nof_additions[cosq];
            if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
                BCMDNX_IF_ERR_EXIT(_bcm_dpp_am_template_queue_rate_cls_ref_get(unit, rate_class, &ref_count));
                /* 
                 * We cannot allocate new rate class on creation of a queue. 
                 * The only exeption is rate class 0, which is the default rate class. 
                 */
                if (is_add && ref_count == 0 && rate_class != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot create a queue mapped to rate class %d, since it is not configured."),unit, rate_class)); 
                }
                if (ref_count == 0) {
                    /*If rate ref_count == 0 init rate class*/
                    rc = _bcm_petra_cosq_voq_rate_class_default_set(unit, rate_class, &rate_class_info);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else {
                    rc = _bcm_dpp_am_template_queue_rate_cls_tdata_get(unit, rate_class, &rate_class_info); 
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                ref_count += rate_class_nof_additions;
                if (ref_count > (SOC_DPP_DEFS_GET(unit, nof_queues) * SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores))
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the rate class %d, the ref_count %d is out of range."),unit, rate_class, ref_count));
                }           
            } else {
                BCMDNX_IF_ERR_EXIT(arad_sw_db_rate_class_ref_count_get(unit, core, 2, (uint32)rate_class, &ref_count));
                ref_count += rate_class_nof_additions;
                if (ref_count > SOC_DPP_DEFS_GET(unit, nof_queues)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, For the rate class %d, the ref_count %d is out of range."),unit, rate_class, ref_count));
                }
                if (queue_to_rate_class_mapping_is_simple == ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED && 
                    is_add && 
                    rate_class != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                                        (_BSL_BCM_MSG("unit %d, Cannot create a queue mapped to a rate class %d != 0, when the queue-to-rate class made is undefined."), unit, rate_class)); 
                }
                rc = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, &rate_class_info);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, queue_attributes_verify[core].queue_attributes[cosq].delay_tolerance_level, &user_q_type));
            DPP_COSQ_USER_Q_TYPE_HW_Q_TYPE(unit, user_q_type, hw_q_type);

            if (!SOC_IS_QAX(unit))
            { 
                /* the following code is not relevant for QAX and later */
                /* ocb only */
                rate_class_info_ocb_sum.queue_quaranteed_size[DPP_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES] += queue_attributes_verify[core].nof_ocb_only_queues_per_rate_class[cosq] * rate_class_info.queue_quaranteed_size[DPP_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];
                rate_class_info_ocb_sum.queue_min_size_bds += queue_attributes_verify[core].nof_ocb_only_queues_per_rate_class[cosq] * rate_class_info.queue_min_size_bds;

                rc = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, TRUE, rate_class_info_dummy, &rate_class_info_ocb_sum, 1, reservation_change);
                BCMDNX_IF_ERR_EXIT(rc);
                queue_attributes_verify[core].ocb_reservation_change += reservation_change[core][DPP_COSQ_INGRESS_THRESHOLD_TOTAL_BYTES];

                /* bds threshold */
                rate_class_info_sum.queue_min_size_bds += queue_attributes_verify[core].nof_dram_mixed_queues_per_rate_class[cosq] * rate_class_info.queue_min_size_bds;

            }

            for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {

                rate_class_info_sum.queue_quaranteed_size[thresh_type] += queue_attributes_verify[core].nof_dram_mixed_queues_per_rate_class[cosq] * 
                    rate_class_info.queue_quaranteed_size[thresh_type];
            }

            rc = _bcm_petra_cosq_gport_ingress_queue_mapping_profile_set_verify(unit, core, FALSE, rate_class_info_dummy, &rate_class_info_sum, 1, reservation_change);
            BCMDNX_IF_ERR_EXIT(rc);
            for (thresh_type = 0; thresh_type < DPP_COSQ_INGRESS_THRESHOLD_NOF_TYPES; thresh_type++) {
                queue_attributes_verify[core].reservation_change[thresh_type] += reservation_change[core][thresh_type];
            }
        }
    }

exit:
    BCM_FREE(rate_class_info_dummy);
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_mcast_gport_add(int unit,
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport)
{
    bcm_gport_t port;
    int         numq;
    int         cosq;
    uint32      flags;
    bcm_error_t rc = BCM_E_NONE;
    int         is_non_contiguous = FALSE;    
    int         base_fmq = 0, fmq = 0, start_fmq = 0, end_fmq;
    int         alloc_flags = 0;
    int         is_composite = FALSE;
    int         base_flow_id = DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START;
    int         sysport = 0;
    int         mcast_sched_mode = 0;

    uint32 relevant_flags, soc_sand_rc;
    int flow_quartet;
    int flow_id = 0;
    int core = BCM_CORE_ALL, core_index;
    int stk_exist;
    SOC_TMC_ITM_QUEUE_INFO queue_info, old_queue_info;
    bcm_dpp_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DPP_DEFS_MAX(NOF_CORES)];
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(gport);
    BCMDNX_NULL_CHECK(config);

    port = config->port;
    numq = config->numq; 
    flags = config->flags;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add multicast queue gport(0x%08x) numq(%d)\n"), unit, port, numq));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "flags(0x%08x)\n"), flags));

    if (BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR & flags) {
        is_non_contiguous = TRUE;
    }

    if (BCM_COSQ_GPORT_COMPOSITE & flags) {
        is_composite = TRUE;
    }

    /* basic consistency checks */
    relevant_flags = flags & (BCM_COSQ_GPORT_REPLACE | BCM_COSQ_GPORT_WITH_ID | BCM_COSQ_GPORT_MCAST_QUEUE_GROUP 
                              | BCM_COSQ_GPORT_COMPOSITE | BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR);
    if (flags != relevant_flags) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags parameter 0x%x"), unit, flags));
    }

    if ((numq < 0) || (numq > DPP_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, flags));
    }
    if (BCM_COSQ_GPORT_WITH_ID & flags) {
        base_fmq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(*gport);
       
        rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMin,&start_fmq);
        BCMDNX_IF_ERR_EXIT(rc);
        
        rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMax,&end_fmq);
        BCMDNX_IF_ERR_EXIT(rc);

        if (base_fmq > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q %d with_id failed, queue out of range "), unit, base_fmq));
        }

        if (base_fmq < start_fmq || base_fmq > end_fmq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add mc q %d with_id failed, queue out of range of multicast fabric queues "), unit, base_fmq));
        }

        core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(*gport);
        if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, core out of range %d"), unit, base_fmq, core));
        }
        alloc_flags |= BCM_DPP_AM_FLAG_ALLOC_WITH_ID;
    } else {
       BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit(%d) add mc q gport(0x%08x) not supported without with_id"), unit, base_fmq));
    }
    /*validate rate class mapping params */
    /* base_queue - relevant for deletion only*/
    rc = _bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, 0, TRUE, config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add gport (0x%08x) dest sysport(%d)\n"), unit, port, sysport));

    rc = bcm_petra_fabric_multicast_scheduler_mode_get(unit, core, &mcast_sched_mode);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Only 4 multicast queues allocated if we are in mode 0 - these are not managed by alloc_mngr.c *
     * so we do not want to allocate them here.  If in mode 1 4k queues are available so allocate.   *
     */
    if (mcast_sched_mode != 0) {

        rc = _bcm_petra_cosq_ingress_queue_get_sysport_destination(unit, 
                                                               core,
                                                               FALSE,/*is_ucast*/
                                                               FALSE,/*is_flow*/
                                                               port,
                                                               &sysport, 
                                                               &stk_exist);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else
    {
        sysport = ARAD_NOF_SYS_PHYS_PORTS_GET(unit) - 1;
    }

    if (mcast_sched_mode == 0) {
        if ((BCM_COSQ_GPORT_WITH_ID & flags) && (base_fmq != 0)) {
            rc = BCM_E_PARAM;
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, mode incompatible with base FMQ(%d) !=0\n"), unit, base_fmq));
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            base_fmq = 0;
        }
    } else if (base_fmq != 0) { /*In all modes we reserved base_fmq - no need to allocate*/
        /* call queue allocation wrapper function which    */
        /* calls lower level function - if with_id is set, */
        /* the user has alloc-ed, pass this flag also      */       
        rc = bcm_dpp_am_ingress_voq_allocate(unit,
                                             core,
                                             alloc_flags,
                                             is_non_contiguous,
                                             numq,
                                             DPP_DEVICE_COSQ_QUEUE_REGION_MULTICAST,
                                             &base_fmq);
        
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) gport(0x%08x) gport add fmq group not available (%d)"), unit, port, rc));
        }
    }
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index){
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_fmq), numq));
    }

    for (flow_quartet = 0, fmq = base_fmq; 
         fmq < (base_fmq + numq);
         flow_quartet++, fmq+=DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        SOC_TMC_IPQ_QUARTET_MAP_INFO queue2flow;

        SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

        _bcm_petra_flow_id_get(unit, core,
                               base_flow_id, 
                               (fmq - base_fmq) /* cos */,
                               is_non_contiguous,
                               is_composite,
                               FALSE /*is_remove*/,
                               &flow_id);

        queue2flow.flow_quartet_index = SOC_TMC_SCH_FLOW_TO_QRTT_ID(flow_id);
        queue2flow.is_composite = is_composite;
        queue2flow.system_physical_port = sysport;
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_set,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(fmq), &queue2flow)));
        
        rc = handle_sand_result(soc_sand_rc);

        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "soc_petra_ipq_queue_to_flow_mapping_set() failed queue(%d) sysport(%u)\n"), fmq, sysport));
        }

        /* Rotate between using default flow ids which are reserved */
        flow_id++;
    }

    /*Set Queue profiles - credit request profile and rate class acording to config info*/
    for (cosq = 0; cosq < numq; cosq++) {
        SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);
        /* retrieve current configuration */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, base_fmq + cosq, &queue_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        sal_memcpy(&old_queue_info, &queue_info, sizeof(SOC_TMC_ITM_QUEUE_INFO));

        /* update configuration */
        /*Map each queue offset to relevant rate class*/
        queue_info.rate_cls = config->queue_atrributes[cosq].rate_class;

        /*Map each queue offset to relevant crefit request profile*/
        rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, config->queue_atrributes[cosq].delay_tolerance_level, &(queue_info.cr_req_type_ndx));
        BCMDNX_IF_ERR_EXIT(rc);  

        old_queue_info.cr_req_type_ndx = SOC_TMC_ITM_QT_NDX_INVALID;
        old_queue_info.rate_cls = SOC_TMC_ITM_NOF_RATE_CLASSES;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit, core, base_fmq + cosq, &old_queue_info, &queue_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }
    /*Update SW state for rate class mapping*/
    rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, core, TRUE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);  

    BCM_GPORT_MCAST_QUEUE_GROUP_CORE_QUEUE_SET(*gport, core, base_fmq);

exit:
BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_ucast_gport_add(int unit, 
                               bcm_cosq_ingress_queue_bundle_gport_config_t *config,
                               bcm_gport_t *gport)
{
    int         rc = BCM_E_NONE;
    bcm_gport_t port;
    int         numq;
    int         cosq;
    uint32      flags;
    int         is_non_contiguous = FALSE;
    int         is_flow = FALSE;
    int         is_composite = FALSE;
    int         is_isq = FALSE;
    int         soc_sand_rc = 0;
    int         sysport = 0;
    int         flow_id, flow_quartet;
    int         base_voq = 0, voq = 0;
    int         alloc_flags = 0;
    int         reference_counter = 1;
    bcm_gport_t tmp_gport = 0;
    unsigned    direct_mode = 0;
    int stk_exist = 0x0;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE;
    SOC_TMC_ITM_QUEUE_INFO queue_info, old_queue_info;
    bcm_dpp_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DPP_DEFS_MAX(NOF_CORES)];
    BCMDNX_INIT_FUNC_DEFS;

    /*Verify unit*/
    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(gport);
    numq = config->numq;
    if ((numq < 0) || (numq > DPP_DEVICE_COSQ_MAX_COS)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels specified %d"), unit, numq));
    }
    port = config->port;
    flags = config->flags;
    tmp_gport = *gport;

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add unicast queue gport(0x%08x) numq(%d)\n"), unit, port, numq));
    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "flags(0x%08x)\n"), flags));    

    if(ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        direct_mode = 1;
    }

    if (BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR & flags) {
        is_non_contiguous = TRUE;
    }

    if (BCM_COSQ_GPORT_TM_FLOW_ID & flags) {
        is_flow = TRUE;
    }

    if (BCM_COSQ_GPORT_COMPOSITE & flags) {
        is_composite = TRUE;
    }

    if (BCM_COSQ_GPORT_ISQ & flags) {
        is_isq = TRUE;
    }
    if (BCM_COSQ_GPORT_SW_ONLY & flags) {
        if (!SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) failed, sw_only configuration not allowed%d"), unit));
        }
        is_sw_only = TRUE;
    }

    if (BCM_COSQ_GPORT_WITH_ID & flags) {
        
        if (is_isq) {
            base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(tmp_gport);
            core = BCM_COSQ_GPORT_ISQ_CORE_GET(tmp_gport);
        } else {
            base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(tmp_gport);
            core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(tmp_gport);
        }

        if (base_voq > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, queue out of range %d"), unit, tmp_gport, base_voq));
        }
        if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q gport(0x%08x) with_id failed, core out of range %d"), unit, tmp_gport, core));
        }

        alloc_flags |= BCM_DPP_AM_FLAG_ALLOC_WITH_ID;
    } else {
        tmp_gport = -1;
        *gport = -1;
        core = config->local_core_id;
        if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) add uc q  without_id failed, core out of range %d"), unit, core));
        }
    }
    /*validate rate class mapping params */
    /* base_queue - relevant for deletion only*/
    rc =_bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, 0, TRUE, config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) add uc gport(0x%08x) flags: interdig(%d) flow(%d) composite(%d)\n"), unit, port, is_non_contiguous, is_flow, is_composite));
    /* Prosses config->port to get the relvent destination sysport*/
    rc = _bcm_petra_cosq_ingress_queue_get_sysport_destination(unit, 
                                                               core,
                                                               TRUE, /*is_ucast*/
                                                               is_flow,
                                                               port, 
                                                               &sysport,
                                                               &stk_exist);
    BCMDNX_IF_ERR_EXIT(rc);

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit=%d, port=0x%x, is_flow=%d, direct_mode=%d, sysport=0x%x\n"), unit, port, is_flow, direct_mode, sysport));
    if (stk_exist == 0x1) {
        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "%s(): stk_exist=%d. exit ucas_cos_add().\n\n"), FUNCTION_NAME(), stk_exist));
        BCM_EXIT;
    }
    /* call queue allocation wrapper function which    */
    /* calls lower level function - if with_id is set, */
    /* the user has alloc-ed, pass this flag also      */
    if (core == BCM_CORE_ALL && !SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit) && !(BCM_DPP_AM_FLAG_ALLOC_WITH_ID & alloc_flags)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) Cannot allocate ingress queue without ID in asymmetric mode."), unit));
    }
    rc = bcm_dpp_am_ingress_voq_allocate(unit,
                                         core,
                                         alloc_flags,
                                         is_non_contiguous,
                                         numq,
                                         (is_isq) ? DPP_DEVICE_COSQ_QUEUE_REGION_ISQ: DPP_DEVICE_COSQ_QUEUE_REGION_UNICAST,
                                         &base_voq);

    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) base_voq(%d) numq_queue(%d) gport add voq group not available (%d)"), unit, base_voq, numq, rc));
    }
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index){
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), numq));
        /* set new VOQ ref counter to 1, see API bcm_cosq_sysport_ingress_queue_map_set */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.ref_cnt.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), reference_counter));
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "voq allocated(0x%08x)\n"), base_voq));

    /*VOQ to flow mapping*/
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
         flow_quartet++, voq+=DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
            
        SOC_TMC_IPQ_QUARTET_MAP_INFO queue2flow;
        SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);
        /*
         * This is a default flow. later on, when connection is made between flow and queue,
         * a meaningful value will be loaded. Validity checks within 'mbcm_dpp_ipq_queue_to_flow_mapping_set'
         * take that into account.
         */
        flow_id = DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START ;
        
        queue2flow.flow_quartet_index = SOC_TMC_SCH_FLOW_TO_QRTT_ID(flow_id);
        queue2flow.is_composite = is_composite;
        queue2flow.system_physical_port = sysport;
        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_set,
                                                (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        rc = handle_sand_result(soc_sand_rc);
        if (rc != BCM_E_NONE) {
            if (is_flow) {
                LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"soc_petra_ipq_queue_to_flow_mapping_set() failed queue(%d)\n"), voq));
            } else {
                LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"soc_petra_ipq_queue_to_flow_mapping_set() failed queue(%d) sysport(%u)\n"), voq, sysport));
            }
        }
        BCMDNX_IF_ERR_EXIT(rc);  
    }
    
    /*SYSPORT to BASEQ MAPPING, SYSPORT MAPPING not required in case of FLOW based forwarding */
    if (!is_flow) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_set,
                                            (unit, core, sysport, TRUE /* queue is valid */,is_sw_only, base_voq)));
        rc = handle_sand_result(soc_sand_rc); /* set sysport to base queue mapping */
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,                                  \
                      (BSL_META_U(unit,                                 \
                                  "soc_petra_ipq_destination_id_packets_base_queue_id_set() failed" \
                                  "base queue(%d) sysport(%d)\n"), base_voq, sysport));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    
    /*Set Queue profiles - credit request profile and rate class acording to config info*/
    for (cosq = 0; cosq < numq; cosq++) {
        SOC_TMC_ITM_QUEUE_INFO_clear(&queue_info);
        /* retrieve current configuration */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_get,(unit, core, base_voq + cosq, &queue_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        sal_memcpy(&old_queue_info, &queue_info, sizeof(SOC_TMC_ITM_QUEUE_INFO));

        /* update configuration */
        /*Map each queue offset to relevant rate class*/
        queue_info.rate_cls = config->queue_atrributes[cosq].rate_class;

        /*Map each queue offset to relevant crefit request profile*/
        rc = _bcm_petra_cosq_delay_tolerance_to_user_q_type(unit, config->queue_atrributes[cosq].delay_tolerance_level, &(queue_info.cr_req_type_ndx));
        BCMDNX_IF_ERR_EXIT(rc);  

        old_queue_info.cr_req_type_ndx = SOC_TMC_ITM_QT_NDX_INVALID;
        old_queue_info.rate_cls = SOC_TMC_ITM_NOF_RATE_CLASSES;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_queue_info_set,(unit, core, base_voq + cosq, &old_queue_info, &queue_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }     
    /*Update SW state for rate class mapping*/
    rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, core, TRUE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);  

    if (is_isq) {
        *gport = BCM_COSQ_GPORT_ISQ_CORE_QUEUE_SET(tmp_gport, core, base_voq);
    } else {                                
        *gport = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_QUEUE_SET(tmp_gport, core, base_voq);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_connector_gport_get(int unit,
                                    bcm_gport_t gport,
                                    bcm_gport_t *physical_port,
                                    int *num_cos_levels,
                                    uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    uint32                           soc_sand_rc;
    bcm_dpp_cosq_gport_info_t        *gport_info;
    uint8                        is_non_contiguous;
    int                              base_flow_id, flow_region, is_odd_even;
    int                              is_cl_cir;
    SOC_TMC_SCH_QUARTET_MAPPING_INFO     quartet_mapping_info;
    int                              core ;
    uint8                            sw_state_num_cos;


    BCMDNX_INIT_FUNC_DEFS;
    gport_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* determine flow id */
    base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);

    if (SOC_IS_QAX(unit)) {
        base_flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, base_flow_id);
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &gport, BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport));
    }

    /* retrieve connector group state */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
    if (sw_state_num_cos <= 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) flow_id(%d) gport get flow internal state retreival error"), unit, base_flow_id));
    }


    /* validate gport (connector) */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, gport, 0, dpp_device_cosq_gport_child_element, &gport_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* retrieve flow to queue mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_flow_to_queue_mapping_get,
        (unit, core, SOC_TMC_SCH_FLOW_TO_QRTT_ID(base_flow_id), &quartet_mapping_info)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreving flow (%d) queue mapping, soc_sand error 0x%x, error 0x%x\n"), unit, base_flow_id, soc_sand_rc, rc));
        goto err;
    }
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    BCM_GPORT_MODPORT_SET((*physical_port), quartet_mapping_info.fip_id, 0);

    /* update parameters */
    (*flags) = BCM_COSQ_GPORT_VOQ_CONNECTOR;
    (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    (*num_cos_levels) = sw_state_num_cos;

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_hr_gport_get(int unit, bcm_dpp_cosq_gport_info_t *gport_info,
                                   SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_FLOW *flow_config,
                                   uint32 *flags)
{
    int                              rc = BCM_E_NONE;

    
    BCMDNX_INIT_FUNC_DEFS;
    switch (se_config->type_info.hr.mode) {
        case SOC_TMC_SCH_HR_MODE_SINGLE_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_SINGLE_WFQ;
            break;

        case SOC_TMC_SCH_HR_MODE_DUAL_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_DUAL_WFQ;
            break;

        case SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_HR_ENHANCED;
            break;

        case SOC_TMC_SCH_HR_MODE_NONE:
        case SOC_TMC_SCH_SE_HR_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            break;
    }

    if (gport_info != NULL) {
        (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
    }
    else {
        (*flags) |= ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                     (flow_config->sub_flow[1].is_valid == TRUE) ) ? BCM_COSQ_GPORT_COMPOSITE: 0;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_cl_gport_get(int unit, int core, bcm_dpp_cosq_gport_info_t *gport_info,
                                   SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_FLOW *flow_config,
                                   uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    uint32                           soc_sand_rc;
    int                              cl_type_ndx;
    SOC_TMC_SCH_SE_CL_CLASS_INFO         class_type;
    bcm_dpp_cosq_gport_info_t        *dual_gport_info;
    bcm_gport_t                      pir_gport;
    uint32                           hr_flags = 0;
    SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE ipf_mode = SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES;

    BCMDNX_INIT_FUNC_DEFS;
    dual_gport_info = NULL ;
    SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

    cl_type_ndx = se_config->type_info.cl.id;
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, core, cl_type_ndx, &class_type)));
    /*
     * Condition related to unit is only added here to appease coverity. It is not
     * really necassary.
     */
    if (SOC_SAND_FAILURE(soc_sand_rc) || (unit >= BCM_MAX_NUM_UNITS)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, cl_type_ndx, soc_sand_rc, rc));
        goto err;
    }

    switch (class_type.mode) {
        case SOC_TMC_SCH_CL_MODE_1:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE1_4SP;
            break;

        case SOC_TMC_SCH_CL_MODE_2:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE2_3SP_WFQ;
            break;

        case SOC_TMC_SCH_CL_MODE_3:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE3_WFQ_2SP;
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE4_2SP_WFQ;
            break;

        case SOC_TMC_SCH_CL_MODE_5:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE5_1SP_WFQ;
            break;

        case SOC_TMC_SCH_CL_MODE_NONE:
        case SOC_TMC_SCH_CL_CLASS_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            goto err;
            break;
    }

    if (class_type.mode != SOC_TMC_SCH_CL_MODE_1) {
        switch (class_type.weight_mode) {
            case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
                (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_DISCREET;
                break;

            case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_ipf_mode_get,(unit, &ipf_mode)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, cl_type_ndx, soc_sand_rc, rc));
                    goto err;
                }
                if(ipf_mode == SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_INVERSE){
                    (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT;
                }
                else if(ipf_mode == SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_PROPORTIONAL){
                    (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT_PROPORTIONAL;
                }
                else{
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, invalid ipf mode %d\n"), unit, ipf_mode));
                    rc = BCM_E_PARAM;
                    goto err;
                }
                break;

            case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
                (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_CLASS;
                break;

            case SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
            default:
            break;
        }
    }

    switch (class_type.enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ;
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ;
            break;

        case SOC_TMC_SCH_CL_ENHANCED_MODE_LAST:
        default:
            rc = BCM_E_PARAM;
            goto err;
            break;
    }

    if (se_config->is_dual) {
        (*flags) |= BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER;

        /* determine type of dual shaper */

        BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(pir_gport, gport_info->flow_id, core);

        rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, pir_gport, 0, dpp_device_cosq_gport_parent_element, &dual_gport_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }
        if (dual_gport_info == NULL) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "unit %d, resource memory allocation failure\n"), unit));
            rc = BCM_E_MEMORY;
            goto err;
        }

        if (dual_gport_info->is_se != TRUE) {
            rc = BCM_E_PARAM;
            goto err;
        }

        switch ((dual_gport_info->se_config)->type) {
            case SOC_TMC_SCH_SE_TYPE_HR:
                rc = _bcm_petra_cosq_sched_hr_gport_get(unit, dual_gport_info, dual_gport_info->se_config, dual_gport_info->flow_config, &hr_flags);
                if (rc != BCM_E_NONE) {
                    goto err;
                }

                (*flags) |= (hr_flags);
                break;

            default:
                break;
       }
    }

    if (gport_info != NULL) {
        (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
    }
    else {
        (*flags) |= ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                     (flow_config->sub_flow[1].is_valid == TRUE) ) ? BCM_COSQ_GPORT_COMPOSITE: 0;
    }

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);

exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    /* Not really needed. Just to aviod coverity defect */
    if(unit < BCM_LOCAL_UNITS_MAX) {
        if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
        {
            /*
             * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
             * {provided pointer is not NULL}.
             */
            if (dual_gport_info) {
                BCM_FREE(dual_gport_info->flow_config);
                BCM_FREE(dual_gport_info->se_config);
                BCM_FREE(dual_gport_info);
            }
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (dual_gport_info) {
        BCM_FREE(dual_gport_info->flow_config);
        BCM_FREE(dual_gport_info->se_config);
        BCM_FREE(dual_gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_gport_get(int unit,
                                bcm_gport_t gport,
                                bcm_gport_t *physical_port,
                                int *num_cos_levels,
                                uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    bcm_gport_t                      res_gport;
    bcm_dpp_cosq_gport_info_t        *gport_info;
    int                              core ;
    int                              flow_id;


    BCMDNX_INIT_FUNC_DEFS;
    gport_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, gport, 0,  &res_gport);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    if (SOC_IS_QAX(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, BCM_GPORT_SCHEDULER_GET(res_gport));
            BCM_GPORT_SCHEDULER_CORE_SET(res_gport, flow_id, core);
    }
    /* validate gport (scheduler) */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, res_gport, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &gport_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    switch ((gport_info->se_config)->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            rc = _bcm_petra_cosq_sched_hr_gport_get(unit, gport_info, gport_info->se_config, gport_info->flow_config, flags);
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
            rc = _bcm_petra_cosq_sched_cl_gport_get(unit, core, gport_info, gport_info->se_config, gport_info->flow_config, flags);
            break;

        case SOC_TMC_SCH_SE_TYPE_FQ:
            (*flags) |= BCM_COSQ_GPORT_SCHEDULER_FQ;
            (*flags) |= (gport_info->is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;
            break;

        default:
            rc = BCM_E_PARAM;
            break;
    }
    if (rc != BCM_E_NONE) {
        goto err;
    }

    (*flags) |= BCM_COSQ_GPORT_SCHEDULER;

    /* In case of Scheduler component, always set num_cos_levels to 1 */
    *num_cos_levels = 1;

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_e2e_gport_get(int unit,
                              bcm_gport_t gport,
                              bcm_gport_t *physical_port,
                              int *num_cos_levels,
                              uint32 *flags)
{
    int                              rc = BCM_E_NONE;
    bcm_dpp_cosq_gport_info_t        *gport_info;


    BCMDNX_INIT_FUNC_DEFS;
    gport_info = NULL ;
    /* validate gport (scheduler) */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, gport, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &gport_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (gport_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    switch ((gport_info->se_config)->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            rc = _bcm_petra_cosq_sched_hr_gport_get(unit, gport_info, gport_info->se_config, gport_info->flow_config, flags);
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
        case SOC_TMC_SCH_SE_TYPE_FQ:
        default:
            rc = BCM_E_PARAM;
            break;
    }
    if (rc != BCM_E_NONE) {
        goto err;
    }

    (*flags) |= BCM_COSQ_GPORT_SCHEDULER;

    /* In case of Scheduler component, always set num_cos_levels to 1 */
    *num_cos_levels = 1;

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (gport_info) {
            BCM_FREE(gport_info->flow_config);
            BCM_FREE(gport_info->se_config);
            BCM_FREE(gport_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (gport_info) {
        BCM_FREE(gport_info->flow_config);
        BCM_FREE(gport_info->se_config);
        BCM_FREE(gport_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ucast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags)
{
    bcm_error_t                  rc = BCM_E_NONE;
    uint8                    is_non_contiguous = FALSE;
    uint8                    is_dest_valid = FALSE;
    uint8                    is_isq = FALSE;
    int                          soc_sand_rc = 0;
    bcm_gport_t                  sysport_gport;
    int                          sysport = 0;
    int                          base_voq = 0;
    uint32                       dest_base_queue = 0;
    uint32                       queue_region;
    SOC_TMC_IPQ_QUARTET_MAP_INFO     queue2flow;
    unsigned indirect_mode = 1;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE;
    uint8 nof_iter = 0;
    uint8 sw_state_num_cos;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    is_isq = (BCM_COSQ_GPORT_IS_ISQ(gport)) ? TRUE: FALSE;
    if(ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        indirect_mode = 0;
    }

    *flags = 0;
    if (is_isq) {
        base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    }

    if (base_voq >= SOC_DPP_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) delete uc q gport(0x%08x) failed, core out of range %d"), unit, gport, core));
    }
    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* Find the queue to flow mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
        (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_voq), &queue2flow)));
    
    rc = handle_sand_result(soc_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed base queue(%d)"), base_voq));
    }

    sysport = queue2flow.system_physical_port;

    /* determine if this queue group is non-flow based */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_dest_valid, &is_sw_only, &dest_base_queue)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
          (_BSL_BCM_MSG("retrieving base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), 
          sysport, soc_sand_rc, rc));
    }

    if (indirect_mode) {
        /* From the queue to flow mapping, get the system port */
        BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, sysport);

        /* return the physical port given the system port */
        rc = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, physical_port);

        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
              (_BSL_BCM_MSG("Unit(%d) sysport(%d) not mapped for base queue(%d)"), unit, sysport, base_voq));
        }
    } else { /* direct mode */
        BCM_GPORT_MODPORT_SET(*physical_port, queue2flow.fap_id, queue2flow.fap_port_id);
    }
    /* update parameters */
    /*If dest_base_queue != base_voq, then we should use tm flow ID */
    (*flags) |= (dest_base_queue != base_voq) ? BCM_COSQ_GPORT_TM_FLOW_ID : 0;
    if (is_isq) {
        (*flags) |= BCM_COSQ_GPORT_ISQ;
    } else {
        (*flags) |= BCM_COSQ_GPORT_UCAST_QUEUE_GROUP;
    }
    (*flags) |= (queue2flow.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                  (_BSL_BCM_MSG("unit %d, error in retreiving queue region %d,error 0x%x\n"), unit, queue_region, rc));
    }
    
    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) gport get voq group internal state get"), unit, base_voq));
        }
        if (!nof_iter){
            *num_cos_levels = sw_state_num_cos;
        }
        nof_iter++;
    }
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_mcast_gport_get(int unit,
                bcm_gport_t gport,
                bcm_gport_t *physical_port,
                uint32 *num_cos_levels,
                uint32 *flags)
{
    bcm_error_t                  rc = BCM_E_NONE;
    uint8                    is_non_contiguous = FALSE;
    int                          soc_sand_rc = 0;
    bcm_gport_t                  sysport_gport;
    int                          sysport = 0;
    int                          base_voq = 0;
    int                          start_fmq = 0, end_fmq;
    SOC_TMC_IPQ_QUARTET_MAP_INFO     queue2flow;
    uint32                       queue_region;
    unsigned                    indirect_mode = 1;
    int                         core = BCM_CORE_ALL, core_index;
    uint8                       nof_iter = 0;
    uint8                       sw_state_num_cos;

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    if(ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
        indirect_mode = 0;
    }

    *flags = 0;
    base_voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
        
    rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMin,&start_fmq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    rc = bcm_petra_fabric_control_get(unit,bcmFabricMulticastQueueMax,&end_fmq);
    BCMDNX_IF_ERR_EXIT(rc);
    
    if (base_voq > DPP_DEVICE_PETRA_COSQ_MAX_QUEUE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("unit(%d) get mc q %d failed, queue out of range"),
          unit, base_voq));
    }
    
    if (base_voq < start_fmq || base_voq > end_fmq) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("unit(%d) get mc q %d failed, queue out of range of multicast fabric queues"),
          unit, base_voq));
    }

    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* Find the queue to flow mapping */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
        (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(base_voq), &queue2flow)));
    
    rc = handle_sand_result(soc_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed base queue(%d)"), base_voq));
    }

    sysport = queue2flow.system_physical_port;

    if (indirect_mode) {
        if (sysport == SOC_TMC_SYS_PHYS_PORT_INVALID_INDIRECT) { /* if not mapped return 0 */
            *physical_port = 0;
        } else {
            /* From the queue to flow mapping, get the system port */
            BCM_GPORT_SYSTEM_PORT_ID_SET(sysport_gport, sysport);
    
            rc = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, physical_port);
    
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
                  (_BSL_BCM_MSG("Unit(%d) sysport(%d) not mapped for base queue(%d)"), 
                  unit, queue2flow.system_physical_port, base_voq));
            }
        }
    } else {
        if (queue2flow.fap_id == SOC_TMC_MAX_FAP_ID) { /* if not mapped return 0 */
            *physical_port = 0;
        } else {
            bcm_port_t fap_port;
            rc = bcm_petra_tm_port_get(unit, core, queue2flow.fap_port_id, &fap_port);
            BCMDNX_IF_ERR_EXIT(rc);
            BCM_GPORT_MODPORT_SET(*physical_port, queue2flow.fap_id, fap_port);
        }
    }

    /* update parameters */
    (*flags) |= BCM_COSQ_GPORT_MCAST_QUEUE_GROUP;
    (*flags) |= (queue2flow.is_composite) ? BCM_COSQ_GPORT_COMPOSITE : 0;

    /* determine flow attributes (non-contiguous) */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, 
                  (_BSL_BCM_MSG("unit %d, error in retreiving queue region %d,error 0x%x\n"), unit, queue_region, rc));
    }

    (*flags) |= (is_non_contiguous) ? BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR : 0;

    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos <= 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_RESOURCE, (_BSL_BCM_MSG("Unit(%d) voq(%d) gport get voq group internal state get"), unit, base_voq));
        }
        if (!nof_iter) {
            *num_cos_levels = sw_state_num_cos;
        }
        nof_iter++;
    }

exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_connector_gport_detach(int unit, bcm_gport_t sched_port, bcm_gport_t input_port, bcm_cos_queue_t cosq)
{
    int                              rc = BCM_E_NONE;
    int                              is_parent_reserved_res = FALSE;
    bcm_dpp_cosq_gport_info_t        *child_info ;
    bcm_dpp_cosq_gport_info_t        *parent_info ;
    uint32                           soc_sand_rc, nof_remote_cores, region;
    int                              child_mode, flow_id_index;
    SOC_TMC_SCH_SE_INFO             *default_se_info = NULL;
    SOC_TMC_SCH_FLOW                *default_sch_flow = NULL;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    SOC_TMC_SCH_FLOW                     exact_flow_config;
    int                              parent_se_port, dummy_tc;
    bcm_gport_t                      parent_port;
    int                              core, flow_id, i, orig_sub_flow0_id, orig_sub_flow1_id;
    SOC_TMC_SCH_SE_ID                sw_state_default_se;
    uint32                           sw_state_ref_cnt;

    BCMDNX_INIT_FUNC_DEFS;
    child_info = NULL ;
    parent_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, sched_port, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for sched_port: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)sched_port, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    
    BCMDNX_ALLOC(default_se_info, sizeof(SOC_TMC_SCH_SE_INFO), "se");
    BCMDNX_ALLOC(default_sch_flow, sizeof(SOC_TMC_SCH_FLOW), "sch flow");

    if ( (default_se_info == NULL) || (default_sch_flow == NULL) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_MEMORY;
         goto err;
    }

    SOC_TMC_SCH_FLOW_clear(unit, default_sch_flow);
    SOC_TMC_SCH_SE_INFO_clear(default_se_info);

    /* determine if parent port refers to a pre-allocated resource */
    rc = _bcm_petra_cosq_parent_gport_to_resource_gport(unit, sched_port, 0, &parent_port);
    if (rc != BCM_E_NONE) {
         goto err;
    }

    if (SOC_IS_QAX(unit)) {
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &parent_port, core);
        _bcm_petra_cosq_gport_qax_flow_id_add(unit, &input_port, core);
    }
    /* validate parent element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, parent_port, 0, dpp_device_cosq_gport_parent_element, &parent_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (parent_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* validate child element */
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, input_port, cosq, dpp_device_cosq_gport_child_element, &child_info);
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (child_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* make sure the parent is a SE */
    if ( !(parent_info->is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, sched_port));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if parent scheduler element is a reserved resource       */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    if (parent_info->is_se) {
        rc = _bcm_petra_cosq_se_id2port(unit, core, parent_info->se_id, &parent_se_port, &dummy_tc);
        if (rc != BCM_E_NONE)
        {
          LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                                "unit %d, Error retreving port id from SE %d\n"), unit,parent_info->se_id));          
          goto err;
        }     
    }
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if ( (parent_info->is_se) &&
                        ( (parent_se_port != DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ||
                          (parent_info->se_id == sw_state_default_se) ) ) {
        is_parent_reserved_res = TRUE;
    }
    flow_id_index = (child_info->is_sf2 == TRUE) ? 1 : 0;
    cs_info = &(child_info->flow_config->sub_flow[flow_id_index].credit_source);

    /* consistency checks. */
    /* verify child scheduler connection to parent scheduler              */
    if ( (parent_info->se_config)->id !=
                       (child_info->flow_config)->sub_flow[flow_id_index].credit_source.id ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, resource memory allocation failure\n"), unit));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* if already detached return error */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (parent_info->se_id == sw_state_default_se) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, detach operation on input_port:cos(0x%x:%d) error, already detached\n"), unit, input_port, cosq));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* verify reference count is greater then 0 */
    if (is_parent_reserved_res == FALSE) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, (parent_info->se_config)->id, &sw_state_ref_cnt));

        if (sw_state_ref_cnt <= DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) Parent SE(%d) reference count is 0\n"),
                                  unit, (parent_info->se_config)->id));
            rc = BCM_E_INTERNAL;
            goto err;
        }
    }

    /* detach by setting to default SE */
    /* determine scheduling mode of child with respect to parent */
    rc = _bcm_petra_cosq_mode_get(unit, core, child_info->flow_config, child_info->is_sf2, &child_mode);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving child element scheduling mode, error 0x%x\n"), unit, rc));
        goto err;
    }

    /* retrieve default SE configuration */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, sw_state_default_se, default_se_info, default_sch_flow)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
            (BSL_META_U(unit,
                "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, sw_state_default_se, soc_sand_rc, rc));
        goto err;
    }

    /* attach to default / reserved SE */
    cs_info->se_type = default_se_info->type;
    cs_info->id = sw_state_default_se;

    /* set all symmetric connections */
    if (child_info->is_connector) {
        region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(child_info->flow_id);
        nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][region];
    } else {
        nof_remote_cores = 1;
    }

    orig_sub_flow0_id = child_info->flow_config->sub_flow[0].id;
    orig_sub_flow1_id = child_info->flow_config->sub_flow[1].id;

    for (i = 0; i < nof_remote_cores; i++) {           
        flow_id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(child_info->flow_id, nof_remote_cores, i);

        child_info->flow_config->sub_flow[0].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow0_id, 
                                                                                                       nof_remote_cores, i);
        child_info->flow_config->sub_flow[1].id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(orig_sub_flow1_id, 
                                                                                                       nof_remote_cores, i);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id, child_info->flow_config, &exact_flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d\n"), unit, flow_id));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
                child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
            }
/* } */
#endif
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        child_info->flow_config->sub_flow[0].id = orig_sub_flow0_id ;
        child_info->flow_config->sub_flow[1].id = orig_sub_flow1_id ;
    }
/* } */
#endif

    /* decrement reference count of parent */
    if (is_parent_reserved_res == FALSE) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, (parent_info->se_config)->id, sw_state_ref_cnt - 1));
    }

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
   BCM_FREE(default_se_info);
   BCM_FREE(default_sch_flow);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (parent_info) {
            BCM_FREE(parent_info->flow_config);
            BCM_FREE(parent_info->se_config);
            BCM_FREE(parent_info);
        }
        if (child_info) {
            BCM_FREE(child_info->flow_config);
            BCM_FREE(child_info->se_config);
            BCM_FREE(child_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (parent_info) {
        BCM_FREE(parent_info->flow_config);
        BCM_FREE(parent_info->se_config);
        BCM_FREE(parent_info);
    }
    if (child_info) {
        BCM_FREE(child_info->flow_config);
        BCM_FREE(child_info->se_config);
        BCM_FREE(child_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_gport_delete(int unit, bcm_gport_t gport)
{
    int                              rc = BCM_E_NONE;
    int                              is_port_reserved_res = FALSE, is_enhanced = FALSE;
    int                              enhanced_mode;
    bcm_dpp_cosq_gport_info_t        *port_info ;
    bcm_dpp_cosq_gport_info_t        *dual_port_info ;
    SOC_TMC_SCH_FLOW                 exact_flow_config;
    bcm_gport_t                      pir_gport;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE  *cs_info;
    uint32                           soc_sand_rc, flags = 0;
    int                              second_flow_id; /* composite or dual */
    int                              res_flow_id; /* fq adjustment for low level alloaction */
    int                              is_last;
    int                              core ;
    SOC_TMC_SCH_SE_ID                sw_state_default_se;
    uint32                           sw_state_ref_cnt;
    bcm_dpp_cosq_flow_config_t       flow_zero = {0};
    bcm_dpp_cosq_se_config_t         se_zero = {0};
    int                              flow_id;


    BCMDNX_INIT_FUNC_DEFS;
    dual_port_info = NULL ;
    port_info = NULL ;
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
    
    /* validate gport element */
    if (SOC_IS_QAX(unit)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, BCM_GPORT_SCHEDULER_GET(gport));
        BCM_GPORT_SCHEDULER_CORE_SET(gport, flow_id, core);
    }
    rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, gport, 0, dpp_device_cosq_gport_sched_nocirpir_ds_element, &port_info); 
    if (rc != BCM_E_NONE) {
        goto err;
    }
    if (port_info == NULL) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
               (BSL_META_U(unit,
                   "unit %d, resource memory allocation failure\n"), unit));
        rc = BCM_E_MEMORY;
        goto err;
    }

    /* make sure the gport is a SE */
    if ( !(port_info->is_se) ) {
         LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                               "unit %d, sched_port(0x%x) during detach is not a SE\n"), unit, gport));
         rc = BCM_E_PARAM;
         goto err;
    }

    /* determine if scheduler element is a reserved resource              */
    /* (e.g. port schedulers, multicast schedulers, etc). These resources */
    /* cannot be deleted and thus no reference count is maintained        */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (port_info->is_se) {
        if (port_info->se_id == sw_state_default_se) {
            is_port_reserved_res = TRUE;
        }
        if (is_port_reserved_res == TRUE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "unit %d, gport(0x%x) is a reserved resource and cannot be deleted\n"), unit, gport));
             rc = BCM_E_PARAM;
             goto err;
        }
    }

    /* check if the SE is not referenced */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, port_info->se_id, &sw_state_ref_cnt));

    if (sw_state_ref_cnt > DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) reference count(%d) not zero \n"),
                              unit, port_info->se_id, sw_state_ref_cnt));
        rc = BCM_E_INTERNAL;
        goto err;
    }

    /* check if the SE is detached */
    cs_info = &(port_info->flow_config->sub_flow[0].credit_source);
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (cs_info->id != sw_state_default_se) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
        rc = BCM_E_PARAM;
        goto err;
    }
    if (port_info->is_composite == TRUE) {
        cs_info = &(port_info->flow_config->sub_flow[1].credit_source);
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
        if (cs_info->id != sw_state_default_se) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
            rc = BCM_E_PARAM;
            goto err;
        }
    }

    /* if dual shaper configuration, check that dual SE is not referenced */
    if (port_info->is_dual) {
        BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(pir_gport, gport, core);

        rc = _bcm_petra_cosq_alloc_n_gport_validate_info_get(unit, pir_gport, 0, dpp_device_cosq_gport_parent_element, &dual_port_info);
        if (rc != BCM_E_NONE) {
            goto err;
        }
        if (dual_port_info == NULL) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                   (BSL_META_U(unit,
                       "unit %d, resource memory allocation failure\n"), unit));
            rc = BCM_E_MEMORY;
            goto err;
        }

        if (dual_port_info->is_se != TRUE) {
            rc = BCM_E_PARAM;
            goto err;
        }

        cs_info = &(dual_port_info->flow_config->sub_flow[0].credit_source);
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
        if (cs_info->id != sw_state_default_se) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) scheduler SE(%d) not detached\n"), unit, cs_info->id));
            rc = BCM_E_PARAM;
            goto err;
        }
    }

    /* disable SE */
    (port_info->se_config)->state = SOC_TMC_SCH_SE_STATE_DISABLE;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, port_info->se_id, port_info->se_config, port_info->flow_config, &exact_flow_config)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, port_info->se_id, soc_sand_rc, rc));
        goto err;
    }

    if (port_info->is_dual) {
        (dual_port_info->se_config)->state = SOC_TMC_SCH_SE_STATE_DISABLE;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, dual_port_info->se_id, dual_port_info->se_config, dual_port_info->flow_config, &exact_flow_config)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, dual_port_info->se_id, soc_sand_rc, rc));
            goto err;
        }
    }

    /* free template resources */
    if ((port_info->se_config)->type == SOC_TMC_SCH_SE_TYPE_CL) {
        rc = _bcm_dpp_am_template_cosq_sched_class_free(unit, core, (port_info->se_config)->type_info.cl.id, &is_last);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in freeing class template cid(%d), error 0x%x\n"), unit, (port_info->se_config)->type_info.cl.id, rc));
            goto err;
        }

        LOG_DEBUG(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "DBG unit %d, CL template(%d) is_last(%s)\n"), unit, (port_info->se_config)->type_info.cl.id, ((is_last == TRUE) ? "TRUE" : "FALSE")));

    }

    /* free resources */
    switch ((port_info->se_config)->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, core, flags, port_info->is_composite, FALSE, port_info->is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, port_info->flow_id);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case SOC_TMC_SCH_SE_TYPE_CL:
            rc = _bcm_petra_cosq_sched_enhanced_mode_get(unit, core, port_info->se_config, &is_enhanced, &enhanced_mode);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, core, flags, port_info->is_composite, is_enhanced, port_info->is_dual, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_CL, port_info->flow_id);
            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;

        case SOC_TMC_SCH_SE_TYPE_FQ:
        default:
            res_flow_id = port_info->flow_id;

            rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, core, flags, port_info->is_composite, FALSE, port_info->is_dual, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_FQ, res_flow_id);

            if (rc != BCM_E_NONE) {
                goto err;
            }

            break;
    }


    /* free flow resources */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.set(unit, core, port_info->flow_id, &flow_zero));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        bcm_petra_vig_delete_this_flow(unit, core, Vig_db[unit], port_info->flow_id) ;
    }
/* } */
#endif

    if ( (port_info->is_composite) || (port_info->is_dual) ) {
        if (port_info->is_composite) {
            rc = _bcm_petra_se_composite_flow_id_get(unit, port_info->flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &second_flow_id);
        }
        if (port_info->is_dual) {
            rc = _bcm_petra_se_dual_flow_id_get(unit, port_info->flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &second_flow_id);
        }
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Unit(%d) failed to get sub-flow 2 for flow_id(%d)\n"), unit, port_info->flow_id));
            goto err;
        }

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.set(unit, core, second_flow_id, &flow_zero));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
        {
            bcm_petra_vig_delete_this_flow(unit,core,Vig_db[unit], second_flow_id) ;
        }
/* } */
#endif
    }

    /* free SE resources */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.set(unit, core, port_info->se_id, &se_zero));
    if (port_info->is_dual) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.set(unit, core, dual_port_info->se_id, &se_zero));
    }

    BCM_EXIT;

err:

    BCMDNX_IF_ERR_EXIT(rc);
exit:
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (!(SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation))
    {
        /*
         * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
         * {provided pointer is not NULL}.
         */
        if (port_info) {
            BCM_FREE(port_info->flow_config);
            BCM_FREE(port_info->se_config);
            BCM_FREE(port_info);
        }
        if (dual_port_info) {
            BCM_FREE(dual_port_info->flow_config);
            BCM_FREE(dual_port_info->se_config);
            BCM_FREE(dual_port_info);
        }
    }
/* } */
#else
/* { */
    /*
     * Free memory allocated by _bcm_petra_cosq_alloc_n_gport_validate_info_get()
     * {provided pointer is not NULL}.
     */
    if (port_info) {
        BCM_FREE(port_info->flow_config);
        BCM_FREE(port_info->se_config);
        BCM_FREE(port_info);
    }
    if (dual_port_info) {
        BCM_FREE(dual_port_info->flow_config);
        BCM_FREE(dual_port_info->se_config);
        BCM_FREE(dual_port_info);
    }
/* } */
#endif
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_connector_gport_delete(int unit, bcm_gport_t gport)
{
    int                               rc = BCM_E_NONE;
    uint32                            soc_sand_rc, nof_remote_cores, region;
    uint32                            flags = 0;
    uint8                             is_non_contiguous, is_composite;
    int                               base_flow_id, numq, flow_region, is_odd_even;
    int                               is_cl_cir;
    int                               cur_flow_id, cur_connector, cur_comp_flow_id;    
    SOC_TMC_SCH_FLOW                  flow_config, exact_flow_config;
    int                              core, i, flow_id;
    SOC_TMC_SCH_SE_ID                 sw_state_default_se;
    uint8                             sw_state_num_cos;
    bcm_dpp_cosq_connector_config_t   zero = {0};

    BCMDNX_INIT_FUNC_DEFS;
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /* determine flow id */
    base_flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
    if (SOC_IS_QAX(unit)) {
        base_flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, base_flow_id);
    }
    /* consistency check - flow withen valid range */
    if (base_flow_id >= SOC_DPP_CONFIG(unit)->tm.max_connectors) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid base connector id %d"),unit, base_flow_id));
    }

    /* retrieve connector group state */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
    numq = sw_state_num_cos;

    if (numq == 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
    }

    /* determine flow attributes */
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
    BCMDNX_IF_ERR_EXIT(rc);

    SOC_TMC_SCH_FLOW_clear(unit, &flow_config);

    /* consistency check - all flows are detached */
    is_composite = FALSE;
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_petra_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE,&cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, core, cur_flow_id, &flow_config)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, cur_flow_id, soc_sand_rc, rc));
            BCM_ERR_EXIT_NO_MSG(rc);
        }

        if (cur_connector == 0) {
            /* determine flow attributes */
            is_composite = ( (flow_config.sub_flow[0].is_valid == TRUE) &&
                            (flow_config.sub_flow[1].is_valid == TRUE) ) ? TRUE : FALSE;
        }

        if (is_composite) {
            rc = _bcm_petra_composite_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite,&cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        
        /* consistency check, check that the flows match up */
        if (cur_flow_id != flow_config.sub_flow[0].id) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, flow id mismatch Expected/Actual(%d / %d)\n"), unit, cur_flow_id, flow_config.sub_flow[0].id));
        }
        if (is_composite) {
            if (cur_comp_flow_id != flow_config.sub_flow[1].id) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, Comp flow id mismatch Expected/Actual(%d / %d)"), unit, cur_comp_flow_id, flow_config.sub_flow[1].id));
            }
        }

        /* check that the flows are detached */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
        if (flow_config.sub_flow[0].credit_source.id != sw_state_default_se) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow id (%d) not detached"), unit, cur_flow_id));
        }
        if (is_composite) {
            if (flow_config.sub_flow[1].credit_source.id != sw_state_default_se) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Comp flow id (%d) not detached"), unit, cur_comp_flow_id));
            }
        }
    }

    region = _BCM_DPP_AM_COSQ_GET_REGION_INDEX_FROM_FLOW_INDEX(base_flow_id);
    nof_remote_cores = SOC_DPP_CONFIG(unit)->arad->region_nof_remote_cores[core][region];


    /* delete all flows */
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_petra_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE,&cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        /* set all symmetric connections */
        for (i = 0; i < nof_remote_cores; i++) {
            flow_id = _BCM_DPP_AM_COSQ_GET_FLOW_INDEX_FROM_REMOTE_CORE_INDEX(cur_flow_id, nof_remote_cores, i);
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, core, flow_id, &flow_config)));
            if(SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, flow_id, soc_sand_rc, rc));
                BCM_ERR_EXIT_NO_MSG(rc);
            }

            flow_config.sub_flow[0].is_valid = FALSE;
            if (is_composite) {
                flow_config.sub_flow[1].is_valid = FALSE;
            }

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_set,(unit, core, flow_id, &flow_config, &exact_flow_config)));
            if(SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up flow %d, soc_sand error 0x%x, error 0x%x\n"), unit, flow_id, soc_sand_rc, rc));
                BCM_ERR_EXIT_NO_MSG(rc);
            }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
            if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
            {
                bcm_petra_vig_delete_this_flow(unit, core, Vig_db[unit], flow_id) ;
            }
/* } */
#endif
        }
    }

    /* free resources */
    rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, core, flags, is_composite, FALSE, FALSE, is_non_contiguous, 
                                            numq, SOC_TMC_AM_SCH_FLOW_TYPE_CONNECTOR, base_flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error freeing connector resources (baseFlowId: %d) from resource manager, error 0x%x\n"), unit, base_flow_id, rc));
        BCM_ERR_EXIT_NO_MSG(rc);
    }

    /* free flow resources */
    for (cur_connector = 0, cur_flow_id = base_flow_id; cur_connector < numq; cur_connector++) {
        rc = _bcm_petra_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, FALSE, &cur_flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_flow_id, &zero));

        if (is_composite) {
            rc = _bcm_petra_composite_flow_id_get(unit, core, base_flow_id, cur_connector, is_non_contiguous, is_composite, &cur_comp_flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, cur_comp_flow_id, &zero));
        }
    }

    /* free connector group resources */
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.set(unit, core, base_flow_id, &zero));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_mcast_gport_delete(int unit, bcm_gport_t gport)
{
    int                         rc = BCM_E_NONE, result = BCM_E_NONE;
    uint8                   is_non_contiguous = FALSE;
    int                         soc_sand_rc = 0;
    int                         base_voq = 0, voq = 0, numq = 0, queue_region;
    SOC_TMC_IPQ_QUARTET_MAP_INFO    queue2flow;
    int                         alloc_flags = 0, flow_quartet;
    SOC_SAND_U32_RANGE              mc_queue_range;
    int                         mcast_sched_mode = 0;
    int                         core = BCM_CORE_ALL, core_index;
    uint8                       nof_iters = 0; 
    int                         numq_tmp = -1;
    bcm_dpp_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DPP_DEFS_MAX(NOF_CORES)];
    bcm_cosq_ingress_queue_bundle_gport_config_t    config;
    uint8                       sw_state_num_cos;
    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    /* determine base queue id */
    base_voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
    core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);

    /* consistency checks */
    if (base_voq >= SOC_DPP_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    /* determine queue region mode */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retrieve queue group state */
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        /* consistency check that it is withen the multicast queue range */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_mult_fabric_enhanced_get,(unit, core_index, &mc_queue_range)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
              (_BSL_BCM_MSG("Unit (%d), retreiving multicast queue range failed, soc_sand error (0x%x), error 0x%x"), unit, soc_sand_rc, rc));
        }

        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        if ( (base_voq < mc_queue_range.start) || (base_voq > mc_queue_range.end) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("base voq is out of the provided range")));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        numq = sw_state_num_cos;
        if (nof_iters && numq_tmp != numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Different configuration between cores"),unit));
        }
        numq_tmp = numq;
        if (numq == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
        }
        nof_iters++;
    }
    config.numq = numq;
    rc = _bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, base_voq, FALSE, &config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);
    /* determine if queue group association with connectors is removed */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
          (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed queue(%d)"), voq));
        }

        /* check if queue is dis-connected */
        /* coverity[unsigned_compare:FALSE] */
        if ( (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) <
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) ||
             (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) >=
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, queue (%d) not dsconnected"), unit, voq));
        }
    }

    /* delete queue group */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_qrtt_unmap,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq))));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unmap of queue quartet failed Voq(%d), soc_sand error 0x%x, error 0x%x\n"), voq, soc_sand_rc, rc));
            if (flow_quartet == 0) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unmap of queue quartet failed")));
            }
        }
    }

    result = bcm_petra_fabric_multicast_scheduler_mode_get(unit, core, &mcast_sched_mode);
    BCMDNX_IF_ERR_EXIT(result);
    
    /* free resources */

    /* If multicast scheduling mode=0, queues 0-3 are used - these aren't reserved through alloc manager. *
     * otherwise, 1k queues can be used for multicast and these are managed by alloc manager              *
     */
    if (mcast_sched_mode != 0 && base_voq != 0) { /*In all modes we reserved base_fmq - no need to deallocate*/
        result = bcm_dpp_am_ingress_voq_deallocate(unit, core, alloc_flags, is_non_contiguous, numq, base_voq);
    }

    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos != 0) {
            bcm_dpp_cosq_voq_config_t zero = {0};
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &zero));
        }
    }   
    BCMDNX_IF_ERR_EXIT(rc);

    /* When deleting a new voq it is unmapped from some rate class*/
    rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, core, FALSE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(result);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ucast_gport_delete(int unit, bcm_gport_t gport)
{
    int                         rc = BCM_E_NONE, result = BCM_E_NONE;
    uint8                   is_non_contiguous = FALSE,
                                is_dest_valid, is_dest = FALSE;
    uint8                   is_isq = FALSE;
    int                         soc_sand_rc = 0;
    int                         base_voq = 0,voq = 0, numq = 0, queue_region;
    SOC_TMC_IPQ_QUARTET_MAP_INFO    queue2flow;
    int                         sysport = 0, alloc_flags = 0, flow_quartet;
    uint32                      dest_base_queue = 0;
    int core = BCM_CORE_ALL, core_index;
    uint8 is_sw_only = FALSE, nof_iters = 0;
    int                        numq_tmp = -1;
    uint32                        reference_counter;
    bcm_dpp_cosq_queue_attributes_verify_t queue_attributes_verify[SOC_DPP_DEFS_MAX(NOF_CORES)];
    bcm_cosq_ingress_queue_bundle_gport_config_t    config;
    uint8                       sw_state_num_cos;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue2flow);

    is_isq = (BCM_COSQ_GPORT_IS_ISQ(gport)) ? TRUE: FALSE;

   /* determine base queue id */
    if (is_isq) {
        base_voq = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else {
        base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    }

    /* consistency checks */
    if (base_voq >= SOC_DPP_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

    if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) get uc q gport(0x%08x failed, core out of range %d"), unit, gport, core));
    }

    /* check reference counter, if more than 1 SYSPORT points to this VOQ, it can't be deleted */
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.ref_cnt.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &reference_counter));
        if (reference_counter > 1) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) VOQ (0x%08x) still has slave sysports pointing to it , delete failed"), unit, gport));
        }
    }

    /* determine queue region mode */
    queue_region = BCM_DEVICE_PETRA_COSQ_QUEUE_REGION_GET(base_voq);
    rc = _bcm_petra_queue_region_config_get(unit, core, queue_region, &is_non_contiguous);
    BCMDNX_IF_ERR_EXIT(rc);

    /* retrieve queue group state */
    

    /* retrieve queue group state */
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        numq = sw_state_num_cos;
        if (nof_iters && numq_tmp != numq) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Different configuration between cores"),unit));
        }
        numq_tmp = numq;
        if (numq == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid numq parameter %d"),unit, numq));
        }
        nof_iters++;
    }
    config.numq = numq;
    rc = _bcm_petra_cosq_ingress_queue_bundle_gport_fill_and_verify(unit, core, base_voq, FALSE, &config, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);
    /* determine if queue group association with connectors is removed */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
            (unit, core ,SOC_TMC_IPQ_Q_TO_QRTT_ID(voq), &queue2flow)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
              (_BSL_BCM_MSG("soc_petra_ipq_queue_to_flow_mapping_get() failed queue(%d)"), voq));
        }

        /* determine state */
        if (flow_quartet == 0) {
            sysport = queue2flow.system_physical_port;
        }

        /* check if queue is dis-connected */
        /* coverity[unsigned_compare:FALSE] */
        if ( (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) <
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) ||
             (SOC_TMC_SCH_QRTT_TO_FLOW_ID(queue2flow.flow_quartet_index) >=
                                 DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, queue (%d) not disconnected"), unit, voq));
        }
    }

    /* determine if this queue group is non-flow based */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_dest_valid, &is_sw_only, &dest_base_queue)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
          (_BSL_BCM_MSG("retreiving base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), sysport, soc_sand_rc, rc));
    }

    if (dest_base_queue == base_voq) {
        is_dest = TRUE;

        /* disable configuration */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_set,
            (unit, core, sysport, FALSE, is_sw_only, dest_base_queue)));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            BCMDNX_ERR_EXIT_MSG(translate_sand_success_failure(soc_sand_rc),
              (_BSL_BCM_MSG("disabling base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), sysport, soc_sand_rc, rc));
        }
    }

    /* delete queue group */
    for (flow_quartet = 0, voq = base_voq; voq < (base_voq + numq);
                       flow_quartet++, voq += DPP_DEVICE_COSQ_NBR_QUEUES_IN_QUARTET) {
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_qrtt_unmap,
            (unit, core, SOC_TMC_IPQ_Q_TO_QRTT_ID(voq))));
        if (SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unmap of queue quartet failed Voq(%d), soc_sand error 0x%x, error 0x%x\n"), voq, soc_sand_rc, rc));
            if ( (flow_quartet == 0) && (is_dest == FALSE) ) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unmap of queue quartet failed")));
            }
        }
    }

    /* free resources */
    result = bcm_dpp_am_ingress_voq_deallocate(unit, core, alloc_flags, is_non_contiguous, numq, base_voq);
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &sw_state_num_cos));
        if (sw_state_num_cos != 0) {
            bcm_dpp_cosq_voq_config_t zero = {0};
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), &zero));
        }
    }

    /* reset reference counter */
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.ref_cnt.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, base_voq), 0));
    }

    BCMDNX_IF_ERR_EXIT(rc);

    /* When deleting a new voq it is unmapped from some rate class*/
    rc = _bcm_petra_cosq_ingress_queue_bundle_ref_count_update(unit, core, FALSE, queue_attributes_verify);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(result);
exit:
BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_sched_cl_profile_get(int unit, int mode, int enhanced_mode, int weight_mode, int validate_only, int *cid)
{
    int rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    (*cid) = -1;
    switch(weight_mode) {
        case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_ind;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_ind_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_ind_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_ind;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_ind_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_ind_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_ind;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_ind_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_ind_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_1:
                case SOC_TMC_SCH_CL_MODE_2:
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_1:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode1;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode1_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode1_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_2:
                case SOC_TMC_SCH_CL_MODE_3:
                case SOC_TMC_SCH_CL_MODE_4:
                case SOC_TMC_SCH_CL_MODE_5:
                    rc = BCM_E_PARAM;
                    break;
            }
            break;

        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_des_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_des_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_des_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = BCM_E_PARAM;
                    break;
                case SOC_TMC_SCH_CL_MODE_2:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_des;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_des_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_des_elp_fq;
                            break;
                    }
                    break;
            }
            break;

        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
            switch (mode) {
                case SOC_TMC_SCH_CL_MODE_3:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode3_cls_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_4:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode4_cls_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_5:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode5_cls_elp_fq;
                            break;
                    }
                    break;
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = BCM_E_PARAM;
                    break;
                case SOC_TMC_SCH_CL_MODE_2:
                    switch (enhanced_mode) {
                        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_cls;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_cls_ehp_fq;
                            break;
                        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
                            (*cid) = bcm_dpp_cosq_cl_cid_mode2_cls_elp_fq;
                            break;
                    }
                    break;
            }
            break;

        default:
            rc = BCM_E_PARAM;
            break;
    }

    if (validate_only == TRUE) {
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
    
    if ((*cid) != -1) {
        BCMDNX_IF_ERR_EXIT(rc); /* does nothing */
        BCM_EXIT;
    }

    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid CL settings")));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_sched_cl_verify_flags_mode_get(int unit, int flags, int *cl_mode, int *enhanced_mode, int *weight_mode)
{
    int rc = BCM_E_NONE;
    int cl_type_flags, cl_enhanced_flags, cl_weight_flags, cid;
    SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE configured_ipf_mode = SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES;
    SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE ipf_mode;
    int  soc_sand_rc = 0;



    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    cl_type_flags = (flags & DPP_DEVICE_COSQ_CL_MASK);
    cl_enhanced_flags = (flags & DPP_DEVICE_COSQ_CL_ENHANCED_MASK);
    cl_weight_flags = (flags & DPP_DEVICE_COSQ_CL_WFQ_MASK);

    /* consistency check of cl type */
    switch (cl_type_flags) {
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE1_4SP:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_1;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE2_3SP_WFQ:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_2;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE3_WFQ_2SP:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_3;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE4_2SP_WFQ:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_4;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_MODE5_1SP_WFQ:
            (*cl_mode) = SOC_TMC_SCH_CL_MODE_5;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl type flags parameter 0x%x\n"), unit, cl_type_flags));
            rc = BCM_E_PARAM;
            break;
    }

    /* consistency check of cl enhanced mode */
    switch (cl_enhanced_flags) {
        case 0:
            (*enhanced_mode) = SOC_TMC_CL_ENHANCED_MODE_DISABLED;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_HIGHPRI_FQ:
            (*enhanced_mode) = SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_ENHANCED_LOWPRI_FQ:
            (*enhanced_mode) = SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl enhanced flags parameter 0x%x\n"), unit, cl_enhanced_flags));
            rc = BCM_E_PARAM;
            break;
    }
    /* consistency check of cl weight mode */
    switch (cl_weight_flags) {
        case 0:
            (*weight_mode) = SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT:
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT_PROPORTIONAL:
            ipf_mode = (BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_INDEPENDENT == cl_weight_flags) ? SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_INVERSE : SOC_TMC_SCH_FLOW_IPF_CONFIG_MODE_PROPORTIONAL; 
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_ipf_mode_get,(unit, &configured_ipf_mode)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, get ipf mode, soc_sand error 0x%x, error 0x%x\n"), unit, soc_sand_rc, rc));
                break;
            }
            /* ipf mode not initialized*/
            if (configured_ipf_mode == SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES){
                uint32 soc_sand_rc;
                soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_ipf_mode_set,(unit, ipf_mode)));
                if (SOC_SAND_FAILURE(soc_sand_rc)) {
                    rc = translate_sand_success_failure(soc_sand_rc);
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, set ipf mode %d, soc_sand error 0x%x, error 0x%x\n"), unit, ipf_mode, soc_sand_rc, rc));
                    break;
                }
            }
            else if(configured_ipf_mode != ipf_mode){
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, you can not use inverse and proportinal Independent per flow CL\n"), unit));
                rc = BCM_E_PARAM;
                break;
            }
            (*weight_mode) = SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_DISCREET:
            (*weight_mode) = SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW;
            break;
        case BCM_COSQ_GPORT_SCHEDULER_CLASS_WFQ_MODE_CLASS:
            (*weight_mode) = SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, Invalid cl weight flags parameter 0x%x\n"), unit, cl_weight_flags));
            rc = BCM_E_PARAM;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);

    /* consistency check across {type, enhanced mode, weight mode } */
    rc = _bcm_petra_sched_cl_profile_get(unit, (*cl_mode), (*enhanced_mode), (*weight_mode), TRUE, &cid);
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* STATIC */ int
_bcm_petra_sched_cl_nbr_discrete_levels_get(int unit, int cl_mode, int *nbr_levels)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch(cl_mode) {
        case SOC_TMC_SCH_CL_MODE_1:
            (*nbr_levels) = 0;
            break;

        case SOC_TMC_SCH_CL_MODE_2:
            (*nbr_levels) = 2;
            break;

        case SOC_TMC_SCH_CL_MODE_3:
            (*nbr_levels) = 3;
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            (*nbr_levels) = 3;
            break;

        case SOC_TMC_SCH_CL_MODE_5:
            (*nbr_levels) = 4;
            break;

        default:
            (*nbr_levels) = 0;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cl mode 0x%x"), unit, cl_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* STATIC */ int
_bcm_petra_sched_cl_default_cl_weights_get(int unit, int cl_mode, int *weights)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(weights, 0, (sizeof(int) * SOC_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS));

    switch(cl_mode) {
        case SOC_TMC_SCH_CL_MODE_1:
            break;

        case SOC_TMC_SCH_CL_MODE_2:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            break;

        case SOC_TMC_SCH_CL_MODE_3:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            break;

        case SOC_TMC_SCH_CL_MODE_4:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            break;

        case SOC_TMC_SCH_CL_MODE_5:
            *(weights + 0) = 1;
            *(weights + 1) = 2;
            *(weights + 2) = 4;
            *(weights + 3) = 8;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid cl mode 0x%x"), unit, cl_mode));
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_sched_cl_dynamic_profile_init(int unit)
{
    int rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_sched_class_template_add(int unit, int core,
                                    int mode,
                                    int enhanced_mode,
                                    int weight_mode,
                                    int *weights,
                                    int flags,
                                    int *template,
                                    int *is_allocated,
                                    int ref_cnt)
{
    int                              rc = BCM_E_NONE;
    bcm_dpp_cosq_sched_class_data_t  class_data;
    int                              expected_template = -1;
    int                              ref_count, count;



    BCMDNX_INIT_FUNC_DEFS;
    ref_count = (ref_cnt > 0) ? ref_cnt : 1;

    /* consistency check */
    if (flags & BCM_DPP_AM_TEMPLATE_FLAG_ALLOC_WITH_ID) {
        expected_template = (*template);
    }

    DPP_DEVICE_COSQ_CL_CLASS_DATA_INIT(class_data, mode, enhanced_mode, weight_mode, weights);

    for (count = 0; count < ref_count; count++) {
        rc = _bcm_dpp_am_template_cosq_sched_class_allocate(unit, core, flags, (int *)&class_data, is_allocated, template);

        BCMDNX_IF_ERR_EXIT(rc);

        /* consistency check */
        if (expected_template != -1) {
            rc = (expected_template != (*template)) ? BCM_E_INTERNAL : rc; 
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,(_BSL_BCM_MSG("unit %d, Unexpected Sched Class Template, Expected(%d) Actual(%d)\n"), unit, expected_template, (*template)));        
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * initialize cl profiles.
 * Only fixed profiles are initialized
 *
 * Consider adding support for profile management via template (discrete weights)
 */
STATIC int
_bcm_petra_sched_cl_profile_init(int unit)
{
    int rc = BCM_E_NONE;
    SOC_TMC_SCH_SE_CL_CLASS_TABLE *cl_class_table = NULL, *exact_cl_class_table = NULL;
    uint32 soc_sand_rc;    
    int weights[SOC_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS];
    int template, flags = BCM_DPP_AM_TEMPLATE_FLAG_ALLOC_WITH_ID, is_allocated;    
    int core ;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCMDNX_ALLOC(cl_class_table, sizeof(SOC_TMC_SCH_SE_CL_CLASS_TABLE), "class table");
    if (cl_class_table == NULL) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }
    BCMDNX_ALLOC(exact_cl_class_table, sizeof(SOC_TMC_SCH_SE_CL_CLASS_TABLE), "class table");
    if (exact_cl_class_table == NULL) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, resource memory allocation failure"), unit));
    }

    BCM_DPP_CORES_ITER(BCM_CORE_ALL, core){
        SOC_TMC_SCH_SE_CL_CLASS_TABLE_clear(cl_class_table);
        SOC_TMC_SCH_SE_CL_CLASS_TABLE_clear(exact_cl_class_table);    
    
        cl_class_table->nof_class_types = bcm_dpp_cosq_cl_cid_last;
    
        /* weight mode - independent */
        sal_memset(weights, 0, (sizeof(int) * SOC_TMC_SCH_MAX_NOF_DISCRETE_WEIGHT_VALS));
    
        /* initialization of default templates. Default templates are allocated thus giving them */
        /* a reference count of one. This will ensure (without any additional checks) that the   */
        /* default templates nver get freed.                                                     */
        rc = _bcm_dpp_am_template_cosq_sched_class_init(unit);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 3
         */
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_ind, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_ind_ehp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_ind_elp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode3_ind;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode3_ind_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode3_ind_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 4
         */
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_ind, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_ind_ehp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_ind_elp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode4_ind;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode4_ind_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode4_ind_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 5
         */
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_ind, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_ind_ehp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_ind_elp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode5_ind;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode5_ind_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode5_ind_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * independent per flow - mode 1
         */
        /* weight mode - none.  setting weights mode to SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST */
        /* causes error.  Instead set h/w to SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW. */
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode1, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode1_ehp_fq, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode1_elp_fq, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode1;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode1_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode1_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_1, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * When discrete weight functionality will be supported this will be via
         * template management
         */
        /* weight mode - discrete flow */
        /*
         * discrete flow - mode 3
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_3, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_des, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_des_ehp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_des_elp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode3_des;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode3_des_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode3_des_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete flow - mode 4
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_4, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_des, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_des_ehp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_des_elp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode4_des;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode4_des_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode4_des_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete flow - mode 5
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_5, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_des, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_des_ehp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_des_elp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode5_des;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode5_des_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode5_des_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete flow - mode 2
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_2, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_des, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_des_ehp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_des_elp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode2_des;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode2_des_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode2_des_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /* weight mode - discrete per class flow */
        /*
         * discrete per class flow - mode 3
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_3, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_cls, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode3_cls_elp_fq, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode3_cls;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode3_cls_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode3_cls_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_3, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete per class flow - mode 4
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_4, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_cls, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode4_cls_elp_fq, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode4_cls;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode4_cls_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode4_cls_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_4, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete per class flow - mode 5
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_5, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_cls, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode5_cls_elp_fq, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode5_cls;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode5_cls_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode5_cls_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_5, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * discrete per class flow - mode 2
         */
        _bcm_petra_sched_cl_default_cl_weights_get(unit, SOC_TMC_SCH_CL_MODE_2, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_cls, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_cls_ehp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
        DPP_DEVICE_COSQ_CL_CLASS_TABLE_INIT(cl_class_table, bcm_dpp_cosq_cl_cid_mode2_cls_elp_fq, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights);
    
        /* add corresponding default templates */
        template = bcm_dpp_cosq_cl_cid_mode2_cls;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_DISABLED, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode2_cls_ehp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        template = bcm_dpp_cosq_cl_cid_mode2_cls_elp_fq;
        rc = _bcm_petra_sched_class_template_add(unit, core, SOC_TMC_SCH_CL_MODE_2, SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP, SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS, weights, flags, &template, &is_allocated, 2);
        BCMDNX_IF_ERR_EXIT(rc);
    
        /*
         * configure h/w
         */
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_table_set,(unit, core, cl_class_table, exact_cl_class_table)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting up cl param table\n"), unit));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }
    rc = _bcm_petra_sched_cl_dynamic_profile_init(unit);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(cl_class_table);
    BCM_FREE(exact_cl_class_table);
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_priority_mode_to_nof_priorities(int unit, 
                                                SOC_TMC_EGR_PORT_PRIORITY_MODE priority_mode, 
                                                int* nof_priorities)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (priority_mode)
    {
    case SOC_TMC_EGR_PORT_ONE_PRIORITY:
      *nof_priorities = 1;
      break;
    case SOC_TMC_EGR_PORT_TWO_PRIORITIES:
      *nof_priorities = 2;
      break;
    case SOC_TMC_EGR_PORT_EIGHT_PRIORITIES:
      *nof_priorities = 8;
      break;
    default:
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, priority type is invalid"), unit));
    }

    BCM_EXIT;
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_sched_init(int unit)
{
    bcm_error_t                 rc = BCM_E_NONE;
    int                         flow_id = 0, core = 0;
    int                         priority_i = 0;
    bcm_port_t                  port_i = 0;
    bcm_gport_t                 gport = 0;
    uint32                      res_mngr_flags = 0, nof_priorities = 0, fap_port, flags;
    uint32                      soc_sand_rc;
    SOC_TMC_SCH_FLOW            flow_config, exact_flow_config;
    SOC_TMC_SCH_SE_INFO         se_config;
    SOC_TMC_SCH_SE_ID           se_index = 0;            
    int                         index;
    int                         is_coldboot = TRUE;
    pbmp_t                      ports_map;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        is_coldboot = FALSE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    if (is_coldboot) {
        BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {

                /*Init ISQ port to invalid port*/
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.isq_port.set(unit, core, BCM_GPORT_INVALID));
                /* initialize FMQ class resources as not being allocated */
                for (index = 0; index < DPP_DEVICE_FMQ_CLASS_PORTS; index++) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.fmq_class_ports.set(unit, core, index, BCM_GPORT_INVALID));
                }

        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_ipf_mode_set,(unit, SOC_TMC_SCH_NOF_FLOW_IPF_CONFIG_MODES)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
          rc = translate_sand_success_failure(soc_sand_rc);
          BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in setting ipf initial value, soc_sand error 0x%x, rc error 0x%x"), unit, soc_sand_rc, rc));
        }
    }

    /* HR resources for ports. */
    /* In ARAD each Port-TC has HR resource */
    res_mngr_flags = BCM_DPP_AM_FLAG_ALLOC_WITH_ID;
    rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_map);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                           "unit %d, failed to get ports bmp, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCM_PBMP_ITER(ports_map, port_i) {

        SOCDNX_IF_ERR_EXIT(soc_port_sw_db_flags_get(unit, port_i, &flags));
        if (!(SOC_PORT_IS_NOT_VALID_FOR_EGRESS_TM(flags))) {
            BCM_COSQ_GPORT_E2E_PORT_SET(gport, port_i); 
            rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port_i, rc));
                continue;
            }
            if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "Invalid fap port %d\n"), fap_port));
                continue;
            }

            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port_i, &nof_priorities));
            
            for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
            {
              soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
              if(SOC_SAND_FAILURE(soc_sand_rc)) {
                  rc = translate_sand_success_failure(soc_sand_rc);
                  BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority_i, soc_sand_rc, rc));
              }
               
              if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit))
              {
                  LOG_ERROR(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, se id retrieve invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                  continue;
              }
              flow_id =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_index)));

              if (!SOC_WARM_BOOT(unit)) {
                rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, 1, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                LOG_VERBOSE(BSL_LS_BCM_COSQ,
                            (BSL_META_U(unit,
                                        "unit %d, port(%d) priority(%d) hr resources, flow_id 0x%x\n"), unit, fap_port, priority_i ,flow_id));
                }
                if (is_coldboot) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0)); 
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));
                }
            }
        }
    }
    res_mngr_flags = 0x0;

    BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        /* additional HR resource allocated to hookup objects just created */
        if (!SOC_WARM_BOOT(unit)) {
            rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, SOC_TMC_COSQ_ANY_NOF_REMOTE_CORES, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_FQ, NULL, &flow_id);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            se_index =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.set(unit, core, se_index));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_flow.set(unit, core, flow_id));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_type.set(unit, SOC_TMC_SCH_SE_TYPE_FQ));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se_class.set(unit, 0));
            LOG_VERBOSE(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                "unit %d, default fq for hookup, flow_id(%d/0x%x) se_index(%d/0x%x)\n"), unit, flow_id, flow_id, se_index, se_index));

            SOC_TMC_SCH_FLOW_clear(unit, &flow_config);

            flow_config.flow_type = SOC_TMC_FLOW_AGGREGATE;
            flow_config.is_slow_enabled = FALSE;
            flow_config.sub_flow[0].is_valid = TRUE;
            flow_config.sub_flow[0].id = flow_id;

            flow_config.sub_flow[0].credit_source.se_type = SOC_TMC_SCH_SE_TYPE_HR;
            flow_config.sub_flow[0].credit_source.se_info.hr.sp_class = SOC_TMC_SCH_FLOW_HR_CLASS_EF1;
            flow_config.sub_flow[0].credit_source.id = SOC_TMC_HR_SE_ID_MIN_ARAD; /* connect to first HR */
            /* Set SE to be disabled so it wont grant credits */
            flow_config.sub_flow[0].shaper.max_burst = 0x0;

            SOC_TMC_SCH_SE_INFO_clear(&se_config);
            se_config.id = se_index;
            se_config.state = SOC_TMC_SCH_SE_STATE_ENABLE;
            se_config.type = SOC_TMC_SCH_SE_TYPE_FQ;
            se_config.type_info.fq.no_info=0;
            se_config.is_dual = FALSE;
            se_config.group = SOC_TMC_SCH_GROUP_AUTO;

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_index, &se_config, &flow_config, &exact_flow_config)));
            if(SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, se_index, "hr", soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }
    if (is_coldboot) {
        /* state restored during warmboot */
        rc = _bcm_petra_sched_cl_profile_init(unit);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, cl profile init failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

    /*ingress scheduler init*/
    if (!SOC_IS_QAX(unit)) {
        /* The following functionality is done in QAX as part of soc_qax_tbls_init */
        if (is_coldboot) 
        {
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_init, (unit)));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    SOC_DPP_WARMBOOT_RELEASE_HW_MUTEX(rc);
    if(rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              " Failed while executing the macro SOC_DPP_WARMBOOT_RELEASE_HW_MUTEX.\n")));
    }
    BCMDNX_FUNC_RETURN;
}

/* calender based flow control reception (Inband/Out-of-band) */
STATIC int
_bcm_petra_cosq_cal_reception_fc_path_add(int unit,
                           int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target,
                           int is_fc_calender,
                           int is_fc_inband, 
                           int fc_calender_port)
{
    bcm_error_t                     rc = BCM_E_NONE;
    soc_error_t                     soc_rc = SOC_E_NONE;
    SOC_TMC_FC_CAL_IF_INFO          cal_if_info;
    SOC_TMC_FC_REC_CALENDAR         *cal_buff = NULL;
    SOC_TMC_FC_REC_CAL_DEST         cal_dest = SOC_TMC_FC_REC_CAL_DEST_NONE, 
                                    cal_dest_ori = SOC_TMC_FC_REC_CAL_DEST_NONE;
    SOC_TMC_FC_PFC_GENERIC_BITMAP   generic_bm;    
    bcm_dpp_cosq_rx_cal_t           _rx_cal;
    int                             is_llfc;
    int                      valid, nof_ilkn_ports;
    uint32                   flow_id, cl_id, target_id=0;
    int                     core=0;
    bcm_port_t target_port = 0;
    uint32 phy_port = 0;
    int is_interface_port = 0;
    _bcm_dpp_pfc_bitmap_type pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT;
    uint32 base_queue_pair, nof_priorities;
    uint32 target_tm_port;
    int old_generic_bm_id = 0, generic_bm_is_last = 0, new_generic_bm_id = -1, generic_bm_is_allocated = 0;
    int pfc_bitmap_class = 0;
    int is_fc_mub = 0;
    SOC_TMC_FC_PFC_GEN_BMP_SRC_TYPE   pfc_src_type = SOC_TMC_FC_PFC_GEN_BMP_SRC_TYPES;
    uint32 is_pfc_gen_valid = 0;
    SOC_TMC_FC_PFC_MAP pfc_map;
    uint32 protocol_offset = 0, interface_type = 0;
    int max_inband_calender_index = 0;
    int max_oob_calender_index = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);

    if (source->flags & BCM_COSQ_FC_MUB) {
        is_fc_mub = 1;
    }

    SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

    if (!is_fc_mub) {
        BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_REC_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
        if (cal_buff == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
        }

        SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

        if (is_fc_inband) {
            if (fc_calender_port >= nof_ilkn_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            }

            max_inband_calender_index = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[fc_calender_port][SOC_TMC_CONNECTION_DIRECTION_RX];
            if(!SOC_IS_ARDON(unit) && ((source->calender_index < 0) || (source->calender_index >= max_inband_calender_index))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG
                    ("unit %d, invalid source calender index (%d) is out of range [0, %d]\n"), unit, source->calender_index, max_inband_calender_index - 1));
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.rx.get(unit, fc_calender_port, &_rx_cal));
        }
        else {
            if (fc_calender_port >= SOC_DPP_CONFIG(unit)->tm.max_oob_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            }

            max_oob_calender_index = SOC_DPP_CONFIG(unit)->tm.fc_oob_calender_length[fc_calender_port][SOC_TMC_CONNECTION_DIRECTION_RX];
            if(!SOC_IS_ARDON(unit) && ((source->calender_index < 0) || (source->calender_index >= max_oob_calender_index))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG
                    ("unit %d, invalid source calender index (%d) is out of range [0, %d]\n"), unit, source->calender_index, max_oob_calender_index - 1));
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.rx.get(unit, fc_calender_port, &_rx_cal));
        }

        if ((_rx_cal.valid != TRUE) && (BCM_GPORT_IS_SCHEDULER(target->port) == 0x0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, rx calender not valid for port(%d)\n"), unit, fc_calender_port));
        }

        /* retrieve calender setting */
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_get,(unit, _rx_cal.cal_mode_ndx, _rx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _rx_cal.intf, soc_rc));
        }
    
        if (is_fc_inband) {
            /* check it does not overlap with the LLFC calender space */
            if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] != SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE_DISABLE) {
                if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE1) {
                    if (source->calender_index == 0) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    }
                }
                else if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE2) {
                    if ((source->calender_index % 16) == 0) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    }
                }
            }
        }
    } else {
        /* MUB flow control */
        if ((source->calender_index < 0) || (source->calender_index >= SOC_TMC_FC_ILKN_MUB_GEN_CAL_LEN)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source calender index out of range [0, %d] \n"), unit, SOC_TMC_FC_ILKN_MUB_GEN_CAL_LEN - 1));
        }
    }

    rc = _bcm_petra_cosq_fap_port_get(unit, target->port, &target_tm_port, &core, &is_interface_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    is_llfc = (is_interface_port) ? TRUE : FALSE;

    if (SOC_IS_ARDON(unit)) {
        if (!BCM_GPORT_IS_SCHEDULER(target->port) && !BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(target->port))  {
            /* Unknow case */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Setting Schedualer CL as target gport (0x%x) supported only for Ardon (FCV)"), target->port));
        }

        valid = is_for_delete ? 0x0 : 0x1;
       
        if (BCM_GPORT_IS_SCHEDULER(target->port)) {
            /* 
             * Mapping FCV calander bit map to SCH CL 
             * Source is calender_index. Target is CL index. 
             * extract CL index: Target Scheduler gport =  (64 * 1024) + CL_Index * 4
             */
            flow_id = BCM_GPORT_SCHEDULER_GET(target->port);
            cl_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit, mbcm_dpp_sch_flow2se_id, (unit, flow_id)));

            rc = arad_fc_shr_mapping(unit, source->calender_index, cl_id, 0x0 /* select */, valid);
            BCMDNX_IF_ERR_EXIT(rc);
        } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(target->port)) {
            /* 
             * Mapping FCV calander bit map to Pair-Queue 
             * Source is calender_index. Target is pair-queue index. 
             */
            rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.base_q_pair.get(unit, target_port, &base_queue_pair);
            BCMDNX_IF_ERR_EXIT(rc);

            pfc_map.mode = SOC_TMC_FC_PFC_MAP_EGQ;
            pfc_map.index = base_queue_pair + target->cosq;
            pfc_map.valid = valid;
            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_set, (unit, source->calender_index/SOC_TMC_EGR_NOF_Q_PRIO_ARAD, source->calender_index%SOC_TMC_EGR_NOF_Q_PRIO_ARAD, &pfc_map));
            BCMDNX_IF_ERR_EXIT(soc_rc);
        }
    } 
    else if(target->flags & BCM_COSQ_FC_RETRANSMIT){
        if (SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, use SOC Property to set ILKN Retransmit Entry for Jericho\n"), unit));
        }
        else {
            /* ILKN Retransmit Entry */
            cal_dest = SOC_TMC_FC_REC_CAL_DEST_RETRANSMIT;
            target_id = fc_calender_port;
            is_llfc = FALSE;
        }
    }
    else if (is_llfc) {
        /* support LLFC setting for OOB interface. Inband Interface calender settings  */
        /* are via SOC properties.                                                     */
        if (is_fc_inband) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, LLFC setting not valid for inband interface (%d)\n"), unit, fc_calender_port));
        }

        /* validate source flags */
        if ((source->flags & (~(BCM_COSQ_FC_MUB))) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)"), unit, source->flags));
        }

        /* validate target flags */
        if (target->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)"), unit, target->flags));
        }

        /* validate source cos */
        if (!((source->cosq == 0) || (source->cosq == -1))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq specified(0x%x)"), unit, source->cosq));
        }

        /* validate target cos */
        if (target->cosq != -1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq specified(0x%x)"), unit, target->cosq));
        }

        target_id = 0;
        cal_dest = SOC_TMC_FC_REC_CAL_DEST_NIF_LL;

         /*get target type*/
         rc = soc_port_sw_db_interface_type_get(unit, target_port, &interface_type);
         BCMDNX_IF_ERR_EXIT(rc);

         if((interface_type == SOC_PORT_IF_ILKN) && !SOC_IS_ARADPLUS_AND_BELOW(unit)) {
             rc = soc_port_sw_db_protocol_offset_get(unit, target_port, 0, &protocol_offset /* ilkn id */);
             BCMDNX_IF_ERR_EXIT(rc);

             /*get nif port*/
             rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_ilkn_nif_port_get, (unit, protocol_offset, &target_id)); 
             BCMDNX_IF_ERR_EXIT(rc);
         } else {
             rc = soc_port_sw_db_first_phy_port_get(unit, target_port, &phy_port /*one based*/);
             if (rc != BCM_E_NONE) {
                 BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error retreiving phy port for port (0x%x)\n"), unit, target->port));
             }
             target_id = phy_port - 1;
         }
    }
    else { /* PFC Configuration (Not LLFC or Retransmit) */
        /* validate source flags */
        if ((source->flags & (~(BCM_COSQ_FC_MUB))) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)"), unit, source->flags));
        }

        /* Check the port queues/priorities - set DEST TYPE accordingly */
        rc = soc_port_sw_db_local_to_out_port_priority_get(unit, target_port, &nof_priorities);
        SOCDNX_IF_ERR_EXIT(rc);

        /* validate target cosq */
        if ((target->cosq < -1) || (target->cosq > (int)(nof_priorities - 1))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq specified(0x%x)"), unit, target->cosq));
        }

        /* validate target flags */
        if (target->cosq == -1) {    /* Reaction point: port */
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target flags(0x%x)"), unit, target->flags));
            }
        } else {                    /* Reaction point: port+cosq */
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_INHERIT_UP|BCM_COSQ_FC_INHERIT_DOWN))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target flags(0x%x)"), unit, target->flags));
            }
        }

        /* validate source cos */
        if ((source->cosq != -1) && (source->cosq != 0)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq specified(0x%x)"), unit, source->cosq));
        }

        rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.base_q_pair.get(unit, target_port, &base_queue_pair);
        BCMDNX_IF_ERR_EXIT(rc);

        SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

        if (!is_for_delete) {
            if (target->cosq == -1) { /* Reaction point: port */ 
                if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) || is_fc_mub) {
                    cal_dest = SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT;
                } else {
                    if (nof_priorities == 8) {
                        cal_dest = SOC_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY;
                        target_id = base_queue_pair;
                    }
                    else if (nof_priorities == 2) {
                        cal_dest = SOC_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY;
                        target_id = base_queue_pair;
                    }
                    else if (nof_priorities == 1) {
                        cal_dest = SOC_TMC_FC_REC_CAL_DEST_PFC; 
                        target_id = base_queue_pair;
                    }
                    target_id += ((core == 1) ? ARAD_EGR_NOF_BASE_Q_PAIRS : 0);
                }
            }
            else {                    /* Reaction point: port+cosq */
                if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                    cal_dest = SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_UP;
                }
                else if (target->flags & BCM_COSQ_FC_INHERIT_DOWN) {
                    cal_dest = SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_DOWN;
                }
                else if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) || is_fc_mub){
                    cal_dest = SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC; 
                    pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT_TC;
                }
                else {
                    cal_dest = SOC_TMC_FC_REC_CAL_DEST_PFC;
                    target_id = base_queue_pair + target->cosq;
                    target_id += ((core == 1) ? ARAD_EGR_NOF_BASE_Q_PAIRS : 0);
                }
            }
        }

        if (is_fc_mub) {
            cal_dest_ori = SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC;
        }
        else {
            cal_dest_ori = (cal_buff + source->calender_index)->destination;
        }

        if ((cal_dest_ori == SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC) || (cal_dest == SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC))
        {
            /* get pfc generic bitmap class */
            if (SOC_IS_JERICHO(unit)) {
                if (!is_fc_mub) {
                    pfc_bitmap_class = (is_fc_inband) ? (fc_calender_port) : (fc_calender_port+6);
                }
                else {
                    pfc_bitmap_class = fc_calender_port;
                }
            }
            else {
                pfc_bitmap_class = 0;
            }

            pfc_src_type = (is_fc_mub) ? (SOC_TMC_FC_PFC_GEN_BMP_SRC_MUB) : 
                                         ((is_fc_inband)? (SOC_TMC_FC_PFC_GEN_BMP_SRC_ILKN_INB) : 
                                                          (SOC_TMC_FC_PFC_GEN_BMP_SRC_OOB));

            /* check if pfc generic bitmap can be used */
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_valid_update,(unit, pfc_src_type, pfc_bitmap_class, &is_pfc_gen_valid)));
            if (is_pfc_gen_valid == FALSE) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, pfc generic bitmap can't be used\n"), unit));
            }

            if (!is_for_delete) {
                BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_pfc_bitmap_get(unit, pfc_bmp_type, target_port, target->cosq, &generic_bm));
            }

            if (!is_fc_mub) 
            {
                if (cal_dest_ori == SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC) {
                    old_generic_bm_id = (cal_buff + source->calender_index)->id;
                }
                else {
                    old_generic_bm_id = SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);
                }

                rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_exchange(unit, pfc_bitmap_class, old_generic_bm_id, &generic_bm, &generic_bm_is_last, &new_generic_bm_id, &generic_bm_is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set HW for new pfc generic bitmap if needed*/
                if(generic_bm_is_allocated)
                {
                    rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, pfc_bitmap_class, new_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, pfc_bitmap_class, new_generic_bm_id, TRUE)));
                }

                if (cal_dest == SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC) {
                    target_id = new_generic_bm_id;
                }

                /* set HW for old pfc generic bitmap if needed*/
                if (generic_bm_is_last && 
                    (old_generic_bm_id != new_generic_bm_id) &&
                    (old_generic_bm_id >= 0) && 
                    (old_generic_bm_id < SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))) {

                    SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                    rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, pfc_bitmap_class, old_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, pfc_bitmap_class, old_generic_bm_id, FALSE)));
                }
            }
            else {
                new_generic_bm_id = source->calender_index;
            
                rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, pfc_bitmap_class, new_generic_bm_id, &generic_bm);
                BCMDNX_IF_ERR_EXIT(rc);

                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, pfc_bitmap_class, source->calender_index, (!is_for_delete))));

                target_id = new_generic_bm_id;
            }
        }
    }

    if (!is_fc_mub) {
        /* Delete only */
        if (is_for_delete) {
            cal_dest = SOC_TMC_FC_REC_CAL_DEST_NONE;
        }

        /* update calender entry */
        (cal_buff + source->calender_index)->destination = cal_dest;
        (cal_buff + source->calender_index)->id = target_id;

        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_set,(unit, _rx_cal.cal_mode_ndx, _rx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) setting, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"), _rx_cal.intf, soc_rc));
        }
    }

exit:
    if (cal_buff != NULL) {
        BCM_FREE(cal_buff);
    }

    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cal_reception_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           int is_fc_inband, 
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count              /* INOUT */
                                           )
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    uint32                   soc_sand_rc;
    SOC_TMC_FC_CAL_IF_INFO        cal_if_info;
    SOC_TMC_FC_REC_CALENDAR      *cal_buff = NULL;
    int                      cal_index, nof_ilkn_ports;
    bcm_dpp_cosq_rx_cal_t   _rx_cal;
    SOC_TMC_FC_REC_CAL_DEST       cal_dest = SOC_TMC_FC_REC_CAL_DEST_NONE;
    int                      internal_target_id;
    int                      queue_id;
    SOC_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int bm_tmp, generic_bm_id;
    uint8                 queue_found = FALSE;
    uint32                    fap_port = 0, tc = 0;
    soc_port_t port;
    int                     core = 0;
    int pfc_bitmap_class = 0;
    int is_fc_mub = 0;
    uint32 ilkn_id = 0;
    uint32 ilkn_nif_port = 0;
    uint32 nif_port = 0;
    bcm_gport_t local_gport = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if(*target_count > max_target) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
    }

    if(*target_count == max_target) {
        BCM_EXIT;
    }

    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);

    if (source->flags & BCM_COSQ_FC_MUB) {
        is_fc_mub = 1;
    }

    if (!is_fc_mub) {
        BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_REC_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
        if (cal_buff == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
        }

        SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
        for (cal_index = 0; cal_index < SOC_TMC_FC_OOB_CAL_LEN_MAX; cal_index++) {
            SOC_TMC_FC_REC_CALENDAR_clear((cal_buff + cal_index));
        }

        if (is_fc_inband) {
            if (fc_calender_port >= nof_ilkn_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.rx.get(unit, fc_calender_port, &_rx_cal));
        } else {
            if (fc_calender_port >= SOC_DPP_CONFIG(unit)->tm.max_oob_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            }
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.rx.get(unit, fc_calender_port, &_rx_cal));
        }

        if (_rx_cal.valid != TRUE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, rx calender not valid for port(%d)\n"), unit, fc_calender_port));
        }

        /* Get Calender setting */
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_rec_cal_get,(unit, _rx_cal.cal_mode_ndx, _rx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _rx_cal.intf, soc_rc));
        }

        if ((source->calender_index < 0) || (source->calender_index >= cal_if_info.cal_len) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, out of range calender index (%d)\n"), unit, source->calender_index));
        }

        if (is_fc_inband) {
            /* check it does not overlap with the LLFC calender space */
            if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] != SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE_DISABLE) {
                if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE1) {
                    if (source->calender_index == 0) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    }
                } else if (SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_llfc_mode[_rx_cal.intf] == SOC_DPP_FC_INBAND_INTLKN_CAL_LLFC_MODE2) {
                    if ((source->calender_index % 16) == 0) {
                        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid calender index (%d), reserved for LLFC\n"), unit, source->calender_index));
                    }
                }
            }
        }
    } else {
        /* MUB flow control */
        if ((source->calender_index < 0) || (source->calender_index > SOC_TMC_FC_ILKN_MUB_GEN_CAL_LEN)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source calender index out of range [0, %d] \n"), unit, SOC_TMC_FC_ILKN_MUB_GEN_CAL_LEN - 1));
        }
    }

    /* Calendar entry is according to SOURCE, so we have only one target */
    if (!is_fc_mub) {
        cal_dest = cal_buff[source->calender_index].destination;
        internal_target_id = cal_buff[source->calender_index].id;
    } else {
        cal_dest = SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC;
        internal_target_id = source->calender_index;
    }

    if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_RETRANSMIT)
    {
        target[*target_count].flags = BCM_COSQ_FC_RETRANSMIT;
        
        /* NIF ID to GPORT */
        rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, internal_target_id, &target[*target_count].port);
        BCMDNX_IF_ERR_EXIT(rc);

        *target_count += 1;
    }
    else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_NIF_LL)
    {
        target[*target_count].cosq = -1;

        if (SOC_IS_JERICHO(unit)) {
            for (ilkn_id = 0; ilkn_id < nof_ilkn_ports;  ilkn_id++) {
                /* get the ILKN ports who have special phy_port for  VSQ LLFC */
                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_ilkn_nif_port_get, (unit, ilkn_id, &ilkn_nif_port));
                BCMDNX_IF_ERR_EXIT(rc);

                if(ilkn_nif_port == cal_buff[source->calender_index].id) {
                    break;
                }
            }

            if (ilkn_id != nof_ilkn_ports) {/* Target port is ILKN */
                /* ILKN ID to GPORT */
                rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, ilkn_id, &target[*target_count].port);
                BCMDNX_IF_ERR_EXIT(rc);
            } else { /* Target port is front panel port */
                nif_port = cal_buff[source->calender_index].id + 1;
                if (SOC_INFO(unit).port_p2l_mapping[nif_port] == -1) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                        (_BSL_BCM_MSG("unit %d, logical port of nif_port %d is not found.\n"), unit, nif_port));
                }
                /* Local Port to GPORT */
                BCM_GPORT_LOCAL_SET(local_gport, SOC_INFO(unit).port_p2l_mapping[nif_port]);
                rc = bcm_petra_fabric_port_get(unit, local_gport, 0, &target[*target_count].port);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        } else {
            nif_port = cal_buff[source->calender_index].id + 1;
            if (SOC_INFO(unit).port_p2l_mapping[nif_port] == -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND,
                    (_BSL_BCM_MSG("unit %d, logical port of nif_port %d is not found.\n"), unit, nif_port));
            }
            /* Local Port to GPORT */
            BCM_GPORT_LOCAL_SET(local_gport, SOC_INFO(unit).port_p2l_mapping[nif_port]);
            rc = bcm_petra_fabric_port_get(unit, local_gport, 0, &target[*target_count].port);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        *target_count += 1;
    }
    else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_GENERIC_PFC)
    {
        generic_bm_id = internal_target_id;

        if (SOC_IS_JERICHO(unit)) {
            if (!is_fc_mub) {
                pfc_bitmap_class = (is_fc_inband) ? (fc_calender_port) : (fc_calender_port+6);
            } else {
                pfc_bitmap_class = fc_calender_port;
            }
        }
        else {
            pfc_bitmap_class = 0;
        }

        if (!is_fc_mub) {
            /* Get the current Profile */
            rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_data_get(unit, pfc_bitmap_class, generic_bm_id, &generic_bm);
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_get(unit, pfc_bitmap_class, generic_bm_id, &generic_bm);
            BCMDNX_IF_ERR_EXIT(rc);
        }

        for(queue_id = 0; queue_id < SOC_TMC_FC_PFC_GENERIC_BITMAP_SIZE; queue_id++)
        {
            if(*target_count == max_target) {
                break;
            }

            bm_tmp = generic_bm.bitmap[queue_id / 32];
            if(bm_tmp & SOC_SAND_BIT(queue_id % 32))
            {
                /* Queue Pair to FAP Port / TC */
                soc_sand_rc = arad_egr_queuing_q_pair_port_tc_find(unit, queue_id, &queue_found, &fap_port, &tc, &core);
                BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

                /* FAP Port to Local Port */
                rc = soc_port_sw_db_tm_to_local_port_get(unit, core, fap_port, &port);
                BCMDNX_IF_ERR_EXIT(rc);

                /* Local Port to GPORT */
                BCM_GPORT_LOCAL_SET(target[*target_count].port, port);
            
                target[*target_count].cosq = tc;

                if(!is_fc_mub) {
                    target[*target_count].flags |= BCM_COSQ_FC_PORT_OVER_PFC;
                }

                *target_count += 1;
            }
        } /* queue_id loop */        
    }
    else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_PFC)
    {
        /* Queue Pair to FAP Port / TC */
        soc_sand_rc = arad_egr_queuing_q_pair_port_tc_find(unit, cal_buff[source->calender_index].id, &queue_found, &fap_port, &tc, &core);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        /* FAP Port to Local Port */
        rc = soc_port_sw_db_tm_to_local_port_get(unit, core, fap_port, &port);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Local Port to GPORT */
        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

        target[*target_count].cosq = tc;
        *target_count += 1;
    }
    else if(cal_dest == SOC_TMC_FC_REC_CAL_DEST_PORT_8_PRIORITY || cal_dest == SOC_TMC_FC_REC_CAL_DEST_PORT_2_PRIORITY)
    {
        /* Queue Pair to FAP Port / TC */
        soc_sand_rc = arad_egr_queuing_q_pair_port_tc_find(unit, cal_buff[source->calender_index].id, &queue_found, &fap_port, &tc, &core);
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        /* FAP Port to Local Port */
        rc = soc_port_sw_db_tm_to_local_port_get(unit, core, fap_port, &port);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Local Port to GPORT */
        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

        *target_count += 1;
    }

exit:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    
    BCMDNX_FUNC_RETURN;
}


STATIC int _bcm_petra_cosq_pfc_bitmap_get(int unit, 
                                          _bcm_dpp_pfc_bitmap_type pfc_bmp_type, 
                                          bcm_port_t port, 
                                          bcm_cos_queue_t cosq, 
                                          SOC_TMC_FC_PFC_GENERIC_BITMAP *generic_bm)
{
    soc_error_t rc = SOC_E_NONE;

    uint32 base_queue_pair, nof_priorities;
    soc_pbmp_t same_interface_ports;
    soc_port_t port_i;
    int core;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* Mapping PFC source to port target */
    if (pfc_bmp_type == _BCM_DPP_PFC_BITMAP_PORT) {
        /* get base queue and nof priorities of port */
        rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.base_q_pair.get(unit, port, &base_queue_pair);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
        SOCDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
        SOCDNX_IF_ERR_EXIT(rc);

        SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair, nof_priorities);

        generic_bm->core = core;
    }
    /* Mapping PFC source to port target */
    else if ((pfc_bmp_type == _BCM_DPP_PFC_BITMAP_PORT_TC) ||
             (pfc_bmp_type == _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_UP) || 
             (pfc_bmp_type == _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_DOWN)) {
        /* get base queue and nof priorities of port */
        rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.base_q_pair.get(unit, port, &base_queue_pair);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
        SOCDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
        SOCDNX_IF_ERR_EXIT(rc);

        if (cosq >= nof_priorities) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, cosq (%d) out of range [0, %d]\n"), unit, cosq, (nof_priorities-1)));
        }

        if (pfc_bmp_type == _BCM_DPP_PFC_BITMAP_PORT_TC) {
            SHR_BITSET_RANGE(generic_bm->bitmap, (base_queue_pair + cosq), 1);
        }      
        else if (pfc_bmp_type == _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_UP) {
            SHR_BITSET_RANGE(generic_bm->bitmap, (base_queue_pair + cosq), (nof_priorities - cosq));
        }
        else {
            SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair, (cosq + 1));
        }

        generic_bm->core = core;
    }
    /* Mapping PFC source to relevant priority in all ports on same interface */
    else if (pfc_bmp_type == _BCM_DPP_PFC_BITMAP_INTF_TC) {
        /* get all the local port belong to specific interface */
        rc = soc_port_sw_db_ports_to_same_interface_get(unit, port, &same_interface_ports);
        SOCDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &tm_port, &core);
        SOCDNX_IF_ERR_EXIT(rc);

        SOC_PBMP_ITER(same_interface_ports, port_i) {
            /* get base queue of each port */
            rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.base_q_pair.get(unit, port, &base_queue_pair);
            BCMDNX_IF_ERR_EXIT(rc);

            rc = soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities);
            SOCDNX_IF_ERR_EXIT(rc);

            if (cosq >= nof_priorities) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, cosq (%d) out of range [0, %d]\n"), unit, cosq, (nof_priorities-1)));
            }

            SHR_BITSET_RANGE(generic_bm->bitmap, base_queue_pair + cosq, 1);
        }

        generic_bm->core = core;
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid pfc_bmp_type(0x%x)"), unit, pfc_bmp_type));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

/* non-calender based flow control reception (Inband) */
STATIC int
_bcm_petra_cosq_noncal_reception_fc_path_add(int unit,
                                             int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target,
                           int is_fc_calender,
                           int is_fc_inband, 
                           int fc_calender_port)
{
    bcm_error_t rc = BCM_E_NONE;
    soc_error_t soc_rc = SOC_E_NONE;
    int is_llfc;
    SOC_TMC_FC_REC_INBND_INFO inbnd_info;
    int core;
    int is_safc = 0;
    uint32 internal_id = 0;
    uint32 source_tm_port;
    SOC_TMC_FC_PFC_GENERIC_BITMAP generic_bm;
    int old_generic_bm_id = 0, generic_bm_is_last = 0, new_generic_bm_id = -1, generic_bm_is_allocated = 0;
    int cur_generic_bm_id = 0;
    SOC_TMC_FC_PFC_MAP pfc_map;
    uint32 phy_port = 0;
    int cosq_index = 0, cosq_start = 0, cosq_end = 0;
    bcm_dpp_cosq_pfc_rx_type_t cur_pfc_type = _BCM_DPP_COSQ_PFC_RX_NONE, 
                               ori_pfc_type = _BCM_DPP_COSQ_PFC_RX_NONE;
    uint32 source_phy_port, target_phy_port;

    bcm_port_t source_port = 0, target_port = 0;
    int is_interface_port = 0;
    _bcm_dpp_pfc_bitmap_type pfc_bmp_type;
    uint32 base_queue_pair = 0, queue_pair_index = 0;
    uint32 nof_priorities = 0, priority_bmp = 0;
    bcm_dpp_cosq_pfc_rx_type_t sw_state_rx_pfc_map_info;
    SOC_TMC_FC_PFC_GEN_BMP_SRC_TYPE   pfc_src_type = SOC_TMC_FC_PFC_GEN_BMP_SRC_NIF;
    uint32 is_pfc_gen_valid = 0;
    uint32 pmx_base_lane = SOC_DPP_DEFS_GET(unit, pmx_base_lane);

    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_FC_REC_INBND_INFO_clear(&inbnd_info);

    is_llfc = (source->cosq == -1) ? TRUE : FALSE;

    rc = bcm_petra_cosq_user_port_get(unit, source->port, &source_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = soc_port_sw_db_local_to_out_port_priority_get(unit, source_port, &nof_priorities);
    BCMDNX_IF_ERR_EXIT(rc);

    if (IS_CPU_PORT(unit, source_port)) { /* enable CFC to react to CMIC FC */
        /* consistency checks */
        if ((source->cosq < -1) || (source->cosq >= (int)nof_priorities)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

       /* validate target port and taget cos */
        if (!(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
            BCMDNX_IF_ERR_EXIT(rc);

            if (source_port != target_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source port(%d) and target port (%d) do not match"), unit, source_port, target_port));
            }

            if ((target->cosq != 0) && (target->cosq != -1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source cosq(%d) and target cosq (%d) do not match\n"), unit, source->cosq, target->cosq));
            }
        }

        if (source->cosq == -1) {
            for (cosq_index = 0; cosq_index < nof_priorities; cosq_index++) {
                SHR_BITSET(&priority_bmp, cosq_index);
            }
        }
        else {
            SHR_BITSET(&priority_bmp, source->cosq);
        }

        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_cmic_rx_set,(unit, source_port, priority_bmp, !is_for_delete));
        if(SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config CMIC FC on port(%d), error 0x%x\n"), unit, source->port, soc_rc));
        }
    }
    else if (is_llfc) { /* Reaction point: Interface */       
        /* consistency checks */
        /* validate source flags */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)"), unit, source->flags));
        }

        /* validate target flags */
        if ((target->flags & ~(BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)"), unit, target->flags));
        }

        /* validate target port and taget cos */
        if (!(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            rc = _bcm_petra_cosq_fap_port_get(unit, source->port, &source_tm_port, &core, &is_interface_port);
            BCMDNX_IF_ERR_EXIT(rc);

            if (!is_interface_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port target(0x%x), it should be interface gport"), unit, target->port));
            }

            rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
            BCMDNX_IF_ERR_EXIT(rc);

            /* check target interface == source interface */
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_first_phy_port_get(unit, source_port, &source_phy_port /*one based*/));
            BCMDNX_IF_ERR_EXIT(soc_port_sw_db_first_phy_port_get(unit, target_port, &target_phy_port /*one based*/));

            if (source_phy_port != target_phy_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source interface(%d) and target interface (%d) do not match"), unit, source_phy_port, target_phy_port));
            }

            if (target->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq specified(0x%x)"), unit, target->cosq));
            }
        }      

        /* if enable llfc reception on NIF, disable llfc in mac and port register */
        inbnd_info.mode = SOC_TMC_FC_INBND_MODE_LL;

        /* Delete only */
        if (is_for_delete) {
            /* if disable llfc reception on NIF, disable llfc in mac and port register */
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_DISABLED;
        }

        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_set,(unit, source_port, 0, inbnd_info.mode));
        if(SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config LLFC port(%d), error 0x%x\n"), unit, source->port, soc_rc));
        }
    }
    else {
        rc = soc_port_sw_db_first_phy_port_get(unit, source_port, &phy_port);
        SOCDNX_IF_ERR_EXIT(rc);
#ifdef BCM_JERICHO_SUPPORT
        if (SOC_IS_JERICHO(unit)) {
            rc = MBCM_DPP_DRIVER_CALL(unit,
                    mbcm_dpp_qsgmii_offsets_remove,
                    (unit, phy_port, &phy_port));
            SOCDNX_IF_ERR_EXIT(rc);
        }
#endif

        if (SOC_IS_QUX(unit) && (phy_port > pmx_base_lane)) {
            /* 15 x 10G ports supporting PFC on QUX */
            rc = MBCM_DPP_DRIVER_CALL(unit,
                    mbcm_dpp_fc_pfc_index_get,
                    (unit, phy_port, &internal_id));
            SOCDNX_IF_ERR_EXIT(rc);
        } else {
            internal_id = phy_port - 1;
        }

        rc = soc_port_sw_db_local_to_tm_port_get(unit, source_port, &source_tm_port, &core);
        SOCDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_tm_port_to_base_q_pair_get(unit, core, source_tm_port, &base_queue_pair);
        SOCDNX_IF_ERR_EXIT(rc);
        
        if (target->cosq == -1) { /* Reaction point: port */
            /* validate source flags */
            if ((source->flags & (~(BCM_COSQ_FC_INHERIT_UP|BCM_COSQ_FC_INHERIT_DOWN))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
            }

            /* validate target flags */
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
            }

            /* validate source cosq */
            if ((source->cosq < 0) || (source->cosq > 7)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
            }

            if((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) == 0) {
                if((nof_priorities != 1) || (source->flags & BCM_COSQ_FC_INHERIT_UP) || (source->flags & BCM_COSQ_FC_INHERIT_DOWN)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
                }
            }

            /* validate target port and target cosq */
            if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
                rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
                BCMDNX_IF_ERR_EXIT(rc);

                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_first_phy_port_get(unit, source_port, &source_phy_port /*one based*/));
                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_first_phy_port_get(unit, target_port, &target_phy_port /*one based*/));

                if (source_phy_port != target_phy_port) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source interface(%d) and target interface (%d) do not match"), unit, source_phy_port, target_phy_port));
                }

                if ((target->cosq != 0) && (target->cosq != -1)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
                }
            } else {
                /* If endpoint is not specified, target port equal source port */
                target_port = source_port;
            }

            cosq_start = cosq_end = source->cosq;
            SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

            if ((target->flags & BCM_COSQ_FC_PORT_OVER_PFC) == 0) { /* EGQ PFC */
                cur_pfc_type = _BCM_DPP_COSQ_PFC_RX_DEFAULT;
            } else { /* Generic Bitmap PFC */
                if (source->flags & BCM_COSQ_FC_INHERIT_UP) {
                    cosq_start = source->cosq;
                    cosq_end = SOC_TMC_EGR_NOF_Q_PRIO_ARAD - 1;
                }
                if (source->flags & BCM_COSQ_FC_INHERIT_DOWN) {
                    cosq_start = 0;
                    cosq_end = source->cosq; 
                }
                cur_pfc_type = _BCM_DPP_COSQ_PFC_RX_PORT_OVER;

                /* check if pfc generic bitmap can be used */
                pfc_src_type = SOC_TMC_FC_PFC_GEN_BMP_SRC_NIF;
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_valid_update,(unit, pfc_src_type, source->cosq, &is_pfc_gen_valid)));
                if (is_pfc_gen_valid == FALSE) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, pfc generic bitmap can't be used\n"), unit));
                }

                /*
                 * check if current pfc map type conflict with existing configuration
                 * only one pfc map type can be configured on the same interface
                 */
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.rx_pfc_map_info.get(unit, internal_id, &sw_state_rx_pfc_map_info));
                if ((sw_state_rx_pfc_map_info != _BCM_DPP_COSQ_PFC_RX_NONE) &&
                    (sw_state_rx_pfc_map_info != _BCM_DPP_COSQ_PFC_RX_DEFAULT) &&
                   (sw_state_rx_pfc_map_info != cur_pfc_type)) {

                    BCMDNX_ERR_EXIT_MSG(BCM_E_CONFIG, (_BSL_BCM_MSG("unit %d, unexpected pfc map type(%d) conflict with existing pfc map type(%d)\n"), unit,
                    cur_pfc_type, sw_state_rx_pfc_map_info));
                }

                /* set info of pfc generic bitmap */
                if (!is_for_delete) {
                    rc = _bcm_petra_cosq_pfc_bitmap_get(unit, _BCM_DPP_PFC_BITMAP_PORT,
                                                    target_port, target->cosq, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }

            for (cosq_index = cosq_start; cosq_index <= cosq_end; cosq_index++) {
                /* get info of pfc mapping from HW */
                soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_get, (unit, internal_id, cosq_index, &pfc_map));
                BCMDNX_IF_ERR_EXIT(soc_rc);

                if ((pfc_map.mode == SOC_TMC_FC_PFC_MAP_GENERIC_BITMAP) && (pfc_map.valid == 1)) {
                    old_generic_bm_id = pfc_map.index;
                }
                else {
                    old_generic_bm_id = SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);
                }

                rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_exchange(unit, cosq_index, old_generic_bm_id, &generic_bm, &generic_bm_is_last, &new_generic_bm_id, &generic_bm_is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set HW for new pfc generic bitmap if needed*/
                if(generic_bm_is_allocated)
                {
                    rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, new_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, new_generic_bm_id, TRUE)));
                }
                cur_generic_bm_id = new_generic_bm_id;

                /* set HW for old pfc generic bitmap if needed*/
                if (generic_bm_is_last && 
                    (old_generic_bm_id != new_generic_bm_id) &&
                    (old_generic_bm_id >= 0) && 
                    (old_generic_bm_id < SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))) {

                    SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                    rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, old_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, old_generic_bm_id, FALSE)));
                }

                /* set info of pfc mapping */
                if (cur_pfc_type == _BCM_DPP_COSQ_PFC_RX_PORT_OVER) {
                    pfc_map.mode = SOC_TMC_FC_PFC_MAP_GENERIC_BITMAP;
                    if (is_for_delete) {
                        pfc_map.index = 0;
                        pfc_map.valid = 0;
                    } else {
                        pfc_map.index = cur_generic_bm_id;
                        pfc_map.valid = 1;
                    }
                } else {
                    queue_pair_index = base_queue_pair + ((core == 1) ? ARAD_EGR_NOF_BASE_Q_PAIRS : 0);

                    pfc_map.mode = SOC_TMC_FC_PFC_MAP_EGQ;
                    if (is_for_delete) {
                        pfc_map.index = 0;
                        pfc_map.valid = 0;
                    } else {
                        pfc_map.index = queue_pair_index;
                        pfc_map.valid = 1;
                    }
                }

                /* set HW for pfc mapping */
                soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_set, (unit, internal_id, cosq_index, &pfc_map));
                BCMDNX_IF_ERR_EXIT(soc_rc);
            }

            if (!is_for_delete) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, cur_pfc_type));
            }
            else {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, _BCM_DPP_COSQ_PFC_RX_NONE));
            }
        }
        else { /* Reaction point: port+cosq */
            /* validate source flags */
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
            }

            /* validate target flags */
            if ((target->flags & (~(BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT|BCM_COSQ_FC_INHERIT_UP|BCM_COSQ_FC_INHERIT_DOWN))) != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
            }

            /* validate source cosq */
            if ((source->cosq < 0) || (source->cosq > 7)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
            }

            /* validate target cosq */
            if ((target->cosq < 0) || (target->cosq > 7)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
            }

            /* validate target port and target cosq */
            if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
                rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
                BCMDNX_IF_ERR_EXIT(rc);

                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_first_phy_port_get(unit, source_port, &source_phy_port /*one based*/));
                BCMDNX_IF_ERR_EXIT(soc_port_sw_db_first_phy_port_get(unit, target_port, &target_phy_port /*one based*/));

                if (source_phy_port != target_phy_port) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source interface(%d) and target interface (%d) do not match"), unit, source_phy_port, target_phy_port));
                }
            }

            cosq_index = source->cosq;
            /* set info of pfc generic bitmap */
            SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);

            if (target->flags & (BCM_COSQ_FC_PORT_OVER_PFC|BCM_COSQ_FC_INHERIT_UP|BCM_COSQ_FC_INHERIT_DOWN)) {
                cur_pfc_type = _BCM_DPP_COSQ_PFC_RX_PORT_OVER;

                /* check if pfc generic bitmap can be used */
                pfc_src_type = SOC_TMC_FC_PFC_GEN_BMP_SRC_NIF;
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_valid_update,(unit, pfc_src_type, source->cosq, &is_pfc_gen_valid)));
                if (is_pfc_gen_valid == FALSE) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, pfc generic bitmap can't be used\n"), unit));
                }

                if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                    pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_UP;
                }
                else if (target->flags & BCM_COSQ_FC_INHERIT_DOWN) {
                    pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT_TC_INHERIT_DOWN;
                }
                else {
                    pfc_bmp_type = _BCM_DPP_PFC_BITMAP_PORT_TC;
                }
                if (!is_for_delete) {
                    rc = _bcm_petra_cosq_pfc_bitmap_get(unit, pfc_bmp_type,
                                                    target_port, target->cosq, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }

            /* get info of pfc mapping from HW */
            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_get, (unit, internal_id, cosq_index, &pfc_map));
            BCMDNX_IF_ERR_EXIT(soc_rc);

            if ((pfc_map.mode == SOC_TMC_FC_PFC_MAP_GENERIC_BITMAP) && (pfc_map.valid == 1)) {
                ori_pfc_type = _BCM_DPP_COSQ_PFC_RX_PORT_OVER;
                old_generic_bm_id = pfc_map.index;
            }
            else {
                old_generic_bm_id = SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps);
            }

            if ((ori_pfc_type == _BCM_DPP_COSQ_PFC_RX_PORT_OVER) || (cur_pfc_type == _BCM_DPP_COSQ_PFC_RX_PORT_OVER))
            {
                rc = _bcm_dpp_am_template_fc_generic_pfc_mapping_exchange(unit, cosq_index, old_generic_bm_id, &generic_bm, &generic_bm_is_last, &new_generic_bm_id, &generic_bm_is_allocated);
                BCMDNX_IF_ERR_EXIT(rc);

                /* set HW for new pfc generic bitmap if needed*/
                if(generic_bm_is_allocated)
                {
                    rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, new_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, new_generic_bm_id, TRUE)));
                }
                cur_generic_bm_id = new_generic_bm_id;

                /* set HW for old pfc generic bitmap if needed*/
                if (generic_bm_is_last && 
                    (old_generic_bm_id != new_generic_bm_id) &&
                    (old_generic_bm_id >= 0) && 
                    (old_generic_bm_id < SOC_DPP_DEFS_GET(unit, nof_fc_pfc_generic_bitmaps))) {

                    SOC_TMC_FC_PFC_GENERIC_BITMAP_clear(&generic_bm);
                    rc = _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(unit, cosq_index, old_generic_bm_id, &generic_bm);
                    BCMDNX_IF_ERR_EXIT(rc);

                    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_used_update,(unit, pfc_src_type, cosq_index, old_generic_bm_id, FALSE)));
                }
            }

            /* set info of pfc mapping */
            if ((cur_pfc_type == _BCM_DPP_COSQ_PFC_RX_PORT_OVER) && (!is_for_delete)) {
                pfc_map.mode = SOC_TMC_FC_PFC_MAP_GENERIC_BITMAP;
                pfc_map.index = cur_generic_bm_id;
                pfc_map.valid = 1;
            } else {
                queue_pair_index = base_queue_pair + target->cosq;
                queue_pair_index += ((core == 1) ? ARAD_EGR_NOF_BASE_Q_PAIRS : 0);

                pfc_map.mode = SOC_TMC_FC_PFC_MAP_EGQ;
                if (is_for_delete) {
                    pfc_map.index = 0;
                    pfc_map.valid = 0;
                } else {
                    pfc_map.index = queue_pair_index;
                    pfc_map.valid = 1;
                }
            }

            /* set HW for pfc mapping */
            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_set, (unit, internal_id, cosq_index, &pfc_map));
            BCMDNX_IF_ERR_EXIT(soc_rc);

            if (cur_pfc_type != _BCM_DPP_COSQ_PFC_RX_PORT_OVER) {
                rc = bcm_port_control_get(unit, source_port, bcmPortControlSAFCReceive, &is_safc);
                BCMDNX_IF_ERR_EXIT(rc);

                if(is_safc) {
                    inbnd_info.mode = SOC_TMC_FC_INBND_MODE_SAFC;
                }
                else {
                    inbnd_info.mode = SOC_TMC_FC_INBND_MODE_PFC;
                }

                /* Delete only */
                if (is_for_delete) {
                    inbnd_info.mode = SOC_TMC_FC_INBND_MODE_DISABLED;
                }

                soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_set,(unit, source_port, 0, inbnd_info.mode));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config CBFC port(%d), error 0x%x\n"), unit, source->port, soc_rc));
                }
            }

            if (!is_for_delete) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, cur_pfc_type));
            }
            else {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.rx_pfc_map_info.set(unit, internal_id, _BCM_DPP_COSQ_PFC_RX_NONE));
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_noncal_reception_fc_path_get(int unit,
                                             bcm_cosq_fc_direction_type_t fc_direction,
                                             bcm_cosq_fc_endpoint_t *source,
                                             int max_target,
                                             bcm_cosq_fc_endpoint_t *target, /* OUT */
                                             int *target_count               /* OUT */
                                             )
{
    bcm_error_t rc = BCM_E_NONE;
    soc_error_t soc_rc = SOC_E_NONE;
    int is_llfc;
    soc_port_t port;
    SOC_TMC_FC_INBND_MODE mode;
    uint32
        phy_port;
    soc_pbmp_t
        pbmp;
    uint32
        interface_i;
    uint32 flags = 0;
    soc_port_if_t interface_type;
    bcm_dpp_cosq_pfc_rx_type_t sw_state_rx_pfc_map_info;
    uint32 priority_bmp = 0;
    int is_ena = 0;
    uint32 pmx_base_lane = SOC_DPP_DEFS_GET(unit, pmx_base_lane);
    SOC_TMC_FC_PFC_MAP pfc_map;
    uint32 source_tm_port = 0;
    int core = 0;
    uint32 base_queue_pair = 0;
    uint32 queue_pair_index = 0;

    BCMDNX_INIT_FUNC_DEFS;

    is_llfc = (source->cosq == -1) ? TRUE : FALSE;

    if(*target_count > max_target) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
    }

    if(*target_count == max_target) {
        BCM_EXIT;
    }

    if (!is_llfc) 
    {
        
        /* Check all interfaces for FC configuration */

        rc = soc_port_sw_db_valid_ports_get(unit, 0, &pbmp);
        SOCDNX_IF_ERR_EXIT(rc);

        SOC_PBMP_ITER(pbmp, port)
        {
            if(*target_count == max_target) {
                break;
            }
            /* only relevant to network interface */
            rc = soc_port_sw_db_flags_get(unit, port, &flags);
            if (SOC_FAILURE(rc) || (!SOC_PORT_IS_NETWORK_INTERFACE(flags))) {
                continue;
            }

            /* skip ilkn and tm internal interface */
            soc_rc = soc_port_sw_db_interface_type_get(unit, port, &interface_type);
            if (SOC_FAILURE(soc_rc) ||
                (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
                continue;
            }

            rc = soc_port_sw_db_first_phy_port_get(unit, port, &phy_port);
            SOCDNX_IF_ERR_EXIT(rc);

#ifdef BCM_JERICHO_SUPPORT
            if (SOC_IS_JERICHO(unit)) {
                rc = MBCM_DPP_DRIVER_CALL(unit,
                        mbcm_dpp_qsgmii_offsets_remove,
                        (unit, phy_port, &phy_port));
                SOCDNX_IF_ERR_EXIT(rc);
            }
#endif

            if (SOC_IS_QUX(unit) && (phy_port > pmx_base_lane)) {
                /* 15 x 10G ports supporting PFC on QUX */
                rc = MBCM_DPP_DRIVER_CALL(unit,
                        mbcm_dpp_fc_pfc_index_get,
                        (unit, phy_port, &interface_i));
                SOCDNX_IF_ERR_EXIT(rc);
            } else {
                interface_i = phy_port - 1;
            }

            /* Get FC Configuration */
            soc_rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_get,(unit, port, 0, &mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed to config CBFC port(%d), error 0x%x\n"), unit, port, soc_rc));
            }

            /* Target is relevant only for PFC */
            if(mode == SOC_TMC_FC_INBND_MODE_PFC || mode == SOC_TMC_FC_INBND_MODE_SAFC)
            {
                rc = soc_port_sw_db_local_to_tm_port_get(unit, port, &source_tm_port, &core);
                SOCDNX_IF_ERR_EXIT(rc);

                rc = soc_port_sw_db_tm_port_to_base_q_pair_get(unit, core, source_tm_port, &base_queue_pair);
                SOCDNX_IF_ERR_EXIT(rc);

                /* get info of pfc mapping from HW */
                sal_memset(&pfc_map, 0x0, sizeof(SOC_TMC_FC_PFC_MAP));
                soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_mapping_get, (unit, interface_i, source->cosq, &pfc_map));
                BCMDNX_IF_ERR_EXIT(soc_rc);

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.rx_pfc_map_info.get(unit, interface_i, &sw_state_rx_pfc_map_info));
                if (sw_state_rx_pfc_map_info == _BCM_DPP_COSQ_PFC_RX_PORT_OVER) {
                    target[*target_count].flags = BCM_COSQ_FC_PORT_OVER_PFC;
                } else if (sw_state_rx_pfc_map_info == _BCM_DPP_COSQ_PFC_RX_INTF_COSQ) {
                    target[*target_count].flags = BCM_COSQ_FC_INTF_COSQ_PFC;
                }

                if (pfc_map.mode == SOC_TMC_FC_PFC_MAP_EGQ) {
                    if (pfc_map.index != 0) {
                        queue_pair_index = pfc_map.index -((core == 1) ? ARAD_EGR_NOF_BASE_Q_PAIRS : 0);
                        target[*target_count].cosq = queue_pair_index - base_queue_pair;
                    }
                }

                BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                *target_count += 1;
            }
        }/* internal id loop */
    }

    /* get CMIC FC configuration */
    PBMP_ITER(PBMP_CMIC(unit), port) {
        if(*target_count == max_target) {
            break;
        }
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_cmic_rx_get,(unit, port, &priority_bmp, &is_ena));
        if(SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to get CMIC FC on port(%d), error 0x%x\n"), unit, port, soc_rc));
        }
        BCM_DPP_UNIT_CHECK(unit);

        if (!is_ena) {
            continue;
        }

        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);
        *target_count += 1;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* retrieve VSQ information */
STATIC int
_bcm_petra_cosq_vsq_info_get(int unit, bcm_gport_t vsq, bcm_cosq_vsq_info_t *vsq_info)
{
    bcm_error_t rc = BCM_E_NONE;
    int vsq_type, vsq_type_info;
    int ct_id;
    int cc_id;
    int traffic_class;
    bcm_gport_t src_port = -1;   
    int pp_vsq_id;
    int core_id;     
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(vsq_info);
    
    if (!BCM_COSQ_GPORT_IS_VSQ(vsq)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, gport type is not vsq (0x%x)"), unit, vsq));
    }
    core_id = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq);
    ct_id = BCM_COSQ_GPORT_VSQ_CT_GET(vsq);
    traffic_class = BCM_COSQ_GPORT_VSQ_TC_GET(vsq);
    cc_id = BCM_COSQ_GPORT_VSQ_CC_GET(vsq);
    pp_vsq_id = BCM_COSQ_GPORT_VSQ_PP_GET(vsq);
    
    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        vsq_type = BCM_DPP_COSQ_GPORT_VSQ_TYPE_GET(vsq);
        vsq_type_info = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GET(vsq);
        if (vsq_type == BCM_DPP_COSQ_VSQ_TYPE_PFC) {
          src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_SRC_PORT_GET(vsq_type_info);
          traffic_class = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPE_TC_GET(vsq_type_info);
        } else if (vsq_type == BCM_DPP_COSQ_VSQ_TYPE_LLFC) {
          src_port = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPF_SRC_PORT_GET(vsq_type_info);
        }
    } else {
            uint8  enable = 0;
            uint32 src_pp_port = -1;
            if (BCM_COSQ_GPORT_IS_VSQ_SRC_PORT(vsq)) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_src_port_get, (unit,
                                                                                                  BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq), 
                                                                                                  BCM_COSQ_GPORT_VSQ_SRC_PORT_GET(vsq),
                                                                                                  &src_pp_port,
                                                                                                  &enable)));
            } else if (BCM_COSQ_GPORT_IS_VSQ_PG(vsq)) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_vsq_pg_mapping_get, (unit,
                                                                                                    BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq), 
                                                                                                    BCM_COSQ_GPORT_VSQ_PG_GET(vsq),
                                                                                                    0, 
                                                                                                    &src_pp_port,
                                                                                                    &enable)));
            }
            if (enable) {
                BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_pp_to_local_port_get, (unit, BCM_COSQ_GPORT_VSQ_CORE_ID_GET(vsq), src_pp_port, &src_port)));
            } else {
                src_port = -1;
            }
    }
    vsq_info->flags = _SHR_COSQ_GPORT_VSQ_FLAGS_GET(vsq);
    if (ct_id != -1) {
        vsq_info->ct_id = ct_id;
    }
    if (cc_id != -1) {
        vsq_info->cc_id = cc_id;
    }
    if (traffic_class != -1) {
        vsq_info->traffic_class = traffic_class;
    }
    if (src_port != -1) {
        vsq_info->src_port = src_port;
    }
    if (pp_vsq_id != -1) {
        vsq_info->pp_vsq_id = pp_vsq_id;
    }
    if (core_id != -1) {
        BCM_COSQ_GPORT_CORE_SET(vsq_info->core_id, core_id);
    }
    
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* given a interface retrieve inband flow control information for that interface */
/* (SOC_PB_FC_GEN_INBND_INFO sructure)                                               */
STATIC int
_bcm_petra_cosq_interface_fc_info_get(int unit, bcm_gport_t port, SOC_TMC_FC_GEN_INBND_INFO *inbnd_info)
{
    bcm_error_t  rc = BCM_E_NONE;
    bcm_port_t user_port;
    BCMDNX_INIT_FUNC_DEFS;  

    if ( !(BCM_GPORT_IS_MODPORT(port) || BCM_GPORT_IS_LOCAL(port) || !(BCM_GPORT_IS_SET(port))) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid port type for (0x%x)"), unit, port));
    }

    rc = bcm_petra_cosq_user_port_get(unit, port, &user_port);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, user_port, inbnd_info));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/* given a VSQ retrieve inband flow control information for an interface         */
/* (SOC_PB_FC_GEN_INBND_INFO structure)                                              */
STATIC int
_bcm_petra_cosq_vsq_fc_info_get(int unit, bcm_gport_t vsq_port, SOC_TMC_FC_GEN_INBND_INFO *inbnd_info)
{
    bcm_error_t          rc = BCM_E_NONE;
    bcm_cosq_vsq_info_t  vsq_info;


    BCMDNX_INIT_FUNC_DEFS;
    rc = _bcm_petra_cosq_vsq_info_get(unit, vsq_port, &vsq_info);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_interface_fc_info_get(unit, vsq_info.src_port, inbnd_info);
    BCMDNX_IF_ERR_EXIT(rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* calender based flow control generation (Inband/Out-of-band) */
STATIC int
_bcm_petra_cosq_cal_generation_fc_path_add(int unit,
                                           int is_for_delete,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           bcm_cosq_fc_endpoint_t *target,
                                           bcm_cosq_vsq_info_t *vsq_info,
                                           int is_fc_calender,
                                           int is_fc_inband,
                                           int fc_calender_port)
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    bcm_dpp_cosq_tx_cal_t   _tx_cal;
    SOC_TMC_FC_CAL_IF_INFO       cal_if_info;
    SOC_TMC_FC_GEN_CALENDAR      *cal_buff = NULL;
    int                      priority;
    SOC_TMC_FC_GEN_CAL_SRC       cal_src = 0;
    int                      cal_id[BCM_DPP_COSQ_FC_CAL_ID_NUM], cal_id_entries = 0, cur_entry;
    int                      restore = FALSE;
    bcm_dpp_cosq_vsq_type_t  vsq_group_type;
    SOC_TMC_ITM_VSQ_GROUP        soc_tmcvsq_group;
    int                      vsq_index, nof_ilkn_ports;
    uint32                   vsq_fc_id = 0;
    uint32 target_id;
    uint32 phy_port;

    int is_fc_mub = 0;
    SOC_TMC_FC_ILKN_MUB_GEN_CAL  mub_cal_info;
    bcm_port_t source_port;
    int is_interface_port = 0;
    int core = 0;
    int pool_id = 0;
    uint8 is_ocb_only = 0;

    SOC_TMC_FC_HCFC_BITMAP hcfc_bitmap;
    int bit;
    int i;
    bcm_cos_queue_t src_cosq = 0;

    int flag_count = 0;
    uint32                     glb_res_src_bitmap = 0;
    SOC_TMC_FC_GLB_RES_TYPE    glb_res_dst = 0;
    uint32 source_tm_port = 0;
    int max_inband_calender_index = 0;
    int max_oob_calender_index = 0;
    soc_port_if_t interface_type = SOC_PORT_IF_XFI;
    uint32 ilkn_id = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);
    sal_memset(&mub_cal_info, 0, sizeof(mub_cal_info));

    cal_src = SOC_TMC_FC_GEN_CAL_SRC_CONST;
    for (i = 0; i < BCM_DPP_COSQ_FC_CAL_ID_NUM; i++) {
        cal_id[i] = 0;
    }

    if (target->flags & BCM_COSQ_FC_MUB) {
        is_fc_mub = 1;
    }

    if (is_fc_mub == 0) {
        BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_GEN_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
        if (cal_buff == NULL) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
        }

        SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);

        /* consistency checks */
        if (is_fc_inband) {
            if (fc_calender_port >= nof_ilkn_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
            }

            max_inband_calender_index = SOC_DPP_CONFIG(unit)->tm.fc_inband_intlkn_calender_length[fc_calender_port][SOC_TMC_CONNECTION_DIRECTION_TX];
            if((target->calender_index < 0) || (target->calender_index >= max_inband_calender_index)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG
                    ("unit %d, invalid target calender index (%d) is out of range [0, %d]\n"), unit, target->calender_index, max_inband_calender_index - 1));
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.tx.get(unit, fc_calender_port, &_tx_cal));
        }
        else {
            if (fc_calender_port >= SOC_DPP_CONFIG(unit)->tm.max_oob_ports) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
            }

            max_oob_calender_index = SOC_DPP_CONFIG(unit)->tm.fc_oob_calender_length[fc_calender_port][SOC_TMC_CONNECTION_DIRECTION_TX];
            if((target->calender_index < 0) || (target->calender_index >= max_oob_calender_index)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG
                    ("unit %d, invalid target calender index (%d) is out of range [0, %d]\n"), unit, target->calender_index, max_oob_calender_index - 1));
            }

            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.tx.get(unit, fc_calender_port, &_tx_cal));
        }
        if (_tx_cal.valid != TRUE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, tx calender not valid for port(%d)\n"), unit, fc_calender_port));
        }
  
        /* retrieve calender setting */
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_get,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
        }
    }
    else {
        /* retrieve calender setting */
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_ilkn_mub_gen_cal_get,(unit, fc_calender_port, &mub_cal_info));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in mub calender(%d) retreive, error 0x%x\n"), unit, fc_calender_port, soc_rc));
        }  
    }
     
    if(target->flags & BCM_COSQ_FC_RETRANSMIT)
    {
        if (SOC_IS_JERICHO(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, use SOC Property to set ILKN Retransmit Entry for Jericho\n"), unit));
        }
        else {
            /* ILKN Retransmit Entry  - Arad Only */
            cal_src = SOC_TMC_FC_GEN_CAL_SRC_RETRANSMIT;
            cal_id_entries = 1;
            cal_id[0] = fc_calender_port;
        }
    }
    else if(source->flags & BCM_COSQ_FC_HCFC_BITMAP)
    {
        if((source->calender_index < 0) || (source->calender_index >= SOC_TMC_FC_HCFC_BITMAP_SIZE)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG
                ("unit %d, invalid source calender index (%d) is out of range [0, %d]\n"), unit, source->calender_index, SOC_TMC_FC_HCFC_BITMAP_SIZE - 1));
        }

        sal_memset(&hcfc_bitmap, 0x0, sizeof(SOC_TMC_FC_HCFC_BITMAP));

        /* validate target flags */
        if ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
        }

        /* validate target cosq */
        if (target->cosq != -1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
        }

        /* validate source cosq */
        if (SOC_IS_JERICHO(unit)) {
            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }
        else {
            if (source->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }

        if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
            /* validate source flags */
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP | BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | 
                                      BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
            if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP|BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                    BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
                }
            }

            /* validate source priority */
            rc = _bcm_dpp_cosq_internal_priority_get(unit, source->priority, &priority);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Invalid source priority (%d)\n"), unit, source->priority));
            }

            /* get core, ocb and set global resource mask for jericho */
            if (SOC_IS_JERICHO(unit)) {
                is_ocb_only = (source->flags & BCM_COSQ_FC_IS_OCB_ONLY) ? 1 : 0;
                core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);

                if (SOC_IS_QAX(unit)) {
                    if (is_ocb_only) {
                        glb_res_src_bitmap |= (1 << SOC_TMC_FC_GLB_RES_TYPE_OCB);
                    } else {
                        glb_res_src_bitmap |= (1 << SOC_TMC_FC_GLB_RES_TYPE_DRAM);
                    }

                    if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                        if (pool_id == 0) {
                            glb_res_src_bitmap |= (1 << SOC_TMC_FC_GLB_RES_TYPE_POOL0);
                        } else if(pool_id == 1) {
                            glb_res_src_bitmap |= (1 << SOC_TMC_FC_GLB_RES_TYPE_POOL1);
                        }
                    }

                    if (source->flags & BCM_COSQ_FC_HEADROOM) {
                        glb_res_src_bitmap |= (1 << SOC_TMC_FC_GLB_RES_TYPE_OCB_HEADROOM);
                    }
                } else {
                    if (is_ocb_only) {
                        glb_res_dst = (pool_id == 0)?(SOC_TMC_FC_GLB_RES_TYPE_OCB_P0):(SOC_TMC_FC_GLB_RES_TYPE_OCB_P1);
                    } else {
                        glb_res_dst = (pool_id == 0)?(SOC_TMC_FC_GLB_RES_TYPE_MIX_P0):(SOC_TMC_FC_GLB_RES_TYPE_MIX_P1);
                    }

                    if (source->flags & BCM_COSQ_FC_BDB) {
                        glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_BDB);
                    }
                    if (source->flags & BCM_COSQ_FC_MINI_DB) {
                        glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_MINI_MC_DB);
                    }
                    if (source->flags & BCM_COSQ_FC_FULL_DB) {
                        glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_MC_DB);
                    }
                    if (source->flags & BCM_COSQ_FC_OCB_DB) {
                        glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_OCB_DB);
                    }
                    if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                        glb_res_src_bitmap |= (1<<glb_res_dst);
                    }
                }
                soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_glb_rcs_mask_set, (unit, core, (priority == 0), glb_res_dst, glb_res_src_bitmap));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting global resource mask, error 0x%x\n"), unit, soc_rc));
                }
            }

            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_glb_hcfc_bitmap_get, (unit, core, (priority == 0), is_ocb_only, pool_id, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in retreiving hcfc bitmap for global VSQ, error 0x%x\n"), unit, soc_rc));
            }

            bit = source->calender_index;
            if (is_for_delete) {
                hcfc_bitmap.bitmap[bit/32] &= ~(0x1 << (bit % 32));
            }
            else {
                hcfc_bitmap.bitmap[bit/32] |= (0x1 << (bit % 32));
            }

            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_glb_hcfc_bitmap_set, (unit, core, (priority == 0), is_ocb_only, pool_id, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting hcfc bitmap for global VSQ, error 0x%x\n"), unit, soc_rc));
            }
        }
        else if (vsq_info->flags == BCM_COSQ_VSQ_CTTC) {
            /* validate source flags */
            if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            if (SOC_IS_JERICHO(unit)) {
                src_cosq = BCM_COSQ_GPORT_VSQ_TC_GET(source->port);
                /*
                is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(source->port);
                */
                core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
            }
            else {
                src_cosq = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(source->port);
            }

            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_cat_2_tc_hcfc_bitmap_get, (unit, core, src_cosq, is_ocb_only, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in retreiving hcfc bitmap for cat2+tc, error 0x%x\n"), unit, soc_rc));
            }

            bit = source->calender_index;
            if (is_for_delete) {
                hcfc_bitmap.bitmap[bit/32] &= ~(0x1 << (bit % 32));
            }
            else {
                hcfc_bitmap.bitmap[bit/32] |= (0x1 << (bit % 32));
            }

            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_cat_2_tc_hcfc_bitmap_set, (unit, core, src_cosq, is_ocb_only, &hcfc_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting hcfc bitmap for cat2+tc, error 0x%x\n"), unit, soc_rc));
            }
        }
        else if (vsq_info->flags == BCM_COSQ_VSQ_PP) {
            /* validate source flags */
            if (source->flags & ~(BCM_COSQ_FC_HCFC_BITMAP)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }   
        }
        else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, hcfc bitmap can only mapped from global VSQ, cat2+tc VSQ and PP VSQ, error 0x%x\n"), unit, rc));
        }

        cal_src = SOC_TMC_FC_GEN_CAL_SRC_HCFC;
        cal_id_entries = 1;
        cal_id[0] = source->calender_index;
    }
    else if (vsq_info->flags == BCM_COSQ_VSQ_GL) 
    {
        /* Global resources */

        /* consistency checks */
        /* validate source flags and source cosq*/
        if(SOC_IS_JERICHO(unit))
        {
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
                if (source->flags & ~(BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                                      BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION )) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
                }
            }

            flag_count = _bcm_cosq_bit_count_get(source->flags & (BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB));
            if (flag_count > 1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }
        else {
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            /* validate source cos: indicate pool id*/
            if (!((source->cosq == 0) || (source->cosq == -1))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }

        /* validate target flags */
        if ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
        }

        /* validate target cos */
        if (!((target->cosq == 0) || (target->cosq == -1)) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target cosq (%d)\n"), unit, target->cosq));
        }

        /* validate source priority */
        rc = _bcm_dpp_cosq_internal_priority_get(unit, source->priority, &priority);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Invalid source priority (%d)\n"), unit, source->priority));
        }

        if(SOC_IS_JERICHO(unit))
        {
            cal_src = SOC_TMC_FC_GEN_CAL_SRC_GLB_RCS;
            cal_id_entries = 0; 
            if (SOC_IS_QAX(unit)) {
                /* The CAL ID separate HP(0,1,2,3,4) form LP(5,6,7,8) */
                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    if (source->cosq == 0) {
                        /* ID = HP ? 2 : 7 */
                        cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_P0 : SOC_TMC_FC_CAL_GLB_RCS_ID_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX;
                    } else if (source->cosq == 1){
                        /* ID = HP ? 3 : 8 */
                        cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_P1 : SOC_TMC_FC_CAL_GLB_RCS_ID_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX;
                    }
                }

                if (source->flags & BCM_COSQ_FC_HEADROOM) {
                    /* ID = 4  for HP, no LP for headroom resource */
                    cal_id[cal_id_entries++] = SOC_TMC_FC_CAL_GLB_RCS_ID_HEADROOM;
                }

                if ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) {
                    /* ID = HP ? 0 : 5 */
                    cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_MIX : SOC_TMC_FC_CAL_GLB_RCS_ID_MIX + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX;
                } else {
                    /* ID = HP ? 1 : 6 */
                    cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_OCB : SOC_TMC_FC_CAL_GLB_RCS_ID_OCB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX;
                }
                cal_id_entries = 1;
            } else {
                /* The CAL ID separate HP(0,1,2) form LP(3,4,5) */
                if (source->flags & BCM_COSQ_FC_BDB) {
                    /* ID = HP ? 0 : 8 */
                    cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_BDB : SOC_TMC_FC_CAL_GLB_RCS_ID_BDB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if (source->flags & BCM_COSQ_FC_MINI_DB) {
                    /* ID = HP ? 1 : 9 */
                    cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_UNI : SOC_TMC_FC_CAL_GLB_RCS_ID_UNI + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if (source->flags & BCM_COSQ_FC_FULL_DB) {
                    /* ID = HP ? 2 : 10 */
                    cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_MUL : SOC_TMC_FC_CAL_GLB_RCS_ID_MUL + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if (source->flags & BCM_COSQ_FC_OCB_DB) {
                    /* ID = HP ? 3 : 11 */
                    cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_DB : SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_DB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                }
                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    if ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) {
                        if (source->cosq == 0) {
                            /* ID = HP ? 4 : 12 */
                            cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P0 : SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                        } else {
                            /* ID = HP ? 5 : 13 */
                           cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P1 : SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;
                        }
                    } else {
                        if (source->cosq == 0) {
                            /* ID = HP ? 6 : 14 */
                            cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P0 : SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;                    
                        } else {
                            /* ID = HP ? 7 : 15 */
                            cal_id[cal_id_entries++] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P1 : SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS;            
                        }
                    }
                }
                if(cal_id_entries != 1) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source->flags (%d)\n"), unit, source->flags));
                }
                cal_id_entries = 1;
            }
        }
        else {
            /* The CAL ID separate HP(0,1,2) form LP(3,4,5) */
            cal_src = SOC_TMC_FC_GEN_CAL_SRC_GLB_RCS;
            /* ID = HP ? 0 : 3 */
            cal_id[0] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_BDB : SOC_TMC_FC_CAL_GLB_RCS_ID_BDB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD;
            /* ID = HP ? 1 : 4 */
            cal_id[1] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_UNI : SOC_TMC_FC_CAL_GLB_RCS_ID_UNI + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD;
            /* ID = HP ? 2 : 5 */
            cal_id[2] = (priority == 0) ? SOC_TMC_FC_CAL_GLB_RCS_ID_MUL : SOC_TMC_FC_CAL_GLB_RCS_ID_MUL + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD;

            /* We need an entry per every GLB RCS type - total of 3 */
            cal_id_entries = SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD;
        }
    }
    else if(BCM_COSQ_GPORT_IS_VSQ(source->port)) 
    {
        /* port/interface resources */

        /* consistency checks */
        /* validate source flags and target flags */
        if ( (source->flags != 0) || ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) target(0x%x)\n"), unit, source->flags, target->flags));
        }

        /* validate source cosq and target cosq */
        if (SOC_IS_JERICHO(unit) && vsq_info->flags == BCM_COSQ_VSQ_PFC) {
            if ((source->cosq < 0 ) || (source->cosq >= DPP_COSQ_FC_NOF_PRIORITIES)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d)\n"), unit, source->cosq));
            }
            src_cosq = -1; /* Not used for retrieve vsq index */
        }
        else {
            if ((source->cosq != 0) && (source->cosq != -1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d)\n"), unit, source->cosq));
            }
            src_cosq = source->cosq;
        }

        if ((target->cosq != 0) && (target->cosq != -1)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq target(%d)\n"), unit, target->cosq));
        }

        /* retrieve vsq index */
        rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, source->port, src_cosq, &core, &is_ocb_only, &vsq_group_type, &vsq_index);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x\n"), unit, source->port, rc));
        }

        rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_group);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error in _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type 0x%x\n"), unit, rc));
        }

        rc = (MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_fc_vsq_index_group2global, (unit, soc_tmcvsq_group, vsq_index, source->cosq, is_ocb_only, vsq_info->src_port, &vsq_fc_id)));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error in mbcm_dpp_fc_vsq_index_group2global 0x%x\n"), unit, rc));
        }

        if (SOC_IS_JERICHO(unit))
        {
            if (soc_tmcvsq_group == SOC_TMC_ITM_VSQ_GROUP_STTSTCS_TAG) {
                /* Group D */
                cal_src = SOC_TMC_FC_GEN_CAL_SRC_STTSTCS_TAG;
            }
            else if(soc_tmcvsq_group == SOC_TMC_ITM_VSQ_GROUP_LLFC) {
                /* Group E */
                cal_src = SOC_TMC_FC_GEN_CAL_SRC_LLFC_VSQ;
            }
            else if(soc_tmcvsq_group == SOC_TMC_ITM_VSQ_GROUP_PFC) {
                /* Group F */
                cal_src = SOC_TMC_FC_GEN_CAL_SRC_PFC_VSQ;
            }
            else
            {
                /* Group A/B/C/D */
                cal_src = SOC_TMC_FC_GEN_CAL_SRC_STE;
            }
        }
        else
        {
            if(soc_tmcvsq_group == SOC_TMC_ITM_VSQ_GROUP_LLFC) {
                /* Group E */
                cal_src = SOC_TMC_FC_GEN_CAL_SRC_LLFC_VSQ;
            }
            else if(soc_tmcvsq_group == SOC_TMC_ITM_VSQ_GROUP_PFC) {
                /* Group F */
                cal_src = SOC_TMC_FC_GEN_CAL_SRC_PFC_VSQ;
            }
            else
            {
                /* Group A/B/C/D */
                cal_src = SOC_TMC_FC_GEN_CAL_SRC_STE;
            }
        }        

        cal_id_entries = 1;
        cal_id[0] = vsq_fc_id;
    }
    else
    {
        /* NIF RX Indication */
        /* consistency checks */
        /* validate source flags and target flags */
        if ( (source->flags != 0) || ((target->flags & (~BCM_COSQ_FC_MUB)) != 0) ) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) target(0x%x)\n"), unit, source->flags, target->flags));
        }

        /* validate source cosq and target cosq */
        if (((source->cosq != 0) && (source->cosq != -1)) ||
            ((target->cosq != 0) && (target->cosq != -1))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d), target(%d)\n"), unit, source->cosq, target->cosq));
        }

        /* validate source port */
        rc = _bcm_petra_cosq_fap_port_get(unit, source->port, &source_tm_port, &core, &is_interface_port);
        BCMDNX_IF_ERR_EXIT(rc);

        if (!is_interface_port) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port source(0x%x), it should be interface gport\n"), unit, source->port));
        }

        rc = bcm_petra_cosq_user_port_get(unit, source->port, &source_port);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_interface_type_get(unit, source_port, &interface_type);
        SOCDNX_IF_ERR_EXIT(rc);

        if (interface_type == SOC_PORT_IF_ILKN){
            /* ILKN ports have special phy_port */
            rc = soc_port_sw_db_protocol_offset_get(unit, source_port, 0, &ilkn_id);
            SOCDNX_IF_ERR_EXIT(rc);

            rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_ilkn_nif_port_get, (unit, ilkn_id, &phy_port));
            SOCDNX_IF_ERR_EXIT(rc);

            target_id = phy_port;
        } else {
            rc = soc_port_sw_db_first_phy_port_get(unit, source_port, &phy_port /*one based*/);
            BCMDNX_IF_ERR_EXIT(rc);

            target_id = phy_port - 1;
        }

        cal_src = SOC_TMC_FC_GEN_CAL_SRC_LLFC;
        cal_id_entries = 1;
        cal_id[0] = target_id;
    }

    /* Delete case */
    if (is_for_delete) {
        cal_src = SOC_TMC_FC_GEN_CAL_SRC_CONST;
        for (i = 0; i < cal_id_entries; i++) {
            cal_id[i] = 0;
        }
    }

    /* update calender { */
    if (is_fc_mub == 0) {
        if (target->calender_index + cal_id_entries > cal_if_info.cal_len) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, out of range calender index (%d)\n"), unit, (target->calender_index + (cal_id_entries - 1))));
        }

        for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {
            (cal_buff + target->calender_index + cur_entry)->source = cal_src;
            (cal_buff + target->calender_index + cur_entry)->id = cal_id[cur_entry];
        }
    } else {
        if ((target->calender_index < 0) || (target->calender_index + cal_id_entries > SOC_TMC_FC_ILKN_MUB_GEN_CAL_LEN)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, calender index out of range [0, %d] \n"), unit, SOC_TMC_FC_ILKN_MUB_GEN_CAL_LEN -1));
        }
        
        for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {
            mub_cal_info.entries[target->calender_index + cur_entry].source = cal_src;
            mub_cal_info.entries[target->calender_index + cur_entry].id = cal_id[cur_entry];
        }
    }
    /* update calender } */

    /* configure calender { */
    if (is_fc_mub == 0) {
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_set,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));
        if (SOC_FAILURE(soc_rc)) {
            restore = TRUE;
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s Tx calender(%d) setup, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
        }
    }
    else {
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_ilkn_mub_gen_cal_set,(unit, fc_calender_port, &mub_cal_info));
        if (SOC_FAILURE(soc_rc)) {
            restore = TRUE;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, error in mub calender(%d) setup, error 0x%x\n"), unit, fc_calender_port, soc_rc));
        }
    }
    /* configure calender } */

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

exit:
    if (restore == TRUE) {
        if (is_fc_mub == 0) {
            for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {
                (cal_buff + target->calender_index + cur_entry)->source = SOC_TMC_FC_GEN_CAL_SRC_NONE;
                (cal_buff + target->calender_index + cur_entry)->id = 0;
            }

            soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_set,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));        
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s Tx calender(%d) setup, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
            }
        }
        else {
            for (cur_entry = 0; cur_entry < cal_id_entries; cur_entry++) {    
                mub_cal_info.entries[target->calender_index + cur_entry].source = SOC_TMC_FC_GEN_CAL_SRC_NONE;
                mub_cal_info.entries[target->calender_index + cur_entry].id = 0;
            }

            soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_ilkn_mub_gen_cal_set,(unit, fc_calender_port, &mub_cal_info));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in mub calender(%d) setup, error 0x%x\n"), unit, fc_calender_port, soc_rc));
            }            
        }
    }

    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cal_generation_fc_path_get(int unit,
                                           bcm_cosq_fc_direction_type_t fc_direction,
                                           bcm_cosq_fc_endpoint_t *source,
                                           bcm_cosq_vsq_info_t *vsq_info,
                                           int is_fc_inband,
                                           int fc_calender_port,
                                           int max_target,
                                           bcm_cosq_fc_endpoint_t *target, /* OUT */
                                           int *target_count             /* INOUT */
                                           )
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    bcm_dpp_cosq_tx_cal_t    _tx_cal;
    SOC_TMC_FC_CAL_IF_INFO       cal_if_info;
    SOC_TMC_FC_GEN_CALENDAR      *cal_buff = NULL;
    int                      cal_index, nof_ilkn_ports;
    SOC_TMC_FC_GEN_CAL_SRC       cal_src = 0;
    int flag_count = 0;
    int pool_id = 0;
    int priority = 0;
    int entry_found = 0;
    bcm_cos_queue_t src_cosq = 0;
    int core = 0;
    uint8 is_ocb_only = 0;
    bcm_dpp_cosq_vsq_type_t vsq_group_type;
    SOC_TMC_ITM_VSQ_GROUP soc_tmcvsq_group;
    int vsq_index = 0;
    uint32 vsq_fc_id = 0;
    SOC_TMC_FC_ILKN_MUB_GEN_CAL mub_cal_info;
    int cal_id = 0;
    uint32 target_id = 0;
    uint32 phy_port = 0;
    uint32 ilkn_id = 0;
    bcm_port_t source_port = -1;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);
    sal_memset(&mub_cal_info, 0, sizeof(mub_cal_info));

    /* Init values */
    if(*target_count > max_target) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
    }

    if(*target_count == max_target) {
        BCM_EXIT;
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
        /* validate source flags and source cosq */
        if (SOC_IS_JERICHO(unit)) {
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                     BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
                if (source->flags & ~(BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                                      BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION )) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
                }
            }

            flag_count = _bcm_cosq_bit_count_get(source->flags & (BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB));
            if (flag_count > 1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        } else {
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            /* validate source cos: indicate pool id*/
            if (!((source->cosq == 0) || (source->cosq == -1))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }

        /* validate source priority */
        rc = _bcm_dpp_cosq_internal_priority_get(unit, source->priority, &priority);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Invalid source priority (%d)\n"), unit, source->priority));
        }
    } else if(BCM_COSQ_GPORT_IS_VSQ(source->port)) {
        /* validate source flags and target flags */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
        }

        /* validate source cosq and target cosq */
        if (SOC_IS_JERICHO(unit) && vsq_info->flags == BCM_COSQ_VSQ_PFC) {
            if ((source->cosq < 0 ) || (source->cosq >= DPP_COSQ_FC_NOF_PRIORITIES)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d)\n"), unit, source->cosq));
            }
            src_cosq = -1; /* Not used for retrieve vsq index */
        } else {
            if ((source->cosq != 0) && (source->cosq != -1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq source (%d)\n"), unit, source->cosq));
            }
            src_cosq = source->cosq;
        }

        /* retrieve vsq index */
        rc = _bcm_petra_cosq_gport_vsq_gport_get(unit, source->port, src_cosq, &core, &is_ocb_only, &vsq_group_type, &vsq_index);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Error retreiving VSQ Index for vsq gport (0x%x) error 0x%x\n"), unit, source->port, rc));
        }

        rc = _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type(vsq_group_type,&soc_tmcvsq_group);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error in _bcm_petra_cosq_bcm_vsq_type_to_tmc_vsq_type 0x%x\n"), unit, rc));
        }

        rc = (MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_fc_vsq_index_group2global, (unit, soc_tmcvsq_group, vsq_index, source->cosq, is_ocb_only, vsq_info->src_port, &vsq_fc_id)));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Error in mbcm_dpp_fc_vsq_index_group2global 0x%x\n"), unit, rc));
        }
    }

    BCMDNX_ALLOC(cal_buff, (sizeof(SOC_TMC_FC_GEN_CALENDAR) * SOC_TMC_FC_OOB_CAL_LEN_MAX), "fc calender");
    if (cal_buff == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, failed to allocate memory"), unit));
    }

    SOC_TMC_FC_CAL_IF_INFO_clear(&cal_if_info);
    for (cal_index = 0; cal_index < SOC_TMC_FC_OOB_CAL_LEN_MAX; cal_index++) {
        SOC_TMC_FC_GEN_CALENDAR_clear((cal_buff + cal_index));
    }

    /* Get the calendar type */
    if (is_fc_inband) {
        if (fc_calender_port >= nof_ilkn_ports) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, inband calender port(%d) out of range\n"), unit, fc_calender_port));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.tx.get(unit, fc_calender_port, &_tx_cal));
    } else {
        if (fc_calender_port >= SOC_DPP_CONFIG(unit)->tm.max_oob_ports) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, OOB calender port(%d) out of range\n"), unit, fc_calender_port));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.tx.get(unit, fc_calender_port, &_tx_cal));
    }
    if (_tx_cal.valid != TRUE) {
        /* No calendar */
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, No calendar for calendar port(%d)\n"), unit, fc_calender_port));
    }

    /* Get the calender setting */
    soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_cal_get,(unit, _tx_cal.cal_mode_ndx, _tx_cal.intf, &cal_if_info, cal_buff));

    if (SOC_FAILURE(soc_rc)) {
        BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in %s calender(%d) retreive, error 0x%x\n"), unit, ((is_fc_inband) ? "InBand" : "OOB"),  _tx_cal.intf, soc_rc));
    }

    /* Search for the Target */
    for(cal_index = 0; cal_index < cal_if_info.cal_len; cal_index++)
    {
        if(*target_count == max_target) {
            break;
        }
        cal_src = cal_buff[cal_index].source;

        /* Need to handle RETRANSMIT */
        if(cal_src == SOC_TMC_FC_GEN_CAL_SRC_RETRANSMIT)
        {
            target[*target_count].calender_index = cal_index;

            /* NIF ID to GPORT */
            rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, cal_buff[cal_index].id, &target[*target_count].port);
            BCMDNX_IF_ERR_EXIT(rc);

            *target_count += 1;
        } else if (cal_src == SOC_TMC_FC_GEN_CAL_SRC_GLB_RCS) {
            entry_found = 0;
            if(SOC_IS_JERICHO(unit)) {
                if (SOC_IS_QAX(unit)) { /* QAX */
                    if(((source->flags & BCM_COSQ_FC_HEADROOM)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_HEADROOM))
                        || (((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX))
                        || (((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))
                        || ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB))
                        || ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_P0))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_P1))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))) {
                        entry_found = 1;
                    }
                } else { /* Jericho */
                    if(((source->flags & BCM_COSQ_FC_BDB) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB))
                        || ((source->flags & BCM_COSQ_FC_BDB) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_OCB_DB) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_DB))
                        || ((source->flags & BCM_COSQ_FC_OCB_DB) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_DB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P0))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P1))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P0))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P1))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))) {
                        entry_found = 1;
                    }
                }
            } else { /* Arad */
                    if(((source->flags & BCM_COSQ_FC_BDB) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB))
                        || ((source->flags & BCM_COSQ_FC_BDB) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 0)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 1)
                           && (cal_buff[cal_index].id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD))) {
                        entry_found = 1;
                    }
            }

            if(entry_found) {
                target[*target_count].calender_index = cal_index;
                if (is_fc_inband) {
                    rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, fc_calender_port, &target[*target_count].port);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else {
                    BCM_GPORT_CONGESTION_SET(target[*target_count].port, fc_calender_port);
                }
                *target_count += 1;
            }
        } else if ((cal_src == SOC_TMC_FC_GEN_CAL_SRC_LLFC_VSQ)
                    || (cal_src == SOC_TMC_FC_GEN_CAL_SRC_PFC_VSQ)
                    || (cal_src == SOC_TMC_FC_GEN_CAL_SRC_STE)
                    || (cal_src == SOC_TMC_FC_GEN_CAL_SRC_STTSTCS_TAG)) {
            if(cal_buff[cal_index].id == vsq_fc_id) {
                target[*target_count].calender_index = cal_index;
                if (is_fc_inband) {
                    rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, fc_calender_port, &target[*target_count].port);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else {
                    BCM_GPORT_CONGESTION_SET(target[*target_count].port, fc_calender_port);
                }
                *target_count += 1;
            }
        } else if (cal_src == SOC_TMC_FC_GEN_CAL_SRC_LLFC) {
            rc = bcm_petra_cosq_user_port_get(unit, source->port, &source_port);
            BCMDNX_IF_ERR_EXIT(rc);

            if (is_fc_inband){
                /* ILKN ports have special phy_port */
                rc = soc_port_sw_db_protocol_offset_get(unit, source_port, 0, &ilkn_id);
                SOCDNX_IF_ERR_EXIT(rc);

                rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_ilkn_nif_port_get, (unit, ilkn_id, &phy_port));
                SOCDNX_IF_ERR_EXIT(rc);

                target_id = phy_port;
            } else {
                rc = soc_port_sw_db_first_phy_port_get(unit, source_port, &phy_port /*one based*/);
                BCMDNX_IF_ERR_EXIT(rc);

                target_id = phy_port - 1;
            }

            if(cal_buff[cal_index].id == target_id) {
                target[*target_count].calender_index = cal_index;
                if (is_fc_inband) {
                    rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, fc_calender_port, &target[*target_count].port);
                    BCMDNX_IF_ERR_EXIT(rc);
                } else {
                    BCM_GPORT_CONGESTION_SET(target[*target_count].port, fc_calender_port);
                }
                *target_count += 1;
            }
        }
    }

    if(is_fc_inband) {
        /* retrieve mub calender setting */
        soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_ilkn_mub_gen_cal_get,(unit, fc_calender_port, &mub_cal_info));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in mub calender(%d) retreive, error 0x%x\n"), unit, fc_calender_port, soc_rc));
        }

        /* Search for the Target */
        for(cal_index = 0; cal_index < SOC_TMC_FC_ILKN_MUB_GEN_CAL_LEN; cal_index++)
        {
            if(*target_count == max_target) {
                break;
            }
            cal_src = mub_cal_info.entries[cal_index].source;
            cal_id = mub_cal_info.entries[cal_index].id;

            if (cal_src == SOC_TMC_FC_GEN_CAL_SRC_GLB_RCS) {
                entry_found = 0;
                if(SOC_IS_JERICHO(unit)) {
                    if (SOC_IS_QAX(unit)) { /* QAX */
                        if(((source->flags & BCM_COSQ_FC_HEADROOM)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_HEADROOM))
                        || (((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX))
                        || (((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) == 0) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))
                        || ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB))
                        || ((source->flags & BCM_COSQ_FC_IS_OCB_ONLY) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_P0))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_P1))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_QAX))) {
                        entry_found = 1;
                        }
                    } else { /* Jericho */
                        if(((source->flags & BCM_COSQ_FC_BDB) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB))
                        || ((source->flags & BCM_COSQ_FC_BDB) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 0)
                            && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 0)
                            && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 1)
                            && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_OCB_DB) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_DB))
                        || ((source->flags & BCM_COSQ_FC_OCB_DB) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_DB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P0))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 0) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P1))
                        || (((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) && (pool_id == 1) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MIX_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) && (pool_id == 0) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P0))
                        || ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) && (pool_id == 0) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P0 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))
                        || ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) && (pool_id == 1) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P1))
                        || ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) && (pool_id == 1) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_OCB_P1 + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS))) {
                           entry_found = 1;
                        }
                    }
                } else { /* Arad */
                    if(((source->flags & BCM_COSQ_FC_BDB) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB))
                        || ((source->flags & BCM_COSQ_FC_BDB) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_BDB + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI))
                        || ((source->flags & BCM_COSQ_FC_MINI_DB) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_UNI + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 0)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL))
                        || ((source->flags & BCM_COSQ_FC_FULL_DB) && (priority == 1)
                           && (cal_id == SOC_TMC_FC_CAL_GLB_RCS_ID_MUL + SOC_TMC_FC_NOF_CAL_GLB_RCS_IDS_ARAD))) {
                        entry_found = 1;
                    }
                }

            if(entry_found) {
                target[*target_count].flags |= BCM_COSQ_FC_MUB;
                target[*target_count].calender_index = cal_index;
                rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, fc_calender_port, &target[*target_count].port);
                BCMDNX_IF_ERR_EXIT(rc);

                *target_count += 1;
            }
        } else if ((cal_src == SOC_TMC_FC_GEN_CAL_SRC_LLFC_VSQ)
                    || (cal_src == SOC_TMC_FC_GEN_CAL_SRC_PFC_VSQ)
                    || (cal_src == SOC_TMC_FC_GEN_CAL_SRC_STE)
                    || (cal_src == SOC_TMC_FC_GEN_CAL_SRC_STTSTCS_TAG)) {
                if(cal_id == vsq_fc_id) {
                    target[*target_count].flags |= BCM_COSQ_FC_MUB;
                    target[*target_count].calender_index = cal_index;
                    rc = bcm_petra_cosq_nif_to_gport_get(unit, SOC_PORT_IF_ILKN, fc_calender_port, &target[*target_count].port);
                    BCMDNX_IF_ERR_EXIT(rc);

                    *target_count += 1;
                }
            }
        }

        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
    if (cal_buff != NULL) {
       BCM_FREE(cal_buff);
    }
    
    BCMDNX_FUNC_RETURN;
}

/* non-calender based flow control generation (Inband) */
STATIC int
_bcm_petra_cosq_noncal_generation_fc_path_add(int unit,
                                              int is_for_delete,
                                              bcm_cosq_fc_direction_type_t fc_direction,
                                              bcm_cosq_fc_endpoint_t *source,
                                              bcm_cosq_fc_endpoint_t *target,
                                              bcm_cosq_vsq_info_t *vsq_info,
                                              int is_fc_calender,            /* not used */
                                              int is_fc_inband,              /* not used */
                                              int fc_calender_port)          /* not used */
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    int                      priority;
    SOC_TMC_FC_GEN_INBND_INFO    inbnd_info;
    SOC_TMC_FC_INGR_GEN_GLB_HP_MODE glb_hp_mode;
    int is_llfc;
    int core = 0;
    int is_safc = 0;
    bcm_cosq_vsq_info_t  temp_vsq_info;
    bcm_port_t source_port = 0, target_port = -1;
    bcm_cos_queue_t src_cosq = 0;
    int is_interface_port = 0;
    uint32                     glb_res_src_bitmap = 0;
    SOC_TMC_FC_GLB_RES_TYPE    glb_res_dst = 0;
    int pool_id = 0;
    int is_ocb_only = 0;
    uint32 source_tm_port = 0;
    SOC_TMC_FC_INBND_MODE fc_mode = SOC_TMC_FC_INBND_MODE_DISABLED;
    uint32 is_headroom = 0;
    uint32 is_mask_pool = 0;

    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_FC_GEN_INBND_INFO_clear(&inbnd_info);

    /* consistency checks */
    if ( (source->calender_index != 0) || (target->calender_index != 0) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, calender not valid source (%d), target (%d)\n"), unit, source->calender_index, target->calender_index));
    }

    if ( vsq_info->flags == BCM_COSQ_VSQ_CTTC ) {
        /* consistency checks */
        /* validate source flags */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        /* validate target flags */
        if (target->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
        }

        /* validate source cosq */
        if (source->cosq != -1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

        /* validate target cos */
        if ((target->cosq < 0 ) || (target->cosq >= DPP_COSQ_FC_NOF_PRIORITIES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
        }

        /* validate fc mode */
        rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
        BCMDNX_IF_ERR_EXIT(rc);

        soc_rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_get,(unit, target_port, TRUE, &fc_mode));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, target_port));
        }

        if ((fc_mode != SOC_TMC_FC_INBND_MODE_PFC) && (fc_mode != SOC_TMC_FC_INBND_MODE_SAFC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband PFC/SAFC on port (%d), please call port API to enable PFC/SAFC on port first\n"), unit, target_port));
        }

        if (SOC_IS_JERICHO(unit)) {
            src_cosq = BCM_COSQ_GPORT_VSQ_TC_GET(source->port);
            is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(source->port);
            core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
        }
        else {
            src_cosq = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(source->port);
        }

        inbnd_info.mode = fc_mode;
        inbnd_info.pfc.gen_src = SOC_TMC_FC_GEN_SRC_VSQ_CAT2TC;
        if (SOC_IS_JERICHO(unit)) {
            inbnd_info.core = core;
            inbnd_info.pfc.is_ocb_only = is_ocb_only;
        }
        inbnd_info.pfc.cat2_tc = src_cosq;

        /* retreive information */
        rc = _bcm_petra_cosq_interface_fc_info_get(unit, target->port, &inbnd_info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
        }

        /* update info */
        if (is_for_delete) {
            inbnd_info.pfc.cat2_tc_bitmap &= ~(1 << target->cosq);
        }
        else {
            inbnd_info.pfc.cat2_tc_bitmap |= (1 << target->cosq);
        }

        /* configure */
        rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_set,(unit, target_port, &inbnd_info));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
        }
    }
    else if ( (vsq_info->flags == BCM_COSQ_VSQ_LLFC) || (vsq_info->flags == BCM_COSQ_VSQ_PFC) ) {
        /* interface resources */

        /* consistency checks */
        /* validate source flags */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }
        
        /* validate target flags */
        if (SOC_IS_JERICHO(unit)) {
            if (target->flags & ~(BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target flags (0x%x)\n"), unit, target->flags));
            }
        }
        else {
            if ((target->flags & ~(BCM_COSQ_FC_INHERIT_UP | BCM_COSQ_FC_INHERIT_DOWN | BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) ||
                ((vsq_info->flags == BCM_COSQ_VSQ_PFC) &&
                 (target->flags & BCM_COSQ_FC_INHERIT_UP) &&
                 (target->flags & BCM_COSQ_FC_INHERIT_DOWN)) ||
                ((vsq_info->flags == BCM_COSQ_VSQ_LLFC) &&
                 ((target->flags & BCM_COSQ_FC_INHERIT_UP) || 
                 (target->flags & BCM_COSQ_FC_INHERIT_DOWN))) ) {

                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid target flags (0x%x)\n"), unit, target->flags));
            }
        }

        /* validate source cosq */
        if (source->cosq != -1 && vsq_info->flags == BCM_COSQ_VSQ_LLFC) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }
        source_port = vsq_info->src_port;

        /* validate target port, cosq */
        if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
            /* validate target port */
            rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
            }

            if (source_port != target_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source port(0x%x) and target port (0x%x) do not match\n"), unit, source_port, target_port));
            }

            /* validate target cosq */
            if (((vsq_info->flags == BCM_COSQ_VSQ_LLFC)&& (target->cosq != -1)) || 
                ((vsq_info->flags == BCM_COSQ_VSQ_PFC) && ((target->cosq < 0) || (target->cosq > 7)))) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target cosq (0x%x)\n"), unit, target->cosq));
            }
        }

        rc = _bcm_petra_cosq_vsq_fc_info_get(unit, source->port, &inbnd_info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for vsq (0x%x), error 0x%x\n"), unit, source->port, rc));
        }

        if ((vsq_info->flags == BCM_COSQ_VSQ_LLFC) && (inbnd_info.cb.glbl_rcs_low != 0)) {            
            LOG_WARN(BSL_LS_BCM_COSQ,
                     (BSL_META_U(unit,
                                 "unit %d, Enabling Inband LLFC on port (%d) disabling Global Low priorities flow control\n"), unit, target->port));
        }

        /* update info */
        if (vsq_info->flags == BCM_COSQ_VSQ_LLFC) {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_LL;
            inbnd_info.ll.gen_src = SOC_TMC_FC_GEN_SRC_VSQ_LLFC;
            inbnd_info.ll.vsq_llfc_enable = (is_for_delete)?(0):1;
            inbnd_info.cb.glbl_rcs_low = 0;
            inbnd_info.cb.inherit = SOC_TMC_FC_INBND_CB_INHERIT_DISABLED;
        }
        else if(vsq_info->flags == BCM_COSQ_VSQ_PFC)
        {
            rc = _bcm_petra_cosq_vsq_info_get(unit, source->port, &temp_vsq_info);   
            BCMDNX_IF_ERR_EXIT(rc);

            rc = bcm_petra_port_control_get(unit, temp_vsq_info.src_port, bcmPortControlSAFCTransmit, &is_safc);
            BCMDNX_IF_ERR_EXIT(rc);

            if(is_safc)
            {
              inbnd_info.mode = SOC_TMC_FC_INBND_MODE_SAFC;
            }
            else
            {
              inbnd_info.mode = SOC_TMC_FC_INBND_MODE_PFC;
            }
            inbnd_info.pfc.gen_src = SOC_TMC_FC_GEN_SRC_VSQ_PFC;
            inbnd_info.pfc.vsq_pfc_enable = (is_for_delete)?(0):1;

            if (target->flags & BCM_COSQ_FC_INHERIT_UP) {
                inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_UP;
            }
            else if (target->flags &   BCM_COSQ_FC_INHERIT_DOWN) {
                inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_DOWN;
            }
            else{
                inbnd_info.pfc.inherit = SOC_TMC_FC_INBND_PFC_INHERIT_DISABLED;
            }
        }

        if (is_for_delete) {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_DISABLED;
        }

        /* configure info */
        rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_set,(unit, source_port, &inbnd_info));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, source->port, rc));
        }
    }
    else if (vsq_info->flags == BCM_COSQ_VSQ_GL) {
        /* global resources */

        /* consistency checks */
        /* validate source flags and source cos */
        if (SOC_IS_JERICHO(unit)) {
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
                if (source->flags & ~(BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                                      BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION )) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
                }
            }

            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }
        else {
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            /* validate source cos */
            if (source->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }


        /* validate source priority */
        rc = _bcm_dpp_cosq_internal_priority_get(unit, source->priority, &priority);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, Invalid source priority (%d)\n"), unit, source->priority));
        }

        /* validate target flags and target port*/
        if (SOC_IS_JERICHO(unit)) {
            if (target->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
            }

            rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
            }
        }
        else {
            if (priority == 0) {
                if (target->flags != BCM_COSQ_FC_ENDPOINT_PORT_ALL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x), Need to set *_ALL flag\n"), unit, target->flags));
                }
            }
            else {
                if (target->flags != 0) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags target(0x%x)\n"), unit, target->flags));
                }

                rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
                if (rc != BCM_E_NONE) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
                }
            }
        }

        /* validate target cos */
        if ((target->cosq < -1 ) || (target->cosq >= DPP_COSQ_FC_NOF_PRIORITIES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
        }

        if ((priority == 1) && (target->cosq == -1 )) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, LLFC can't be triggered by Global resources low\n"), unit));            
        }

        /* validate fc mode */
        if (target_port != -1) { 
            soc_rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_get,(unit, target_port, TRUE, &fc_mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, target_port));
            }

            if (target->cosq == -1) {
                /* target is LLFC */
                if (fc_mode != SOC_TMC_FC_INBND_MODE_LL) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband LLFC on port (%d), please call port API to enable LLFC on port first\n"), unit, target_port));
                }
            }
            else {
                /* target is PFC/SAFC */
                if ((fc_mode != SOC_TMC_FC_INBND_MODE_PFC) && (fc_mode != SOC_TMC_FC_INBND_MODE_SAFC)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband PFC/SAFC on port (%d), please call port API to enable PFC/SAFC on port first\n"), unit, target_port));
                }
            }
        }

        /* get core, ocb and set global resource mask for jericho */
        if (SOC_IS_JERICHO(unit)) {
            is_ocb_only = (source->flags & BCM_COSQ_FC_IS_OCB_ONLY) ? 1 : 0;
            core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
            is_headroom = (source->flags & BCM_COSQ_FC_HEADROOM) ? 1 : 0;
            is_mask_pool = (source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) ? 1 : 0;

            if (SOC_IS_QAX(unit)) {
                if (is_ocb_only) {
                    glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_OCB);
                } else {
                    glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_DRAM);
                }

                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    if (pool_id == 0) {
                        glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_POOL0);
                    } else if(pool_id == 1) {
                        glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_POOL1);
                    }
                }

                if (source->flags & BCM_COSQ_FC_HEADROOM) {
                    glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_OCB_HEADROOM);
                }
            } else {
                if (is_ocb_only) {
                    glb_res_dst = (pool_id == 0)?(SOC_TMC_FC_GLB_RES_TYPE_OCB_P0):(SOC_TMC_FC_GLB_RES_TYPE_OCB_P1);
                } else {
                    glb_res_dst = (pool_id == 0)?(SOC_TMC_FC_GLB_RES_TYPE_MIX_P0):(SOC_TMC_FC_GLB_RES_TYPE_MIX_P1);
                }
                if (source->flags & BCM_COSQ_FC_BDB) {
                    glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_BDB);
                }
                if (source->flags & BCM_COSQ_FC_MINI_DB) {
                    glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_MINI_MC_DB);
                }
                if (source->flags & BCM_COSQ_FC_FULL_DB) {
                    glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_MC_DB);
                }
                if (source->flags & BCM_COSQ_FC_OCB_DB) {
                    glb_res_src_bitmap |= (1<<SOC_TMC_FC_GLB_RES_TYPE_OCB_DB);
                }
                if ((source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) == 0) {
                    glb_res_src_bitmap |= (1<<glb_res_dst);
                }
            }

            soc_rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_glb_rcs_mask_set, (unit, core, (priority == 0), glb_res_dst, glb_res_src_bitmap));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting global resource mask, error 0x%x\n"), unit, soc_rc));
            }
        }

        BCM_DPP_UNIT_CHECK(unit);

        if (priority == 0) {
            /* Global High Prioriry */
            if (SOC_IS_JERICHO(unit)) {
                inbnd_info.core = core;
                if (target->cosq == -1) {
                    /* target is LLFC */
                    inbnd_info.mode = SOC_TMC_FC_INBND_MODE_LL;
                    inbnd_info.ll.gen_src = SOC_TMC_FC_GEN_SRC_GLB_HIGH;
                    inbnd_info.ll.is_ocb_only = is_ocb_only;
                    inbnd_info.ll.glbl_rcs_pool = pool_id;
                    inbnd_info.ll.is_headroom = is_headroom;
                    inbnd_info.ll.is_mask_pool = is_mask_pool;
                    /* update info */
                    inbnd_info.ll.glbl_rcs_enable = ((is_for_delete) ? 0 : 1);
                }
                else {
                    /* target is PFC */
                    inbnd_info.mode = fc_mode;
                    inbnd_info.pfc.gen_src = SOC_TMC_FC_GEN_SRC_GLB_HIGH;
                    inbnd_info.pfc.is_ocb_only = is_ocb_only;
                    inbnd_info.pfc.glbl_rcs_pool = pool_id;
                    inbnd_info.pfc.is_headroom = is_headroom;
                    inbnd_info.pfc.is_mask_pool = is_mask_pool;

                    /* retreive information */
                    rc = _bcm_petra_cosq_interface_fc_info_get(unit, target->port, &inbnd_info);
                    if (rc != BCM_E_NONE) {
                        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
                    }

                    /* update info */
                    if (is_for_delete) {
                        inbnd_info.pfc.glbl_rcs_high &= ~(1 << target->cosq);
                    }
                    else {
                        inbnd_info.pfc.glbl_rcs_high |= 1 << target->cosq;
                    }
                }

                /* configure */
                rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_set,(unit, target_port, &inbnd_info));
                if (rc != BCM_E_NONE) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
                }
            }
            else {
                /* target is both LLFC and PFC */
                glb_hp_mode = SOC_TMC_FC_INGR_GEN_GLB_HP_MODE_ALL;
                soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_glb_hp_set,(unit, glb_hp_mode));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, error in setting InBand (LLFC) Hi Priorirty Flow Control, error: 0x%x\n"), unit, soc_rc));
                }
            }
        }
        else {
            inbnd_info.mode = fc_mode;
            inbnd_info.pfc.gen_src = SOC_TMC_FC_GEN_SRC_GLB_LOW;
            if (SOC_IS_JERICHO(unit)) {
                inbnd_info.core = core;
                inbnd_info.pfc.is_ocb_only = is_ocb_only;
                inbnd_info.pfc.glbl_rcs_pool = pool_id;
                inbnd_info.pfc.is_headroom = is_headroom;
                inbnd_info.pfc.is_mask_pool = is_mask_pool;
            }

            /* retreive information */
            rc = _bcm_petra_cosq_interface_fc_info_get(unit, target->port, &inbnd_info);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
            }

            /* update state */
            if (is_for_delete) {
                inbnd_info.pfc.glbl_rcs_low &= ~(1 << target->cosq);
            }
            else {
                inbnd_info.pfc.glbl_rcs_low |= (1 << target->cosq);
            }

            /* configure */
            rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_set,(unit, target_port, &inbnd_info));
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
            }
        }
    }
    else {
        /* consistency checks */
        /* validate source flags */
        if ((source->flags & ~(BCM_COSQ_FC_ETH_PORT)) != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        /* validate target flags */
        if (target->flags & ~(BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid target flags (0x%x)\n"), unit, target->flags));
        }

        /* validate source cosq */
        if ((source->cosq != 0) && (source->cosq != -1)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

        /* validate target cos */
        if ((target->cosq < -1 ) || (target->cosq >= DPP_COSQ_FC_NOF_PRIORITIES)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, target cosq (%d) out of range\n"), unit, target->cosq));
        }

        /* validate source port */
        rc = _bcm_petra_cosq_fap_port_get(unit, source->port, &source_tm_port, &core, &is_interface_port);
        BCMDNX_IF_ERR_EXIT(rc);

        if (!is_interface_port) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid port source(0x%x), it should be interface gport\n"), unit, source->port));
        }

        rc = bcm_petra_cosq_user_port_get(unit, source->port, &source_port);
        BCMDNX_IF_ERR_EXIT(rc);
        
        /* validate target port */
        if ( !(target->flags & BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT) ) {
            /* validate target port */
            rc = bcm_petra_cosq_user_port_get(unit, target->port, &target_port);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving user port for target->port(0x%x), error 0x%x\n"), unit, target->port, rc));
            }

            if (source_port != target_port) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, source port(0x%x) and target port (0x%x) do not match\n"), unit, source_port, target_port));
            }
        }

        /* validate fc mode */
        soc_rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_get,(unit, source_port, TRUE, &fc_mode));
        if (SOC_FAILURE(soc_rc)) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, source_port));
        }

        if (target->cosq == -1) {
            /* target is LLFC */
            if (fc_mode != SOC_TMC_FC_INBND_MODE_LL) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband LLFC on port (%d), please call port API to enable LLFC on port first\n"), unit, source_port));
            }
        }
        else {
            /* target is PFC/SAFC */
            if ((fc_mode != SOC_TMC_FC_INBND_MODE_PFC) && (fc_mode != SOC_TMC_FC_INBND_MODE_SAFC)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Cannot set inband PFC/SAFC on port (%d), please call port API to enable PFC/SAFC on port first\n"), unit, source_port));
            }
        }

        is_llfc = (target->cosq == -1) ? TRUE : FALSE;

        if (is_llfc) {
            inbnd_info.mode = SOC_TMC_FC_INBND_MODE_LL;
            inbnd_info.ll.gen_src = SOC_TMC_FC_GEN_SRC_NIF;

            /* update info */
            inbnd_info.ll.nif_enable = is_for_delete ? 0 : 1;
        }
        else {          
            inbnd_info.mode = fc_mode;
            inbnd_info.pfc.gen_src = SOC_TMC_FC_GEN_SRC_NIF;

            /* retreive information */
            rc = _bcm_petra_cosq_interface_fc_info_get(unit, source->port, &inbnd_info);
            if (rc != BCM_E_NONE) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for port (0x%x), error 0x%x\n"), unit, source->port, rc));
            }

            /* update info */
            if (is_for_delete) {
                inbnd_info.pfc.nif_cls_bitmap &= ~(1 << target->cosq);
            }
            else {
                inbnd_info.pfc.nif_cls_bitmap |= (1 << target->cosq);
            }
        }

        /* configure */
        rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_set,(unit, source_port, &inbnd_info));
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in setting inband flow control info for port (0x%x), error 0x%x\n"), unit, target->port, rc));
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_noncal_generation_fc_path_get(int unit,
                                              bcm_cosq_fc_direction_type_t fc_direction,
                                              bcm_cosq_fc_endpoint_t *source,
                                              bcm_cosq_vsq_info_t *vsq_info,
                                              int max_target,
                                              bcm_cosq_fc_endpoint_t *target, /* OUT */
                                              int *target_count               /* INOUT */
                                              )                
{
    bcm_error_t              rc = BCM_E_NONE;
    soc_error_t              soc_rc = SOC_E_NONE;
    int                      priority;
    SOC_TMC_FC_GEN_INBND_INFO    inbnd_info;
    int                      i;
    soc_port_t               port;
    int                      pool_id = 0;
    uint32                   pfc_bitmap[1] = {0};
    SOC_TMC_FC_INBND_MODE    fc_mode;
    uint32                   flags = 0;
    pbmp_t                   ports_map;
    soc_port_if_t            interface_type;
    bcm_cos_queue_t          src_cosq = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    SOC_TMC_FC_GEN_INBND_INFO_clear(&inbnd_info);

    if(*target_count > max_target) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("unit %d, target_count is bigger than max_target\n"), unit));
    }

    if(*target_count == max_target) {
        BCM_EXIT;
    }

    /* Check all interfaces for FC configuration */
    soc_rc = soc_port_sw_db_valid_ports_get(unit, 0, &ports_map);
    if (SOC_FAILURE(soc_rc)) {
        BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed(%d) in soc_port_sw_db_valid_ports_get\n"), unit, soc_rc));
    }

    if (vsq_info->flags == BCM_COSQ_VSQ_CTTC) {
        /* validate source flag */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        /* validate source cosq */
        if (source->cosq != -1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

        SOC_PBMP_ITER(ports_map, port)
        {
            /* only relevant to network interface */
            soc_rc = soc_port_sw_db_flags_get(unit, port, &flags);
            if (SOC_FAILURE(soc_rc) || (!SOC_PORT_IS_NETWORK_INTERFACE(flags)) || SOC_PORT_IS_LB_MODEM(flags)) {
                continue;
            }

            /* skip ilkn and tm internal interface */
            soc_rc = soc_port_sw_db_interface_type_get(unit, port, &interface_type);
            if (SOC_FAILURE(soc_rc) ||
                (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
                continue;
            }

            /* Get FC mode */
            soc_rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_get,(unit, port, TRUE, &fc_mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, port));
            }

            /* Target is relevant for PFC/SAFC */
            if ((fc_mode == SOC_TMC_FC_INBND_MODE_PFC) || (fc_mode == SOC_TMC_FC_INBND_MODE_SAFC))
            {
                if (SOC_IS_JERICHO(unit)) {
                    src_cosq = BCM_COSQ_GPORT_VSQ_TC_GET(source->port);
                } else {
                    src_cosq = BCM_COSQ_GPORT_VSQ_TYPE_INFO_GROUPB_TC_GET(source->port);
                }

                inbnd_info.mode = fc_mode;
                inbnd_info.pfc.gen_src = SOC_TMC_FC_GEN_SRC_VSQ_CAT2TC;
                if (SOC_IS_JERICHO(unit)) {
                    inbnd_info.core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
                    inbnd_info.pfc.is_ocb_only = BCM_COSQ_GPORT_VSQ_IS_OCB_ONLY(source->port);
                }
                inbnd_info.pfc.cat2_tc = src_cosq;

                /* Get FC Configuration */
                soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, port, &inbnd_info));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed to get CBFC port(%d), error 0x%x\n"), unit, port, soc_rc));
                }

                *pfc_bitmap = inbnd_info.pfc.cat2_tc_bitmap;
                for(i = 0; i < DPP_COSQ_FC_NOF_PRIORITIES; i++)
                {
                    if(*target_count == max_target) {
                        break;
                    }
                    if(SHR_BITGET(pfc_bitmap, i))
                    {
                        target[*target_count].cosq = i;
                        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                        *target_count += 1;
                    }
                }
            }
        }
    } else if ((vsq_info->flags == BCM_COSQ_VSQ_LLFC) || (vsq_info->flags == BCM_COSQ_VSQ_PFC)) {/* interface resources */
        /* consistency checks */
        if (source->flags != 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source flags (0x%x)\n"), unit, source->flags));
        }

        /* validate source cosq */
        if ((source->cosq != -1) && (vsq_info->flags == BCM_COSQ_VSQ_LLFC)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid source cosq (0x%x)\n"), unit, source->cosq));
        }

        /* only relevant to network interface */
        soc_rc = soc_port_sw_db_flags_get(unit, vsq_info->src_port, &flags);
        if (SOC_FAILURE(soc_rc) || (!SOC_PORT_IS_NETWORK_INTERFACE(flags)) || SOC_PORT_IS_LB_MODEM(flags)) {
            goto exit;
        }

        /* skip ilkn and tm internal interface */
        soc_rc = soc_port_sw_db_interface_type_get(unit, vsq_info->src_port, &interface_type);
        if (SOC_FAILURE(soc_rc) || (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
            goto exit;
        }

        rc = _bcm_petra_cosq_vsq_fc_info_get(unit, source->port, &inbnd_info);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, error in retreiving inband flow control info for vsq (0x%x), error 0x%x\n"), unit, source->port, rc));
        }

        if(inbnd_info.mode != SOC_TMC_FC_INBND_MODE_DISABLED) {
            if (inbnd_info.pfc.inherit == SOC_TMC_FC_INBND_PFC_INHERIT_UP) {
                target[*target_count].flags = BCM_COSQ_FC_INHERIT_UP;
            } else if (inbnd_info.pfc.inherit == SOC_TMC_FC_INBND_PFC_INHERIT_DOWN) {
                target[*target_count].flags = BCM_COSQ_FC_INHERIT_DOWN;
            }

            /* Target port should the same as source port */
            BCM_GPORT_LOCAL_SET(target[*target_count].port, vsq_info->src_port);

            *target_count += 1;
        }
    } else if (vsq_info->flags == BCM_COSQ_VSQ_GL) {/* global resources */
        /* validate source flags and source cos */
        if (SOC_IS_JERICHO(unit)) {
            if (SOC_IS_QAX(unit)) {
                if (source->flags & ~(BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_HEADROOM | BCM_COSQ_FC_MASK_POOL_INDICATION)) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            } else {
                if (source->flags & ~(BCM_COSQ_FC_BDB | BCM_COSQ_FC_MINI_DB | BCM_COSQ_FC_FULL_DB | BCM_COSQ_FC_OCB_DB |
                                      BCM_COSQ_FC_IS_OCB_ONLY | BCM_COSQ_FC_MASK_POOL_INDICATION )) {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x) \n"), unit, source->flags));
                }
            }

            pool_id = source->cosq;
            if ((pool_id != 0) && (pool_id != 1)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        } else {
            if (source->flags != 0) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid flags source(0x%x)\n"), unit, source->flags));
            }

            /* validate source cos */
            if (source->cosq != -1) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
            }
        }

        /* validate source priority */
        rc = _bcm_dpp_cosq_internal_priority_get(unit, source->priority, &priority);
        if (rc != BCM_E_NONE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid source cosq (%d)\n"), unit, source->cosq));
        }

        if ((priority == 0) && !SOC_IS_JERICHO(unit)) {
            /* Target is irrelevant */
            goto exit;
        }

        SOC_PBMP_ITER(ports_map, port)
        {
            /* only relevant to network interface */
            soc_rc = soc_port_sw_db_flags_get(unit, port, &flags);
            if (SOC_FAILURE(soc_rc) || (!SOC_PORT_IS_NETWORK_INTERFACE(flags)) || SOC_PORT_IS_LB_MODEM(flags)) {
                continue;
            }

            /* skip ilkn and tm internal interface */
            soc_rc = soc_port_sw_db_interface_type_get(unit, port, &interface_type);
            if (SOC_FAILURE(soc_rc) ||
                (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
                continue;
            }

            /* Get FC mode */
            soc_rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_get,(unit, port, TRUE, &fc_mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, port));
            }

            /* Target is relevant for PFC */
            if ((fc_mode == SOC_TMC_FC_INBND_MODE_PFC) || (fc_mode == SOC_TMC_FC_INBND_MODE_SAFC))
            {
                inbnd_info.mode = fc_mode;
                if (SOC_IS_JERICHO(unit)) {
                    inbnd_info.core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
                    inbnd_info.pfc.glbl_rcs_pool = pool_id;
                    inbnd_info.pfc.is_ocb_only = (source->flags & BCM_COSQ_FC_IS_OCB_ONLY) ? 1 : 0;
                    inbnd_info.pfc.is_headroom = (source->flags & BCM_COSQ_FC_HEADROOM) ? 1 : 0;
                    inbnd_info.pfc.is_mask_pool = (source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) ? 1 : 0;
                }
                inbnd_info.pfc.gen_src = ((priority == 0)? SOC_TMC_FC_GEN_SRC_GLB_HIGH : SOC_TMC_FC_GEN_SRC_GLB_LOW);

                /* Get FC Configuration */
                soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, port, &inbnd_info));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed to get CBFC port(%d), error 0x%x\n"), unit, port, soc_rc));
                }

                *pfc_bitmap = ((priority == 0)? (inbnd_info.pfc.glbl_rcs_high) : (inbnd_info.pfc.glbl_rcs_low));
                for(i = 0; i < 8; i++)
                {
                    if(SHR_BITGET(pfc_bitmap, i))
                    {
                        if(*target_count == max_target) {
                            break;
                        }

                        target[*target_count].cosq = i;
                        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                        *target_count += 1;
                    }
                }
            } else if (fc_mode == SOC_TMC_FC_INBND_MODE_LL) { /* Target is relevant for LLFC */
                /* Only high priority resouces can generate LLFC */
                if(priority) {
                    /* This target is irrelevant */
                    continue;
                }

                inbnd_info.mode = fc_mode;
                if (SOC_IS_JERICHO(unit)) {
                    inbnd_info.core = BCM_COSQ_GPORT_VSQ_CORE_ID_GET(source->port);
                    inbnd_info.ll.glbl_rcs_pool = pool_id;
                    inbnd_info.ll.is_ocb_only = (source->flags & BCM_COSQ_FC_IS_OCB_ONLY) ? 1 : 0;
                    inbnd_info.ll.is_headroom = (source->flags & BCM_COSQ_FC_HEADROOM) ? 1 : 0;
                    inbnd_info.ll.is_mask_pool = (source->flags & BCM_COSQ_FC_MASK_POOL_INDICATION) ? 1 : 0;
                }
                inbnd_info.ll.gen_src = SOC_TMC_FC_GEN_SRC_GLB_HIGH;

                /* Get FC Configuration */
                soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, port, &inbnd_info));
                if (SOC_FAILURE(soc_rc)) {
                    BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed to get port(%d), error 0x%x\n"), unit, port, soc_rc));
                }

                if(inbnd_info.ll.glbl_rcs_enable) {
                    if(*target_count == max_target) {
                        break;
                    }
                    target[*target_count].cosq = -1;
                    BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                    *target_count += 1;
                }
            }
        } /* Internal ID Loop */
    }
    else if(target->flags & BCM_COSQ_FC_ETH_PORT)
    {
        SOC_PBMP_ITER(ports_map, port)
        {
            /* only relevant to network interface */
            soc_rc = soc_port_sw_db_flags_get(unit, port, &flags);
            if (SOC_FAILURE(soc_rc) || (!SOC_PORT_IS_NETWORK_INTERFACE(flags)) || SOC_PORT_IS_LB_MODEM(flags)) {
                continue;
            }

            /* skip ilkn and tm internal interface */
            soc_rc = soc_port_sw_db_interface_type_get(unit, port, &interface_type);        
            if (SOC_FAILURE(soc_rc) ||
                (interface_type == SOC_PORT_IF_ILKN) || (interface_type == SOC_PORT_IF_TM_INTERNAL_PKT)) {
                continue;
            }

            /* Get FC mode */
            soc_rc = MBCM_DPP_SOC_DRIVER_CALL(unit,mbcm_dpp_fc_inbnd_mode_get,(unit, port, TRUE, &fc_mode));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("unit %d, failed(%d) to get fc inbnd mode on port(%d)\n"), unit, soc_rc, port));
            }

            inbnd_info.mode = fc_mode;
            if ((inbnd_info.mode == SOC_TMC_FC_INBND_MODE_PFC) || (inbnd_info.mode == SOC_TMC_FC_INBND_MODE_SAFC)) {
                inbnd_info.pfc.gen_src = SOC_TMC_FC_GEN_SRC_NIF;
            }
            else if (inbnd_info.mode == SOC_TMC_FC_INBND_MODE_LL) {
                inbnd_info.ll.gen_src = SOC_TMC_FC_GEN_SRC_NIF;
            }
            else {
                continue;
            }

            /* Get FC Configuration */
            soc_rc = MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fc_gen_inbnd_get,(unit, port, &inbnd_info));
            if (SOC_FAILURE(soc_rc)) {
                BCMDNX_ERR_EXIT_MSG(soc_rc, (_BSL_BCM_MSG("unit %d, failed to config CBFC port(%d), soc_sand error 0x%x\n"), unit, port, soc_rc));
            }

            /* Target is relevant only for PFC */
            if((inbnd_info.mode == SOC_TMC_FC_INBND_MODE_PFC) || (inbnd_info.mode == SOC_TMC_FC_INBND_MODE_SAFC))
            {
                for(i = 0; i < 8; i++)
                {
                    if(SHR_BITGET(&inbnd_info.pfc.nif_cls_bitmap, i))
                    {
                        if(*target_count == max_target) {
                            break;
                        }

                        target[*target_count].cosq = i;
                        BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                        *target_count += 1;
                    }
                }
            }
            else if (inbnd_info.mode == SOC_TMC_FC_INBND_MODE_LL) 
            {
                if(*target_count == max_target) {
                    break;
                }

                target[*target_count].cosq = -1;
                BCM_GPORT_LOCAL_SET(target[*target_count].port, port);

                *target_count += 1;
            }
        } /* Internal ID Loop */
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_link_fc_verify(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;
    BCMDNX_INIT_FUNC_DEFS;
    if (target->flags != BCM_COSQ_FC_ENDPOINT_PORT_IMPLICIT)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid flags parameter 0x%x\n"), unit, target->flags));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    if (source->cosq != -1)
    {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, Invalid cosq parameter 0x%x\n"), unit, target->cosq));
        rc = BCM_E_PARAM;
        BCMDNX_IF_ERR_EXIT(rc);
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_link_fc_add(int unit,
                       int is_for_delete,
                       bcm_cosq_fc_direction_type_t fc_direction,
                       bcm_cosq_fc_endpoint_t *source,
                       bcm_cosq_fc_endpoint_t *target)
{
    uint32 link;
    uint32 soc_sand_rc;
    SOC_TMC_FABRIC_FC info_rx;
    SOC_TMC_FABRIC_FC info_tx;
    SOC_TMC_CONNECTION_DIRECTION direction;
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_clear(unit, &info_rx);
    SOC_TMC_FABRIC_FC_clear(unit, &info_tx);

    link = SOC_DPP_FABRIC_PORT_TO_LINK(unit, source->port);
    rc = _bcm_petra_link_fc_verify(unit,fc_direction,source,target);
    BCMDNX_IF_ERR_EXIT(rc);        
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_get,(unit, &info_rx,&info_tx)));
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get flow control parameters, soc_sand error 0x%x\n"), unit, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    
    if (fc_direction == bcmCosqFlowControlGeneration) {
        info_tx.enable[link] = (is_for_delete == FALSE)?TRUE:FALSE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_TX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction, &info_tx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable generation flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    if (fc_direction == bcmCosqFlowControlReception) {
        info_rx.enable[link] = TRUE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_RX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction, &info_rx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable reception flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_link_fc_delete(int unit,
                       bcm_cosq_fc_direction_type_t fc_direction,
                       bcm_cosq_fc_endpoint_t *source,
                       bcm_cosq_fc_endpoint_t *target)
{
    uint32 link;
    uint32 soc_sand_rc;
    SOC_TMC_FABRIC_FC info_rx;
    SOC_TMC_FABRIC_FC info_tx;
    SOC_TMC_CONNECTION_DIRECTION direction;
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;
    SOC_TMC_FABRIC_FC_clear(unit, &info_rx);
    SOC_TMC_FABRIC_FC_clear(unit, &info_tx);

    link = SOC_DPP_FABRIC_PORT_TO_LINK(unit, source->port);
    _bcm_petra_link_fc_verify(unit,fc_direction,source,target);
    BCMDNX_IF_ERR_EXIT(rc);        
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_get,(unit, &info_rx, &info_tx)));
    if(SOC_SAND_FAILURE(soc_sand_rc)){
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to get flow control parameters, soc_sand error 0x%x\n"), unit, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }    
    if (fc_direction == bcmCosqFlowControlGeneration) {
        info_tx.enable[link] = FALSE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_TX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction,&info_tx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable generation flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    if (fc_direction == bcmCosqFlowControlReception) {
        info_rx.enable[link] = FALSE; 
        direction = SOC_TMC_CONNECTION_DIRECTION_RX;
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_fabric_fc_enable_set,(unit, direction, &info_rx)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to enable reception flow control on link %d, soc_sand error 0x%x\n"), unit, link, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}



STATIC int
_bcm_petra_cosq_fc_path_add_remove(int unit,
                                   int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;

    if (source == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow control source not specified"), unit));
    }
    if (target == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, flow control target not specified"), unit));
    }

    if (fc_direction == bcmCosqFlowControlGeneration) {
        rc = _bcm_petra_cosq_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target);
    }
    else if (fc_direction == bcmCosqFlowControlReception) {
        rc = _bcm_petra_cosq_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target);
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow control direction %d"), unit, fc_direction));
    }


    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_generation_fc_path_add(int unit,
                                       int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    int                  is_fc_calender, is_fc_inband;
    uint32               fc_calender_port;
    bcm_cosq_vsq_info_t  vsq_info;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_petra_link_fc_add(unit, is_for_delete, fc_direction,source,target);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        /* Port is incoming nif port */
        if(BCM_COSQ_GPORT_IS_VSQ(source->port))
        {
            /* vsq validation and retrieve vsq inormation */
            rc = _bcm_petra_cosq_vsq_info_get(unit, source->port, &vsq_info);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else
        {
            sal_memset(&vsq_info, 0, sizeof(vsq_info));
        }
    
        if (target->port == BCM_GPORT_TYPE_NONE) {
            is_fc_calender = FALSE;
            is_fc_inband = TRUE;
            fc_calender_port = -1;
        }
        else {
            if ( !(BCM_GPORT_IS_MODPORT(target->port) || BCM_GPORT_IS_CONGESTION(target->port) || BCM_GPORT_IS_LOCAL(target->port) || 
                  ((SOC_PORT_VALID(unit, target->port)) && (IS_PORT(unit, target->port)))   ) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unexpected target port (0x%x)"), unit, target->port));
            }
    
            /* determine if calender based flow control generation */
            rc = bcm_petra_cosq_fc_port_info_get(unit, target->port, &is_fc_calender,
                                                  &is_fc_inband, &fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
        if (is_fc_calender || target->flags & BCM_COSQ_FC_HCFC_BITMAP) {
            /*
             * COVERITY *
             * Coverity note: Overruning callee's array of size 328 by passing argument "source->port"(which evaluates to 328) in call to "_bcm_petra_cosq_cal_generation_fc_path_add". 
             * In check there are no overun. */
            /* coverity[overrun-call] */
            rc = _bcm_petra_cosq_cal_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                           &vsq_info, is_fc_calender, is_fc_inband, fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            rc = _bcm_petra_cosq_noncal_generation_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                           &vsq_info, is_fc_calender, is_fc_inband, fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_reception_fc_path_add(int unit,
                                      int is_for_delete,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_NONE;
    int         is_fc_calender, is_fc_inband;
    uint32      fc_calender_port;

    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_petra_link_fc_add(unit, is_for_delete, fc_direction,source,target);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        /* Port is incoming nif port  BCM_COSQ_GPORT_IS_INBAND_COE is used for inband COE port */
        if (BCM_GPORT_IS_MODPORT(source->port) || BCM_GPORT_IS_CONGESTION(source->port) || BCM_GPORT_IS_LOCAL(source->port)
            || BCM_COSQ_GPORT_IS_INBAND_COE(source->port)) {
            rc = bcm_petra_cosq_fc_port_info_get(unit, source->port, &is_fc_calender,
                                                  &is_fc_inband, &fc_calender_port);
            BCMDNX_IF_ERR_EXIT(rc);
    
            if (is_fc_calender) {
               rc = _bcm_petra_cosq_cal_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                                      is_fc_calender, is_fc_inband, fc_calender_port);
                BCMDNX_IF_ERR_EXIT(rc);
            }
            else {
                rc = _bcm_petra_cosq_noncal_reception_fc_path_add(unit, is_for_delete, fc_direction, source, target,
                                      is_fc_calender, is_fc_inband, fc_calender_port);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        else {
            
            /*        bcm_petra_cosq_control_set(), Type => bcmCosqControlFlowControlPriority */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid port type for source port (0x%x)"), unit, source->port));
        }
    
    
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_generation_fc_path_get(int unit,
                                       bcm_cosq_fc_direction_type_t fc_direction,
                                       bcm_cosq_fc_endpoint_t *source,
                                       int target_max,
                                       bcm_cosq_fc_endpoint_t *target, /* OUT */
                                       int *target_count)              /* OUT */
{
    bcm_error_t          rc = BCM_E_UNAVAIL;
    int                  is_fc_inband;
    uint32               fc_calender_port, calender_port_max;
    uint32               nof_ilkn_ports;
    bcm_cosq_vsq_info_t  vsq_info;
    bcm_dpp_cosq_tx_cal_t   _tx_cal;
    uint32               nof_oob_ports = SOC_DPP_CONFIG(unit)->tm.max_oob_ports;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init the results counter */

    nof_ilkn_ports = SOC_DPP_DEFS_GET(unit, nof_interlaken_ports);
    
    *target_count = 0;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /* Port is link port */
        /* Target is irrelevant */
    } else {
        /* Port is incoming NIF */
        if(BCM_COSQ_GPORT_IS_VSQ(source->port)) {
            /* vsq validation and retrieve vsq inormation */
            rc = _bcm_petra_cosq_vsq_info_get(unit, source->port, &vsq_info);
            BCMDNX_IF_ERR_EXIT(rc);
        } else {
            sal_memset(&vsq_info, 0, sizeof(vsq_info));
        }

        for(is_fc_inband = 0; is_fc_inband < 2; is_fc_inband++) {
            calender_port_max = is_fc_inband ? nof_ilkn_ports : nof_oob_ports;

            for(fc_calender_port = 0; fc_calender_port < calender_port_max; fc_calender_port++) {
                if (is_fc_inband) {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.inband_cal.tx.get(unit, fc_calender_port, &_tx_cal));
                } else {
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.oob_cal.tx.get(unit, fc_calender_port, &_tx_cal));
                }

                if (_tx_cal.valid != TRUE) {
                    continue;
                }
                
                /* Get CAL FC Targets */
                rc = _bcm_petra_cosq_cal_generation_fc_path_get(unit, fc_direction, source, &vsq_info, is_fc_inband, fc_calender_port, target_max, 
                                                            target, target_count);
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }

        /* Get NON-CAL FC Targets */
        rc = _bcm_petra_cosq_noncal_generation_fc_path_get(unit, fc_direction, source, &vsq_info, target_max, 
                                                           target, target_count);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_reception_fc_path_get(int unit,
                           bcm_cosq_fc_direction_type_t fc_direction,
                           bcm_cosq_fc_endpoint_t *source,
                           int target_max,
                           bcm_cosq_fc_endpoint_t *target,
                           int *target_count)
{
    bcm_error_t rc = BCM_E_NONE;
    int         is_fc_calender, is_fc_inband;
    uint32      fc_calender_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* Init values */
    *target_count = 0;

    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /* Port is link port */
        /* Target is irrelevant */
    }
    else {
        /* Port is incoming nif port */
        if (BCM_GPORT_IS_MODPORT(source->port) || BCM_GPORT_IS_CONGESTION(source->port) || BCM_GPORT_IS_LOCAL(source->port)
            || BCM_COSQ_GPORT_IS_INBAND_COE(source->port)) 
        {
          /* Get FC info according to source port */
          rc = bcm_petra_cosq_fc_port_info_get(unit, source->port, &is_fc_calender,
                                                &is_fc_inband, &fc_calender_port);
          BCMDNX_IF_ERR_EXIT(rc);

          if (is_fc_calender) {
             rc = _bcm_petra_cosq_cal_reception_fc_path_get(unit, fc_direction, source,
                                    is_fc_inband, fc_calender_port, target_max, target, target_count);
              BCMDNX_IF_ERR_EXIT(rc);
          }
          else {
              rc = _bcm_petra_cosq_noncal_reception_fc_path_get(unit, fc_direction, source,
                                                                target_max, target, target_count);
              BCMDNX_IF_ERR_EXIT(rc);
          }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_generation_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) 
    {

        /*Port is link port*/
         rc =  _bcm_petra_link_fc_delete(unit,fc_direction,source,target); 
        BCMDNX_IF_ERR_EXIT(rc);
    
    }
    else {
        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
        BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_reception_fc_path_delete(int unit,
                              bcm_cosq_fc_direction_type_t fc_direction,
                              bcm_cosq_fc_endpoint_t *source,
                              bcm_cosq_fc_endpoint_t *target)
{
    bcm_error_t rc = BCM_E_UNAVAIL;

    BCMDNX_INIT_FUNC_DEFS;
    if (!BCM_GPORT_IS_SET(source->port) && SOC_PORT_VALID(unit, source->port) && IS_SFI_PORT(unit,source->port)) {
        /*Port is link port*/
        rc =  _bcm_petra_link_fc_delete(unit,fc_direction,source,target); 

        BCMDNX_IF_ERR_EXIT(rc);
    }
    else {
        BCMDNX_IF_ERR_EXIT(rc);
    }

exit:
        BCMDNX_FUNC_RETURN;
}

/*
 * Local Functions (Resource allocation)
 */
int
_bcm_petra_flow_region_config(int unit, int core, int region_start, int region_end,
                              int is_interdigitated, int is_oddEven, int is_clCir)
{
    bcm_error_t rc = BCM_E_NONE;    
    SOC_TMC_SCH_GLOBAL_PER1K_INFO per1k_info;
    uint32 soc_sand_rc;
    int cur_region;

   BCMDNX_INIT_FUNC_DEFS;

   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "DBG, FLOW REGION Start(%d), End(%d), isInterdigitated %s, isOddEven %s\n"), region_start, region_end, ((is_interdigitated) ? "TRUE" : "FALSE"), ((is_oddEven) ? "TRUE" : "FALSE")));

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        BCM_EXIT;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    SOC_TMC_SCH_GLOBAL_PER1K_INFO_clear(&per1k_info);    
    per1k_info.is_interdigitated = is_interdigitated;
    per1k_info.is_odd_even = is_oddEven;

    per1k_info.is_cl_cir = is_clCir;

    if ( (region_start < (DPP_DEVICE_COSQ_CONFIG_FLOW_REGION_START(unit) - 1)) ||
         (region_end > ((DPP_DEVICE_COSQ_CONFIG_FLOW_REGION_START(unit) - 1) +
                        (DPP_DEVICE_COSQ_CONFIG_FLOW_REGIONS(unit) - 1))) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid region range for %d-%d"),unit, region_start, region_end));
    }

    for (cur_region = region_start; cur_region <= region_end; cur_region++) {

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_per1k_info_set,(unit, core, cur_region, &per1k_info)));

        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, failed to config flow region %d, soc_sand error 0x%x\n"), unit, cur_region, soc_sand_rc));
            BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_flow_region_config_get(int unit, int core, int flow_region, uint8 *p_is_interdigitated,
                                                      int *p_is_oddEven, int *p_is_clCir)
{
    bcm_error_t rc = BCM_E_NONE;    
    SOC_TMC_SCH_GLOBAL_PER1K_INFO per1k_info;
    uint32 soc_sand_rc;    

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_per1k_info_get,(unit, core, flow_region, &per1k_info)));

    if(SOC_SAND_FAILURE(soc_sand_rc)) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, failed to get flow flow_region %d, soc_sand error 0x%x\n"), unit, flow_region, soc_sand_rc));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    *p_is_interdigitated = per1k_info.is_interdigitated;
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    *p_is_oddEven = per1k_info.is_odd_even;
    /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
    /* coverity[uninit_use:FALSE] */
    *p_is_clCir = per1k_info.is_cl_cir;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


/* This is a callback function, registered to the alloc manager to be called 
 * whenever a new 1k region is allocated.  At that time, we need to set the
 * region to be interdigitated or not.
 */
int
_bcm_petra_queue_region_config(int unit, int core, int region_start, int region_end,
                               int is_interdigitated)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;  

   BCMDNX_INIT_FUNC_DEFS;
   LOG_DEBUG(BSL_LS_BCM_COSQ,
             (BSL_META_U(unit,
                         "DBG, QUEUE REGION Start(%d), End(%d), isInterdigitated %s\n"), region_start, region_end, ((is_interdigitated) ? "TRUE" : "FALSE")));

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
        BCM_EXIT;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    if ( (region_start > (DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ||
         (region_end > (DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid region range for %d-%d"),unit, region_start, region_end));
    }
    if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for queue region config."), unit, core));
    }

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_interdigitated_mode_set,
        (unit, core, region_start, is_interdigitated)));
    rc = handle_sand_result(soc_sand_rc);

    if (rc != BCM_E_NONE) {
      LOG_ERROR(BSL_LS_BCM_COSQ, \
                (BSL_META_U(unit, \
                            "soc_petra_ipq_queue_interdigitated_mode_set() failed \
                            base queue %d\n"),
                 region_start*1024));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_queue_region_config_get(int unit, int core, int queue_region, uint8 *is_interdigitated)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;   

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if ( (queue_region < 0) || (queue_region > (DPP_DEVICE_COSQ_CONFIG_QUEUE_REGIONS(unit) - 1)) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, invalid range for queue region %d"),unit, queue_region ));
    }
    if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for queue region config."), unit, core));
    }
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_queue_interdigitated_mode_get,(unit, core, queue_region, is_interdigitated)));
    if (SOC_SAND_FAILURE(soc_sand_rc)) {
        rc = translate_sand_success_failure(soc_sand_rc);
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, error in retreiving queue region %d, soc_sand error 0x%x, error 0x%x\n"), unit, queue_region, soc_sand_rc, rc));
        BCMDNX_IF_ERR_EXIT(rc);
        BCM_EXIT;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Support Functions - Flow 
 */

int
_bcm_petra_flow_id_get(int unit, int core, int base_flow_id, int cos, int is_non_contiguous, int is_composite, int is_remove, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_region;
    int is_odd_even;
    int is_cl_cir;
    uint8 is_interdigitated; /*Dummy*/

    BCMDNX_INIT_FUNC_DEFS;
    if (core == BCM_CORE_ALL) {
        /*
         * Get operation for all cores: Read from core '0'.
         */
        core = 0 ;
    } else {
        if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for getting flow id."), unit, core));
        }
    }
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even, &is_cl_cir);
    BCMDNX_IF_ERR_EXIT(rc);

    if (is_remove) {
        (*flow) = DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START;
    }
    else{
        if (is_non_contiguous) {
            if (is_odd_even) {
                (*flow) = (is_composite) ? (base_flow_id + cos * 4) : 
                                                  (base_flow_id + ((cos & 0x6) * 2) + (cos & 0x01));
            } else {
                /*Does not matter if composite or not composite*/
                (*flow) = (base_flow_id + ((cos & 0x6) * 2) + (cos & 0x01));
            }
        }
        else {
            (*flow) = (is_composite) ? (base_flow_id + cos * 2) : (base_flow_id + cos);
        }

        BCMDNX_IF_ERR_EXIT(rc);
    }
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_composite_flow_id_get(int unit, int core, int base_flow_id, int cos, int is_non_contiguous, int is_composite, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_region;
    int is_odd_even;
    int is_cl_cir;
    uint8 is_interdigitated; /*Dummy*/

    BCMDNX_INIT_FUNC_DEFS;
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_interdigitated, &is_odd_even, &is_cl_cir);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_composite) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, core %d, flow %d, must be composite flow"),unit, core, base_flow_id));
    }

    rc = _bcm_petra_flow_id_get(unit, core, base_flow_id, cos, is_non_contiguous, is_composite, FALSE,flow);
    BCMDNX_IF_ERR_EXIT(rc);

    if (!is_odd_even && is_non_contiguous) {
        (*flow)=(*flow)&0x2 ? ((*flow)-2) : ((*flow)+2);        
    } else {
        (*flow)++;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/* STATIC */ int
_bcm_petra_se_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_odd_even == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, must be odd-even flow"),unit));
    }

    switch (type) {
        case SOC_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
            if ( !(flow_id & 0x1) && (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;

        case SOC_TMC_SCH_SE_TYPE_NONE:
        default:
            if (flow_id & 0x2) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_se_composite_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (type) {
        case SOC_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                (*flow) = flow_id + 1;
            } else {
                (*flow) = flow_id + 2;
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
            if ( !(flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 2;
            break;

        case SOC_TMC_SCH_SE_TYPE_NONE:
        default:
            if (flow_id & 0x2) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            if (is_odd_even) {
                (*flow) = (flow_id & 0x1) ? (flow_id - 1) : (flow_id + 1);
            } else {
                (*flow) = (flow_id & 0x2) ? (flow_id - 2) : (flow_id + 2);
            }
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


int
_bcm_petra_se_dual_flow_id_get(int unit, int flow_id, SOC_TMC_SCH_SE_TYPE type, int is_odd_even, int *flow)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if (is_odd_even == FALSE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, must be odd-even flow"),unit));
    }

    switch (type) {
        case SOC_TMC_SCH_SE_TYPE_CL:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 1;
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            break;

        case SOC_TMC_SCH_SE_TYPE_NONE:
        default:
            if ( (flow_id & 0x1) || (flow_id & 0x2) ) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid flow id 0x%x, for flow type 0x%x"),unit, flow_id,type ));
            }
            (*flow) = flow_id + 1;

            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_nbr_flow_quartets_for_queue_quartet(int unit, int is_interdigitated, int is_composite,
                                                                       int *nbr_flow_quartets)
{
    bcm_error_t rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    if ( (is_interdigitated == FALSE) && (is_composite == FALSE) ) {
        (*nbr_flow_quartets) = 1;
    }
    else if ( (is_interdigitated == TRUE) && (is_composite == TRUE) ) {
        (*nbr_flow_quartets) = 4;
    }
    else {
        (*nbr_flow_quartets) = 2;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode1_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP3; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP3; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP4; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3: (*mode) = BCM_COSQ_SP3; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4: (*mode) = BCM_COSQ_SP4; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode2_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP2; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP3; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2: (*mode) = BCM_COSQ_SP3; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode3_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode4_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    break;
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ: (*mode) = BCM_COSQ_SP2; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3: (*mode) = BCM_COSQ_SP2; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_cl_mode5_mode_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info,
                                            SOC_TMC_SCH_SE_INFO *se_config,
                                            SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int *mode)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED: (*mode) = BCM_COSQ_SP1; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP0; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;
        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (cs_info->se_info.cl.sp_class) {
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED: (*mode) = BCM_COSQ_SP0; break;
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
                case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4: (*mode) = BCM_COSQ_SP1; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the scheduling discipline (mode) as viewed by the user application.
 */
STATIC int
_bcm_petra_cosq_mode_get(int unit, int core, SOC_TMC_SCH_FLOW *flow_config, int is_sf2, int *mode)
{
    bcm_error_t rc = BCM_E_NONE;
    int flow_id_index;
    SOC_TMC_SCH_SUBFLOW *sub_flow_config;
    SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info;
    SOC_TMC_SCH_SE_INFO *parent_se = NULL;
    SOC_TMC_SCH_FLOW *parent_flow_config = NULL;
    SOC_TMC_SCH_SE_CL_CLASS_INFO class_type;
    uint32 soc_sand_rc;

    BCMDNX_INIT_FUNC_DEFS;
    flow_id_index = (is_sf2 == TRUE) ? 1 : 0;
    sub_flow_config = &(flow_config->sub_flow[flow_id_index]);
    cs_info = &(sub_flow_config->credit_source);

    switch (cs_info->se_type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            switch (cs_info->se_info.hr.sp_class) {
                case SOC_TMC_SCH_FLOW_HR_CLASS_EF1:              (*mode) = BCM_COSQ_SP0;  break;
                case SOC_TMC_SCH_FLOW_HR_CLASS_EF2:              (*mode) = BCM_COSQ_SP1;  break;
                case SOC_TMC_SCH_FLOW_HR_CLASS_EF3:              (*mode) = BCM_COSQ_SP2;  break;
                case SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_AF1_WFQ:   (*mode) = BCM_COSQ_SP3;  break;
                case SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_BE1:       (*mode) = BCM_COSQ_SP4;  break;
                case SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_AF1_WFQ:     (*mode) = BCM_COSQ_SP3;  break;
                case SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE1_WFQ:     (*mode) = BCM_COSQ_SP4;  break;
                case SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE2:         (*mode) = BCM_COSQ_SP5;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF1:     (*mode) = BCM_COSQ_SP3;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF2:     (*mode) = BCM_COSQ_SP4;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF3:     (*mode) = BCM_COSQ_SP5;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF4:     (*mode) = BCM_COSQ_SP6;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF5:     (*mode) = BCM_COSQ_SP7;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF6:     (*mode) = BCM_COSQ_SP8;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE1_WFQ: (*mode) = BCM_COSQ_SP9;  break;
                case SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE2:     (*mode) = BCM_COSQ_SP10; break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:            

            BCMDNX_ALLOC(parent_flow_config, sizeof(SOC_TMC_SCH_FLOW), "sch flow");
            BCMDNX_ALLOC(parent_se, sizeof(SOC_TMC_SCH_SE_INFO), "se");
            if ( (parent_flow_config == NULL) ||(parent_se == NULL) ) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, resource memory allocation failure\n"), unit));
                rc = BCM_E_MEMORY;
                goto err;
            }

            SOC_TMC_SCH_SE_INFO_clear(parent_se);
            SOC_TMC_SCH_FLOW_clear(unit, parent_flow_config);
            SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            /* retrieve parent element */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core,cs_info->id, parent_se, parent_flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in setting up scheduler element %d, type %s, soc_sand error 0x%x, error 0x%x\n"), unit, cs_info->id, "cl", soc_sand_rc, rc));
                goto err;
            }

            /* determine parent element attribute */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, core, parent_se->type_info.cl.id, &class_type)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, parent_se->type_info.cl.id, soc_sand_rc, rc));
                goto err;
            }

            /* map the element attribute to user specified scheduling discipline */
            switch (class_type.mode) {
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = _bcm_petra_cosq_cl_mode1_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_2:
                    rc = _bcm_petra_cosq_cl_mode2_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_3:
                    rc = _bcm_petra_cosq_cl_mode3_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_4:
                    rc = _bcm_petra_cosq_cl_mode4_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                case SOC_TMC_SCH_CL_MODE_5:
                    rc = _bcm_petra_cosq_cl_mode5_mode_get(unit, cs_info, parent_se, &class_type, mode); break;
                default: rc = BCM_E_PARAM; goto err; break;
            }
           BCM_FREE(parent_flow_config);
           BCM_FREE(parent_se);
            break;

        case SOC_TMC_SCH_SE_TYPE_FQ: (*mode) = BCM_COSQ_SP0; break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

    BCMDNX_IF_ERR_EXIT(rc);
    BCM_EXIT;

err:
    if (parent_flow_config != NULL)
       BCM_FREE(parent_flow_config);
    if (parent_se != NULL) 
       BCM_FREE(parent_se);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode1_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch(mode) {
                case -1:
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode2_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                case -1:
                case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1, class_type->weight_mode, -1, 2); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode3_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;
              
        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode4_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {
        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 63, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch (mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1, class_type->weight_mode, -1, 3); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_credit_class_cl_mode5_info_get(int unit, SOC_TMC_SCH_SE_INFO *se_config, SOC_TMC_SCH_SE_CL_CLASS_INFO *class_type, int mode, bcm_dpp_cosq_class_info_t *info)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch (class_type->enhanced_mode) {

        case SOC_TMC_CL_ENHANCED_MODE_DISABLED:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0:
                         DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case -1:
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_5_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        case SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP:
            switch (class_type->weight_mode) {
                case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 253, -1); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
                default:
                    switch(mode) {
                        case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP_0_ENHANCED, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                        case -1:
                        case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1, class_type->weight_mode, -1, 4); break;
                        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the "flow mode info" that corresponds to the attach point (i.e. mode) of
 * the child. The "flow info mode" contains information of flow type to be configured in child
 * flow and the parents weight mode corresponding to this attach point.
 */
STATIC int
_bcm_petra_cosq_credit_class_info_get(int unit, int core, SOC_TMC_SCH_SE_INFO *se_config, int mode, bcm_dpp_cosq_class_info_t *info)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 soc_sand_rc;    
    SOC_TMC_SCH_SE_CL_CLASS_INFO class_type;

    
    BCMDNX_INIT_FUNC_DEFS;
    switch(se_config->type) {
        case SOC_TMC_SCH_SE_TYPE_HR:
            switch (se_config->type_info.hr.mode) {
                case SOC_TMC_SCH_HR_MODE_SINGLE_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_AF1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_SINGLE_CLASS_BE1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;

                case SOC_TMC_SCH_HR_MODE_DUAL_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_AF1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP5: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_DUAL_CLASS_BE2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;

                case SOC_TMC_SCH_HR_MODE_ENHANCED_PRIO_WFQ:
                    switch(mode) {
                          case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP1: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP2: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_CLASS_EF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP3: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP4: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP5: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF3, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP6: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF4, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP7: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF5, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP8: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_AF6, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          case BCM_COSQ_SP9: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE1_WFQ, SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW, 4096, 0); break;
                          case BCM_COSQ_SP10: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, SOC_TMC_SCH_FLOW_HR_ENHANCED_CLASS_BE2, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                          default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
                    }
                    break;

                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_CL:            
            SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, core, se_config->type_info.cl.id, &class_type)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, se_config->type_info.cl.id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }

            switch (class_type.mode) {
                case SOC_TMC_SCH_CL_MODE_1:
                    rc = _bcm_petra_cosq_credit_class_cl_mode1_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_2:
                    rc = _bcm_petra_cosq_credit_class_cl_mode2_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_3:
                    rc = _bcm_petra_cosq_credit_class_cl_mode3_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_4:
                    rc = _bcm_petra_cosq_credit_class_cl_mode4_info_get(unit, se_config, &class_type,mode, info); break;
                case SOC_TMC_SCH_CL_MODE_5:
                    rc = _bcm_petra_cosq_credit_class_cl_mode5_info_get(unit, se_config, &class_type,mode, info); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        case SOC_TMC_SCH_SE_TYPE_FQ:
            switch(mode) {
                case BCM_COSQ_SP0: DPP_DEVICE_COSQ_CLASS_INFO_INIT(info, -1, SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST, 0, 0); break;
                default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
            }
            break;

        default: BCM_RETURN_VAL_EXIT(BCM_E_PARAM);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the scheduling discipline (mode) as viewed by the user application.
 */
STATIC int
_bcm_petra_cosq_sched_enhanced_mode_get(int unit, int core, SOC_TMC_SCH_SE_INFO *sch_info, int *is_enhanced, int *enhanced_mode)
{
    bcm_error_t                rc = BCM_E_NONE;
    uint32                     soc_sand_rc;    
    SOC_TMC_SCH_SE_CL_CLASS_INFO   class_type;


    BCMDNX_INIT_FUNC_DEFS;
    switch (sch_info->type) {
        case SOC_TMC_SCH_SE_TYPE_CL:            
            SOC_TMC_SCH_SE_CL_CLASS_INFO_clear(&class_type);

            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_class_type_params_get,(unit, core, sch_info->type_info.cl.id, &class_type)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in class type for class index(%d), soc_sand error 0x%x, error 0x%x\n"), unit, sch_info->type_info.cl.id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }

            (*enhanced_mode) = class_type.enhanced_mode;
            (*is_enhanced) = ( (class_type.enhanced_mode == SOC_TMC_CL_ENHANCED_MODE_ENABLED_HP) ||
                  (class_type.enhanced_mode == SOC_TMC_CL_ENHANCED_MODE_ENABLED_LP) ) ? TRUE : FALSE;
            break;

        case SOC_TMC_SCH_SE_TYPE_HR:
        case SOC_TMC_SCH_SE_TYPE_FQ:
        default:
            (*is_enhanced) = FALSE;
            (*enhanced_mode) = SOC_TMC_SCH_CL_ENHANCED_MODE_LAST; /* not valid */
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * This function gets the cl discrete weight  as viewed by the user application.
 */
STATIC int
_bcm_petra_cosq_cl_sched_weight_get(int unit, SOC_TMC_SCH_SUB_FLOW_CREDIT_SOURCE *cs_info, bcm_dpp_cosq_class_info_t *info, int *weight)
{
    bcm_error_t                rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;
    switch (cs_info->se_info.cl.sp_class) {
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ1:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ1:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ1:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL0;
            break;

        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ2:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ2:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP3_WFQ2:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL1;
            break;

        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ3:
        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP2_WFQ3:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL2;
            break;

        case SOC_TMC_SCH_SUB_FLOW_CL_CLASS_SP1_WFQ4:
            (*weight) = BCM_COSQ_WEIGHT_DISCRETE_WEIGHT_LEVEL3;
            break;

        default:
            rc = BCM_E_INTERNAL;
            break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_credit_class_weight_validate(int unit, int weight, bcm_dpp_cosq_class_info_t *info, int *updated_type)
{
    bcm_error_t rc = BCM_E_NONE;
    int discrete_weight_index = 0;


    BCMDNX_INIT_FUNC_DEFS;
    switch (info->weight_mode) {
        case SOC_TMC_SCH_CL_CLASS_WEIGHTS_MODE_LAST:
             if (weight != 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type;
             break;

        case SOC_TMC_SCH_CL_WEIGHTS_MODE_INDEPENDENT_PER_FLOW:
             if (weight <= 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             else if (weight > info->max_weight) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type;
             break;

        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_FLOW:
        case SOC_TMC_SCH_CL_WEIGHTS_MODE_DISCRETE_PER_CLASS:
             if (weight >= 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
            
             for (discrete_weight_index = 0; (weight != 0) &&
                    (discrete_weight_index < BCM_DEVICE_PETRA_COSQ_DWEIGHT_MAX_INDEX);
                                                              discrete_weight_index++) {
                 weight++;
             }
             if (weight != 0) {
                 rc = BCM_E_PARAM;
                 break;
             }
             if (discrete_weight_index > info->max_discrete_class) {
                 rc = BCM_E_PARAM;
                 break;
             }
             (*updated_type) = info->type + (discrete_weight_index - 1);
          
             break;

        default:
             rc = BCM_E_PARAM;
             break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_port_tcg_validate(int unit, bcm_gport_t gport, SOC_TMC_TCG_NDX tcg)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 nof_priorities;
    int port;

    BCMDNX_INIT_FUNC_DEFS;
    /* retrieve port */
    rc = bcm_petra_cosq_user_port_get(unit, gport, &port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));

    if (tcg >= nof_priorities) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("cosq is out of range. Should be in range of 0-%d. gport: 0x%x cosq %d failed, error(0x%x)"), nof_priorities, gport, tcg, rc));
    }

    if (nof_priorities != DPP_COSQ_TCG_NOF_PRIORITIES_SUPPORT) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d TCG is not supported for given port 0x%x. "), unit, gport));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_port_priority_validate(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq)
{
    bcm_error_t rc = BCM_E_NONE;
    uint32 nof_priorities;
    int port;

    BCMDNX_INIT_FUNC_DEFS;
    /* retrieve port */
    rc = bcm_petra_cosq_user_port_get(unit, gport, &port);
    BCMDNX_IF_ERR_EXIT(rc);
    
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));

    if (cosq >= nof_priorities) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("cosq is out of range. Should be in range of 0-%d. gport: 0x%x cosq %d failed, error(0x%x)"), nof_priorities - 1, gport, cosq, rc));
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}
/*
 * Note:
 *   This procedure uses sal_alloc() to allocate memory and load pointer
 *   into '*info_p'. If loaded value is NULL then no memory has been
 *   allocated.
 *   When OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY is zero, then the caller is
 *   assumed to free allocated memory using sal_free() {provided pointer
 *   to memory block is not NULL}.
 */
STATIC int
_bcm_petra_cosq_alloc_n_gport_validate_info_get(int unit, bcm_gport_t gport, bcm_cos_queue_t in_cosq, int flags, bcm_dpp_cosq_gport_info_t **info_p)
{
    bcm_error_t rc ;
    int is_child, is_parent, is_sched_object_ns, is_connnector_object;
    uint8 is_connector, is_se ;
    uint8 is_non_contiguous, is_composite, is_dual ;
    uint8 is_sf2 ;
    int is_odd_even ;
    int is_cl_cir ;
    int base_flow_id, flow_id, sf2_id, flow_region;
    SOC_TMC_SCH_SE_ID se_id ;
    int pass2 ;
    bcm_dpp_cosq_gport_info_t *info ;
    SOC_TMC_SCH_FLOW *flow_config;
    SOC_TMC_SCH_SE_INFO *se_config;
    uint32 soc_sand_rc, tm_port;
    int gport_sf2_type = 0;
    int priority ;
    int state_check, is_warmboot_phase, is_reserved ;
    int fap_port, core;
    uint8 sw_state_num_cos;
    uint32 sw_state_ref_cnt;
      /*
       * Flag. Indicating whether entry corresponding to indicated flow id
       * has been found. The index indicates the stage.
       */
    int entry_was_found[2] = {0,0} ;
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
      /*
       * Indication, for cache, on source of flow_id. A match is full
       * only if both 'flow_id' and 'source_of_flow_id' are the same.
       */
    int source_of_flow_id ;
      /*
       * Storage of flow id after first stage. used to detect change
       * on second stage within this procedure.
       */
    int first_stage_flow_id ;
    bcm_dpp_cosq_vig_leaf_t vig_leaf ;
      /*
       * Pointer to data section on leaf allocated for info
       * collected by this procedure for the 'base_flow_id'.
       */
    bcm_dpp_cosq_vig_leaf_t *base_vig_leaf_on_tree ;
      /*
       * Pointer to data section on leaf allocated for info
       * collected by this procedure for the 'final_flow_id'.
       */
    bcm_dpp_cosq_vig_leaf_t *final_vig_leaf_on_tree ;
/* } */
#endif
    BCMDNX_INIT_FUNC_DEFS ;

    /*
     * Initialize pointer to 'flow info' area to NULL to indicate it has not yet
     * been allocated and loaded by meaningful info. It will only be loaded at the
     * exit (or just going to exit) of this procedure.
     */
    *info_p = NULL ;
    info = NULL ;

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation) {
      sal_memset(&(vig_leaf.gport_info),0x0,sizeof(vig_leaf.gport_info)) ;
      vig_leaf.valid = 0 ;
      vig_leaf.is_base_flow = 0 ;
      vig_leaf.is_final_flow = 0 ;
      vig_leaf.base_flow_id = (int)(-1) ;
      base_vig_leaf_on_tree = NULL ;
    } else {
      BCMDNX_ALLOC(info, sizeof(*info), "flow info") ;
      if (info) {
        sal_memset(info,0x0,sizeof(*info)) ;
        BCMDNX_ALLOC(info->flow_config, sizeof(*(info->flow_config)), "sch flow") ;
        BCMDNX_ALLOC(info->se_config, sizeof(*(info->se_config)), "se") ;
      }
      if ( (info == NULL) ||((info->flow_config) == NULL) ||((info->se_config) == NULL) ) {
              LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "unit %d, resource memory allocation failure\n"), unit));
        if(info) {
            BCM_FREE(info->se_config);
            BCM_FREE(info->flow_config);
        }
        BCM_FREE(info);
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
      }
    }

    final_vig_leaf_on_tree = NULL;
/* } */
#else
/* { */
    BCMDNX_ALLOC(info, sizeof(*info), "flow info") ;
    if (info) {
        sal_memset(info,0x0,sizeof(*info)) ;
        BCMDNX_ALLOC(info->flow_config, sizeof(*(info->flow_config)), "sch flow") ;
        BCMDNX_ALLOC(info->se_config, sizeof(*(info->se_config)), "se") ;
    }
    if ( (info == NULL) ||((info->flow_config) == NULL) ||((info->se_config) == NULL) ) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                          "unit %d, resource memory allocation failure\n"), unit));
        if (info) {
            BCM_FREE(info->se_config);
            BCM_FREE(info->flow_config);
        }
        BCM_FREE(info);
        rc = BCM_E_MEMORY;
        BCMDNX_IF_ERR_EXIT(rc);
    }

/* } */
#endif

    rc = BCM_E_NONE;
    is_connector = FALSE ;
    is_se = FALSE ;
    is_non_contiguous = FALSE ;
    is_composite = FALSE ;
    is_dual = FALSE ;
    is_sf2 = FALSE;
    is_odd_even = TRUE;
    base_flow_id = -1 ;
    flow_id = -1 ;
    sf2_id = -1 ;
    se_id = 0;
    pass2 = FALSE ;
    priority = 0;
    state_check = FALSE ;
    is_warmboot_phase = FALSE ;
    {
        rc = _bcm_petra_cosq_core_get(unit, gport, 0, &core) ;
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                (BSL_META_U(unit,
                    "failed to get core for gport: 0x%08lX, error(0x%08lX)\r\n"), (unsigned long)gport, (unsigned long)rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }

#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        /*
         * Note that vig_leaf.gport_info.flow_config and vig_leaf.gport_info.se_config
         * are not loaded here. They will be loaded when 'lookup' is invoked.
         */
        flow_config = &(vig_leaf.flow_config) ;
        se_config = &(vig_leaf.se_config);
    }
    else
    {
        /* coverity[deref_ptr:FALSE] */
        flow_config = info->flow_config;
        se_config = info->se_config;
    }
/* } */
#else
/* { */
    /* coverity[deref_ptr:FALSE] */
    flow_config = info->flow_config;
    se_config = info->se_config;
/* } */
#endif
    /*
     * First stage (for getting flow_id)
     */
    SOC_TMC_SCH_FLOW_clear(unit, flow_config);
    SOC_TMC_SCH_SE_INFO_clear(se_config);    

    is_child = (flags & dpp_device_cosq_gport_child_element) ? TRUE : FALSE;
    is_parent = (flags & dpp_device_cosq_gport_parent_element) ? TRUE : FALSE;
    is_sched_object_ns = (flags & dpp_device_cosq_gport_sched_nocirpir_ds_element) ? TRUE : FALSE;
    is_connnector_object = (flags & dpp_device_cosq_gport_connector_element) ? TRUE : FALSE;

#ifdef BCM_WARM_BOOT_SUPPORT
    BCM_DPP_UNIT_CHECK(unit);

    if (SOC_WARM_BOOT(unit)) {
        is_warmboot_phase = TRUE;
    }
#endif /* BCM_WARM_BOOT_SUPPORT */

    /*
     * consistency checks
     */
    if (is_child) {
        if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport) ||
              BCM_GPORT_IS_SCHEDULER(gport) || BCM_COSQ_GPORT_IS_SCHED_CIR(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_PIR(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Unexpected child gport type, 0x%x"), gport));
        }
    }  

    if (is_parent) {
        if (!(BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_CIR(gport) || BCM_COSQ_GPORT_IS_SCHED_PIR(gport) ||
              BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("Unexpected parent gport type, 0x%x"), gport));
        }
    }

    if (is_sched_object_ns) {
        if (!(BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
              BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected sched object name space gport type, 0x%x"), gport));
        }
    }

    if (is_connnector_object) {
        if (!(BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport))) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected connector gport type, 0x%x"), gport));
        }

        if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
            BCM_INT_DPP_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
            if (gport_sf2_type != BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) {
              BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unexpected connector gport type, 0x%x"), gport));
            }
        }
    }

    if (BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_GPORT_IS_SCHEDULER(gport) ||
            BCM_COSQ_GPORT_IS_SCHED_CIR(gport) || BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        if ((in_cosq != 0) && (in_cosq != -1)) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
        }
        is_se = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        if ((in_cosq < 0) || (in_cosq > DPP_DEVICE_COSQ_MAX_COS)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
        }
        is_se = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        if ((in_cosq < 0) || (in_cosq > DPP_DEVICE_COSQ_MAX_COS)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
        }
        is_connector = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        /* determine if associated with  connector or se */
        BCM_INT_DPP_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, gport);
        is_connector = (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) ? TRUE : FALSE;

        if (is_connector == FALSE) {
            is_se = TRUE;
            if ((in_cosq != 0) && (in_cosq != -1)) { 
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
            }
        }
        else {
            if ((in_cosq < 0) || (in_cosq > DPP_DEVICE_COSQ_MAX_COS)) {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos levels %d"), unit, in_cosq));
            }
        }
    }
    /*
     * Determine whether the gport is valid (pass1).
     * Also,classify the source for getting flow_id (for OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY)
     */
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    /*
     * This is not necessary. Just precaution.
     */
    source_of_flow_id = 0 ;
/* } */
#endif
    if (BCM_COSQ_GPORT_IS_E2E_PORT(gport) || BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        /*
         * Reminder: For ARAD, returned 'core' should be '0'.
         */
        rc = _bcm_petra_cosq_fap_port_get(unit, gport, &tm_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "failed to get fap port for gport: 0x%x, error(0x%x)\n"), gport, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
            priority = DPP_COSQ_PB_DEFAULT_PORT_TC;
        } else {
            /* Port-TC */
            /* validate priority */
            rc = _bcm_petra_cosq_port_priority_validate(unit,gport,in_cosq);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "verify for gport: 0x%x cosq %d failed, error(0x%x)\n"), gport, in_cosq, rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            priority = in_cosq ;
        }

        rc = _bcm_petra_cosq_port2se_id(unit,core,tm_port,priority,&se_id);
        if (rc != BCM_E_NONE || se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE for port %d"), unit, tm_port));
        }

        base_flow_id = flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_id)));
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = VIG_SRC_FID_E2E_PORT ;
/* } */
#endif
        /* retrieve SE info */
    }
    else if (BCM_GPORT_IS_SCHEDULER(gport)) {
        base_flow_id = flow_id = BCM_GPORT_SCHEDULER_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = VIG_SRC_FID_SCHEDULER ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_CIR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_SCHED_CIR_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = VIG_SRC_FID_SCHED_CIR ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_SCHED_PIR_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = VIG_SRC_FID_SCHED_PIR ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(gport);
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = VIG_SRC_FID_VOQ_CONNECTOR ;
/* } */
#endif
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        base_flow_id = flow_id = BCM_COSQ_GPORT_COMPOSITE_SF2_GET(gport);
        is_sf2 = TRUE;
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
        source_of_flow_id = VIG_SRC_FID_COMPOSITE_SF2 ;
/* } */
#endif
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE for port %d"), unit, /* port */0));
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    /*
     * End of first stage (for getting flow_id). Beginning of second stage.
     * At this point, flow_id has been calculated (and is equal to 'base_flow_id').
     */
    first_stage_flow_id = flow_id ;

    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        if (Vig_db[unit]) {
            entry_was_found[0] =
                bcm_petra_vig_lookup(
                  Vig_db[unit], unit, core, flow_id, source_of_flow_id,&base_vig_leaf_on_tree) ;
            if (entry_was_found[0]) {
                /*
                 * Matching entry has been found. Use information on data base for second stage.
                 * Pointer to structure of type 'bcm_dpp_cosq_vig_leaf_t' (on data base)
                 * is returned on base_vig_leaf_on_tree.
                 */
                /*
                 * Found entry must be marked as 'base flow'.
                 */
                if (!(base_vig_leaf_on_tree->is_base_flow)) {
                    rc = BCM_E_INTERNAL ;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "Found base flow entry (but is not marked as such)\r\n")) ) ;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                /*
                 * Info on leaf/element (on data base) should be valid.
                 */
                {
                    /*
                     * Point 'flow_config' and 'se_config' to locations in found entry
                     * and do not reread them from HW again.
                     */
                    info = &(base_vig_leaf_on_tree->gport_info) ;
                    flow_config = info->flow_config ;
                    se_config = info->se_config ;
                    se_id = info->se_id ;
                    *info_p = info ;
                }
            } else {
                /*
                 * No matching entry has been found. Data need to be collected and
                 * inserted into binary tree.
                 * Empy element (invalid) is pointed by 'base_vig_leaf_on_tree'.
                 */
            }
        } else {
            /*
             * Data base has not yet been initialized. Do all required initializations,
             * collect VIG info and load into db.
             */
            rc = bcm_petra_vig_db_create(unit,(bcm_dpp_cosq_vig_leaf_t **)&Vig_db[unit]) ;
            if (rc != 0) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                    (BSL_META_U(unit,
                        "failed to create binary tree: error0x%08lX\r\n"), (unsigned long)rc));
                BCMDNX_IF_ERR_EXIT(rc);
            }
            entry_was_found[0] =
                bcm_petra_vig_lookup(
                  Vig_db[unit], unit, core, flow_id, source_of_flow_id,&base_vig_leaf_on_tree) ;
        }
        /*
         * At this point, the data base (direct table/tree) is set.
         * 'base_vig_leaf_on_tree' is pointed to corresponding element/leaf.
         * If 'entry_was_found[0]' is not set then we need to load entry with
         * data collected so far.
         * Otherwise, found entry is valid and contains collected data which will be
         * used below until a new flow_id is indicated (or current flow_id is
         * also used as new).
         */
    }
/* } */
#endif
    if ( (is_se) && (base_flow_id != -1) ) {
        if (!entry_was_found[0]) {
            /*
             * If matching entry in data base has NOT been found then 'se_id' needs
             * to be calculated (arad_sch_flow2se_id()).
             */
            se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, base_flow_id)));
        }
        if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE associated with flow %d"), unit, base_flow_id));
        }
    }

    if (is_connector) {
        if (!entry_was_found[0]) {
            /*
             * If matching entry in data base has NOT been found then 'flow_config' needs
             * to be loaded from chip memory (arad_sch_flow_get()).
             */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, core, base_flow_id, flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retrieving sch flow (%d), soc_sand error 0x%x, error 0x%x\n"), unit, base_flow_id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }
    else if (is_se) {
        if (!entry_was_found[0]) {
            /*
             * If matching entry in data base has NOT been found then 'flow_config' and
             * 'se_config' need to be loaded from chip memory (arad_sch_aggregate_get()).
             */
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, se_id, se_config, flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in retrieving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
      if (!entry_was_found[0])
      {
        /*
         * If matching entry in data base has NOT been found then insert new
         * entry into data base.
         *
         * Insert info collected on 'vig_leaf' into data base (tree/direct table)
         */
        bcm_dpp_cosq_gport_info_t *loc_info ;

        vig_leaf.gport = (int)gport ;
        vig_leaf.is_base_flow = 1 ;
        vig_leaf.base_flow_id = base_flow_id ;
        vig_leaf.source_of_flow_id = source_of_flow_id ;
        /*
         * copy info collected on 'vig_leaf' to element on data base (pointed by )
         */
        *base_vig_leaf_on_tree = vig_leaf ;

        /* update data structure */
        base_vig_leaf_on_tree->gport_info.is_connector = is_connector;
        base_vig_leaf_on_tree->gport_info.is_se = is_se;
        base_vig_leaf_on_tree->gport_info.is_sf2 = is_sf2;
        base_vig_leaf_on_tree->gport_info.flow_id = flow_id;
        if (is_se) {
            base_vig_leaf_on_tree->gport_info.se_id = se_id;
        }
        base_vig_leaf_on_tree->gport_info.actual_flow_id = flow_id;
        if (is_sf2) {
            is_composite = ( (base_vig_leaf_on_tree->flow_config.sub_flow[0].is_valid == TRUE) &&
                            (base_vig_leaf_on_tree->flow_config.sub_flow[1].is_valid == TRUE) ) ? TRUE : FALSE;
            flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
            rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
            BCMDNX_IF_ERR_EXIT(rc);
            rc = _bcm_petra_composite_flow_id_get(unit, core, base_flow_id, 0, is_non_contiguous, is_composite,&sf2_id);
            BCMDNX_IF_ERR_EXIT(rc);
            base_vig_leaf_on_tree->gport_info.actual_flow_id = sf2_id;
        }
        base_vig_leaf_on_tree->gport = (int)gport ;
        /*
         * Info is of type 'bcm_dpp_cosq_gport_info_t'. We now need to update it
         * with pointers (on newly allocated tree) to some of collected data.
         */
        loc_info = &(base_vig_leaf_on_tree->gport_info) ;
        flow_config = loc_info->flow_config = &(base_vig_leaf_on_tree->flow_config) ;
        se_config = loc_info->se_config = &(base_vig_leaf_on_tree->se_config) ;
        /*
         * Later on, just before exit-without-errors, we shall mark info on
         * element/leaf (on data base) as valid.
         * Also, if, at exit, we find that first_stage flow_id remained as the final
         * one then we may need to update some items on the data base.
         */
      }
    }
/* } */
#endif

    is_composite = ( (flow_config->sub_flow[0].is_valid == TRUE) &&
                            (flow_config->sub_flow[1].is_valid == TRUE) ) ? TRUE : FALSE;
    flow_region = BCM_DEVICE_PETRA_COSQ_FLOW_REGION_GET(base_flow_id);
    rc = _bcm_petra_flow_region_config_get(unit, core, flow_region, &is_non_contiguous, &is_odd_even, &is_cl_cir);
    BCMDNX_IF_ERR_EXIT(rc);

    /* determine if pass2 is required */
    if (BCM_GPORT_IS_SCHEDULER(gport)) {
        if (se_config->is_dual == TRUE) {
            if (is_sched_object_ns == TRUE) {
                is_dual = TRUE;
            }
            else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d,gport 0x%08lX, not a dual configuration for se 0x%x"), unit, gport, se_id));
            }
        }
    }
    else if ((BCM_COSQ_GPORT_IS_SCHED_CIR(gport) && is_cl_cir) || (BCM_COSQ_GPORT_IS_SCHED_PIR(gport) && !is_cl_cir)) {
        if (se_config->is_dual == FALSE) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, not a dual configuration for se 0x%x"), unit, se_id));
        }
        is_dual = TRUE;
    }
    else if ((BCM_COSQ_GPORT_IS_SCHED_PIR(gport) && is_cl_cir) || (BCM_COSQ_GPORT_IS_SCHED_CIR(gport) && !is_cl_cir) ) {
        if (se_config->is_dual == FALSE) {
            LOG_INFO(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                "Flow id (%d) PIR not marked as dual (first_stage_flow_id %d). gport 0x%08lX\r\n"),
                  flow_id,first_stage_flow_id,(unsigned long)gport) ) ;
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, not a dual configuration for se 0x%x"), unit, se_id));
        }
        is_dual = TRUE;
        rc = _bcm_petra_se_dual_flow_id_get(unit, base_flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &flow_id);
        BCMDNX_IF_ERR_EXIT(rc);
        se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, flow_id)));
        if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, unable to retrieve SE associated with flow %d"), unit, flow_id));
        }
        pass2 = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport)) {
        
        rc = _bcm_petra_flow_id_get(unit, core, base_flow_id, in_cosq, is_non_contiguous, is_composite, FALSE,&flow_id);
        BCMDNX_IF_ERR_EXIT(rc);

        pass2 = TRUE;
    }
    else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport)) {
        if (is_connector) {
            rc = _bcm_petra_flow_id_get(unit, core, base_flow_id, in_cosq, is_non_contiguous, is_composite, FALSE, &flow_id);
            BCMDNX_IF_ERR_EXIT(rc);
            pass2 = TRUE;

            rc = _bcm_petra_composite_flow_id_get(unit, core, base_flow_id, in_cosq, is_non_contiguous, is_composite,&sf2_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
        else {
            rc = _bcm_petra_se_composite_flow_id_get(unit, base_flow_id, SOC_TMC_SCH_SE_TYPE_NONE, TRUE, &sf2_id);
            BCMDNX_IF_ERR_EXIT(rc);
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
    {
        /*
         * END OF SECOND STAGE. If flow_id has been changed, mark it.
         */
        if (flow_id != first_stage_flow_id)
        {
            /*
             * Initial flow_id ('base_flow_id') was changed. We need to use
             * another entry for the new flow id. This is done at exit.
             * Note that the 'base' entry has, by now, either been found or newly created
             * and, in any case, it is in the data base.
             * If we have 'entry not found' on first stage then force 'not found'
             * on this second stage. We do this to keep consistency. {The scenario of
             * 'not found' on first and 'found' on second could be due to 'remnants' of a previous
             * storage (with different 'source_of_flow_id'). Remember that we mark 'not found' if
             * there is no match on 'source_of_flow_id'}
             */
            entry_was_found[1] =
                bcm_petra_vig_lookup(
                  Vig_db[unit], unit, core, flow_id, source_of_flow_id,&final_vig_leaf_on_tree) ;
            if (!entry_was_found[0]) { /* Flow id found on second stage but not on first stage */
                final_vig_leaf_on_tree->valid = 0 ;
                entry_was_found[1] = 0 ;
            }
            if (entry_was_found[1]) {
                /*
                 * Matching entry has been found. Return to caller with pointer to
                 * information on data base.
                 * Note that this entry needs to have 'final_vig_leaf_on_tree->is_final_flow' set!!
                 */
                if (final_vig_leaf_on_tree->is_final_flow == 0)
                {
                    /*
                     * Should not happen!
                     */
                    rc = BCM_E_PARAM ;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "Found valid entry (but not marked final)\r\n")) ) ;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
                /*
                 * Info on element/leaf (on data base) should be valid.
                 */
                {
                    info = &(final_vig_leaf_on_tree->gport_info) ;
                    *info_p = info ;
                    goto exit ;
                }
            } else {
                /*
                 * No matching entry has been found. Data need to be collected and
                 * inserted into data base. Element on db is pointed by 'final_vig_leaf_on_tree'
                 */
                flow_config = &(vig_leaf.flow_config) ;
                se_config = &(vig_leaf.se_config);
            }
        }
        else
        {
            /*
             * Flow_id has NOT change on second stage
 */
            if (entry_was_found[0])
            {
                /*
                 * Entry HAS been found on first stage.
                 * No need to update information collected above. Go to exit.
                 */
                goto exit ;
            }
            else
            {
                /*
                 * Entry HAS NOT been found on first stage
                 * We need to proceeed and load entry just before exit.
                 */
            }
        }
    }
/* } */
#endif
    /* pass 2 processing */
    if (pass2 == TRUE) {
        if (is_connector) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_flow_get,(unit, core, flow_id, flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving sch flow (%d), soc_sand error 0x%x, error 0x%x\n"), unit, flow_id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
        else if (is_se) {
            soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, se_id, se_config, flow_config)));
            if (SOC_SAND_FAILURE(soc_sand_rc)) {
                rc = translate_sand_success_failure(soc_sand_rc);
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, error in retreiving scheduler element %d, soc_sand error 0x%x, error 0x%x\n"), unit, se_id, soc_sand_rc, rc));
                BCMDNX_IF_ERR_EXIT(rc);
                BCM_EXIT;
            }
        }
    }

    /* state consistency check */
    /* NOTE: if required checking can be based on any additional flags that may be later added */
    if ( (is_warmboot_phase == FALSE) &&
             (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport) || BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport) ||
              BCM_GPORT_IS_SCHEDULER(gport) || BCM_COSQ_GPORT_IS_SCHED_CIR(gport) ||
              BCM_COSQ_GPORT_IS_SCHED_PIR(gport)) ) {
        if (is_connector) {
            _bcm_petra_cosq_is_conn_reserved(unit, base_flow_id, &is_reserved);
            if (is_reserved != TRUE) {
                state_check = TRUE;
            }
        }
        else if (is_se) {
            fap_port = DPP_COSQ_SCH_PORT_ID_INVALID(unit);
            _bcm_petra_cosq_is_se_reserved(unit, core, se_id, &is_reserved);
            rc = _bcm_petra_cosq_se_id2port(unit, core, se_id, &fap_port, &priority);
            if (rc != BCM_E_NONE) {
                state_check = TRUE;
            }
            else if ( (is_reserved != TRUE) && (fap_port == DPP_COSQ_SCH_PORT_ID_INVALID(unit)) ) {
                state_check = TRUE;
            }
        }
    }
    if (state_check == TRUE) {
        if (is_connector) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_flow_id, &sw_state_num_cos));
            if ((sw_state_num_cos == 0) || (in_cosq >= sw_state_num_cos) ) {
                rc = BCM_E_NOT_FOUND;
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
        else if (is_se) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, se_id, &sw_state_ref_cnt));
            if (sw_state_ref_cnt == 0) {
                rc = BCM_E_NOT_FOUND;
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }
#if OPTIMIZE_VALIDATE_INFO_GET_AT_ENTRY
/* { */
    {
        if (SOC_CONTROL(unit)->runtime_performance_optimize_enable_sched_allocation)
        {
            if (!entry_was_found[0])
            {
              /*
               * Note that we enter here also when no match was found on both
               * first stage and second stage.
               * If entry was not found on first stage then this is a good place
               * (after all validity checks) to mark collected info (in data base)
               * as valid.
               * At any point before this one, then, it is not marked as valid so
               * that any validity fail blocks update of the data base.
               */
              base_vig_leaf_on_tree->gport_info.is_non_contiguous = is_non_contiguous;
              base_vig_leaf_on_tree->gport_info.is_dual = is_dual;
              base_vig_leaf_on_tree->gport_info.is_composite = is_composite;
              if (flow_id == first_stage_flow_id)
              {
                if (is_se) {
                    base_vig_leaf_on_tree->gport_info.se_id = se_id;
                }
                if (is_sf2) {
                    base_vig_leaf_on_tree->gport_info.actual_flow_id = sf2_id;
                }
                /*
                 * Mark this entry as 'containing info on final flow'.
                 */
                base_vig_leaf_on_tree->is_final_flow = 1 ;
                /*
                 * We load 'info' here since this is the final flow.
                 */
                info = &(base_vig_leaf_on_tree->gport_info) ;
              }
              base_vig_leaf_on_tree->valid = 1 ;
            }
            if (flow_id != first_stage_flow_id)
            {
                /*
                 * If flow_id has changed on the second stage then a new entry needs to
                 * be updated in the data base. Entry is pointed by 'final_vig_leaf_on_tree'
                 */

                /* update data structure */
                vig_leaf.gport_info.is_connector = is_connector;
                vig_leaf.gport_info.is_se = is_se;
                vig_leaf.gport_info.is_composite = is_composite;
                vig_leaf.gport_info.is_non_contiguous = is_non_contiguous;
                vig_leaf.gport_info.is_dual = is_dual;
                vig_leaf.gport_info.is_sf2 = is_sf2;
                vig_leaf.gport_info.flow_id = flow_id;
                if (is_se) {
                    vig_leaf.gport_info.se_id = se_id;
                }
                vig_leaf.gport_info.actual_flow_id = flow_id;
                if (is_sf2) {
                    vig_leaf.gport_info.actual_flow_id = sf2_id;
                }
                vig_leaf.gport = (int)gport ;
                vig_leaf.source_of_flow_id = source_of_flow_id ;
                vig_leaf.base_flow_id = base_flow_id ;
                /*
                 * Mark this entry as 'containing info on final flow'.
                 */
                vig_leaf.is_final_flow = 1 ;
                *final_vig_leaf_on_tree = vig_leaf ;
                /*
                 * Info is of type 'bcm_dpp_cosq_gport_info_t'. We now need to update it
                 * with pointers (on newly allocated tree) to some of collected data.
                 */
                info = &(final_vig_leaf_on_tree->gport_info) ;
                info->flow_config = &(final_vig_leaf_on_tree->flow_config) ;
                info->se_config = &(final_vig_leaf_on_tree->se_config) ;
                /*
                 * Mark info on leaf (on tree) as valid.
                 */
                final_vig_leaf_on_tree->valid = 1 ;
            }
            else
            {
                /*
                 * flow_id has NOT changed on the second stage so the 'base' entry
                 * (which is, by now, also the 'final' entry) needs to be used for update here.
                 */
                if (entry_was_found[0])
                {
                    /*
                     * flow_id has NOT changed on the second stage and 'base' entry has been found.
                     * In that case, program flow should take it to 'exit' so we should never get here!
                     */
                    rc = BCM_E_INTERNAL ;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                        (BSL_META_U(unit,
                            "flow_id NOT changed on 2nd and 'base' entry was found but - program did not go to exit: error(0x%08lX)\r\n"), (unsigned long)rc)) ;
                    BCMDNX_IF_ERR_EXIT(rc);
                }
            }
        }
        else
        {
            /* update data structure */
            info->is_connector = is_connector;
            info->is_se = is_se;
            info->is_composite = is_composite;
            info->is_non_contiguous = is_non_contiguous;
            info->is_dual = is_dual;
            info->is_sf2 = is_sf2;
            info->flow_id = flow_id;
            if (is_se) {
                info->se_id = se_id;
            }
            info->actual_flow_id = flow_id;
            if (is_sf2) {
                info->actual_flow_id = sf2_id;
            }
        }
    }
/* } */
#else
/* { */
    /* update data structure */
    info->is_connector = is_connector;
    info->is_se = is_se;
    info->is_composite = is_composite;
    info->is_non_contiguous = is_non_contiguous;
    info->is_dual = is_dual;
    info->is_sf2 = is_sf2;
    info->flow_id = flow_id;
    if (is_se) {
        info->se_id = se_id;
    }
    info->actual_flow_id = flow_id;
    if (is_sf2) {
        info->actual_flow_id = sf2_id;
    }
/* } */
#endif
    /*
     * Only now load pointer to allocated memory into place (to be used
     * by the caller).
     */
    *info_p = info ;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_validate_connector_id(int unit, int is_non_contiguous, int is_composite, int num_cos, int flow_id)
{
    int rc = BCM_E_NONE;

   
    BCMDNX_INIT_FUNC_DEFS;
    if (is_non_contiguous) {
        if (!(flow_id & 0x2)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, connector 0x%x not at an offset of 2\n"), unit, flow_id));
            rc = BCM_E_PARAM;
        }
    }
    switch (is_non_contiguous) {
        case TRUE:
            switch (is_composite) {
                case TRUE:
                    if (((flow_id - 0x2) % (num_cos * 4)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos*4, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                case FALSE:
                    if (((flow_id - 0x2) % (num_cos * 2)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos*2, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                default: rc = BCM_E_PARAM; break;
            }
            break;

        case FALSE:
            switch (is_composite) {
                case TRUE:
                    if ((flow_id % (num_cos * 2)) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos*2, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                case FALSE:
                    if ((flow_id % num_cos) != 0) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, connector 0x%x not aligned at %d\n"), unit, num_cos, flow_id));
                        rc = BCM_E_PARAM;
                    }
                    break;

                default: rc = BCM_E_PARAM; break;
            }
            break;

        default: rc = BCM_E_PARAM; break;
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_parent_gport_to_resource_gport(int unit, bcm_gport_t sched_port, int allow_core_all, bcm_gport_t *parent_port)
{
    bcm_error_t rc = BCM_E_NONE;
    int sched_id, core;
    bcm_gport_t sw_state_isq_port, sw_state_fmq_class_port;



    BCMDNX_INIT_FUNC_DEFS;
    (*parent_port) = sched_port;

    if (BCM_GPORT_IS_SCHEDULER(sched_port)) {
        sched_id = BCM_GPORT_SCHEDULER_GET(sched_port);
        rc = _bcm_petra_cosq_core_get(unit, sched_port, allow_core_all, &core);
        BCMDNX_IF_ERR_EXIT(rc);

        if (sched_id >= DPP_COSQ_SCH_MAX_FLOW_ID(unit)) {
            switch (sched_id) {
                case _SHR_GPORT_FMQ_CLASS1:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 0, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-1 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_FMQ_CLASS2:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 1, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-2 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_FMQ_CLASS3:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 2, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-3 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_FMQ_CLASS4:
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.fmq_class_ports.get(unit, core, 3, &sw_state_fmq_class_port));
                    if (sw_state_fmq_class_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, FMQ Class-4 resource not allocated\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_fmq_class_port;
                    break;
                case _SHR_GPORT_ISQ_ROOT:
                  BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.isq_port.get(unit, core, &sw_state_isq_port));
                  if (sw_state_isq_port == BCM_GPORT_INVALID) {
                        rc = BCM_E_PARAM;
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, ISQ resource not allocated, need to set isq range\n"), unit));
                        break;
                    }
                    (*parent_port) = sw_state_isq_port;
                    break;
            default:
              (*parent_port) = sched_port;
            }
        }
    }

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Utility Functions
 */


/* function which returns pbmp or internal port associated with the given FAP port */
int
bcm_petra_tm_port_get(int unit, int core, int p_fap_port, bcm_port_t* port)
{
    soc_port_t out_port;
    BCMDNX_INIT_FUNC_DEFS;

    if (core == BCM_CORE_ALL) {
        /*
         * Get operation for all cores: Read from core '0'.
         */
        core = 0 ;
    } else {
        if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) invalid core ID(%d) for getting flow id."), unit, core));
        }
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_tm_to_local_port_get,(unit, core, p_fap_port, &out_port)));

   *port = out_port;

exit:
    BCMDNX_FUNC_RETURN;
}

/* Returns the FAP port associated with the given mod:port gport */
STATIC int
_bcm_petra_cosq_fap_port_get(int unit, bcm_gport_t gport, uint32 *p_fap_port, int* core, int *is_interface)
{
    bcm_port_t port = 0;
    int is_interface_gport = FALSE;
    bcm_port_t     mod_port; 
    bcm_module_t    modid, base_modid;
    int                 rv = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_LOCAL(gport)) {
        port = BCM_GPORT_LOCAL_GET(gport);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DPP_PORT_INTERFACE_START;
            is_interface_gport = TRUE;
        }

    } else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_GET(gport);
        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            port -= BCM_DPP_PORT_INTERFACE_START;
            is_interface_gport = TRUE;
        }
    } else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_PORT_TC_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(gport);        
    } else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_PORT_TCG_GET(gport);        
    } else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TCG_GET(gport);        
    } else if (BCM_GPORT_IS_MODPORT(gport)) {
        mod_port = BCM_GPORT_MODPORT_PORT_GET(gport);
        modid = BCM_GPORT_MODPORT_MODID_GET(gport);

        rv = bcm_petra_stk_my_modid_get(unit, &base_modid);
        BCMDNX_IF_ERR_EXIT(rv);

        if (SOC_DPP_IS_MODID_AND_BASE_MODID_ON_SAME_FAP(unit, modid, base_modid)){

            *core = SOC_DPP_MODID_TO_CORE(unit, base_modid, modid);
            rv = soc_port_sw_db_tm_to_local_port_get(unit, *core, mod_port, (soc_port_t *)&port);
            BCMDNX_IF_ERR_EXIT(rv);
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
        }

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DPP_PORT_INTERFACE_START;
            is_interface_gport = TRUE;
        }
        
    } else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_GET(gport);
    } else if ((SOC_PORT_VALID(unit, port)) && (IS_PORT(unit, port))) {
        port = gport;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_tm_port_get, (unit, port, p_fap_port, core)));

    if (is_interface != NULL) {
        (*is_interface) = is_interface_gport;
    }

    LOG_DEBUG(BSL_LS_BCM_COSQ,
              (BSL_META_U(unit,
                          "unit(%d) port(%d) fap_port(%d)\n"), unit, port, *p_fap_port));
    
exit:
    BCMDNX_FUNC_RETURN;
}
/*************************************************************
*  NAME
*    _bcm_petra_cosq_core_get
*  TYPE:
*    PROC
*  DATE:
*    13/11/2014
*  FUNCTION:
*    Given 'unit' and 'gport', get corresponding core.
*  INPUT:
*    Direct:
*      int unit -
*        Identifier of device to access.
*      bcm_gport_t gport -
*        Identifier of gport to deduce 'core' from.
*      int *core -
*        This procedure loads pointed memory by identifier of
*        corresponding 'core'
*    Indirect:
*      None
*  OUTPUT:
*    Direct:
*      BCM_E_NONE or error code as per bcm_error_t.
*    Indirect:
*      *core 
*  REMARKS:
*    
*  See also:
*    BCM_GPORT_IS_SCHEDULER, BCM_COSQ_GPORT_IS_VOQ_CONNECTOR
 */
int
_bcm_petra_cosq_core_get(int unit, bcm_gport_t gport, int allow_core_all, int *core)
{
  uint32 fap_port ;

  BCMDNX_INIT_FUNC_DEFS ;
  BCMDNX_NULL_CHECK(core) ;
  if (SOC_DPP_DEFS_GET(unit, nof_cores) <= 1)
  {
    *core = 0 ;
  }
  else if (BCM_COSQ_GPORT_IS_CORE(gport)) {
    *core = BCM_COSQ_GPORT_CORE_GET(gport);
  }
  else if (BCM_GPORT_IS_SCHEDULER(gport))
  {
    *core = BCM_GPORT_SCHEDULER_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(gport))
  {
    *core = BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_SCHED_CIR(gport))
  {
    *core = BCM_COSQ_GPORT_SCHED_CIR_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_SCHED_PIR(gport))
  {
    *core = BCM_COSQ_GPORT_SCHED_PIR_CORE_GET(gport) ;
  }
  else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(gport))
  {
    *core = BCM_COSQ_GPORT_COMPOSITE_SF2_CORE_GET(gport) ;
  }
  else
  {
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_fap_port_get(unit,gport,&fap_port,core, NULL)) ;
  }

  /* If extracted core is out of bounds then return with error. */
  SOC_DPP_CORE_VALIDATE(unit, (*core), allow_core_all);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_user_port_get(int unit, bcm_gport_t gport, bcm_port_t *user_port)
{
    int rc = BCM_E_NONE;
    bcm_port_t port = 0;
    
    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_LOCAL(gport)) {
        port = BCM_GPORT_LOCAL_GET(gport);

        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            port -= BCM_DPP_PORT_INTERFACE_START;
        }        
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_GET(gport);

        /* if this is the interface, return the fap port associated with that interface */
        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            port -= BCM_DPP_PORT_INTERFACE_START;
        }
    }
    else if (BCM_GPORT_IS_MODPORT(gport)) {
        port = BCM_GPORT_MODPORT_PORT_GET(gport);

        if (BCM_DPP_PORT_IS_INTERFACE(port)) {
            /* if this is the interface, return the fap port associated with that interface */
            port -= BCM_DPP_PORT_INTERFACE_START;
        }
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_PORT_TC_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TC(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TC_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_PORT_TCG_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_E2E_PORT_TCG(gport)) {
        port = BCM_COSQ_GPORT_E2E_PORT_TCG_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_UCAST_EGRESS_QUEUE_GET(gport);
    }
    else if (BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) {
        port = BCM_COSQ_GPORT_MCAST_EGRESS_QUEUE_GET(gport);
    }
    else if ((SOC_PORT_VALID(unit, gport)) && (IS_PORT(unit, gport))) {
        port = gport;
    }
    else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Query invalid, port must be of type mod/port or e2e for gport 0x%08x"), gport));
    }

    (*user_port) = port;

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fc_port_info_get(int             unit,
                                bcm_gport_t     gport,
                                int            *is_fc_calender,
                                int            *is_fc_inband,
                                uint32         *fc_calender_port)
{
    int rc = BCM_E_NONE;
    bcm_port_t user_port;
    int congestion_port;
    uint32 ilkn_id = 0;
    soc_port_if_t interface_type;
    uint32 calander_id = 0; /* Decided which one is used in six ilkn inband calandar in Jericho */

    BCMDNX_INIT_FUNC_DEFS;

    /* check if it is a congestion port */
    if (BCM_GPORT_IS_CONGESTION(gport)) {
        congestion_port = BCM_GPORT_CONGESTION_GET(gport);
        if (congestion_port >= SOC_DPP_CONFIG(unit)->tm.max_oob_ports) {
            SOCDNX_EXIT_WITH_ERR(BCM_E_PARAM, (_BSL_SOC_MSG("invalid congestion port (%d)"),congestion_port));
        }

        (*is_fc_calender) = TRUE;
        (*is_fc_inband) = FALSE;
        (*fc_calender_port) = congestion_port;
    } else if (BCM_COSQ_GPORT_IS_INBAND_COE(gport)){ /* check if it is a inband coe port */
        calander_id = BCM_COSQ_GPORT_INBAND_COE_GET(gport);
        /* Inband COE uses ilkn inband calandar in Jericho; Inband COE uses dedicated calandar in QAX*/
        if (SOC_IS_JERICHO(unit) && !SOC_IS_QAX(unit)){
            if ((calander_id >= SOC_DPP_CONFIG(unit)->tm.max_interlaken_ports)) {
                SOCDNX_EXIT_WITH_ERR(BCM_E_PARAM, (_BSL_SOC_MSG("invalid ilkn id (%d)"),ilkn_id));
            }
        }

        (*is_fc_calender) = TRUE;
        (*is_fc_inband) = TRUE;
        (*fc_calender_port) = calander_id;
    } else {

        rc = bcm_petra_cosq_user_port_get(unit, gport, &user_port);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_interface_type_get(unit, user_port, &interface_type);
        BCMDNX_IF_ERR_EXIT(rc);

        if (interface_type == SOC_PORT_IF_ILKN) {
            rc = soc_port_sw_db_protocol_offset_get(unit, user_port, 0, &ilkn_id);
            BCMDNX_IF_ERR_EXIT(rc);

            if (ilkn_id >= SOC_DPP_CONFIG(unit)->tm.max_interlaken_ports) {
                SOCDNX_EXIT_WITH_ERR(BCM_E_PARAM, (_BSL_SOC_MSG("invalid interlaken id (%d)"),ilkn_id));
            }

            (*is_fc_calender) = TRUE;
            (*is_fc_inband) = TRUE;
            (*fc_calender_port) = ilkn_id;
        }
        else {
            (*is_fc_calender) = FALSE;
            (*is_fc_inband) = TRUE;
            (*fc_calender_port) = -1;
        }
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC unsigned int
_bcm_cosq_bit_count_get(uint32 value)
{ 
    uint32 count = 0; 

    while (value > 0) {           /* until all bits are zero  */
        if ((value & 1) == 1) {   /* check lower bit */
            count++; 
        } 
        value >>= 1;              /* shift bits, removing lower bit */
    } 

    return count;
} 


/*
 * element (data structure) allocation
 */
/* This function to be populated if we allocate dynamically memory for */
/* flow_hd, se_hd, connector_hd, voq_hd rather than having this fixed  */
/* in the bcm_dpp_cosq_config_t structure                              */
/* structure.                                                          */            
/* static */ bcm_dpp_cosq_list_hd_t *
_bcm_petra_cosq_listhd_alloc(int unit)
{
    return(NULL);
}

STATIC int
_bcm_petra_cosq_fmq_hr_port_allocate(int unit, bcm_core_t core, int nbr_ports, uint32 *tm_ports)
{
    int rc = BCM_E_NONE;
    int index = 0;
    SOC_TMC_SCH_PORT_INFO port_info;
    uint32 soc_sand_rc;
    int* hr_fmq_array = NULL;
    soc_port_t logical_port = 0;
    bcm_core_t core_1;

    BCMDNX_INIT_FUNC_DEFS;

    /* 
     * FMQ and ISQ HRs are being assumed to be allocated after soc init.
     * All HRs that are currently used are Ports-HRs
     * FMQ and ISQ HRs must be allocated from a free PS.
     * So first find a free PS and then allocate HRs.
     * This being handled in the following API.
     */ 
    rc = soc_arad_fmq_base_hr_get(unit, core, &hr_fmq_array);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Allocate unused local ports */
    for (index = 0; index < nbr_ports; index++) {
        rc = _bcm_petra_port_find_free_port_and_allocate(unit, core, SOC_PORT_IF_NOCXN, 0, &logical_port);
        BCMDNX_IF_ERR_EXIT(rc);
      
        rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.base_q_pair.set(unit, logical_port, hr_fmq_array[index]);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_tm_port_get(unit, logical_port, &tm_ports[index], &core_1);
        BCMDNX_IF_ERR_EXIT(rc);

        if(core != core_1) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("Core validation failed")));
        }

        rc = arad_egr_dsp_pp_to_base_q_pair_set(unit, core, tm_ports[index], hr_fmq_array[index]);
        BCMDNX_IF_ERR_EXIT(rc); 
        
        if (hr_fmq_array[index] % 8 == 0) { /* Set new configured PS */
            soc_sand_rc = arad_egr_dsp_pp_priorities_mode_set(unit, core, tm_ports[index], SOC_TMC_EGR_PORT_ONE_PRIORITY);
            BCMDNX_IF_ERR_EXIT(soc_sand_rc);
        } 

        /* Update only SW */
        BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_set(unit, logical_port, 1));
    }  

    for (index = 0; index < nbr_ports; index++) {
        /* Set port enable */        
        SOC_TMC_SCH_PORT_INFO_clear(&port_info);
        port_info.enable = TRUE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }        
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, tm_ports[index], &port_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
        BCM_DPP_UNIT_CHECK(unit);
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_fmq_hr_port_deallocate(int unit, int core, int nbr_ports, uint32 *tm_ports)
{
    int rc = BCM_E_NONE;
    int index = 0;
    soc_port_t port;
    BCMDNX_INIT_FUNC_DEFS;
    for (index = 0; index < nbr_ports; index++) {
        BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, tm_ports[index], &port));
        BCMDNX_IF_ERR_EXIT(soc_port_sw_db_port_remove(unit, port));
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_isq_hr_port_allocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    int rc = BCM_E_NONE;
    SOC_TMC_SCH_PORT_INFO port_info;
    uint32 soc_sand_rc; 
    int hr_isq;
    soc_port_t logical_port = -1;
    bcm_core_t core_index, core_tmp;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    BCM_DPP_CORES_ITER(core, core_index) {
        /* 
         * FMQ and ISQ HRs are being assumed to be allocated after soc init.
         * All HRs that are currently used are Ports-HRs
         * FMQ and ISQ HRs must be allocated from a free PS.
         * for ARAD first find a free PS and then allocate HRs.
         * This being handled in the following API.
         */ 
        rc = soc_arad_isq_hr_get(unit, core_index, &hr_isq);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Allocate unused local ports */
        rc = _bcm_petra_port_find_free_port_and_allocate(unit, core_index, SOC_PORT_IF_NOCXN, 0, &logical_port);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = sw_state_access[unit].dpp.soc.arad.tm.logical_ports_info.base_q_pair.set(unit, logical_port, hr_isq);
        BCMDNX_IF_ERR_EXIT(rc);

        rc = soc_port_sw_db_local_to_tm_port_get(unit, logical_port, tm_port, &core_tmp);
        BCMDNX_IF_ERR_EXIT(rc);
        if (core_tmp != core_index) {
            BCMDNX_IF_ERR_EXIT(BCM_E_CONFIG);
        }
        soc_sand_rc = arad_egr_dsp_pp_to_base_q_pair_set(unit, core_index, *tm_port, hr_isq);
        BCMDNX_IF_ERR_EXIT(soc_sand_rc); 
        
        if (hr_isq % 8 == 0) { /* Set new configured PS */
            rc = arad_egr_dsp_pp_priorities_mode_set(unit, core_index, *tm_port, SOC_TMC_EGR_PORT_ONE_PRIORITY);
            BCMDNX_IF_ERR_EXIT(rc);
        } 
        /* Update only SW */
        BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_set(unit, logical_port, 1));
                             
        /* Set port enable */        
        SOC_TMC_SCH_PORT_INFO_clear(&port_info);
        port_info.enable = TRUE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
            port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }    
        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core_index, *tm_port, &port_info)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);        
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_isq_hr_port_deallocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    soc_port_t port;
    BCMDNX_INIT_FUNC_DEFS;
    
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_tm_to_local_port_get(unit, core, *tm_port, &port));
    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_port_remove(unit, port));
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * External Functions
 */
int
bcm_petra_cosq_fmq_hr_allocate(int unit, bcm_core_t core, int nbr_ports, uint32 *tm_ports)
{
    int index = 0;
    int rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id[DPP_DEVICE_FMQ_CLASS_PORTS];
    int flow_id[DPP_DEVICE_FMQ_CLASS_PORTS];
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    bcm_gport_t sw_state_fmq_class_port;    
    
    BCMDNX_INIT_FUNC_DEFS;

    if (nbr_ports > DPP_DEVICE_FMQ_CLASS_PORTS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("core %d, number of ports %d, is out of range"), core, nbr_ports));
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(unit, &sch_flow);
    SOC_TMC_SCH_FLOW_clear(unit, &exact_sch_flow);

    rc = _bcm_petra_cosq_fmq_hr_port_allocate(unit, core, nbr_ports, tm_ports);
    BCMDNX_IF_ERR_EXIT(rc);

    /* enable the HR scheduler elements */
    for (index = 0; index < nbr_ports; index++) {        

        /* retrieve corresponding SE element */
        rc = _bcm_petra_cosq_port2se_id(unit, core, tm_ports[index], DPP_COSQ_PB_DEFAULT_PORT_TC, &(se_id[index]));
        BCMDNX_IF_ERR_EXIT(rc);
        if (se_id[index] == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("error in retreiving seId for fapPort(%d)"), tm_ports[index]));
        }

        /* retrieve corresponding flow id */
        flow_id[index] = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,((se_id[index]))));
        if (flow_id[index] == DPP_COSQ_SCH_FLOW_ID_INVALID(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("error in retreiving FlowId for seId(0x%x)"), se_id[index]));
        }

        rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, 1, BCM_DPP_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id[index]);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* configure scheduler element */
        soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, se_id[index], &se_info, &sch_flow)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        se_info.state = SOC_TMC_SCH_SE_STATE_ENABLE;
        se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_id[index], &se_info, &sch_flow, &exact_sch_flow)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

    /* update local data structures with FMQ Class Schedulers */
    for (index = 0; index < nbr_ports; index++) {
        /* scheduler gport format */
        BCM_GPORT_SCHEDULER_CORE_SET(sw_state_fmq_class_port, flow_id[index], core);
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.fmq_class_ports.set(unit, core, index, sw_state_fmq_class_port));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_ucast_qid_range_set(int unit, int core, int qid_start, int qid_end)
{   
    int                      rc = BCM_E_NONE;
    int                     core_index;


    BCMDNX_INIT_FUNC_DEFS;
    if (!SOC_WARM_BOOT(unit)) {
        BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
            if (qid_start != -1) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.ingress.ucast_qid_start.set(unit, core_index, qid_start));
            }
            if (qid_end != -1) {
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.ingress.ucast_qid_end.set(unit, core_index, qid_end));
            }
        }
    }
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_ucast_qid_range_get(int unit, int core, int *qid_start, int *qid_end)
{   
    int                      rc = BCM_E_NONE;
    int                     core_index = (core == BCM_CORE_ALL || SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) ? 0 : core;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.ingress.ucast_qid_start.get(unit, core_index, qid_start));
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.ingress.ucast_qid_end.get(unit, core_index, qid_end));

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_is_se_reserved(int unit, int core, int se_id, int *is_reserved)
{
    int                      rc = BCM_E_NONE;
    int fap_port;
    bcm_cos_t priority;
    SOC_TMC_SCH_SE_ID sw_state_default_se;

    BCMDNX_INIT_FUNC_DEFS;
    
    (*is_reserved) = FALSE;
    
    if ( (se_id >= SOC_DPP_CONFIG(unit)->tm.port_hr_se_min) && (se_id <= SOC_DPP_CONFIG(unit)->tm.port_hr_se_max) ) {
            rc = _bcm_petra_cosq_se_id2port(unit, core, se_id, &fap_port, &priority);
            if (rc == BCM_E_NONE) {
                if (DPP_COSQ_SCH_PORT_ID_INVALID(unit) != fap_port) {
                    (*is_reserved) = TRUE;
                }
            }
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.default_se.get(unit, core, &sw_state_default_se));
    if (se_id == sw_state_default_se) {
        (*is_reserved) = TRUE;
    }
    
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int 
_bcm_petra_cosq_is_conn_reserved(int unit, int conn_id, int *is_reserved)
{
    BCMDNX_INIT_FUNC_DEFS;

    (*is_reserved) = FALSE;

    if ( (conn_id >= DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START) &&
         (conn_id < (DPP_DEVICE_COSQ_QUEUE_RESERVED_FLOW_START +
                         DPP_DEVICE_COSQ_QUEUE_RESERVED_TOTAL_FLOWS)) ) {
        (*is_reserved) = TRUE;
    }

    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_is_queue_reserved(int unit, int queue_id, int *is_reserved)
{
    int                      rc = BCM_E_NONE;


    BCMDNX_INIT_FUNC_DEFS;

    (*is_reserved) = FALSE;

    /*         changes associatd with enhanced FMQ mode                               */
    /*         currently the following range is always reserved in allocation manager */
    /*         during init phase. This will change once enhanced mode is supported.   */
    if ( (queue_id >= DPP_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MIN) && (queue_id <= DPP_DEVICE_COSQ_FMQ_NON_ENHANCED_QID_MAX) ) {
        (*is_reserved) = TRUE;
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fmq_hr_deallocate(int unit, bcm_core_t core, int nbr_ports, uint32 *tm_ports)
{
    int index = 0;
    int rc = BCM_E_NONE;
    int flow_id;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id;
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    if (nbr_ports > DPP_DEVICE_FMQ_CLASS_PORTS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, number of ports %d, is out of range"), unit, nbr_ports));
    }

    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(unit,&sch_flow);
    SOC_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);

    for (index = 0; index < nbr_ports; index++) {
        /* retrieve corresponding SE element */
        rc = _bcm_petra_cosq_port2se_id(unit, core, tm_ports[index], DPP_COSQ_PB_DEFAULT_PORT_TC, &se_id);
        BCMDNX_IF_ERR_EXIT(rc);

        if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
            SOCDNX_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving seId for tm_port(%d)"),tm_ports[index]));
        }

        /* retrieve corresponding flow id */
        flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,((se_id))));
        if (flow_id == DPP_COSQ_SCH_FLOW_ID_INVALID(unit)) {
            SOCDNX_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving FlowId for seId(0x%x)"), se_id));
        }

        /* free HR resources */
        rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, core, BCM_DPP_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* configure scheduler element */
        soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

        se_info.state = SOC_TMC_SCH_SE_STATE_DISABLE;
        se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
        BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    }

    rc = _bcm_petra_cosq_fmq_hr_port_deallocate(unit, core, nbr_ports, tm_ports);
    BCMDNX_IF_ERR_EXIT(rc);

    for (index = 0; index < nbr_ports; index++) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.fmq_class_ports.set(unit, core, index, BCM_GPORT_INVALID));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_isq_hr_allocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    int rc = BCM_E_NONE;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id;
    int flow_id;
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;    
    bcm_gport_t sw_state_isq_port;
    
    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(unit,&sch_flow);
    SOC_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);

    rc = _bcm_petra_cosq_isq_hr_port_allocate(unit, core, tm_port);
    BCMDNX_IF_ERR_EXIT(rc);

    /* enable the HR scheduler elements */
    /* retrieve corresponding SE element */
    rc = _bcm_petra_cosq_port2se_id(unit, core, *tm_port, DPP_COSQ_PB_DEFAULT_PORT_TC,&(se_id));
    BCMDNX_IF_ERR_EXIT(rc);

    if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
        SOCDNX_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving seId for tm_port(%d)"), *tm_port));
    }

    /* retrieve corresponding flow id */
    flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,((se_id))));
    if (flow_id == DPP_COSQ_SCH_FLOW_ID_INVALID(unit)) {
        SOCDNX_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving FlowId for seId(0x%x)"), se_id));
    }

    /* reserve HR in allocation manager */
    rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, 1, BCM_DPP_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* configure scheduler element */
    soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    se_info.state = SOC_TMC_SCH_SE_STATE_ENABLE;
    se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    /* scheduler gport format */
    BCM_GPORT_SCHEDULER_CORE_SET(sw_state_isq_port, flow_id, core);
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.isq_port.set(unit, core, sw_state_isq_port));

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_isq_hr_deallocate(int unit, bcm_core_t core, uint32 *tm_port)
{
    int rc = BCM_E_NONE;
    int flow_id;
    uint32 soc_sand_rc;
    SOC_TMC_SCH_SE_ID se_id;
    SOC_TMC_SCH_SE_INFO se_info;
    SOC_TMC_SCH_FLOW  sch_flow, exact_sch_flow;
    
    BCMDNX_INIT_FUNC_DEFS;
    
    SOC_TMC_SCH_SE_INFO_clear(&se_info);
    SOC_TMC_SCH_FLOW_clear(unit,&sch_flow);
    SOC_TMC_SCH_FLOW_clear(unit,&exact_sch_flow);
    
    /* retrieve corresponding SE element */
    rc = _bcm_petra_cosq_port2se_id(unit, core, *tm_port, DPP_COSQ_PB_DEFAULT_PORT_TC, &se_id);
    BCMDNX_IF_ERR_EXIT(rc);

    if (se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
        SOCDNX_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving seId for tm_port(%d)"), *tm_port));
    }

    /* retrieve corresponding flow id */
    flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,((se_id))));
    if (flow_id == DPP_COSQ_SCH_FLOW_ID_INVALID(unit)) {
        SOCDNX_EXIT_WITH_ERR(BCM_E_INTERNAL, (_BSL_SOC_MSG("error in retreiving FlowId for seId(0x%x)"), se_id));
    }

    /* free HR resources */
    rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, core, BCM_DPP_AM_FLAG_ALLOC_WITH_ID, FALSE, FALSE, FALSE, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
    if (rc != BCM_E_NONE) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* configure scheduler element */
    soc_sand_rc =  (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_get,(unit, core, se_id, &se_info, &sch_flow)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    se_info.state = SOC_TMC_SCH_SE_STATE_DISABLE;
    se_info.type_info.hr.mode = SOC_TMC_SCH_HR_MODE_SINGLE_WFQ;
    
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_aggregate_set,(unit, core, se_id, &se_info, &sch_flow, &exact_sch_flow)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
    
    rc = _bcm_petra_cosq_isq_hr_port_deallocate(unit, core, tm_port);
    BCMDNX_IF_ERR_EXIT(rc);
    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.isq_port.set(unit, core, BCM_GPORT_INVALID));

exit:
    BCMDNX_FUNC_RETURN;
}


int
bcm_petra_cosq_fmq_vsq_category_mode_set(int unit, int core, bcm_fabric_vsq_category_mode_t vsq_category_mode)
{
    int                     core_index;
    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        if (vsq_category_mode < 0 || vsq_category_mode > bcmFabricVsqCatagoryMode2) {
            LOG_ERROR(BSL_LS_BCM_COSQ,(BSL_META_U(unit,"unit %d, error in setting vsq category mode %d\n"), unit, vsq_category_mode));
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("vsq_category_mode invalid")));
        }
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.ingress.vsq_category_mode.set(unit, core_index, vsq_category_mode));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_fmq_vsq_category_mode_get(int unit, int core, bcm_fabric_vsq_category_mode_t *vsq_category_mode)
{
    int rc = BCM_E_NONE;
    int                     core_index = (core == BCM_CORE_ALL || SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) ? 0 : core;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(vsq_category_mode);

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.ingress.vsq_category_mode.get(unit, core_index, vsq_category_mode));

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_set(int unit, 
                                       bcm_port_t port,
                                       int count,
                                       bcm_cos_t *priority, 
                                       bcm_cos_queue_t *cosq)
{
  int rc = BCM_E_NONE;
  int soc_sand_rc = SOC_SAND_OK;
  SOC_TMC_ITM_TC_MAPPING tc_mapping;
  int tc = 0, new_tc = 0, dest_ndx = 0, dest_base_queue = 0, is_allocated, is_last, new_mapping_profile;
  uint32 old_profile;
  int is_flow;
  int nof_quartet,quartet_index;
  SOC_TMC_IPQ_EXPLICIT_MAPPING_MODE_INFO mapping_mode_info;
  uint32 flow_mapping_queue_base_offset;
  int core_id = BCM_CORE_ALL, core = BCM_CORE_ALL;
  uint8 sw_state_num_cos;
  int i;
  int used_priority[DPP_COSQ_PACKET_NOF_TC] = {0};

  BCMDNX_INIT_FUNC_DEFS;
  SOC_TMC_ITM_TC_MAPPING_clear(&tc_mapping);

  if (!BCM_GPORT_IS_SYSTEM_PORT (port) && 
      !BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) && 
      !BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) && 
      !BCM_COSQ_GPORT_IS_ISQ(port)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
  }

  if (count <= 0 || count > DPP_COSQ_PACKET_NOF_TC) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid count parameter %d"), unit, count));
  }

  for (i = 0; i < count; i++)
  {
      tc = priority[i];
      if (tc < 0 || tc >= DPP_COSQ_PACKET_NOF_TC) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, tc));
      }
      if (used_priority[tc])
      {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Priority %d is mapped several times"), unit, tc));

      }
      used_priority[tc] = 1;

      if (cosq[i] < 0 || cosq[i] >= DPP_COSQ_PACKET_NOF_TC) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cosq parameter %d"), unit, cosq[i]));
      }
  }

  if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port))
  {
      dest_base_queue = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
      core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
      is_flow = 1;
  }
  else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(port)) 
  {
      dest_base_queue = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
      core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
      is_flow = 1;
     
  } 
  else if (BCM_COSQ_GPORT_IS_ISQ(port))
  {
      dest_base_queue = BCM_COSQ_GPORT_ISQ_QID_GET(port);
      core = BCM_COSQ_GPORT_ISQ_CORE_GET(port);
      is_flow = 1;
  }
  else if (BCM_GPORT_IS_SYSTEM_PORT(port)) 
  {
      dest_ndx = BCM_GPORT_SYSTEM_PORT_ID_GET(port);
      core = BCM_CORE_ALL; /* Currently the mapping is symmetric. Consider to get the core of the system port or should allways be symeric? */
      is_flow = 0;
  }
  else 
  {
      /* Protected by higher level function, but added just to be on the safe side */
      BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
  }
  if (core == BCM_CORE_ALL && !SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, API bcm_cosq_port_mapping_set() cannot configure both cores if device is if configured asymmetriclly."), unit));
  }
  if (core != BCM_CORE_ALL && SOC_DPP_CORE_MODE_IS_SYMMETRIC(unit) && !SOC_DPP_CORE_MODE_IS_SINGLE_CORE(unit)) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, API bcm_cosq_port_mapping_set() cannot configure one core if device is if configured symmetriclly."), unit));
  }

  SOC_DPP_ASSYMETRIC_CORES_ITER(core, core_id) {
      if(is_flow) {
        /*if dest_ndx is flow then find its num of quartets, else num of quartets is 1*/
        /*get VOQ configuration from dest_base_queue*/
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit ,core_id, dest_base_queue), &sw_state_num_cos));
        /*dest_ndx not configed*/
        if (sw_state_num_cos ==  0) {
            BCMDNX_IF_ERR_EXIT(BCM_E_RESOURCE);
        }
        nof_quartet = (sw_state_num_cos)/4;

        /*dest_ndx is the flow id before mapped into VOQ: dest_base_queue - (global offset)*/
        rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_explicit_mapping_mode_info_get,(unit, &mapping_mode_info)));
        BCMDNX_IF_ERR_EXIT(rc);

        /* The MBCM_DPP_DRIVER_CALL initializing the required varible */ 
        /* coverity[uninit_use:FALSE] */
        flow_mapping_queue_base_offset = (mapping_mode_info.queue_id_add_not_decrement) ? mapping_mode_info.base_queue_id : 0;
        dest_ndx = dest_base_queue - flow_mapping_queue_base_offset;

        /* Get old data */
        rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
        BCMDNX_IF_ERR_EXIT(rc);

        /* Set data configuration */
        for (i = 0; i < count; i++)
        {
            tc = priority[i];
            new_tc = cosq[i];
            tc_mapping.new_tc[tc] = new_tc;
        }
        /* Exchange SW Data */
        rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_exchange(unit, core_id, dest_ndx, &tc_mapping, &old_profile, &is_last, &new_mapping_profile, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);   
      } else {
          /*if dest_ndx is flow then find its num of quartets, else num of quartets is 1*/
          nof_quartet = 1;
          
          /* Get old data */
          rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
          BCMDNX_IF_ERR_EXIT(rc);

          /* Set data configuration */
          for (i = 0; i < count; i++)
          {
              tc = priority[i];
              new_tc = cosq[i];
              tc_mapping.new_tc[tc] = new_tc;
          }

          /* Exchange SW Data */
          rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_exchange(unit, core_id, dest_ndx, &tc_mapping, &old_profile, &is_last, &new_mapping_profile, &is_allocated);
          BCMDNX_IF_ERR_EXIT(rc);
      }

      if (is_allocated) {
          /* Set new profile data */
          rc = _bcm_petra_cosq_ingress_tc_mapping_hw_set(unit, core, new_mapping_profile, is_flow, &tc_mapping);
          BCMDNX_IF_ERR_EXIT(rc);
      }

      /*for each quartet(dest_ndx + (quartet_index * 4)) configure its profile using new_mapping_profile*/
      for (quartet_index = 0; quartet_index < nof_quartet; quartet_index++) {
          /* Set new mapping */
          soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_tc_profile_set,(unit, core, is_flow, dest_ndx + (quartet_index * 4), new_mapping_profile)));
          BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
      }
  }
  BCMDNX_IF_ERR_EXIT(rc);

exit:
  BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_petra_cosq_ingress_tc_mapping_hw_set(int unit,
                                                     int core_id,
                                                     int profile,
                                                     int is_flow,
                                                     SOC_TMC_ITM_TC_MAPPING *tc_mapping)
{
  int rc = BCM_E_NONE;
  int soc_sand_rc = SOC_SAND_OK;
  int i;

  BCMDNX_INIT_FUNC_DEFS;
  for(i=0; i < SOC_TMC_NOF_TRAFFIC_CLASSES ; i++)
  {
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_tc_profile_map_set,(unit, core_id, profile, is_flow, i, tc_mapping->new_tc[i])));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);                   
  }

  BCMDNX_IF_ERR_EXIT(rc);
exit:
  BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_ingress_tc_mapping_get(int unit, 
                                       bcm_port_t port,
                                       int count,
                                       bcm_cos_t *priority, 
                                       bcm_cos_queue_t *cosq)
{
  int rc = BCM_E_NONE;
  SOC_TMC_ITM_TC_MAPPING tc_mapping;
  int dest_ndx=0;
  int is_flow;
  int core_id;
  int i;
  int tc;

  BCMDNX_INIT_FUNC_DEFS;
  SOC_TMC_ITM_TC_MAPPING_clear(&tc_mapping);


  if (!BCM_GPORT_IS_SYSTEM_PORT (port) && 
      !BCM_GPORT_IS_UCAST_QUEUE_GROUP(port) && 
      !BCM_GPORT_IS_MCAST_QUEUE_GROUP(port) && 
      !BCM_COSQ_GPORT_IS_ISQ(port)) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport parameter 0x%08x"), unit, port));
  }

  if (count < 0 || count > DPP_COSQ_PACKET_NOF_TC) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid count parameter %d"), unit, count));
  }

  for (i = 0; i < count; i++)
  {
      if (priority[i] < 0 || priority[i] >= DPP_COSQ_PACKET_NOF_TC) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid priority parameter %d"), unit, priority[i]));
      }
  }

  if(BCM_GPORT_IS_UCAST_QUEUE_GROUP(port))
  {
      dest_ndx = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(port);
      core_id = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(port);
      is_flow = 1;
  }
  else if(BCM_GPORT_IS_MCAST_QUEUE_GROUP(port))
  {
      dest_ndx = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(port);
      core_id = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(port);
      is_flow = 1;
  }
  else if (BCM_COSQ_GPORT_IS_ISQ(port))
  {
      dest_ndx = BCM_COSQ_GPORT_ISQ_QID_GET(port);
      core_id = BCM_COSQ_GPORT_ISQ_CORE_GET(port);
      is_flow = 1;
  }
  else if (BCM_GPORT_IS_SYSTEM_PORT(port)) 
  {
      dest_ndx = BCM_GPORT_SYSTEM_PORT_ID_GET(port);
      core_id = BCM_CORE_ALL; /* Consider to get the core of the system port or should allways be symeric?*/
      is_flow = 0;
  }
  else 
  {
      /* Protected by higher level function, but added just to be on the safe side */
      return BCM_E_PARAM;
  }

  if(is_flow)
  {
      /* Get old data */
      rc = _bcm_dpp_am_template_ingress_flow_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
      BCMDNX_IF_ERR_EXIT(rc);
  }
  else
  {
      /* Get old data */
      rc = _bcm_dpp_am_template_ingress_uc_tc_mapping_data_get(unit, core_id, dest_ndx ,&tc_mapping);
      BCMDNX_IF_ERR_EXIT(rc);
  }

  if(cosq != NULL)
  {
      for (i = 0; i < count; i++)
      {
          tc = priority[i];
          cosq[i] = tc_mapping.new_tc[tc];
      }
  }

  BCMDNX_IF_ERR_EXIT(rc);

exit:
  BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_set(int unit, int priority, int generic_bm_id, SOC_TMC_FC_PFC_GENERIC_BITMAP *bitmap)
{
    int rc = BCM_E_NONE;
    int soc_sand_rc = SOC_SAND_OK;

    BCMDNX_INIT_FUNC_DEFS;

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_set,(unit, priority, generic_bm_id, bitmap)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_petra_cosq_fc_pfc_generic_bitmap_mapping_hw_get(int unit, int priority, int generic_bm_id, SOC_TMC_FC_PFC_GENERIC_BITMAP *bitmap)
{
    int rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_fc_pfc_generic_bitmap_get,(unit, priority, generic_bm_id, bitmap)));
    BCM_SAND_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_petra_cosq_stk_sysport_set(int unit, int core, bcm_gport_t sysport_gport, int *stk_exist)
{
    int 
        rv = BCM_E_NONE,
        soc_sand_rc = SOC_SAND_OK,
        local_modid;
    uint32
        sysport_modid,
        is_same_domain = 0x0,
        dest_base_queue = 0x0;
    bcm_gport_t
        sysport,
        modport_gport;
    int 
        sysport_domain;
    uint8 
        is_sw_only = FALSE; /*We want to write to HW.*/

    BCMDNX_INIT_FUNC_DEFS;
 
    BCM_DPP_UNIT_CHECK(unit);
    if (stk_exist == NULL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("NULL argument")));
    }

    *stk_exist = 0x0;

    /* Get local modid*/ 
    rv = bcm_petra_stk_my_modid_get(unit, &local_modid);
    if (rv) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "local modid invalid bcm_petra_stk_my_modid_get() rv=%s\n"), bcm_errmsg(rv)));
        BCMDNX_IF_ERR_EXIT(rv);
    }

    /* Get mod/fap id from sysyport */ 
    rv = bcm_petra_stk_sysport_gport_get(unit, sysport_gport, &modport_gport);
    BCMDNX_IF_ERR_EXIT(rv);
    sysport_modid = BCM_GPORT_MODPORT_MODID_GET(modport_gport);

    /* check if modid in other TM doamin */
     rv = bcm_petra_stk_modid_to_domain_find(unit, local_modid, sysport_modid, &is_same_domain);
     BCM_SAND_IF_ERR_EXIT(rv);

     if (is_same_domain == 0x0) {

         /* Get sysport TM-domain */
         rv = bcm_petra_stk_domain_modid_get(unit, sysport_modid, &sysport_domain);
         BCM_SAND_IF_ERR_EXIT(rv);

         /* Set dest_base_queue  Jericho/Arad  is { 16:6 all ones, 5:0 tmd}
                                                      QAX  is { 14:6 all ones, 5:0 tmd}
                                                      QUX  is { 13:6 all ones, 5:0 tmd}  */
         dest_base_queue = ((uint32)sysport_domain) | ARAD_IPQ_DESTINATION_ID_STACKING_BASE_QUEUE_MIN;

         /* connect VOQ to sysport */
         sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);
         soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_ipq_destination_id_packets_base_queue_id_set,(unit, core, sysport, TRUE /* queue is valid */,is_sw_only ,dest_base_queue)));
         rv = handle_sand_result(soc_sand_rc); /* set sysport to base queue mapping */
         if (rv != BCM_E_NONE) {
             LOG_ERROR(BSL_LS_BCM_COSQ,
                       (BSL_META_U(unit,
                                   "soc_petra_ipq_destination_id_packets_base_queue_id_set() failed \"base queue(%d) sysport(%d)\n"), dest_base_queue, sysport));
         }

         *stk_exist = 0x1;
     }            

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Map from a bcm_cosq_gport_stats_t to a bcm_dpp_counter_t.
 *  if the use_color is true it means that the dp is part of the counter_id
 */
STATIC int
_bcm_dpp_cosq_gport_stat_map(bcm_cosq_gport_stats_t bcmstat,
                             unsigned int use_color, /* If True, the color of stat was used */
                             bcm_dpp_counter_t *ctrstat)
{
    uint8 is_offset_base_stat = TRUE;
    switch(bcmstat){
    case bcmCosqGportOffset0Packets:
        *ctrstat = bcm_dpp_counter_offset0_pkts;
        break;
    case bcmCosqGportOffset0Bytes:
        *ctrstat = bcm_dpp_counter_offset0_bytes;
        break;
    case bcmCosqGportOffset1Packets:
        *ctrstat = bcm_dpp_counter_offset1_pkts;
        break;
    case bcmCosqGportOffset1Bytes:
        *ctrstat = bcm_dpp_counter_offset1_bytes;
        break;
    case bcmCosqGportOffset2Packets:
        *ctrstat = bcm_dpp_counter_offset2_pkts;
        break;
    case bcmCosqGportOffset2Bytes:
        *ctrstat = bcm_dpp_counter_offset2_bytes;
        break;
    case bcmCosqGportOffset3Packets:
        *ctrstat = bcm_dpp_counter_offset3_pkts;
        break;
    case bcmCosqGportOffset3Bytes:
        *ctrstat = bcm_dpp_counter_offset3_bytes;
        break;
    case bcmCosqGportOffset4Packets:
        *ctrstat = bcm_dpp_counter_offset4_pkts;
        break;
    case bcmCosqGportOffset4Bytes:
        *ctrstat = bcm_dpp_counter_offset4_bytes;
        break;
    case bcmCosqGportOffset5Packets:
        *ctrstat = bcm_dpp_counter_offset5_pkts;
        break;
    case bcmCosqGportOffset5Bytes:
        *ctrstat = bcm_dpp_counter_offset5_bytes;
        break;
    case bcmCosqGportOffset6Packets:
        *ctrstat = bcm_dpp_counter_offset6_pkts;
        break;
    case bcmCosqGportOffset6Bytes:
        *ctrstat = bcm_dpp_counter_offset6_bytes;
        break;
    case bcmCosqGportOffset7Packets:
        *ctrstat = bcm_dpp_counter_offset7_pkts;
        break;
    case bcmCosqGportOffset7Bytes:
        *ctrstat = bcm_dpp_counter_offset7_bytes;
        break;
    default:
        is_offset_base_stat = FALSE;
    }
    if(is_offset_base_stat){
        return BCM_E_NONE;
    }
    if (use_color == 0) {
        switch (bcmstat) {
        case bcmCosqGportGreenAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_green_pkts;
            break;
        case bcmCosqGportGreenAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_green_bytes;
            break;
        case bcmCosqGportNotGreenAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_not_green_pkts;
            break;
        case bcmCosqGportNotGreenAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_not_green_bytes;
            break;
        case bcmCosqGportGreenDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_green_pkts;
            break;
        case bcmCosqGportGreenDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_green_bytes;
            break;
        case bcmCosqGportNotGreenDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_not_green_pkts;
            break;
        case bcmCosqGportNotGreenDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_not_green_bytes;
            break;
        case bcmCosqGportYellowAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_yellow_pkts;
            break;
        case bcmCosqGportYellowAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_yellow_bytes;
            break;
        case bcmCosqGportYellowDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_yellow_pkts;
            break;
        case bcmCosqGportYellowDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_yellow_bytes;
            break;
        case bcmCosqGportRedAcceptedPkts:
            *ctrstat = bcm_dpp_counter_fwd_red_pkts;
            break;
        case bcmCosqGportRedAcceptedBytes:
            *ctrstat = bcm_dpp_counter_fwd_red_bytes;
            break;
        case bcmCosqGportRedDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_red_pkts;
            break;
        case bcmCosqGportRedDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_red_bytes;
            break;
        case bcmCosqGportGreenPkts:
            *ctrstat = bcm_dpp_counter_green_pkts;
            break;
        case bcmCosqGportGreenBytes:
            *ctrstat = bcm_dpp_counter_green_bytes;
            break;
        case bcmCosqGportNotGreenPkts:
            *ctrstat = bcm_dpp_counter_not_green_pkts;
            break;
        case bcmCosqGportNotGreenBytes:
            *ctrstat = bcm_dpp_counter_not_green_bytes;
            break;
        case bcmCosqGportDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_bytes;
            break;
        case bcmCosqGportDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_pkts;
            break;
        case bcmCosqGportEnqueuedBytes:
            *ctrstat = bcm_dpp_counter_fwd_bytes;
            break;
        case bcmCosqGportReceivedBytes:
            *ctrstat = bcm_dpp_counter_bytes;
            break;
        case bcmCosqGportEnqueuedPkts:
            *ctrstat = bcm_dpp_counter_fwd_pkts;
            break;
        case bcmCosqGportReceivedPkts:
            *ctrstat = bcm_dpp_counter_pkts;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META("unable to map GPORT stat %d; not supported\n"), bcmstat));
            return BCM_E_UNAVAIL;
        }
    }
    else /* use_color == 1 */ {
        switch (bcmstat) {
        case bcmCosqGportGreenAcceptedPkts:
        case bcmCosqGportNotGreenAcceptedPkts:
        case bcmCosqGportYellowAcceptedPkts:
        case bcmCosqGportRedAcceptedPkts:
        case bcmCosqGportEnqueuedPkts:
            *ctrstat = bcm_dpp_counter_fwd_pkts;
            break;
        case bcmCosqGportGreenAcceptedBytes:
        case bcmCosqGportNotGreenAcceptedBytes:
        case bcmCosqGportYellowAcceptedBytes:
        case bcmCosqGportRedAcceptedBytes:
        case bcmCosqGportEnqueuedBytes:
            *ctrstat = bcm_dpp_counter_fwd_bytes;
            break;
        case bcmCosqGportGreenDroppedPkts:
        case bcmCosqGportNotGreenDroppedPkts:
        case bcmCosqGportYellowDroppedPkts:
        case bcmCosqGportRedDroppedPkts:
        case bcmCosqGportDroppedPkts:
            *ctrstat = bcm_dpp_counter_drop_pkts;
            break;
        case bcmCosqGportGreenDroppedBytes:
        case bcmCosqGportNotGreenDroppedBytes:
        case bcmCosqGportYellowDroppedBytes:
        case bcmCosqGportRedDroppedBytes:
        case bcmCosqGportDroppedBytes:
            *ctrstat = bcm_dpp_counter_drop_bytes;
            break;
        case bcmCosqGportNotGreenPkts:
        case bcmCosqGportGreenPkts:
        case bcmCosqGportReceivedPkts:
            *ctrstat = bcm_dpp_counter_pkts;
            break;
        case bcmCosqGportNotGreenBytes:
        case bcmCosqGportGreenBytes:
        case bcmCosqGportReceivedBytes:
            *ctrstat = bcm_dpp_counter_bytes;
            break;
        default:
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META("unable to map GPORT stat %d; not supported\n"),
bcmstat));
            return BCM_E_UNAVAIL;
        }
    }
    return BCM_E_NONE;
}


/*
 *  Figure out the counter processor and counter set ID (and number of sets) to
 *  read according to the requested GPORT and offset.  If the value at
 *  numCosLevels is -1, this will fill in the proper values for the GPORT; if
 *  it is any other value, it assumes the value was already filled in.
 */
STATIC int
_bcm_dpp_cosq_gport_to_counter_proc_and_set(int unit,
                                            bcm_gport_t gport,
                                            int offset,
                                            int maxCtrSet,
                                            bcm_dpp_counter_t ctrStat,
                                            unsigned int *use_color, /* If True, the color of stat was used */
                                            bcm_dpp_counter_proc_and_set_t *proc_and_set,
                                            uint32 *numCosLevels,
                                            unsigned int *numCtrSet)
{

    int result = BCM_E_NONE;
    unsigned int voq = ~0;
    int core;
    bcm_gport_t physPort;
    uint32 flags;
   
    bcm_port_t   user_port;
    uint32       tm_port  = 0;
    uint32       pp_port  = 0;
    int          is_mc = 0;
    unsigned int use_color_get = 0;
    unsigned int nof_counter_sets = 0;
    int nof_found = 0;
    BCMDNX_INIT_FUNC_DEFS;
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
        if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) {
            voq = BCM_COSQ_GPORT_IS_ISQ(gport)? 
                BCM_COSQ_GPORT_ISQ_QID_GET(gport) : BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);           

            core = BCM_COSQ_GPORT_IS_ISQ(gport)? 
                BCM_COSQ_GPORT_ISQ_CORE_GET(gport) : BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);

            if ((-1) == (*numCosLevels)) {
                result = _bcm_petra_cosq_ucast_gport_get(unit, gport, &physPort, numCosLevels, &flags);
                BCMDNX_IF_ERR_EXIT(result);
            }
        } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)) {
            voq = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
            core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
            if ((-1) == (*numCosLevels)) {
                result = _bcm_petra_cosq_mcast_gport_get(unit, gport, &physPort, numCosLevels, &flags);
                BCMDNX_IF_ERR_EXIT(result);
            }
        } 

        result = bcm_dpp_counter_find_voq(unit, core, voq + offset, proc_and_set, ctrStat, &nof_found, NULL, NULL);
        BCMDNX_IF_ERR_EXIT(result);
        if (numCtrSet) {
            *numCtrSet = nof_found;
        }
    } else if ( BCM_COSQ_GPORT_IS_UCAST_EGRESS_QUEUE(gport) || BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport) ) {

        /* retrieve port */
        result = bcm_petra_cosq_user_port_get(unit, gport, &user_port);
        BCMDNX_IF_ERR_EXIT(result);
        /* For egress TM counter there are 8 traffic classes, not matter what the EGQ's priority level is */
        *numCosLevels = DPP_DEVICE_COSQ_EGR_NOF_TC;

        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_tm_port_get, (unit, user_port, &tm_port, &core)));
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_local_to_pp_port_get, (unit, user_port, &pp_port, &core)));

        is_mc = ((BCM_COSQ_GPORT_IS_MCAST_EGRESS_QUEUE(gport)) ? 1 : 0);
        nof_counter_sets = 0;
        result = bcm_dpp_counter_find_egress_que(unit,
                         maxCtrSet,
                         offset,
                         core,
                         tm_port, 
                         is_mc,
                         pp_port,
                         ctrStat,
                         &use_color_get,
                         proc_and_set,
                         &nof_counter_sets);
        if (numCtrSet) {
            *numCtrSet = nof_counter_sets;
        }
        BCMDNX_IF_ERR_EXIT(result);
    } else {
        LOG_ERROR(BSL_LS_BCM_COSQ, (BSL_META_U(unit, "COSQ stats not supported for unit %d GPORT %08X\n"), unit, gport));
        BCMDNX_IF_ERR_EXIT(BCM_E_PARAM);
    }

    if (use_color != NULL) {
        *use_color = use_color_get;
    }
exit:
    BCMDNX_FUNC_RETURN;

}

/*
 *  Get a statistic for a GPORT (and a specific offset within that GPORT)
 */
int
bcm_petra_cosq_gport_stat_get(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              bcm_cosq_gport_stats_t stat,
                              uint64 *value)
{
    bcm_dpp_counter_proc_and_set_t proc_and_set[DPP_COSQ_COUNTERS_MAX_SETS];

    bcm_dpp_counter_t ctrStat;
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    uint64 v, total_v;
    unsigned int i, numCtrSet;
    unsigned int use_color;
    uint8 cached;

    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(proc_and_set, 0, sizeof(bcm_dpp_counter_proc_and_set_t) * DPP_COSQ_COUNTERS_MAX_SETS);

    /*convert to internal type*/
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, 0, &ctrStat));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                                gport,                                                               
                                                                cosq,
                                                                DPP_COSQ_COUNTERS_MAX_SETS,
                                                                ctrStat,
                                                                &use_color,
                                                                proc_and_set,
                                                                &numCosLevels,
                                                                &numCtrSet));

    /*convert the type (important just for case of egress que counting)*/

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, use_color, &ctrStat));
    BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_cache_only_get(unit, &cached));
    COMPILER_64_ZERO(total_v);
    for (i = 0; i < numCtrSet ;i++) {
        if (cached) {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_get_cached(unit, proc_and_set[i].ctr_proc_id, proc_and_set[i].ctr_set_id, ctrStat, &v)); 
            COMPILER_64_ADD_64(total_v, v);
        } else {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_get(unit, proc_and_set[i].ctr_proc_id, proc_and_set[i].ctr_set_id, ctrStat, &v)); 
            COMPILER_64_ADD_64(total_v, v);
        }
    }
    *value = total_v;
exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * read many stats by one call. We don't update the counters with direct read in this API 
*/
int
bcm_petra_cosq_gport_statistic_multi_get(int unit,
                                   bcm_gport_t gport,
                                   bcm_gport_t lgl_gport,
                                   bcm_cos_queue_t cosq,
                                   int stat_count,
                                   bcm_cosq_gport_stats_t *stats_array,
                                   int value_count,
                                   uint64 *value_array)
{
    bcm_dpp_counter_t ctrStat[DPP_COSQ_COUNTERS_MAX_STATS];
    bcm_dpp_counter_proc_and_set_t proc_and_set[SOC_DPP_DEFS_MAX(NOF_CORES)];
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    unsigned int i, numCtrSet;
    unsigned int stat_index;
    uint8 cached;
    uint64 *value_sum_array = NULL;
    int stat_count_index;
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_NULL_CHECK(stats_array);
    BCMDNX_NULL_CHECK(value_array);

    if(stat_count != value_count){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("stat_count must be equal to value_count")));
    }
    if (stat_count > DPP_COSQ_COUNTERS_MAX_STATS){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("stat_count must be lower than %d"), DPP_COSQ_COUNTERS_MAX_STATS));
    }
    /* not a voq gport*/
    if(!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(lgl_gport) || BCM_COSQ_GPORT_IS_ISQ(lgl_gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(lgl_gport))){
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("COSQ statistic multi get support just for voq GPORT types and not %x\n"), lgl_gport));
    }
    BCMDNX_ALLOC(value_sum_array, sizeof(uint64) * value_count, "value sum array");

    for ( stat_index = 0 ; stat_index < stat_count ; stat_index++){
        /*convert to internal type*/
        BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stats_array[stat_index], 0, &ctrStat[stat_index]));
    }
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                                lgl_gport,                                                               
                                                                cosq,
                                                                DPP_COSQ_COUNTERS_MAX_SETS,
                                                                ctrStat[0],
                                                                NULL,
                                                                proc_and_set,
                                                                &numCosLevels,
                                                                &numCtrSet));
    BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_cache_only_get(unit, &cached));
    for (stat_count_index = 0; stat_count_index < stat_count; stat_count_index++) {
        COMPILER_64_ZERO(value_array[stat_count_index]);
    }
    for (i = 0; i < numCtrSet; ++i) {
        if (cached) {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_multi_get_cached(unit, proc_and_set[i].ctr_proc_id, proc_and_set[i].ctr_set_id, stat_count, ctrStat, value_sum_array)); 
        } else {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_multi_get(unit, proc_and_set[i].ctr_proc_id, proc_and_set[i].ctr_set_id, stat_count, ctrStat, value_sum_array)); 
        }
        for (stat_count_index = 0; stat_count_index < stat_count; stat_count_index++) {
            COMPILER_64_ADD_64(value_array[stat_count_index], value_sum_array[stat_count_index]);
        }
    }
exit:
    if (value_sum_array) {
        BCM_FREE(value_sum_array);
    }
    BCMDNX_FUNC_RETURN; 
}

/*
 *  Set a statistic for a GPORT (and a specific offset within that GPORT)
 */
int
bcm_petra_cosq_gport_stat_set(int unit,
                              bcm_gport_t gport,
                              bcm_cos_queue_t cosq,
                              bcm_cosq_gport_stats_t stat,
                              uint64 value)
{
    bcm_dpp_counter_t ctrStat;
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    unsigned int numCtrSet, i;
    unsigned int use_color;
    bcm_dpp_counter_proc_and_set_t proc_and_set[DPP_COSQ_COUNTERS_MAX_SETS];
    uint8 cached;
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(proc_and_set, 0, sizeof(bcm_dpp_counter_proc_and_set_t) * DPP_COSQ_COUNTERS_MAX_SETS);

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, 0, &ctrStat));

    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                                gport,                                                               
                                                                cosq,
                                                                DPP_COSQ_COUNTERS_MAX_SETS,
                                                                ctrStat,
                                                                &use_color,
                                                                proc_and_set,
                                                                &numCosLevels,
                                                                &numCtrSet));
    BCMDNX_IF_ERR_EXIT(_bcm_dpp_cosq_gport_stat_map(stat, use_color, &ctrStat));
    BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_cache_only_get(unit, &cached));
    for (i=0; i<numCtrSet; i++) {
        if (cached) {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_set_cached(unit, proc_and_set[i].ctr_proc_id, proc_and_set[i].ctr_set_id, ctrStat, value));
        } else {
            BCMDNX_IF_ERR_EXIT(bcm_dpp_counter_set(unit, proc_and_set[i].ctr_proc_id, proc_and_set[i].ctr_set_id, ctrStat, value));
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Enable/disable statistics for a GPORT
 *
 *  On PetraB/Arad, the stats are actually enabled by the counter processor
 *  configuration, so this returns an error if the caller tries to set it the
 *  other way, and success if the caller tries to set it as configured. *
 */
int
bcm_petra_cosq_gport_stat_enable_set(int unit,
                                     bcm_gport_t gport,
                                     int enable)
{
    bcm_error_t rc = BCM_E_UNAVAIL;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rc);        
exit:
    BCMDNX_FUNC_RETURN;

}

/*
 *  Get statistics state for a GPORT
 *
 *  On PetraB/Arad, the stats are actually enabled by the counter processor
 *  configuration, so this merely returns TRUE or FALSE according to whether
 *  the particular GPORT is covered by at least one of the counter processors.
 */
int
bcm_petra_cosq_gport_stat_enable_get(int unit,
                                     bcm_gport_t gport,
                                     int *enable)
{
    int result;
    uint32 numCosLevels = 0xFFFFFFFF; /* get and check CoS levels */
    unsigned int use_color, numCtrSet;
    bcm_dpp_counter_proc_and_set_t proc_and_set[DPP_COSQ_COUNTERS_MAX_SETS];
    BCMDNX_INIT_FUNC_DEFS;
    sal_memset(proc_and_set, 0, sizeof(bcm_dpp_counter_proc_and_set_t) * DPP_COSQ_COUNTERS_MAX_SETS);

    result = _bcm_dpp_cosq_gport_to_counter_proc_and_set(unit,
                                                         gport,
                                                         0 /* offset */,
                                                         SOC_DPP_DEFS_MAX(NOF_CORES),
                                                         bcm_dpp_counter_count,
                                                         &use_color,
                                                         proc_and_set,
                                                         &numCosLevels,
                                                         &numCtrSet);
    *enable = (BCM_E_NONE == result);
    BCMDNX_FUNC_RETURN;
}


STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int mode,
                                                       int weight)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_clos_sched_set")));
    }

    if (mode != BCM_COSQ_WEIGHTED_FAIR_QUEUING) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: mode: %d\n"), mode)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to BCM_COSQ_WEIGHTED_FAIR_QUEUING")));
    }

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_sched_set, (unit, gport, weight)));

exit:    
    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight)
{

    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_clos_sched_get")));
    }
         
    *mode = BCM_COSQ_WEIGHTED_FAIR_QUEUING;
    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_sched_get, (unit, gport, weight)));
        
exit:    
    BCMDNX_FUNC_RETURN;   
}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg)
{
    SOC_TMC_ING_SCH_CLOS_INFO clos_info;
    int                       core;
    BCMDNX_INIT_FUNC_DEFS;

    /*
     * For ingress scheduler, user may either configure both cores the same way or
     * each core on its own.
     * In the former case, user
     *   (a) 'sets' using 'BCM_CORE_ALL' (and software configures both cores the same way)
     *   (b) 'gets' using 'BCM_CORE_ALL' (and software queries only port '0')
     * This explains the few following lines.
     * In the latter case, using BCM_CORE_ALL for 'get' operation is an error.
     */
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);
    if (core == BCM_CORE_ALL) 
    {
        core = 0;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_slow_start_get, (unit, core, &clos_info)));
    switch(type) {
        case bcmCosqControlFlowSlowRate:
            /*Enable/Disable slow start mechanism for multicast queues*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_enable;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_enable;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
            break;
        case bcmCosqControlFlowSlowRate1:
            /*Get first rate of slow start mechanism*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_0;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_0;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        case bcmCosqControlFlowSlowRate2:
            /*Get first rate of slow start mechanism*/
            if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                *arg = clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_1;
            } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                *arg = clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_1;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
             break;
     }

exit:    
    BCMDNX_FUNC_RETURN;  

}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_clos_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg)
{
    SOC_TMC_ING_SCH_CLOS_INFO clos_info;
    int                       core, index;
    BCMDNX_INIT_FUNC_DEFS;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);

    BCM_DPP_CORES_ITER(core, index)
    {
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_slow_start_get, (unit, index, &clos_info)));

        /*setting all shaper fields to don't touch (0xffffffff)*/
        SOC_TMC_ING_SCH_CLOS_INFO_SHAPERS_dont_touch(&clos_info);

        switch(type) {
            case bcmCosqControlFlowSlowRate:
                /*Enable/Disable slow start mechanism for multicast queues*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_enable = arg ? 1 : 0;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_enable = arg ? 1 : 0;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                break;
            case bcmCosqControlFlowSlowRate1:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                /*Configure first rate of slow start mechanism*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_0 = arg;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_0 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            case bcmCosqControlFlowSlowRate2:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                /*Configure first rate of slow start mechanism*/
                if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_GUARANTEED(port)) {
                    clos_info.shapers.hp.fabric_multicast.slow_start_rate_phase_1 = arg;
                } else if (BCM_GPORT_IS_FABRIC_CLOS_FMQ_BESTEFFORT(port)) {
                    clos_info.shapers.lp.fabric_multicast.slow_start_rate_phase_1 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
                 break;
         }

         BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_slow_start_set, (unit, index, &clos_info)));

    }
exit:    
    BCMDNX_FUNC_RETURN;  

}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_get(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int *arg)
{
    SOC_TMC_ING_SCH_SHAPER   shaper_info;
    int                      core;
    BCMDNX_INIT_FUNC_DEFS;

    /*
     * For ingress scheduler, user may either configure both cores the same way or
     * each core on its own.
     * In the former case, user
     *   (a) 'sets' using 'BCM_CORE_ALL' (and software configures both cores the same way)
     *   (b) 'gets' using 'BCM_CORE_ALL' (and software queries only port '0')
     * This explains the few following lines.
     * In the latter case, using BCM_CORE_ALL for 'get' operation is an error.
     */
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);
    if (core == BCM_CORE_ALL) 
    {
        core = 0;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_slow_start_get, (unit, core, &shaper_info)));
    switch(type) {
        case bcmCosqControlFlowSlowRate:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_enable;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
            break;
        case bcmCosqControlFlowSlowRate1:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_rate_phase_0;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        case bcmCosqControlFlowSlowRate2:
            if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                *arg = shaper_info.slow_start_rate_phase_1;
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
            }
             break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
             break;
     }

exit:    
    BCMDNX_FUNC_RETURN;  
}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_slow_start_set(int unit,
                                                         bcm_gport_t port,
                                                         bcm_cos_queue_t cosq,
                                                         bcm_cosq_control_t type,
                                                         int arg)
{
    SOC_TMC_ING_SCH_SHAPER    shaper_info;
    int                       core, index;
    BCMDNX_INIT_FUNC_DEFS;
    core = BCM_GPORT_SCHEDULER_CORE_GET(port);

    BCM_DPP_CORES_ITER(core, index)
    {
        /*setting slow start shaper fields to don't touch (0xffffffff)*/
        shaper_info.slow_start_enable = SOC_TMC_ING_SCH_DONT_TOUCH;
        shaper_info.slow_start_rate_phase_0 = SOC_TMC_ING_SCH_DONT_TOUCH;
        shaper_info.slow_start_rate_phase_1 = SOC_TMC_ING_SCH_DONT_TOUCH;        

        switch(type) {
            case bcmCosqControlFlowSlowRate:
                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_enable = arg ? 1 : 0;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                break;
            case bcmCosqControlFlowSlowRate1:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_rate_phase_0 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            case bcmCosqControlFlowSlowRate2:
                if (arg < 0 || arg > 100) /*arg represents precent*/
                {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Expected value [0-100] , instead got %d\n"), arg)); 
                }

                if (BCM_GPORT_IS_FABRIC_MESH_MC(port)) {
                    shaper_info.slow_start_rate_phase_1 = arg;
                } else {
                    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type %d ,  for gport %u\n"), type, port)); 
                }
                 break;
            default:
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported control type, %d\n"), type)); 
                break;
         }

         BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_slow_start_set, (unit, index, &shaper_info)));

    }
exit:    
    BCMDNX_FUNC_RETURN;  
}

STATIC int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int mode,
                                                       int weight)
{
BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_mesh_sched_set")));
    }


    if (mode != BCM_COSQ_WEIGHTED_FAIR_QUEUING) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: mode: %d\n"), mode)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to BCM_COSQ_WEIGHTED_FAIR_QUEUING")));
    }
  
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_sched_set, (unit, gport, weight)));
      
exit:    
    BCMDNX_FUNC_RETURN;   
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_sched_get(int unit,
                                                       bcm_gport_t gport,
                                                       int *mode, 
                                                       int *weight)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_mesh_sched_get")));
    }

    *mode = BCM_COSQ_WEIGHTED_FAIR_QUEUING;
    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_sched_get, (unit, gport, weight)));
  
exit:    
    BCMDNX_FUNC_RETURN;   
}

int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_get(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 *kbits_sec_min, 
                                                           uint32 *kbits_sec_max, 
                                                           uint32 *flags)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_clos_bandwidth_get")));
    }

    *kbits_sec_min = 0;
    *flags = 0;

    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_bandwidth_get, (unit, gport, kbits_sec_max)));
        
exit:    
    BCMDNX_FUNC_RETURN;
}


int
_bcm_petra_cosq_gport_ingress_scheduler_clos_bandwidth_set(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 kbits_sec_min, 
                                                           uint32 kbits_sec_max, 
                                                           uint32 flags)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_clos_bandwidth_set")));
    }

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    if (flags != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: flags: %d\n"), flags)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to 0")));
    }
    
    if (kbits_sec_max == 1) {
        kbits_sec_max = 2;
    }  

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_bandwidth_set, (unit, gport, kbits_sec_max)));
      
exit:    
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_get(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 *kbits_sec_min, 
                                                           uint32 *kbits_sec_max, 
                                                           uint32 *flags)
{
    BCMDNX_INIT_FUNC_DEFS;
      
    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_mesh_bandwidth_get")));
    }
    *kbits_sec_min = 0;
    *flags = 0;
     
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_bandwidth_get, (unit, gport, kbits_sec_max))); 

exit:    
    BCMDNX_FUNC_RETURN;
}

int
_bcm_petra_cosq_gport_ingress_scheduler_mesh_bandwidth_set(int unit, 
                                                           bcm_gport_t gport, 
                                                           uint32 kbits_sec_min, 
                                                           uint32 kbits_sec_max, 
                                                           uint32 flags)
{
    BCMDNX_INIT_FUNC_DEFS;
    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("QAX devices doesnt support api bcm_cosq_gport_ingress_scheduler_mesh_bandwidth_set")));
    }

    if (kbits_sec_min > 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Invalid parameter: kbits_sec_min: %d . It must be zero"), kbits_sec_min));
    }    

    if (flags != 0) {
        LOG_ERROR(BSL_LS_BCM_COSQ,
                  (BSL_META_U(unit,
                              "Invalid parameter: flags: %d\n"), flags)); 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Flags must be set to 0")));
    }
    
    if (kbits_sec_max == 1) {
        kbits_sec_max = 2;
    }

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_bandwidth_set, (unit, gport, kbits_sec_max))); 
exit:        
    BCMDNX_FUNC_RETURN;
}

#ifdef BCM_WARM_BOOT_SUPPORT_SW_DUMP
int
_bcm_dpp_cosq_sw_dump(int unit)
{
    int                                 rc = BCM_E_NONE;
    int                                 nbr_entry, base_qid = 0, base_cid = 0, nbr_cos = 0, nbr_se;
    bcm_gport_t                         conn_gport, physical_port, se_gport;
    int                                 num_cos_levels, flow_id, dual_flow_id, dual_se_id;
    int                                 is_non_contiguous = 0, is_composite, is_dual;
    uint32                              flags;
    uint8                              *se_info = NULL;
    int                                 hd_core;
    int core = 0 ;
    uint8                               sw_state_num_cos;
    uint8                               sw_state_flags;
    int                                 sw_state_weight;
    uint32                              sw_state_ref_cnt;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_ALLOC(se_info, sizeof(uint8) * ((SOC_DPP_CONFIG(unit)->tm.max_ses / 8) + 1), "temp se info");
    if (se_info == NULL) {
        return(BCM_E_MEMORY);
    }
    sal_memset(se_info, 0, sizeof(uint8) * ((SOC_DPP_CONFIG(unit)->tm.max_ses / 8) + 1));


    LOG_CLI((BSL_META_U(unit,
                        "\nVoQ State\n")));
    for (nbr_entry = 0, base_qid = 0;
           nbr_entry < (DPP_DEVICE_PETRA_VOQ_HD_SIZE(unit) + 1) / DPP_DEVICE_COSQ_COS_ALLOC_SZ;
                                        base_qid += DPP_DEVICE_COSQ_COS_ALLOC_SZ, nbr_entry++) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(unit, 0, base_qid, &sw_state_num_cos));

        if (sw_state_num_cos == 0) {
            continue;
        }
        hd_core = DPP_DEVICE_PETRA_VOQ_HD_CORE(unit ,base_qid);
        LOG_CLI((BSL_META_U(unit,
                            "  baseVoq(%d), core(%d) numCos(%d)\n"), DPP_DEVICE_PETRA_VOQ_HD_ID(unit, core, base_qid), hd_core, sw_state_num_cos));
    }
    BCM_DPP_CORES_ITER(BCM_CORE_ALL, core) {
        LOG_CLI((BSL_META_U(unit,
                        "\nConnector State\n")));
        for (nbr_entry = 0, base_cid = 0;
               nbr_entry < (DPP_DEVICE_PETRA_COSQ_MAX_FLOW(unit) + 1) / DPP_DEVICE_COSQ_COS_ALLOC_SZ;
                                            base_cid += DPP_DEVICE_COSQ_COS_ALLOC_SZ, nbr_entry++) {
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.num_cos.get(unit, core, base_cid, &sw_state_num_cos));
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.connector_hd.connector_buf.flags.get(unit, core, base_cid, &sw_state_flags));
            if (sw_state_num_cos == 0) {
                continue;
            }
            LOG_CLI((BSL_META_U(unit,
                                "  baseConn(%d), numCos(%d), flags(0x%04X)\n"), base_cid, sw_state_num_cos, (unsigned short)sw_state_flags));
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(conn_gport, base_cid, core);
            rc = bcm_petra_cosq_gport_get(unit, conn_gport, &physical_port, &num_cos_levels, &flags);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting gport(0x%x) info, error 0x%x\n"), unit, conn_gport, rc));
                BCM_EXIT;
            }
            is_non_contiguous = (flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
            is_composite = (flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
            for (nbr_cos = 0; nbr_cos < sw_state_num_cos; nbr_cos++) {
                rc = _bcm_petra_flow_id_get(unit, core, base_cid, nbr_cos, is_non_contiguous, is_composite, FALSE,&flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, failure in getting flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_cos, rc));
                    BCM_EXIT;
                }
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));
    
                LOG_CLI((BSL_META_U(unit,
                                    "    cos(%d), flow(%d), weight(%d)\n"), nbr_cos, flow_id, sw_state_weight));
    
                if (is_composite) {
                    rc = _bcm_petra_composite_flow_id_get(unit, core, base_cid, nbr_cos, is_non_contiguous, is_composite, &flow_id);
                    if (rc != BCM_E_NONE) {
                        LOG_ERROR(BSL_LS_BCM_COSQ,
                                  (BSL_META_U(unit,
                                              "unit %d, failure in getting Composite Flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_cos, rc));
                        BCM_EXIT;
                    }
    
                    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));
    
                    LOG_CLI((BSL_META_U(unit,
                                        "    cos(%d), composite-flow(%d), weight(%d)\n"), nbr_cos, flow_id, sw_state_weight));
                }
            }
        }
    
        LOG_CLI((BSL_META_U(unit,
                            "\nSE State\n")));
    
        for (nbr_se = 0; nbr_se < SOC_DPP_CONFIG(unit)->tm.max_ses; nbr_se++) {
    
            /* check that the element is not already processed */
            if (se_info[(nbr_se / 8)] & (1 << (nbr_se % 8))) {
                continue;
            }
    
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, nbr_se, &sw_state_ref_cnt));
    
            if (sw_state_ref_cnt == 0) {
                continue;
            }
    
            /* update temp state to indicate element processed */
            se_info[(nbr_se / 8)] |= (1 << (nbr_se % 8));
    
            LOG_CLI((BSL_META_U(unit,
                                "  SE(%d), ref_cnt(%d)\n"), nbr_se,
                     (sw_state_ref_cnt - DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE)));
    
            flow_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,( nbr_se)));
            BCM_GPORT_SCHEDULER_CORE_SET(se_gport, flow_id, core);
    
            rc = bcm_petra_cosq_gport_get(unit, se_gport, &physical_port, &num_cos_levels, &flags);
            if (rc != BCM_E_NONE) {
                LOG_ERROR(BSL_LS_BCM_COSQ,
                          (BSL_META_U(unit,
                                      "unit %d, failure in getting gport(0x%x) info, error 0x%x\n"), unit, se_gport, rc));
                BCM_EXIT;
            }
    
            BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));

            LOG_CLI((BSL_META_U(unit,
                                "    flow(%d), weight(%d)\n"), flow_id, sw_state_weight));
    
            is_non_contiguous = (flags & BCM_COSQ_GPORT_NON_CONTIGUOUS_VOQ_CONNECTOR) ? TRUE : FALSE;
            is_composite = (flags & BCM_COSQ_GPORT_COMPOSITE) ? TRUE : FALSE;
            is_dual = (flags & BCM_COSQ_GPORT_SCHEDULER_DUAL_SHAPER) ? TRUE : FALSE;
    
            if (is_composite) {
                rc = _bcm_petra_composite_flow_id_get(unit, core, base_cid, nbr_se, is_non_contiguous, is_composite, &flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, failure in getting Composite Flow(baseFlow(%d) cos(%d), error 0x%x\n"), unit, base_cid, nbr_se, rc));
                    BCM_EXIT;
                }
    
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, flow_id, &sw_state_weight));
    
                LOG_CLI((BSL_META_U(unit,
                                    "    Composite Flow(%d), weight(%d)\n"), flow_id, sw_state_weight));
            }
    
            if (is_dual) {
    
                rc = _bcm_petra_se_dual_flow_id_get(unit, flow_id, SOC_TMC_SCH_SE_TYPE_CL, TRUE, &dual_flow_id);
                if (rc != BCM_E_NONE) {
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, cl se failure in getting dual flow(%d), error 0x%x\n"), unit, flow_id, rc));
                    BCM_EXIT;
                }
    
                dual_se_id = (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_flow2se_id,(unit, dual_flow_id)));
                if (dual_se_id == DPP_COSQ_SCH_SE_ID_INVALID(unit)) {
                    rc = BCM_E_INTERNAL;
                    LOG_ERROR(BSL_LS_BCM_COSQ,
                              (BSL_META_U(unit,
                                          "unit %d, Invalid flow 0x%x specified - does not correspond to SE\n"), unit, dual_flow_id));
                    BCM_EXIT;
                }
    
                /* update temp state to indicate element processed */
                se_info[(nbr_se / 8)] |= (1 << (dual_se_id % 8));
    
                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.get(unit, core, dual_se_id, &sw_state_ref_cnt));

                if ( sw_state_ref_cnt == 0 ) {
                    rc = BCM_E_INTERNAL;
                    BCM_EXIT;
                }
                LOG_CLI((BSL_META_U(unit,
                                    "    SE-Dual(%d), ref_cnt(%d)\n"), nbr_se,
                         (sw_state_ref_cnt - DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE)));

                BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.get(unit, core, dual_flow_id, &sw_state_weight));

                LOG_CLI((BSL_META_U(unit,
                                    "    flow(%d), weight(%d)\n"), dual_flow_id, sw_state_weight));
            }
        }
        LOG_CLI((BSL_META_U(unit,"\n")));
    }

    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCM_FREE(se_info);
    BCMDNX_FUNC_RETURN;
}
#endif /* BCM_WARM_BOOT_SUPPORT_SW_DUMP */


STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg)
{
    BCMDNX_INIT_FUNC_DEFS;
    
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_burst_get, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_get(int unit, 
                                                       bcm_gport_t gport, 
                                                       int *arg)
{
    BCMDNX_INIT_FUNC_DEFS;
 
    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_burst_get, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;   
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_clos_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg)
{
    BCMDNX_INIT_FUNC_DEFS;

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_clos_burst_set, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;
}

STATIC int 
_bcm_petra_cosq_gport_ingress_scheduler_mesh_burst_set(int unit, 
                                                       bcm_gport_t gport, 
                                                       int arg)
{
    BCMDNX_INIT_FUNC_DEFS;

    SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ingress_scheduler_mesh_burst_set, (unit, gport, arg)));

    BCMDNX_FUNC_RETURN;  
}

/* when a port added or removed (dynamic port) the coresspoding hr should be added or removed */
int 
_bcm_petra_cosq_hr_handle(int unit, int port, int enable)
{
    int                         core, priority_i, flow_id, rc;
    uint32                      fap_port, nof_priorities;
    SOC_TMC_SCH_PORT_INFO       port_info;
    bcm_gport_t                 gport;
    uint32                      res_mngr_flags = 0, soc_sand_rc = 0;
    SOC_TMC_SCH_SE_ID           se_index = 0;
    bcm_dpp_cosq_flow_config_t  flow_zero = {0};
    bcm_dpp_cosq_se_config_t    se_zero = {0};

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(soc_port_sw_db_local_to_out_port_priority_get(unit, port, &nof_priorities));
    SOC_TMC_SCH_PORT_INFO_clear(&port_info);
    BCM_COSQ_GPORT_E2E_PORT_SET(gport, port);

    /* A new port is added*/
    if (enable) 
    {   
        /* Set default port information */
        port_info.enable = TRUE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_DUAL_WFQ);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
          port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_EF3;
        }

        rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), fap_port));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        /* allocate hr */ 
         res_mngr_flags = BCM_DPP_AM_FLAG_ALLOC_WITH_ID;
         
         for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
         {
             soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
             if(SOC_SAND_FAILURE(soc_sand_rc)) {
                 rc = translate_sand_success_failure(soc_sand_rc);
                 BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL,
                     (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"),
                                                                                                        unit, fap_port, priority_i, soc_sand_rc, rc));
             }
              
             if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit))
             {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, se id retrieve invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                 continue;
             }

             /* allocate port HRs */
             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.ref_cnt.set(unit, core, se_index, DPP_DEVICE_COSQ_RESOURCE_ALLOC_NREF_VALUE));
             /*  allocate flow */
             flow_id =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_index)));

             rc = bcm_dpp_am_cosq_scheduler_allocate(unit, core, 1, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1, SOC_TMC_AM_SCH_FLOW_TYPE_HR, NULL, &flow_id);
             if (rc != BCM_E_NONE) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                 BCMDNX_IF_ERR_EXIT(rc);
             }
             LOG_VERBOSE(BSL_LS_BCM_COSQ,
                         (BSL_META_U(unit,
                                     "unit %d, port(%d) priority(%d) hr resources, flow_id 0x%x\n"), unit, fap_port, priority_i ,flow_id));

             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.weight.set(unit, core, flow_id, 0));
             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.mode.set(unit, core, flow_id, BCM_COSQ_SP0));
         }
    }
    else /* An exising port is deleted */
    {
        /* Set default port information */
        port_info.enable = FALSE;
        DPP_COSQ_SCH_PORT_INFO_HR_MODE_SET_ALL(unit,port_info,SOC_TMC_SCH_HR_MODE_NONE);
        if (!SOC_DPP_CONFIG(unit)->tm.is_port_tc_enable) {
          port_info.lowest_hp_class = SOC_TMC_SCH_PORT_LOWEST_HP_HR_CLASS_NONE;
        }

        rc = _bcm_petra_cosq_fap_port_get(unit, gport, &fap_port, &core, NULL);
        if (rc != BCM_E_NONE) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "failed to get fap port for gport: 0x%x, error(0x%x)\n"), port, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        if (fap_port > DPP_COSQ_SCH_MAX_PORT_ID(unit)) {
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "Invalid fap port %d\n"), fap_port));
            BCMDNX_IF_ERR_EXIT(rc);
        }

        soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_sched_set,(unit, core, fap_port, &port_info)));
        if(SOC_SAND_FAILURE(soc_sand_rc)) {
            rc = translate_sand_success_failure(soc_sand_rc);
            LOG_ERROR(BSL_LS_BCM_COSQ,
                      (BSL_META_U(unit,
                                  "unit %d, error in setting scheduler port %d, soc_sand error 0x%x, error 0x%x\n"), unit, fap_port, soc_sand_rc, rc));
            BCMDNX_IF_ERR_EXIT(rc);
        }
        /* release hr */
         res_mngr_flags = 0;
        
         for (priority_i = 0; priority_i < nof_priorities; priority_i++) 
         {
             /* retrieve flow id */
             soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_sch_port_tc2se_id,(unit, core, fap_port, priority_i, &se_index)));
             if(SOC_SAND_FAILURE(soc_sand_rc)) {
                 rc = translate_sand_success_failure(soc_sand_rc);
                 BCMDNX_ERR_EXIT_MSG(BCM_E_INTERNAL, (_BSL_BCM_MSG("unit %d, error in getting HR scheduler element for port %d priority %d, soc_sand error 0x%x, rc error 0x%x"), unit, fap_port, priority_i, soc_sand_rc, rc));
             }
              
             if (se_index == DPP_COSQ_SCH_SE_ID_INVALID(unit))
             {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, se id retrieve invalid for port %d TC %d\n"), unit, fap_port, priority_i));
                 continue;
             }
             flow_id =  (MBCM_DPP_DRIVER_CALL_WITHOUT_DEV_ID(unit,mbcm_dpp_sch_se2flow_id,(se_index)));

             /* free HR resources */
             rc = bcm_dpp_am_cosq_scheduler_deallocate(unit, core, res_mngr_flags, FALSE, FALSE, FALSE, TRUE, 1,SOC_TMC_AM_SCH_FLOW_TYPE_HR, flow_id);
             if (rc != BCM_E_NONE) {
                 LOG_ERROR(BSL_LS_BCM_COSQ,
                           (BSL_META_U(unit,
                                       "unit %d, hr se resource allocation failure, error 0x%x\n"), unit, rc));
                 BCMDNX_IF_ERR_EXIT(rc);
             }

             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.flow_hd.flow_buf.set(unit, core, flow_id, &flow_zero));
             BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.se_hd.se_buf.set(unit, core, se_index, &se_zero));
         }

    }

exit:
    BCMDNX_FUNC_RETURN;
}

int
_bcm_arad_cosq_control_congestion_queue_range_set(int unit, 
                                                 bcm_cosq_control_t type, 
                                                 int arg)
{
  int rv = BCM_E_NONE;
  int soc_sand_dev_id, soc_sand_rc;
  ARAD_CNM_Q_MAPPING_INFO info;
  int num_of_queues;

  BCMDNX_INIT_FUNC_DEFS;
  soc_sand_dev_id = (unit);

  soc_sand_rc = arad_cnm_queue_mapping_get(soc_sand_dev_id, &info);
  BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  
  if(type == bcmCosqControlCongestionManagedQueueMin)
  {
    info.cp_queue_low = arg;
  }

  if(type == bcmCosqControlCongestionManagedQueueMax)
  {
    info.cp_queue_high = arg;
  }

  num_of_queues = info.cp_queue_high - info.cp_queue_low + 1;
  if(num_of_queues > DPP_COSQ_ARAD_CNM_MAX_CP_QUEUES)
  {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, number of congestion managed queues is too large (%d)"), unit, num_of_queues));
  }

  soc_sand_rc = arad_cnm_queue_mapping_set(soc_sand_dev_id, &info);
  BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

  BCMDNX_IF_ERR_EXIT(rv);
exit:
  BCMDNX_FUNC_RETURN;
}

int
_bcm_arad_cosq_control_congestion_queue_range_get(int unit, 
                                                 bcm_cosq_control_t type, 
                                                 int *arg)
{
  int rv = BCM_E_NONE;
  int soc_sand_dev_id, soc_sand_rc;
  ARAD_CNM_Q_MAPPING_INFO info;
  
  BCMDNX_INIT_FUNC_DEFS;
  soc_sand_dev_id = (unit);

  soc_sand_rc = arad_cnm_queue_mapping_get(soc_sand_dev_id, &info);
  BCM_SAND_IF_ERR_EXIT(soc_sand_rc);
  
  if(type == bcmCosqControlCongestionManagedQueueMin)
  {
    *arg = info.cp_queue_low;
  }

  if(type == bcmCosqControlCongestionManagedQueueMax)
  {
    *arg = info.cp_queue_high;
  }

  BCMDNX_IF_ERR_EXIT(rv);
exit:
  BCMDNX_FUNC_RETURN;
}


/* Configure Weighted Random Early Discard (WRED).
   global drop per DP , and ECN enabled or not*/
int bcm_petra_cosq_discard_set(
    int unit, 
    uint32 flags) 
{
    uint32 discard_dp, enable_ecn = flags & BCM_COSQ_DISCARD_MARK_CONGESTION;
    int ecn_not_supported = SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system || SOC_IS_ARAD_A0(unit);

    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);

    /* check unsupported flags */
    if (enable_ecn) {
        if (ecn_not_supported) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported BCM_COSQ_DISCARD_MARK_CONGESTION flag: System does not support ECN")));    
        }
        flags &= ~BCM_COSQ_DISCARD_MARK_CONGESTION;
    }
    if (flags & ~(BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_ALL)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag. Supported flags are: BCM_COSQ_DISCARD_ENABLE, "
                                                "BCM_COSQ_DISCARD_COLOR_BLACK, BCM_COSQ_DISCARD_COLOR_RED, BCM_COSQ_DISCARD_COLOR_YELLOW, "
                                                "BCM_COSQ_DISCARD_COLOR_ALL and BCM_COSQ_DISCARD_MARK_CONGESTION")));    
    }

    switch (flags) {
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_ALL):
            /* Drop all packets */
            discard_dp = 0;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_YELLOW):
            /* Drop all packets with DP 1 or above */
            discard_dp = 1;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED):
            /* Drop all packets with DP 2 or above */
            discard_dp = 2;
            break;
        case (BCM_COSQ_DISCARD_ENABLE | BCM_COSQ_DISCARD_COLOR_BLACK):
            /* Drop all packets with DP 3 or above */
            discard_dp = 3;
            break;
        case 0:
            /* No discard per DP */
            discard_dp = 4;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported flag combination\n"))); 
        } 

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dp_discard_set,(unit, discard_dp)));

    if (!ecn_not_supported) {
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_enable_ecn,(unit, enable_ecn)));
    }
    
exit:              
    BCMDNX_FUNC_RETURN;   
}

/* Get configuration of Weighted Random Early Discard (WRED).
   global drop per DP, and ECN enabled */
int bcm_petra_cosq_discard_get(
    int unit, 
    uint32 *flags)
{
    uint32 soc_sand_rc = 0, discard_dp = 0;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_dp_discard_get,(unit, &discard_dp)));
    BCM_SAND_IF_ERR_EXIT(soc_sand_rc);

    if (discard_dp > 3) { /* No discard per DP */
        *flags = 0;
    } 
    else { 
        /* BCM_COSQ_DISCARD_ENABLE is set */
        *flags = BCM_COSQ_DISCARD_ENABLE;

        switch (discard_dp) {
        case 0:
            /* Drop all packets */
            *flags |= BCM_COSQ_DISCARD_COLOR_ALL;
            break;
        case 1:
            /* Drop all packets with DP 1 or above */
            *flags |= (BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED | BCM_COSQ_DISCARD_COLOR_YELLOW);
            break;
        case 2:
            /* Drop all packets with DP 2 or above */
            *flags |= (BCM_COSQ_DISCARD_COLOR_BLACK | BCM_COSQ_DISCARD_COLOR_RED);
            break;
        default: /* case 3 */
            /* Drop all packets with DP 3 or above */
            *flags |= BCM_COSQ_DISCARD_COLOR_BLACK;
        }
    }

    if (!SOC_DPP_CONFIG(unit)->tm.is_petrab_in_system && SOC_IS_ARAD_B0_AND_ABOVE(unit)) {
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit,mbcm_dpp_itm_get_ecn_enabled,(unit, &discard_dp)));
        if (discard_dp) {
            *flags |= BCM_COSQ_DISCARD_MARK_CONGESTION;
        }
    }
    
exit:              
    BCMDNX_FUNC_RETURN;
}

int _bcm_cosq_before_traffic_validation(int unit)
{
  int rv = BCM_E_NONE;

  BCMDNX_INIT_FUNC_DEFS;

    /* Check each queue */
    /* Check only using single SP */
    /* Check PD values are below 4k */
    /* Add reserved value to SP Max Reserved */
    /* Check each service pool */
    /* Check MAX value is below 13k */
    if(soc_property_suffix_num_get(unit, -1, spn_CUSTOM_FEATURE, "skip_before_traffic_validation", 0) == 0)
    {
      rv = _bcm_arad_cosq_update_reserved_pd_threshold_all_sps(unit);
        BCMDNX_IF_ERR_EXIT(rv);
    }

    BCMDNX_IF_ERR_EXIT(rv);
exit:              
    BCMDNX_FUNC_RETURN;
}

/*
 * Set the mapping of device (module) to credit value.
 * In Arad plus only two such values are supported.
 */
int
bcm_petra_cosq_dest_credit_size_set(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 credit_size)
{
    uint32 credit_worth_local = -1, credit_worth_remote = -1;
    uint32 credit_value_type = SOC_TMC_FAP_CREDIT_VALUE_LOCAL;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    if (!(SOC_IS_ARADPLUS(unit) || SOC_IS_JERICHO(unit))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The API is not supported on this device.")));
    }
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_credit_worth_get,(unit, &credit_worth_local)));
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_credit_worth_remote_get,(unit, &credit_worth_remote)));
    if (credit_size == credit_worth_local) {
        credit_value_type = SOC_TMC_FAP_CREDIT_VALUE_LOCAL;
    } else if (credit_size == credit_worth_remote) {
        credit_value_type = SOC_TMC_FAP_CREDIT_VALUE_REMOTE;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Credit size %u is different from both local=%u and remote=%u credit sizes."),
          (unsigned)credit_size, (unsigned)credit_worth_local, (unsigned)credit_worth_remote));
    }
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_module_to_credit_worth_map_set, (unit, dest_modid, credit_value_type)));

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * Get the mapping of device (module) to credit value.
 * In Arad plus only two such values are supported.
 */
int 
bcm_petra_cosq_dest_credit_size_get(
    int unit, 
    bcm_module_t dest_modid, 
    uint32 *credit_size)
{
    uint32 credit_worth_local = -1, credit_worth_remote = -1;
    uint32 credit_value_type = 0;
    BCMDNX_INIT_FUNC_DEFS;
    BCM_DPP_UNIT_CHECK(unit);
    if (!(SOC_IS_ARADPLUS(unit) || SOC_IS_JERICHO(unit))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The API is not supported on this device.")));
    }
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_module_to_credit_worth_map_get, (unit, dest_modid, &credit_value_type)));
    if (credit_value_type == SOC_TMC_FAP_CREDIT_VALUE_LOCAL) {
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_credit_worth_get,(unit, &credit_worth_local)));
        *credit_size = credit_worth_local;
    } else if (credit_value_type == SOC_TMC_FAP_CREDIT_VALUE_REMOTE) {
        BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mgmt_credit_worth_remote_get,(unit, &credit_worth_remote)));
        *credit_size = credit_worth_remote;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("The credit size of FAP ID %u was not set."),
          (unsigned)dest_modid));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_flow_control_set(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 flow_control_mask)
{
    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP fc_map;
    BCMDNX_INIT_FUNC_DEFS;

    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP_clear(&fc_map);

    if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(port)) {
        fc_map.bfmc0_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(port)) {
        fc_map.bfmc1_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(port)) {
        fc_map.bfmc2_lb_fc_map = flow_control_mask;
    } else if(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
        fc_map.gfmc_lb_fc_map = flow_control_mask;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, gport(0x%08x) not supported."), unit, port));
    }

    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mult_fabric_flow_control_set, (unit, &fc_map)));

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_gport_flow_control_get(
    int unit, 
    bcm_gport_t port, 
    bcm_cos_t int_pri, 
    uint32 *flow_control_mask)
{
    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP fc_map;
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(flow_control_mask);

    SOC_TMC_MULT_FABRIC_FLOW_CONTROL_MAP_clear(&fc_map);
    BCM_SAND_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_mult_fabric_flow_control_get, (unit, &fc_map)));

    if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT0(port)) {
        *flow_control_mask = fc_map.bfmc0_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT1(port)) {
        *flow_control_mask = fc_map.bfmc1_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_BESTEFFORT2(port)) {
        *flow_control_mask = fc_map.bfmc2_lb_fc_map;
    } else if(BCM_COSQ_GPORT_IS_FMQ_GUARANTEED(port)) {
        *flow_control_mask = fc_map.gfmc_lb_fc_map;
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, gport(0x%08x) not supported."), unit, port));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_slow_profile_set(
    int unit, 
    bcm_cosq_slow_level_t *slow_level, 
    bcm_cosq_slow_profile_attributes_t *attr)
{

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(slow_level);
    BCMDNX_NULL_CHECK(attr);

    if ((slow_level->profile != 1) && (slow_level->profile != 2))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level profile %d must be 1 or 2"), unit, slow_level->profile));
    }
    if (slow_level->level > 7)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level %d must be between 0a and 7"), unit, slow_level->level));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_slow_max_rates_per_level_set, (unit, slow_level->core, slow_level->level, slow_level->profile, attr->max_rate)));

exit:
    BCMDNX_FUNC_RETURN;

}

/* Set flow factor per level configuration. */
int bcm_petra_cosq_slow_profile_get(
    int unit, 
    bcm_cosq_slow_level_t *slow_level, 
    bcm_cosq_slow_profile_attributes_t *attr)
{

    int slow_rate_val;
    BCMDNX_INIT_FUNC_DEFS;
    
    BCMDNX_NULL_CHECK(slow_level);
    BCMDNX_NULL_CHECK(attr);

    if ((slow_level->profile != 1) && (slow_level->profile != 2))
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level profile %d must be 1 or 2"), unit, slow_level->profile));
    }
    if (slow_level->level > 7)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Slow level %d must be between 0a and 7"), unit, slow_level->level));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sch_slow_max_rates_per_level_get, (unit, slow_level->core, slow_level->level, slow_level->profile, &slow_rate_val)));

    attr->max_rate = slow_rate_val;

exit:
    BCMDNX_FUNC_RETURN;

}

/*Shift the gports flow_id by 64k*/
void
_bcm_petra_cosq_gport_qax_flow_id_add(int unit, bcm_gport_t *gport, int core) {
    int flow_id = 0, gport_sf2_type = 0;
    bcm_gport_t sf2_gport = 0;

    if (BCM_COSQ_GPORT_IS_VOQ_CONNECTOR(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_VOQ_CONNECTOR_ID_GET(*gport));
        BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(*gport, flow_id, core); 
    } else if (BCM_GPORT_IS_SCHEDULER(*gport)) {
        flow_id = BCM_GPORT_SCHEDULER_GET(*gport);
        /*
         * If flow_id > max_flows it means that it is a fmq_class,
         * so no need to add offset to flow_id, because flow_id already
         * comes with the offset.
         */
        if (flow_id < DPP_COSQ_SCH_MAX_FLOW_ID(unit)) {
            flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, flow_id);
        }
        BCM_GPORT_SCHEDULER_CORE_SET(*gport, flow_id, core);
    } else if (BCM_COSQ_GPORT_IS_SCHED_CIR(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_SCHED_CIR_GET(*gport));
        BCM_COSQ_GPORT_SCHED_CIR_CORE_SET(*gport, flow_id, core);
    } else if (BCM_COSQ_GPORT_IS_SCHED_PIR(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_SCHED_PIR_GET(*gport));
        BCM_COSQ_GPORT_SCHED_PIR_CORE_SET(*gport, flow_id, core);
    } else if (BCM_COSQ_GPORT_IS_COMPOSITE_SF2(*gport)) {
        flow_id = BCM_COSQ_FLOW_ID_QAX_ADD_OFFSET(unit, BCM_COSQ_GPORT_COMPOSITE_SF2_GET(*gport));

        /* determine sf2 type to create suitable gport */
        BCM_INT_DPP_COSQ_GPORT_COMPOSITE_SF2_TYPE_GET(gport_sf2_type, *gport);
        if (gport_sf2_type == BCM_COSQ_GPORT_TYPE_VOQ_CONNECTOR) { /* connector */
            BCM_COSQ_GPORT_VOQ_CONNECTOR_CORE_SET(sf2_gport, flow_id, core);
        } else { /* scheduler */
            BCM_GPORT_SCHEDULER_CORE_SET(sf2_gport, flow_id, core);
        }

        BCM_COSQ_GPORT_COMPOSITE_SF2_CORE_SET(*gport, sf2_gport, core);
    }
}

STATIC int
_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int *delta)
{
    int index = 0, core = 0, rc = BCM_E_NONE;
    SOC_TMC_ITM_CGM_PKT_SIZE_ADJUST_TYPE adjust_type;
    int qid = 0;
    SOC_TMC_ITM_CR_DISCOUNT_INFO discount_data;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(adjust_info);
    BCMDNX_NULL_CHECK(delta);

    /* retrieve information and translate to internal types */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(adjust_info->gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(adjust_info->gport) || BCM_COSQ_GPORT_IS_ISQ(adjust_info->gport)) {
        /* per queue compensation */

        /* get core and qid */
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_get(unit, adjust_info->gport,  adjust_info->cosq, &core, &qid)); 

        core = 0; /* both cores are configured symmetrically currently */

        /* HW contains sum of per port and per queue compensation -- retreive the value from SW */
        rc = _bcm_dpp_am_template_queue_discount_cls_data_get(unit, core, qid, &discount_data);
        BCMDNX_IF_ERR_EXIT(rc);

        *delta = discount_data.discount;

    }  else if (BCM_GPORT_IS_LOCAL(adjust_info->gport)) { /* per port compensation */
        uint32 pp_port;

        /* convert local port to PP port */
        BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_pp_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &pp_port, &core) );

        /* HW contains sum of per port and per queue compensation -- retreive the value from SW */
        rc = _bcm_dpp_am_template_pp_port_discount_cls_data_get(unit, core, pp_port, &discount_data);
        BCMDNX_IF_ERR_EXIT(rc);

        *delta = discount_data.discount;

    } else if (BCM_GPORT_IS_PROFILE(adjust_info->gport)) { /* append size ptr compensation (per OutLif profile)*/

        index = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        core = 0; /* both cores are set in the same way */
        adjust_type = SOC_TMC_ITM_PKT_SIZE_ADJUST_APPEND_SIZE_PTR;

        /* get compensation delta */
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_credits_adjust_size_get ,(unit, core, index, adjust_type, delta)));
        BCMDNX_IF_ERR_EXIT(rc);

    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x)"), unit, (adjust_info->gport)));

    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* 
   In Jericho and QAX per queue compensasion profile and per in pp port compensation profile are combined to a single key to compensation value table.
   SW interface to user is 2 separate compensation settings - per queue and per pp port. These two are managed separately in two SW template managers.
   When updating HW, sum of per queue and per pp port compensation is used.
   Note that when updating compensation value for a certain profile, all combinations of this profile with all existing profiles of the other type should be updated.

   This function takes care of this all combinations update
 */
STATIC int _bcm_petra_cosq_compensation_hw_set(int unit, int core, int is_queue, int template, int delta)
{
    int index, core_index;
    uint32 ref_count;
    int rc;

    SOC_TMC_ITM_CR_DISCOUNT_INFO discount_data;
    SOC_TMC_ITM_CGM_PKT_SIZE_ADJUST_TYPE adjust_type;
    _dpp_am_template_t template_type;
    int template_count;
    SOC_TMC_ITM_PKT_SIZE_ADJUST_INFO additional_info;
    int is_other_profile_queue = !is_queue;

    BCMDNX_INIT_FUNC_DEFS;

    adjust_type = (is_queue ? SOC_TMC_ITM_PKT_SIZE_ADJUST_QUEUE : SOC_TMC_ITM_PKT_SIZE_ADJUST_PORT);
    
    template_type = (is_other_profile_queue ? dpp_am_template_queue_discount_cls : dpp_am_template_pp_port_discount_cls);
    BCMDNX_IF_ERR_EXIT(dpp_am_template_template_count_get(unit, 0  /* currently both cores are configured symmetrically */, template_type, &template_count));
    
    /* iterate over all existing profiles from other type*/
    for (index = 0; index < template_count; index++) {
        /* 
           for port update (other profile queue) - configure only the required core 
           for queue update (other profile port) configure both cores 
        */
        BCM_DPP_CORES_ITER((is_other_profile_queue ? core : BCM_CORE_ALL), core_index) { 
            BCMDNX_IF_ERR_EXIT(dpp_am_template_ref_count_get(unit, (is_other_profile_queue ? 0 : core_index)  /* currently in per queue both cores are configured symmetrically */, template_type, index, &ref_count));
            if (ref_count != 0) {
                BCMDNX_IF_ERR_EXIT(dpp_am_template_data_get(unit, (is_other_profile_queue ? 0 : core_index)  /* currently in per queue both cores are configured symmetrically */, template_type, index, &discount_data));
                
                additional_info.index = index;
                additional_info.value = discount_data.discount;
                
                rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_credits_adjust_size_set, (unit, core_index, template, adjust_type, delta, &additional_info)));
                BCMDNX_IF_ERR_EXIT(rc);
            }
        }
    }

exit:
    BCMDNX_FUNC_RETURN;

}

STATIC int _bcm_petra_cosq_compensation_update(int unit, int core, int is_queue,  int id, int delta)
{
    int old_discount_cls, is_last, is_allocated;
    SOC_TMC_ITM_CR_DISCOUNT_INFO discount_data;
    int index = 0;
    int rc;

    BCMDNX_INIT_FUNC_DEFS;

    /* exchange to new class */
    SOC_TMC_ITM_CR_DISCOUNT_INFO_clear(&discount_data);
    discount_data.discount = delta;

    /* before updating alloc manager, need to make sure delta is valid */
    if (delta < DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL || delta > DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
        BCMDNX_ERR_EXIT_MSG(SOC_E_PARAM, (_BSL_SOCDNX_MSG("Delta %d is out of range"), delta));
    }

    if (is_queue) {

         rc = _bcm_dpp_am_template_queue_discount_cls_exchange (unit, 0 /* currently both cores are configured symmetrically */, 
                                                                id, &discount_data, &old_discount_cls, &is_last, &index, &is_allocated);
         BCMDNX_IF_ERR_EXIT(rc);
    } else {
        
        rc = _bcm_dpp_am_template_pp_port_discount_cls_exchange(unit, core,
                                                                id, &discount_data, &old_discount_cls, &is_last, &index, &is_allocated);
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    /* configure compensation delta profile */
    if (is_allocated) {
        rc = _bcm_petra_cosq_compensation_hw_set(unit, core, is_queue, index, delta);
        BCMDNX_IF_ERR_EXIT(rc);
    }

    if (is_queue) {
        /* set new queue to discount class profile mapping, configures both cores */
        rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core, id, BCM_DPP_COSQ_DISCOUNT_CLS, index); 
        BCMDNX_IF_ERR_EXIT(rc);
    } else {
        /* set new pp port to discount class profile mapping */
        rc = MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_in_pp_port_scheduler_compensation_profile_set, (unit, core, id, index));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    
    
exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    int index = 0, core = 0, rc = BCM_E_NONE;
    int qid = 0;
    SOC_TMC_ITM_CGM_PKT_SIZE_ADJUST_TYPE adjust_type;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(adjust_info);

    /* retrieve information and translate to internal types */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(adjust_info->gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(adjust_info->gport) || BCM_COSQ_GPORT_IS_ISQ(adjust_info->gport)) {
        /* per queue compensation */

        /* get core and qid */
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_get(unit, adjust_info->gport,  adjust_info->cosq, &core, &qid)); 

        /* update compensation value and mapping in SW and HW as required */
        rc = _bcm_petra_cosq_compensation_update(unit, core, 1 /*is_queue*/, qid, delta);
        BCMDNX_IF_ERR_EXIT(rc);

    } else if (BCM_GPORT_IS_LOCAL(adjust_info->gport)) { /* per port compensation */
        uint32 pp_port;

        /* convert local port to PP port */
        BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_pp_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &pp_port, &core) );

       /* update compensation value and mapping in SW and HW as required */
        rc = _bcm_petra_cosq_compensation_update(unit, core, 0 /*is_queue*/, pp_port, delta);
        BCMDNX_IF_ERR_EXIT(rc);

    } else if (BCM_GPORT_IS_PROFILE(adjust_info->gport)) { /* append size ptr compensation (per OutLif profile)*/

        index = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        core = BCM_CORE_ALL; /* both cores are set in the same way */
        adjust_type = SOC_TMC_ITM_PKT_SIZE_ADJUST_APPEND_SIZE_PTR;

        /* configure compensation delta */
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_credits_adjust_size_set, (unit, core, index, adjust_type, delta, NULL)));
        BCMDNX_IF_ERR_EXIT(rc);

    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid gport (0x%x)"), unit, (adjust_info->gport)));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_crps_get
 *  Purpose
 *    get the compensation delta which is configure for CRPS ingress PP or ingress TM (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int * delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
STATIC int
_bcm_cosq_gport_pkt_size_adjust_crps_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int * delta)
{
    SOC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int tableIndex, profileIndex;
    int core;
    uint32 tm_port, pp_port;
    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP) ? SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP : SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_outLif_delta_get, (unit, 0, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInTM)
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP)
        {
            /* convert local port to PP port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_pp_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &pp_port, &core) );
            tableIndex = (int)pp_port;
            BCMDNX_IF_ERR_EXIT(MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_crps_get
 *  Purpose
 *    set the compensation delta which is configure for CRPS ingress PP or ingress TM (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
STATIC int
_bcm_cosq_gport_pkt_size_adjust_crps_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    SOC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int core, template, temp;
    int is_last, is_allocated;
    int tableIndex, profileIndex;
    int oldProfileIndex = 0;
    uint32 tm_port, pp_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP) ? SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP : SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_outLif_delta_set, (unit, SOC_CORE_ALL, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInTM)
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            /* get from HW the prev profile for this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get,
                    (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));
            BCM_DPP_UNIT_CHECK(unit);
            /* exchange from DB the profile index for this port */
            BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_crps_pktSize_compensation_exchange(
                    unit, core, dpp_am_template_crps_intm_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
            /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, tableIndex, profileIndex)));
        }
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceCrpsInPP)
        {
            /* convert local port to PP port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_pp_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &pp_port, &core) );
            tableIndex = (int)pp_port;
            /* get from HW the prev profile for this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));

            /* unit check was added to satisfy the coverity */        
            BCM_DPP_UNIT_CHECK(unit);                        
            /* exchange from DB the profile index for this port */
            BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_crps_pktSize_compensation_exchange(
                    unit, core, dpp_am_template_crps_inpp_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
            /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, tableIndex, profileIndex)));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
    }

exit:
    BCMDNX_FUNC_RETURN;    
}




/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_stat_report_get
 *  Purpose
 *    get the compensation delta which is configure for statistics interface ingress or egress (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int * delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
STATIC int
_bcm_cosq_gport_pkt_size_adjust_stat_report_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int * delta)
{
    SOC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int tableIndex, profileIndex;
    int core;
    uint32 tm_port;
    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn) ? SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN : SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_outLif_delta_get, (unit, 0, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn)
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportOut)
        {
            /* convert local port to PP port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get, (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &profileIndex, delta )));
        }
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
    }

exit:
    BCMDNX_FUNC_RETURN;
}



/*
 *  Name
 *    _bcm_cosq_gport_pkt_size_adjust_stat_report_set
 *  Purpose
 *    get the compensation delta which is configure for statistics interface ingress or egress (IQM).
 *    there are 2 compensations types: LIF (as profile) and PORT (as local)
 *  Arguments
 *       int unit,
 *       bcm_cosq_pkt_size_adjust_info_t * adjust_info,
 *       int * delta
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */


STATIC int
_bcm_cosq_gport_pkt_size_adjust_stat_report_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    SOC_COMPENSATION_PKT_SIZE_SRC_TYPE src_type;
    int core, template, temp;
    int is_last, is_allocated;
    int tableIndex, profileIndex;
    int oldProfileIndex = 0;
    uint32 tm_port;

    BCMDNX_INIT_FUNC_DEFS;

    /* convert source_type bcm enum into source_type soc enum */
    src_type = (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn) ? SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN : SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT;

    if (BCM_GPORT_IS_PROFILE(adjust_info->gport) == TRUE)
    {
        tableIndex = BCM_GPORT_PROFILE_GET(adjust_info->gport);
        SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_outLif_delta_set, (unit, SOC_CORE_ALL, adjust_info->source_info.source_id, src_type, tableIndex, delta)));
    }
    else if (BCM_GPORT_IS_LOCAL(adjust_info->gport) == TRUE)
    {
        if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportIn) 
        {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            /* get from HW the prev profile for this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get,
                                                           (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));
            BCM_DPP_UNIT_CHECK(unit); /* Coverity Fix */
            /* exchange from DB the profile index for t his port */
            BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_stat_interface_pktSize_compensation_exchange(
                        unit, core, dpp_am_template_stat_interface_ing_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
                /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, tableIndex, profileIndex)));
        } else if (adjust_info->source_info.source_type == bcmCosqPktSizeAdjustSourceStatReportOut) {
            /* convert local port to TM port */
            BCMDNX_IF_ERR_EXIT( soc_port_sw_db_local_to_tm_port_get(unit, BCM_GPORT_LOCAL_GET(adjust_info->gport), &tm_port, &core) );
            tableIndex = (int)tm_port;
            /* get from HW the prev profile for this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_delta_and_profile_get,
                    (unit, core, adjust_info->source_info.source_id, src_type, tableIndex, &oldProfileIndex, &temp )));
            BCM_DPP_UNIT_CHECK(unit); /* Coverity Fix */
            /* exchange from DB the profile index for this port */
            BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_stat_interface_pktSize_compensation_exchange(
                    unit, core, dpp_am_template_stat_interface_egr_port_compensation_profile, tableIndex, delta, oldProfileIndex, &is_last, &template, &is_allocated) );
            profileIndex = (uint32)template;
            /* if new profile were allocated, need to update the HW with new profile */
            if (is_allocated == TRUE)
            {
                SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, profileIndex, delta)));
            }
            /* update the HW with the profile match to this port */
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, adjust_info->source_info.source_id, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, tableIndex, profileIndex)));
        } else {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("wrong gport. allowed only TYPES: LOCAL|PROFILE")));
        }
    }
exit:
    BCMDNX_FUNC_RETURN;    
}

int bcm_petra_cosq_gport_pkt_size_adjust_set(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int delta)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch(adjust_info->source_info.source_type)
    {
        case bcmCosqPktSizeAdjustSourceScheduler:
            if (!SOC_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit) || SOC_TMC_ITM_COMPENSATION_LEGACY_MODE(unit))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, per packer scheduler compensation is not enabled"), unit));
            }
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_set(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceCrpsInPP:
        case bcmCosqPktSizeAdjustSourceCrpsInTM:
            BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_crps_set(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceStatReportIn:
            BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_stat_report_set(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceStatReportOut:
            /* in QAX, the HW module -  ingress header comprensation handle only the ingress, egress compensation is made in EPNI using different API {bcm_switch_control_port_set, bcmSwitchCounterAdjust} */
            if(!SOC_IS_QAX(unit)) {
                BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_stat_report_set(unit, adjust_info, delta));
            } else {
                BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_petra_cosq_gport_pkt_size_adjust_set called with source_info bcmCosqPktSizeAdjustSourceStatReportOut is not allowed")));
            }
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_petra_cosq_gport_pkt_size_adjust_set called with invalid source_info enum value")));
            break;
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_pkt_size_adjust_get(
        int unit,
        bcm_cosq_pkt_size_adjust_info_t * adjust_info,
        int *delta)
{
    BCMDNX_INIT_FUNC_DEFS;
    switch(adjust_info->source_info.source_type)
    {
        case bcmCosqPktSizeAdjustSourceScheduler:
            if (!SOC_TMC_ITM_PER_PACKET_COMPENSATION_ENABLED(unit) || SOC_TMC_ITM_COMPENSATION_LEGACY_MODE(unit))
            {
                BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unit(%d) Invalid API, per packer scheduler compensation is not enabled"), unit));
            }
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_pkt_size_adjust_scheduler_get(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceCrpsInPP:
        case bcmCosqPktSizeAdjustSourceCrpsInTM:
            BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_crps_get(unit, adjust_info, delta));
            break;
        case bcmCosqPktSizeAdjustSourceStatReportIn:
        case bcmCosqPktSizeAdjustSourceStatReportOut:
            BCMDNX_IF_ERR_EXIT(_bcm_cosq_gport_pkt_size_adjust_stat_report_get(unit, adjust_info, delta));
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_petra_cosq_gport_pkt_size_adjust_get called with invalid source_info enum value")));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_pkt_size_adjust_delta_map_set(
        int unit,
        int delta,
        int final_delta)
{
    int old_profile, is_last, new_profile, is_allocated, rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    if (SOC_IS_QAX(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, 
                            (_BSL_BCM_MSG("API bcm_petra_cosq_pkt_size_adjust_delta_map_set() is not supported for this device type.")));
    }

    /* delta range validation */
    if (delta < DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL || delta > DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_petra_cosq_pkt_size_adjust_delta_map_set called with invalid delta value"), delta));
    }

   /* final delta range validation */
    if (final_delta < DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL || final_delta > DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_petra_cosq_pkt_size_adjust_delta_map_set called with invalid delta value"), delta));
    }

    rc = _bcm_dpp_am_template_scheduler_adjust_size_final_delta_mapping_exchange(unit,
                                                                                 0/*both cores are symmetric */, delta, &final_delta, 
                                                                                 &old_profile, &is_last, &new_profile, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* commit profile value to HW, both cores are configured the same */
    if (is_allocated) {
        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_sch_final_delta_set, (unit, SOC_CORE_ALL, new_profile, final_delta)));
        BCMDNX_IF_ERR_EXIT(rc);
    }

    /* map original delta to new final delta profile */
    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_itm_sch_final_delta_map_set, (unit, SOC_CORE_ALL, delta, new_profile)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_pkt_size_adjust_delta_map_get(
        int unit,
        int delta,
        int *final_delta)
{
    int rc;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(final_delta);

    /* delta range validation */
    if (delta < DPP_COSQ_PB_CR_DISCOUNT_MIN_VAL || delta > DPP_COSQ_PB_CR_DISCOUNT_MAX_VAL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_FAIL, (_BSL_BCM_MSG("bcm_petra_cosq_pkt_size_adjust_delta_map_set called with invalid delta value"), delta));
    }

    /* get final delta from original delta, both cores are configured in the same way */
    rc = _bcm_dpp_am_template_scheduler_adjust_size_final_delta_mapping_data_get(unit, 0, delta , final_delta);
    BCMDNX_IF_ERR_EXIT(rc);


exit:
    BCMDNX_FUNC_RETURN;
}


/*
 *  Name
 *    _bcm_dpp_cosq_pkt_size_compensation_profiles_crps_init
 *  Purpose
 *    init the packet size compensations profiles.
 *  Arguments
 *    IN unit
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
STATIC
int _bcm_dpp_cosq_pkt_size_compensation_profiles_crps_init(int unit)
{
    int core, commandId;
    int delta; 
    int template = 0;

    BCMDNX_INIT_FUNC_DEFS;

    /* to compensate for 4 bytes packet CRC which is removed in the device. */
    /* in jericho the packet size include also 2 internal CRC, therefore, we add DC delta of 2 only */
    delta = SOC_IS_QAX(unit) ? 4 : 2;
    
    /* INIT compensation for IQM DC delta */
    SOC_DPP_CORES_ITER(SOC_CORE_ALL, core)
    {
        BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_crps_pktSize_compensation_init(unit, core, dpp_am_template_crps_intm_port_compensation_profile, delta, template) );
        SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, template, delta)));

        /* loop of 2, for two CMDS_ID */
        for (commandId=0; commandId<2; commandId++)
        {
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, commandId, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM, MAX_PORTS_IN_CORE, template)));
        }
        /* unit check was added to satisfy the coverity */        
        BCM_DPP_UNIT_CHECK(unit);
    }

    /* INIT compensation for IRPP DC delta */
    SOC_DPP_CORES_ITER(SOC_CORE_ALL, core)
    {
        BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_crps_pktSize_compensation_init(unit, core, dpp_am_template_crps_inpp_port_compensation_profile, delta, template) );
        SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, template, delta)));

        /* loop of 2, for two CMDS_ID */
        for (commandId=0; commandId<2; commandId++)
        {
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, commandId, SOC_PKT_SIZE_ADJUST_SRC_CRPS_IQM_IRPP, MAX_PORTS_IN_CORE, template)));
        }
        /* unit check was added to satisfy the coverity */
        BCM_DPP_UNIT_CHECK(unit);
    }

exit:
    BCMDNX_FUNC_RETURN;
}



/*
 *  Name
 *    _bcm_dpp_cosq_pkt_size_compensation_profiles_stat_interface_init
 *  Purpose
 *    init the packet size compensations profiles.
 *  Arguments
 *    IN unit
 *  Returns
 *     bcm_error_t cast as int
 *       BCM_E_NONE if success
 *  Notes
 */
STATIC
int _bcm_dpp_cosq_pkt_size_compensation_profiles_stat_interface_init(int unit)
{
    int core;
    int delta; 
    int template = 0;

    BCMDNX_INIT_FUNC_DEFS;

    /* to compensate for 4 bytes packet CRC which is removed in the device. */
    /* in jericho the packet size include also 2 internal CRC, therefore, we add DC delt of 2 only */
    delta = SOC_IS_QAX(unit) ? 4 : 2;


    /* INIT compensation for ING */
    SOC_DPP_CORES_ITER(SOC_CORE_ALL, core)
    {
        BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_stat_interface_pktSize_compensation_init(unit, core, dpp_am_template_stat_interface_ing_port_compensation_profile, delta, template) );
        SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, template, delta)));


        SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, 0, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_IN, MAX_PORTS_IN_CORE, template)));
        BCM_DPP_UNIT_CHECK(unit); /* Coverity Fix */
        
    }
    if(!SOC_IS_QAX(unit)) {
        /* INIT compensation for EGR. Do not relevant for QAX, becaue it was remove from the HW module */
        SOC_DPP_CORES_ITER(SOC_CORE_ALL, core)
        {
            BCMDNX_IF_ERR_EXIT( _bcm_dpp_am_template_stat_interface_pktSize_compensation_init(unit, core, dpp_am_template_stat_interface_egr_port_compensation_profile, delta, template) );
            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_profile_delta_set, (unit, core, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, template, delta)));


            SOCDNX_SAND_IF_ERR_RETURN(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_cnt_ingress_compensation_port_profile_set, (unit, core, 0, SOC_PKT_SIZE_ADJUST_SRC_STAT_REPOR_OUT, MAX_PORTS_IN_CORE, template)));
            BCM_DPP_UNIT_CHECK(unit); /* Coverity Fix */
            
        }
    }
exit:
    BCMDNX_FUNC_RETURN;
    }

int 
bcm_petra_cosq_ingress_port_drop_enable_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int *enable_mode)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_enable_get, (unit, port, flags, enable_mode)));

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_ingress_port_drop_enable_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int enable_mode)
{
    int port_ext_type;
    uint32 soc_flags = 0;
    BCMDNX_INIT_FUNC_DEFS;

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    switch (enable_mode) {
    case bcmCosqIngressPortDropDisable:
    case bcmCosqIngressPortDropEnableHardStage:
        /*valid input*/
        break;
    case bcmCosqIngressPortDropEnableHardAndSoftStage:
        if (!SOC_IS_JERICHO_PLUS_ONLY(unit)) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop enable mode %d is invalid"), unit ,port, enable_mode));
        }
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop enable mode %d is invalid"), unit ,port, enable_mode));
        break;
    }

    if (_BCM_DPP_EXTENDER_IS_INIT(unit)) {
        BCMDNX_IF_ERR_EXIT(bcm_petra_port_control_get(unit, port, bcmPortControlExtenderType, &port_ext_type));
        if (port_ext_type == BCM_PORT_EXTENDER_TYPE_SWITCH)
        {
            soc_flags |= SOC_TMC_PORT_PRD_F_PORT_EXTERNDER;
        }
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_enable_set, (unit, port, soc_flags, enable_mode))); 

exit:
    BCMDNX_FUNC_RETURN;
}
/* soc_color_t */
int 
bcm_petra_cosq_ingress_port_drop_map_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_cosq_ingress_port_drop_map_t map, 
    uint32 key, 
    int *priority)
{
    
    soc_dpp_prd_map_t prd_map;
    BCMDNX_INIT_FUNC_DEFS;
    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    /* Check if the key matches to the correct map, and clear the map indication */
    switch (map) 
    {
    case bcmCosqIngressPortDropTmTcDpPriorityTable:
        /* TM map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdTmTcDpPriorityTable; 
        break;
    case bcmCosqIngressPortDropIpDscpToPriorityTable:
        /* IP map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdIpDscpToPriorityTable;
        break;
    case bcmCosqIngressPortDropEthPcpDeiToPriorityTable:
        /* ETH map size is 16x2b - key should be 4b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdEthPcpDeiToPriorityTable;
        break;
    case bcmCosqIngressPortDropMplsExpToPriorityTable:
        /* MPLS map size is 8x2b - key should be 3b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdMplsExpToPriorityTable;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid map %d"), unit ,map));
        break;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_map_get, (unit, port, flags, prd_map, key, priority)));

    if ((*priority < SOC_DPP_COSQ_PORT_PRIORITY_MIN) || (*priority > SOC_DPP_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit ,*priority));
    }
    
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_ingress_port_drop_map_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_cosq_ingress_port_drop_map_t map, 
    uint32 key, 
    int priority)
{
    soc_dpp_prd_map_t prd_map;

    BCMDNX_INIT_FUNC_DEFS;
    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit , port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    switch (map)
    {
    case bcmCosqIngressPortDropTmTcDpPriorityTable:
        /* TM map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdTmTcDpPriorityTable;
        break;
    case bcmCosqIngressPortDropIpDscpToPriorityTable:
        /* IP map size is 64x2b - key should be 6b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdIpDscpToPriorityTable;
        break;
    case bcmCosqIngressPortDropEthPcpDeiToPriorityTable:
        /* ETH map size is 16x2b - key should be 4b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdEthPcpDeiToPriorityTable;
        break;
    case bcmCosqIngressPortDropMplsExpToPriorityTable:
        /* MPLS map size is 8x2b - key should be 3b */
        if (_BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_GET(key) == 0) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, key %d is not a match to map %d"), unit, key, map));
        }
        _BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY_CLEAR(key);
        prd_map = socDppPrdMplsExpToPriorityTable;
        break;
    default:
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid map %d"), unit ,map));
        break;
    }

    if ((priority < SOC_DPP_COSQ_PORT_PRIORITY_MIN) || (priority > SOC_DPP_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , priority));
    }
    
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_map_set, (unit, port, flags, prd_map, key, priority)));

exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_ingress_port_drop_threshold_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int priority,
    uint32 *value)
{
    BCMDNX_INIT_FUNC_DEFS;

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if ((priority < SOC_DPP_COSQ_PORT_PRIORITY_MIN) || (priority > SOC_DPP_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , priority));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_threshold_get, (unit, port, flags, priority, value)));
exit:
    BCMDNX_FUNC_RETURN;
}

int 
bcm_petra_cosq_ingress_port_drop_threshold_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int priority,
    uint32 value)
{
    BCMDNX_INIT_FUNC_DEFS;

    if ((IS_IL_PORT(unit,port) && !SOC_IS_JERICHO_PLUS(unit)) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: NIF priority drop invalid for this port"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if ((priority < SOC_DPP_COSQ_PORT_PRIORITY_MIN) || (priority > SOC_DPP_COSQ_PORT_PRIORITY_MAX)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , priority));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_threshold_set, (unit, port, flags, priority, value)));
exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_icgm_resource_stat_get(int unit,
                                     bcm_cosq_icgm_resource_stat_key_t *stat_key,
                                     uint64 *value)
{
    bcm_error_t rv = BCM_E_NONE;
    int core_id = -1;
    bcm_gport_t core_gport = 0;
    SOC_TMC_ITM_CGM_RSRC_STAT_TYPE type = 0;
    
    BCMDNX_INIT_FUNC_DEFS;
    BCMDNX_IF_ERR_EXIT(rv);        

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(stat_key);
    BCMDNX_NULL_CHECK(value);

    if (SOC_IS_ARADPLUS_AND_BELOW(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("API bcm_cosq_icgm_resource_stat_get() is not supported for this device.")));
    }

    core_gport = stat_key->gport;

    if (SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores == 1 && core_gport == 0) {
        core_id = 0;
    } else if (BCM_COSQ_GPORT_IS_CORE(core_gport)) {
        core_id = BCM_COSQ_GPORT_CORE_GET(core_gport);
        if (((core_id < 0) || (core_id >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores))) { 
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid core id %d"), unit, core_id));
        }
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid gport 0x%x type."), unit, core_gport));
    }

    switch (stat_key->stat_type) {
        case bcmCosqICgmMinFreeBDB:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_BDB;
            break;

        case bcmCosqICgmMinFreeOcbBuffers:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_OCB_BUFFERS;
            break;

        case bcmCosqICgmMinFreeMiniMcBuffers:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_MINI_MC_BUFFERS;
            break;

        case bcmCosqICgmMinFreeFullMcBuffers:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_FULL_MC_BUFFERS;
            break;

        case bcmCosqICgmMinFreeVoqDramBDB:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_VOQ_DRAM_BDB;
            break;

        case bcmCosqICgmMinFreeVoqOcbBDB:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_VOQ_OCB_BDB;
            break;

        case bcmCosqICgmMinFreeSramBuffers:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_SRAM_BUFFERS;
            break;

        case bcmCosqICgmMinFreeSramPDB:
            type = SOC_TMC_ITM_CGM_RSRC_STAT_MIN_FREE_SRAM_PDB;
            break;

        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unknown resource statistic type.")));
    }

    rv = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_min_free_resources_stat_get, (unit, core_id, type, value));
    BCMDNX_IF_ERR_EXIT(rv);

exit:
    BCMDNX_FUNC_RETURN;
}

int
bcm_petra_cosq_max_latency_pkts_get(int unit,
                                    bcm_gport_t gport,
                                    uint32 flags,
                                    int max_count,
                                    bcm_cosq_max_latency_pkts_t *max_latency_pkts,
                                    int *actual_count)
{
    bcm_error_t rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(max_latency_pkts);  
    
    rc = MBCM_DPP_SOC_DRIVER_CALL(unit, mbcm_dpp_itm_max_latency_pkts_get,(unit, max_count, (void*)max_latency_pkts, actual_count));
    BCMDNX_IF_ERR_EXIT(rc);
exit:
    BCMDNX_FUNC_RETURN;

}

int bcm_petra_cosq_ingress_port_drop_default_priority_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 default_priority) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    if (default_priority > SOC_DPP_COSQ_PORT_PRIORITY_MAX) { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , default_priority));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_default_priority_set, (unit, port, flags, default_priority)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_ingress_port_drop_default_priority_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags,
    uint32 *default_priority) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_default_priority_get, (unit, port, flags, default_priority)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_ingress_port_drop_custom_ether_type_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 ether_type_code,
    uint32 ether_type_val) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_custom_ether_type_set, (unit, port, flags, ether_type_code, ether_type_val)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_ingress_port_drop_custom_ether_type_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 ether_type_code,
    uint32 *ether_type_val) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_custom_ether_type_get, (unit, port, flags, ether_type_code, ether_type_val)));
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_ingress_port_drop_control_frame_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 control_frame_index,
    bcm_cosq_ingress_drop_control_frame_config_t *control_frame_config) {

    SOC_TMC_PORT_PRD_CONTROL_PLANE prd_ctrl_plane;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }
    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    COMPILER_64_COPY(prd_ctrl_plane.mac_da_val, control_frame_config->mac_da_val);
    COMPILER_64_COPY(prd_ctrl_plane.mac_da_mask, control_frame_config->mac_da_mask);
    prd_ctrl_plane.ether_type_code = control_frame_config->ether_type_code;
    prd_ctrl_plane.ether_type_code_mask = control_frame_config->ether_type_code_mask;
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_control_frame_set, (unit, port, flags, control_frame_index, &prd_ctrl_plane)));
exit:
    BCMDNX_FUNC_RETURN; 
}

int bcm_petra_cosq_ingress_port_drop_control_frame_get(
    int unit, 
    bcm_gport_t port, 
    uint32 flags, 
    uint32 control_frame_index,
    bcm_cosq_ingress_drop_control_frame_config_t *control_frame_config) {

    SOC_TMC_PORT_PRD_CONTROL_PLANE prd_ctrl_plane;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }

    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_control_frame_get, (unit, port, flags, control_frame_index, &prd_ctrl_plane)));

    COMPILER_64_COPY(control_frame_config->mac_da_val, prd_ctrl_plane.mac_da_val);
    COMPILER_64_COPY(control_frame_config->mac_da_mask, prd_ctrl_plane.mac_da_mask);
    control_frame_config->ether_type_code = prd_ctrl_plane.ether_type_code;
    control_frame_config->ether_type_code_mask = prd_ctrl_plane.ether_type_code_mask;
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_ingress_port_drop_flex_key_construct_set(
    int unit, 
    bcm_cosq_ingress_drop_flex_key_construct_id_t *key_id, 
    uint32 flags, 
    bcm_cosq_ingress_drop_flex_key_construct_t *flex_key_config) {

    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, key_id->port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,key_id->port));
    }
    if (!SOC_PORT_VALID(unit, key_id->port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), key_id->port));
    }
    if (flex_key_config->array_size != BCM_COSQ_INGRESS_PORT_DROP_MAX_FLEX_KEY_FIELDS) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: offset array size %d is invalid - shold be %d ."), 
                                          unit ,key_id->port, flex_key_config->array_size, SOC_TMC_PORT_PRD_MAX_KEY_BUILD_OFFSETS));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_flex_key_construct_set, (unit, key_id->port, flags, flex_key_config->offset_array, flex_key_config->array_size))); 
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_ingress_port_drop_flex_key_construct_get(
    int unit, 
    bcm_cosq_ingress_drop_flex_key_construct_id_t *key_id, 
    uint32 flags, 
    bcm_cosq_ingress_drop_flex_key_construct_t *flex_key_config) 
{
    int i;
    uint32 offset_array[SOC_TMC_PORT_PRD_MAX_KEY_BUILD_OFFSETS];
    uint32 array_size;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, key_id->port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,key_id->port));
    }
    if (!SOC_PORT_VALID(unit, key_id->port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), key_id->port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_flex_key_construct_get, (unit, key_id->port, flags, offset_array, &array_size)));
    for (i = 0; i < SOC_TMC_PORT_PRD_MAX_KEY_BUILD_OFFSETS; ++i) {
        flex_key_config->offset_array[i] = offset_array[i];
    }
    flex_key_config->array_size = array_size;
exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_ingress_port_drop_flex_key_entry_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 key_index,
    bcm_cosq_ingress_drop_flex_key_entry_t *flex_key_info) {

    SOC_TMC_PORT_PRD_FLEX_KEY_ENTRY prd_key_entry;
    int i;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }
    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }
    if (flex_key_info->priority > SOC_DPP_COSQ_PORT_PRIORITY_MAX) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, invalid priority %d"), unit , flex_key_info->priority));
    }

    prd_key_entry.ether_code = flex_key_info->ether_code.value;
    prd_key_entry.ether_code_mask = flex_key_info->ether_code.mask;
    prd_key_entry.priority = flex_key_info->priority;
    prd_key_entry.num_key_fields = flex_key_info->num_key_fields;
    for (i = 0; i < prd_key_entry.num_key_fields; ++i) {
        prd_key_entry.key_fields_values[i] = flex_key_info->key_fields[i].value;
        prd_key_entry.key_fields_masks[i] = flex_key_info->key_fields[i].mask;
    }
    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_flex_key_entry_set, (unit, port, flags, key_index, &prd_key_entry)));
exit:
    BCMDNX_FUNC_RETURN; 
}

int bcm_petra_cosq_ingress_port_drop_flex_key_entry_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    uint32 key_index,
    bcm_cosq_ingress_drop_flex_key_entry_t *flex_key_info) {

    SOC_TMC_PORT_PRD_FLEX_KEY_ENTRY prd_key_entry;
    int i;
    BCMDNX_INIT_FUNC_DEFS;

    if (!SOC_IS_JERICHO_PLUS_ONLY(unit) || IS_QSGMII_PORT(unit, port) ) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, port %d: This NIF priority drop API is not supported for this device type or port type"), unit ,port));
    }
    if (!SOC_PORT_VALID(unit, port)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("invalid port %d"), port));
    }

    BCMDNX_IF_ERR_EXIT(MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_port_prd_flex_key_entry_get, (unit, port, flags, key_index, &prd_key_entry)));
    flex_key_info->ether_code.value = prd_key_entry.ether_code;
    flex_key_info->ether_code.mask = prd_key_entry.ether_code_mask;
    flex_key_info->priority = prd_key_entry.priority;
    flex_key_info->num_key_fields = prd_key_entry.num_key_fields;
    for (i = 0; i < prd_key_entry.num_key_fields; ++i) {
        flex_key_info->key_fields[i].value = prd_key_entry.key_fields_values[i];
        flex_key_info->key_fields[i].mask = prd_key_entry.key_fields_masks[i];
    }
exit:
    BCMDNX_FUNC_RETURN;
}

/* ------------------------------------------------------
 *  DRAM BOUND 
 * -------------------------------------------------------*/

int  _bcm_petra_cosq_rate_class_data_dram_bound_thresh_get(int unit,    
                                                           uint32 flags,
                                                           bcm_cosq_fadt_info_t* fadt_info,
                                                           bcm_cosq_fadt_threshold_t* threshold, 
                                                           bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
                                                           SOC_TMC_ITM_DRAM_BOUND_THRESHOLD** dram_threshold
        )
{
    SOC_TMC_INGRESS_DRAM_BOUND_TYPE_E dram_bound_type;
    SOC_TMC_INGRESS_THRESHOLD_TYPE_E resource_type;

    BCMDNX_INIT_FUNC_DEFS;

    switch (fadt_info->thresh_type) {
        case bcmCosqFadtDramBound:
            dram_bound_type = SOC_TMC_INGRESS_DRAM_BOUND;
            break;
        case bcmCosqFadtDramBoundRecoveryFailure:
            dram_bound_type = SOC_TMC_INGRESS_DRAM_BOUND_RECOVERY_FAILURE;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unknown threshold type."),fadt_info->thresh_type));
    }

    switch (fadt_info->resource_type) {
        case bcmResourceOcbBytes: 
            /* SRAM WORDS */
            resource_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_BYTES;
            break;
        case bcmResourceOcbPacketDescriptors: 
            /* SRAM PDS */
            resource_type = SOC_TMC_INGRESS_THRESHOLD_SRAM_PDS;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unsupported resource type."),fadt_info->resource_type));
            
    }
    *dram_threshold = SOC_TMC_ITM_DRAM_BOUND_INFO_thresh_get(unit, &data_rate_class->dram_bound_info, dram_bound_type, resource_type );

exit:
    BCMDNX_FUNC_RETURN;
}

int  _bcm_petra_cosq_gport_dram_bound_to_rate_class_data(int unit,    
                                                         uint32 flags,
                                                         bcm_cosq_fadt_info_t* fadt_info,
                                                         bcm_cosq_fadt_threshold_t* threshold, 
                                                         bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class
        )
{ 
    SOC_TMC_ITM_DRAM_BOUND_THRESHOLD* dram_threshold = NULL;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(fadt_info);
    BCMDNX_NULL_CHECK(threshold);
    BCMDNX_NULL_CHECK(data_rate_class);

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_rate_class_data_dram_bound_thresh_get( unit, flags, fadt_info, threshold, data_rate_class,
                                                                              &dram_threshold));

    dram_threshold->free_max_threshold = threshold->resource_range_max;
    dram_threshold->free_min_threshold = threshold->resource_range_min;
    dram_threshold->max_threshold = threshold->thresh_max;
    dram_threshold->min_threshold = threshold->thresh_min;
    dram_threshold->alpha = threshold->alpha;

exit:
    BCMDNX_FUNC_RETURN;
}

int  _bcm_petra_cosq_gport_rate_class_data_to_dram_bound(int unit,    
                                                         uint32 flags,
                                                         bcm_cosq_fadt_info_t* fadt_info,
                                                         bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class, 
                                                         bcm_cosq_fadt_threshold_t* threshold
        )
{ 
    SOC_TMC_ITM_DRAM_BOUND_THRESHOLD* dram_threshold = NULL;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(fadt_info);
    BCMDNX_NULL_CHECK(threshold);
    BCMDNX_NULL_CHECK(data_rate_class);

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_rate_class_data_dram_bound_thresh_get( unit, flags, fadt_info, threshold, data_rate_class,
                                                                              &dram_threshold));

    threshold->resource_range_max = dram_threshold->free_max_threshold;
    threshold->resource_range_min = dram_threshold->free_min_threshold;
    threshold->thresh_max = dram_threshold->max_threshold;
    threshold->thresh_min = dram_threshold->min_threshold;
    threshold->alpha = dram_threshold->alpha;

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_gport_dram_bound_threshold_verify(int unit,
                                                  bcm_cosq_fadt_threshold_t* threshold)
{
    BCMDNX_INIT_FUNC_DEFS;
    
    if (threshold->thresh_min > threshold->thresh_max) {
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid fadt: min parameter %d, max parameter %d"), unit, threshold->thresh_min, threshold->thresh_max));
    }

    if (threshold->resource_range_min > threshold->resource_range_max) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid fadt: resource_range_min parameter %d, resource_range_min parameter %d"), unit, 
                                          threshold->resource_range_min, threshold->resource_range_max));
    }

exit:
    BCMDNX_FUNC_RETURN;
}



int _bcm_petra_cosq_gport_dram_bound_fadt_threshold_set(
    int unit,
    uint32 flags,
    bcm_cosq_fadt_info_t* fadt_info,
    bcm_cosq_fadt_threshold_t* threshold) 
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_gport_t gport;
    bcm_cos_queue_t cosq;
    bcm_dpp_cosq_ingress_rate_class_info_t exact_data_rate_class;
    bcm_dpp_cosq_rate_class_threshold_info_t update_info;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(fadt_info);
    BCMDNX_NULL_CHECK(threshold);

    gport = fadt_info->gport;
    cosq = fadt_info->cosq;

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_PROFILE(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }

    rc =_bcm_petra_cosq_gport_dram_bound_threshold_verify(unit, threshold);
    BCMDNX_IF_ERR_EXIT(rc);


    /* store update information */
    sal_memset(&update_info,0x0,sizeof(update_info));
    sal_memcpy(&update_info.fadt_info, fadt_info, sizeof(*fadt_info));
    sal_memcpy(&update_info.fadt_threshold, threshold, sizeof(*threshold));
    update_info.valid_element = BCM_DPP_COSQ_RATE_CLASS_ELEMENT_DRAM_BOUND;
    update_info.flags = flags;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_rate_class_threshold_set(unit, gport, cosq, 
                                                                          &update_info, &exact_data_rate_class));

exit:

    BCMDNX_FUNC_RETURN;
}

int _bcm_petra_cosq_gport_dram_bound_fadt_threshold_get(
    int unit,
    uint32 flags,
    bcm_cosq_fadt_info_t* fadt_info,
    bcm_cosq_fadt_threshold_t* threshold ) 
{

    bcm_gport_t gport;
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(fadt_info);

    gport = fadt_info->gport;
    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_PROFILE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unsupported gport type provided\n")));
    }

    /* Validate Params */
    BCMDNX_NULL_CHECK(threshold);

    /* Get Rate class data */
    rc = _bcm_petra_cosq_gport_voq_rate_class_data_get(unit, gport, fadt_info->cosq, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    rc = _bcm_petra_cosq_gport_rate_class_data_to_dram_bound(unit, flags, fadt_info, &data_rate_class, threshold);
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;

}

int bcm_petra_cosq_gport_fadt_threshold_set(
    int unit,
    uint32 flags,
    bcm_cosq_fadt_info_t* fadt_info,
    bcm_cosq_fadt_threshold_t* threshold ) 
{

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(fadt_info);

    switch (fadt_info->thresh_type) {
        case bcmCosqFadtDramBound:
        case bcmCosqFadtDramBoundRecoveryFailure:
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_dram_bound_fadt_threshold_set(unit,flags,fadt_info,threshold));
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported fadt threshold type %d"), 
                                              unit,fadt_info->thresh_type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_fadt_threshold_get(
    int unit,
    uint32 flags,
    bcm_cosq_fadt_info_t* fadt_info,
    bcm_cosq_fadt_threshold_t* threshold ) {

    BCMDNX_INIT_FUNC_DEFS;

    BCM_DPP_UNIT_CHECK(unit);
    BCMDNX_NULL_CHECK(fadt_info);

    switch (fadt_info->thresh_type) {
        case bcmCosqFadtDramBound:
        case bcmCosqFadtDramBoundRecoveryFailure:
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_dram_bound_fadt_threshold_get(unit,flags,fadt_info,threshold));
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Unsupported fadt threshold type %d"), 
                                              unit,fadt_info->thresh_type));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int _bcm_petra_cosq_dram_bound_recovery_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_dpp_cosq_ingress_rate_class_info_t exact_data_rate_class;
    bcm_dpp_cosq_rate_class_threshold_info_t update_info;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(threshold);

    if (threshold->value < 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid threshold %d"), unit, threshold->value));
    }

    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_PROFILE(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }

    /* store update information */
    sal_memset(&update_info,0x0,sizeof(update_info));
    update_info.dram_bound_recovery_threshold =  threshold->value;
    update_info.valid_element = BCM_DPP_COSQ_RATE_CLASS_ELEMENT_DRAM_BOUND_RECOVERY;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_rate_class_threshold_set(unit, gport, cosq, 
                                                                          &update_info, &exact_data_rate_class));

exit:
    BCMDNX_FUNC_RETURN;

}

STATIC int _bcm_petra_cosq_dram_bound_recovery_get(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, bcm_cosq_threshold_t* threshold)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */

    if (!(BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_GPORT_IS_PROFILE(gport))) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unsupported gport type provided\n")));
    }

    /* Validate Params */
    BCMDNX_NULL_CHECK(threshold);

    /* Get Rate class data */
    rc = _bcm_petra_cosq_gport_voq_rate_class_data_get(unit, gport, cosq, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    threshold->value = data_rate_class.dram_bound_info.qsize_recovery_th;

exit:
    BCMDNX_FUNC_RETURN;


}

/* -------------------------------------------------------------------------------------------------------------------------------------------
 *
 *               VOQ Rate Class profile functionality
 *
 *--------------------------------------------------------------------------------------------------------------------------------------------*/

int _bcm_petra_cosq_voq_rate_class_data_update(
    int unit,
    bcm_dpp_cosq_rate_class_threshold_info_t* update_info,
    bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class_to_update
)
{
    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(update_info);
    BCMDNX_NULL_CHECK(data_rate_class_to_update);


    switch (update_info->valid_element) {
        case BCM_DPP_COSQ_RATE_CLASS_ELEMENT_DRAM_BOUND:
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_dram_bound_to_rate_class_data(unit, update_info->flags, &update_info->fadt_info, &update_info->fadt_threshold, data_rate_class_to_update));
            break;
        case BCM_DPP_COSQ_RATE_CLASS_ELEMENT_DRAM_BOUND_RECOVERY:
            data_rate_class_to_update->dram_bound_info.qsize_recovery_th = update_info->dram_bound_recovery_threshold;
            break;
        case BCM_DPP_COSQ_RATE_CLASS_ELEMENT_WRED:
            BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_discard_to_rate_class_data(unit, &update_info->discard, data_rate_class_to_update));
            break;
        case BCM_DPP_COSQ_RATE_CLASS_ELEMENT_OCB_ONLY:
            data_rate_class_to_update->ocb_only = update_info->ocb_only;
            break;
        default:
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Unknown threshold type."),update_info->valid_element));
            break;
    }

exit:
    BCMDNX_FUNC_RETURN;
}



/* 
   Update SW and HW for VOQ according to provided data_rate_class.
   Actual data set in HW is returned in exact_data_rate_class. 

   Note: this is a single stage out of the two stages update process.
*/
STATIC int _bcm_petra_cosq_voq_rate_class_single_update(
    int unit,
    int core,
    int qid,
    bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
    bcm_dpp_cosq_ingress_rate_class_info_t* exact_data_rate_class
)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t *clear_rate_class_data = NULL, *dummy_rate_class_data = NULL;
    int  new_rate_class, old_rate_class, is_allocated, is_last;

    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    /* Update information in SW */
    rc = _bcm_dpp_am_template_queue_rate_cls_exchange(unit, core, qid, data_rate_class, &old_rate_class, &is_last, &new_rate_class, &is_allocated);
    BCMDNX_IF_ERR_EXIT(rc);

    /* Commit Changes in HW according to given thresholds */
    if (is_allocated) {
        /* Set new profile data */
        rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit, new_rate_class, data_rate_class, exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);        
    } else {
        sal_memcpy(exact_data_rate_class, data_rate_class, sizeof(*exact_data_rate_class));
    }


    /* Set new mapping */
    rc = _bcm_petra_cosq_voq_class_mapping_set(unit, core, qid, BCM_DPP_COSQ_RATE_CLS, new_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);
    
    /* Clear old profile */
    if (is_last && new_rate_class != old_rate_class) {

        /* 
         * rate_class_info takes about 1K bytes and we have several such structs on stack.
         * We allocate these two on the heap and free it at the end of the function
         * to reduce stack usage
         */
        BCMDNX_ALLOC(clear_rate_class_data, (sizeof(bcm_dpp_cosq_ingress_rate_class_info_t)), "rate class data");
        if (clear_rate_class_data == NULL) {        
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
        }
        BCMDNX_ALLOC(dummy_rate_class_data, (sizeof(bcm_dpp_cosq_ingress_rate_class_info_t)), "rate class data");
        if (dummy_rate_class_data == NULL) {        
            BCMDNX_ERR_EXIT_MSG(BCM_E_MEMORY, (_BSL_BCM_MSG("failed to allocate memory")));
        }
        sal_memset(clear_rate_class_data, 0x0, sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));
        rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit, old_rate_class, clear_rate_class_data, dummy_rate_class_data);
        BCMDNX_IF_ERR_EXIT(rc);    
    }

exit:
    if (clear_rate_class_data != NULL) {
        BCM_FREE(clear_rate_class_data);
    }
    if (dummy_rate_class_data != NULL) {
        BCM_FREE(dummy_rate_class_data);
    }
    BCMDNX_FUNC_RETURN;
}

/* 
   Set data_rate_class for VOQ both in SW and HW.
   Actual data set in HW is returned in exact_data_rate_class. 

   Note: this is two stages process, when a first stage can result with a  different data than provided by a user
   due to mantissa-exponent representation of some numbers
*/
STATIC int _bcm_petra_cosq_voq_rate_class_set(
    int unit,
    int core,
    int qid,
    bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class,
    bcm_dpp_cosq_ingress_rate_class_info_t* exact_data_rate_class
)
{
    bcm_dpp_cosq_ingress_rate_class_info_t rate_class_dummy_data;

    BCMDNX_INIT_FUNC_DEFS;

    /* Settings rate class parameters is done in two stages: */
    /* 1. Find new profile according to given Thresholds, and set accordingly */
    /* 2. If exact is different than given thresholds, Find new profile according to exact
       and set accordingly the profile management */

    /* Stage 1: Find new profile according to given settings */
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_rate_class_single_update(unit, core, qid, data_rate_class, exact_data_rate_class));

    /* Step 2: Allocate according to exact */
    /* Update information in SW according to exact thresholds */
    /* We have enough profiles here since or data was not exact and we allocated already new profile */
    /* or data was exact thus info is same */
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_voq_rate_class_single_update(unit, core, qid, exact_data_rate_class, &rate_class_dummy_data));
 
exit:
    BCMDNX_FUNC_RETURN;
}

/* 
   Set changes defined by update_info for rate class both in SW and HW.
   rate class can be provided either as voq or as rate classs profile.

   Actual data set in HW is returned in exact_data_rate_class. 
   
 */
STATIC int 
_bcm_petra_cosq_gport_voq_rate_class_threshold_set(int unit, 
                                                   bcm_gport_t gport, 
                                                   bcm_cos_queue_t cosq,
                                                   bcm_dpp_cosq_rate_class_threshold_info_t* update_info,
                                                   bcm_dpp_cosq_ingress_rate_class_info_t* exact_data_rate_class)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(update_info);
    BCMDNX_NULL_CHECK(exact_data_rate_class);

    sal_memset(exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)  || BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) || BCM_COSQ_GPORT_IS_ISQ(gport)) { 
        /* VOQ gport */

        int qid;
        int core = BCM_CORE_ALL;    
        
        /* get core and qid */
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_validate_and_get(unit, gport, cosq, &core, &qid));
        
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_queue_rate_cls_mapping_mode_simple_enable(unit));
        
        /* Get Rate class data */
        rc = _bcm_dpp_am_template_queue_rate_cls_data_get(unit, core, qid, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);
        
        /* Change related information */
        rc = _bcm_petra_cosq_voq_rate_class_data_update(unit, update_info, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);
        
        /* set the updated data to the HW and sw_state */
        rc = _bcm_petra_cosq_voq_rate_class_set(unit, core, qid, &data_rate_class, exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);

    } else if (BCM_GPORT_IS_PROFILE(gport)) {
        /* rate class gport */

        int rate_class;

        /* 
         * Check that the system is in advance queue to rate class mapping mode, 
         *    if not set it to advance mode.
         */
        rc = _bcm_petra_cosq_queue_rate_cls_mapping_mode_advance_enable(unit);
        BCMDNX_IF_ERR_EXIT(rc);
        
        rc = _bcm_petra_cosq_gport_rate_class_get(unit, gport, &rate_class);
        BCMDNX_IF_ERR_EXIT(rc);
        
        rc = _bcm_petra_cosq_gport_voq_rate_class_data_get(unit, gport, cosq, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);
        
        /* 
         * Change related information
         */
        rc = _bcm_petra_cosq_voq_rate_class_data_update(unit, update_info, &data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);
        
        /*2. configure HW*/
        rc = _bcm_petra_cosq_voq_rate_class_hw_set(unit, rate_class, &data_rate_class, exact_data_rate_class);
        BCMDNX_IF_ERR_EXIT(rc);        

    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unsupported gport type provided\n")));
        
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* get core and qid from VOQ gport */
STATIC int _bcm_petra_cosq_gport_voq_get(
    int unit,
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq,
    int *core,
    int *qid
)
{
    int base_qid;

    BCMDNX_INIT_FUNC_DEFS;
 
    *core = BCM_CORE_ALL;

    /* get Queue */
    if (BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport)) {
        base_qid = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(gport);
        *core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(gport);
    } else if (BCM_COSQ_GPORT_IS_ISQ(gport)) {
        base_qid = BCM_COSQ_GPORT_ISQ_QID_GET(gport);
        *core = BCM_COSQ_GPORT_ISQ_CORE_GET(gport);
    } else if (BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport)){
        base_qid = BCM_GPORT_MCAST_QUEUE_GROUP_QID_GET(gport);
        *core = BCM_GPORT_MCAST_QUEUE_GROUP_CORE_GET(gport);
    } else {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport));
    }
    *qid = base_qid + cosq;

exit:
    BCMDNX_FUNC_RETURN;
}

/* get core and qid from VOQ gport */
STATIC int _bcm_petra_cosq_gport_voq_validate_and_get(
    int unit,
    bcm_gport_t gport, 
    bcm_cos_queue_t cosq,
    int *core,
    int *qid
)
{
    uint8 sw_state_num_cos;
    int base_qid;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_get(unit, gport, cosq, core, qid));

    base_qid = *qid - cosq; 
    
    if ((*core < 0 || *core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && *core != BCM_CORE_ALL) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Core ID %d out of range\n"), *core));
    }

    BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.num_cos.get(
                           unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, *core, base_qid), &sw_state_num_cos));

    if (sw_state_num_cos <= 0) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_NOT_FOUND, (_BSL_BCM_MSG("Unit(%d) Invalid VOQ %d parameter\n"),
                                              unit, base_qid));
    }

    if (cosq < 0 || cosq >= sw_state_num_cos) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, Invalid cos level specified %d"), unit, cosq));
    }

exit:
    BCMDNX_FUNC_RETURN;

}

/* get rate class from rate class gport */
STATIC int
_bcm_petra_cosq_gport_rate_class_get(int unit,
                                     bcm_gport_t gport,
                                     int* rate_class)
{
    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        *rate_class = BCM_GPORT_PROFILE_GET(gport);
    } else { 
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("The type of gport %d is not supported."), gport)); 
    }

    /*validate profiles range*/
    if(*rate_class < 0 || *rate_class > SOC_TMC_ITM_RATE_CLASS_MAX)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, The rate class id %d is out of range."),unit, *rate_class)); 
    }

exit:
    BCMDNX_FUNC_RETURN;
}

/* get rate class data from VOQ or rate class gport */
STATIC int
_bcm_petra_cosq_gport_voq_rate_class_data_get(int unit,
                                              bcm_gport_t gport,
                                              bcm_cos_queue_t cosq,
                                              bcm_dpp_cosq_ingress_rate_class_info_t* data_rate_class)
{ 
    bcm_error_t rv = BCM_E_NONE;
    int rate_class;
    int qid; 
    uint8 queue_to_rate_class_mapping_is_simple = ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_UNDEFINED;
    int core = BCM_CORE_ALL;

    BCMDNX_INIT_FUNC_DEFS;

    sal_memset(data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    if (BCM_GPORT_IS_PROFILE(gport)) { 
        _bcm_petra_cosq_gport_rate_class_get( unit, gport, &rate_class);

        /* 1. Get rate class data */
        rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit, rate_class, data_rate_class);
        BCMDNX_IF_ERR_EXIT(rv);

    } else { 
        /* VOQ */

        /* get core and qid */
        BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_validate_and_get(unit, gport, cosq, &core, &qid));
        
        /* Get old rate class data */
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.soc.arad.tm.tm_info.queue_to_rate_class_mapping.is_simple_mode.get(unit, &queue_to_rate_class_mapping_is_simple));
        if (queue_to_rate_class_mapping_is_simple != ARAD_SW_DB_QUEUE_TO_RATE_CLASS_MAPPING_IS_SIMPLE) {
            rv = _bcm_petra_cosq_voq_class_mapping_get(unit,core,qid,BCM_DPP_COSQ_RATE_CLS,&rate_class);
            BCMDNX_IF_ERR_EXIT(rv);
            
            /* in advance mode allocation manager is not used */
            rv = _bcm_petra_cosq_voq_rate_class_hw_get(unit,rate_class,data_rate_class);
            BCMDNX_IF_ERR_EXIT(rv);
        } 
        else
        {
            /* Get old rate class data */
            rv = _bcm_dpp_am_template_queue_rate_cls_data_get(unit, core, qid, data_rate_class);
            BCMDNX_IF_ERR_EXIT(rv);
        }
    }

exit:
    BCMDNX_FUNC_RETURN;
} 

STATIC int
_bcm_petra_cosq_voq_rate_class_ocb_only_set(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int value)
{
    bcm_dpp_cosq_ingress_rate_class_info_t exact_data_rate_class;
    bcm_dpp_cosq_rate_class_threshold_info_t update_info;

    BCMDNX_INIT_FUNC_DEFS;

    if (!BCM_GPORT_IS_UCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_MCAST_QUEUE_GROUP(gport) && !BCM_GPORT_IS_PROFILE(gport)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PORT, (_BSL_BCM_MSG("unit %d, Invalid gport(0x%08x)"), unit, gport));
    }

    sal_memset(&exact_data_rate_class,0x0,sizeof(bcm_dpp_cosq_ingress_rate_class_info_t));

    /* store update information */
    sal_memset(&update_info,0x0,sizeof(update_info));
    update_info.ocb_only = value;
    update_info.valid_element = BCM_DPP_COSQ_RATE_CLASS_ELEMENT_OCB_ONLY;

    /* we call generic function which configure rate class by 2 levels exchange even that in this case one exchange whould be enough */
    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_rate_class_threshold_set(unit, gport, cosq, 
                                                                          &update_info, &exact_data_rate_class));

exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_voq_rate_class_ocb_only_get(int unit,
                                            bcm_gport_t gport,
                                            bcm_cos_queue_t cosq,
                                            int* value)
{
    bcm_error_t rc = BCM_E_NONE;
    bcm_dpp_cosq_ingress_rate_class_info_t data_rate_class;

    BCMDNX_INIT_FUNC_DEFS;

    /* Validate Params */
    BCMDNX_NULL_CHECK(value);

    /* Get Rate class data */
    rc = _bcm_petra_cosq_gport_voq_rate_class_data_get(unit, gport, cosq, &data_rate_class);
    BCMDNX_IF_ERR_EXIT(rc);

    *value = data_rate_class.ocb_only;

exit:
    BCMDNX_FUNC_RETURN;
}

/* Helper function of API bcm_cosq_sysport_ingress_queue_map */
/* Input validation (unit, core, voq) */
STATIC int
_bcm_petra_cosq_sysport_ingress_queue_map_validate_inputs(int unit, bcm_gport_t sysport, bcm_gport_t ingress_queue)
{
  int core = BCM_CORE_ALL;
  int base_voq  = 0;
  BCMDNX_INIT_FUNC_DEFS;
  /* unit check */
  BCM_DPP_UNIT_CHECK(unit);

  /* GPORT_VOQ -> CORE, BASE_VOQ */
  core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(ingress_queue);
  base_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(ingress_queue);

  /* check BASE_VOQ range */
  if (base_voq >= SOC_DPP_DEFS_GET(unit, max_queues)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, base voq 0x%x is out of range"),unit, base_voq));
    }

  /* check core range */
  if ((core < 0 || core >= SOC_DPP_CONFIG(unit)->core_mode.nof_active_cores) && core != BCM_CORE_ALL) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit(%d) sysport ingress queue map set (0x%08x) failed, core out of range %d"), unit, ingress_queue, core));
  }

  exit:
    BCMDNX_FUNC_RETURN;
}

/* Helper function of API bcm_cosq_sysport_ingress_queue_map */
/* validate that new slave SYSPORT points to same MODPORT as master SYSPORT 
      1. MASTER_SYSPORT -> MASTER_MODPORT
      2. SLAVE_SYSPORT -> SLAVE_MODPORT 
      3. Compare
*/
STATIC int
_bcm_petra_cosq_sysport_ingress_queue_map_validate_modports(int unit, bcm_gport_t slave_sysport, bcm_gport_t master_sysport)
{
  bcm_error_t     rc = BCM_E_NONE;
  bcm_gport_t     master_modport = 0;
  bcm_gport_t     slave_modport = 0;

  BCMDNX_INIT_FUNC_DEFS;

  /* 1. MASTER_SYSPORT -> MASTER_MODPORT */
  rc = bcm_petra_stk_sysport_gport_get(unit, master_sysport, &master_modport);
  if (rc != BCM_E_NONE) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("Unit(%d) sysport(%d) modport get failed"), 
          unit, master_sysport));
  }
  /* 2. SLAVE_SYSPORT -> SLAVE_MODPORT */
  rc = bcm_petra_stk_sysport_gport_get(unit, slave_sysport, &slave_modport);
  if (rc != BCM_E_NONE) {
      BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM,
          (_BSL_BCM_MSG("Unit(%d) sysport(%d) modport get failed"), 
          unit, slave_sysport));
  }
  /* 3. Compare */
  if (master_modport != slave_modport) {
    BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("master (0x%x) and slave (0x%x) sysport point to modport (0x%x) and (0x%x)"), master_sysport, slave_sysport, master_modport, slave_modport));
  }
  exit:
    BCMDNX_FUNC_RETURN;
}

/* Helper function of API bcm_cosq_sysport_ingress_queue_map */
/* Get SYSPORT pointed to by VOQ */
STATIC int
_bcm_petra_cosq_sysport_ingress_queue_map_voq2sysport(int unit, int core, int base_voq, int *sysport)
{
  int soc_sand_rc = 0;
  int rc = BCM_E_NONE;
  SOC_TMC_IPQ_QUARTET_MAP_INFO    queue_to_sysport_info;

  BCMDNX_INIT_FUNC_DEFS;

  /* VOQ -> MASTER_SYSPORT */
  SOC_TMC_IPQ_QUARTET_MAP_INFO_clear(&queue_to_sysport_info);
  soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_queue_to_flow_mapping_get,
            (unit, core ,SOC_TMC_IPQ_Q_TO_QRTT_ID(base_voq), &queue_to_sysport_info)));
  rc = handle_sand_result(soc_sand_rc);
  if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(rc, (_BSL_BCM_MSG("mbcm_dpp_ipq_queue_to_flow_mapping_get() failed base queue(%d)"), base_voq));
  }
  *sysport = queue_to_sysport_info.system_physical_port;

  exit:
    BCMDNX_FUNC_RETURN;
}

/*  This feature allows N:1 DSP to VOQ mapping
    - should be used with soc property hqos_mapping_enable=1
    - supports both DIRECT and INDIRECT modes
    - API bcm_cosq_ingress_queue_bundle_gport_add allocates VOQ and master DSP
    - This API adds slave DSPs mapping to the same VOQ
    - remove slave DSPs with flag BCM_COSQ_SYSPORT_INGRESS_QUEUE_UNMAP
    - master DSP added with gport_add API should not be unmapped using this API

             DIRECT MODE
           +-------------+

                        +------------+         +--------------+           +----------------+
                        |            |         |              |           |                |
            gport_add   | master DSP +--------->      VOQ     +----------->     MODPORT    |
                        |            |         |              |           |                |
                        +------------+         +------^-------+           +----------------+
                                                      |
                        +------------+                |
                        |            |                |
           queue_map_set| slave DSP  +----------------+
                        |            |                ^
                        +------------+                |
                                                      |
                        +------------+                |
                        |            |                |
           queue_map_set| slave DSP  +----------------+
                        |            |
                        +------------+

    - when trying to delete VOQ: if more than 1 SYSPORT points to VOQ, gport_delete will fail (reference counter)
    - API only accepts DSP as input (not modport)
    - this API fails if:
      1. given DSP is already mapped to another VOQ
      2. given VOQ is not allocated
*/
int 
bcm_petra_cosq_sysport_ingress_queue_map_set(int unit, uint32 flags, bcm_gport_t sysport_gport, bcm_gport_t ingress_queue)
{
    int     soc_sand_rc = 0;
    bcm_error_t  rc = BCM_E_NONE;
    uint32  input_voq  = 0;
    uint32  current_voq = 0;
    uint32  old_voq = 0;
    int     master_sysport = 0;
    uint32  sysport = 0;
    int     core = BCM_CORE_ALL;
    int     core_index;
    uint32  voq_ref_counter;
    int     ref_count_change;
    int     replace_flag = 0;
    uint8   is_current_voq_valid = 0;
    uint8   is_sw_only = FALSE;
    uint32  is_unmap_cmd = flags & BCM_COSQ_SYSPORT_INGRESS_QUEUE_UNMAP;
    bcm_gport_t  master_sysport_gport;

    BCMDNX_INIT_FUNC_DEFS;

    /* validate inputs */
    rc = _bcm_petra_cosq_sysport_ingress_queue_map_validate_inputs(unit, sysport_gport, ingress_queue);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("input validation failed")));
    }

    if (!ARAD_IS_HQOS_MAPPING_ENABLE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("This API only works with HQOS mapping (SOC hqos_mapping_enable=1)")));
    }

    core = BCM_GPORT_UNICAST_QUEUE_GROUP_CORE_GET(ingress_queue);
    input_voq = BCM_GPORT_UNICAST_QUEUE_GROUP_QID_GET(ingress_queue);
    sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);

    /*  SYSPORT -> VOQ  */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_current_voq_valid, &is_sw_only, &current_voq)));
    rc = handle_sand_result(soc_sand_rc);

    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("retrieving base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), 
            sysport_gport, soc_sand_rc, rc));
    }


    /* SYSPORT mapped to the same VOQ and no unmap flag */
    if (is_current_voq_valid && (input_voq == current_voq) && !is_unmap_cmd) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, sysport 0x%x already mapped to voq 0x%x "),unit, sysport, current_voq)); 
    }

    /* SYSPORT not mapped to VOQ and unmap flag */
    if (is_unmap_cmd && !is_current_voq_valid) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, can't unmap sysport 0x%x not mapped to voq 0x%x "),unit, sysport, input_voq)); 
    }

    if (!ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
      /* INPUT_VOQ -> MASTER_SYSPORT in case of indirect mapping */
      rc = _bcm_petra_cosq_sysport_ingress_queue_map_voq2sysport(unit, core, input_voq, &master_sysport);
      if (rc != BCM_E_NONE) {
         BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, voq2sysport fail 0x%x voq "),unit, current_voq));
      }
    }
    else {
      /* direct mapping, no voq->sysport mapping */
      master_sysport = -1;
    }

    /* map Scenario */
    if (!is_unmap_cmd) {
        /* SYSPORT mapped to a different VOQ, REPLACE Scenario */
        if (is_current_voq_valid && (input_voq != current_voq)) {
            replace_flag = 1;
            old_voq = current_voq;
        }
        current_voq = input_voq; /* assign input voq as destination to map */
        is_current_voq_valid = TRUE; /* make this destination valid */
        ref_count_change = 1; /* reference counter of destination will be increased by 1 */
    }
    else  { /* unmap Scenario */
        if (sysport == master_sysport) { /* Checking that SYSPORT to remove is not MASTER */
            BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("unit %d, master sysport 0x%x can't be unmapped with this API "),unit, sysport));
        }
        is_current_voq_valid = FALSE; /* make this destination invalid */
        ref_count_change = -1; /* reference counter of destination will be decreased by 1 */
    }

    if (!ARAD_IS_VOQ_MAPPING_DIRECT(unit)) {
      /* in case of indirect mapping, validate that slave SYSPORT and master SYSPORT map to the same MODPORT */
      BCM_GPORT_SYSTEM_PORT_ID_SET(master_sysport_gport, master_sysport);
      rc = _bcm_petra_cosq_sysport_ingress_queue_map_validate_modports(unit, sysport_gport, master_sysport_gport);
      if (rc != BCM_E_NONE) {
          BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("modport validation failed")));
      }
    }

    /* Unmap/Map new SLAVE_SYSPORT to VOQ */
    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_set,
        (unit, core, sysport, is_current_voq_valid, is_sw_only, current_voq)));
    rc = handle_sand_result(soc_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("set base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), 
            sysport, soc_sand_rc, rc));
    }

    /* increase/decrease VOQ ref count by 1*/
    BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.ref_cnt.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, current_voq), &voq_ref_counter));
        voq_ref_counter = voq_ref_counter + ref_count_change;
        BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.ref_cnt.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, current_voq), voq_ref_counter));
    }
    /* In case of REPLACE, need to decrement previous VOQ reference counter */
    if (replace_flag) {
      BCM_DPP_ASSYMETRIC_CORES_ITER(core, core_index) {
          BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.ref_cnt.get(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, old_voq), &voq_ref_counter));
          voq_ref_counter = voq_ref_counter - 1;
          BCMDNX_IF_ERR_EXIT(sw_state_access[unit].dpp.bcm.cosq.cosq_config.voq_hd.voq_buf.ref_cnt.set(unit, 0, DPP_DEVICE_PETRA_VOQ_HD_ELEMENT(unit, core_index, old_voq), voq_ref_counter));
      }
    }

    exit:
    BCMDNX_FUNC_RETURN;
}

/* Get VOQ pointed to by SYSPORT_GPORT */
int 
bcm_petra_cosq_sysport_ingress_queue_map_get(int unit, uint32 flags, bcm_gport_t sysport_gport, bcm_gport_t *ingress_queue)
{
    int       soc_sand_rc = 0;
    int       core = BCM_CORE_ALL;
    uint8     is_dest_valid = FALSE;
    uint8     is_sw_only = FALSE;
    uint32    output_voq = 0;
    uint32    sysport = 0;
    bcm_error_t     rc = BCM_E_NONE;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_NULL_CHECK(ingress_queue);

    if (!ARAD_IS_HQOS_MAPPING_ENABLE(unit)) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("This API only works with HQOS mapping (SOC hqos_mapping_enable=1)")));
    }
    sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(sysport_gport);

    soc_sand_rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_ipq_destination_id_packets_base_queue_id_get,
        (unit, core, sysport, &is_dest_valid, &is_sw_only, &output_voq)));
    rc = handle_sand_result(soc_sand_rc);
    if (rc != BCM_E_NONE) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("retrieving base queue for dest port(%d) failed, soc_sand error (0x%x), error 0x%x"), 
            sysport, soc_sand_rc, rc));
    }
    if (!is_dest_valid) {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("destination for sysport(%d) is invalid, sysport isn't mapped to VOQ"), sysport));
    }

    BCM_GPORT_UNICAST_QUEUE_GROUP_SET(*ingress_queue, output_voq);

    exit:
    BCMDNX_FUNC_RETURN;
}

STATIC int
_bcm_petra_cosq_voq_flush_set(int unit, bcm_gport_t gport, bcm_cos_queue_t cosq, int timeout)
{
    int core = BCM_CORE_ALL;
    int qid;
    int rc;

    BCMDNX_INIT_FUNC_DEFS;

    BCMDNX_IF_ERR_EXIT(_bcm_petra_cosq_gport_voq_validate_and_get(unit, gport, cosq, &core, &qid));

    if (timeout < 0)
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_PARAM, (_BSL_BCM_MSG("Timeout %d is invalid."), timeout));
    }

    rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_queue_flush_set, (unit, core, qid, timeout)));
    BCMDNX_IF_ERR_EXIT(rc);

exit:
    BCMDNX_FUNC_RETURN;
}

/*
 * For _SHR_GPORT_TYPE_SYSTEM_PORT type: enable/disable system port mapping to VOQ
 */
int bcm_petra_cosq_gport_enable_set(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    int enable)
{
    int rc;
    int sysport;
    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_SYSTEM_PORT(gport))
    {
        /*
         * get system port id
         */
        sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(gport);

        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sysport_ingress_queue_map_enable_set, (unit, sysport, enable)));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid port (0x%x) "), unit, gport));
    }

exit:
    BCMDNX_FUNC_RETURN;
}

int bcm_petra_cosq_gport_enable_get(
    int unit,
    bcm_gport_t gport,
    bcm_cos_queue_t cosq,
    int *enable)
{
    int rc;
    int sysport;
    BCMDNX_INIT_FUNC_DEFS;

    if (BCM_GPORT_IS_SYSTEM_PORT(gport))
    {
        /*
         * get system port id
         */
        sysport = BCM_GPORT_SYSTEM_PORT_ID_GET(gport);

        rc = (MBCM_DPP_DRIVER_CALL(unit, mbcm_dpp_sysport_ingress_queue_map_enable_get, (unit, sysport, enable)));
        BCMDNX_IF_ERR_EXIT(rc);
    }
    else
    {
        BCMDNX_ERR_EXIT_MSG(BCM_E_UNAVAIL, (_BSL_BCM_MSG("unit %d, invalid port (0x%x) "), unit, gport));
    }

exit:
    BCMDNX_FUNC_RETURN;
}
