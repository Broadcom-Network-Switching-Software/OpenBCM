/*
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 * 
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */

typedef int _bcm_client_dispatch_not_empty; /* Make ISO compilers happy. */

#include <bcm_int/control.h>
#include <bcm_int/api_xlate_port.h>
#include <bcm/error.h>
#include <bcm/debug.h>
#include <bcm/collector.h>
#include <bcm/cosq.h>
#include <bcm/cpri.h>
#include <bcm/custom.h>
#include <bcm/fabric.h>
#include <bcm/field.h>
#include <bcm/flexdigest.h>
#include <bcm/flow.h>
#include <bcm/flowtracker.h>
#include <bcm/hash.h>
#include <bcm/instru.h>
#include <bcm/ipfix.h>
#include <bcm/knet.h>
#include <bcm/knetsync.h>
#include <bcm/l2.h>
#include <bcm/latency_monitor.h>
#include <bcm/link.h>
#include <bcm/mirror.h>
#include <bcm/oam.h>
#include <bcm/pktio.h>
#include <bcm/port.h>
#include <bcm/rx.h>
#include <bcm/sat.h>
#include <bcm/stack.h>
#include <bcm/stat.h>
#include <bcm/stg.h>
#include <bcm/subport.h>
#include <bcm/switch.h>
#include <bcm/tdm.h>
#include <bcm/time.h>
#include <bcm/tsn.h>
#include <bcm/tx.h>
#include <bcm/txbeacon.h>
#include <bcm/vlan.h>
#include <bcm_int/client_dispatch.h>
#if defined(INCLUDE_FCMAP)
#include <bcm/fcmap.h>
#endif
#if defined(INCLUDE_GDPLL)
#include <bcm/gdpll.h>
#endif
#if defined(INCLUDE_I2C)
#include <bcm/bcmi2c.h>
#endif
#if defined(INCLUDE_L3)
#include <bcm/ipmc.h>
#include <bcm/l3.h>
#include <bcm/nat.h>
#endif
#if defined(INCLUDE_MACSEC)
#include <bcm/macsec.h>
#endif
#if defined(INCLUDE_PTP)
#include <bcm/ptp.h>
#endif
#if defined(INCLUDE_REGEX)
#include <bcm/bregex.h>
#endif
#if defined(INCLUDE_XFLOW_MACSEC)
#include <bcm/xflow_macsec.h>
#endif

int 
bcm_client_collector_export_record_register(
    int unit, 
    bcm_collector_t collector_id, 
    bcm_collector_callback_options_t callback_options, 
    bcm_collector_export_record_cb_f callback_fn, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_collector_export_record_unregister(
    int unit, 
    bcm_collector_t collector_id, 
    bcm_collector_callback_options_t callback_options, 
    bcm_collector_export_record_cb_f callback_fn)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_cosq_event_register(
    int unit, 
    bcm_cosq_event_types_t event_types, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_cosq_event_unregister(
    int unit, 
    bcm_cosq_event_types_t event_types, 
    bcm_gport_t port, 
    bcm_cos_queue_t cosq, 
    bcm_cosq_event_cb cb)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_cosq_icgm_resource_stat_get(
    int unit, 
    bcm_cosq_icgm_resource_stat_key_t *stat_key, 
    uint64 *value)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_TCB)
int 
bcm_client_cosq_tcb_cb_register(
    int unit, 
    bcm_cosq_tcb_callback_t fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_TCB)
int 
bcm_client_cosq_tcb_cb_unregister(
    int unit, 
    bcm_cosq_tcb_callback_t fn)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_cpri_port_interrupt_callback_register(
    int unit, 
    bcm_cpri_interrupt_type_t cpri_intr_type, 
    bcm_cpri_port_interrupt_callback_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_cpri_port_interrupt_callback_unregister(
    int unit, 
    bcm_cpri_interrupt_type_t cpri_intr_type, 
    bcm_cpri_port_interrupt_callback_t callback)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_cpri_rsvd1_msg_get(
    int unit, 
    bcm_cpri_rsvd1_msg_t *rsvd1_msg)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_cpri_speed_scan_callback_register(
    int unit, 
    bcm_cpri_speed_scan_handler_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_cpri_speed_scan_callback_unregister(
    int unit, 
    bcm_cpri_speed_scan_handler_t callback)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_custom_register(
    int unit, 
    bcm_custom_cb_t func, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_custom_unregister(
    int unit)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_QL_SSM_map(
    int unit, 
    bcm_esmc_network_option_t opt, 
    bcm_esmc_quality_level_t ql, 
    uint8 *ssm_code)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_SSM_QL_map(
    int unit, 
    bcm_esmc_network_option_t opt, 
    uint8 ssm_code, 
    bcm_esmc_quality_level_t *ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_g781_option_get(
    int unit, 
    int stack_id, 
    bcm_esmc_network_option_t *g781_option)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_g781_option_set(
    int unit, 
    int stack_id, 
    bcm_esmc_network_option_t g781_option)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_rx_callback_register(
    int unit, 
    int stack_id, 
    bcm_esmc_rx_cb rx_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_rx_callback_unregister(
    int unit, 
    int stack_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_tunnel_get(
    int unit, 
    int stack_id, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_tunnel_set(
    int unit, 
    int stack_id, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_esmc_tx(
    int unit, 
    int stack_id, 
    bcm_pbmp_t pbmp, 
    bcm_esmc_pdu_data_t *esmc_pdu_data)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_fabric_module_control_get(
    int unit, 
    uint32 flags, 
    bcm_module_t modid, 
    bcm_fabric_module_control_t control, 
    int *value)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_fabric_module_control_set(
    int unit, 
    uint32 flags, 
    bcm_module_t modid, 
    bcm_fabric_module_control_t control, 
    int value)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_diag_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_diag_code_t *diag)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_enable_get(
    int unit, 
    bcm_fcmap_event_t t, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_enable_set(
    int unit, 
    bcm_fcmap_event_t t, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_register(
    int unit, 
    bcm_fcmap_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_event_unregister(
    int unit, 
    bcm_fcmap_event_cb cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_linkfault_trigger_rc_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_lf_tr_t *trigger, 
    bcm_fcmap_lf_rc_t *rc)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_ability_advert_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_ability_t *ability_mask)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_ability_advert_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_ability_t *ability_mask)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_config_selective_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_config_selective_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_enable(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_link_reset(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_shutdown(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_speed_set(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_port_speed_t speed)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_port_traverse(
    int unit, 
    bcm_fcmap_port_traverse_cb callbk, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_stat_clear(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint64 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_stat_t stat, 
    uint32 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_vlan_map_add(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_vlan_map_delete(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_FCMAP)
int 
bcm_client_fcmap_vlan_map_get(
    int unit, 
    bcm_port_t port, 
    bcm_fcmap_vlan_vsan_map_t *vlan)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_field_context_hash_create(
    int unit, 
    uint32 flags, 
    bcm_field_stage_t stage, 
    bcm_field_context_t context_id, 
    bcm_field_context_hash_info_t *hash_info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_context_hash_info_get(
    int unit, 
    bcm_field_stage_t stage, 
    bcm_field_context_t context_id, 
    bcm_field_context_hash_info_t *hash_info)
{
    return BCM_E_UNAVAIL;
}

#if defined(BROADCOM_DEBUG)
int 
bcm_client_field_entry_dump(
    int unit, 
    bcm_field_entry_t entry)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_field_flush_entry_add(
    int unit, 
    uint32 flags, 
    bcm_field_group_t fg_id, 
    int entry_id, 
    bcm_field_flush_entry_info_t *flush_entry_info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_flush_entry_delete(
    int unit, 
    uint32 flags, 
    bcm_field_group_t fg_id, 
    int entry_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_flush_entry_get(
    int unit, 
    uint32 flags, 
    bcm_field_group_t fg_id, 
    int entry_id, 
    bcm_field_flush_entry_info_t *flush_entry_info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_flush_profile_attach(
    int unit, 
    uint32 flags, 
    bcm_field_group_t fg_id, 
    uint32 flush_profile_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_flush_profile_create(
    int unit, 
    uint32 flags, 
    bcm_field_flush_profile_info_t *flush_profile_info, 
    uint32 *flush_profile_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_flush_profile_destroy(
    int unit, 
    uint32 flags, 
    uint32 flush_profile_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_flush_profile_get(
    int unit, 
    uint32 flags, 
    uint32 flush_profile_id, 
    bcm_field_flush_profile_info_t *flush_profile_info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_field_group_config_extension_create(
    int unit, 
    bcm_field_group_config_extension_t *group_config)
{
    return BCM_E_UNAVAIL;
}

#if defined(BROADCOM_DEBUG)
int 
bcm_client_field_group_dump(
    int unit, 
    bcm_field_group_t group)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_field_show(
    int unit, 
    const char *pfx)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_flexdigest_entry_dump(
    int unit, 
    bcm_field_entry_t entry)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_flexdigest_group_dump(
    int unit, 
    bcm_field_group_t group)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_flexdigest_show(
    int unit, 
    const char *pfx)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_flow_handle_get(
    int unit, 
    const char *flow_name, 
    bcm_flow_handle_t *handle)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_flow_logical_field_id_get(
    int unit, 
    bcm_flow_handle_t flow_handle, 
    const char *field_name, 
    bcm_flow_field_id_t *field_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_flow_match_info_add(
    int unit, 
    bcm_flow_handle_info_t *flow_handle_info, 
    bcm_flow_special_fields_t *key_special_fields)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_flow_match_info_delete(
    int unit, 
    bcm_flow_handle_info_t *flow_handle_info, 
    bcm_flow_special_fields_t *key_special_fields)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_flow_match_info_get(
    int unit, 
    bcm_flow_handle_info_t *flow_handle_info, 
    bcm_flow_special_fields_t *key_special_fields)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_flow_option_id_get(
    int unit, 
    bcm_flow_handle_t flow_handle, 
    const char *flow_option_name, 
    bcm_flow_option_id_t *option_id)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_flowtracker_export_record_register(
    int unit, 
    bcm_flowtracker_collector_t collector_id, 
    bcm_flowtracker_collector_callback_options_t callback_options, 
    bcm_flowtracker_export_record_cb_f callback_fn, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_flowtracker_export_record_unregister(
    int unit, 
    bcm_flowtracker_collector_t collector_id, 
    bcm_flowtracker_collector_callback_options_t callback_options, 
    bcm_flowtracker_export_record_cb_f callback_fn)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_cb_register(
    int unit, 
    bcm_gdpll_cb_reg_t cb_type, 
    bcm_gdpll_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_cb_unregister(
    int unit, 
    bcm_gdpll_cb_reg_t cb_type)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_chan_create(
    int unit, 
    uint32 flags, 
    bcm_gdpll_chan_t *gdpll_chan, 
    int *pChan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_chan_debug_enable(
    int unit, 
    int chan, 
    bcm_gdpll_debug_mode_t debug_mode, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_chan_destroy(
    int unit, 
    int chan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_chan_enable(
    int unit, 
    int chan, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_chan_get(
    int unit, 
    int chan, 
    bcm_gdpll_chan_t *gdpll_chan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_chan_state_get(
    int unit, 
    int chan, 
    uint32 *dpllState)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_debug(
    int unit, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_debug_cb_register(
    int unit, 
    bcm_gdpll_debug_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_flush(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_input_event_poll(
    int unit, 
    bcm_gdpll_input_event_t input_event, 
    uint32 timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_offset_get(
    int unit, 
    int chan, 
    uint64 *dpllOffset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_GDPLL)
int 
bcm_client_gdpll_offset_set(
    int unit, 
    int chan, 
    uint64 offset)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_hash_flex_field_id_get(
    int unit, 
    bcm_hash_flex_object_t object, 
    const char *field_name, 
    uint32 *field_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_hash_flex_field_name_get(
    int unit, 
    uint32 field_id, 
    bcm_hash_flex_object_t *object, 
    int size, 
    char *field_name)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_ioctl(
    int unit, 
    int fd, 
    int opcode, 
    void *data, 
    int len)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_open(
    int unit, 
    char *devname, 
    uint32 flags, 
    int speed)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_read(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 *nbytes)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_I2C)
int 
bcm_client_i2c_write(
    int unit, 
    int fd, 
    uint32 addr, 
    uint8 *data, 
    uint32 nbytes)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_instru_eventor_context_get(
    int unit, 
    uint32 flags, 
    bcm_eventor_context_id_t context, 
    bcm_eventor_context_type_t context_type, 
    bcm_instru_eventor_context_conf_t *out_conf)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_instru_eventor_context_set(
    int unit, 
    uint32 flags, 
    bcm_eventor_context_id_t context, 
    bcm_eventor_context_type_t context_type, 
    bcm_instru_eventor_context_conf_t *conf)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_instru_synced_counters_config_get(
    int unit, 
    uint32 flags, 
    bcm_instru_synced_counters_source_type_t source_type, 
    bcm_instru_synced_counters_config_t *config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_instru_synced_counters_config_set(
    int unit, 
    uint32 flags, 
    bcm_instru_synced_counters_source_type_t source_type, 
    bcm_instru_synced_counters_config_t *config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_instru_synced_counters_records_get(
    int unit, 
    uint32 flags, 
    bcm_instru_synced_counters_records_key_t *key, 
    bcm_instru_synced_counters_data_t *data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_instru_vis_signal_get(
    int unit, 
    bcm_core_t core_id, 
    uint32 flags, 
    int nof_signals, 
    bcm_instru_vis_signal_key_t *signal_key, 
    bcm_instru_vis_signal_result_t *signal_result)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_ipfix_register(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_ipfix_unregister(
    int unit, 
    bcm_ipfix_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_L3)
int 
bcm_client_ipmc_age(
    int unit, 
    uint32 flags, 
    bcm_ipmc_traverse_cb age_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_knet_cleanup(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_create(
    int unit, 
    bcm_knet_filter_t *filter)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_destroy(
    int unit, 
    int filter_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_get(
    int unit, 
    int filter_id, 
    bcm_knet_filter_t *filter)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_filter_traverse(
    int unit, 
    bcm_knet_filter_traverse_cb trav_fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_init(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_create(
    int unit, 
    bcm_knet_netif_t *netif)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_destroy(
    int unit, 
    int netif_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_get(
    int unit, 
    int netif_id, 
    bcm_knet_netif_t *netif)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knet_netif_traverse(
    int unit, 
    bcm_knet_netif_traverse_cb trav_fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knetsync_deinit(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_knetsync_init(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_l2_key_dump(
    int unit, 
    char *pfx, 
    bcm_l2_addr_t *entry, 
    char *sfx)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_L3)
int 
bcm_client_l3_alpm_trace_cb_register(
    int unit, 
    bcm_l3_alpm_trace_cb_f write_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_l3_alpm_trace_cb_unregister(
    int unit, 
    bcm_l3_alpm_trace_cb_f write_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_l3_host_age(
    int unit, 
    uint32 flags, 
    bcm_l3_host_traverse_cb age_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_l3_nat_ingress_age(
    int unit, 
    uint32 flags, 
    bcm_l3_nat_ingress_traverse_cb age_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_L3)
int 
bcm_client_l3_route_age(
    int unit, 
    uint32 flags, 
    bcm_l3_route_traverse_cb age_out, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_latency_monitor_config_get(
    int unit, 
    uint8 monitor_id, 
    bcm_latency_monitor_config_t *config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_latency_monitor_config_set(
    int unit, 
    uint8 monitor_id, 
    bcm_latency_monitor_config_t *config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_latency_monitor_info_get(
    int unit, 
    uint8 monitor_id, 
    bcm_latency_monitor_info_t *monitor_info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_latency_monitor_register(
    int unit, 
    int monitor_id, 
    bcm_latency_monitor_callback_fn fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_latency_monitor_unregister(
    int unit, 
    int monitor_id, 
    bcm_latency_monitor_callback_fn fn)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_linkscan_port_register(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_linkscan_port_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_linkscan_port_handler_t f)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_enable_get(
    int unit, 
    bcm_macsec_event_t t, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_enable_set(
    int unit, 
    bcm_macsec_event_t t, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_register(
    int unit, 
    bcm_macsec_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_event_unregister(
    int unit, 
    bcm_macsec_event_cb cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *action, 
    int *flowId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_destroy(
    int unit, 
    bcm_port_t port, 
    int flowId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_get(
    int unit, 
    bcm_port_t port, 
    int flowId, 
    bcm_macsec_flow_match_t *flow, 
    bcm_macsec_flow_action_t *a)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_flow_traverse(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_flow_traverse_cb callbk, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_capability_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_capability_t *cap)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_config_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_config_set(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_port_config_t *cfg)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_port_traverse(
    int unit, 
    bcm_macsec_port_traverse_cb callbk, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int chanId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *assocId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_destroy(
    int unit, 
    bcm_port_t port, 
    int assocId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_get(
    int unit, 
    bcm_port_t port, 
    int assocId, 
    bcm_macsec_secure_assoc_t *assoc, 
    int *chanId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_assoc_traverse(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_assoc_traverse_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_create(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_macsec_secure_chan_t *chan, 
    int *chanId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_destroy(
    int unit, 
    bcm_port_t port, 
    int chanId)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_get(
    int unit, 
    bcm_port_t port, 
    int chanId, 
    bcm_macsec_secure_chan_t *chan)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_secure_chan_traverse(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_chan_traverse_cb calback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_clear(
    int unit, 
    bcm_port_t port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_get(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_get32(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_set(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint64 val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_MACSEC)
int 
bcm_client_macsec_stat_set32(
    int unit, 
    bcm_port_t port, 
    bcm_macsec_stat_t stat, 
    int chanId, 
    int assocId, 
    uint32 val)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_mirror_port_destination_add(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    bcm_gport_t mirror_dest, 
    bcm_mirror_options_t options)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_mirror_port_destination_get(
    int unit, 
    bcm_port_t port, 
    uint32 flags, 
    int mirror_dest_size, 
    bcm_gport_t *mirror_dest, 
    int *mirror_dest_count, 
    bcm_mirror_options_t *options)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_mirror_port_vlan_destination_add(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    bcm_gport_t destid, 
    bcm_mirror_options_t options)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_mirror_port_vlan_destination_get(
    int unit, 
    bcm_port_t port, 
    bcm_vlan_t vlan, 
    uint32 flags, 
    uint32 mirror_dest_size, 
    bcm_gport_t *destid, 
    uint32 *destcount, 
    bcm_mirror_options_t *options)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_oam_performance_event_register(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_performance_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_oam_performance_event_unregister(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_performance_event_cb cb)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_oam_pm_event_register(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_pm_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_oam_pm_event_unregister(
    int unit, 
    bcm_oam_event_types_t event_types, 
    bcm_oam_pm_event_cb cb)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_obm_cb_register(
    int unit, 
    bcm_obm_callback_fn fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_obm_cb_unregister(
    int unit, 
    bcm_obm_callback_fn fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_alloc(
    int unit, 
    uint32 max_size, 
    uint32 flags, 
    bcm_pktio_pkt_t **packet)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_claim(
    int unit, 
    bcm_pktio_pkt_t *pkt, 
    bcm_pktio_pkt_t **new_pkt)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_cleanup(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_filter_create(
    int unit, 
    bcm_pktio_filter_t *filter)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_filter_destroy(
    int unit, 
    int filter_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_filter_get(
    int unit, 
    int filter_id, 
    bcm_pktio_filter_t *filter)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_filter_traverse(
    int unit, 
    bcm_pktio_filter_traverse_cb_f cb_func, 
    void *cb_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_free(
    int unit, 
    bcm_pktio_pkt_t *packet)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_init(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_netif_create(
    int unit, 
    bcm_pktio_netif_t *netif)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_netif_destroy(
    int unit, 
    int netif_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_netif_get(
    int unit, 
    int netif_id, 
    bcm_pktio_netif_t *netif)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_netif_link_status_set(
    int unit, 
    int netif_id, 
    int status)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_netif_traverse(
    int unit, 
    bcm_pktio_netif_traverse_cb_f cb_func, 
    void *cb_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pkt_data_get(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    void **data, 
    uint32 *length)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pmd_fid_support_get(
    int unit, 
    bcm_pktio_fid_support_t *support)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pmd_field_get(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    bcm_pktio_pmd_type_t type, 
    int fid, 
    uint32 *val)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pmd_field_set(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    bcm_pktio_pmd_type_t type, 
    int fid, 
    uint32 val)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pmd_pkt_format_get(
    int unit, 
    int array_size, 
    uint32 *match_id_array, 
    int *count, 
    bcm_pktio_bitmap_t *pkt_format)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pmd_reasons_get(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    bcm_pktio_reasons_t *reasons)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pmd_set(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    bcm_pktio_txpmd_t *txpmd)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_pull(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    uint32 len, 
    void **data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_push(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    uint32 len, 
    void **data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_put(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    uint32 len, 
    void **data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_raw_pmd_fid_support_get(
    int unit, 
    bcm_pktio_pmd_t *pmd, 
    bcm_pktio_fid_support_t *support)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_raw_pmd_field_get(
    int unit, 
    bcm_pktio_pmd_t *pmd, 
    bcm_pktio_pmd_type_t type, 
    int fid, 
    uint32 *val)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_raw_pmd_field_set(
    int unit, 
    bcm_pktio_pmd_t *pmd, 
    bcm_pktio_pmd_type_t type, 
    int fid, 
    uint32 val)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_raw_pmd_reasons_get(
    int unit, 
    bcm_pktio_pmd_t *pmd, 
    bcm_pktio_reasons_t *reasons)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_raw_pmd_reasons_set(
    int unit, 
    bcm_pktio_pmd_t *pmd, 
    bcm_pktio_reasons_t *reasons)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_reserve(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    uint32 len, 
    void **data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_rx_register(
    int unit, 
    const char *name, 
    bcm_pktio_rx_cb_f callback, 
    uint8 priority, 
    void *cookie, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_rx_unregister(
    int unit, 
    bcm_pktio_rx_cb_f callback, 
    uint8 priority)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_trace_counter_get(
    int unit, 
    bcm_pktio_trace_data_t *trace_data, 
    bcm_pktio_bitmap_t *bitmap)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_trace_data_collect(
    int unit, 
    bcm_pktio_trace_pkt_t *trace_pkt, 
    bcm_pktio_trace_data_t *trace_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_trace_dop_data_collect(
    int unit, 
    bcm_port_t port, 
    uint32 dop_id, 
    bcm_pktio_trace_data_t *trace_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_trace_drop_reasons_get(
    int unit, 
    bcm_pktio_trace_data_t *trace_data, 
    bcm_pktio_bitmap_t *bitmap)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_trace_field_get(
    int unit, 
    bcm_pktio_trace_data_t *trace_data, 
    int fid, 
    uint32 *val)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_trace_tx(
    int unit, 
    bcm_pktio_trace_pkt_t *trace_pkt)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_trim(
    int unit, 
    bcm_pktio_pkt_t *packet, 
    uint32 len)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_pktio_tx(
    int unit, 
    bcm_pktio_pkt_t *packet)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_fdr_callback_register(
    int unit, 
    bcm_port_fdr_handler_t f, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_fdr_callback_unregister(
    int unit, 
    bcm_port_fdr_handler_t f, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_medium_status_register(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_medium_status_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_port_medium_status_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_phy_drv_name_get(
    int unit, 
    bcm_port_t port, 
    char *name, 
    int len)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_phy_reset_register(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_phy_reset_unregister(
    int unit, 
    bcm_port_t port, 
    bcm_port_phy_reset_cb_t callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_tpid_class_create(
    int unit, 
    uint32 flags, 
    bcm_port_tag_struct_type_t tag_struct_type, 
    bcm_port_tag_format_class_t *tag_format_class_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_port_tpid_class_destroy(
    int unit, 
    uint32 flags, 
    bcm_port_tag_format_class_t tag_format_class_id)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int priority1_alt_value, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_enabled_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 *enabled)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_enabled_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint8 enabled)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_acceptable_master_table_size_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_bs_time_info_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_bs_time_info_t *time)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_cb_register(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_cb_unregister(
    int unit, 
    bcm_ptp_cb_types_t cb_types, 
    bcm_ptp_cb cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_accuracy_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_accuracy_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_accuracy_t *accuracy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_gps_offset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *offset_nsec)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_gps_offset_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int offset_nsec)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_mode_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_apts_mode_t *current_mode)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_source_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_apts_source_t source, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_source_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_apts_source_t source, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_source_prio_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_sources, 
    bcm_ptp_clock_apts_source_t *priority_list)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_apts_source_prio_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_sources, 
    bcm_ptp_clock_apts_source_t *priority_list)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_bmca_override_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *flags, 
    uint32 *enable_mask)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_bmca_override_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 flags, 
    uint32 enable_mask)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_create(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_clock_info_t *clock_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_current_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_current_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_default_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_default_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_domain_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_domain_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_info_t *clock_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_local_priority_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 *local_priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_local_priority_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 local_priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_max_steps_removed_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 *max_steps_removed)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_max_steps_removed_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 max_steps_removed)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_parent_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_parent_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_peer_age_timer_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 *aging_time)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_peer_age_timer_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 aging_time)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_announce_receipt_timeout_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_announce_receipt_timeout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_configure(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_dataset_t *dataset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_delay_mechanism_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *delay_mechanism)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_delay_mechanism_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 delay_mechanism)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_disable(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_drop_counters_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_drop_counters_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_packet_drop_counters_t *per_port_packet_drop_counters)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_enable(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_identity_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_identity_t *identity)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_info_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_clock_port_info_t *info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_latency_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 latency_in, 
    uint32 latency_out)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_announce_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_announce_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_delay_req_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_delay_req_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_pdelay_req_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_min_pdelay_req_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_sync_interval_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int *interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_log_sync_interval_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    int interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_mac_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_protocol_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_protocol_t *protocol)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_tlv_config_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_index, 
    uint32 clock_port, 
    bcm_ptp_tlv_type_t tlv_type, 
    uint16 data_len, 
    uint8 *data, 
    bcm_ptp_tlv_action_t action, 
    int config_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_tlv_config_delete(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_index, 
    uint32 clock_port, 
    int config_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_tlv_config_delete_all(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_index, 
    uint32 clock_port)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_type_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    bcm_ptp_port_type_t *type)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_port_version_number_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 clock_port, 
    uint32 *version)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority1_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority1)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority1_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority1)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority2_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *priority2)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_priority2_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 priority2)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_quality_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_quality_t *clock_quality, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_quality_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_quality_t clock_quality, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_slaveonly_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *slaveonly)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_slaveonly_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 slaveonly)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_time_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_time_properties_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_time_properties_t *data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_time_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timestamp_t *time)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_timescale_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_timescale_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timescale_t *timescale)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_tlv_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_index, 
    uint32 clock_port, 
    int config_id, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_tlv_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_index, 
    uint32 clock_port, 
    int config_id, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_traceability_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_traceability_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_trace_t *trace)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_user_description_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 *desc)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_utc_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_clock_utc_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_utc_t *utc)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alarm_callback_register(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_ctdev_alarm_cb alarm_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alarm_callback_unregister(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alpha_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 *alpha_numerator, 
    uint16 *alpha_denominator)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_alpha_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 alpha_numerator, 
    uint16 alpha_denominator)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_verbose_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_ctdev_verbose_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_external_phy_synchronize(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_external_phy_config_t *extphy_config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_foreign_master_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_foreign_master_dataset_t *data_set)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_g8275p1_traceability_info_clock_class_map(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_g8275p1_clock_traceability_info_t traceability_info, 
    uint8 *clock_class)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channel_precedence_mode_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_select_mode)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channel_switching_mode_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int channel_switching_mode)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channels_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_channels, 
    bcm_ptp_channel_t *channels)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_input_channels_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_channels, 
    bcm_ptp_channel_t *channels)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_enable_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *enable, 
    uint32 *flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_enable_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int enable, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_phyts_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *phyts, 
    int *framesync_pin)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_phyts_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int phyts, 
    int framesync_pin)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_portbitmap_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t *pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_portbitmap_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_pbmp_t pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_verbose_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_modular_verbose_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int verbose)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_packet_counters_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    uint32 counter_bitmap)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_packet_counters_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_packet_counters_t *counters)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_peer_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_peers, 
    bcm_ptp_peer_entry_t *peers, 
    int *num_peers)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_phase_offset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_phase_offset_t *offset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_phase_offset_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    const bcm_ptp_phase_offset_t *offset)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_pkt_flags_override_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 *override_flag, 
    uint32 *override_value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_pkt_flags_override_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint32 override_flag, 
    uint32 override_value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_primary_domain_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *primary_domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_primary_domain_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int primary_domain)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_configuration_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_configuration_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_status_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_status_t *status)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_threshold_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_threshold_t *threshold)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_servo_threshold_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_servo_threshold_t *threshold)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signal_output_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_count, 
    bcm_ptp_signal_output_t *signal_output_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signal_output_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int signal_output_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signal_output_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *signal_output_id, 
    bcm_ptp_signal_output_t *output_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info, 
    uint32 mask)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_slave_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaled_unicast_slave_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int callstack)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaling_arbiter_register(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_signaling_arbiter_t arb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_signaling_arbiter_unregister(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_stack_create(
    int unit, 
    bcm_ptp_stack_info_t *ptp_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_stack_destroy(
    int unit, 
    bcm_ptp_stack_id_t ptp_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_stack_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_stack_info_t *ptp_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_stack_get_all(
    int unit, 
    int max_size, 
    bcm_ptp_stack_info_t *ptp_info, 
    int *no_of_stacks)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_unicast_master_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_masters, 
    int *num_masters, 
    bcm_ptp_clock_peer_address_t *master_addr)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_address_t *master_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_master_table_size_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int *max_table_entries)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    int max_num_slaves, 
    int *num_slaves, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_peer_t *slave_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_static_unicast_slave_table_clear(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_sync_phy(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_sync_phy_input_t sync_input)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_init(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_network_option_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t *network_option)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_network_option_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_network_option_t network_option)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_add(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_best_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_clock_port_address_t *address, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_list(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int max_master_count, 
    int *num_masters, 
    int *best_master, 
    bcm_ptp_telecom_g8265_pktmaster_t *pktmaster)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_lockout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 lockout, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_non_reversion_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 nonres, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_priority_override(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint8 override, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_priority_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 priority, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int port_num, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_packet_master_wait_duration_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint64 wait_sec, 
    bcm_ptp_clock_port_address_t *address)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_pktstats_thresholds_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t *thresholds)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_pktstats_thresholds_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_pktstats_t thresholds)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_quality_level_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_telecom_g8265_quality_level_t ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_receipt_timeout_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 *receipt_timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_receipt_timeout_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_message_type_t message_type, 
    uint32 receipt_timeout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_telecom_g8265_shutdown(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_time_format_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    bcm_ptp_time_type_t type)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_timesource_input_status_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_timesource_status_t *status)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_input_sources_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_input_sources_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int num_tod_sources, 
    bcm_ptp_tod_input_t *tod_sources)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_output_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_count, 
    bcm_ptp_tod_output_t *tod_output)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_output_remove(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int tod_output_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_tod_output_set(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    int *tod_output_id, 
    bcm_ptp_tod_output_t *output_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_transparent_clock_default_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    bcm_ptp_transparent_clock_default_dataset_t *data_set)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_ptp_transparent_clock_port_dataset_get(
    int unit, 
    bcm_ptp_stack_id_t ptp_id, 
    int clock_num, 
    uint16 clock_port, 
    bcm_ptp_transparent_clock_port_dataset_t *data_set)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_config_get(
    int unit, 
    bcm_regex_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_config_set(
    int unit, 
    bcm_regex_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_create(
    int unit, 
    bcm_regex_engine_config_t *config, 
    bcm_regex_engine_t *engid)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_destroy(
    int unit, 
    bcm_regex_engine_t engid)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_get(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_engine_config_t *config)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_info_get(
    int unit, 
    int engine_id, 
    bcm_regex_engine_info_t *regex_engine_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_engine_traverse(
    int unit, 
    bcm_regex_engine_traverse_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_add(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_delete(
    int unit, 
    uint8 protocol, 
    uint16 l4_start, 
    uint16 l4_end)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_delete_all(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_exclude_get(
    int unit, 
    int array_size, 
    uint8 *protocol, 
    uint16 *l4low, 
    uint16 *l4high, 
    int *array_count)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_get_match_id(
    int unit, 
    int signature_id, 
    int *match_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_get_sig_id(
    int unit, 
    int match_id, 
    int *signature_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_info_get(
    int unit, 
    bcm_regex_info_t *regex_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_init(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_match_check(
    int unit, 
    bcm_regex_match_t *matches, 
    int count, 
    int *metric)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_match_set(
    int unit, 
    bcm_regex_engine_t engid, 
    bcm_regex_match_t *matches, 
    int count)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_add(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_delete(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 param0, 
    uint32 param1)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_get(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    uint32 *param0, 
    uint32 *param1)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_mac_add(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_mac_t mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_mac_get(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_ports_add(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_pbmp_t pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_ports_get(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action, 
    bcm_pbmp_t *pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_remove(
    int unit, 
    bcm_regex_policy_t policy, 
    bcm_field_action_t action)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_action_remove_all(
    int unit, 
    bcm_regex_policy_t policy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_create(
    int unit, 
    int flags, 
    bcm_regex_policy_t *policy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_destroy(
    int unit, 
    bcm_regex_policy_t policy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_destroy_all(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_install(
    int unit, 
    bcm_regex_policy_t policy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_policer_attach(
    int unit, 
    bcm_regex_policy_t policy, 
    int level, 
    bcm_policer_t policer_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_policer_detach(
    int unit, 
    bcm_regex_policy_t policy, 
    int level)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_policer_detach_all(
    int unit, 
    bcm_regex_policy_t policy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_policer_get(
    int unit, 
    bcm_regex_policy_t policy, 
    int level, 
    bcm_policer_t *policer_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_remove(
    int unit, 
    bcm_regex_policy_t policy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_stat_attach(
    int unit, 
    bcm_regex_policy_t policy, 
    int stat_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_stat_detach(
    int unit, 
    bcm_regex_policy_t policy, 
    int stat_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_policy_stat_get(
    int unit, 
    bcm_regex_policy_t policy, 
    int *stat_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_report_register(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_report_unregister(
    int unit, 
    uint32 reports, 
    bcm_regex_report_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_session_add(
    int unit, 
    int flags, 
    bcm_regex_session_key_t *key, 
    bcm_regex_session_t *session)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_session_delete(
    int unit, 
    bcm_regex_session_key_t *key)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_session_delete_all(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_session_get(
    int unit, 
    int flags, 
    bcm_regex_session_key_t *key, 
    bcm_regex_session_t *session)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_session_policy_update(
    int unit, 
    int flags, 
    int flow_index, 
    bcm_regex_policy_t policy)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_stat_create(
    int unit, 
    int flags, 
    int nstat, 
    bcm_field_stat_t *stat_arr, 
    int *stat_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_stat_destroy(
    int unit, 
    int stat_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_stat_get(
    int unit, 
    bcm_regex_stat_t type, 
    uint64 *val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_REGEX)
int 
bcm_client_regex_stat_set(
    int unit, 
    bcm_regex_stat_t type, 
    uint64 val)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(BROADCOM_DEBUG)
int 
bcm_client_rx_show(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_sat_event_register(
    int unit, 
    bcm_sat_event_type_t event_type, 
    bcm_sat_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_sat_event_unregister(
    int unit, 
    bcm_sat_event_type_t event_type, 
    bcm_sat_event_cb cb)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_sat_gtf_packet_config(
    int unit, 
    bcm_sat_gtf_t gtf_id, 
    bcm_sat_gtf_packet_config_t *config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_sat_gtf_packet_config_get(
    int unit, 
    bcm_sat_gtf_t gtf_id, 
    bcm_sat_gtf_packet_config_t *config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_sat_gtf_packet_config_set(
    int unit, 
    bcm_sat_gtf_t gtf_id, 
    bcm_sat_gtf_packet_config_t *config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stat_counter_eviction_get(
    int unit, 
    uint32 flags, 
    bcm_stat_engine_t *engine, 
    bcm_stat_eviction_t *eviction)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stat_counter_eviction_set(
    int unit, 
    uint32 flags, 
    bcm_stat_engine_t *engine, 
    bcm_stat_eviction_t *eviction)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stat_counter_get(
    int unit, 
    uint32 flags, 
    bcm_stat_counter_input_data_t *stat_counter_input_data, 
    bcm_stat_counter_output_data_t *stat_counter_output_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stg_list(
    int unit, 
    bcm_stg_t **list, 
    int *count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stg_list_destroy(
    int unit, 
    bcm_stg_t *list, 
    int count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stg_vlan_list(
    int unit, 
    bcm_stg_t stg, 
    bcm_vlan_t **list, 
    int *count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stg_vlan_list_destroy(
    int unit, 
    bcm_vlan_t *list, 
    int count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_modmap_register(
    int unit, 
    bcm_stk_modmap_cb_t func)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_modmap_unregister(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_get(
    int unit, 
    bcm_port_t port, 
    uint32 *flags)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_modmap_group_get(
    int unit, 
    bcm_port_t port, 
    int *group)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_modmap_group_max_get(
    int unit, 
    int *max_group)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_modmap_group_set(
    int unit, 
    bcm_port_t port, 
    int group)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_port_set(
    int unit, 
    bcm_port_t port, 
    uint32 flags)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_update_callback_register(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_stk_update_callback_unregister(
    int unit, 
    bcm_stk_cb_f cb, 
    void *cookie)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_subport_linkphy_rx_error_register(
    int unit, 
    bcm_subport_linkphy_rx_errors_t errors, 
    bcm_subport_linkphy_rx_error_reg_info_t *reg_info, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_chip_info_get(
    int unit, 
    bcm_switch_chip_info_t info_type, 
    int max_size, 
    void *data_buf, 
    int *actual_size)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_dram_power_down_cb_register(
    int unit, 
    uint32 flags, 
    bcm_switch_dram_power_down_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_dram_power_down_cb_unregister(
    int unit, 
    bcm_switch_dram_power_down_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_event_register(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_event_unregister(
    int unit, 
    bcm_switch_event_cb_t cb, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_fec_property_get(
    int unit, 
    bcm_switch_fec_property_config_t *fec_config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_hard_reset_cb_register(
    int unit, 
    uint32 flags, 
    bcm_switch_hard_reset_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_hard_reset_cb_unregister(
    int unit, 
    bcm_switch_hard_reset_callback_t callback, 
    void *userdata)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_control_data_read(
    int unit, 
    int led_uc, 
    int offset, 
    uint8 *data, 
    int len)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_control_data_write(
    int unit, 
    int led_uc, 
    int offset, 
    const uint8 *data, 
    int len)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_fw_load(
    int unit, 
    int led_uc, 
    const uint8 *data, 
    int len)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_fw_start_get(
    int unit, 
    int led_uc, 
    int *data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_fw_start_set(
    int unit, 
    int led_uc, 
    int data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_port_to_uc_port_get(
    int unit, 
    int port, 
    int *led_uc, 
    int *led_uc_port)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_port_to_uc_port_set(
    int unit, 
    int port, 
    int led_uc, 
    int led_uc_port)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_led_uc_num_get(
    int unit, 
    int *led_uc_num)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_reflector_traverse(
    int unit, 
    uint32 flags, 
    bcm_switch_reflector_traverse_cb traverse_cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_stable_register(
    int unit, 
    bcm_switch_read_func_t rf, 
    bcm_switch_write_func_t wf)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_temperature_monitor_get(
    int unit, 
    int temperature_max, 
    bcm_switch_temperature_monitor_t *temperature_array, 
    int *temperature_count)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_wide_data_extension_add(
    int unit, 
    uint32 flags, 
    bcm_switch_wide_data_extension_info_t *info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_wide_data_extension_delete(
    int unit, 
    uint32 flags, 
    bcm_switch_wide_data_extension_info_t *info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_switch_wide_data_extension_get(
    int unit, 
    uint32 flags, 
    bcm_switch_wide_data_extension_info_t *info)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tdm_ingress_context_failover_get(
    int unit, 
    uint32 flags, 
    int nof_contexts, 
    int *context_ids, 
    int *context_en)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tdm_ingress_context_failover_set(
    int unit, 
    uint32 flags, 
    int nof_contexts, 
    int *context_ids, 
    int *context_en)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tdm_interface_config_get(
    int unit, 
    uint32 flags, 
    bcm_gport_t gport, 
    bcm_tdm_interface_config_t *interface_config)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tdm_interface_config_set(
    int unit, 
    uint32 flags, 
    bcm_gport_t gport, 
    bcm_tdm_interface_config_t *interface_config)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_dpll_bandwidth_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bandwidth_t *bandwidth)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_dpll_bandwidth_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bandwidth_t *bandwidth)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_dpll_bindings_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bindings_t *bindings)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_dpll_bindings_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_bindings_t *bindings)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_dpll_phase_control_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_phase_control_t *phase_control)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_dpll_phase_control_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_tdpll_dpll_phase_control_t *phase_control)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_dpll_reference_get(
    int unit, 
    int stack_id, 
    int max_num_dpll, 
    int *dpll_ref, 
    int *num_dpll)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_essm_code_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_essm_code_t  *essm_code)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_essm_code_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_essm_code_t  essm_code)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_holdover_ql_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t *ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_holdover_ql_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_mac_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_mac_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_ql_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t *ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_ql_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_esmc_quality_level_t ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_rx_enable_get(
    int unit, 
    int stack_id, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_rx_enable_set(
    int unit, 
    int stack_id, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_rx_portbitmap_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t *pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_rx_portbitmap_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_rx_state_machine(
    int unit, 
    int stack_id, 
    int ingress_port, 
    bcm_esmc_pdu_data_t *esmc_pdu_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_tx_enable_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_tx_enable_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_tx_portbitmap_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t *pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_esmc_tx_portbitmap_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    bcm_pbmp_t pbmp)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_event_callback_register(
    int unit, 
    int stack_id, 
    bcm_tdpll_event_cb_f event_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_event_callback_unregister(
    int unit, 
    int stack_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_best_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *best_clock)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_callback_register(
    int unit, 
    int stack_id, 
    bcm_tdpll_callback_type_t type, 
    bcm_tdpll_input_clock_cb callback)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_callback_unregister(
    int unit, 
    int stack_id, 
    bcm_tdpll_callback_type_t type)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_control(
    int unit, 
    int stack_id, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_enable_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_enable_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_frequency_error_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *freq_error_ppb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_frequency_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *clock_frequency, 
    uint32 *tsevent_frequency)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 clock_frequency, 
    uint32 tsevent_frequency)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_l1mux_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_l1mux_t *l1mux)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_l1mux_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_l1mux_t *l1mux)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_lockout_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *lockout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_lockout_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int lockout)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_mac_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_mac_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_mac_t *mac)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_monitor_callback_register(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_cb monitor_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_monitor_callback_unregister(
    int unit, 
    int stack_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_monitor_interval_get(
    int unit, 
    int stack_id, 
    uint32 *monitor_interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_monitor_interval_set(
    int unit, 
    int stack_id, 
    uint32 monitor_interval)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_monitor_threshold_get(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    uint32 *threshold)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_monitor_threshold_set(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    uint32 threshold)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_priority_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_priority_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_ql_change_callback_register(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_ql_change_cb ql_change_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_ql_change_callback_unregister(
    int unit, 
    int stack_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_ql_enabled_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *ql_enabled)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_ql_enabled_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int ql_enabled)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_ql_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_esmc_quality_level_t *ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_ql_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_esmc_quality_level_t ql)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_revertive_get(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int *revertive)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_revertive_set(
    int unit, 
    int stack_id, 
    int dpll_index, 
    int revertive)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_selector_callback_register(
    int unit, 
    int stack_id, 
    bcm_tdpll_input_clock_selector_cb selector_cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_selector_callback_unregister(
    int unit, 
    int stack_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_threshold_state_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_input_clock_monitor_type_t threshold_type, 
    int *threshold_state)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_valid_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *valid)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_input_clock_valid_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int valid)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_create(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_pbmp_t pbmp, 
    bcm_tdpll_dpll_bandwidth_t *bandwidth)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_deriv_frequency_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *deriv_frequency)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_deriv_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 deriv_frequency)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_enable_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_enable_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_holdover_data_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_data_t *hdata)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_holdover_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_frequency_correction_t hfreq)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_holdover_mode_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_mode_t *hmode)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_holdover_mode_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    bcm_tdpll_holdover_mode_t hmode)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_holdover_reset(
    int unit, 
    int stack_id, 
    int clock_index)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_synth_frequency_get(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 *synth_frequency, 
    uint32 *tsevent_frequency)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_PTP)
int 
bcm_client_tdpll_output_clock_synth_frequency_set(
    int unit, 
    int stack_id, 
    int clock_index, 
    uint32 synth_frequency, 
    uint32 tsevent_frequency)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_time_capture_cb_register(
    int unit, 
    bcm_time_if_t id, 
    bcm_time_capture_cb_type_t cb_type, 
    bcm_time_capture_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_capture_cb_unregister(
    int unit, 
    bcm_time_if_t id, 
    bcm_time_capture_cb_type_t cb_type)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_capture_enable_set(
    int unit, 
    bcm_time_if_t id, 
    bcm_time_capture_t *time_capture, 
    int enable, 
    int *capture_handle)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_heartbeat_register(
    int unit, 
    bcm_time_if_t id, 
    bcm_time_heartbeat_cb f, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_ts_counter_time_init(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_ts_offset_set(
    int unit, 
    int64 ts_offset, 
    uint64 ts_update_intv, 
    int ts_counter)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_ts_time_convert(
    int unit, 
    uint32 ts_val, 
    bcm_time_spec_t *time)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_time_ts_time_update(
    int unit)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tsn_event_notification_traverse(
    int unit, 
    bcm_tsn_event_notification_traverse_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tsn_event_register(
    int unit, 
    bcm_tsn_event_type_t event, 
    bcm_tsn_event_source_t *src, 
    bcm_tsn_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tsn_event_unregister(
    int unit, 
    bcm_tsn_event_type_t event, 
    bcm_tsn_event_source_t *src, 
    bcm_tsn_event_cb cb)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tsn_taf_event_register(
    int unit, 
    bcm_tsn_taf_event_types_t event_types, 
    int taf_gate, 
    bcm_tsn_taf_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_tsn_taf_event_unregister(
    int unit, 
    bcm_tsn_taf_event_types_t event_types, 
    int taf_gate, 
    bcm_tsn_taf_event_cb cb)
{
    return BCM_E_UNAVAIL;
}

#if defined(BROADCOM_DEBUG)
int 
bcm_client_tx_dv_dump(
    int unit, 
    void *dv_p)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_tx_pkt_l2_map(
    int unit, 
    bcm_pkt_t *pkt, 
    bcm_mac_t dest_mac, 
    int vid)
{
    return BCM_E_UNAVAIL;
}

#if defined(BROADCOM_DEBUG)
int 
bcm_client_tx_show(
    int unit)
{
    return BCM_E_UNAVAIL;
}
#endif

int 
bcm_client_txbeacon_destroy(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_init(
    int unit, 
    int uC)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_pkt_get(
    int unit, 
    bcm_txbeacon_t *txbeacon)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_pkt_setup(
    int unit, 
    bcm_txbeacon_t *txbeacon)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_start(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_stop(
    int unit, 
    bcm_txbeacon_pkt_id_t pkt_id)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_txbeacon_traverse(
    int unit, 
    bcm_txbeacon_traverse_cb_t trav_fn, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_vlan_list(
    int unit, 
    bcm_vlan_data_t **listp, 
    int *countp)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_vlan_list_by_pbmp(
    int unit, 
    bcm_pbmp_t ports, 
    bcm_vlan_data_t **listp, 
    int *countp)
{
    return BCM_E_UNAVAIL;
}

int 
bcm_client_vlan_list_destroy(
    int unit, 
    bcm_vlan_data_t *list, 
    int count)
{
    return BCM_E_UNAVAIL;
}

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_control_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_control_t type, 
    uint64 *value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_control_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_control_t type, 
    uint64 value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_flow_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int priority, 
    bcm_xflow_macsec_flow_id_t *flow_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_flow_default_policy_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_policy_id_t *policy_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_flow_destroy(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_flow_enable_get(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_flow_enable_set(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_flow_get(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int *priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_flow_set(
    int unit, 
    bcm_xflow_macsec_flow_id_t flow_id, 
    bcm_xflow_macsec_decrypt_flow_info_t *flow_info, 
    int priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_policy_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info, 
    bcm_xflow_macsec_policy_id_t *policy_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_policy_destroy(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_policy_get(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_policy_set(
    int unit, 
    bcm_xflow_macsec_policy_id_t policy_id, 
    bcm_xflow_macsec_decrypt_policy_info_t *policy_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_svtag_cpu_flex_map_enable_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    int index, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_svtag_cpu_flex_map_enable_set(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    int index, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_svtag_cpu_flex_map_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    int index, 
    bcm_xflow_macsec_svtag_cpu_flex_map_info_t *svtag_cpu_flex_map_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_decrypt_svtag_cpu_flex_map_set(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    int index, 
    bcm_xflow_macsec_svtag_cpu_flex_map_info_t *svtag_cpu_flex_map_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_event_deregister(
    int unit, 
    bcm_xflow_macsec_event_cb cb)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_event_register(
    int unit, 
    bcm_xflow_macsec_event_cb cb, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_handle_create(
    int unit, 
    bcm_xflow_macsec_handle_info_t *handle_info, 
    bcm_xflow_macsec_id_t *id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_handle_info_get(
    int unit, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_handle_info_t *handle_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_instance_pbmp_map_get(
    int unit, 
    int instance_max, 
    bcm_xflow_macsec_instance_pbmp_t *instance_pbmp_map, 
    int *instance_count)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_assoc_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_ipsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_assoc_id_t *assoc_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_assoc_destroy(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_assoc_get(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_ipsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_assoc_set(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_ipsec_secure_assoc_info_t *assoc_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_assoc_traverse(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_ipsec_secure_assoc_traverse_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_chan_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_ipsec_secure_chan_info_t *chan_info, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_chan_destroy(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_chan_get(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_ipsec_secure_chan_info_t *chan_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_chan_info_traverse(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_ipsec_chan_traverse_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_ipsec_secure_chan_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_ipsec_secure_chan_info_t *chan_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_mac_addr_control_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_mac_addr_control_t control_type, 
    bcm_xflow_macsec_mac_addr_info_t *control_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_mac_addr_control_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_mac_addr_control_t control_type, 
    bcm_xflow_macsec_mac_addr_info_t *control_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_mtu_get(
    int unit, 
    int flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_mtu_t mtu_sel, 
    uint32 *mtu)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_mtu_set(
    int unit, 
    int flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    uint32 mtu, 
    bcm_xflow_macsec_mtu_t *mtu_sel)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_port_control_get(
    int unit, 
    uint32 flags, 
    bcm_gport_t gport, 
    bcm_xflow_macsec_port_control_t control_type, 
    bcm_xflow_macsec_port_info_t *value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_port_control_set(
    int unit, 
    uint32 flags, 
    bcm_gport_t gport, 
    bcm_xflow_macsec_port_control_t control_type, 
    bcm_xflow_macsec_port_info_t *value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_port_info_get(
    int unit, 
    bcm_port_t port, 
    bcm_xflow_macsec_port_info_t *port_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_port_info_set(
    int unit, 
    bcm_port_t port, 
    bcm_xflow_macsec_port_info_t *port_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_port_map_info_get(
    int unit, 
    uint32 flags, 
    bcm_gport_t gport, 
    bcm_xflow_macsec_port_map_info_t *port_map_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_port_rsvd_secure_chan_get(
    int unit, 
    uint32 flags, 
    bcm_gport_t port, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_sectag_etype_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_sectag_ethertype_t sectag_etype_sel, 
    uint32 *sectag_etype)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_sectag_etype_set(
    int unit, 
    int flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    uint32 sectag_etype, 
    bcm_xflow_macsec_sectag_ethertype_t *sectag_etype_sel)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_assoc_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_assoc_id_t *assoc_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_assoc_destroy(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_assoc_get(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_assoc_set(
    int unit, 
    bcm_xflow_macsec_secure_assoc_id_t assoc_id, 
    bcm_xflow_macsec_secure_assoc_info_t *assoc_info)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_assoc_traverse(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_assoc_traverse_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_chan_create(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int priority, 
    bcm_xflow_macsec_secure_chan_id_t *chan_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_chan_destroy(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_chan_enable_get(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    int *enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_chan_enable_set(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    int enable)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_chan_get(
    int unit, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int *priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_chan_info_traverse(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_chan_traverse_cb callback, 
    void *user_data)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_secure_chan_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_secure_chan_id_t chan_id, 
    bcm_xflow_macsec_secure_chan_info_t *chan_info, 
    int priority)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_stat_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_stat_type_t  stat_type, 
    uint64 *value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_stat_multi_get(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    uint32 num_stats, 
    bcm_xflow_macsec_stat_type_t  *stat_type_array, 
    uint64 *value_array)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_stat_multi_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    uint32 num_stats, 
    bcm_xflow_macsec_stat_type_t  *stat_type_array, 
    uint64 *value_array)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_stat_set(
    int unit, 
    uint32 flags, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_stat_type_t  stat_type, 
    uint64 value)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_subport_id_get(
    int unit, 
    bcm_xflow_macsec_id_t id, 
    bcm_xflow_macsec_subport_id_t *macsec_subport_id)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_vlan_tpid_array_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_vlan_tpid_t *vlan_tpid)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_vlan_tpid_array_index_get(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    uint32 vlan_tpid, 
    uint8 *tpid_index_sel)
{
    return BCM_E_UNAVAIL;
}
#endif

#if defined(INCLUDE_XFLOW_MACSEC)
int 
bcm_client_xflow_macsec_vlan_tpid_array_set(
    int unit, 
    bcm_xflow_macsec_instance_id_t instance_id, 
    bcm_xflow_macsec_vlan_tpid_t *vlan_tpid)
{
    return BCM_E_UNAVAIL;
}
#endif

