/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:      ser.c
 * Purpose:   SER enable/detect and test functionality.
 * Requires:
 */
#include <shared/bsl.h>
#include <soc/drv.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/hurricane3.h>

/* Internal Use Only : Individually Test Purpose */
#define _HR3_SER_TEST_MMU  (1)
#define _HR3_SER_TEST_TCAM (1)
#define _HR3_SER_TEST_EP   (1)
#define _HR3_SER_TEST_IP0  (1)
#define _HR3_SER_TEST_IP1  (1)
#define _HR3_SER_TEST_IP2  (1)

/*
 * Chip specific SER information.
 */
static soc_ser_functions_t _hr3_ser_functions;

#define _SOC_SER_SKIP_HR3L  (0x1 << 0)
#define _SOC_SER_SKIP_FH2   (0x1 << 1)
#define _SOC_SER_SKIP_BH    (0x1 << 2)
#define _SOC_SER_SKIP_WH2   (0x1 << 3)

typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_PARITY_DUAL,
    _SOC_PARITY_TYPE_COUNTER,
    _SOC_PARITY_TYPE_PORT_XL,
    _SOC_PARITY_TYPE_MMU_SER,
    _SOC_PARITY_TYPE_MMU_ECC,
    _SOC_PARITY_TYPE_MMU_ECC_CBPH,/* 2-level ecc */
    _SOC_PARITY_TYPE_MMU_ECC_XQ, /* 2-level ecc */
    _SOC_PARITY_TYPE_MMU_PAR_E2EFC, /* par*/
    _SOC_PARITY_TYPE_MMU_PAR_WRED,/* 2-level par */
    _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP,/* 2-level ecc_correctable */
    _SOC_PARITY_TYPE_MMU_ECC_IPMCVLAN, /* ecc_correctable */
    _SOC_PARITY_TYPE_SER
} _soc_hr3_ser_info_type_t;

typedef struct _soc_hr3_ser_reg_s {
    soc_reg_t reg;
    char      *str;
    soc_mem_t mem;
} _soc_hr3_ser_reg_t;

typedef struct _soc_hr3_ser_info_s {
    _soc_hr3_ser_info_type_t    type;
    struct _soc_hr3_ser_info_s  *info; /* used for MMU */
    /* registers sets for parity/ecc group related */
    soc_field_t                 group_reg_enable_field;
    soc_field_t                 group_reg_status_field;
    soc_mem_t                   mem;
    char                        *mem_str;
    /* registers sets for parity/ecc enable*/
    soc_reg_t                   enable_reg;
    soc_field_t                 enable_field;
    soc_field_t                 *enable_field_list;
    /* registers sets for parity/ecc interrupt related */
    soc_reg_t                   intr_enable_reg;
    soc_field_t                 intr_enable_field;
    soc_field_t                 *intr_enable_field_list;
    soc_reg_t                   intr_status_reg;
    _soc_hr3_ser_reg_t          *intr_status_reg_list;
    soc_field_t                 intr_status_field;
    soc_reg_t                   intr_clr_reg;
    soc_field_t                 intr_clr_field;
    soc_reg_t                   intr2_valid_reg;
    soc_reg_t                   intr2_multi_err_reg;
    soc_reg_t                   intr2_clr_reg;
    uint32                      sku_skip;
}_soc_hr3_ser_info_t;

#if _HR3_SER_TEST_IP0
static _soc_hr3_ser_reg_t vlan_xlate_regs[] = {
    { VLAN_XLATE_PARITY_STATUS_0r, "",INVALIDm},
    { VLAN_XLATE_PARITY_STATUS_1r, "",INVALIDm},
    { INVALIDr }
};
#endif /* _HR3_SER_TEST_IP0 */
#if _HR3_SER_TEST_IP1
static _soc_hr3_ser_reg_t l3_entry_regs[] = {
    { L3_ENTRY_PARITY_STATUS_0r, "",INVALIDm},
    { L3_ENTRY_PARITY_STATUS_1r, "",INVALIDm},
    { INVALIDr }
};
static _soc_hr3_ser_reg_t l2_entry_regs[] = {
    { L2_ENTRY_PARITY_STATUS_0r, "",INVALIDm},
    { L2_ENTRY_PARITY_STATUS_1r, "",INVALIDm},
    { INVALIDr }
};
#endif /* _HR3_SER_TEST_IP1 */
#if _HR3_SER_TEST_EP
static _soc_hr3_ser_reg_t egr_vlan_xlate_regs[] = {
    { EGR_VLAN_XLATE_PARITY_STATUS_0r, "",INVALIDm},
    { EGR_VLAN_XLATE_PARITY_STATUS_1r, "",INVALIDm},
    { INVALIDr }
};
#endif /* _HR3_SER_TEST_EP */
static _soc_hr3_ser_info_t _soc_hr3_ip0_ser_info[] = {
#if _HR3_SER_TEST_IP0
    { _SOC_PARITY_TYPE_PARITY, NULL,
        PORT_TABLE_1BIT_ERR_INTRf, PORT_TABLE_1BIT_ERR_INTRf,
        PORT_TABm, NULL,
        PORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PORT_TABLE_PARITY_STATUS_INTRr, NULL, PARITY_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        PORT_TABLE_ECC_INTRf, PORT_TABLE_ECC_INTRf,
        INVALIDm, NULL,
        PORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PORT_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SYSTEM_CONFIG_PAR_ERRf, SYSTEM_CONFIG_PAR_ERRf,
        SYSTEM_CONFIG_TABLEm, NULL,
        SYSTEM_CONFIG_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SYSTEM_CONFIG_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SYSTEM_CONFIG_MODBASE_PAR_ERRf, SYSTEM_CONFIG_MODBASE_PAR_ERRf,
        SYSTEM_CONFIG_TABLE_MODBASEm, NULL,
        SYSTEM_CONFIG_TABLE_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SYSTEM_CONFIG_TABLE_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SOURCE_TRUNK_MAP_PARITY_ERRf, SOURCE_TRUNK_MAP_PARITY_ERRf,
        SOURCE_TRUNK_MAP_TABLEm, NULL,
        SOURCE_TRUNK_MAP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SOURCE_TRUNK_MAP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SOURCE_TRUNK_MAP_MODBASE_PARITY_ERRf, SOURCE_TRUNK_MAP_MODBASE_PARITY_ERRf,
        SOURCE_TRUNK_MAP_MODBASEm, NULL,
        SOURCE_TRUNK_MAP_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SOURCE_TRUNK_MAP_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_MOD_MAP_PAR_ERRf, ING_MOD_MAP_PAR_ERRf,
        ING_MOD_MAP_TABLEm, "ING_MOD_MAP",
        ING_MOD_MAP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_MOD_MAP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        LPORT_TABLE_ECC_INTRf, LPORT_TABLE_ECC_INTRf,
        INVALIDm, "LPORT_TABLE/LPORT_PROFILE_TABLE ECC",
        LPORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LPORT_TABLE_ECC_STATUS_INTRr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        LPORT_TABLE_1BIT_ERR_INTRf, LPORT_TABLE_1BIT_ERR_INTRf,
        LPORT_TABm, "LPORT_TABLE/LPORT_PROFILE_TABLE PARITY",
        LPORT_TABLE_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LPORT_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        UDF_OFFSET_PAR_ERRf, UDF_OFFSET_PAR_ERRf,
        FP_UDF_OFFSETm, NULL,
        UDF_OFFSET_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        UDF_OFFSET_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_ETAG_PCP_MAPPING_PAR_ERRf, ING_ETAG_PCP_MAPPING_PAR_ERRf,
        ING_ETAG_PCP_MAPPINGm, NULL,
        ING_ETAG_PCP_MAPPING_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_ETAG_PCP_MAPPING_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        VXLT_PAR_ERRf, VXLT_PAR_ERRf,
        VLAN_XLATEm, NULL,
        VLAN_XLATE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, vlan_xlate_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_PROTOCOL_DATA_PARITY_ERRf, VLAN_PROTOCOL_DATA_PARITY_ERRf,
        VLAN_PROTOCOL_DATAm, NULL,
        VLAN_PROTOCOL_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_PROTOCOL_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_SUBNET_DATA_PARITY_ERRf, VLAN_SUBNET_DATA_PARITY_ERRf,
        VLAN_SUBNETm, NULL,
        VLAN_SUBNET_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_SUBNET_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_SUBNET_DATA_PARITY_ERRf, VLAN_SUBNET_DATA_PARITY_ERRf,
        VLAN_SUBNET_DATA_ONLYm, NULL,
        VLAN_SUBNET_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_SUBNET_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VFP_POLICY_PAR_ERRf, VFP_POLICY_PAR_ERRf,
        VFP_POLICY_TABLEm, NULL,
        VFP_POLICY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VFP_POLICY_PARITY_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        (_SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_WH2)
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        LMEP_PAR_ERRf, LMEP_PAR_ERRf,
        LMEPm, NULL,
        LMEP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LMEP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        LMEP_DA_PAR_ERRf, LMEP_DA_PAR_ERRf,
        LMEP_DAm, NULL,
        LMEP_DA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        LMEP_DA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_PARITY_ERRf, VLAN_PARITY_ERRf,
        VLAN_TABm, NULL,
        VLAN_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_IIF_PAR_ERRf, L3_IIF_PAR_ERRf,
        L3_IIFm, NULL,
        L3_IIF_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_IIF_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_BH
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_STG_PARITY_ERRf, VLAN_STG_PARITY_ERRf,
        STG_TABm, NULL,
        VLAN_STG_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_STG_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        IARB_PKT_1BIT_ERR_INTRf, IARB_PKT_1BIT_ERR_INTRf,
        INVALIDm, "IARB_PKT",
        IARB_PKT_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IARB_PKT_ECC_STATUS_INTRr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
#endif /* _HR3_SER_TEST_IP0 */
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};
static _soc_hr3_ser_info_t _soc_hr3_ip1_ser_info[] = {
#if _HR3_SER_TEST_IP1
    { _SOC_PARITY_TYPE_PARITY, NULL,
        RMEP_PAR_ERRf, RMEP_PAR_ERRf,
        RMEPm, NULL,
        RMEP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        RMEP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3MC_PAR_ERRf, L3MC_PAR_ERRf,
        L3_IPMCm, NULL,
        L3MC_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3MC_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_BH
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        INITIAL_L3_ECMP_GROUP_PAR_ERRf, INITIAL_L3_ECMP_GROUP_PAR_ERRf,
        INITIAL_L3_ECMP_GROUPm, NULL,
        INITIAL_L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INITIAL_L3_ECMP_GROUP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_BH |
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        INITIAL_L3_ECMP_PAR_ERRf, INITIAL_L3_ECMP_PAR_ERRf,
        INITIAL_L3_ECMPm, NULL,
        INITIAL_L3_ECMP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INITIAL_L3_ECMP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 |  _SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_BH |
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        L3_ENTRY_PAR_ERRf, L3_ENTRY_PAR_ERRf,
        L3_ENTRY_ONLYm, NULL,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, l3_entry_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L2_USER_ENTRY_DATA_ONLY_PAR_ERRf, L2_USER_ENTRY_DATA_ONLY_PAR_ERRf,
        L2_USER_ENTRYm, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L2_USER_ENTRY_DATA_ONLY_PAR_ERRf, L2_USER_ENTRY_DATA_ONLY_PAR_ERRf,
        L2_USER_ENTRY_DATA_ONLYm, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L2_USER_ENTRY_DATA_ONLY_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        L2_ENTRY_PAR_ERRf, L2_ENTRY_PAR_ERRf,
        L2Xm, "L2_ENTRY/L2_ENTRY_ONLY",
        L2_ENTRY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, l2_entry_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_DEFIP_DATA_PAR_ERRf, L3_DEFIP_DATA_PAR_ERRf,
        L3_DEFIPm, NULL,
        L3_DEFIP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_DEFIP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_BH
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_DEFIP_DATA_PAR_ERRf, L3_DEFIP_DATA_PAR_ERRf,
        L3_DEFIP_DATA_ONLYm, NULL,
        L3_DEFIP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_DEFIP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_BH
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MAID_REDUCTION_PAR_ERRf, MAID_REDUCTION_PAR_ERRf,
        MAID_REDUCTIONm, NULL,
        MAID_REDUCTION_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MAID_REDUCTION_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MA_STATE_PAR_ERRf, MA_STATE_PAR_ERRf,
        MA_STATEm, NULL,
        MA_STATE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MA_STATE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        INITIAL_NHOP_PAR_ERRf, INITIAL_NHOP_PAR_ERRf,
        INITIAL_ING_L3_NEXT_HOPm, NULL,
        INITIAL_NHOP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INITIAL_NHOP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_BH
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L2MC_PAR_ERRf, L2MC_PAR_ERRf,
        L2MCm, NULL,
        L2MC_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L2MC_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MA_INDEX_PAR_ERRf, MA_INDEX_PAR_ERRf,
        MA_INDEXm, NULL,
        MA_INDEX_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MA_INDEX_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
#endif /* _HR3_SER_TEST_IP1 */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};
static _soc_hr3_ser_info_t _soc_hr3_ip2_ser_info[] = {
#if _HR3_SER_TEST_IP2
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_MASK_PAR_ERRf, EGR_MASK_PAR_ERRf,
        EGR_MASKm, NULL,
        EGR_MASK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_MASK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_MASK_MODBASE_PAR_ERRf, EGR_MASK_MODBASE_PAR_ERRf,
        EGR_MASK_MODBASEm, NULL,
        EGR_MASK_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_MASK_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        TRUNK_GROUP_PAR_ERRf, TRUNK_GROUP_PAR_ERRf,
        TRUNK_GROUPm, NULL,
        TRUNK_GROUP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        TRUNK_GROUP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_ECMP_PAR_ERRf, L3_ECMP_PAR_ERRf,
        L3_ECMPm, NULL,
        L3_ECMP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_ECMP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_BH | _SOC_SER_SKIP_HR3L |
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_ECMP_GROUP_PAR_ERRf, L3_ECMP_GROUP_PAR_ERRf,
        L3_ECMP_COUNTm, NULL,
        L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_ECMP_GROUP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_BH | _SOC_SER_SKIP_HR3L |
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        VLAN_PROFILE_2_PAR_ERRf, VLAN_PROFILE_2_PAR_ERRf,
        VLAN_PROFILE_2m, NULL,
        VLAN_PROFILE_2_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        VLAN_PROFILE_2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_STORM_CONTROL_PAR_ERRf, IFP_STORM_CONTROL_PAR_ERRf,
        FP_STORM_CONTROL_METERSm, NULL,
        IFP_STORM_CONTROL_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_STORM_CONTROL_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf, NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf,
        NONUCAST_TRUNK_BLOCK_MASKm, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        SRC_MODID_BLOCK_PAR_ERRf, SRC_MODID_BLOCK_PAR_ERRf,
        SRC_MODID_BLOCKm, NULL,
        SRC_MODID_BLOCK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        SRC_MODID_BLOCK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_METER_PAR_ERRf, IFP_METER_PAR_ERRf,
        FP_METER_TABLEm, NULL,
        IFP_METER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_METER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MODPORT_MAP_SW_PAR_ERRf, MODPORT_MAP_SW_PAR_ERRf,
        MODPORT_MAP_SWm, NULL,
        MODPORT_MAP_SW_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MODPORT_MAP_SW_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MODPORT_MAP_IM_PAR_ERRf, MODPORT_MAP_IM_PAR_ERRf,
        MODPORT_MAP_IMm, NULL,
        MODPORT_MAP_IM_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MODPORT_MAP_IM_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MODPORT_MAP_EM_PAR_ERRf, MODPORT_MAP_EM_PAR_ERRf,
        MODPORT_MAP_EMm, NULL,
        MODPORT_MAP_EM_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MODPORT_MAP_EM_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ALTERNATE_EMIRROR_BITMAP_PAR_ERRf, ALTERNATE_EMIRROR_BITMAP_PAR_ERRf,
        ALTERNATE_EMIRROR_BITMAPm, NULL,
        ALTERNATE_EMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        MAC_BLOCK_TABLE_PAR_ERRf, MAC_BLOCK_TABLE_PAR_ERRf,
        MAC_BLOCKm, "MAC_BLOCK_TABLE",
        MAC_BLOCK_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        MAC_BLOCK_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        TRUNK_EGR_MASK_PAR_ERRf, TRUNK_EGR_MASK_PAR_ERRf,
        TRUNK_EGR_MASKm, NULL,
        TRUNK_EGR_MASK_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        TRUNK_EGR_MASK_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        L3_MTU_VALUES_PAR_ERRf, L3_MTU_VALUES_PAR_ERRf,
        L3_MTU_VALUESm, NULL,
        L3_MTU_VALUES_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        L3_MTU_VALUES_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        OAM_LM_COUNTERS_PAR_ERRf, OAM_LM_COUNTERS_PAR_ERRf,
        OAM_LM_COUNTERSm, NULL,
        OAM_LM_COUNTERS_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        OAM_LM_COUNTERS_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_VLAN_COUNTER_PAR_ERRf, ING_VLAN_COUNTER_PAR_ERRf,
        ING_VLAN_COUNTER_TABLEm, NULL,
        ING_VLAN_COUNTER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_VLAN_COUNTER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        TRUNK_BITMAP_TABLE_PAR_ERRf, TRUNK_BITMAP_TABLE_PAR_ERRf,
        TRUNK_BITMAPm, NULL,
        TRUNK_BITMAP_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        TRUNK_BITMAP_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        ING_NHOP_PAR_ERRf, ING_NHOP_PAR_ERRf,
        ING_L3_NEXT_HOPm, NULL,
        ING_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        ING_L3_NEXT_HOP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_POLICY_PAR_ERRf, IFP_POLICY_PAR_ERRf,
        FP_POLICY_TABLEm, NULL,
        IFP_POLICY_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_POLICY_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        IFP_COUNTER_PAR_ERRf, IFP_COUNTER_PAR_ERRf,
        FP_COUNTER_TABLEm, NULL,
        IFP_COUNTER_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        IFP_COUNTER_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
#endif /* _HR3_SER_TEST_IP2 */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};
static _soc_hr3_ser_info_t _soc_hr3_ep_ser_info[] = {
#if _HR3_SER_TEST_EP
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_EFP_POLICY_TABLE_PAR_ERRf, EGR_EFP_POLICY_TABLE_PAR_ERRf,
        EFP_POLICY_TABLEm, NULL,
        EFP_POLICY_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EFP_POLICY_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_EFP_METER_TABLE_PAR_ERRf, EGR_EFP_METER_TABLE_PAR_ERRf,
        EFP_METER_TABLEm, NULL,
        EFP_METER_TABLE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EFP_METER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_PERQ_XMT_COUNTERS_PAR_ERRf, EGR_PERQ_XMT_COUNTERS_PAR_ERRf,
        EGR_PERQ_XMT_COUNTERSm, NULL,
        EGR_EDATABUF_PARITY_CONTROLr, EGR_PERQ_XMT_COUNTERS_PAR_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_PERQ_XMT_COUNTERS_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EFP_COUNTER_TABLE_PAR_ERRf, EFP_COUNTER_TABLE_PAR_ERRf,
        EFP_COUNTER_TABLEm, NULL,
        EGR_EDATABUF_PARITY_CONTROLr, EFP_COUNTER_TABLE_PAR_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EFP_COUNTER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_NHOP_PAR_ERRf, EGR_NHOP_PAR_ERRf,
        EGR_L3_NEXT_HOPm, NULL,
        EGR_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_L3_NEXT_HOP_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_L3_INTF_PAR_ERRf, EGR_L3_INTF_PAR_ERRf,
        EGR_L3_INTFm, NULL,
        EGR_L3_INTF_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_L3_INTF_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_VLAN_PAR_ERRf, EGR_VLAN_PAR_ERRf,
        EGR_VLANm, NULL,
        EGR_VLAN_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_VLAN_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_VLAN_STG_PAR_ERRf, EGR_VLAN_STG_PAR_ERRf,
        EGR_VLAN_STGm, NULL,
        EGR_VLAN_STG_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_VLAN_STG_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY_DUAL, NULL,
        EGR_VXLT_PAR_ERRf, EGR_VXLT_PAR_ERRf,
        EGR_VLAN_XLATEm, NULL,
        EGR_VLAN_XLATE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, egr_vlan_xlate_regs, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_ETAG_PCP_DE_MAPPING_PAR_ERRf, EGR_ETAG_PCP_DE_MAPPING_PAR_ERRf,
        EGR_ETAG_PCP_MAPPINGm, NULL,
        EGR_ETAG_PCP_DE_MAPPING_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_ETAG_PCP_DE_MAPPING_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GPP_ATTRIBUTES_PAR_ERRf, EGR_GPP_ATTRIBUTES_PAR_ERRf,
        EGR_GPP_ATTRIBUTESm, NULL,
        EGR_GPP_ATTRIBUTES_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GPP_ATTRIBUTES_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf, EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_MODBASEm, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_HEADER_ENCAP_DATA_PAR_ERRf, EGR_HEADER_ENCAP_DATA_PAR_ERRf,
        EGR_HEADER_ENCAP_DATAm, NULL,
        EGR_HEADER_ENCAP_DATA_PARITY_CONTROLr, PARITY_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_HEADER_ENCAP_DATA_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_PER_Q_ECN_MARKED_PAR_ERRf, EGR_PER_Q_ECN_MARKED_PAR_ERRf,
        EGR_PER_Q_ECN_MARKEDm, NULL,
        EGR_EDATABUF_PARITY_CONTROLr, EGR_PER_Q_ECN_MARKED_PAR_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_PER_Q_ECN_MARKED_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_PARITY, NULL,
        EGR_VLAN_COUNTER_TABLE_PAR_ERRf, EGR_VLAN_COUNTER_TABLE_PAR_ERRf,
        EGR_VLAN_COUNTER_TABLEm, NULL,
        EGR_EDATABUF_PARITY_CONTROLr, EGR_VLAN_COUNTER_TABLE_PAR_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_VLAN_COUNTER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    /* disable ser on EGR_MOD_MAP_TABLEm */
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_INITBUF_DBE_PAR_ERRf, EGR_INITBUF_DBE_PAR_ERRf,
        INVALIDm, "EGR_INITBUF Double-Bit error",
        EGR_INITBUF_ECC_CONTROLr, ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_INITBUF_ECC_STATUS_DBEr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_CM_PAR_ERRf, EGR_CM_PAR_ERRf,
        INVALIDm, "EP_EDB_CM_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_CM_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_GP0_PAR_ERRf, EGR_GP0_PAR_ERRf,
        INVALIDm, "EP_EDB_GP0_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, GP0_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GP0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_GP1_PAR_ERRf, EGR_GP1_PAR_ERRf,
        INVALIDm, "EP_EDB_GP1_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, GP1_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GP1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_GP2_PAR_ERRf, EGR_GP2_PAR_ERRf,
        INVALIDm, "EP_EDB_GP2_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, GP2_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GP2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_GP3_PAR_ERRf, EGR_GP3_PAR_ERRf,
        INVALIDm, "EP_EDB_GP3_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, GP3_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GP3_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_GP4_PAR_ERRf, EGR_GP4_PAR_ERRf,
        INVALIDm, "EP_EDB_GP4_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, GP4_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_GP4_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_FH2 | _SOC_SER_SKIP_HR3L | _SOC_SER_SKIP_BH
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_XP0_PAR_ERRf, EGR_XP0_PAR_ERRf,
        INVALIDm, "EP_EDB_XP0_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XP0_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XP0_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_XP1_PAR_ERRf, EGR_XP1_PAR_ERRf,
        INVALIDm, "EP_EDB_XP1_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XP1_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XP1_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_XP2_PAR_ERRf, EGR_XP2_PAR_ERRf,
        INVALIDm, "EP_EDB_XP2_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XP2_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XP2_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        EGR_XP3_PAR_ERRf, EGR_XP3_PAR_ERRf,
        INVALIDm, "EP_EDB_XP0_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, XP3_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_XP3_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        _SOC_SER_SKIP_WH2
    },
    { _SOC_PARITY_TYPE_COUNTER, NULL,
        EGR_STATS_COUNTER_TABLE_PAR_ERRf, EGR_STATS_COUNTER_TABLE_PAR_ERRf,
        INVALIDm, "TDBGC0-TDBGC11",
        EGR_EDATABUF_PARITY_CONTROLr,EGR_STATS_COUNTER_TABLE_PAR_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        EGR_STATS_COUNTER_TABLE_PARITY_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
#endif /* _HR3_SER_TEST_EP */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};
#if _HR3_SER_TEST_MMU
static _soc_hr3_ser_reg_t cbppkthdr_regs[] = {
    { CBPPKTHDR_ERRPTR0r, "CBPPKTHD[0:126]",INVALIDm},
    { CBPPKTHDR_ERRPTR1r, "CBPPKTHD[127:253]",INVALIDm},
    { CBPPKTHDR_ERRPTR2r, "CBPPKTHD[254:286]",INVALIDm},
    { CBPPKTHDR_ERRPTR3r, "CBPPKTHD[287:322]",INVALIDm},
    { INVALIDr }
};
static _soc_hr3_ser_reg_t wred_regs[] = {
    { WRED_MARK_THD_PARITY_ERR_PTRr, "WRED MARK THD", MMU_WRED_MARK_THDm},
    { WRED_DROP_PROFILE_GREEN_PARITY_ERR_PTRr, "WRED DROP PROFILE GREEN", MMU_WRED_DROP_PROFILE_GREENm},
    { WRED_DROP_PROFILE_YELLOW_PARITY_ERR_PTRr, "WRED_DROP_PROFILE YELLOW", MMU_WRED_DROP_PROFILE_YELLOWm},
    { WRED_DROP_PROFILE_RED_PARITY_ERR_PTRr, "WRED DROP PROFILE RED", MMU_WRED_DROP_PROFILE_REDm},
    { WRED_MARK_PROFILE_GREEN_PARITY_ERR_PTRr, "WRED MARK PROFILE GREEN", MMU_WRED_MARK_PROFILE_GREENm},
    { WRED_MARK_PROFILE_YELLOW_PARITY_ERR_PTRr, "WRED MARK PROFILE YELLOW", MMU_WRED_MARK_PROFILE_YELLOWm},
    { WRED_MARK_PROFILE_RED_PARITY_ERR_PTRr, "WRED MARK PROFILE RED", MMU_WRED_MARK_PROFILE_REDm},
    { WRED_AVG_QSIZE_PARITY_ERR_PTRr, "WRED AVG QSIZE", MMU_WRED_AVG_QSIZEm},
    { WRED_CONFIG_PARITY_ERR_PTRr, "WRED CONFIG", MMU_WRED_CONFIGm},
    { INVALIDr }
};
static _soc_hr3_ser_reg_t ipmcgroup_regs[] = {
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "", INVALIDm },
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP2", MMU_IPMC_GROUP_TBL2m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP3", MMU_IPMC_GROUP_TBL3m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP4", MMU_IPMC_GROUP_TBL4m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP5", MMU_IPMC_GROUP_TBL5m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP6", MMU_IPMC_GROUP_TBL6m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP7", MMU_IPMC_GROUP_TBL7m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP8", MMU_IPMC_GROUP_TBL8m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP9", MMU_IPMC_GROUP_TBL9m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP10", MMU_IPMC_GROUP_TBL10m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP11", MMU_IPMC_GROUP_TBL11m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP12", MMU_IPMC_GROUP_TBL12m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP13", MMU_IPMC_GROUP_TBL13m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP14", MMU_IPMC_GROUP_TBL14m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP15", MMU_IPMC_GROUP_TBL15m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP16", MMU_IPMC_GROUP_TBL16m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP17", MMU_IPMC_GROUP_TBL17m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP18", MMU_IPMC_GROUP_TBL18m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP19", MMU_IPMC_GROUP_TBL19m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP20", MMU_IPMC_GROUP_TBL20m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP21", MMU_IPMC_GROUP_TBL21m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP22", MMU_IPMC_GROUP_TBL22m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP23", MMU_IPMC_GROUP_TBL23m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP24", MMU_IPMC_GROUP_TBL24m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP25", MMU_IPMC_GROUP_TBL25m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP26", MMU_IPMC_GROUP_TBL26m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP27", MMU_IPMC_GROUP_TBL27m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP28", MMU_IPMC_GROUP_TBL28m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP29", MMU_IPMC_GROUP_TBL29m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP30", MMU_IPMC_GROUP_TBL30m},
    { IPMC_GROUP_ERR_PTRr, "IPMC_GROUP31", MMU_IPMC_GROUP_TBL31m},
    { INVALIDr }
};
#endif /*_HR3_SER_TEST_MMU */

static _soc_hr3_ser_info_t _soc_hr3_mmu_ser_info[] = {
#if _HR3_SER_TEST_MMU
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CELLECCERRORINTMASKf, CELLECCERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CBPCELLERRPTRr, NULL, INVALIDf,
        INVALIDr ,CELLECCERROR_CLRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CBPCELLHDRPARITYERRORINTMASKf, CBPCELLHDRPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CBPCELLHDRPARITYERRPTRr, NULL, INVALIDf,
        INVALIDr, CBPCELLHDRPARITYERROR_CLRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CFAPPARITYERRORINTMASKf, CFAPPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CFAPPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, CFAPPARITYERROR_CLRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC, NULL,
        CCPPARITYERRORINTMASKf, CCPPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        CCPPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, CCPPARITYERROR_CLRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_CBPH, NULL,
        CBPPKTHDRPARITYERRORINTMASKf, CBPPKTHDRPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, cbppkthdr_regs, INVALIDf,
        INVALIDr, CBPPKTHDRPARITYERROR_CLRf,
        CBPPKTHDR_ERR_VLDr, INVALIDr, CBPPKTHDR_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_XQ, NULL,
        XQPARITYERRORINTMASKf, XQPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        XQPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, XQPARITYERROR_CLRf,
        XQ_ERR_VLDr, XQ_MULTI_ERRr, XQ_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_XQ, NULL,
        XQFLLPARITYERRORINTMASKf, XQFLLPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        XQFLLPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, XQFLLPARITYERROR_CLRf,
        XQFLL_ERR_VLDr, XQFLL_MULTI_ERRr, XQFLL_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_E2EFC, NULL,
        E2EFCPARITYERRORINTMASKf, E2EFCPARITYERRORf,
        INVALIDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        E2EFC_PARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, E2EFCPARITYERROR_CLRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_THDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_DROP_PROFILE_GREENm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_DROP_PROFILE_YELLOWm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_DROP_PROFILE_REDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_PROFILE_GREENm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_PROFILE_YELLOWm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_MARK_PROFILE_REDm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_AVG_QSIZEm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_PAR_WRED, NULL,
        WREDPARITYERRORINTMASKf, WREDPARITYERRORf,
        MMU_WRED_CONFIGm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, wred_regs, INVALIDf,
        INVALIDr, WREDPARITYERROR_CLRf,
        WRED_PARITY_ERR_STATUSr, INVALIDr, WRED_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL2m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL3m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL4m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL5m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL6m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL7m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL8m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL9m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL10m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL11m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL12m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL13m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL14m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL15m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL16m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL17m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL18m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL19m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL20m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL21m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL22m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL23m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL24m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL25m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL26m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL27m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL28m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL29m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL30m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },
    { _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP, NULL,
        IPMCGROUPPARITYERRORINTMASKf, IPMCGROUPPARITYERRORf,
        MMU_IPMC_GROUP_TBL31m, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, ipmcgroup_regs, INVALIDf,
        INVALIDr, IPMCGROUPPARITYERROR_CLRf,
        IPMC_GROUP_ERR_VLDr, IPMC_GROUP_MULTI_ERRr, IPMC_GROUP_ERR_CLRr,
        0
    },

    { _SOC_PARITY_TYPE_MMU_ECC_IPMCVLAN, NULL,
        IPMCVLANXPORTPARITYERRORINTMASKf,IPMCVLANXPORTPARITYERRORf,
        MMU_IPMC_VLAN_TBLm, NULL,
        INVALIDr, INVALIDf, NULL,
        INVALIDr, INVALIDf, NULL,
        IPMCPARITYERRORPTRr, NULL, INVALIDf,
        INVALIDr, IPMCVLANXPORTPARITYERROR_CLRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
#endif /*_HR3_SER_TEST_MMU */
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */

};

static _soc_hr3_ser_info_t _soc_hr3_mmu_top_ser_info[] = {
    { _SOC_PARITY_TYPE_MMU_SER, _soc_hr3_mmu_ser_info,
        INVALIDf, INVALIDf,
        INVALIDm, "MMU MEM PAR",
        MISCCONFIGr, PARITY_CHECK_ENf, NULL,
        MEMFAILINTMASKr, INVALIDf, NULL,
        MEMFAILINTSTATUSr, NULL, INVALIDf,
        MEMFAILINT_CLRr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_hr3_ser_info_t _soc_hr3_xlport_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL,
        MIB_RX_MEM_ERRf, MIB_RX_MEM_ERRf,
        INVALIDm, NULL,
        XLPORT_ECC_CONTROLr, MIB_RSC_MEM_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        XLPORT_MIB_RSC0_ECC_STATUSr, NULL, ECC_ERRf,
        XLPORT_INTR_STATUSr, MIB_RX_MEM_ERRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        MIB_TX_MEM_ERRf, MIB_TX_MEM_ERRf,
        INVALIDm, NULL,
        XLPORT_ECC_CONTROLr, MIB_TSC_MEM_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        XLPORT_MIB_TSC0_ECC_STATUSr, NULL, ECC_ERRf,
        XLPORT_INTR_STATUSr, MIB_TX_MEM_ERRf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_hr3_ser_info_t _soc_hr3_pgw_xlport_ser_info[] = {
    { _SOC_PARITY_TYPE_PORT_XL, _soc_hr3_xlport_ser_info,
        PM_INTRf, PM_INTRf,
        INVALIDm, "XL PORT INTR",
        INVALIDr, INVALIDf, NULL,
        XLPORT_INTR_ENABLEr, INVALIDf, NULL,
        XLPORT_INTR_STATUSr, NULL, INVALIDf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO_DBEf, RXFIFO_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_RXFIFO_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO0_DBEf, TXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO0_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO1_DBEf, TXFIFO1_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO1_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO2_DBEf, TXFIFO2_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO2_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO3_DBEf, TXFIFO3_DBEf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO3_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO0_DBE_Hf, TXFIFO0_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO0_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO1_DBE_Hf, TXFIFO1_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO1_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO2_DBE_Hf, TXFIFO2_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO2_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO3_DBE_Hf, TXFIFO3_DBE_Hf,
        INVALIDm, NULL,
        PGW_XL_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_XL_TXFIFO3_ECC_DBE_STATUS_Hr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

static _soc_hr3_ser_info_t _soc_hr3_pgw_gport_ser_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO0_DBEf, TXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO0_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO1_DBEf, TXFIFO1_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO1_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO2_DBEf, TXFIFO2_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO2_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        TXFIFO3_DBEf, TXFIFO3_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, TXFIFO_ECC_ENf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_TXFIFO3_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO0_DBEf, RXFIFO0_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO0_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO1_DBEf, RXFIFO1_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO1_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO2_DBEf, RXFIFO2_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO2_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_ECC, NULL,
        RXFIFO3_DBEf, RXFIFO3_DBEf,
        INVALIDm, NULL,
        PGW_GE_ECC_CONTROLr, RXFIFO_ECC_ENABLEf, NULL,
        INVALIDr, INVALIDf, NULL,
        PGW_GE_RXFIFO3_ECC_DBE_STATUSr, NULL, ECC_ERRf,
        INVALIDr, INVALIDf,
        INVALIDr, INVALIDr, INVALIDr,
        0
    },
    { _SOC_PARITY_TYPE_NONE }, /* table terminator */
};

/* from FORMAT CMIC_PARITY_INTR_STATUS */
#define _HR3_PAR_MMU       (0)
#define _HR3_PAR_EP        (1)
#define _HR3_PAR_IP0       (2)
#define _HR3_PAR_IP1       (3)
#define _HR3_PAR_IP2       (4)
#define _WH2_PAR_GXP2      (6)
#define _HR3_PAR_XLP0      (6)
#define _HR3_PAR_XLP1      (7)
#define _HR3_PAR_GXP0      (8)
#define _HR3_PAR_GXP1      (9)

#define _HR3_X_TO_CMIC_INTR(bit) (1<<(bit) ) /* Bit 0-31  */

typedef struct _soc_hr3_ser_route_block_s {
    uint32          cmic_bit;
    soc_block_t     blocktype;
    uint8           id;
    soc_reg_t       enable_reg;
    soc_reg_t       status_reg;
    void            *info;
} _soc_hr3_ser_route_block_t;

STATIC const _soc_hr3_ser_route_block_t
    *_soc_hr3_ser_route_blocks[SOC_MAX_NUM_DEVICES] = {NULL};

STATIC const _soc_hr3_ser_route_block_t
_soc_hr3_ser_route_blocks_template[] = {
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_MMU), SOC_BLK_MMU, 0,
        INVALIDr, INVALIDr,
        _soc_hr3_mmu_top_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_EP), SOC_BLK_EPIPE, 0,
        EGR_INTR_ENABLE_64r, EGR_INTR_STATUS_64r,
        _soc_hr3_ep_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_IP0), SOC_BLK_IPIPE, 0,
        IP0_INTR_ENABLEr, IP0_INTR_STATUSr,
        _soc_hr3_ip0_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_IP1), SOC_BLK_IPIPE, 0,
        IP1_INTR_ENABLEr, IP1_INTR_STATUSr,
        _soc_hr3_ip1_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_IP2), SOC_BLK_IPIPE, 0,
        IP2_INTR_ENABLEr, IP2_INTR_STATUSr,
        _soc_hr3_ip2_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_XLP0), SOC_BLK_XLPORT, 0,
        PGW_XL_INTR_ENABLEr, PGW_XL_INTR_STATUSr,
        _soc_hr3_pgw_xlport_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_XLP1), SOC_BLK_XLPORT, 1,
        PGW_XL_INTR_ENABLEr, PGW_XL_INTR_STATUSr,
        _soc_hr3_pgw_xlport_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_GXP0), SOC_BLK_PGW_GE, 0,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_hr3_pgw_gport_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_GXP1), SOC_BLK_PGW_GE, 1,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_hr3_pgw_gport_ser_info},
    { 0 } /* table terminator */
};

STATIC const _soc_hr3_ser_route_block_t
_soc_wh2_ser_route_blocks_template[] = {
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_MMU), SOC_BLK_MMU, 0,
        INVALIDr, INVALIDr,
        _soc_hr3_mmu_top_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_EP), SOC_BLK_EPIPE, 0,
        EGR_INTR_ENABLE_64r, EGR_INTR_STATUS_64r,
        _soc_hr3_ep_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_IP0), SOC_BLK_IPIPE, 0,
        IP0_INTR_ENABLEr, IP0_INTR_STATUSr,
        _soc_hr3_ip0_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_IP1), SOC_BLK_IPIPE, 0,
        IP1_INTR_ENABLEr, IP1_INTR_STATUSr,
        _soc_hr3_ip1_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_IP2), SOC_BLK_IPIPE, 0,
        IP2_INTR_ENABLEr, IP2_INTR_STATUSr,
        _soc_hr3_ip2_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_GXP0), SOC_BLK_PGW_GE, 0,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_hr3_pgw_gport_ser_info},
    {_HR3_X_TO_CMIC_INTR(_HR3_PAR_GXP1), SOC_BLK_PGW_GE, 1,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_hr3_pgw_gport_ser_info},
    {_HR3_X_TO_CMIC_INTR(_WH2_PAR_GXP2), SOC_BLK_PGW_GE, 2,
        PGW_GE_INTR_ENABLEr, PGW_GE_INTR_STATUSr,
        _soc_hr3_pgw_gport_ser_info},
    { 0 } /* table terminator */
};

static int
soc_hr3_ser_route_blocks_init(int unit)
{
    if (soc_feature(unit, soc_feature_wh2)) {
        /* Wolfhound2 */
        _soc_hr3_ser_route_blocks[unit] = _soc_wh2_ser_route_blocks_template;
    } else {
        /* Hurricane3 */
        _soc_hr3_ser_route_blocks[unit] = _soc_hr3_ser_route_blocks_template;
    }

    return SOC_E_NONE;
}


STATIC int
_soc_hr3_ser_process_is_per_port_mem(
    int unit,
    _soc_hr3_ser_info_type_t type)
{
    if (type == _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP) {
        return TRUE;
    }
    return FALSE;
}

/* Skip those MMU ports (memories) which logical ports don't exist */
STATIC int
_soc_hr3_ser_process_skip_disabled_mmu_port(
    int unit,
    _soc_hr3_ser_info_t *info)
{
    int logical_port = 0;
    _soc_hr3_ser_reg_t *reg_ptr;
    int ptr;

    if (NULL == info) {
        return TRUE;
    }

    if (info->type == _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP &&
        info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return FALSE;
    }

    for (ptr = 0; reg_ptr[ptr].reg != INVALIDr; ptr++) {
        if (reg_ptr[ptr].mem == info->mem) {
            break;
        }
        logical_port++;
    }
    if (!SOC_PORT_VALID(unit, logical_port)) {
        return TRUE;
    }
    return FALSE;
}

STATIC int
_soc_hr3_ser_mem_skip(int unit, _soc_hr3_ser_info_t *info)
{
    int sku;
    int skip = FALSE;

    if (NULL == info) {
        return TRUE;
    }
    if (soc_feature(unit, soc_feature_wh2)) {
        if (info->sku_skip & _SOC_SER_SKIP_WH2) {
            skip = TRUE;
        }
    } else {
        (void)soc_hurricane3_chip_sku_get(unit, &sku);

        switch (sku){
            case (SOC_HR3_SKU_HURRICANE3LITE):
                if (info->sku_skip & _SOC_SER_SKIP_HR3L) {
                    skip = TRUE;
                }
                break;
            case (SOC_HR3_SKU_BUCKHOUND):
                if (info->sku_skip & _SOC_SER_SKIP_BH) {
                    skip = TRUE;
                }
                break;
            case (SOC_HR3_SKU_FOXHOUND2):
                if (info->sku_skip & _SOC_SER_SKIP_FH2) {
                    skip = TRUE;
                }
                break;
            default:
                {
                    skip = FALSE;
                    break;
                }
        };
    }
    /* skip invalid logical port */
    if (_soc_hr3_ser_process_is_per_port_mem(unit, info->type)) {
        if (_soc_hr3_ser_process_skip_disabled_mmu_port(unit, info)) {
            skip = TRUE;
        }
    }
    return skip;
}

STATIC int
_soc_hr3_ser_2bit_ecc_mem(int unit, soc_mem_t memTable)
{
    int is_2bit_ecc_mem = FALSE;
    /* FOR _SOC_PARITY_TYPE_ECC_DUAL */
    switch (memTable){
        case MMU_IPMC_GROUP_TBL2m:
        case MMU_IPMC_GROUP_TBL3m:
        case MMU_IPMC_GROUP_TBL4m:
        case MMU_IPMC_GROUP_TBL5m:
        case MMU_IPMC_GROUP_TBL6m:
        case MMU_IPMC_GROUP_TBL7m:
        case MMU_IPMC_GROUP_TBL8m:
        case MMU_IPMC_GROUP_TBL9m:
        case MMU_IPMC_GROUP_TBL10m:
        case MMU_IPMC_GROUP_TBL11m:
        case MMU_IPMC_GROUP_TBL12m:
        case MMU_IPMC_GROUP_TBL13m:
        case MMU_IPMC_GROUP_TBL14m:
        case MMU_IPMC_GROUP_TBL15m:
        case MMU_IPMC_GROUP_TBL16m:
        case MMU_IPMC_GROUP_TBL17m:
        case MMU_IPMC_GROUP_TBL18m:
        case MMU_IPMC_GROUP_TBL19m:
        case MMU_IPMC_GROUP_TBL20m:
        case MMU_IPMC_GROUP_TBL21m:
        case MMU_IPMC_GROUP_TBL22m:
        case MMU_IPMC_GROUP_TBL23m:
        case MMU_IPMC_GROUP_TBL24m:
        case MMU_IPMC_GROUP_TBL25m:
        case MMU_IPMC_GROUP_TBL26m:
        case MMU_IPMC_GROUP_TBL27m:
        case MMU_IPMC_GROUP_TBL28m:
        case MMU_IPMC_GROUP_TBL29m:
        case MMU_IPMC_GROUP_TBL30m:
        case MMU_IPMC_GROUP_TBL31m:
        case MMU_IPMC_VLAN_TBLm:
            is_2bit_ecc_mem = TRUE;
            break;
        default:
            is_2bit_ecc_mem = FALSE;
            break;
    };
    return is_2bit_ecc_mem;
}

STATIC void
_soc_hr3_mem_parity_info(int unit, int block_info_idx, int pipe,
                         soc_field_t field_enum, uint32 *minfo)
{
    *minfo = (SOC_BLOCK2SCH(unit, block_info_idx) << SOC_ERROR_BLK_BP)
        | ((pipe & 0xff) << SOC_ERROR_PIPE_BP)
        | (field_enum & SOC_ERROR_FIELD_ENUM_MASK);
}

#define _SOC_HR3_MMU_E2EFC_MAX     4
static soc_reg_t e2efc_regs[_SOC_HR3_MMU_E2EFC_MAX] = {
      INVALIDr,
      E2EFC_CNT_SET_LIMITr,
      E2EFC_CNT_RESET_LIMITr,
      E2EFC_CNT_DISC_LIMITr
};

STATIC int
_soc_hr3_ser_process_mmu_e2efc(int unit,_soc_hr3_ser_info_t *info_list,
                             int info_index, int block_info_idx, char *msg)
{
    _soc_hr3_ser_info_t *info;
    soc_reg_t status_reg;
    uint32  intr_status;
    int index, mem_id;
    uint32 minfo;
    _soc_ser_correct_info_t spci;

    info = &info_list[info_index];
    status_reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, status_reg, REG_PORT_ANY, 0,
                       &intr_status));
    mem_id = soc_reg_field_get(unit, status_reg,
                                   intr_status, MEM_IDf);
    /* CHECK if the error is valid */
    if (mem_id == 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: parity hardware inconsistency\n"),
                   msg));
        return SOC_E_NONE;
    }
    index = soc_reg_field_get(unit, status_reg, intr_status, ENTRY_INDEXf);
    _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);
    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY,
                       index, minfo);
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "unit %d MMU E2EFC entry %d parity error\n"),
               unit, index));
    sal_memset(&spci, 0, sizeof(_soc_ser_correct_info_t));
    spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
    spci.reg = e2efc_regs[mem_id];
    spci.mem = INVALIDm;
    spci.blk_type = SOC_BLK_MMU;
    spci.index = index;
    spci.detect_time = sal_time_usecs();
    (void)soc_ser_correction(unit, &spci);

    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_mmu_group_correct(int unit,_soc_hr3_ser_info_t *info_list,
                                       int info_index, int block_info_idx,
                                       char *msg, int report_type)
{
    _soc_hr3_ser_info_t *info;
    _soc_hr3_ser_reg_t *reg_ptr;
    soc_reg_t valid_reg, status_reg, clear_reg;
    soc_reg_t multi_err_reg = INVALIDr;
    uint32  reg_val, valid_val;
    int index, double_bit = 0, multiple = 0;
    uint32 minfo;
    int ptr;
    _soc_ser_correct_info_t spci;
    int port;

    info = &info_list[info_index];

    valid_reg = info->intr2_valid_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, valid_reg, REG_PORT_ANY, 0,
                       &reg_val));
    valid_val = soc_reg_field_get(unit, valid_reg, reg_val, ERR_VALIDf);

    if (valid_val == 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: ecc hardware inconsistency\n"),
                   msg));
        return SOC_E_NONE;
    }

    if (SOC_REG_IS_VALID(unit, info->intr2_multi_err_reg) &&
        soc_reg_field_valid(unit, info->intr2_multi_err_reg, MULTIPLE_ERRf)) {
        multi_err_reg = info->intr2_multi_err_reg;
    } else if (soc_reg_field_valid(unit, valid_reg, MULTIPLE_ERRf)) {
        multi_err_reg = valid_reg;
    }
    if (INVALIDr != multi_err_reg) {
        multiple =
            soc_reg_field_get(unit, multi_err_reg, reg_val, MULTIPLE_ERRf);
    }

    if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_INTERNAL;
    }

    for (ptr = 0; reg_ptr[ptr].reg != INVALIDr; ptr++) {
        if (ptr > 31) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s: left shifting by more"
                                  " than 31 bits, ptr = %d"),
                       msg, ptr));
            return SOC_E_INTERNAL;
        }
        if (!(valid_val & (0x1 << ptr))) {
            continue;
        }
        status_reg = reg_ptr[ptr].reg;

        /* get logical port for per port memories */
        if (_soc_hr3_ser_process_is_per_port_mem(unit, info->type)) {
            if (SOC_PORT_VALID(unit, ptr)) {
                port = ptr;
            } else {
                return SOC_E_INTERNAL;
            }
        } else {
            port = REG_PORT_ANY;
        }

        SOC_IF_ERROR_RETURN(
            soc_reg32_get(unit, status_reg, port, 0, &reg_val));
        index =
                soc_reg_field_get(unit, status_reg, reg_val, ENTRY_INDEXf);

        sal_memset(&spci, 0, sizeof(_soc_ser_correct_info_t));
        spci.flags |= SOC_SER_SRC_MEM;
        if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
            double_bit =
                soc_reg_field_get(unit, status_reg, reg_val, DOUBLE_BIT_ERRf);
            spci.double_bit = 1;
        }
        _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           report_type,
                           index, minfo);

        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s entry %d %s parity error\n"),
                   msg, reg_ptr[ptr].str, index,
                   double_bit ? "double-bit" : ""));

        if (multiple & (1 << ptr)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s has multiple parity errors\n"),
                       msg, reg_ptr[ptr].str));
            spci.flags |= SOC_SER_ERR_MULTI;
        }
        spci.reg = INVALIDr;
        spci.mem = reg_ptr[ptr].mem;
        spci.flags |= SOC_SER_REG_MEM_KNOWN;
        spci.blk_type = SOC_BLK_MMU;
        spci.detect_time = sal_time_usecs();
        spci.index = index;
        (void)soc_ser_correction(unit, &spci);

    }
    /* Clear interrupt status */
    clear_reg = info->intr2_clr_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,
                                REG_PORT_ANY, 0, &reg_val));
    soc_reg_field_set(unit, clear_reg, &reg_val,
                            CLR_ERRf, valid_val);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,
                                REG_PORT_ANY, 0, reg_val));
    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_mmu_group_ecc(int unit,_soc_hr3_ser_info_t *info_list,
                                   int info_index, int block_info_idx, char *msg)
{
    _soc_hr3_ser_info_t *info;
    _soc_hr3_ser_reg_t *reg_ptr;
    soc_reg_t valid_reg, status_reg, clear_reg;
    uint32  reg_val, valid_val;
    int index, double_bit = 0, multiple;
    uint32 minfo;
    int ptr;

    info = &info_list[info_index];
    valid_reg = info->intr2_valid_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, valid_reg, REG_PORT_ANY, 0,
                       &reg_val));
    valid_val = soc_reg_field_get(unit, valid_reg, reg_val, ERR_VALIDf);
    /* CBPPKTHDR_ERR */
    multiple =
        soc_reg_field_get(unit, valid_reg, reg_val, MULTIPLE_ERRf);
    if (valid_val == 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: ecc hardware inconsistency\n"),
                   msg));
        return SOC_E_NONE;
    }

    if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_INTERNAL;
    }
    for (ptr = 0; reg_ptr[ptr].reg != INVALIDr; ptr++) {
        if (!(valid_val & (0x1 << ptr))) {
            continue;
        }
        status_reg = reg_ptr[ptr].reg;

        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, status_reg,
                                    REG_PORT_ANY, 0, &reg_val));
        index =
                soc_reg_field_get(unit, status_reg, reg_val, ENTRY_INDEXf);
        if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
            double_bit =
                soc_reg_field_get(unit, status_reg, reg_val, DOUBLE_BIT_ERRf);
        }
        _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                               index, minfo);

        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s entry %d %s ECC error\n"),
                   msg, reg_ptr[ptr].str, index,
                   double_bit ? "double-bit" : ""));
        if (multiple & (1 << ptr)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s (%s) has multiple ECC errors\n"),
                       msg, reg_ptr[ptr].str));
        }
    }
    /* Clear interrupt status */
    clear_reg = info->intr2_clr_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,
                                REG_PORT_ANY, 0, &reg_val));
    soc_reg_field_set(unit, clear_reg, &reg_val,
                            CLR_ERRf, valid_val);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,
                                REG_PORT_ANY, 0, reg_val));
    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_mmu_ecc2(int unit,_soc_hr3_ser_info_t *info_list,
                              int info_index, int block_info_idx, char *msg)

{
    _soc_hr3_ser_info_t *info;
    soc_reg_t valid_reg, status_reg, clear_reg, merr_reg;
    uint32  reg_val, valid_val;
    int index, double_bit = 0, multiple = 0;
    uint32 minfo;
    int port;

    info = &info_list[info_index];

    valid_reg = info->intr2_valid_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, valid_reg, REG_PORT_ANY, 0,
                       &reg_val));
    valid_val = soc_reg_field_get(unit, valid_reg, reg_val, ERR_VALIDf);
    if (valid_val == 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s: ecc hardware inconsistency\n"),
                   msg));
        return SOC_E_NONE;
    }
    port = 0;
    while (!(valid_val & (0x1 << port))) {
        port++;
    }
    if (info->intr_status_reg != INVALIDr){
        status_reg = info->intr_status_reg;
    } else {
        return SOC_E_INTERNAL;
    }
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, status_reg,
                                port, 0, &reg_val));
    index =
            soc_reg_field_get(unit, status_reg, reg_val, ENTRY_INDEXf);
    if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
        double_bit =
            soc_reg_field_get(unit, status_reg, reg_val, DOUBLE_BIT_ERRf);
    }
    if (info->intr2_multi_err_reg != INVALIDr) {
        merr_reg = info->intr2_multi_err_reg;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, merr_reg,
                                port, 0, &reg_val));
        multiple =
            soc_reg_field_get(unit, merr_reg, reg_val, MULTIPLE_ERRf);
    }
    _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);
    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                           index, minfo);
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s port %d entry %d %s ECC error\n"),
               msg, port, index, double_bit ? "double-bit" : ""));
    if (multiple) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s has multiple ECC errors\n"),
                   msg));
    }
    /* Clear interrupt status */
    clear_reg = info->intr2_clr_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,
                                REG_PORT_ANY, 0, &reg_val));
    soc_reg_field_set(unit, clear_reg, &reg_val,
                            CLR_ERRf, valid_val);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,
                                REG_PORT_ANY, 0, reg_val));
    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_mmu_ecc(int unit,_soc_hr3_ser_info_t *info_list,
                             int info_index, int block_info_idx, char *msg,
                             int correctable)
{
    _soc_hr3_ser_info_t *info;
    soc_reg_t status_reg;
    uint32  intr_status;
    int index, double_bit = 0;
    uint32 minfo;
    _soc_ser_correct_info_t spci;

    info = &info_list[info_index];
    status_reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, status_reg, REG_PORT_ANY, 0,
                       &intr_status));
    index = soc_reg_field_get(unit, status_reg, intr_status, ENTRY_INDEXf);
    if (soc_reg_field_valid(unit, status_reg, DOUBLE_BIT_ERRf)) {
        double_bit = soc_reg_field_get(unit, status_reg,
                                       intr_status, DOUBLE_BIT_ERRf);
    }
    _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);

    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_ECC,
                           index, minfo);
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s entry %d %s ECC error\n"),
               msg, index, double_bit ? "double-bit" : ""));
    if (correctable) {
        sal_memset(&spci, 0, sizeof(_soc_ser_correct_info_t));
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        spci.reg = INVALIDr;
        spci.mem = info->mem;
        spci.blk_type = SOC_BLK_MMU;
        spci.index = index;
        (void)soc_ser_correction(unit, &spci);
    }
    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_mmu_err(int unit, int block_info_idx,
                             soc_reg_t group_reg,
                             soc_reg_t clear_reg,
                             _soc_hr3_ser_info_t *info_list)
{
    soc_reg_t grp_reg, clr_reg;
    uint32 rval, group_rval;
    int rv = SOC_E_NONE;
    int info_index;
    _soc_hr3_ser_info_t *info;
    char *mem_str;

    if (info_list->type == _SOC_PARITY_TYPE_MMU_SER){
        grp_reg = info_list->intr_status_reg;
        clr_reg = info_list->intr_clr_reg;


        rv = _soc_hr3_ser_process_mmu_err(unit, block_info_idx,
                                          grp_reg,
                                          clr_reg,
                                          info_list->info);
        if (SOC_FAILURE(rv)) {
            LOG_CLI((BSL_META_U(unit,
                                "process_mmu_err: Error processing %s !!\n"),
                     info_list->mem_str));
            return rv;
        }
        return rv;
    }
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, group_reg, REG_PORT_ANY, 0,
                           &group_rval));
        if (!soc_reg_field_get(unit, group_reg, group_rval,
                                   info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "process_mmu_err %s analysis\n"),
                                mem_str));
        switch (info->type) {
        case _SOC_PARITY_TYPE_MMU_ECC:
            SOC_IF_ERROR_RETURN(
                _soc_hr3_ser_process_mmu_ecc(unit, info_list, info_index,
                                             block_info_idx, mem_str, 0));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_XQ:
            SOC_IF_ERROR_RETURN(
                _soc_hr3_ser_process_mmu_ecc2(unit, info_list, info_index,
                                             block_info_idx, mem_str));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_CBPH:
            SOC_IF_ERROR_RETURN(
                _soc_hr3_ser_process_mmu_group_ecc(unit, info_list, info_index,
                                             block_info_idx, mem_str));
            break;
        case _SOC_PARITY_TYPE_MMU_PAR_E2EFC:
            SOC_IF_ERROR_RETURN(
                _soc_hr3_ser_process_mmu_e2efc(unit, info_list, info_index,
                                             block_info_idx, mem_str));
            break;
        case _SOC_PARITY_TYPE_MMU_PAR_WRED:
            SOC_IF_ERROR_RETURN(_soc_hr3_ser_process_mmu_group_correct(
                                unit, info_list, info_index,
                                block_info_idx, mem_str,
                                SOC_SWITCH_EVENT_DATA_ERROR_PARITY));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_IPMCGROUP:
            SOC_IF_ERROR_RETURN(_soc_hr3_ser_process_mmu_group_correct(
                                unit, info_list, info_index,
                                block_info_idx, mem_str,
                                SOC_SWITCH_EVENT_DATA_ERROR_ECC));
            break;
        case _SOC_PARITY_TYPE_MMU_ECC_IPMCVLAN:
            SOC_IF_ERROR_RETURN(
                _soc_hr3_ser_process_mmu_ecc(unit, info_list, info_index,
                                             block_info_idx, mem_str, 1));
            break;
        default:
            break;
        }
        /* clear interrupt */
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, clear_reg,  REG_PORT_ANY,
                            0, &rval));
        soc_reg_field_set(unit, clear_reg, &rval,
                          info->intr_clr_field, 1);
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, clear_reg,  REG_PORT_ANY,
                            0, rval));

    }
    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_parity_hash(int unit, int block_info_idx, int port,
                                _soc_hr3_ser_info_t *info,
                                  char *mem_str,
                                 soc_block_t blocktype)
{
    _soc_hr3_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    _soc_ser_correct_info_t spci;
    uint32 bitmap = 0, len = 0, bits, rval, minfo;
    uint32 multiple = 0, bucket_index = 0, entry_idx, idx, has_error;
    char *mem_str_ptr;

    if (info->intr_status_reg != INVALIDr) {
        reg_entry[0].reg = info->intr_status_reg;
        reg_entry[0].str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_NONE;
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = (reg_ptr[idx].str != NULL) ?
                       reg_ptr[idx].str : mem_str;
        sal_memset(&spci, 0, sizeof(spci));

        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_valid(unit, reg, BUCKET_IDXf)) {
            bucket_index =
                soc_reg_field_get(unit, reg, rval, BUCKET_IDXf);
            multiple =
                soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            bitmap =
                soc_reg_field_get(unit, reg, rval, PARITY_ERR_BMf);
            len = soc_reg_field_length(unit, reg, PARITY_ERR_BMf);
        } else if (soc_reg_field_valid(unit, reg, BUCKET_IDX_0f)) {
            bucket_index =
                soc_reg_field_get(unit, reg, rval, BUCKET_IDX_0f);
            multiple =
                soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_0f);
            bitmap =
                soc_reg_field_get(unit, reg, rval, PARITY_ERR_BM_0f);
            len = soc_reg_field_length(unit, reg, PARITY_ERR_BM_0f);
        } else if (soc_reg_field_valid(unit, reg, BUCKET_IDX_1f)) {
            bucket_index =
                soc_reg_field_get(unit, reg, rval, BUCKET_IDX_1f);
            multiple =
               soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_1f);
            bitmap =
                soc_reg_field_get(unit, reg, rval, PARITY_ERR_BM_1f);
            len = soc_reg_field_length(unit, reg, PARITY_ERR_BM_1f);
        }
        if (bitmap != 0) {
            for (bits = 0; bits < len; bits++) {
                if (bitmap & (1 << bits)) {
                    has_error = TRUE;
                    break;
                }
            }
            entry_idx = bucket_index * len * 2 + bits + (idx * len);
            _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_PARITY,
                               entry_idx, minfo);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s entry %d parity error\n"),
                       unit, mem_str_ptr, entry_idx));
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d %s has multiple parity errors\n"),
                           unit, mem_str_ptr));
            }
            spci.flags = SOC_SER_SRC_MEM;
            if (multiple) {
                spci.flags |= SOC_SER_ERR_MULTI;
            }
            spci.double_bit = 0;
            spci.reg = INVALIDr;
            spci.mem = info->mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            spci.detect_time = sal_time_usecs();
            spci.pipe_num = 0;
            spci.acc_type = -1;
            spci.addr = (spci.mem != INVALIDm)? SOC_MEM_BASE(unit, spci.mem) : 0;
            if (spci.mem != INVALIDm) {
                spci.flags |= SOC_SER_REG_MEM_KNOWN;
                (void)soc_ser_correction(unit, &spci);
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, 0));
        }
    }
    if (!has_error) {
        LOG_VERBOSE(BSL_LS_SOC_SER,
            (BSL_META_U(unit,
                        "unit %d %s parity hardware inconsistency\n"),
             unit, mem_str));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_parity_ecc(int unit, int block_info_idx, int port,
                                _soc_hr3_ser_info_t *info,
                                char *mem_str,
                                soc_block_t blocktype, int parity_type)
{
    _soc_hr3_ser_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    soc_field_t parity_error_field = PARITY_ERRf;
    _soc_ser_correct_info_t spci;
    uint32 rval, minfo, double_bit = 0;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    int report_type = SOC_SWITCH_EVENT_DATA_ERROR_PARITY;

    if (info->intr_status_reg != INVALIDr) {
        reg_entry[0].reg = info->intr_status_reg;
        reg_entry[0].str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else if (info->intr_status_reg_list != NULL) {
        reg_ptr = info->intr_status_reg_list;
    } else {
        return SOC_E_NONE;
    }
    if (INVALIDf != info->intr_status_field) {
        parity_error_field = info->intr_status_field;
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = (reg_ptr[idx].str != NULL) ?
                       reg_ptr[idx].str : mem_str;
        sal_memset(&spci, 0, sizeof(spci));
        if (!soc_reg_field_valid(unit, reg, parity_error_field)) {
            continue;
        }
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));
        if (soc_reg_field_get(unit, reg, rval, parity_error_field)) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);

            if (soc_feature(unit, soc_feature_hr3_lite_lpm_shadow_hit) &&
                NEED_HR3LITE_LPM_SHADOW(info->mem)){
                if (entry_idx >= 512) {
                    entry_idx = entry_idx - 512 + 32;
                }
            }
            _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                             info->group_reg_status_field, &minfo);
            if (parity_type == _SOC_PARITY_TYPE_ECC) {
                report_type = SOC_SWITCH_EVENT_DATA_ERROR_ECC;
                if (soc_reg_field_valid(unit, reg, DOUBLE_BIT_ERRf)) {
                    double_bit =
                        soc_reg_field_get(unit, reg, rval, DOUBLE_BIT_ERRf);
                }
            }

            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               report_type,
                               entry_idx, minfo);
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s entry %d %s error\n"),
                       unit, mem_str_ptr, entry_idx,
                       ((parity_type == _SOC_PARITY_TYPE_ECC)?
                         "ecc" : "parity")));
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d %s has multiple %s errors\n"),
                           unit, mem_str_ptr,
                           ((parity_type == _SOC_PARITY_TYPE_ECC)?
                             "ecc" : "parity")));
            }
            spci.flags = SOC_SER_SRC_MEM;
            if (multiple) {
                spci.flags |= SOC_SER_ERR_MULTI;
            }
            if (double_bit) {
                spci.double_bit = 1;
            }
            spci.reg = INVALIDr;
            spci.mem = info->mem;
            spci.blk_type = blocktype;
            spci.index = entry_idx;
            spci.detect_time = sal_time_usecs();
            spci.pipe_num = 0;
            spci.acc_type = -1;
            spci.addr = (spci.mem != INVALIDm)? SOC_MEM_BASE(unit, spci.mem) : 0;
            if (spci.mem != INVALIDm) {
                spci.flags |= SOC_SER_REG_MEM_KNOWN;
                (void)soc_ser_correction(unit, &spci);
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, reg, port, 0, 0));
        }
    }
    if (!has_error) {
        LOG_VERBOSE(BSL_LS_SOC_SER,
            (BSL_META_U(unit,
                        "unit %d %s parity hardware inconsistency\n"),
             unit, mem_str));
    }

    return SOC_E_NONE;

}

#define _SOC_HR3_DBG_COUNTER_MAX     12
static soc_reg_t dbgc_regs[_SOC_HR3_DBG_COUNTER_MAX] = {
    TDBGC0r, TDBGC1r,  TDBGC2r,  TDBGC3r,
    TDBGC4r, TDBGC5r,  TDBGC6r,  TDBGC7r,
    TDBGC8r, TDBGC9r, TDBGC10r, TDBGC11r
};
STATIC int
_soc_hr3_ser_process_parity_counter(int unit, int block_info_idx, int port,
                                    _soc_hr3_ser_info_t *info,
                                    char *mem_str,
                                    soc_block_t blocktype)
{
    soc_reg_t reg, counter_reg;
    uint32 rval, minfo;
    uint32 multiple, counter_idx, port_idx;
    char *counter_name;
    _soc_ser_correct_info_t spci;
    soc_field_t parity_error_field = PARITY_ERRf;

    reg = info->intr_status_reg;
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg,
                                      port, 0, &rval));
    if (soc_reg_field_get(unit, reg, rval, parity_error_field)) {
        multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
        counter_idx = soc_reg_field_get(unit, reg, rval, COUNTER_IDXf);
        port_idx = soc_reg_field_get(unit, reg, rval, PORT_IDXf);

        counter_reg = dbgc_regs[counter_idx];
        _soc_hr3_mem_parity_info(unit, block_info_idx, 0,
                                 info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                           SOC_SWITCH_EVENT_DATA_ERROR_PARITY,
                           counter_idx, minfo);
        counter_name = SOC_REG_NAME(unit, counter_reg);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "EGR STAT COUNTER port %d %s parity error\n"),
                   port_idx, counter_name));

        sal_memset(&spci, 0, sizeof(spci));
        spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
        spci.mem = INVALIDm;
        spci.port = port_idx;
        spci.index = -1;
        spci.reg = counter_reg;
        spci.blk_type = blocktype;
        (void)soc_ser_correction(unit, &spci);
        if (multiple) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "EGR STAT COUNTER has multiple parity errors\n")));
        }
    }else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "EGR STAT COUNTER parity hardware inconsistency\n")));
    }
    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg,  port, 0, 0));

    return SOC_E_NONE;
}

STATIC int
_soc_hr3_process_ser(int unit, soc_block_t block_info_idx, int inst,
                     int port, soc_reg_t group_reg, uint64 group_rval,
                     _soc_hr3_ser_info_t *info_list,
                     soc_block_t blocktype)

{
    _soc_hr3_ser_info_t *info;
    int info_index;
    char *mem_str;

    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (_soc_hr3_ser_mem_skip(unit, info)) {
            continue;
        }
        if (group_reg != INVALIDr) {
            /* Check status for the info entry in the group register */
            /* for SOC_BLK_MMU, group_reg is INVALIDr */
            if (!soc_reg_field_valid(unit, group_reg,
                                     info->group_reg_status_field)) {
                continue;
            }
            if (!soc_reg64_field32_get(unit, group_reg, group_rval,
                                       info->group_reg_status_field)) {
                continue;
            }
        }
        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "unit %d  _soc_hr3_process_ser %s analysis\n"),
                                unit, mem_str));

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_MMU_SER:
            SOC_IF_ERROR_RETURN
                (_soc_hr3_ser_process_mmu_err(unit, block_info_idx,
                                              INVALIDr, INVALIDr,
                                              info));
                /* info points to _soc_hr3_mmu_top_ser_info[0] */
            break;
        case _SOC_PARITY_TYPE_PARITY:
            SOC_IF_ERROR_RETURN
                (_soc_hr3_ser_process_parity_ecc(unit, block_info_idx, port,
                                                 info, mem_str, blocktype,
                                                 info->type));
            break;
        case _SOC_PARITY_TYPE_PARITY_DUAL:
            SOC_IF_ERROR_RETURN
                (_soc_hr3_ser_process_parity_hash(unit, block_info_idx, port,
                                                  info, mem_str, blocktype));
            break;
        case _SOC_PARITY_TYPE_ECC:
            SOC_IF_ERROR_RETURN
                (_soc_hr3_ser_process_parity_ecc(unit, block_info_idx, port,
                                                 info, mem_str, blocktype,
                                                 info->type));
            break;
        case _SOC_PARITY_TYPE_COUNTER:
            SOC_IF_ERROR_RETURN
                (_soc_hr3_ser_process_parity_counter(unit, block_info_idx, port,
                                                     info, mem_str, blocktype));
            break;

        default:
            break;
        }

    }

    return SOC_E_NONE;
}

STATIC int
_soc_hr3_ser_process_all(int unit, uint32 cmic_rval)
{
    uint8       rbi;
    const _soc_hr3_ser_route_block_t *rb;
    uint32      cmic_bit;
    int         port = REG_PORT_ANY;
    int         block_info_idx;
    uint64      rb_rval64, rb_enable64, temp64;
    soc_reg_t   tmp_reg;

    COMPILER_64_ZERO(rb_rval64);
    COMPILER_64_ZERO(rb_enable64);

    if (cmic_rval == 0) {
        return SOC_E_NONE;
    }
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_hr3_ser_route_blocks[unit][rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        if (!(cmic_rval & cmic_bit)) {
            /* Indicated bit not asserted for the route block */
            continue;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (rb->enable_reg != INVALIDr) {
            if (SOC_BLOCK_IN_LIST(unit, SOC_REG_INFO(unit, rb->enable_reg).block,
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                /* This port block is not configured */
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "unit %d SER error on disabled "
                                      "port block %d !!\n"),
                           unit, block_info_idx));
                continue;
            }
            SOC_IF_ERROR_RETURN(soc_reg_get(unit, rb->enable_reg,
                                port, 0, &rb_enable64));
        }
        /* Read per route block parity status register */
        if (rb->status_reg != INVALIDr) {
            tmp_reg = rb->status_reg;
            SOC_IF_ERROR_RETURN(
                soc_reg_get(unit, tmp_reg, port, 0, &rb_rval64));
            if (COMPILER_64_IS_ZERO(rb_rval64)) {
                continue;
            }
            if (!COMPILER_64_IS_ZERO(rb_enable64)) {
                /* mask out the disabled status */
                COMPILER_64_AND(rb_rval64, rb_enable64);
                if (COMPILER_64_IS_ZERO(rb_rval64)){
                    continue;
                }
            }
        }

        /* ser process per type */
        SOC_IF_ERROR_RETURN(
            _soc_hr3_process_ser(unit, block_info_idx, rb->id,
                                 port, rb->status_reg, rb_rval64,
                                 rb->info, rb->blocktype));

        /* Enable interrupt */
        if (rb->enable_reg != INVALIDr) {
            SOC_IF_ERROR_RETURN(soc_reg_get(unit, rb->enable_reg,
                                port, 0, &rb_enable64));
            COMPILER_64_SET(temp64, COMPILER_64_HI(rb_rval64),
                                COMPILER_64_LO(rb_rval64));
            COMPILER_64_NOT(temp64);
            COMPILER_64_AND(rb_enable64, temp64);
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, rb->enable_reg,
                port, 0, rb_enable64));
            COMPILER_64_OR(rb_enable64, rb_rval64);
            SOC_IF_ERROR_RETURN(soc_reg_set(unit, rb->enable_reg,
                port, 0, rb_enable64));
        }
    }/* for rbi */
    return SOC_E_NONE;
}
/* parity enable for mmu block */
STATIC int
_soc_hr3_mmu_ser_config(int unit, _soc_hr3_ser_info_t *info_list,
                        soc_reg_t group_reg, soc_mem_t mem,
                        int enable)
{
    _soc_hr3_ser_info_t *info;
    int info_index, rv;
    uint32 rval;

    rv = SOC_E_NOT_FOUND;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, group_reg, REG_PORT_ANY, 0,
                       &rval));
    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if ((mem != INVALIDm) && (mem != info->mem)) {
            continue;
        }
        rv = SOC_E_NONE;
        soc_reg_field_set(unit, group_reg, &rval,
                          info->group_reg_enable_field,
                          enable ? 1 : 0);

        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, group_reg, REG_PORT_ANY, 0, rval));
    }
    return rv;
}
/* parity enable for xlport */
STATIC int
_soc_hr3_pm_ser_config(int unit, _soc_hr3_ser_info_t *info_list,
                       int block_info_idx, soc_reg_t group_reg,
                       int enable)
{
    _soc_hr3_ser_info_t *info;
    int info_index, port;
    uint32 rval, group_rval;
    soc_reg_t reg;


    port = SOC_BLOCK_PORT(unit, block_info_idx);
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, group_reg, REG_PORT_ANY, 0,
                       &group_rval));
    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        reg = info->enable_reg;
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, reg, port, 0, &rval));
        soc_reg_field_set(unit, reg, &rval, info->enable_field,
                          enable ? 1 : 0);
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, reg, port, 0, rval));

        soc_reg_field_set(unit, group_reg, &group_rval,
                          info->group_reg_enable_field,
                          enable ? 1 : 0);

        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, group_reg, port, 0, group_rval));
    }
    return SOC_E_NONE;
}


STATIC int
_soc_hr3_ser_enable_info(int unit, int block_info_idx, int inst, int port,
                         soc_reg_t group_reg, uint64 *group_rval,
                         _soc_hr3_ser_info_t *info_list,
                         soc_mem_t mem, int enable)
{
    _soc_hr3_ser_info_t *info;
    int         info_index, rv;
    soc_reg_t   reg;
    uint64      rval64;


    rv = SOC_E_NOT_FOUND;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (_soc_hr3_ser_mem_skip(unit, info)) {
            continue;
        }
        if ((mem != INVALIDm) && (mem != info->mem)) {
            continue;
        }
        rv = SOC_E_NONE;
        if (group_reg != INVALIDr && info->group_reg_enable_field != INVALIDf) {
            if (!soc_reg_field_valid(unit, group_reg,
                                     info->group_reg_enable_field)) {
                continue;
            }
            /* Enable the info entry in the group register */
            soc_reg64_field32_set(unit, group_reg, group_rval,
                                  info->group_reg_enable_field, enable ? 1 : 0);
        }
        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PORT_XL:
            /* only ecc in pm, don't need mem information */
            rv =_soc_hr3_pm_ser_config(unit, info->info, block_info_idx,
                                       info->intr_enable_reg, enable);
            break;
        case _SOC_PARITY_TYPE_MMU_SER:
        case _SOC_PARITY_TYPE_ECC:
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_PARITY_DUAL:
            reg = info->enable_reg;
            if (!SOC_REG_IS_VALID(unit, reg)) {
                break;
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, reg, port, 0, &rval64));
            soc_reg64_field32_set(unit, reg, &rval64, info->enable_field,
                                  enable ? 1 : 0);
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, reg, port, 0, rval64));

            LOG_VERBOSE(BSL_LS_SOC_SOCMEM,
                        (BSL_META_U(unit,
                                    "SER enable for: %s\n"),
                         (info->mem == INVALIDm) ? info->mem_str :
                         SOC_MEM_NAME(unit, info->mem)));
            if (info->type == _SOC_PARITY_TYPE_MMU_SER) {
                rv = _soc_hr3_mmu_ser_config(unit, info->info,
                                             info->intr_enable_reg,
                                             mem, enable);
            }
            break;
        default: break;
        }
    }
    return rv;
}


int
_soc_hr3_mem_parity_control(int unit, soc_mem_t mem,
                            int copyno, int enable)
{
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf;
    uint8       rbi;
    const _soc_hr3_ser_route_block_t *rb;
    uint32      cmic_bit;
    int         block_info_idx;
    soc_mem_t   memTable;
    int         port = REG_PORT_ANY;
    _soc_hr3_ser_info_t *info_list, *info;
    int         info_index;
    uint32      misc_cfg;

    if (!soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        /* Parity checking is not enabled, nothing to do */
        return SOC_E_NONE;
    }
    /* Convert component/aggregate memories to the table for which
     * the parity registers correspond. */
    switch(mem) {
    case VLAN_SUBNET_ONLYm:
    case VLAN_SUBNET_DATA_ONLYm:
        mem = VLAN_SUBNETm;
        break;
    case L2_ENTRY_ONLYm:
        mem = L2Xm;
        break;
    case L2_USER_ENTRY_ONLYm:
    case L2_USER_ENTRY_DATA_ONLYm:
        mem = L2_USER_ENTRYm;
        break;
    case L3_DEFIP_DATA_ONLYm:
        mem = L3_DEFIPm;
        break;
    case L3_ENTRY_IPV4_UNICASTm:
    case L3_ENTRY_IPV6_UNICASTm:
    case L3_ENTRY_IPV4_MULTICASTm:
    case L3_ENTRY_IPV6_MULTICASTm:
        mem = L3_ENTRY_ONLYm;
        break;
    case VLAN_MACm:
        mem = VLAN_XLATEm;
        break;
    case MODPORT_MAPm:
        mem = MODPORT_MAP_SWm;
        break;
    default:
        /* Do nothing, keep memory as provided */
        break;
    }

    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_hr3_ser_route_blocks[unit][rbi];
        cmic_bit = rb->cmic_bit;
        parity_enable_reg = INVALIDr;
        hw_parity_field = INVALIDf;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if ((copyno != MEM_BLOCK_ANY) && (copyno != block_info_idx)) {
            continue;
        }
        info_list = rb->info;
        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            parity_enable_reg = info_list[0].enable_reg;
            hw_parity_field = info_list[0].enable_field;
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_hr3_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm) {
                continue;
            }
            if (memTable == mem)  {
                if (parity_enable_reg == INVALIDr) {
                    parity_enable_reg = info->enable_reg;
                }
                if (hw_parity_field == INVALIDf) {
                    hw_parity_field = info->enable_field;
                }
                SOC_IF_ERROR_RETURN(
                    soc_reg_field32_modify(unit, parity_enable_reg, port,
                                           hw_parity_field,
                                           enable ? 1 : 0));

                return SOC_E_NONE;
            }
        }
    }
    /* MMU controls */
    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &misc_cfg));
    if (enable) {
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_CHECK_ENf, 1);
    } else {
        soc_reg_field_set(unit, MISCCONFIGr, &misc_cfg, PARITY_CHECK_ENf, 0);
    }
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, misc_cfg));

    return SOC_E_NONE;
}
int
soc_hr3_ser_enable_all(int unit, int enable)
{
    const _soc_hr3_ser_route_block_t *rb;
    uint8       rbi;
    uint32      cmic_bit, cmic_rval = 0;
    int         block_info_idx;
    int         port = REG_PORT_ANY;
    uint64      rval64;
    int         rv = SOC_E_NONE;

    SOC_IF_ERROR_RETURN(
        soc_hr3_ser_route_blocks_init(unit));

    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_hr3_ser_route_blocks[unit][rbi];
        cmic_bit = rb->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        cmic_rval |= cmic_bit;
        port = REG_PORT_ANY;
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if (rb->enable_reg != INVALIDr) {
            if (!SOC_REG_IS_VALID(unit, rb->enable_reg)) {
                continue;
            }
            if (SOC_BLOCK_IN_LIST(unit, SOC_REG_INFO(unit, rb->enable_reg).block,
                SOC_BLK_PORT) && (port == REG_PORT_ANY)) {
                    /* This port block is not configured */
                    continue;
            }
            SOC_IF_ERROR_RETURN
                (soc_reg_get(unit, rb->enable_reg, port, 0, &rval64));
        }
        rv = _soc_hr3_ser_enable_info(unit, block_info_idx, rb->id, port,
                                      rb->enable_reg, &rval64,
                                      rb->info, INVALIDm, enable);
        if (rv == SOC_E_NOT_FOUND) {
            continue;
        } else if (SOC_FAILURE(rv)) {
            return rv;
        }

        if (rb->enable_reg != INVALIDr) {
            /* Write per route block parity enable register */
            SOC_IF_ERROR_RETURN
                (soc_reg_set(unit, rb->enable_reg, port, 0, rval64));
        }
    }
    if (enable) {
        /* Write CMIC enable register */
        (void)soc_cmicm_intr3_enable(unit, cmic_rval);
    } else {
        /* Write CMIC disable register */
        (void)soc_cmicm_intr3_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}


void
soc_hr3_ser_error(void *unit_vp, void *d1, void *d2, void *d3,
                       void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    uint32  irq_stat;
    uint32  ip1_stat;


    (void)READ_CMIC_CMC0_IRQ_STAT3r(unit, &irq_stat);

    if (irq_stat & _HR3_X_TO_CMIC_INTR(_HR3_PAR_IP1)){
        (void)soc_reg32_get(unit, IP1_INTR_STATUSr, REG_PORT_ANY,
                            0, &ip1_stat);
        if (ip1_stat) {
            /* oam process */
            (void) soc_hr3_process_oam_interrupt(unit);
            /* l2 */
            (void) _soc_hr3_process_l2_overflow(unit);
        }
    }
    (void)_soc_hr3_ser_process_all(unit, irq_stat);
    sal_usleep(SAL_BOOT_QUICKTURN ? 1000000 : 10000);
    (void)soc_cmicm_intr3_enable(unit, PTR_TO_INT(d2));
}

static _soc_generic_ser_info_t _soc_hr3_tcam_ser_info_template[] = {
#if _HR3_SER_TEST_TCAM
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS, _SOC_SER_INTERLEAVE_MOD2,
      { {0, 37}, {1, 37}, {38, 74}, {39, 74} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
#endif /* _HR3_SER_TEST_TCAM */
    /* End of list */
    { INVALIDm },
};
static _soc_generic_ser_info_t _soc_hr3l_tcam_ser_info_template[] = {
#if _HR3_SER_TEST_TCAM
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS, _SOC_SER_INTERLEAVE_MOD2,
      { {0, 37}, {1, 37}, {38, 74}, {39, 74} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
#endif /* _HR3_SER_TEST_TCAM */
    /* End of list */
    { INVALIDm },
};
static _soc_generic_ser_info_t _soc_bh_tcam_ser_info_template[] = {
#if _HR3_SER_TEST_TCAM
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS, _SOC_SER_INTERLEAVE_MOD2,
      { {0, 37}, {1, 37}, {38, 74}, {39, 74} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
#endif /* _HR3_SER_TEST_TCAM */
    /* End of list */
    { INVALIDm },
};
static _soc_generic_ser_info_t _soc_fh2_tcam_ser_info_template[] = {
#if _HR3_SER_TEST_TCAM
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS, _SOC_SER_INTERLEAVE_MOD2,
      { {0, 37}, {1, 37}, {38, 74}, {39, 74} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_NO_DMA},
#endif /* _HR3_SER_TEST_TCAM */
    /* End of list */
    { INVALIDm },
};

static _soc_generic_ser_info_t _soc_wh2_tcam_ser_info_template[] = {
#if _HR3_SER_TEST_TCAM
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_4BITS, _SOC_SER_INTERLEAVE_MOD2,
      { {0, 37}, {1, 37}, {38, 74}, {39, 74} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 69}, {1, 69}, {70, 138}, {71, 138} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ},
#endif /* _HR3_SER_TEST_TCAM */
    /* End of list */
    { INVALIDm },
};

static _soc_generic_ser_info_t *_soc_hr3_tcam_ser_info[SOC_MAX_NUM_DEVICES] = {NULL};

int
soc_hr3_tcam_ser_init(int unit)
{
    int alloc_size;
    int sku;

    /* First, make per-unit copy of the master TCAM list */
    alloc_size = sizeof(_soc_hr3_tcam_ser_info_template);
    if (NULL == _soc_hr3_tcam_ser_info[unit]) {
        if ((_soc_hr3_tcam_ser_info[unit] =
             sal_alloc(alloc_size, "hr3 tcam list")) == NULL) {
            return SOC_E_MEMORY;
        }
        sal_memset(_soc_hr3_tcam_ser_info[unit], 0, alloc_size);
    }
    if (soc_feature(unit, soc_feature_wh2)) {
        /* Wolfhound2 */
        sal_memcpy(_soc_hr3_tcam_ser_info[unit],
               &(_soc_wh2_tcam_ser_info_template),
               sizeof(_soc_wh2_tcam_ser_info_template));
    } else {
        (void)soc_hurricane3_chip_sku_get(unit, &sku);
        if (sku == SOC_HR3_SKU_HURRICANE3) {
            /* Hurricane3 */
            sal_memcpy(_soc_hr3_tcam_ser_info[unit],
                   &(_soc_hr3_tcam_ser_info_template),
                   alloc_size);
        } else if (sku == SOC_HR3_SKU_HURRICANE3LITE) {
            /* Hurricane3_Lite: no EFP,VFP */
            sal_memcpy(_soc_hr3_tcam_ser_info[unit],
               &(_soc_hr3l_tcam_ser_info_template),
               sizeof(_soc_hr3l_tcam_ser_info_template));
        } else if (sku == SOC_HR3_SKU_BUCKHOUND) {
            /* Buckhound,Foxhound2: no EFP, VFP, L3_DEFIP */
            sal_memcpy(_soc_hr3_tcam_ser_info[unit],
               &(_soc_bh_tcam_ser_info_template),
               sizeof(_soc_bh_tcam_ser_info_template));
        } else {
            /* Foxhound2: no EFP, VFP, L3_DEFIP, VLAN_SUBNET */
            sal_memcpy(_soc_hr3_tcam_ser_info[unit],
               &(_soc_fh2_tcam_ser_info_template),
               sizeof(_soc_fh2_tcam_ser_info_template));
        }
    }

#ifdef INCLUDE_MEM_SCAN
    soc_mem_scan_ser_list_register(unit, TRUE,
                                   _soc_hr3_tcam_ser_info[unit]);
#endif
    return soc_generic_ser_init(unit, _soc_hr3_tcam_ser_info[unit]);
}
void
soc_hr3_ser_fail(int unit)
{
    soc_generic_ser_process_error(unit, _soc_hr3_tcam_ser_info[unit],
                                  _SOC_PARITY_TYPE_SER);
}

void
soc_hr3_ser_register(int unit)
{
    memset(&_hr3_ser_functions, 0, sizeof(soc_ser_functions_t));
    _hr3_ser_functions._soc_ser_fail_f = &soc_hr3_ser_fail;
    _hr3_ser_functions._soc_ser_parity_error_cmicm_intr_f =
        &soc_hr3_ser_error;
    soc_ser_function_register(unit, &_hr3_ser_functions);
}

#if defined(SER_TR_TEST_SUPPORT)
int
ser_test_hr3_mem_index_remap(int unit, ser_test_data_t *test_data,
                                  int *mem_has_ecc)
{
    int uft_bkt_bank = 0;
    int uft_le_fv = 0;
    int uft_le_ecc = 0;
    int remap_status = 0;

    *mem_has_ecc = 0;
    test_data->mem = test_data->mem_fv;
    test_data->index = test_data->index_fv;

    if (_soc_hr3_ser_2bit_ecc_mem(unit, test_data->mem_fv)) {
        *mem_has_ecc = 1;
    }

    if ((test_data->mem != test_data->mem_fv) ||
        (test_data->index != test_data->index_fv)) {
        LOG_VERBOSE(BSL_LS_SOC_SER,
            (BSL_META_U(unit,
                        "unit %d, ser_test_mem_index_remap: "
                        "mem_fv %s, index_fv %0d, mem %s, index %0d, "
                        "uft_bkt_bank %0d, uft_le_fv %0d, "
                        "uft_le_ecc %0d, remap_status %0d \n"),
             unit, SOC_MEM_NAME(unit, test_data->mem_fv), test_data->index_fv,
             SOC_MEM_NAME(unit, test_data->mem), test_data->index,
             uft_bkt_bank, uft_le_fv, uft_le_ecc, remap_status));
    }
    return remap_status;
}

soc_ser_test_functions_t ser_hr3_test_fun;

/* Overlay memory */
const soc_ser_overlay_test_t soc_ser_hr3_overlay_mems[] = {
    {L3_ENTRY_IPV4_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {L3_ENTRY_IPV4_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {L3_ENTRY_IPV6_MULTICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {L3_ENTRY_IPV6_UNICASTm, L3_ENTRY_PARITY_CONTROLr, PARITY_ENf, L3_ENTRY_ONLYm,  _SOC_ACC_TYPE_PIPE_ANY},
    {MODPORT_MAPm, MODPORT_MAP_SW_PARITY_CONTROLr, PARITY_ENf, MODPORT_MAP_SWm,  _SOC_ACC_TYPE_PIPE_ANY},
    {INVALIDm}
};

STATIC int soc_hr3_tcam_entry_is_invalid(int unit,
                                                    soc_mem_t mem, int index)
{
    if (soc_feature(unit, soc_feature_field_slice_size128)) {
        if (mem == FP_GLOBAL_MASK_TCAMm ||  mem == FP_TCAMm) {
            if ((index / 64) % 2) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

/*
 * Function:
 *      soc_hr3_ser_inject_error
 * Purpose:
 *       Injects an error into a single memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      pipeTarget  - (IN) The pipe (x/y) to use when injecting the error
 *      block - (IN) The index into which block will be injected.
 *      index  - (IN) The index into which the error will be injected.
 */
int soc_hr3_ser_inject_error(int unit, uint32 flags, soc_mem_t mem,
                            int pipeTarget, int block, int index)
{
    _soc_generic_ser_info_t *tcam_ser_info = _soc_hr3_tcam_ser_info[unit];
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf;
    uint8       rbi;
    const _soc_hr3_ser_route_block_t *rb;
    uint32      cmic_bit;
    int         block_info_idx;
    soc_mem_t   memTable;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_REG_FIELD_WORDS];
    int         i, overlay_mem = 0;
    ser_test_data_t test_data;
    int         port = REG_PORT_ANY;
    _soc_hr3_ser_info_t *info_list, *info;
    int         info_index;

    if (!SOC_MEM_IS_VALID(unit, mem)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return SOC_E_UNAVAIL;
    }
    if (tcam_ser_info != NULL) {
        /*TCAM_test*/
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            if (tcam_ser_info[i].mem == mem) {
                /* Check if this entry is invalid or not */
                if (soc_hr3_tcam_entry_is_invalid(unit, mem, index)) {
                    return (SOC_E_PARAM);
                }
                soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                 SER_RANGE_ENABLEr, i, VALIDf, mem,
                                 VALIDf, MEM_BLOCK_ANY, REG_PORT_ANY,
                                 _SOC_ACC_TYPE_PIPE_ANY, index, &test_data);
                /*Disable parity*/
                SOC_IF_ERROR_RETURN(
                    _ser_test_parity_control(unit, &test_data, 0));
                /*Read the memory for successful injection*/
                SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
                /*Inject error*/
                SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags,
                                                             &test_data));
                /*Enable parity*/
                SOC_IF_ERROR_RETURN(
                    _ser_test_parity_control(unit, &test_data, 1));
                return SOC_E_NONE;
            }
        }
    }

    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_hr3_ser_route_blocks[unit][rbi];
        cmic_bit = rb->cmic_bit;
        parity_enable_reg = INVALIDr;
        hw_parity_field = INVALIDf;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        if ((block != MEM_BLOCK_ANY) && (block != block_info_idx)) {
            continue;
        }
        info_list = rb->info;
        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            parity_enable_reg = info_list[0].enable_reg;
            hw_parity_field = info_list[0].enable_field;
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_hr3_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm) {
                continue;
            }
            /* Check if overlay memory */
            for (i=0; soc_ser_hr3_overlay_mems[i].mem != INVALIDm; i++) {
                if ((soc_ser_hr3_overlay_mems[i].mem == mem) &&
                    (soc_ser_hr3_overlay_mems[i].base_mem == memTable)) {
                    overlay_mem = 1;
                    break;
                }
            }
            if ((memTable == mem) || (overlay_mem)) {
                /*Inject error*/
                test_data.mem = mem;
                test_data.tcam_parity_bit = -1;
                if (parity_enable_reg == INVALIDr) {
                    parity_enable_reg = info->enable_reg;
                }
                if (hw_parity_field == INVALIDf) {
                    hw_parity_field = info->enable_field;
                }
                if (_soc_hr3_ser_2bit_ecc_mem(unit, memTable)) {
                    flags |= SOC_INJECT_ERROR_2BIT_ECC;
                }
                soc_ser_create_test_data(unit, tmp_entry,
                                         fieldData,
                                         parity_enable_reg,
                                         SOC_INVALID_TCAM_PARITY_BIT,
                                         hw_parity_field,
                                         mem, EVEN_PARITYf, block,
                                         port, _SOC_ACC_TYPE_PIPE_ANY,
                                         index, &test_data);
                /*Disable parity*/
                SOC_IF_ERROR_RETURN(_ser_test_parity_control(
                            unit, &test_data, 0));
                /*Read the memory for successful injection*/
                SOC_IF_ERROR_RETURN(ser_test_mem_read(
                            unit, 0, &test_data));
                /*Inject error*/
                SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(
                            unit, flags, &test_data));
                /*Enable parity*/
                SOC_IF_ERROR_RETURN(_ser_test_parity_control(
                            unit, &test_data, 1));
                return SOC_E_NONE;
            }
        }
    }
    /* The tested memory is not found in SER enabled list, can't inject error of it */
    return SOC_E_UNAVAIL;
}

STATIC soc_error_t
_ser_hr3_ser_error_injection_support(int unit, soc_mem_t mem,
                                    int pipe_target)
{
    int rv = SOC_E_UNAVAIL;
    int i = 0, hw_enable_ix = 0;
    int overlay_mem = 0, block_info_idx = 0;
    uint32 range_enable;

    uint8       rbi;
    soc_mem_t   memTable;
    int         info_index;
    _soc_generic_ser_info_t *tcam_ser_info;
    const _soc_hr3_ser_route_block_t *rb;
    _soc_hr3_ser_info_t *info_list, *info;

    if ((mem == MMU_WRED_AVG_QSIZEm) ||
        (mem == MMU_WRED_MARK_THDm)) {
        /*
         * Inject function aim for SQA to test SER in an easiler way
         * To support above memories, soc_mem_read need to support
         * FUNCTIONAL_REFRESH_ENr which is not a general case of SER.
         * Also, TR144 & SER recovery have supported those memories.
         * Thus, we disable them on inject function.
         */
        return rv;
    }
    LOG_VERBOSE(BSL_LS_SOC_SER,
                    (BSL_META_U(unit,
                                "unit %d, mem %s, pipe_target %d\n"),
                     unit, SOC_MEM_NAME(unit,mem), pipe_target));

    if (!SOC_MEM_IS_VALID(unit, mem)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return rv;
    }

    tcam_ser_info = _soc_hr3_tcam_ser_info[unit];

    /* Search TCAMs */
    if (tcam_ser_info != NULL) {

        /* Check if enable */
        SOC_IF_ERROR_RETURN
            (READ_SER_RANGE_ENABLEr(unit, &range_enable));
        LOG_DEBUG(BSL_LS_SOC_SER,
                        (BSL_META_U(unit,
                                    "Search TCAMs: SER_RANGE_ENABLE 0x%X\n"),
                         range_enable));
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            if (tcam_ser_info[i].mem == mem) {

                hw_enable_ix = tcam_ser_info[i].ser_hw_index;
                LOG_DEBUG(BSL_LS_SOC_SER,
                                (BSL_META_U(unit,
                                            "SER Range HW Enable index %d\n"),
                                 hw_enable_ix));
                if (((range_enable >> hw_enable_ix) & 0x1) == 0) {
                    LOG_WARN(BSL_LS_SOC_SER,
                        (BSL_META_U(
                            unit,
                            "matched mem but SER detection is disabled\n"
                            "SER_RANGE_ENABLE 0x%X, SER Range HW index %d\n"),
                        range_enable, hw_enable_ix));
                    return rv; /* matched mem but ser_detection is disabled */
                }
                LOG_VERBOSE(BSL_LS_SOC_SER,
                                (BSL_META_U(unit,
                                            "TCAM found\n")));
                return SOC_E_NONE; /* found */
            }
        }
    }


    /* Search H/W memory (route blocks) */
    /* Loop through each place-and-route block entry */
    for (rbi = 0; ; rbi++) {
        rb = &_soc_hr3_ser_route_blocks[unit][rbi];
        if (rb->cmic_bit == 0) {
            /* End of table */
            break;
        }

        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                break;
            }
        }

        info_list = rb->info;
        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_hr3_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm) {
                continue;
            }
            /* Check if overlay memory */
            for (i=0; soc_ser_hr3_overlay_mems[i].mem != INVALIDm; i++) {
                if ((soc_ser_hr3_overlay_mems[i].mem == mem) &&
                    (soc_ser_hr3_overlay_mems[i].base_mem == memTable)) {
                    overlay_mem = 1;
                    LOG_DEBUG(BSL_LS_SOC_SER,
                                    (BSL_META_U(unit,
                                                "mem %s base_mem %s\n"),
                                     SOC_MEM_NAME(unit,mem),SOC_MEM_NAME(unit,memTable)));
                    break;
                }
            }
            if ((memTable == mem) || (overlay_mem)) {
                LOG_VERBOSE(BSL_LS_SOC_SER,
                                (BSL_META_U(unit,
                                            "H/W memory (route blocks) found\n")));
                return SOC_E_NONE;
            }
        }
    }
    /* The tested memory is not found in SER enabled list, can't inject error of it */
    return rv;
}


/*
 * Function:
 *      soc_hr3_ser_mem_test
 * Purpose:
 *      Performs a SER test on a single memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 *      cmd         - (IN) TRUE if a command-line test is desired.
 */
int soc_hr3_ser_test_mem(int unit, soc_mem_t mem,
                         _soc_ser_test_t test_type, int cmd)
{
    _soc_generic_ser_info_t *tcam_ser_info = _soc_hr3_tcam_ser_info[unit];
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf;
    uint8       rbi;
    const _soc_hr3_ser_route_block_t *rb;
    uint32      cmic_bit;
    int         block_info_idx;
    int         found_mem = FALSE;
    soc_mem_t   memTable;
    int         testErrors = 0;
    ser_test_data_t test_data;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_REG_FIELD_WORDS];
    int         i, overlay_mem = 0;
    int         rv = SOC_E_NONE;
    int         port = REG_PORT_ANY;
    _soc_hr3_ser_info_t *info_list, *info;
    int         info_index;
    uint32      wred_refresh = 0, reg_val;

    if (!SOC_MEM_IS_VALID(unit, mem)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d, mem %d is INVALID or not valid "
                              "for this unit !!\n"),
                   unit, mem));
        return SOC_E_UNAVAIL;
    }

    if (!SAL_BOOT_QUICKTURN) {
        soc_ser_test_long_sleep = TRUE;
        soc_ser_test_long_sleep_time_us = 500000;
    }
    if (tcam_ser_info != NULL) {
        /*TCAM_test*/
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            if (tcam_ser_info[i].mem == mem) {
                memTable = mem;
                found_mem = TRUE;
                soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                         SER_RANGE_ENABLEr, i, INVALIDf, memTable,
                                         VALIDf, MEM_BLOCK_ANY, REG_PORT_ANY,
                                         _SOC_ACC_TYPE_PIPE_ANY, 0, &test_data);
               if (cmd) {
                    ser_test_cmd_generate(unit, &test_data);
                } else {
                    rv = ser_test_mem(unit, 0, &test_data,
                                      test_type, &testErrors);
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(
                            unit,
                            "Error during TCAM test.  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                }
            }
        }
    }
    if (!found_mem) {
        /*H/W memory Test*/
        /* Loop through each place-and-route block entry */
        for (rbi = 0; ; rbi++) {
            rb = &_soc_hr3_ser_route_blocks[unit][rbi];
            cmic_bit = rb->cmic_bit;
            parity_enable_reg = INVALIDr;
            hw_parity_field = INVALIDf;
            if (cmic_bit == 0) {
                /* End of table */
                break;
            }
            SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                    port = SOC_BLOCK_PORT(unit, block_info_idx);
                    break;
                }
            }

            info_list = rb->info;
            if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
                parity_enable_reg = info_list[0].enable_reg;
                hw_parity_field = info_list[0].enable_field;
                info_list = info_list[0].info;
            }
            for (info_index = 0; ; info_index++) {
                info = &info_list[info_index];
                if (info->type == _SOC_PARITY_TYPE_NONE) {
                    /* End of table */
                    break;
                }
                if (_soc_hr3_ser_mem_skip(unit, info)) {
                    continue;
                }
                memTable = info->mem;
                if (memTable == INVALIDm) {
                    continue;
                }
                /* Check if overlay memory */
                for (i=0; soc_ser_hr3_overlay_mems[i].mem != INVALIDm; i++) {
                    if ((soc_ser_hr3_overlay_mems[i].mem == mem) &&
                        (soc_ser_hr3_overlay_mems[i].base_mem == memTable)) {
                        overlay_mem = 1;
                        break;
                    }
                }
                if ((memTable == mem) || (overlay_mem)) {
                    found_mem = TRUE;
                    if (parity_enable_reg == INVALIDr) {
                        parity_enable_reg = info->enable_reg;
                    }
                    if (hw_parity_field == INVALIDf) {
                        hw_parity_field = info->enable_field;
                    }
                    if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                        (memTable == MMU_WRED_MARK_THDm)) {
                        rv = soc_reg32_get(unit,
                                        FUNCTIONAL_REFRESH_ENr, port, 0,
                                        &reg_val);
                        if (rv != SOC_E_NONE) {
                            LOG_CLI((BSL_META_U(
                                unit,
                                "Error of getting WRED "
                                "refresh function  Aborting.\n")));
                            soc_ser_test_long_sleep = FALSE;
                            return rv;
                        }
                        wred_refresh = soc_reg_field_get(
                            unit, FUNCTIONAL_REFRESH_ENr,
                            reg_val, WRED_REFRESH_ENf);
                        if (wred_refresh) {
                            soc_reg_field_set(unit,
                                FUNCTIONAL_REFRESH_ENr, &reg_val,
                                WRED_REFRESH_ENf, 0);
                            rv = soc_reg32_set(unit,
                                FUNCTIONAL_REFRESH_ENr, port, 0,
                                reg_val);
                            if (rv != SOC_E_NONE) {
                                LOG_CLI((BSL_META_U(
                                    unit,
                                    "Error of disabling WRED "
                                    "refresh function  Aborting.\n")));
                                soc_ser_test_long_sleep = FALSE;
                                return rv;
                            }
                        }
                    }
                    soc_ser_create_test_data(unit, tmp_entry,
                                             fieldData,
                                             parity_enable_reg,
                                             SOC_INVALID_TCAM_PARITY_BIT,
                                             hw_parity_field,
                                             mem, EVEN_PARITYf, block_info_idx,
                                             port, _SOC_ACC_TYPE_PIPE_ANY,
                                             0, &test_data);
                    if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                        (memTable == MMU_WRED_MARK_THDm)) {
                        /* restore WRED refresh configuration */
                        if (wred_refresh) {
                            soc_reg_field_set(unit,
                                FUNCTIONAL_REFRESH_ENr, &reg_val,
                                WRED_REFRESH_ENf, 1);
                            rv = soc_reg32_set(unit,
                                FUNCTIONAL_REFRESH_ENr, port, 0,
                                reg_val);
                            if (rv != SOC_E_NONE) {
                                LOG_CLI((BSL_META_U(
                                    unit,
                                    "Error of enabling WRED "
                                    "refresh function  Aborting.\n")));
                                soc_ser_test_long_sleep = FALSE;
                                return rv;
                            }
                        }
                    }
                    if (cmd) {
                        ser_test_cmd_generate(unit, &test_data);
                    } else {
                        rv = ser_test_mem(unit, 0, &test_data,
                                          test_type, &testErrors);
                    }
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Error during H/W test.  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                    break;
                }
            }
            if (found_mem) {
                break;
            }
        }

    }
    if (!found_mem) {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test is unavaible on unit: %d for memory %s\n"), unit,
                 SOC_MEM_NAME(unit,mem)));
        return SOC_E_UNAVAIL;
    }

    if (testErrors == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test passed on unit: %d for memory %s\n"), unit,
                 SOC_MEM_NAME(unit,mem)));
    }
    else {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test failed on unit: %d for memory %s\n"), unit,
                 SOC_MEM_NAME(unit,mem)));
        soc_ser_test_long_sleep = FALSE;
        return SOC_E_MEMORY;
    }
    /* restore to default */
    soc_ser_test_long_sleep = FALSE;
    return SOC_E_NONE;

}

/*
 * Function:
 *      soc_hr3_ser_test
 * Purpose:
 *      Performs a SER test on all Memories
 * Parameters:
 *      unit               - (IN) Device Number
 *      test_type        - (IN) Determines how comprehensive of a test to run
 */
int soc_hr3_ser_test(int unit, _soc_ser_test_t test_type)
{
    _soc_generic_ser_info_t *tcam_ser_info = _soc_hr3_tcam_ser_info[unit];
    int         numTCAMErr = 0;
    int         numHwMemErr   = 0;
    soc_reg_t   parity_enable_reg = INVALIDr;
    soc_field_t hw_parity_field = INVALIDf, testfield;
    int         port = REG_PORT_ANY;
    uint8       rbi;
    const _soc_hr3_ser_route_block_t *rb;
    uint32      cmic_bit, reg_val;
    int         block_info_idx;
    int         rv = SOC_E_NONE;
    _soc_hr3_ser_info_t *info_list, *info;
    int         info_index;
    soc_mem_t   memTable = INVALIDm;
    uint32      wred_refresh = 0;

    if (!SAL_BOOT_QUICKTURN) {
        soc_ser_test_long_sleep = TRUE;
        soc_ser_test_long_sleep_time_us = 500000;
    }

    if (tcam_ser_info != NULL) {
        int         i;
        /*TCAM_test*/
        for (i = 0; tcam_ser_info[i].mem != INVALIDm; i++) {
            rv = ser_test_mem_pipe(unit, SER_RANGE_ENABLEr, i, -1,
                                   tcam_ser_info[i].mem, VALIDf, test_type,
                                   MEM_BLOCK_ANY, REG_PORT_ANY,
                                   _SOC_ACC_TYPE_PIPE_ANY, &numTCAMErr);
            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                                    "TR 144 test failed. "
                                    "Error during TCAM test.  Aborting.\n")));
                soc_ser_test_long_sleep = FALSE;
                return rv;
            }
        }
    }

    for (rbi = 0; ; rbi++) {
        rb = &_soc_hr3_ser_route_blocks[unit][rbi];
        cmic_bit = rb->cmic_bit;
        parity_enable_reg = INVALIDr;
        hw_parity_field = INVALIDf;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        SOC_BLOCK_ITER(unit, block_info_idx, rb->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_info_idx).number == rb->id) {
                port = SOC_BLOCK_PORT(unit, block_info_idx);
                break;
            }
        }
        info_list = rb->info;

        if (info_list[0].type == _SOC_PARITY_TYPE_MMU_SER) {
            parity_enable_reg = info_list[0].enable_reg;
            hw_parity_field = info_list[0].enable_field;
            info_list = info_list[0].info;
        }
        for (info_index = 0; ; info_index++) {
            info = &info_list[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (_soc_hr3_ser_mem_skip(unit, info)) {
                continue;
            }
            memTable = info->mem;
            if (memTable == INVALIDm){
                continue;
            }
            if (parity_enable_reg == INVALIDr) {
                parity_enable_reg = info->enable_reg;
            }
            if (hw_parity_field == INVALIDf) {
                hw_parity_field = info->enable_field;
            }
            testfield = INVALIDf;
            if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                (memTable == MMU_WRED_MARK_THDm)) {
                rv = soc_reg32_get(unit,
                                FUNCTIONAL_REFRESH_ENr, port, 0,
                                &reg_val);
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Error of getting WRED "
                                        "refresh function  Aborting.\n")));
                    soc_ser_test_long_sleep = FALSE;
                    return rv;
                }
                wred_refresh = soc_reg_field_get(
                    unit, FUNCTIONAL_REFRESH_ENr,
                    reg_val, WRED_REFRESH_ENf);
                if (wred_refresh) {
                    soc_reg_field_set(unit,
                        FUNCTIONAL_REFRESH_ENr, &reg_val,
                        WRED_REFRESH_ENf, 0);
                    rv = soc_reg32_set(unit,
                        FUNCTIONAL_REFRESH_ENr, port, 0,
                        reg_val);
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(
                            unit,
                            "Error of disabling WRED "
                            "refresh function  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                }
            }
            rv = ser_test_mem_pipe(unit, parity_enable_reg, -1,
                                   hw_parity_field,
                                   memTable, testfield, test_type,
                                   block_info_idx, port,
                                   _SOC_ACC_TYPE_PIPE_ANY, &numHwMemErr);

            if ((memTable == MMU_WRED_AVG_QSIZEm) ||
                (memTable == MMU_WRED_MARK_THDm)) {
                /* restore WRED refresh configuration */
                if (wred_refresh) {
                    soc_reg_field_set(unit,
                        FUNCTIONAL_REFRESH_ENr, &reg_val,
                        WRED_REFRESH_ENf, 1);
                    rv = soc_reg32_set(unit,
                        FUNCTIONAL_REFRESH_ENr, port, 0,
                        reg_val);
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(
                            unit,
                            "Error of enabling WRED "
                            "refresh function  Aborting.\n")));
                        soc_ser_test_long_sleep = FALSE;
                        return rv;
                    }
                }
            }

            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                                    "TR 144 test failed. "
                                    "Error during H/W test.  Aborting.\n")));
                soc_ser_test_long_sleep = FALSE;
                return rv;
            }
            if (rb->blocktype != SOC_BLK_MMU) {
                parity_enable_reg = INVALIDr;
                hw_parity_field = INVALIDf;
            }
        }
    }

    if ((numTCAMErr != 0) || (numHwMemErr != 0)) {
        LOG_CLI((BSL_META_U(unit,
                            "TR 144 test failed.\n")));
    }

    LOG_CLI((BSL_META_U(
        unit, "Total TCAM errors on unit %d: %d\n"), unit, numTCAMErr));
    LOG_CLI((BSL_META_U(
        unit, "Total H/W parity errors on unit %d: %d\n"),unit, numHwMemErr));
    soc_ser_test_long_sleep = FALSE;
    return SOC_E_NONE;
}

void
soc_hr3_ser_test_register(int unit)
{
    /*Initialize chip-specific functions for SER testing*/
    memset(&ser_hr3_test_fun, 0, sizeof(soc_ser_test_functions_t));
    ser_hr3_test_fun.inject_error_f = &soc_hr3_ser_inject_error;
    ser_hr3_test_fun.test_mem = &soc_hr3_ser_test_mem;
    ser_hr3_test_fun.test = &soc_hr3_ser_test;
    ser_hr3_test_fun.injection_support = &_ser_hr3_ser_error_injection_support;

    soc_ser_test_functions_register(unit, &ser_hr3_test_fun);
}
#endif /* SER_TR_TEST_SUPPORT */
