/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:        katana2.c
 * Purpose:
 * Requires:
 */


#include <shared/bsl.h>

#include <sal/core/boot.h>
#include <shared/bsl.h>
#include <soc/katana2.h>
#include <soc/trident.h>
#include <soc/bradley.h>
#include <soc/drv.h>
#include <soc/scache.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/mem.h>
#include <soc/hash.h>
#include <soc/shmoo_ddr40.h>
#include <soc/phy/ddr40.h>
#include <soc/mspi.h>
#include <soc/phyreg.h>
#include <soc/mmu_config.h>
#include <soc/soc_ser_log.h>
#include <soc/phy/phyctrl.h>

#ifdef BCM_CMICM_SUPPORT
#include <soc/cmicm.h>
#endif

#ifdef BCM_KATANA2_SUPPORT
#include <bcm_int/esw/katana2.h>
#include <bcm_int/esw/switch.h>
#include <soc/katana.h>
/* Min/Max threshold settings - 33 Gbps */
#define KT2_QUEUE_FLUSH_RATE_MANTISSA    1023
#define KT2_QUEUE_FLUSH_RATE_EXP         14
#define KT2_QUEUE_FLUSH_BURST_MANTISSA   124
#define KT2_QUEUE_FLUSH_BURST_EXP        14
#define KT2_QUEUE_FLUSH_CYCLE_SEL        0

/* Min/Max threshold settings - 2 Gbps */
#define KT2_QUEUE_MIN_RATE_MANTISSA    1
#define KT2_QUEUE_MIN_RATE_EXP         0
#define KT2_QUEUE_MIN_BURST_MANTISSA   0
#define KT2_QUEUE_MIN_BURST_EXP        0
#define KT2_QUEUE_MIN_CYCLE_SEL        4

#define _SOC_KT2_DEFIP_MAX_TCAMS   16
#define _SOC_KT2_DEFIP_TCAM_DEPTH  1024
#define KT2_MAX_NUMBER_INTERLEAVED_PKTS 512
#ifdef BCM_KATANA2_SUPPORT
#include <soc/saber2.h>
#endif
#ifdef BCM_METROLITE_SUPPORT
#include <soc/metrolite.h>
#endif

#ifdef BCM_WARM_BOOT_SUPPORT

#define KT2_MAX_TDM_SLOTS_VER_1_1         128
#define KT2_MAX_TDM_SLOTS                 256
#define KT2_MAX_WARPCORE_BLOCKS           2
#define BCM_WB_VERSION_1_1                SOC_SCACHE_VERSION(1,1)
#define BCM_WB_VERSION_1_2                SOC_SCACHE_VERSION(1,2)
#define BCM_WB_DEFAULT_VERSION            BCM_WB_VERSION_1_2

static uint8  scache_begin_magic_number[]={0xAA,0xBB,0xCC,0xDD};
static uint8  scache_end_magic_number[]={0xDD,0xCC,0xBB,0xAA};
static bcm56450_tdm_info_t kt2_scache_tdm_info[SOC_MAX_NUM_DEVICES]={{0}};
static uint32 kt2_scache_tdm[SOC_MAX_NUM_DEVICES][KT2_MAX_TDM_SLOTS]={{0}};
static uint32 kt2_scache_speed[SOC_MAX_NUM_DEVICES][KT2_MAX_PHYSICAL_PORTS]={{0}};
static soc_port_details_t kt2_scache_port_details[SOC_MAX_NUM_DEVICES]
                                       [KT2_MAX_PHYSICAL_PORTS+1]={{{0}}};
static uint8  kt2_scache_portgroup[SOC_MAX_NUM_DEVICES][KT2_MAX_MXQPORTS_PER_BLOCK *
                                   KT2_MAX_WARPCORE_BLOCKS]={{0}};
#endif

extern sal_mutex_t cosq_sync_lock[SOC_MAX_NUM_DEVICES];
#define KT2_COSQ_LOCK(unit)      do { \
                                    if (cosq_sync_lock[unit]) { \
                                        sal_mutex_take(cosq_sync_lock[unit], \
                                                       sal_mutex_FOREVER); \
                                    } \
                                } while (0)
#define KT2_COSQ_UNLOCK(unit)    do { \
                                    if (cosq_sync_lock[unit]) { \
                                        sal_mutex_give(cosq_sync_lock[unit]); \
                                    } \
                                } while (0)


extern int _bcm_kt_ipmc_port_ext_queue_count(int unit, int ipmc_id, bcm_port_t port);
extern int _bcm_kt2_ipmc_subscriber_egress_queue_ext_set(int unit, int port, int ipmc_id, int ext_mem_enable);
extern int _soc_katana2_mmu_init_phase4_port(int unit,int port);

static int flexio_lock;
/*
*   STATIC  Macro:
*   SOC_FLEXIO_LOCK
*   Purpose:
*   Lock take the flex status mutex
*/
#define SOC_FLEXIO_LOCK flexio_lock = sal_splhi()
/*
*  STATIC  Macro:
*  SOC_FLEXIO_UNLOCK
*  Purpose:
*  Unlock flex status mutex
*/
#define SOC_FLEXIO_UNLOCK sal_spl(flexio_lock)

int flex_io_operation_busy[SOC_MAX_NUM_DEVICES] = {0};

int _soc_kt2_config_get(int unit,
                        soc_kt2_sku_config_info_t *conf);
int soc_flex_io_operation_status_set(int unit, int value);
STATIC int soc_flex_io_operation_status_get(int unit,
                                        int *flex_io_operation_status);
typedef enum {
    _SOC_PARITY_TYPE_NONE,
    _SOC_PARITY_TYPE_GENERIC,
    _SOC_PARITY_TYPE_PARITY,
    _SOC_PARITY_TYPE_ECC,
    _SOC_PARITY_TYPE_HASH,
    _SOC_PARITY_TYPE_EDATABUF,
    _SOC_PARITY_TYPE_COUNTER,
    _SOC_PARITY_TYPE_SER,
    _SOC_PARITY_INFO_TYPE_OAM
} _soc_kt2_parity_info_type_t;

typedef enum {
    _SOC_KT2_MMU_SUBBLOCK_IPCTR,
    _SOC_KT2_MMU_SUBBLOCK_ADM,
    _SOC_KT2_MMU_SUBBLOCK_RDE,
    _SOC_KT2_MMU_SUBBLOCK_CI5,
    _SOC_KT2_MMU_SUBBLOCK_CI4,
    _SOC_KT2_MMU_SUBBLOCK_CI3,
    _SOC_KT2_MMU_SUBBLOCK_MEM1,
    _SOC_KT2_MMU_SUBBLOCK_INTFI,
    _SOC_KT2_MMU_SUBBLOCK_INTFI_ECC,
    _SOC_KT2_MMU_SUBBLOCK_E2EFC,
    _SOC_KT2_MMU_SUBBLOCK_ITE,
    _SOC_KT2_MMU_SUBBLOCK_ITE_CFG,
    _SOC_KT2_MMU_SUBBLOCK_THDI,
    _SOC_KT2_MMU_SUBBLOCK_ENQ_CFG,
    _SOC_KT2_MMU_SUBBLOCK_ENQ,
    _SOC_KT2_MMU_SUBBLOCK_ENQ_FAP,
    _SOC_KT2_MMU_SUBBLOCK_CI2,
    _SOC_KT2_MMU_SUBBLOCK_CI1,
    _SOC_KT2_MMU_SUBBLOCK_CI0,
    _SOC_KT2_MMU_SUBBLOCK_WRED,
    _SOC_KT2_MMU_SUBBLOCK_THDO_STATUS1,
    _SOC_KT2_MMU_SUBBLOCK_THDO_STATUS2,
    _SOC_KT2_MMU_SUBBLOCK_RQE_SER,
    _SOC_KT2_MMU_SUBBLOCK_RQE_EXTQ,
    _SOC_KT2_MMU_SUBBLOCK_EMC,
    _SOC_KT2_MMU_SUBBLOCK_DEQ,
    _SOC_KT2_MMU_SUBBLOCK_CTR,
    _SOC_KT2_MMU_SUBBLOCK_CFAPI,
    _SOC_KT2_MMU_SUBBLOCK_CFAPE,
    _SOC_KT2_MMU_SUBBLOCK_CCP,
    _SOC_KT2_MMU_SUBBLOCK_AGING_INT,
    _SOC_KT2_MMU_SUBBLOCK_AGING_EXT,
    _SOC_KT2_MMU_SUBBLOCK_LLS,
    _SOC_KT2_MMU_SUBBLOCK_LLS_PORT,
    _SOC_KT2_MMU_SUBBLOCK_LLS_L0_ECC,
    _SOC_KT2_MMU_SUBBLOCK_LLS_UPD2,
    _SOC_KT2_MMU_SUBBLOCK_LLS_L1_ECC,
    _SOC_KT2_MMU_SUBBLOCK_LLS_L2_ECC,
    _SOC_KT2_MMU_SUBBLOCK_LLS_MISC_ECC,
    _SOC_KT2_MMU_SUBBLOCK_QSTRUCT,
    _SOC_KT2_MMU_SUBBLOCK_TOQ,
    _SOC_KT2_MMU_SUBBLOCK_MAX
} _soc_katana2_mmu_subblock_type_t;

typedef enum {
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_0,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_1,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_2,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_3,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_0,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_1,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_2,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_3,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_4,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_U,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_L,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QBLOCK,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_FAP,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_2,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_1,
    _SOC_KT2_MMU_LVL2_SUBBLOCK_MAX
} _soc_katana2_mmu_lvl2_subblock_type_t;

typedef struct _soc_katana2_parity_reg_s {
    soc_reg_t          reg;
    char               *mem_str;
} _soc_katana2_parity_reg_t;

typedef struct _soc_katana2_parity_info_s {
    _soc_kt2_parity_info_type_t       type;
    struct _soc_katana2_parity_info_s *info;
    int                id;
    soc_field_t        group_reg_enable_field;
    soc_field_t        group_reg_status_field;
    soc_mem_t          mem;
    char               *mem_str;
    soc_reg_t          reg;
    soc_reg_t          enable_reg;
    soc_field_t        enable_field;
    soc_reg_t          intr_status_reg;
    _soc_katana2_parity_reg_t         *intr_status_reg_list;
    soc_reg_t                         nack_status_reg;
    _soc_katana2_parity_reg_t         *nack_status_reg_list;
} _soc_katana2_parity_info_t;

typedef struct _soc_katana2_parity_route_block_s {
    uint32             cmic_bit;
    soc_block_t        blocktype;
    soc_reg_t          enable_reg;
    soc_reg_t          status_reg;
    _soc_katana2_parity_info_t *info;
    uint8              id;
} _soc_katana2_parity_route_block_t;

typedef struct _soc_katana2_mmu_sub_block_leaf_info_s {
    uint32             intr_bit; /* bit position in intr register of 
                                    sub block */
    soc_field_t        status_field; /* INTR field of a leaf block */
    soc_field_t        enable_field; /* MASK field of a leaf block */
} _soc_katana2_mmu_sub_block_leaf_info_t;

typedef struct _soc_katana2_mmu_sub_block_internal_info_s {
    uint32             intr_bit; /* bit position in level 1 sub block INTR and 
                                    INTR_MASK */
    _soc_katana2_mmu_lvl2_subblock_type_t lvl2_sub_block; /* level 2 sub block 
                                                           */
    soc_field_t        internal_enable_field; /* field in 1evel 1 sub block INTR 
                                                 MASK register */
    soc_field_t        internal_status_field; /* field in level 1 sub block INTR 
                                                 register */
    soc_reg_t          leaf_enable_reg;   /* intr mask register for level 2 sub 
                                             block */
    soc_reg_t          leaf_status_reg;   /* intr register for level 2 sub block 
                                           */
    _soc_katana2_mmu_sub_block_leaf_info_t *info;
} _soc_katana2_mmu_sub_block_internal_info_t;

typedef struct _soc_katana2_mmu_sub_block_one_level_s {
    uint32             mmu_bit;  /* bit position in MMU_INTR and MMU_INTR_MASK 
                                  */
    _soc_katana2_mmu_subblock_type_t mmu_sub_block; /* level 1 sub block */
    soc_field_t        mmu_enable_field; /* field in MMU_INTR_MASK */
    soc_field_t        mmu_status_field; /* field in MMU_INTR */
    soc_reg_t          leaf_enable_reg; /* intr mask register for sub block */
    soc_reg_t          leaf_status_reg; /* intr register for sub block */
    _soc_katana2_mmu_sub_block_leaf_info_t *info; /* list of memory instances */
} _soc_katana2_mmu_sub_block_one_level_t;

typedef struct _soc_katana2_mmu_sub_block_two_level_s {
    uint32             mmu_bit; /* bit position in MMU_INTR and MMU_INTR_MASK */
    _soc_katana2_mmu_subblock_type_t mmu_sub_block; /* level 1 sub block */
    soc_field_t        mmu_enable_field; /* field in MMU_INTR_MASK */
    soc_field_t        mmu_status_field; /* field in MMU_INTR */
    soc_reg_t          internal_enable_reg; /* intr mask for sub block */
    soc_reg_t          internal_status_reg; /* intr for sub block */
    _soc_katana2_mmu_sub_block_internal_info_t *info;
} _soc_katana2_mmu_sub_block_two_level_t;


STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_vlan_xlate_intr_reg[] = {
    { EGR_VLAN_XLATE_PARITY_STATUS_INTR_0r, NULL },
    { EGR_VLAN_XLATE_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_vlan_xlate_nack_reg[] = {
    { EGR_VLAN_XLATE_PARITY_STATUS_NACK_0r, NULL },
    { EGR_VLAN_XLATE_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_vlan_xlate_intr_reg[] = {
    { VLAN_XLATE_PARITY_STATUS_INTR_0r, NULL },
    { VLAN_XLATE_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_vlan_xlate_nack_reg[] = {
    { VLAN_XLATE_PARITY_STATUS_NACK_0r, NULL },
    { VLAN_XLATE_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_mpls_entry_intr_reg[] = {
    { MPLS_ENTRY_PARITY_STATUS_INTR_0r, NULL },
    { MPLS_ENTRY_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_mpls_entry_nack_reg[] = {
    { MPLS_ENTRY_PARITY_STATUS_NACK_0r, NULL },
    { MPLS_ENTRY_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l3_entry_only_intr_reg[] = {
    { L3_ENTRY_PARITY_STATUS_INTR_0r, NULL },
    { L3_ENTRY_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l3_entry_only_nack_reg[] = {
    { L3_ENTRY_PARITY_STATUS_NACK_0r, NULL },
    { L3_ENTRY_PARITY_STATUS_NACK_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l2_entry_only_intr_reg[] = {
    { L2_ENTRY_PARITY_STATUS_INTR_0r, NULL },
    { L2_ENTRY_PARITY_STATUS_INTR_1r, NULL } };
    	
STATIC _soc_katana2_parity_reg_t _soc_katana2_l2_entry_only_nack_reg[] = {
    { L2_ENTRY_PARITY_STATUS_NACK_0r, NULL },
    { L2_ENTRY_PARITY_STATUS_NACK_1r, NULL } };

STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_mp_group_intr_reg[] = {
    { EGR_MP_GROUP_PARITY_STATUS_INTR_0r, NULL },
    { EGR_MP_GROUP_PARITY_STATUS_INTR_1r, NULL } };

STATIC _soc_katana2_parity_reg_t _soc_katana2_egr_mp_group_nack_reg[] = {
    { EGR_MP_GROUP_PARITY_STATUS_NACK_0r, NULL },
    { EGR_MP_GROUP_PARITY_STATUS_NACK_1r, NULL } };

STATIC _soc_katana2_parity_info_t _soc_katana2_xport_parity_info[] = {
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        TXFIFO_MEM_ERRf,
        TXFIFO_MEM_ERRf,
        INVALIDm, "TX FIFO",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_TXFIFO_MEM_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM0_ERRf,
        MIB_TSC_MEM0_ERRf,
        INVALIDm, "TX MIB MEM0",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM1_ERRf,
        MIB_TSC_MEM1_ERRf,
        INVALIDm, "TX MIB MEM1",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM2_ERRf,
        MIB_TSC_MEM2_ERRf,
        INVALIDm, "TX MIB MEM2",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_TSC_MEM3_ERRf,
        MIB_TSC_MEM3_ERRf,
        INVALIDm, "TX MIB MEM3",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_TSC_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM0_ERRf,
        MIB_RSC_MEM0_ERRf,
        INVALIDm, "RX MIB MEM0",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM1_ERRf,
        MIB_RSC_MEM1_ERRf,
        INVALIDm, "RX MIB MEM1",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM2_ERRf,
        MIB_RSC_MEM2_ERRf,
        INVALIDm, "RX MIB MEM2",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM3_ERRf,
        MIB_RSC_MEM3_ERRf,
        INVALIDm, "RX MIB MEM3",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MIB_RSC_MEM4_ERRf,
        MIB_RSC_MEM4_ERRf,
        INVALIDm, "RX MIB MEM4",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_MIB_RSC_MEM4_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM0_ERRf,
        RXFIFO_MEM0_ERRf,
        INVALIDm, "RX FIFO MEM0",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM0_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM1_ERRf,
        RXFIFO_MEM1_ERRf,
        INVALIDm, "RX FIFO MEM1",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM1_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM2_ERRf,
        RXFIFO_MEM2_ERRf,
        INVALIDm, "RX FIFO MEM2",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM2_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM3_ERRf,
        RXFIFO_MEM3_ERRf,
        INVALIDm, "RX FIFO MEM3",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM3_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RXFIFO_MEM4_ERRf,
        RXFIFO_MEM4_ERRf,
        INVALIDm, "RX FIFO MEM4",
        INVALIDr,
        INVALIDr, INVALIDf,
        XPORT_RXFIFO_MEM4_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_rxlp_parity_info[] = {
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        MAIN_BUFF_ECC_INTR_ENABLEf,
        MAIN_BUFF_ECC_INTR_STATUSf,
        INVALIDm, "main data buffer",
        INVALIDr,
        RXLP_ECC_PARITY_CONTROLr, DATABUF_ECC_ENf,
        RXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CTRL_BUFFER_ECC_INTR_ENABLEf,
        CTRL_BUFF_ECC_INTR_STATUSf,
        INVALIDm, "ctrl data buffer",
        INVALIDr,
        RXLP_ECC_PARITY_CONTROLr, CTRLBUF_ECC_ENf,
        RXLP_CTRLBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RESIDUAL_CRC_ECC_INTR_ENABLEf,
        RESIDUAL_CRC_ECC_INTR_STATUSf,
        INVALIDm, "Residual CRC Buffer ",
        INVALIDr,
        RXLP_ECC_PARITY_CONTROLr, RESIDUALCRC_ECC_ENf,
        RXLP_RESIDUAL_CRC_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_BUF_ECC_INTR_ENABLEf,
        IARB_BUF_ECC_INTR_STATUSf,
        INVALIDm, "IARB Buffer",
        INVALIDr,
        RXLP_ECC_PARITY_CONTROLr, IARBBUF_ECC_ENf,
        RXLP_IARBBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRIGGER_MEM_PARITY_ERR_INTR_ENABLEf,
        TRIGGER_MEM_PARITY_ERRf,
        INVALIDm, "IARB Buffer",
        INVALIDr,
        RXLP_ECC_PARITY_CONTROLr, TRIGGERS_MEM_PARITY_ENf,
        RXLP_TRIGGER_MEM_PARITY_STATUSr, NULL,
        RXLP_TRIGGER_MEM_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        COUNTER_MEM_PARITY_ERR_INTR_ENABLEf,
        COUNTER_MEM_PARITY_ERRf,
        INVALIDm, "IARB Buffer",
        INVALIDr,
        RXLP_ECC_PARITY_CONTROLr, COUNTERS_MEM_PARITY_ENf,
        RXLP_COUNTER_MEM_PARITY_STATUSr, NULL,
        RXLP_COUNTER_MEM_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_txlp_parity_info[] = {
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        INT2EXT_PARITY_ERRf,
        INT2EXT_PARITY_ERRf,
        INVALIDm, "INT2EXT-MAP-TABLE",
        INVALIDr,
        TXLP_ECC_PARITY_CONTROLr, INT2EXT_STREAM_MAP_PARITY_ENf,
        TXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RESICRCBUF_PARITY_ERRf,
        RESICRCBUF_PARITY_ERRf,
        INVALIDm, "RESIDUAL-CRC-BUFFER",
        INVALIDr,
        TXLP_ECC_PARITY_CONTROLr, RESICRCBUF_PARITY_ENf,
        TXLP_RESICRCBUF_PARITY_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        RESIDATABUF_ECC_ERRf,
        RESIDATABUF_ECC_ERRf,
        INVALIDm, "RESIDUAL-DATA-BUFFER",
        INVALIDr,
        TXLP_ECC_PARITY_CONTROLr, RESIDATABUF_ECC_ENf,
        TXLP_RESIDATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        DATABUF_ECC_ERRf,
        DATABUF_ECC_ERRf,
        INVALIDm, "MAIN-DATA-BUFFER.",
        INVALIDr,
        TXLP_ECC_PARITY_CONTROLr, DATABUF_ECC_ENf,
        TXLP_DATABUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        CTRLBUF_ECC_ERRf,
        CTRLBUF_ECC_ERRf,
        INVALIDm, "MAIN-CTRL-BUFFER.",
        INVALIDr,
        TXLP_ECC_PARITY_CONTROLr, CTRLBUF_ECC_ENf,
        TXLP_CTRLBUF_ECC_STATUSr, NULL,
        INVALIDr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRIGGER_MEM_PARITY_ERRf,
        TRIGGER_MEM_PARITY_ERRf,
        INVALIDm, "TXLP_DEBUG_COUNTER[0-7]",
        INVALIDr,
        TXLP_ECC_PARITY_CONTROLr, TRIGGERS_MEM_PARITY_ENf,
        TXLP_TRIGGER_MEM_PARITY_STATUSr, NULL,
        TXLP_TRIGGER_MEM_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        COUNTER_MEM_PARITY_ERRf,
        COUNTER_MEM_PARITY_ERRf,
        INVALIDm, "TXLP_DEBUG_COUNTER[8-11]",
        INVALIDr,
        TXLP_ECC_PARITY_CONTROLr, COUNTERS_MEM_PARITY_ENf,
        TXLP_COUNTER_MEM_PARITY_STATUSr, NULL,
        TXLP_COUNTER_MEM_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};


STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_ipctr_parity_info[] = {
    /* MMU_IPCTR_ECC_ERROR_0 */
    { 0x0020, CTXT_COUNTER_0_CORRECTED_ERRORf,
	     CTXT_COUNTER_0_CORRECTED_ERROR_DISINTf},
    { 0x0010, CTXT_COUNTER_0_UNCORRECTED_ERRORf,
	     CTXT_COUNTER_0_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, PG_COUNTER_1_CORRECTED_ERRORf,
	     PG_COUNTER_1_CORRECTED_ERROR_DISINTf},
    { 0x0004, PG_COUNTER_1_UNCORRECTED_ERRORf,
	     PG_COUNTER_1_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, PG_COUNTER_0_CORRECTED_ERRORf,
	     PG_COUNTER_0_CORRECTED_ERROR_DISINTf},
    { 0x0001, PG_COUNTER_0_UNCORRECTED_ERRORf,
	     PG_COUNTER_0_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_adm_parity_info[] = {
    /* MMU_ADM_ECC_ERROR_0 */
    { 0x0008, SRC_CTXT_DB_CORRECTED_ERRORf,
	     SRC_CTXT_DB_CORRECTED_ERROR_DISINTf},
    { 0x0004, SRC_CTXT_DB_UNCORRECTED_ERRORf,
	     SRC_CTXT_DB_UNCORRECTED_ERROR_ERROR_DISINTf},
    { 0x0002, QUEUE_DB_CORRECTED_ERRORf,
	     QUEUE_DB_CORRECTED_ERROR_DISINTf},
    { 0x0001, QUEUE_DB_UNCORRECTED_ERRORf,
	     QUEUE_DB_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_rde_parity_info[] = {
    /* RDE_SER_STATUS */
    { 0x1000000, ITE_REL_FIFO_FULLf,
	     ITE_REL_FIFO_FULL_MASKf},
	  { 0x800000, PQE_CELL_FIFO_FULLf,
	     PQE_CELL_FIFO_FULL_MASKf},
	  { 0x400000, DEQ_CELL_FIFO_FULLf,
	     DEQ_CELL_FIFO_FULL_MASKf},
	  { 0x200000, RPFAP_DUPLICATE_PTRf,
	     RPFAP_DUPLICATE_PTR_MASKf},
	  { 0x100000, TXQ_FLL_EMPTYf,
	     TXQ_FLL_EMPTY_MASKf}, 
    { 0x0FFC00, ECC_1B_BITMAPf,
	     ECC_1B_MASKf},
    { 0x3FF, ECC_2B_BITMAPf,
	     ECC_2B_MASKf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_lls_parity_info[] = {
    /* LLS_ERROR */
    { 0x80000000, VBS_ILLEGAL_CONFIG_INTERRUPTf,
       VBS_ILLEGAL_CONFIG_INTERRUPT_DISINTf},
    { 0x40000000, S1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
       S1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x20000000, ENQ_TO_ACTIVE_QUEUE_VIOL_INTERRUPTf,
       ENQ_TO_ACTIVE_QUEUE_VIOL_INTERRUPT_DISINTf},
    { 0x10000000, PORT_1_IN_4_DEQ_VIOL_INTERRUPTf,
       PORT_1_IN_4_DEQ_VIOL_INTERRUPT_DISINTf},
    { 0x8000000, S0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
       S0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x4000000, PORT_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     PORT_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x2000000, L0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L0_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x1000000, L1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L1_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x800000, L2_UPPER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_UPPER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x400000, L2_LOWER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_LOWER_MAX_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x200000, L0_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L0_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x100000, L1_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L1_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x80000, L2_UPPER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_UPPER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},
    { 0x40000, L2_LOWER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPTf,
	     L2_LOWER_MIN_SHAPER_REFRESH_CYCLE_INTERRUPT_DISINTf},

    /* The following fields need to be left with reset value in
     * lls_error_mask as recommended. These fields are used only
     * for debugging */

    /*
    { 0x20000, MAX_SHAPER_BUCKET_UNDERFLOW_PORTf,
	     MAX_SHAPER_BUCKET_UNDERFLOW_PORT_DISINTf},
    { 0x10000, MAX_SHAPER_BUCKET_UNDERFLOW_L0f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L0_DISINTf},
    { 0x8000, MAX_SHAPER_BUCKET_UNDERFLOW_L1f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L1_DISINTf},
    { 0x4000, MAX_SHAPER_BUCKET_UNDERFLOW_L2_UPPERf,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L2_UPPER_DISINTf},
    { 0x2000, MAX_SHAPER_BUCKET_UNDERFLOW_L2_LOWERf,
	     MAX_SHAPER_BUCKET_UNDERFLOW_L2_LOWER_DISINTf},
    { 0x1000, MIN_SHAPER_BUCKET_UNDERFLOW_L0f,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L0_DISINTf},
    { 0x0800, MIN_SHAPER_BUCKET_UNDERFLOW_L1f,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L1_DISINTf},
    { 0x0400, MIN_SHAPER_BUCKET_UNDERFLOW_L2_UPPERf,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L2_UPPER_DISINTf},
    { 0x0200, MIN_SHAPER_BUCKET_UNDERFLOW_L2_LOWERf,
	     MIN_SHAPER_BUCKET_UNDERFLOW_L2_LOWER_DISINTf},
    */
    { 0x0100, MAX_SHAPER_BUCKET_OVERFLOW_PORTf,
	     MAX_SHAPER_BUCKET_OVERFLOW_PORT_DISINTf},
    { 0x0080, MAX_SHAPER_BUCKET_OVERFLOW_L0f,
	     MAX_SHAPER_BUCKET_OVERFLOW_L0_DISINTf},
    { 0x0040, MAX_SHAPER_BUCKET_OVERFLOW_L1f,
	     MAX_SHAPER_BUCKET_OVERFLOW_L1_DISINTf},
    { 0x0020, MAX_SHAPER_BUCKET_OVERFLOW_L2_UPPERf,
	     MAX_SHAPER_BUCKET_OVERFLOW_L2_UPPER_DISINTf},
    { 0x0010, MAX_SHAPER_BUCKET_OVERFLOW_L2_LOWERf,
	     MAX_SHAPER_BUCKET_OVERFLOW_L2_LOWER_DISINTf},
    { 0x0008, MIN_SHAPER_BUCKET_OVERFLOW_L0f,
	     MIN_SHAPER_BUCKET_OVERFLOW_L0_DISINTf},
    { 0x0004, MIN_SHAPER_BUCKET_OVERFLOW_L1f,
	     MIN_SHAPER_BUCKET_OVERFLOW_L1_DISINTf},
    { 0x0002, MIN_SHAPER_BUCKET_OVERFLOW_L2_UPPERf,
	     MIN_SHAPER_BUCKET_OVERFLOW_L2_UPPER_DISINTf},
    { 0x0001, MIN_SHAPER_BUCKET_OVERFLOW_L2_LOWERf,
	     MIN_SHAPER_BUCKET_OVERFLOW_L2_LOWER_DISINTf},
    { 0 } /* table terminator */ 
};

STATIC 
_soc_katana2_mmu_sub_block_leaf_info_t _soc_katana2_mmu_sb_lls2_parity_info[] = {
    /* LLS_ERROR2 */
    { 0x0080, ENQ_PORT_FROM_S1_ID_MULTIPLE_MATCH_ERRORf,
	     ENQ_PORT_FROM_S1_ID_MULTIPLE_MATCH_ERRORf},
    { 0x0040, ENQ_PORT_FROM_S1_ID_S1_NOT_ON_PORT_ERRORf,
	     ENQ_PORT_FROM_S1_ID_S1_NOT_ON_PORT_ERROR_DISINTf},
    { 0x0020, PORT_L2_COUNT_OVERFLOWf,
	     PORT_L2_COUNT_OVERFLOW_DISINTf},
    { 0x0010, PORT_L2_COUNT_UNDERRUNf,
	     PORT_L2_COUNT_UNDERRUN_DISINTf},
    { 0x0008, MAX_SHAPER_BUCKET_OVERFLOW_S1f,
	     MAX_SHAPER_BUCKET_OVERFLOW_S1f},
    { 0x0004, MAX_SHAPER_BUCKET_UNDERFLOW_S1f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_S1f},
    { 0x0002, MAX_SHAPER_BUCKET_OVERFLOW_S0f,
	     MAX_SHAPER_BUCKET_OVERFLOW_S0_DISINTf},
    { 0x0001, MAX_SHAPER_BUCKET_UNDERFLOW_S0f,
	     MAX_SHAPER_BUCKET_UNDERFLOW_S0_DISINTf},
    { 0 } /* table terminator */ 
};

/* LLS_ERROR_UPD2 */
STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                  _soc_katana2_mmu_sb_lls_upd2_parity_info [] = {
    { 0x1000, UPD2_PORT_1_IN_4_VIOLATED_INTERRUPTf,
	     UPD2_PORT_1_IN_4_VIOLATED_INTERRUPT_DISINTf},
	  { 0x0800, UPD2_S1_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_S1_ERROR_UNDERRUN_INTERRUPT_DISINTf},
	  { 0x0400, UPD2_S1_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_S1_ERROR_OVERFLOW_INTERRUPT_DISINTf},
	  { 0x0200, UPD2_S0_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_S0_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0100, UPD2_S0_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_S0_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0080, UPD2_PORT_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_PORT_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0040, UPD2_PORT_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_PORT_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0020, UPD2_L0_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_L0_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0010, UPD2_L0_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_L0_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0008, UPD2_L1_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_L1_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0004, UPD2_L1_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_L1_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0x0002, UPD2_L2_ERROR_UNDERRUN_INTERRUPTf,
	     UPD2_L2_ERROR_UNDERRUN_INTERRUPT_DISINTf},
    { 0x0001, UPD2_L2_ERROR_OVERFLOW_INTERRUPTf,
	     UPD2_L2_ERROR_OVERFLOW_INTERRUPT_DISINTf},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                  _soc_katana2_mmu_sb_lls_port_parity_info [] = {
       /* LLS_PORT_ECC_ERROR */
    { 0x8000, DB_S1_TAILS_CORRECTED_ERRORf,
  	      DB_S1_TAILS_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_S1_TAILS_UNCORRECTED_ERRORf,
  	      DB_S1_TAILS_UNCORRECTED_ERROR_DISINTf},
  	{ 0x2000, DB_S1_SHAPER_BUCKET_CORRECTED_ERRORf,
  	      DB_S1_SHAPER_BUCKET_CORRECTED_ERROR_DISINTf},
  	{ 0x1000, DB_S1_SHAPER_BUCKET_UNCORRECTED_ERRORf,
  	      DB_S1_SHAPER_BUCKET_UNCORRECTED_ERROR_DISINTf},
  	{ 0x0800, DB_S1_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_S1_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
  	{ 0x0400, DB_S1_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_S1_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
  	{ 0x0200, DB_S0_SHAPER_BUCKET_CORRECTED_ERRORf,
  	      DB_S0_SHAPER_BUCKET_CORRECTED_ERROR_DISINTf},
  	{ 0x0100, DB_S0_SHAPER_BUCKET_UNCORRECTED_ERRORf,
  	      DB_S0_SHAPER_BUCKET_UNCORRECTED_ERROR_DISINTf},
  	{ 0x0080, DB_S0_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_S0_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
  	{ 0x0040, DB_S0_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_S0_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0020, DB_PORT_TDM_CORRECTED_ERRORf,
  	      DB_PORT_TDM_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_PORT_TDM_UNCORRECTED_ERRORf,
  	      DB_PORT_TDM_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_PORT_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_PORT_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_PORT_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_PORT_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_PORT_WERR_MAX_SC_CORRECTED_ERRORf,
  	      DB_PORT_WERR_MAX_SC_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_PORT_WERR_MAX_SC_UNCORRECTED_ERRORf,
  	      DB_PORT_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */

};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t
                _soc_katana2_mmu_sb_lls_l0_ecc_parity_info [] = {
         /* LLS_L0_ECC_ERROR1 */
    { 0x8000000, DB_L0_MIN_NEXT_CORRECTED_ERRORf,
  	      DB_L0_MIN_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x4000000, DB_L0_MIN_NEXT_UNCORRECTED_ERRORf,
  	      DB_L0_MIN_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x2000000, DB_L0_PARENT_CORRECTED_ERRORf,
  	      DB_L0_PARENT_CORRECTED_ERROR_DISINTf},
    { 0x1000000, DB_L0_PARENT_UNCORRECTED_ERRORf,
  	      DB_L0_PARENT_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, DB_L0_CONFIG_CORRECTED_ERRORf,
  	      DB_L0_CONFIG_CORRECTED_ERROR_DISINTf},
    { 0x400000, DB_L0_CONFIG_UNCORRECTED_ERRORf,
  	      DB_L0_CONFIG_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, DB_L0_MIN_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L0_MIN_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x100000, DB_L0_MIN_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L0_MIN_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x80000, DB_L0_PARENT_STATE_CORRECTED_ERRORf,
  	      DB_L0_PARENT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x40000, DB_L0_PARENT_STATE_UNCORRECTED_ERRORf,
  	      DB_L0_PARENT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, DB_L0_HEADS_TAILS_CORRECTED_ERRORf,
  	      DB_L0_HEADS_TAILS_CORRECTED_ERROR_DISINTf},
    { 0x10000, DB_L0_HEADS_TAILS_UNCORRECTED_ERRORf,
  	      DB_L0_HEADS_TAILS_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, DB_L0_WERR_MAX_SC_CORRECTED_ERRORf,
  	      DB_L0_WERR_MAX_SC_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_L0_WERR_MAX_SC_UNCORRECTED_ERRORf,
  	      DB_L0_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, DB_L0_MIN_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L0_MIN_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x1000, DB_L0_MIN_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L0_MIN_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L0_CHILD_STATE1_CORRECTED_ERRORf,
  	      DB_L0_CHILD_STATE1_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L0_CHILD_STATE1_UNCORRECTED_ERRORf,
  	      DB_L0_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L0_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
  	      DB_L0_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L0_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
  	      DB_L0_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L0_WERR_NEXT_CORRECTED_ERRORf,
  	      DB_L0_WERR_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L0_WERR_NEXT_UNCORRECTED_ERRORf,
  	      DB_L0_WERR_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L0_EF_NEXT_CORRECTED_ERRORf,
  	      DB_L0_EF_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L0_EF_NEXT_UNCORRECTED_ERRORf,
  	      DB_L0_EF_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L0_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L0_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L0_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L0_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L0_SHAPER_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L0_SHAPER_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L0_SHAPER_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L0_SHAPER_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */

};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_lls_l1_ecc_parity_info [] = {
             /* LLS_L1_ECC_ERROR1 */
    { 0x8000000, DB_L1_MIN_NEXT_CORRECTED_ERRORf,
  	      DB_L1_MIN_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x4000000, DB_L1_MIN_NEXT_UNCORRECTED_ERRORf,
  	      DB_L1_MIN_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x2000000, DB_L1_PARENT_CORRECTED_ERRORf,
  	      DB_L1_PARENT_CORRECTED_ERROR_DISINTf},
    { 0x1000000, DB_L1_PARENT_UNCORRECTED_ERRORf,
  	      DB_L1_PARENT_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, DB_L1_CONFIG_CORRECTED_ERRORf,
  	      DB_L1_CONFIG_CORRECTED_ERROR_DISINTf},
    { 0x400000, DB_L1_CONFIG_UNCORRECTED_ERRORf,
  	      DB_L1_CONFIG_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, DB_L1_MIN_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L1_MIN_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x100000, DB_L1_MIN_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L1_MIN_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x80000, DB_L1_PARENT_STATE_CORRECTED_ERRORf,
  	      DB_L1_PARENT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x40000, DB_L1_PARENT_STATE_UNCORRECTED_ERRORf,
  	      DB_L1_PARENT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, DB_L1_HEADS_TAILS_CORRECTED_ERRORf,
  	      DB_L1_HEADS_TAILS_CORRECTED_ERROR_DISINTf},
    { 0x10000, DB_L1_HEADS_TAILS_UNCORRECTED_ERRORf,
  	      DB_L1_HEADS_TAILS_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, DB_L1_WERR_MAX_SC_CORRECTED_ERRORf,
  	      DB_L1_WERR_MAX_SC_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_L1_WERR_MAX_SC_UNCORRECTED_ERRORf,
  	      DB_L1_WERR_MAX_SC_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, DB_L1_MIN_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L1_MIN_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x1000, DB_L1_MIN_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L1_MIN_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L1_CHILD_STATE1_CORRECTED_ERRORf,
  	      DB_L1_CHILD_STATE1_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L1_CHILD_STATE1_UNCORRECTED_ERRORf,
  	      DB_L1_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L1_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
  	      DB_L1_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L1_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
  	      DB_L1_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L1_WERR_NEXT_CORRECTED_ERRORf,
  	      DB_L1_WERR_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L1_WERR_NEXT_UNCORRECTED_ERRORf,
  	      DB_L1_WERR_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L1_EF_NEXT_CORRECTED_ERRORf,
  	      DB_L1_EF_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L1_EF_NEXT_UNCORRECTED_ERRORf,
  	     DB_L1_EF_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L1_SHAPER_CONFIG_C_CORRECTED_ERRORf,
  	      DB_L1_SHAPER_CONFIG_C_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L1_SHAPER_CONFIG_C_UNCORRECTED_ERRORf,
  	      DB_L1_SHAPER_CONFIG_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L1_SHAPER_BUCKET_C_CORRECTED_ERRORf,
  	      DB_L1_SHAPER_BUCKET_C_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L1_SHAPER_BUCKET_C_UNCORRECTED_ERRORf,
  	      DB_L1_SHAPER_BUCKET_C_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_lls_l2_ecc_parity_info [] = {
             /*   LLS_L2_ECC_ERROR1 */
    { 0x2000000, DB_L2_MIN_CONFIG_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x1000000, DB_L2_MIN_CONFIG_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, DB_L2_MIN_BUCKET_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x400000, DB_L2_MIN_BUCKET_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, DB_L2_SHAPER_CONFIG_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x100000, DB_L2_SHAPER_CONFIG_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x80000, DB_L2_SHAPER_BUCKET_UPPER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_UPPER_C_CORRECTED_ERROR_DISINTf},
    { 0x40000, DB_L2_SHAPER_BUCKET_UPPER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_UPPER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, DB_L2_MIN_CONFIG_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x10000, DB_L2_MIN_CONFIG_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_CONFIG_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, DB_L2_MIN_BUCKET_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x4000, DB_L2_MIN_BUCKET_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_BUCKET_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, DB_L2_SHAPER_CONFIG_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x1000, DB_L2_SHAPER_CONFIG_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_CONFIG_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L2_SHAPER_BUCKET_LOWER_C_CORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_LOWER_C_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L2_SHAPER_BUCKET_LOWER_C_UNCORRECTED_ERRORf,
  	      DB_L2_SHAPER_BUCKET_LOWER_C_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L2_CHILD_STATE1_CORRECTED_ERRORf,
  	      DB_L2_CHILD_STATE1_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L2_CHILD_STATE1_UNCORRECTED_ERRORf,
  	      DB_L2_CHILD_STATE1_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L2_PARENT_CORRECTED_ERRORf,
  	      DB_L2_PARENT_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L2_PARENT_UNCORRECTED_ERRORf,
  	      DB_L2_PARENT_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L2_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERRORf,
  	      DB_L2_CHILD_WEIGHT_CFG_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L2_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERRORf,
  	      DB_L2_CHILD_WEIGHT_CFG_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L2_WERR_NEXT_CORRECTED_ERRORf,
  	      DB_L2_WERR_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L2_WERR_NEXT_UNCORRECTED_ERRORf,
  	      DB_L2_WERR_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L2_MIN_NEXT_CORRECTED_ERRORf,
  	      DB_L2_MIN_NEXT_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L2_MIN_NEXT_UNCORRECTED_ERRORf,
  	      DB_L2_MIN_NEXT_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_lls_misc_ecc_parity_info [] = {
              /* LLS_MISC_ECC_ERROR1 */
    { 0x200000, DB_S1_ERROR_CORRECTED_ERRORf,
  	      DB_S1_ERROR_CORRECTED_ERROR_DISINTf},
  	{ 0x100000, DB_S1_ERROR_UNCORRECTED_ERRORf,
  	      DB_S1_ERROR_UNCORRECTED_ERROR_DISINTf},
  	{ 0x80000, DB_S0_ERROR_CORRECTED_ERRORf,
  	      DB_S0_ERROR_CORRECTED_ERRORf},
  	{ 0x40000, DB_S0_ERROR_UNCORRECTED_ERRORf,
  	      DB_S0_ERROR_UNCORRECTED_ERROR_DISINTf},
  	{ 0x20000, DB_L0_ERROR_MIN_CORRECTED_ERRORf,
  	      DB_L0_ERROR_MIN_CORRECTED_ERROR_DISINTf},
  	{ 0x10000, DB_L0_ERROR_MIN_UNCORRECTED_ERRORf,
  	      DB_L0_ERROR_MIN_UNCORRECTED_ERROR_DISINTf},
  	{ 0x8000, DB_L1_ERROR_MIN_CORRECTED_ERRORf,
  	      DB_L1_ERROR_MIN_CORRECTED_ERROR_DISINTf},
  	{ 0x4000, DB_L1_ERROR_MIN_UNCORRECTED_ERRORf,
  	      DB_L1_ERROR_MIN_UNCORRECTED_ERROR_DISINTf},
  	{ 0x2000, DB_L2_ERROR_MIN_CORRECTED_ERRORf,
  	      DB_L2_ERROR_MIN_CORRECTED_ERROR_DISINTf},
  	{ 0x1000, DB_L2_ERROR_MIN_UNCORRECTED_ERRORf,
  	      DB_L2_ERROR_MIN_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, DB_L2_ACT_XON_CORRECTED_ERRORf,
  	      DB_L2_ACT_XON_CORRECTED_ERROR_DISINTf},
    { 0x0400, DB_L2_ACT_XON_UNCORRECTED_ERRORf,
  	      DB_L2_ACT_XON_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, DB_L2_ACT_SHAPER_CORRECTED_ERRORf,
  	      DB_L2_ACT_SHAPER_CORRECTED_ERROR_DISINTf},
    { 0x0100, DB_L2_ACT_SHAPER_UNCORRECTED_ERRORf,
  	      DB_L2_ACT_SHAPER_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, DB_L2_ACT_MIN_CORRECTED_ERRORf,
  	      DB_L2_ACT_MIN_CORRECTED_ERROR_DISINTf},
    { 0x0040, DB_L2_ACT_MIN_UNCORRECTED_ERRORf,
  	      DB_L2_ACT_MIN_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, DB_L0_ERROR_CORRECTED_ERRORf,
  	      DB_L0_ERROR_CORRECTED_ERROR_DISINTf},
    { 0x0010, DB_L0_ERROR_UNCORRECTED_ERRORf,
  	      DB_L0_ERROR_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, DB_L1_ERROR_CORRECTED_ERRORf,
  	      DB_L1_ERROR_CORRECTED_ERROR_DISINTf},
    { 0x0004, DB_L1_ERROR_UNCORRECTED_ERRORf,
  	      DB_L1_ERROR_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, DB_L2_ERROR_CORRECTED_ERRORf,
  	      DB_L2_ERROR_CORRECTED_ERROR_DISINTf},
    { 0x0001, DB_L2_ERROR_UNCORRECTED_ERRORf,
  	      DB_L2_ERROR_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */

};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                        _soc_katana2_mmu_sb_mem1_parity_info [] = {
    /* CLINK_ERROR */
    { 0x0008, CLINKE_CORRECTED_ERRORf,
        CLINKE_CORRECTED_ERROR_DISINTf },
    { 0x0004, CLINKE_UNCORRECTED_ERRORf,
        CLINKE_UNCORRECTED_ERROR_DISINTf },
    { 0x0002, CLINKI_CORRECTED_ERRORf,
        CLINKI_CORRECTED_ERROR_DISINTf },
    { 0x0001, CLINKI_UNCORRECTED_ERRORf,
        CLINKI_UNCORRECTED_ERROR_DISINTf },
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_e2efc_parity_info [] = {
    /* MMU_E2EFC_ERROR_0 */
    { 0x0200, E2EFC_QEN_CNT_UNDERRUNf,
        E2EFC_QEN_CNT_UNDERRUN_DISINTf},
    { 0x0100, E2EFC_QEN_CNT_OVERFLOWf,
        E2EFC_QEN_CNT_OVERFLOW_DISINTf},
    { 0x0080, E2EFC_RQE_CNT_UNDERRUNf,
        E2EFC_RQE_CNT_UNDERRUN_DISINTf},
    { 0x0040, E2EFC_RQE_CNT_OVERFLOWf,
        E2EFC_RQE_CNT_OVERFLOW_DISINTf},
    { 0x0020, E2EFC_EMA_CNT_UNDERRUNf,
        E2EFC_EMA_CNT_UNDERRUN_DISINTf},
    { 0x0010, E2EFC_EMA_CNT_OVERFLOWf,
        E2EFC_EMA_CNT_OVERFLOW_DISINTf},
    { 0x0008, E2EFC_EXT_CNT_UNDERRUNf,
        E2EFC_EXT_CNT_UNDERRUN_DISINTf},
    { 0x0004, E2EFC_EXT_CNT_OVERFLOWf,
        E2EFC_EXT_CNT_OVERFLOW_DISINTf},
    { 0x0002, E2EFC_INT_CNT_UNDERRUNf,
        E2EFC_INT_CNT_UNDERRUN_DISINTf},
    { 0x0001, E2EFC_INT_CNT_OVERFLOWf,
        E2EFC_INT_CNT_OVERFLOW_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_thdi_parity_info [] = {
    /* MMU_THDI_INTR */
    { 0x0010, THDI_INTR_4f, THDI_INTR_4_DISINTf},
    { 0x0008, THDI_INTR_3f, THDI_INTR_3_DISINTf},
    { 0x0004, THDI_INTR_2f, THDI_INTR_2_DISINTf},
    { 0x0002, THDI_INTR_1f, THDI_INTR_1_DISINTf},
    { 0x0001, THDI_INTR_0f, THDI_INTR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                      _soc_katana2_mmu_sb_ctr_parity_info [] = {
    /* CTR_ERROR */
    { 0x0100, CTR_RQE_FIFO_OVERFLOW_ERRORf,
        CTR_RQE_FIFO_OVERFLOW_ERROR_DISINTf},
    { 0x0080, CTR_ENQ_WRAP_ERRORf,
        CTR_ENQ_WRAP_ERROR_DISINTf},
    { 0x0040, CTR_DEQ_WRAP_ERRORf,
        CTR_DEQ_WRAP_ERROR_DISINTf},
    { 0x0020, CTR_DEQ_STATUS_CORRECTED_ERRORf,
        CTR_DEQ_STATUS_CORRECTED_ERROR_DISINTf},
    { 0x0010, CTR_DEQ_STATUS_UNCORRECTED_ERRORf,
        CTR_DEQ_STATUS_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, CTR_RQE_FIFO_CORRECTED_ERRORf,
        CTR_RQE_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0004, CTR_RQE_FIFO_UNCORRECTED_ERRORf,
        CTR_RQE_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, CTR_FLEX_CNT_CORRECTED_ERRORf,
        CTR_FLEX_CNT_CORRECTED_ERROR_DISINTf},
    { 0x0001, CTR_FLEX_CNT_UNCORRECTED_ERRORf,
        CTR_FLEX_CNT_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                    _soc_katana2_mmu_sb_ccp_parity_info [] = {
    /* CCP_ERROR */
    { 0x0200, CCPE_FIFO_CORRECTED_ERRORf,
         CCPE_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0100, CCPE_FIFO_UNCORRECTED_ERRORf,
         CCPE_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, CCPI_FIFO_CORRECTED_ERRORf,
         CCPI_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0040, CCPI_FIFO_UNCORRECTED_ERRORf,
         CCPI_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, CCPI_RQE_UPD_NEGATIVEf,
         CCPI_RQE_UPD_NEGATIVE_DISINTf},
    { 0x0010, CCPE_RQE_UPD_NEGATIVEf,
         CCPE_RQE_UPD_NEGATIVE_DISINTf},
    { 0x0008, CCPE_CORRECTED_ERRORf,
         CCPE_CORRECTED_ERROR_DISINTf},
    { 0x0004, CCPE_UNCORRECTED_ERRORf,
         CCPE_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, CCPI_CORRECTED_ERRORf,
         CCPI_CORRECTED_ERROR_DISINTf},
    { 0x0001, CCPI_UNCORRECTED_ERRORf,
         CCPI_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                        _soc_katana2_mmu_sb_toq2_parity_info [] = {
    /* TOQ_ERROR2 */
    { 0x2000, REPL_HEAD_WRAPf,
         REPL_HEAD_WRAP_DISINTf},
    { 0x1000, PQE_CREDIT_UNDERRUNf,
         PQE_CREDIT_UNDERRUN_DISINTf},
    { 0x0800, PQE_CREDIT_OVERFLOWf,
         PQE_CREDIT_OVERFLOW_DISINTf},
    { 0x0400, QEN_ALLOC_UNDERRUNf,
         QEN_ALLOC_UNDERRUN_DISINTf},
    { 0x0200, QEN_ALLOC_OVERFLOWf,
         QEN_ALLOC_OVERFLOW_DISINTf},
    { 0x0100, FLUSH_COMPLETEf,
         FLUSH_COMPLETE_DISINTf},
    { 0x0080, QDIS_FIFO_OVERFLOWf,
         QDIS_FIFO_OVERFLOW_DISINTf},
    { 0x0040, TRACE_DEQ_EVENTf,
         TRACE_DEQ_EVENT_DISINTf},
    { 0x0020, TRACE_ENQ_EVENTf,
         TRACE_ENQ_EVENT_DISINTf},
    { 0x0010, DEQ_TO_EMPTY_QUEUE_ERRORf,
         DEQ_TO_EMPTY_QUEUE_ERROR_DISINTf},
    { 0x0008, QSTRUCT_EMPTY_ERRORf,
         QSTRUCT_EMPTY_ERROR_DISINTf},
    { 0x0004, QUEUE_OVELOAD_ERRORf,
         QUEUE_OVELOAD_ERROR_DISINTf},
    { 0x0002, TDM_VIOLATION_ERRORf,
         TDM_VIOLATION_ERROR_DISINTf},
    { 0x0001, RQE_FIFO_OVERFLOWf,
         RQE_FIFO_OVERFLOW_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                        _soc_katana2_mmu_sb_toq1_parity_info [] = {
    /* TOQ_ERROR1 */
    { 0x80000, QPACK_MODE_TBL_CORRECTED_ERRORf,
         QPACK_MODE_TBL_CORRECTED_ERROR_DISINTf},
    { 0x40000, QPACK_MODE_TBL_UNCORRECTED_ERRORf,
         QPACK_MODE_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, EOPE_TBL_CORRECTED_ERRORf,
         EOPE_TBL_CORRECTED_ERROR_DISINTf},
    { 0x10000, EOPE_TBL_UNCORRECTED_ERRORf,
         EOPE_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, REPL_MAP_TBL_CORRECTED_ERRORf,
         REPL_MAP_TBL_CORRECTED_ERROR_DISINTf},
    { 0x4000, REPL_MAP_TBL_UNCORRECTED_ERRORf,
         REPL_MAP_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, REPL_STATE_TBL_CORRECTED_ERRORf,
         REPL_STATE_TBL_CORRECTED_ERROR_DISINTf},
    { 0x1000, REPL_STATE_TBL_UNCORRECTED_ERRORf,
         REPL_STATE_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, PORT_STATE_CORRECTED_ERRORf,
         PORT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x0400, PORT_STATE_UNCORRECTED_ERRORf,
         PORT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, RQE_FIFO_CORRECTED_ERRORf,
         RQE_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0100, RQE_FIFO_UNCORRECTED_ERRORf,
         RQE_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, REPL_GRP_TBL_CORRECTED_ERRORf,
         REPL_GRP_TBL_CORRECTED_ERROR_DISINTf},
    { 0x0040, REPL_GRP_TBL_UNCORRECTED_ERRORf,
         REPL_GRP_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, REPL_HEAD_TBL_CORRECTED_ERRORf,
         REPL_HEAD_TBL_CORRECTED_ERROR_DISINTf},
    { 0x0010, REPL_HEAD_TBL_UNCORRECTED_ERRORf,
         REPL_HEAD_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, REPL_LIST_TBL_CORRECTED_ERRORf,
         REPL_LIST_TBL_CORRECTED_ERROR_DISINTf},
    { 0x0004, REPL_LIST_TBL_UNCORRECTED_ERRORf,
         REPL_LIST_TBL_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, TOQ_STATE_CORRECTED_ERRORf,
         TOQ_STATE_CORRECTED_ERROR_DISINTf},
    { 0x0001, TOQ_STATE_UNCORRECTED_ERRORf,
         TOQ_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};


STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                         _soc_katana2_mmu_sb_ite_parity_info [] = {
    /* MMU_ITE_ERROR_0  */
    { 0x0008, ITE_WORK_QUEUE_RD_EMPTYf,
        ITE_WORK_QUEUE_RD_EMPTY_DISINTf},
    { 0x0004, ITE_WORK_QUEUE_WR_FULLf,
        ITE_WORK_QUEUE_WR_FULL_DISINTf},
    { 0x0002, ITE_CTRL_RD_EMPTYf,
        ITE_CTRL_RD_EMPTY_DISINTf},
    { 0x0001, ITE_CTRL_WR_FULLf,
        ITE_CTRL_WR_FULL_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                         _soc_katana2_mmu_sb_ite_cfg_parity_info [] = {
    /* MMU_ITE_CFG_ECC_ERROR_0 */
    { 0x0800, SOP_CONTROL_ECC_0_CORRECTED_ERRORf,
        SOP_CONTROL_ECC_0_CORRECTED_ERROR_DISINTf},
    { 0x0400, SOP_CONTROL_ECC_0_UNCORRECTED_ERRORf,
        SOP_CONTROL_ECC_0_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, PACKET_PTR_STORE_CORRECTED_ERRORf,
        PACKET_PTR_STORE_FORCE_CORRECTED_ERROR_DISINTf},
    { 0x0100, PACKET_PTR_STORE_UNCORRECTED_ERRORf,
        PACKET_PTR_STORE_FORCE_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, ITE_WORK_QUEUE_CORRECTED_ERRORf,
        ITE_WORK_QUEUE_FORCE_CORRECTED_ERROR_DISINTf},
    { 0x0040, ITE_WORK_QUEUE_UNCORRECTED_ERRORf,
        ITE_WORK_QUEUE_FORCE_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, ITE_CTRL_CORRECTED_ERRORf,
        ITE_CTRL_CORRECTED_ERROR_DISINTf},
    { 0x0010, ITE_CTRL_UNCORRECTED_ERRORf,
        ITE_CTRL_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, ITE_QMGR_FLL_CORRECTED_ERRORf,
        ITE_QMGR_FLL_FORCE_CORRECTED_ERROR_DISINTf},
    { 0x0004, ITE_QMGR_FLL_UNCORRECTED_ERRORf,
        ITE_QMGR_FLL_FORCE_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, ITE_QMGR_QLL_CORRECTED_ERRORf,
        ITE_QMGR_QLL_CORRECTED_ERROR_DISINTf},
    { 0x0001, ITE_QMGR_QLL_UNCORRECTED_ERRORf,
        ITE_QMGR_QLL_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                           _soc_katana2_mmu_sb_enq_cfg_parity_info [] = {
    /* MMU_ENQ_CFG_ECC_ERROR_0 */
    { 0x800000, CBI_CORRECTED_ERRORf,
            CBI_CORRECTED_ERROR_DISINTf},
    { 0x400000, CBI_UNCORRECTED_ERRORf,
            CBI_UNCORRECTED_ERROR_DISINTf},
    { 0x200000, ITE_REORDER_FIFO_CORRECTED_ERRORf,
            ITE_REORDER_FIFO_CORRECTED_ERRORf},
    { 0x100000, ITE_REORDER_FIFO_UNCORRECTED_ERRORf,
            ITE_REORDER_FIFO_UNCORRECTED_ERRORf},
    { 0x80000, PACKING_PKT_LEN_FIFOS_CORRECTED_ERRORf,
            PACKING_PKT_LEN_FIFOS_CORRECTED_ERROR_DISINTf},
    { 0x40000, PACKING_PKT_LEN_FIFOS_UNCORRECTED_ERRORf,
            PACKING_PKT_LEN_FIFOS_UNCORRECTED_ERROR_DISINTf},
    { 0x20000, PACKING_PORT_FIFOS_CORRECTED_ERRORf,
            PACKING_PORT_FIFOS_CORRECTED_ERROR_DISINTf},
    { 0x10000, PACKING_PORT_FIFOS_UNCORRECTED_ERRORf,
            PACKING_PORT_FIFOS_UNCORRECTED_ERROR_DISINTf},
    { 0x8000, PACKING_CTXT_FIFOS_FP_LL_CORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_FP_LL_CORRECTED_ERROR_DISINTf},
    { 0x4000, PACKING_CTXT_FIFOS_FP_LL_UNCORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_FP_LL_UNCORRECTED_ERROR_DISINTf},
    { 0x2000, PACKING_CTXT_FIFOS_CORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_CORRECTED_ERROR_DISINTf},
    { 0x1000, PACKING_CTXT_FIFOS_UNCORRECTED_ERRORf,
            PACKING_CTXT_FIFOS_UNCORRECTED_ERROR_DISINTf},
    { 0x0800, CFAPI_INTERNAL_RECYCLE_CORRECTED_ERRORf,
            CFAPI_INTERNAL_RECYCLE_CORRECTED_ERROR_DISINTf},
    { 0x0400, CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERRORf,
            CFAPI_INTERNAL_RECYCLE_UNCORRECTED_ERROR_DISINTf},
    { 0x0200, SRC_PPP_TO_S1_LOOKUP_CORRECTED_ERRORf,
            SRC_PPP_TO_S1_LOOKUP_CORRECTED_ERROR_DISINTf},
    { 0x0100, SRC_PPP_TO_S1_LOOKUP_UNCORRECTED_ERRORf,
            SRC_PPP_TO_S1_LOOKUP_UNCORRECTED_ERROR_DISINTf},
    { 0x0080, SRC_PORT_STATE_CORRECTED_ERRORf,
            SRC_PORT_STATE_CORRECTED_ERROR_DISINTf},
    { 0x0040, SRC_PORT_STATE_UNCORRECTED_ERRORf,
            SRC_PORT_STATE_UNCORRECTED_ERROR_DISINTf},
    { 0x0020, SOP_STORE_CORRECTED_ERRORf,
            SOP_STORE_CORRECTED_ERROR_DISINTf},
    { 0x0010, SOP_STORE_UNCORRECTED_ERRORf,
            SOP_STORE_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, RQE_WR_COMPLETE_CORRECTED_ERRORf,
            RQE_WR_COMPLETE_CORRECTED_ERROR_DISINTf},
    { 0x0004, RQE_WR_COMPLETE_UNCORRECTED_ERRORf,
            RQE_WR_COMPLETE_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, CBP_32B_WR_STORE_CORRECTED_ERRORf,
            CBP_32B_WR_STORE_CORRECTED_ERROR_DISINTf},
    { 0x0001, CBP_32B_WR_STORE_UNCORRECTED_ERRORf,
            CBP_32B_WR_STORE_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                            _soc_katana2_mmu_sb_enq_parity_info [] = {
    /* MMU_ENQ_ERROR_0 */
    { 0x0010, FAP_DUPLICATE_PTRf,
            FAP_DUPLICATE_PTR_DISINTf},
    { 0x0008, ENQ_TRACE_STATUSf,
            ENQ_TRACE_STATUS_DISINTf},
    { 0x0004, ILLEGAL_CELL_PBIf,
            ILLEGAL_CELL_PBI_DISINTf},
    { 0x0002, MISSING_START_ERRf,
            MISSING_START_ERR_DISINTf},
    { 0x0001, START_BY_START_ERRf,
            START_BY_START_ERR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_enq_fap_parity_info [] = {
    /* MMU_ENQ_FAP_ECC_ERROR_0 */
    { 0x0008, FAP_STACK_CORRECTED_ERRORf,
            FAP_STACK_CORRECTED_ERROR_DISINTf},
    { 0x0004, FAP_STACK_UNCORRECTED_ERRORf,
            FAP_STACK_UNCORRECTED_ERROR_ERROR_DISINTf},
    { 0x0002, FAP_BITMAP_CORRECTED_ERRORf,
            FAP_BITMAP_CORRECTED_ERROR_DISINTf},
    { 0x0001, FAP_BITMAP_UNCORRECTED_ERRORf,
            FAP_BITMAP_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_thdo_stat1_parity_info [] = {
    /* THDO_PARITY_ERROR_STATUS1 */
    { 0xfffff, ECC_1B_ERROR_STATUSf, ECC_1B_MASKf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                     _soc_katana2_mmu_sb_thdo_stat2_parity_info [] = {
    /* THDO_PARITY_ERROR_STATUS2 */
    { 0xfffff, ECC_2B_ERROR_STATUSf, ECC_2B_MASKf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                    _soc_katana2_mmu_sb_cfapi_parity_info [] = {
    /* CFAPI_ECC_ERROR */
    { 0x0010, DUPLICATE_PTRf,
        DUPLICATE_PTR_DISINTf},
    { 0x0008, BITMAP_CORRECTED_ERRORf,
        BITMAP_CORRECTED_ERROR_DISINTf},
    { 0x0004, BITMAP_UNCORRECTED_ERRORf,
        BITMAP_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, STACK_CORRECTED_ERRORf,
        STACK_CORRECTED_ERROR_DISINTf},
    { 0x0001, STACK_UNCORRECTED_ERRORf,
        STACK_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                    _soc_katana2_mmu_sb_cfape_parity_info [] = {
    /* CFAPE_ECC_ERROR */
    { 0x0010, DUPLICATE_PTRf,
        DUPLICATE_PTR_DISINTf},
    { 0x0008, BITMAP_CORRECTED_ERRORf,
        BITMAP_CORRECTED_ERROR_DISINTf},
    { 0x0004, BITMAP_UNCORRECTED_ERRORf,
        BITMAP_UNCORRECTED_ERROR_DISINTf},
    { 0x0002, STACK_CORRECTED_ERRORf,
        STACK_CORRECTED_ERROR_DISINTf},
    { 0x0001, STACK_UNCORRECTED_ERRORf,
        STACK_UNCORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                      _soc_katana2_mmu_sb_age_int_parity_info [] = {
    /* AGING_ERROR_INT */
    { 0x0020, LMT_CORRECTED_ERRORf, LMT_CORRECTED_ERROR_DISINTf}, 
    { 0x0010, LMT_UNCORRECTED_ERRORf, LMT_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0008, CTR_CORRECTED_ERRORf, CTR_CORRECTED_ERROR_DISINTf}, 
    { 0x0004, CTR_UNCORRECTED_ERRORf, CTR_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0002, EXP_CORRECTED_ERRORf, EXP_CORRECTED_ERROR_DISINTf}, 
    { 0x0001, EXP_UNCORRECTED_ERRORf, EXP_UNCORRECTED_ERROR_DISINTf}, 
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                                _soc_katana2_mmu_sb_age_ext_parity_info [] = {
    { 0x0020, LMT_CORRECTED_ERRORf, LMT_CORRECTED_ERROR_DISINTf}, 
    { 0x0010, LMT_UNCORRECTED_ERRORf, LMT_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0008, CTR_CORRECTED_ERRORf, CTR_CORRECTED_ERROR_DISINTf}, 
    { 0x0004, CTR_UNCORRECTED_ERRORf, CTR_UNCORRECTED_ERROR_DISINTf}, 
    { 0x0002, EXP_CORRECTED_ERRORf, EXP_CORRECTED_ERROR_DISINTf}, 
    { 0x0001, EXP_UNCORRECTED_ERRORf, EXP_UNCORRECTED_ERROR_DISINTf}, 
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                _soc_katana2_mmu_sb_rqe_extq_parity_info [] = {
    { 0x4000000, REPLICATION_SRCH_FAILf, REPLICATION_SRCH_FAIL_MASKf }, 
    { 0x2000000, REPLICATION_OVER_LIMITf, REPLICATION_OVER_LIMIT_MASKf},
    { 0x1ffe000, REPLICATION_FAIL_MGIDf , 0 }, 
    { 0x0001fff, REPLICATION_COUNTf, 0 }, 
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                _soc_katana2_mmu_sb_ci_parity_info [] = {
    { 0x0100, PHY_READY_EVENTf,
       PHY_READYf},
    { 0x0080, PHY_BL1_RD_FIFO_ERRORf,
       PHY_BL1_RD_FIFO_ERRORf},
    { 0x0040, PHY_BL0_RD_FIFO_ERRORf,
       PHY_BL0_RD_FIFO_ERRORf},
    { 0x0020, WFIFO_CTL_CORRECTED_ERRORf,
       WFIFO_CTL_CORRECTED_ERROR_DISINTf},
    { 0x0010, WFIFO_CTL_UNCORRECTED_ERRORf,
       WFIFO_CTL_UNCORRECTED_ERROR_DISINTf},
    { 0x0008, WFIFO_OVERFLOWf,
       WB_OVERFLOW_DISINTf},
    { 0x0004, RFIFO_CTL_CORRECTED_ERRORf,
       RFIFO_CTL_CORRECTED_ERROR_DISINTf},
    { 0x0002, RFIFO_CTL_UNCORRECTED_ERRORf,
       RFIFO_CTL_UNCORRECTED_ERROR_DISINTf},
    { 0x0001, RFIFO_OVERFLOWf,
       RFIFO_OVERFLOW_DISINTf},
    { 0 } /* table terminator */

};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                         _soc_katana2_mmu_sb_emc0_parity_info [] = {
    /* EMC_ERROR_0 */
    { 0x0020, EMC_WTAC_SPC_EMA_LOCKUP_ERRORf, 
         EMC_WTAC_SPC_EMA_LOCKUP_ERROR_DISINTf },
    { 0x0010, EMC_WLCT2_MF_BUFFER_OVERFLOW_ERRORf, 
         EMC_WLCT2_MF_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0008, EMC_WLCT1_MF_BUFFER_OVERFLOW_ERRORf, 
         EMC_WLCT1_MF_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0004, EMC_WLCT0_MF_BUFFER_OVERFLOW_ERRORf, 
         EMC_WLCT0_MF_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0002, EMC_IRRB_BUFFER_OVERFLOW_ERRORf, 
         EMC_IRRB_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0x0001, EMC_IWRB_BUFFER_OVERFLOW_ERRORf, 
         EMC_IWRB_BUFFER_OVERFLOW_ERROR_DISINTf },
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                                 _soc_katana2_mmu_sb_emc1_parity_info [] = {
    /* EMC_ERROR_1 */
    { 0x20000000, EMC_CSDB_2_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_2_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x10000000, EMC_CSDB_2_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_2_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x8000000, EMC_CSDB_1_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_1_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x4000000, EMC_CSDB_1_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_1_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x2000000, EMC_CSDB_0_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_0_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x1000000, EMC_CSDB_0_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_0_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x800000, EMC_ERRB_1_BUFFER_UNCORRECTED_ERRORf,
        EMC_ERRB_1_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x400000, EMC_ERRB_1_BUFFER_CORRECTED_ERRORf,
        EMC_ERRB_1_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x200000, EMC_ERRB_0_BUFFER_UNCORRECTED_ERRORf,
        EMC_ERRB_0_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x100000, EMC_ERRB_0_BUFFER_CORRECTED_ERRORf,    
        EMC_ERRB_0_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x80000, EMC_RFCQ_BUFFER_UNCORRECTED_ERRORf,      
        EMC_RFCQ_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x40000, EMC_RFCQ_BUFFER_CORRECTED_ERRORf,    
        EMC_RFCQ_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x20000, EMC_RSFP_BUFFER_UNCORRECTED_ERRORf,      
        EMC_RSFP_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x10000, EMC_RSFP_BUFFER_CORRECTED_ERRORf,    
        EMC_RSFP_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x8000, EMC_IRRB_BUFFER_UNCORRECTED_ERRORf,      
        EMC_IRRB_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x4000, EMC_IRRB_BUFFER_CORRECTED_ERRORf,    
        EMC_IRRB_BUFFER_CORRECTED_ERROR_DISINTf},    
    { 0x2000, EMC_EWRB_0_BUFFER_1_UNCORRECTED_ERRORf,      
        EMC_EWRB_0_BUFFER_1_UNCORRECTED_ERROR_DISINTf},      
    { 0x1000, EMC_EWRB_0_BUFFER_1_CORRECTED_ERRORf,    
        EMC_EWRB_0_BUFFER_1_CORRECTED_ERROR_DISINTf},    
    { 0x0800, EMC_EWRB_0_BUFFER_0_UNCORRECTED_ERRORf,      
        EMC_EWRB_0_BUFFER_0_UNCORRECTED_ERROR_DISINTf},      
    { 0x0400, EMC_EWRB_0_BUFFER_0_CORRECTED_ERRORf,    
        EMC_EWRB_0_BUFFER_0_CORRECTED_ERROR_DISINTf},    
    { 0x0200, EMC_WCMT_BUFFER_UNCORRECTED_ERRORf,      
        EMC_WCMT_BUFFER_UNCORRECTED_ERROR_DISINTf},      
    { 0x0100, EMC_WCMT_BUFFER_CORRECTED_ERRORf,     
        EMC_WCMT_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0080, EMC_SWAT_BUFFER_UNCORRECTED_ERRORf,       
        EMC_SWAT_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0040, EMC_SWAT_BUFFER_CORRECTED_ERRORf,     
        EMC_SWAT_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0020, EMC_WTOQ_BUFFER_UNCORRECTED_ERRORf,       
        EMC_WTOQ_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0010, EMC_WTOQ_BUFFER_CORRECTED_ERRORf,     
        EMC_WTOQ_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0008, EMC_WTFP_BUFFER_UNCORRECTED_ERRORf,       
        EMC_WTFP_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0004, EMC_WTFP_BUFFER_CORRECTED_ERRORf,     
        EMC_WTFP_BUFFER_CORRECTED_ERROR_DISINTf},     
    { 0x0002, EMC_IWRB_BUFFER_UNCORRECTED_ERRORf,       
        EMC_IWRB_BUFFER_UNCORRECTED_ERROR_DISINTf},       
    { 0x0001, EMC_IWRB_BUFFER_CORRECTED_ERRORf,     
        EMC_IWRB_BUFFER_CORRECTED_ERROR_DISINTf},  
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                          _soc_katana2_mmu_sb_emc2_parity_info [] = {
    /* EMC_ERROR_2 */
    { 0x20000000, EMC_CSDB_5_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_5_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x10000000, EMC_CSDB_5_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_5_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x08000000, EMC_CSDB_4_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_4_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x04000000, EMC_CSDB_4_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_4_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x02000000, EMC_CSDB_3_UPPER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_3_UPPER_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x01000000, EMC_CSDB_3_LOWER_BUFFER_UNCORRECTED_ERRORf,
        EMC_CSDB_3_LOWER_BUFFER_UNCORRECTED_ERROR_DISINTf},    
    { 0x00800000, EMC_WLCT2_UPPER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_UPPER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x00400000, EMC_WLCT2_UPPER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_UPPER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0200000, EMC_WLCT2_UPPER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_UPPER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0100000, EMC_WLCT2_UPPER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_UPPER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0080000, EMC_WLCT2_LOWER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_LOWER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0040000, EMC_WLCT2_LOWER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_LOWER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0020000, EMC_WLCT2_LOWER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT2_LOWER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0010000, EMC_WLCT2_LOWER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT2_LOWER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0008000, EMC_WLCT1_UPPER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_UPPER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0004000, EMC_WLCT1_UPPER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_UPPER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0002000, EMC_WLCT1_UPPER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_UPPER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0001000, EMC_WLCT1_UPPER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_UPPER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000800, EMC_WLCT1_LOWER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_LOWER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000400, EMC_WLCT1_LOWER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_LOWER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000200, EMC_WLCT1_LOWER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT1_LOWER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000100, EMC_WLCT1_LOWER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT1_LOWER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000080, EMC_WLCT0_UPPER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_UPPER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000040, EMC_WLCT0_UPPER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_UPPER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000020, EMC_WLCT0_UPPER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_UPPER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000010, EMC_WLCT0_UPPER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_UPPER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000008, EMC_WLCT0_LOWER_B_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_LOWER_B_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000004, EMC_WLCT0_LOWER_B_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_LOWER_B_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0x0000002, EMC_WLCT0_LOWER_A_BUFFER_UNCORRECTED_ERRORf,
        EMC_WLCT0_LOWER_A_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x0000001, EMC_WLCT0_LOWER_A_BUFFER_CORRECTED_ERRORf,
        EMC_WLCT0_LOWER_A_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                          _soc_katana2_mmu_sb_emc3_parity_info [] = {
    /* EMC_ERROR_3 */
    { 0x0008000, EMC_CI5_FIXED_PATTERN_ERRORf,
        EMC_CI5_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0004000, EMC_CI4_FIXED_PATTERN_ERRORf,
        EMC_CI4_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0002000, EMC_CI3_FIXED_PATTERN_ERRORf,
        EMC_CI3_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0001000, EMC_CI2_FIXED_PATTERN_ERRORf,
        EMC_CI2_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0000800, EMC_CI1_FIXED_PATTERN_ERRORf,
        EMC_CI1_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0000400, EMC_CI0_FIXED_PATTERN_ERRORf,
        EMC_CI0_FIXED_PATTERN_ERROR_DISINTf},
    { 0x0000200, EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERRORf,
        EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0000100, EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERRORf,
        EMC_WLCT2_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0000080, EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERRORf,
        EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0000040, EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERRORf,
        EMC_WLCT1_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0000020, EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERRORf,
        EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_UNCORRECTED_ERROR_DISINTf},
    { 0x0000010, EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERRORf,
        EMC_WLCT0_MERGED_RETURN_WTAG_FIFO_CORRECTED_ERROR_DISINTf},
    { 0x0000008, EMC_EWRB_1_BUFFER_1_UNCORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_1_UNCORRECTED_ERROR_DISINTf},
    { 0x0000004, EMC_EWRB_1_BUFFER_1_CORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_1_CORRECTED_ERROR_DISINTf},
    { 0x0000002, EMC_EWRB_1_BUFFER_0_UNCORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_0_UNCORRECTED_ERROR_DISINTf},
    { 0x0000001, EMC_EWRB_1_BUFFER_0_CORRECTED_ERRORf,
        EMC_EWRB_1_BUFFER_0_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_internal_info_t
               _soc_katana2_mmu_sb_emc_parity_info [] = {
    { 0x0008, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_3, 
      0,
      EMC_ERROR_3f,
      EMC_ERROR_MASK_3r,
      EMC_ERROR_3r,
      _soc_katana2_mmu_sb_emc3_parity_info },
      
    { 0x0004, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_2, 
    	0,
      EMC_ERROR_2f,
      EMC_ERROR_MASK_2r,
      EMC_ERROR_2r,
      _soc_katana2_mmu_sb_emc2_parity_info },
      
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_1,
    	0,
      EMC_ERROR_1f,
      EMC_ERROR_MASK_1r,
      EMC_ERROR_1r, 
      _soc_katana2_mmu_sb_emc1_parity_info },
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_EMC_ERROR_0,
    	0,
    	EMC_ERROR_0f,
    	EMC_ERROR_MASK_0r,
      EMC_ERROR_0r, 
      _soc_katana2_mmu_sb_emc0_parity_info },
      
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_internal_info_t
               _soc_katana2_mmu_sb_toq_parity_info [] = {
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_2,
    	TOQ_ERROR2_DISINTf,
      TOQ_ERROR2f,
      TOQ_ERROR2_MASKr,
      TOQ_ERROR2r, 
      _soc_katana2_mmu_sb_toq2_parity_info },
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_TOQ_ERROR_1,
    	TOQ_ERROR1_DISINTf,
    	TOQ_ERROR1_ERRORf,
    	TOQ_ERROR1_MASKr,
      TOQ_ERROR1r, 
      _soc_katana2_mmu_sb_toq1_parity_info },
      
    { 0 } /* table terminator */

};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t
                                  _soc_katana2_mmu_sb_deq0_parity_info [] = {
    { 0x0800, DEQ_RDE_TRACE_EVENTf, 
    	DEQ_RDE_TRACE_EVENT_DISINTf},
    { 0x0400, CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_2_ERRORf, 
    	CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_2_ERROR_DISINTf},
    { 0x0200, CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_1_ERRORf, 
    	CCBE_CONTROL_DATA_REPLICATION_CREDIT_RETURN_1_ERROR_DISINTf},
    { 0x0100, CCBE_CONTROL_DATA_REPLICATION_ERRORf, 
    	CCBE_CONTROL_DATA_REPLICATION_ERROR_DISINTf},
    { 0x0080, CELL_CLASSIFICATION_EXT_ERRORf, 
    	CELL_CLASSIFICATION_EXT_ERROR_DISINTf},
    { 0x0040, CELL_CLASSIFICATION_INT_ERRORf, 
    	CELL_CLASSIFICATION_INT_ERROR_DISINTf},
    { 0x0020, RD_CTRL_RD_REQ_DISCARD_ERRORf, 
    	RD_CTRL_RD_REQ_DISCARD_ERROR_DISINTf},
    { 0x0010, DEQ_TRACE_EVENTf, 
    	DEQ_TRACE_EVENT_DISINTf},
    { 0x0008, EGRESS_FIFO_OVERFLOW_ERRORf, 
    	EGRESS_FIFO_OVERFLOW_ERROR_DISINTf},
    { 0x0004, EGRESS_FIFO_UNDERRUN_ERRORf,
        EGRESS_FIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0002, TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_RD_REQ_ERRORf,
        DEQ_TO_CFG_TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_RD_REQ_ERROR_DISINTf}, 
    { 0x0001, TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_WR_REQ_ERRORf,
        DEQ_TO_CFG_TOQ_TO_DEQ_CELL_REP_INFO_BUFFER_WR_REQ_ERROR_DISINTf}, 
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq1_parity_info [] = {
    { 0x0200, PORT_41_EFIFO_UNDERRUN_ERRORf,         
        PORT_41_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0100, PORT_40_EFIFO_UNDERRUN_ERRORf,         
        PORT_40_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0080, PORT_39_EFIFO_UNDERRUN_ERRORf,         
        PORT_39_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0040, PORT_38_EFIFO_UNDERRUN_ERRORf,         
        PORT_38_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0020, PORT_37_EFIFO_UNDERRUN_ERRORf,         
        PORT_37_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0010, PORT_36_EFIFO_UNDERRUN_ERRORf,         
        PORT_36_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0008, PORT_35_EFIFO_UNDERRUN_ERRORf,         
        PORT_35_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0004, PORT_34_EFIFO_UNDERRUN_ERRORf,         
        PORT_34_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x0002, PORT_33_EFIFO_UNDERRUN_ERRORf,         
        PORT_33_EFIFO_UNDERRUN_ERROR_DISINTf},     
    { 0x0001, PORT_32_EFIFO_UNDERRUN_ERRORf,
        PORT_32_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq2_parity_info [] = {
    { 0x80000000, PORT_31_EFIFO_UNDERRUN_ERRORf,
         PORT_31_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x40000000, PORT_30_EFIFO_UNDERRUN_ERRORf,
         PORT_30_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x20000000, PORT_29_EFIFO_UNDERRUN_ERRORf,
         PORT_29_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x10000000, PORT_28_EFIFO_UNDERRUN_ERRORf,
         PORT_28_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x08000000, PORT_27_EFIFO_UNDERRUN_ERRORf,
         PORT_27_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x04000000, PORT_26_EFIFO_UNDERRUN_ERRORf,
         PORT_26_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x02000000, PORT_25_EFIFO_UNDERRUN_ERRORf,
         PORT_25_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x01000000, PORT_24_EFIFO_UNDERRUN_ERRORf,
         PORT_24_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00800000, PORT_23_EFIFO_UNDERRUN_ERRORf,
         PORT_23_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00400000, PORT_22_EFIFO_UNDERRUN_ERRORf,
         PORT_22_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00200000, PORT_21_EFIFO_UNDERRUN_ERRORf,
         PORT_21_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00100000, PORT_20_EFIFO_UNDERRUN_ERRORf,
         PORT_20_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00080000, PORT_19_EFIFO_UNDERRUN_ERRORf,
         PORT_19_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00040000, PORT_18_EFIFO_UNDERRUN_ERRORf,
         PORT_18_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00020000, PORT_17_EFIFO_UNDERRUN_ERRORf,
         PORT_17_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00010000, PORT_16_EFIFO_UNDERRUN_ERRORf,
         PORT_16_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00008000, PORT_15_EFIFO_UNDERRUN_ERRORf,
         PORT_15_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00004000, PORT_14_EFIFO_UNDERRUN_ERRORf,
         PORT_14_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00002000, PORT_13_EFIFO_UNDERRUN_ERRORf,
         PORT_13_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00001000, PORT_12_EFIFO_UNDERRUN_ERRORf,
         PORT_12_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000800, PORT_11_EFIFO_UNDERRUN_ERRORf,
         PORT_11_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000400, PORT_10_EFIFO_UNDERRUN_ERRORf,
         PORT_10_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000200, PORT_09_EFIFO_UNDERRUN_ERRORf,
         PORT_09_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000100, PORT_08_EFIFO_UNDERRUN_ERRORf,
         PORT_08_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000080, PORT_07_EFIFO_UNDERRUN_ERRORf,
         PORT_07_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000040, PORT_06_EFIFO_UNDERRUN_ERRORf,
         PORT_06_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000020, PORT_05_EFIFO_UNDERRUN_ERRORf,
         PORT_05_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000010, PORT_04_EFIFO_UNDERRUN_ERRORf,
         PORT_04_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000008, PORT_03_EFIFO_UNDERRUN_ERRORf,
         PORT_03_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000004, PORT_02_EFIFO_UNDERRUN_ERRORf,
         PORT_02_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000002, PORT_01_EFIFO_UNDERRUN_ERRORf,
         PORT_01_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0x00000001, PORT_00_EFIFO_UNDERRUN_ERRORf,
         PORT_00_EFIFO_UNDERRUN_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq3_parity_info [] = {
    { 0x80000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_UNCORRECTED_ERROR_DISINTf},
    { 0x40000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_2_CORRECTED_ERROR_DISINTf},
    { 0x20000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_UNCORRECTED_ERROR_DISINTf},
    { 0x10000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_1_CORRECTED_ERROR_DISINTf},
    { 0x08000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_UNCORRECTED_ERROR_DISINTf},
    { 0x04000000, DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_EXT_ECC0_CHECK_0_CORRECTED_ERROR_DISINTf},
    { 0x02000000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_UNCORRECTED_ERROR_DISINTf},
    { 0x01000000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_2_CORRECTED_ERROR_DISINTf},
    { 0x00800000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_UNCORRECTED_ERROR_DISINTf},
    { 0x00400000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_1_CORRECTED_ERROR_DISINTf},
    { 0x00200000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_UNCORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_UNCORRECTED_ERROR_DISINTf},
    { 0x00100000, DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_CORRECTED_ERRORf,
          DEQ_CELL_CLASSIFICATION_INT_ECC0_CHECK_0_CORRECTED_ERROR_DISINTf},      
    { 0x00080000, DEQ_EP_REDIRECT_BUFFER_2_UNCORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_2_UNCORRECTED_ERROR_DISINTf},
    { 0x00040000, DEQ_EP_REDIRECT_BUFFER_2_CORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_2_CORRECTED_ERROR_DISINTf},
    { 0x00020000, DEQ_EP_REDIRECT_BUFFER_1_UNCORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_1_UNCORRECTED_ERROR_DISINTf},
    { 0x00010000, DEQ_EP_REDIRECT_BUFFER_1_CORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_1_CORRECTED_ERROR_DISINTf},
    { 0x00008000, DEQ_EP_REDIRECT_BUFFER_0_UNCORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_0_UNCORRECTED_ERROR_DISINTf},
    { 0x00004000, DEQ_EP_REDIRECT_BUFFER_0_CORRECTED_ERRORf,
          DEQ_EP_REDIRECT_BUFFER_0_CORRECTED_ERROR_DISINTf},
    { 0x00002000, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_UNCORRECTED_ERROR_DISINTf},
    { 0x00001000, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_1520_CORRECTED_ERROR_DISINTf},
    { 0x00000800, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_UNCORRECTED_ERROR_DISINTf},
    { 0x00000400, DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_EXT_57_CORRECTED_ERROR_DISINTf},
    { 0x00000200, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_UNCORRECTED_ERROR_DISINTf},
    { 0x00000100, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_1520_CORRECTED_ERROR_DISINTf},
    { 0x00000080, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_UNCORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_UNCORRECTED_ERROR_DISINTf},
    { 0x00000040, DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_CORRECTED_ERRORf,
          DEQ_PST_EGRESS_FIFO_ECC_VERIF_INT_57_CORRECTED_ERROR_DISINTf},
    { 0x00000020, DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_UNCORRECTED_ERRORf,
          DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_UNCORRECTED_ERROR_DISINTf},
    { 0x00000010, DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_CORRECTED_ERRORf,
          DEQ_EGRESS_FIFO_CONTROL_DATA_MEMORY_CORRECTED_ERROR_DISINTf},
    { 0x00000008, DEQ_AGING_MASK_MEMORY_UNCORRECTED_ERRORf,
          DEQ_AGING_MASK_MEMORY_UNCORRECTED_ERROR_DISINTf},
    { 0x00000004, DEQ_AGING_MASK_MEMORY_CORRECTED_ERRORf,
          DEQ_AGING_MASK_MEMORY_CORRECTED_ERROR_DISINTf},
    { 0x00000002, DEQ_TOQ_CELL_REP_INFO_BUFFER_UNCORRECTED_ERRORf,
  	  DEQ_TOQ_CELL_REP_INFO_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x00000001, DEQ_TOQ_CELL_REP_INFO_BUFFER_CORRECTED_ERRORf,
          DEQ_TOQ_CELL_REP_INFO_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                                  _soc_katana2_mmu_sb_deq4_parity_info [] = {
    { 0x00000002, DEQ_OPQ_CELL_INFO_BUFFER_UNCORRECTED_ERRORf,
  	  DEQ_OPQ_CELL_INFO_BUFFER_UNCORRECTED_ERROR_DISINTf},
    { 0x00000001, DEQ_OPQ_CELL_INFO_BUFFER_CORRECTED_ERRORf,
          DEQ_OPQ_CELL_INFO_BUFFER_CORRECTED_ERROR_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_internal_info_t
                           _soc_katana2_mmu_sb_deq_parity_info [] = {
    { 0x0010, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_4, 
    	0,
    	DEQ_ERROR_4f,
    	DEQ_ERROR_MASK_4r,
    	DEQ_ERROR_4r, 
      _soc_katana2_mmu_sb_deq4_parity_info },
      
    { 0x0008, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_3,
    	0,
      DEQ_ERROR_3f,
      DEQ_ERROR_MASK_3r,
    	DEQ_ERROR_3r, 
       _soc_katana2_mmu_sb_deq3_parity_info },
    
    { 0x0004, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_2, 
    	0,
      DEQ_ERROR_2f,
      DEQ_ERROR_MASK_2r,
    	DEQ_ERROR_2r, 
      _soc_katana2_mmu_sb_deq2_parity_info },
      
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_1,
    	0,
      DEQ_ERROR_1f, 
      DEQ_ERROR_MASK_1r,
    	DEQ_ERROR_1r, 
      _soc_katana2_mmu_sb_deq1_parity_info },
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_DEQ_ERROR_0,
    	0,
      DEQ_ERROR_0f, 
      DEQ_ERROR_MASK_0r,
    	DEQ_ERROR_0r, 
      _soc_katana2_mmu_sb_deq0_parity_info },
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_qstruct_fap_parity_info [] = {
    { 0x100000, FAP3_DUPLICATE_PTR_ERRORf,
  	    FAP3_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x80000, FAP2_DUPLICATE_PTR_ERRORf,
  	    FAP2_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x40000, FAP1_DUPLICATE_PTR_ERRORf,
  	    FAP1_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x20000, FAP0_DUPLICATE_PTR_ERRORf,
  	    FAP0_DUPLICATE_PTR_ERROR_DISINTf},
    { 0x10000, FAP_LOADING_ERRORf,
  	    FAP_LOADING_ERROR_DISINTf},
    { 0x8000, CORRECTED_BITMAP_ERROR_3f,
  	    CORRECTED_BITMAP_ERROR_3_DISINTf},
    { 0x4000, UNCORRECTED_BITMAP_ERROR_3f,
  	    UNCORRECTED_BITMAP_ERROR_3_DISINTf},
    { 0x2000, CORRECTED_STACK_ERROR_3f,
  	    CORRECTED_STACK_ERROR_3_DISINTf},
    { 0x1000, UNCORRECTED_STACK_ERROR_3f,
  	    UNCORRECTED_STACK_ERROR_3_DISINTf},
    { 0x0800, CORRECTED_BITMAP_ERROR_2f,
            CORRECTED_BITMAP_ERROR_2_DISINTf},
    { 0x0400, UNCORRECTED_BITMAP_ERROR_2f,
  	    UNCORRECTED_BITMAP_ERROR_2_DISINTf},
    { 0x0200, CORRECTED_STACK_ERROR_2f,
  	    CORRECTED_STACK_ERROR_2_DISINTf},
    { 0x0100, UNCORRECTED_STACK_ERROR_2f,
  	    UNCORRECTED_STACK_ERROR_2_DISINTf},
    { 0x0080, CORRECTED_BITMAP_ERROR_1f,
            CORRECTED_BITMAP_ERROR_1_DISINTf},
    { 0x0040, UNCORRECTED_BITMAP_ERROR_1f,
  	    UNCORRECTED_BITMAP_ERROR_1_DISINTf},
    { 0x0020, CORRECTED_STACK_ERROR_1f,
  	    CORRECTED_STACK_ERROR_1_DISINTf},
    { 0x0010, UNCORRECTED_STACK_ERROR_1f,
  	    UNCORRECTED_STACK_ERROR_1_DISINTf},
    { 0x0008, CORRECTED_BITMAP_ERROR_0f,
            CORRECTED_BITMAP_ERROR_0_DISINTf},
    { 0x0004, UNCORRECTED_BITMAP_ERROR_0f,
            UNCORRECTED_BITMAP_ERROR_0_DISINTf},
    { 0x0002, CORRECTED_STACK_ERROR_0f,
            CORRECTED_STACK_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_STACK_ERROR_0f,
            UNCORRECTED_STACK_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_qstruct_qentry_upper_parity_info [] = {
    { 0x8000, CORRECTED_ERROR_7f,
        CORRECTED_ERROR_7_DISINTf},
    { 0x4000, UNCORRECTED_ERROR_7f,
        UNCORRECTED_ERROR_7_DISINTf},
    { 0x2000, CORRECTED_ERROR_6f,
        CORRECTED_ERROR_6_DISINTf},
    { 0x1000, UNCORRECTED_ERROR_6f,
        UNCORRECTED_ERROR_6_DISINTf},
    { 0x0800, CORRECTED_ERROR_5f,
        CORRECTED_ERROR_5_DISINTf},
    { 0x0400, UNCORRECTED_ERROR_5f,
        UNCORRECTED_ERROR_5_DISINTf},
    { 0x0200, CORRECTED_ERROR_4f,
        CORRECTED_ERROR_4_DISINTf},
    { 0x0100, UNCORRECTED_ERROR_4f,
        UNCORRECTED_ERROR_4_DISINTf},
    { 0x0080, CORRECTED_ERROR_3f,
        CORRECTED_ERROR_3_DISINTf},
    { 0x0040, UNCORRECTED_ERROR_3f,
        UNCORRECTED_ERROR_3_DISINTf},
    { 0x0020, CORRECTED_ERROR_2f,
        CORRECTED_ERROR_2_DISINTf},
    { 0x0010, UNCORRECTED_ERROR_2f,
        UNCORRECTED_ERROR_2_DISINTf},
    { 0x0008, CORRECTED_ERROR_1f,
        CORRECTED_ERROR_1_DISINTf},
    { 0x0004, UNCORRECTED_ERROR_1f,
        UNCORRECTED_ERROR_1_DISINTf},
    { 0x0002, CORRECTED_ERROR_0f,
        CORRECTED_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_ERROR_0f,
        UNCORRECTED_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                      _soc_katana2_mmu_sb_qstruct_qentry_lower_parity_info [] = {
    { 0x8000, CORRECTED_ERROR_7f,
         CORRECTED_ERROR_7_DISINTf},
    { 0x4000, UNCORRECTED_ERROR_7f,
         UNCORRECTED_ERROR_7_DISINTf},
    { 0x2000, CORRECTED_ERROR_6f,
         CORRECTED_ERROR_6_DISINTf},
    { 0x1000, UNCORRECTED_ERROR_6f,
         UNCORRECTED_ERROR_6_DISINTf},
    { 0x0800, CORRECTED_ERROR_5f,
         CORRECTED_ERROR_5_DISINTf},
    { 0x0400, UNCORRECTED_ERROR_5f,
         UNCORRECTED_ERROR_5_DISINTf},
    { 0x0200, CORRECTED_ERROR_4f,
         CORRECTED_ERROR_4_DISINTf},
    { 0x0100, UNCORRECTED_ERROR_4f,
         UNCORRECTED_ERROR_4_DISINTf},
    { 0x0080, CORRECTED_ERROR_3f,
         CORRECTED_ERROR_3_DISINTf},
    { 0x0040, UNCORRECTED_ERROR_3f,
         UNCORRECTED_ERROR_3_DISINTf},
    { 0x0020, CORRECTED_ERROR_2f,
         CORRECTED_ERROR_2_DISINTf},
    { 0x0010, UNCORRECTED_ERROR_2f,
         UNCORRECTED_ERROR_2_DISINTf},
    { 0x0008, CORRECTED_ERROR_1f,
         CORRECTED_ERROR_1_DISINTf},
    { 0x0004, UNCORRECTED_ERROR_1f,
         UNCORRECTED_ERROR_1_DISINTf},
    { 0x0002, CORRECTED_ERROR_0f,
         CORRECTED_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_ERROR_0f,
         UNCORRECTED_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t
                _soc_katana2_mmu_sb_qstruct_qentry_qblock_nxt_parity_info [] = {
    { 0x8000, CORRECTED_ERROR_7f,
         CORRECTED_ERROR_7_DISINTf},
    { 0x4000, UNCORRECTED_ERROR_7f,
         UNCORRECTED_ERROR_7_DISINTf},
    { 0x2000, CORRECTED_ERROR_6f,
         CORRECTED_ERROR_6_DISINTf},
    { 0x1000, UNCORRECTED_ERROR_6f,
         UNCORRECTED_ERROR_6_DISINTf},
    { 0x0800, CORRECTED_ERROR_5f,
         CORRECTED_ERROR_5_DISINTf},
    { 0x0400, UNCORRECTED_ERROR_5f,
         UNCORRECTED_ERROR_5_DISINTf},
    { 0x0200, CORRECTED_ERROR_4f,
         CORRECTED_ERROR_4_DISINTf},
    { 0x0100, UNCORRECTED_ERROR_4f,
         UNCORRECTED_ERROR_4_DISINTf},
    { 0x0080, CORRECTED_ERROR_3f,
         CORRECTED_ERROR_3_DISINTf},
    { 0x0040, UNCORRECTED_ERROR_3f,
         UNCORRECTED_ERROR_3_DISINTf},
    { 0x0020, CORRECTED_ERROR_2f,
         CORRECTED_ERROR_2_DISINTf},
    { 0x0010, UNCORRECTED_ERROR_2f,
         UNCORRECTED_ERROR_2_DISINTf},
    { 0x0008, CORRECTED_ERROR_1f,
         CORRECTED_ERROR_1_DISINTf},
    { 0x0004, UNCORRECTED_ERROR_1f,
         UNCORRECTED_ERROR_1_DISINTf},
    { 0x0002, CORRECTED_ERROR_0f,
         CORRECTED_ERROR_0_DISINTf},
    { 0x0001, UNCORRECTED_ERROR_0f,
         UNCORRECTED_ERROR_0_DISINTf},
    { 0 } /* table terminator */
};

STATIC  _soc_katana2_mmu_sub_block_internal_info_t
                           _soc_katana2_mmu_sb_qstruct_parity_info [] = {
    { 0x0008, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_FAP,
      QENTRY_FAP_ERROR_DISINTf,
      QENTRY_FAP_ERRORf,
      QSTRUCT_FAP_MEM_ERROR_MASKr,
      QSTRUCT_FAP_MEM_ERRORr,
      _soc_katana2_mmu_sb_qstruct_fap_parity_info }, 
      
    { 0x0004, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_U,
      QENTRY_UPPER_ERROR_DISINTf,
      QENTRY_UPPER_ERRORf, 
      QSTRUCT_QENTRY_UPPER_ERROR_MASKr,
      QSTRUCT_QENTRY_UPPER_ERRORr,
      _soc_katana2_mmu_sb_qstruct_qentry_upper_parity_info }, 
      
    { 0x0002, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QENTRY_L,
    	QENTRY_LOWER_ERROR_DISINTf,
      QENTRY_LOWER_ERRORf,
      QSTRUCT_QENTRY_LOWER_ERROR_MASKr,
      QSTRUCT_QENTRY_LOWER_ERRORr,
      _soc_katana2_mmu_sb_qstruct_qentry_lower_parity_info }, 
      
    { 0x0001, 
    	_SOC_KT2_MMU_LVL2_SUBBLOCK_QSTRUCT_QBLOCK,
      QBLOCK_NEXT_ERROR_DISINTf,
      QBLOCK_NEXT_ERRORf, 
      QSTRUCT_QBLOCK_NEXT_ERROR_MASKr,
      QSTRUCT_QBLOCK_NEXT_ERRORr,                                         
      _soc_katana2_mmu_sb_qstruct_qentry_qblock_nxt_parity_info }, 
    { 0 } /* table terminator */
};

STATIC  
_soc_katana2_mmu_sub_block_leaf_info_t 
                             _soc_katana2_mmu_sb_wred_parity_info [] = {
    { 0x4000000, UPDATE_INTRPT_STATUSf,
       UPDATE_INTRPT_MASKf },
    { 0x3ffe000, ECC_ERROR_1Bf,
       ECC_1B_ERROR_MASKf },
    { 0x1fff, ECC_ERROR_2Bf,
       ECC_2B_ERROR_MASKf },
    { 0 } /* table terminator */

};

STATIC  _soc_katana2_mmu_sub_block_leaf_info_t 
                _soc_katana2_mmu_sb_rqe_ser_parity_info [] = {
    { 0x1000000, NULL_REPL_PKTf, NULL_REPL_PKT_MASKf }, 
    { 0x0800000, FLL_EMPTYf, FLL_EMPTY_MASKf }, 
    { 0x0400000, EXTQ_LL_ERRORf, EXTQ_LL_ERROR_MASKf }, 
    { 0x03ff100, ECC_1B_BITMAPf, ECC_1B_MASKf }, 
    { 0x00007ff, ECC_2B_BITMAPf, ECC_2B_MASKf }, 
    { 0 } /* table terminator */
};


STATIC 
_soc_katana2_mmu_sub_block_one_level_t  _soc_katana2_mmu_sub_blocks_type_1[] = {
    { 0x08000000, 
    	_SOC_KT2_MMU_SUBBLOCK_IPCTR,
      IPCTR_INTR_DISINTf, 
      IPCTR_INTRf,
      MMU_IPCTR_ECC_ERROR_0_MASKr,
      MMU_IPCTR_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_ipctr_parity_info },
    
    { 0x04000000, 
    	_SOC_KT2_MMU_SUBBLOCK_ADM,
      ADM_INTR_DISINTf, 
      ADM_INTRf,
      MMU_ADM_ECC_ERROR_0_MASKr,
      MMU_ADM_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_adm_parity_info },

    { 0x02000000, 
    	_SOC_KT2_MMU_SUBBLOCK_RDE,
      RDE_INTR_DISINTf, 
      RDE_INTRf,
      RDE_SER_MASKr,
      RDE_SER_STATUSr,
      _soc_katana2_mmu_sb_rde_parity_info },
    
    { 0x00800000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI5,
      CI5_INTR_DISINTf, 
      CI5_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info },

    { 0x00400000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI4,
      CI4_INTR_DISINTf, 
      CI4_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info },

    { 0x00200000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI3,
      CI3_INTR_DISINTf, 
      CI3_INTRf, 
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info },

    { 0x00100000, 
    	_SOC_KT2_MMU_SUBBLOCK_MEM1,
      MEM1_INTR_DISINTf, 
      MEM1_INTRf,
      CLINK_ERROR_MASKr,
      CLINK_ERRORr,
      _soc_katana2_mmu_sb_mem1_parity_info },

    { 0x00040000, 
    	_SOC_KT2_MMU_SUBBLOCK_E2EFC,
      E2EFC_INTR_DISINTf, 
      E2EFC_INTRf,
      MMU_E2EFC_ERROR_0_MASKr,
      MMU_E2EFC_ERROR_0r,
      _soc_katana2_mmu_sb_e2efc_parity_info},

    { 0x00010000, 
    	_SOC_KT2_MMU_SUBBLOCK_THDI,
      THDI_INTR_DISINTf, 
      THDI_INTRf,
      MMU_THDI_INTR_MASKr,
      MMU_THDI_INTRr,
      _soc_katana2_mmu_sb_thdi_parity_info},

    { 0x00000800, 
    	_SOC_KT2_MMU_SUBBLOCK_WRED,
      WRED_INTR_DISINTf, 
      WRED_INTRf,
      WRED_PARITY_ERROR_MASKr,
      WRED_PARITY_ERROR_BITMAPr,
      _soc_katana2_mmu_sb_wred_parity_info},

    { 0x00000040, 
    	_SOC_KT2_MMU_SUBBLOCK_CTR,
      CTR_INTR_DISINTf, 
      CTR_INTRf,
      CTR_ERROR_MASKr,
      CTR_ERRORr,
      _soc_katana2_mmu_sb_ctr_parity_info},

    { 0x00000010, 
    	_SOC_KT2_MMU_SUBBLOCK_CCP,
      CCP_INTR_DISINTf, 
      CCP_INTRf,
      CCP_ERROR_MASKr,
      CCP_ERRORr,
      _soc_katana2_mmu_sb_ccp_parity_info},
    
    { 0x00020000, 
    	_SOC_KT2_MMU_SUBBLOCK_ITE,
      ITE_INTR_DISINTf, 
      ITE_INTRf,
      MMU_ITE_ERROR_0_MASKr,
      MMU_ITE_ERROR_0r,
      _soc_katana2_mmu_sb_ite_parity_info},

    { 0x00020000, 
    	_SOC_KT2_MMU_SUBBLOCK_ITE_CFG,
      ITE_INTR_DISINTf, 
      ITE_INTRf,
      MMU_ITE_CFG_ECC_ERROR_0_MASKr,
      MMU_ITE_CFG_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_ite_cfg_parity_info},

    { 0x00008000, 
    	_SOC_KT2_MMU_SUBBLOCK_ENQ_CFG,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_CFG_ECC_ERROR_0_MASKr,
      MMU_ENQ_CFG_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_enq_cfg_parity_info},

    { 0x00008000, 
    	_SOC_KT2_MMU_SUBBLOCK_ENQ,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_ERROR_0_MASKr,
      MMU_ENQ_ERROR_0r,
      _soc_katana2_mmu_sb_enq_parity_info},

    { 0x00008000, 
    	_SOC_KT2_MMU_SUBBLOCK_ENQ_FAP,
      ENQ_INTR_DISINTf, 
      ENQ_INTRf,
      MMU_ENQ_FAP_ECC_ERROR_0_MASKr,
      MMU_ENQ_FAP_ECC_ERROR_0r,
      _soc_katana2_mmu_sb_enq_fap_parity_info},

    { 0x00000400, 
    	_SOC_KT2_MMU_SUBBLOCK_THDO_STATUS1,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK1r,
      THDO_PARITY_ERROR_STATUS1r,
      _soc_katana2_mmu_sb_thdo_stat1_parity_info},

    { 0x00000400, 
    	_SOC_KT2_MMU_SUBBLOCK_THDO_STATUS2,
      THDO_INTR_DISINTf, 
      THDO_INTRf,
      THDO_PARITY_ERROR_MASK2r,
      THDO_PARITY_ERROR_STATUS2r,
      _soc_katana2_mmu_sb_thdo_stat2_parity_info},

    { 0x00000020, 
    	_SOC_KT2_MMU_SUBBLOCK_CFAPI,
      CFAP_INTR_DISINTf, 
      CFAP_INTRf,
      CFAPI_ERROR_MASKr,
      CFAPI_ECC_ERRORr,
      _soc_katana2_mmu_sb_cfapi_parity_info},

    { 0x00000020, 
    	_SOC_KT2_MMU_SUBBLOCK_CFAPE,
      CFAP_INTR_DISINTf, 
      CFAP_INTRf,
      CFAPE_ERROR_MASKr,
      CFAPE_ECC_ERRORr,
      _soc_katana2_mmu_sb_cfape_parity_info},

    { 0x00000008, 
    	_SOC_KT2_MMU_SUBBLOCK_AGING_INT,
      AGING_INTR_DISINTf, 
      AGING_INTRf,
      AGING_ERROR_MASK_INTr,
      AGING_ERROR_INTr,
      _soc_katana2_mmu_sb_age_int_parity_info},

    { 0x00000008, 
      _SOC_KT2_MMU_SUBBLOCK_AGING_EXT,
      AGING_INTR_DISINTf, 
      AGING_INTRf,
      AGING_ERROR_MASK_EXTr,
      AGING_ERROR_EXTr,
      _soc_katana2_mmu_sb_age_ext_parity_info},

    { 0x00004000, 
      _SOC_KT2_MMU_SUBBLOCK_CI2,
      CI2_INTR_DISINTf, 
      CI2_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info},

    { 0x00002000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI1,
      CI1_INTR_DISINTf, 
      CI1_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info},

    { 0x00001000, 
    	_SOC_KT2_MMU_SUBBLOCK_CI0,
      CI0_INTR_DISINTf, 
      CI0_INTRf,
      CI_ERROR_MASKr,
      CI_ERRORr,
      _soc_katana2_mmu_sb_ci_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_ERROR_MASKr,
      LLS_ERRORr,
      _soc_katana2_mmu_sb_lls_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_PORT,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_PORT_ECC_ERROR_MASKr,
      LLS_PORT_ECC_ERRORr,
      _soc_katana2_mmu_sb_lls_port_parity_info},
    
    { 0x00000004,
    	_SOC_KT2_MMU_SUBBLOCK_LLS,
    	LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_ERROR2_MASKr,
      LLS_ERROR2r,
      _soc_katana2_mmu_sb_lls2_parity_info},


    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_UPD2,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_ERROR_UPD2_MASKr,
      LLS_ERROR_UPD2r,
      _soc_katana2_mmu_sb_lls_upd2_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_L0_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L0_ECC_ERROR1_MASKr,
      LLS_L0_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_l0_ecc_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_L1_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L1_ECC_ERROR1_MASKr,
      LLS_L1_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_l1_ecc_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_L2_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_L2_ECC_ERROR1_MASKr,
      LLS_L2_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_l2_ecc_parity_info},

    { 0x00000004, 
    	_SOC_KT2_MMU_SUBBLOCK_LLS_MISC_ECC,
      LLS_INTR_DISINTf, 
      LLS_INTRf,
      LLS_MISC_ECC_ERROR1_MASKr,
      LLS_MISC_ECC_ERROR1r,
      _soc_katana2_mmu_sb_lls_misc_ecc_parity_info},
    
    /*  RQE Ser gives MMU parity error while accessing IPMC group
        tables. Hence, disabling parity for this */
    { 0x00000200, 
    	_SOC_KT2_MMU_SUBBLOCK_RQE_SER,
      RQE_INTR_DISINTf, 
      RQE_INTRf,
      RQE_SER_MASKr,
      RQE_SER_STATUSr,
      _soc_katana2_mmu_sb_rqe_ser_parity_info},
    
    { 0x00000200, 
    	_SOC_KT2_MMU_SUBBLOCK_RQE_EXTQ,
      RQE_INTR_DISINTf, 
      RQE_INTRf,
      RQE_EXTQ_REPLICATION_LIMITr,
      RQE_EXTQ_REPLICATION_COUNTr,
        _soc_katana2_mmu_sb_rqe_extq_parity_info},

    { 0 } /* table terminator */
};

STATIC
_soc_katana2_mmu_sub_block_two_level_t  _soc_katana2_mmu_sub_blocks_type_2[] = {
    { 0x00000100, 
    	_SOC_KT2_MMU_SUBBLOCK_EMC,
      EMC_INTR_DISINTf, 
      EMC_INTRf,
      0,
      EMC_ERRORr,
      _soc_katana2_mmu_sb_emc_parity_info},

    { 0x00000080, 
    	_SOC_KT2_MMU_SUBBLOCK_DEQ,
      DEQ_INTR_DISINTf, 
      DEQ_INTRf,
      0,
      DEQ_ERRORr,
      _soc_katana2_mmu_sb_deq_parity_info},

    { 0x00000002, 
    	_SOC_KT2_MMU_SUBBLOCK_QSTRUCT,
      QSTRUCT_INTR_DISINTf, 
      QSTRUCT_INTRf,
      QSTRUCT_INTERRUPT_MASKr,
      QSTRUCT_INTERRUPTr,
      _soc_katana2_mmu_sb_qstruct_parity_info},
      
    { 0x00000001, 
    	_SOC_KT2_MMU_SUBBLOCK_TOQ,
      TOQ_INTR_DISINTf, 
      TOQ_INTRf,
      TOQ_INTERRUPT_MASKr,
      TOQ_INTERRUPTr,
      _soc_katana2_mmu_sb_toq_parity_info},
    { 0 } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ep0_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_NHOP_PAR_ERRf,
        EGR_NHOP_PAR_ERRf,
        EGR_L3_NEXT_HOPm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_NEXT_HOP_PARITY_ENf,
        EGR_L3_NEXT_HOP_PARITY_STATUS_INTRr, NULL,
        EGR_L3_NEXT_HOP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_L3_INTF_PAR_ERRf,
        EGR_L3_INTF_PAR_ERRf,
        EGR_L3_INTFm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_L3_INTF_PARITY_ENf,
        EGR_L3_INTF_PARITY_STATUS_INTRr, NULL,
        EGR_L3_INTF_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PAR_ERRf,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PAR_ERRf,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLEm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_ENf,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_VC_AND_SWAP_LABEL_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_VLAN_PAR_ERRf,
        EGR_VLAN_PAR_ERRf,
        EGR_VLANm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_VLAN_PARITY_ENf,
        EGR_VLAN_PARITY_STATUS_INTRr, NULL,
        EGR_VLAN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_VLAN_STG_PAR_ERRf,
        EGR_VLAN_STG_PAR_ERRf,
        EGR_VLAN_STGm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_VLAN_STG_PARITY_ENf,
        EGR_VLAN_STG_PARITY_STATUS_INTRr, NULL,
        EGR_VLAN_STG_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_IP_TUNNEL_PAR_ERRf,
        EGR_IP_TUNNEL_PAR_ERRf,
        EGR_IP_TUNNELm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_IP_TUNNEL_PARITY_ENf,
        EGR_IP_TUNNEL_PARITY_STATUS_INTRr, NULL,
        EGR_IP_TUNNEL_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        EGR_VLAN_XLATE_PAR_ERRf,
        EGR_VLAN_XLATE_PAR_ERRf,
        EGR_VLAN_XLATEm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_VLAN_XLATE_PARITY_ENf,
        INVALIDr, _soc_katana2_egr_vlan_xlate_intr_reg,
        INVALIDr, _soc_katana2_egr_vlan_xlate_nack_reg },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FRAGMENT_ID_TABLE_PAR_ERRf,
        EGR_FRAGMENT_ID_TABLE_PAR_ERRf,
        EGR_FRAGMENT_ID_TABLEm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_FRAGMENT_ID_TABLE_PARITY_ENf,
        EGR_FRAGMENT_ID_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_FRAGMENT_ID_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        EGR_INITBUF_ECC_ERRf,
        EGR_INITBUF_ECC_ERRf,
        INVALIDm, "EGR_INITBUF",
        INVALIDr,
        EGR_EHCPM_ECC_PARITY_CONTROLr, INITBUF_ECC_ENf,
        EGR_INITBUF_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_PORT_PAR_ERRf,
        EGR_PORT_PAR_ERRf,
        EGR_PORTm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_PORT_PARITY_ENf,
        EGR_PORT_PARITY_STATUS_INTRr, NULL,
        EGR_PORT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MOD_MAP_TABLE_PAR_ERRf,
        EGR_MOD_MAP_TABLE_PAR_ERRf,
        EGR_MOD_MAP_TABLEm, NULL,
        INVALIDr,
        EGR_EHCPM_ECC_PARITY_CONTROLr, MOD_MAP_PARITY_ENf,
        EGR_MOD_MAP_PARITY_STATUS_INTRr, NULL,
        EGR_MOD_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MAC_DA_PROFILE_PAR_ERRf,
        EGR_MAC_DA_PROFILE_PAR_ERRf,
        EGR_MAC_DA_PROFILEm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAC_DA_PROFILE_PARITY_ENf,
        EGR_MAC_DA_PROFILE_PARITY_STATUS_INTRr, NULL,
        EGR_MAC_DA_PROFILE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_DVP_ATTRIBUTE_PAR_ERRf,
        EGR_DVP_ATTRIBUTE_PAR_ERRf,
        EGR_DVP_ATTRIBUTEm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_DVP_ATTRIBUTE_PARITY_ENf,
        EGR_DVP_ATTRIBUTE_PARITY_STATUS_INTRr, NULL,
        EGR_DVP_ATTRIBUTE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_VFI_PAR_ERRf,
        EGR_VFI_PAR_ERRf,
        EGR_VFIm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_VFI_PARITY_ENf,
        EGR_VFI_PARITY_STATUS_INTRr, NULL,
        EGR_VFI_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_IPMC_PAR_ERRf,
        EGR_IPMC_PAR_ERRf,
        EGR_IPMCm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_IPMC_PARITY_ENf,
        EGR_IPMC_PARITY_STATUS_INTRr, NULL,
        EGR_IPMC_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_EXP_MAPPING_2_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_2_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_2m, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_MPLS_EXP_MAPPING_2_PARITY_ENf,
        EGR_MPLS_EXP_MAPPING_2_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_EXP_MAPPING_2_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_PRI_MAPPING_PAR_ERRf,
        EGR_MPLS_PRI_MAPPING_PAR_ERRf,
        EGR_MPLS_PRI_MAPPINGm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_MPLS_PRI_MAPPING_PARITY_ENf,
        EGR_MPLS_PRI_MAPPING_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_PRI_MAPPING_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_PRI_CNG_MAP_PAR_ERRf,
        EGR_PRI_CNG_MAP_PAR_ERRf,
        EGR_PRI_CNG_MAPm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_PRI_CNG_MAP_PARITY_ENf,
        EGR_PRI_CNG_MAP_PARITY_STATUS_INTRr, NULL,
        EGR_PRI_CNG_MAP_PARITY_STATUS_NACKr, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_DSCP_TABLE_PAR_ERRf,
        EGR_DSCP_TABLE_PAR_ERRf,
        EGR_DSCP_TABLEm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_DSCP_TABLE_PARITY_ENf,
        EGR_DSCP_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_DSCP_TABLE_PARITY_STATUS_NACKr, NULL }, 
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MPLS_EXP_MAPPING_1_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_1_PAR_ERRf,
        EGR_MPLS_EXP_MAPPING_1m, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_MPLS_EXP_MAPPING_1_PARITY_ENf,
        EGR_MPLS_EXP_MAPPING_1_PARITY_STATUS_INTRr, NULL,
        EGR_MPLS_EXP_MAPPING_1_PARITY_STATUS_NACKr, NULL },
     
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        EGR_MPB_ECC_ERRf,
        EGR_MPB_ECC_ERRf,
        INVALIDm, "EGR_MPB",
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MPB_ECC_ENf,
        EGR_MPB_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL }, 
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_MODBASE_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_MODBASEm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_GPP_ATTRIBUTES_MODBASE_PARITY_ENf,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_STATUS_INTRr, NULL,
        EGR_GPP_ATTRIBUTES_MODBASE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_GPP_ATTRIBUTES_PAR_ERRf,
        EGR_GPP_ATTRIBUTES_PAR_ERRf,
        EGR_GPP_ATTRIBUTESm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_GPP_ATTRIBUTES_PARITY_ENf,
        EGR_GPP_ATTRIBUTES_PARITY_STATUS_INTRr, NULL,
        EGR_GPP_ATTRIBUTES_PARITY_STATUS_NACKr, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_QUEUE_TO_PP_PORT_MAP_PAR_ERRf,
        EGR_QUEUE_TO_PP_PORT_MAP_PAR_ERRf,
        EGR_QUEUE_TO_PP_PORT_MAPm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_QUEUE_TO_PP_PORT_MAP_PARITY_ENf,
        EGR_QUEUE_TO_PP_PORT_MAP_PARITY_STATUS_INTRr, NULL,
        EGR_QUEUE_TO_PP_PORT_MAP_PARITY_STATUS_NACKr, NULL },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_PCP_DE_MAPPING_PAR_ERRf,
        EGR_PCP_DE_MAPPING_PAR_ERRf,
        EGR_PCP_DE_MAPPINGm, NULL,
        INVALIDr,
        EGR_VLAN_PARITY_CONTROLr, EGR_PCP_DE_MAPPING_PARITY_ENf,
        EGR_PCP_DE_MAPPING_PARITY_STATUS_INTRr, NULL,
        EGR_PCP_DE_MAPPING_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        EGR_MP_GROUP_PAR_ERRf,
        EGR_MP_GROUP_PAR_ERRf,
        EGR_MP_GROUPm, NULL,
        INVALIDr,
        EGR_EOAM_ECC_PARITY_CONTROLr, MP_GROUP_PARITY_ENf,
        INVALIDr, _soc_katana2_egr_mp_group_intr_reg,
        INVALIDr, _soc_katana2_egr_mp_group_nack_reg },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MA_INDEX_PAR_ERRf,
        EGR_MA_INDEX_PAR_ERRf,
        EGR_MA_INDEXm, NULL,
        INVALIDr,
        EGR_EOAM_ECC_PARITY_CONTROLr, MA_INDEX_PARITY_ENf,
        EGR_MA_INDEX_PARITY_STATUS_INTRr, NULL,
        EGR_MA_INDEX_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MAP_MH_PAR_ERRf,
        EGR_MAP_MH_PAR_ERRf,
        EGR_MAP_MHm, NULL,
        INVALIDr,
        EGR_EL3_ECC_PARITY_CONTROLr, EGR_MAP_MH_PARITY_ENf,
        EGR_MAP_MH_PARITY_STATUS_INTRr, NULL,
        EGR_MAP_MH_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_OAM_LM_COUNTERS_0_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_0_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_0m, NULL,
        INVALIDr,
        EGR_EOAM_ECC_PARITY_CONTROLr, OAM_LM_COUNTERS_0_PARITY_ENf,
        EGR_OAM_LM_COUNTERS_0_PARITY_STATUS_INTRr, NULL,
        EGR_OAM_LM_COUNTERS_0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_OAM_LM_COUNTERS_1_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_1_PAR_ERRf,
        EGR_OAM_LM_COUNTERS_1m, NULL,
        INVALIDr,
        EGR_EOAM_ECC_PARITY_CONTROLr, OAM_LM_COUNTERS_1_PARITY_ENf,
        EGR_OAM_LM_COUNTERS_1_PARITY_STATUS_INTRr, NULL,
        EGR_OAM_LM_COUNTERS_1_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_SF_SRC_MODID_CHECK_PAR_ERRf,
        EGR_SF_SRC_MODID_CHECK_PAR_ERRf,
        INVALIDm, NULL,
        EGR_SF_SRC_MODID_CHECKr,
        EGR_EHCPM_ECC_PARITY_CONTROLr, SF_SRC_MODID_CHECK_PARITY_ENf,
        EGR_SF_SRC_MODID_CHECK_PARITY_STATUS_INTRr, NULL,
        EGR_SF_SRC_MODID_CHECK_PARITY_STATUS_NACKr, NULL },
        
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ep1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        CM_ECC_ERRf,
        CM_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_CM_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, CM_ECC_ENf,
        EGR_CM_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        LP_ECC_ERRf,
        LP_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_LP_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, LP_ECC_ENf,
        EGR_LP_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },

    /* Remove this due to HW issue that a false ECC is reported for the EDATABUFF on KT2*/
    /*{ _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        RESI_ECC_ERRf,
        RESI_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_RESI_MEM",
        EGR_EDATABUF_PARITY_CONTROLr, RESI_ECC_ENf,
        EGR_RESI_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
        INVALIDr, NULL },*/
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        EGR_STATS_COUNTER_TABLE_PAR_ERRf,
        EGR_STATS_COUNTER_TABLE_PAR_ERRf,
        INVALIDm, "TX Debug Counter",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, STATS_PAR_ENf,
        EGR_STATS_COUNTER_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_STATS_COUNTER_TABLE_PARITY_STATUS_NACKr, NULL },
    

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_COUNTER_TABLE_PAR_ERRf,
        EGR_EFP_COUNTER_TABLE_PAR_ERRf,
        EFP_COUNTER_TABLEm, NULL,
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, EFPCTR_PAR_ENf,
        EGR_EFP_COUNTER_TABLE_PARITY_STATUS_INTRr, NULL,
        EGR_EFP_COUNTER_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_METER_TABLE_PAR_ERRf,
        EGR_EFP_METER_TABLE_PAR_ERRf,
        EFP_METER_TABLEm, NULL,
        INVALIDr,
        EFP_METER_PARITY_CONTROLr, PARITY_ENf,
        EFP_METER_PARITY_STATUS_INTRr, NULL,
        EFP_METER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_POLICY_TABLE_PAR_ERRf,
        EGR_EFP_POLICY_TABLE_PAR_ERRf,
        EFP_POLICY_TABLEm, NULL,
        INVALIDr,
        EFP_POLICY_PARITY_CONTROLr, PARITY_ENf,
        EFP_POLICY_PARITY_STATUS_INTRr, NULL,
        EFP_POLICY_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_EFP_PW_INIT_COUNTERS_PAR_ERRf,
        EGR_EFP_PW_INIT_COUNTERS_PAR_ERRf,
        EGR_PW_INIT_COUNTERSm, NULL,
        INVALIDr,
        EGR_PW_INIT_COUNTERS_PARITY_CONTROLr, PARITY_ENf,
        EGR_PW_INIT_COUNTERS_PARITY_STATUS_INTRr, NULL,
        EGR_PW_INIT_COUNTERS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_0m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_0r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_1m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_1r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_1r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_2m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_2r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_2r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_3m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_3r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_3r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_0_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_0m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_0r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_1_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_1m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_1r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_1r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_2_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_2m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_2r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_2r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_3_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_3m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_3r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_3r, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_4m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_4r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_4r, NULL },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_5m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_5r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_5r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_6m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_6r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_OFFSET_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_OFFSET_TABLE_7m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_7r, NULL,
        EGR_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_7r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_4_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_4m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_4r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_4r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_5_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_5m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_5r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_5r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_6_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_6m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_6r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_6r, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_FLEX_CTR_COUNTER_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_7_INTR_STATUSf,
        EGR_FLEX_CTR_COUNTER_TABLE_7m, NULL,
        INVALIDr,
        EGR_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_7r, NULL,
        EGR_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_7r, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ep2_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_1588_LNK_DELAY_PAR_ERRf,
        EGR_1588_LNK_DELAY_PAR_ERRf,
        INVALIDm, NULL,
        EGR_1588_LINK_DELAY_64r,
        EGR_1588_LINK_DELAY_64_PARITY_CONTROLr, PARITY_ENf,
        EGR_1588_LINK_DELAY_64_PARITY_STATUS_INTRr, NULL,
        EGR_1588_LINK_DELAY_64_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_1588_SA_PAR_ERRf,
        EGR_1588_SA_PAR_ERRf,
        EGR_1588_SAm, NULL,
        INVALIDr,
        EGR_1588_SA_PARITY_CONTROLr, PARITY_ENf,
        EGR_1588_SA_PARITY_STATUS_INTRr, NULL,
        EGR_1588_SA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ0_ECC_ERRf,
        XQ0_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ0_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ0_ECC_ENf,
        EGR_XQ0_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ1_ECC_ERRf,
        XQ1_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ1_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ1_ECC_ENf,
        EGR_XQ1_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ2_ECC_ERRf,
        XQ2_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ2_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ2_ECC_ENf,
        EGR_XQ2_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ3_ECC_ERRf,
        XQ3_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ3_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ3_ECC_ENf,
        EGR_XQ3_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ4_ECC_ERRf,
        XQ4_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ4_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ4_ECC_ENf,
        EGR_XQ4_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ5_ECC_ERRf,
        XQ5_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ5_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ5_ECC_ENf,
        EGR_XQ5_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ6_ECC_ERRf,
        XQ6_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ6_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ6_ECC_ENf,
        EGR_XQ6_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_EDATABUF, NULL, 0,
        XQ7_ECC_ERRf,
        XQ7_ECC_ERRf,
        INVALIDm, "EP_EDATABUF_XQ7_MEM",
        INVALIDr,
        EGR_EDATABUF_PARITY_CONTROLr, XQ7_ECC_ENf,
        EGR_XQ7_BUFFER_STATUS_INTRr, NULL,
        INVALIDr, NULL },
        
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip0_parity_info[] = {
    /* Block-IPIPE, Stage-IARB */
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IARB_LMEP1_PAR_ERRf,
        IARB_LMEP1_PAR_ERRf,
        LMEP_1m, NULL,
        INVALIDr,
        LMEP_1_PARITY_CONTROLr, PARITY_ENf,
        LMEP_1_PARITY_STATUS_INTRr, NULL,
        LMEP_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_PIPE_X_LEARN_FIFO_ECC_ERRf,
        IARB_PIPE_X_LEARN_FIFO_ECC_ERRf,
        INVALIDm, "IARB_LEARN_FIFO_PIPE_X",
        INVALIDr,
        IARB_LEARN_FIFO_ECC_CONTROLr, ECC_ENf,
        IARB_PIPE_X_LERAN_FIFO_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_HDR_ERRf,
        IARB_HDR_ERRf,
        INVALIDm, "IARB_PKT_HDR",
        INVALIDr,
        IARB_HDR_ECC_CONTROLr, ECC_ENf,
        IARB_HDR_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        IARB_PKT_ERRf,
        IARB_PKT_ERRf,
        INVALIDm, "IARB_PKT_BUF",
        INVALIDr,
        IARB_PKT_ECC_CONTROLr, ECC_ENf,
        IARB_PKT_ECC_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        LMEP_PAR_ERRf,
        LMEP_PAR_ERRf,
        LMEPm, NULL,
        INVALIDr,
        LMEP_PARITY_CONTROLr, PARITY_ENf,
        LMEP_PARITY_STATUS_INTRr, NULL,
        LMEP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SUBPORT_TAG_TO_PP_PORT_MAP_PARITY_ERRf,
        SUBPORT_TAG_TO_PP_PORT_MAP_PARITY_ERRf,
        SUBPORT_TAG_TO_PP_PORT_MAP_DATA_ONLYm, NULL,
        INVALIDr,
        SUBPORT_TAG_TO_PP_PORT_MAP_DATA_PARITY_CONTROLr, PARITY_ENf,
        SUBPORT_TAG_TO_PP_PORT_MAP_DATA_PARITY_STATUS_INTRr, NULL,
        SUBPORT_TAG_TO_PP_PORT_MAP_DATA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_PHYSICAL_PORT_TABLE_PARITY_ERRf,
        ING_PHYSICAL_PORT_TABLE_PARITY_ERRf,
        ING_PHYSICAL_PORT_TABLEm, NULL,
        INVALIDr,
        ING_PHYSICAL_PORT_TABLE_PARITY_CONTROLr, PARITY_ENf,
        ING_PHYSICAL_PORT_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_PHYSICAL_PORT_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_ERRf,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_ERRf,
        DEVICE_STREAM_ID_TO_PP_PORT_MAPm, NULL,
        INVALIDr,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_CONTROLr, PARITY_ENf,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_STATUS_INTRr, NULL,
        DEVICE_STREAM_ID_TO_PP_PORT_MAP_PARITY_STATUS_NACKr, NULL },    
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        SOURCE_TRUNK_MAP_PARITY_ERRf,
        SOURCE_TRUNK_MAP_PARITY_ERRf,
        SOURCE_TRUNK_MAP_TABLEm, NULL,
        INVALIDr,
        SRC_TRUNK_ECC_CONTROLr, ECC_ENf,
        SRC_TRUNK_ECC_STATUS_INTRr, NULL,
        SRC_TRUNK_ECC_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SOURCE_TRUNK_MAP_MODVIEW_PAR_ERRf,
        SOURCE_TRUNK_MAP_MODVIEW_PAR_ERRf,
        SOURCE_TRUNK_MAP_MODBASEm, NULL,
        INVALIDr,
        SOURCE_TRUNK_MAP_MODVIEW_PARITY_CONTROLr, PARITY_ENf,
        SOURCE_TRUNK_MAP_MODVIEW_PARITY_STATUS_INTRr, NULL,
        SOURCE_TRUNK_MAP_MODVIEW_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SYSTEM_CONFIG_MODVIEW_PAR_ERRf,
        SYSTEM_CONFIG_MODVIEW_PAR_ERRf,
        SYSTEM_CONFIG_TABLE_MODBASEm, NULL,
        INVALIDr,
        SYSTEM_CONFIG_MODVIEW_PARITY_CONTROLr, PARITY_ENf,
        SYSTEM_CONFIG_MODVIEW_PARITY_STATUS_INTRr, NULL,
        SYSTEM_CONFIG_MODVIEW_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SYS_CONFIG_PAR_ERRf,
        SYS_CONFIG_PAR_ERRf,
        SYSTEM_CONFIG_TABLEm, NULL,
        INVALIDr,
        SYSTEM_CONFIG_PARITY_CONTROLr, PARITY_ENf,
        SYSTEM_CONFIG_PARITY_STATUS_INTRr, NULL,
        SYSTEM_CONFIG_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        PORT_TABLE_PAR_ERRf,
        PORT_TABLE_PAR_ERRf,
        PORT_TABm, NULL,
        INVALIDr,
        PORT_TABLE_ECC_CONTROLr, ECC_ENf,
        PORT_TABLE_ECC_STATUS_INTRr, NULL,
        PORT_TABLE_ECC_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PTP_LABEL_RANGE_PROFILE_TABLE_PAR_ERRf,
        PTP_LABEL_RANGE_PROFILE_TABLE_PAR_ERRf,
        PTP_LABEL_RANGE_PROFILE_TABLEm, NULL,
        INVALIDr,
        PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_CONTROLr, PARITY_ENf,
        PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_STATUS_INTRr, NULL,
        PTP_LABEL_RANGE_PROFILE_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_ECC, NULL, 0,
        LPORT_PAR_ERRf,
        LPORT_PAR_ERRf,
        LPORT_TABm, NULL,
        INVALIDr,
        LPORT_ECC_CONTROLr, ECC_ENf,
        LPORT_ECC_STATUS_INTRr, NULL,
        LPORT_ECC_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RX_PROT_GROUP_TABLE_1_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_1_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_1_DMAm, NULL,
        INVALIDr,
        RX_PROT_GROUP_TABLE_1_DMA_PARITY_CONTROLr, PARITY_ENf,
        RX_PROT_GROUP_TABLE_1_DMA_PARITY_STATUS_INTRr, NULL,
        RX_PROT_GROUP_TABLE_1_DMA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_TUNNEL_PAR_ERRf,
        L3_TUNNEL_PAR_ERRf,
        L3_TUNNEL_DATA_ONLYm, NULL,
        INVALIDr,
        L3_TUNNEL_PARITY_CONTROLr, PARITY_ENf,
        L3_TUNNEL_PARITY_STATUS_INTRr, NULL,
        L3_TUNNEL_PARITY_STATUS_NACKr, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        FP_UDF_PAR_ERRf,
        FP_UDF_PAR_ERRf,
        FP_UDF_OFFSETm, NULL,
        INVALIDr,
        FP_UDF_PARITY_CONTROLr, PARITY_ENf,
        FP_UDF_PARITY_STATUS_INTRr, NULL,
        FP_UDF_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MOD_MAP_PAR_ERRf,
        MOD_MAP_PAR_ERRf,
        ING_MOD_MAP_TABLEm, NULL,
        INVALIDr,
        MOD_MAP_PARITY_CONTROLr, PARITY_ENf,
        MOD_MAP_PARITY_STATUS_INTRr, NULL,
        MOD_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_RANGE_PAR_ERRf,
        VLAN_RANGE_PAR_ERRf,
        ING_VLAN_RANGEm, NULL,
        INVALIDr,
        VLAN_RANGE_PARITY_CONTROLr, PARITY_ENf,
        VLAN_RANGE_PARITY_STATUS_INTRr, NULL,
        VLAN_RANGE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        CPU_TS_POLICY_PAR_ERRf,
        CPU_TS_POLICY_PAR_ERRf,
        CPU_TS_MAPm, NULL,
        INVALIDr,
        CPU_TS_PARITY_CONTROLr, PARITY_ENf,
        CPU_TS_PARITY_STATUS_INTRr, NULL,
        CPU_TS_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SOURCE_VP_PAR_ERRf,
        SOURCE_VP_PAR_ERRf,
        SOURCE_VPm, NULL,
        INVALIDr,
        SOURCE_VP_PARITY_CONTROLr, PARITY_ENf,
        SOURCE_VP_PARITY_STATUS_INTRr, NULL,
        SOURCE_VP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VFI_1_PAR_ERRf,
        VFI_1_PAR_ERRf,
        VFI_1m, NULL,
        INVALIDr,
        VFI_1_PARITY_CONTROLr, PARITY_ENf,
        VFI_1_PARITY_STATUS_INTRr, NULL,
        VFI_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_IIF_PAR_ERRf,
        L3_IIF_PAR_ERRf,
        L3_IIFm, NULL,
        INVALIDr,
        L3_IIF_PARITY_CONTROLr, PARITY_ENf,
        L3_IIF_PARITY_STATUS_INTRr, NULL,
        L3_IIF_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VFI_PAR_ERRf,
        VFI_PAR_ERRf,
        VFIm, NULL,
        INVALIDr,
        VFI_PARITY_CONTROLr, PARITY_ENf,
        VFI_PARITY_STATUS_INTRr, NULL,
        VFI_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VRF_PAR_ERRf,
        VRF_PAR_ERRf,
        VRFm, NULL,
        INVALIDr,
        VRF_PARITY_CONTROLr, PARITY_ENf,
        VRF_PARITY_STATUS_INTRr, NULL,
        VRF_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_MPLS_PAR_ERRf,
        VLAN_MPLS_PAR_ERRf,
        VLAN_MPLSm, NULL,
        INVALIDr,
        VLAN_MPLS_PARITY_CONTROLr, PARITY_ENf,
        VLAN_MPLS_PARITY_STATUS_INTRr, NULL,
        VLAN_MPLS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_PAR_ERRf,
        VLAN_PAR_ERRf,
        VLAN_TABm, NULL,
        INVALIDr,
        VLAN_PARITY_CONTROLr, PARITY_ENf,
        VLAN_PARITY_STATUS_INTRr, NULL,
        VLAN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_STG_PAR_ERRf,
        VLAN_STG_PAR_ERRf,
        STG_TABm, NULL,
        INVALIDr,
        VLAN_STG_PARITY_CONTROLr, PARITY_ENf,
        VLAN_STG_PARITY_STATUS_INTRr, NULL,
        VLAN_STG_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_ONLYm, NULL,
        INVALIDr,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l3_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l3_entry_only_nack_reg },

    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_IPV4_UNICASTm, NULL,
        INVALIDr,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l3_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l3_entry_only_nack_reg },  
  
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_IPV6_UNICASTm, NULL,
        INVALIDr,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l3_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l3_entry_only_nack_reg },  

    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_IPV4_MULTICASTm, NULL,
        INVALIDr,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l3_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l3_entry_only_nack_reg },  

    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_PAR_ERRf,
        L3_ENTRY_IPV6_MULTICASTm, NULL,
        INVALIDr,
        L3_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l3_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l3_entry_only_nack_reg },  

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_DEFIP_PAR_ERRf,
        L3_DEFIP_PAR_ERRf,
        L3_DEFIP_DATA_ONLYm, NULL,
        INVALIDr,
        L3_DEFIP_DATA_PARITY_CONTROLr, PARITY_ENf,
        L3_DEFIP_DATA_PARITY_STATUS_INTRr, NULL,
        L3_DEFIP_DATA_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RTAG7_FLOW_BASED_HASH_PAR_ERRf,
        RTAG7_FLOW_BASED_HASH_PAR_ERRf,
        RTAG7_FLOW_BASED_HASHm, NULL,
        INVALIDr,
        RTAG7_FLOW_BASED_HASH_PARITY_CONTROLr, PARITY_ENf,
        RTAG7_FLOW_BASED_HASH_PARITY_STATUS_INTRr, NULL,
        RTAG7_FLOW_BASED_HASH_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        FP_FIELD_SEL_PAR_ERRf,
        FP_FIELD_SEL_PAR_ERRf,
        FP_PORT_FIELD_SELm, NULL,
        INVALIDr,
        FP_FIELD_SEL_PARITY_CONTROLr, PARITY_ENf,
        FP_FIELD_SEL_PARITY_STATUS_INTRr, NULL,
        FP_FIELD_SEL_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TTL_FN_PAR_ERRf,
        TTL_FN_PAR_ERRf,
        TTL_FNm, NULL,
        INVALIDr,
        TTL_FN_PARITY_CONTROLr, PARITY_ENf,
        TTL_FN_PARITY_STATUS_INTRr, NULL,
        TTL_FN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TOS_FN_PAR_ERRf,
        TOS_FN_PAR_ERRf,
        TOS_FNm, NULL,
        INVALIDr,
        TOS_FN_PARITY_CONTROLr, PARITY_ENf,
        TOS_FN_PARITY_STATUS_INTRr, NULL,
        TOS_FN_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_PRI_CNG_MAP_PAR_ERRf,
        ING_PRI_CNG_MAP_PAR_ERRf,
        ING_PRI_CNG_MAPm, NULL,
        INVALIDr,
        ING_PRI_CNG_MAP_PARITY_CONTROLr, PARITY_ENf,
        ING_PRI_CNG_MAP_PARITY_STATUS_INTRr, NULL,
        ING_PRI_CNG_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_UNTAGGED_PHB_PAR_ERRf,
        ING_UNTAGGED_PHB_PAR_ERRf,
        ING_UNTAGGED_PHBm, NULL,
        INVALIDr,
        ING_UNTAGGED_PHB_PARITY_CONTROLr, PARITY_ENf,
        ING_UNTAGGED_PHB_PARITY_STATUS_INTRr, NULL,
        ING_UNTAGGED_PHB_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DSCP_TABLE_PAR_ERRf,
        DSCP_TABLE_PAR_ERRf,
        DSCP_TABLEm, NULL,
        INVALIDr,
        DSCP_TABLE_PARITY_CONTROLr, PARITY_ENf,
        DSCP_TABLE_PARITY_STATUS_INTRr, NULL,
        DSCP_TABLE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        L2_ENTRY_PAR_ERRf,
        L2_ENTRY_PAR_ERRf,
        L2_ENTRY_ONLYm, NULL,
        INVALIDr,
        L2_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_l2_entry_only_intr_reg,
        INVALIDr, _soc_katana2_l2_entry_only_nack_reg },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NHOP_PAR_ERRf,
        NHOP_PAR_ERRf,
        INITIAL_ING_L3_NEXT_HOPm, NULL,
        INVALIDr,
        INITIAL_ING_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_ING_L3_NEXT_HOP_PARITY_STATUS_INTRr, NULL,
        INITIAL_ING_L3_NEXT_HOP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ECMP_GRP_PAR_ERRf,
        ECMP_GRP_PAR_ERRf,
        INITIAL_L3_ECMP_GROUPm, NULL,
        INVALIDr,
        INITIAL_L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_L3_ECMP_GROUP_PARITY_STATUS_INTRr, NULL,
        INITIAL_L3_ECMP_GROUP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_ECMP_PAR_ERRf,
        L3_ECMP_PAR_ERRf,
        INITIAL_L3_ECMPm, NULL,
        INVALIDr,
        INITIAL_L3_ECMP_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_L3_ECMP_PARITY_STATUS_INTRr, NULL,
        INITIAL_L3_ECMP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_DVP_PAR_ERRf,
        ING_DVP_PAR_ERRf,
        ING_DVP_TABLEm, NULL,
        INVALIDr,
        ING_DVP_TABLE_PARITY_CONTROLr, PARITY_ENf,
        ING_DVP_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_DVP_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PROT_NHI_PAR_ERRf,
        PROT_NHI_PAR_ERRf,
        INITIAL_PROT_NHI_TABLEm, NULL,
        INVALIDr,
        INITIAL_PROT_NHI_TABLE_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_PROT_NHI_TABLE_PARITY_STATUS_INTRr, NULL,
        INITIAL_PROT_NHI_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PORT_CBL_PAR_ERRf,
        PORT_CBL_PAR_ERRf,
        PORT_CBL_TABLEm, NULL,
        INVALIDr,
        PORT_CBL_TABLE_PARITY_CONTROLr, PARITY_ENf,
        PORT_CBL_TABLE_PARITY_STATUS_INTRr, NULL,
        PORT_CBL_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PORT_CBL_MODBASE_PAR_ERRf,
        PORT_CBL_MODBASE_PAR_ERRf,
        PORT_CBL_TABLE_MODBASEm, NULL,
        INVALIDr,
        PORT_CBL_TABLE_MODBASE_PARITY_CONTROLr, PARITY_ENf,
        PORT_CBL_TABLE_MODBASE_PARITY_STATUS_INTRr, NULL,
        PORT_CBL_TABLE_MODBASE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_IPMC_1_PAR_ERRf,
        L3_IPMC_1_PAR_ERRf,
        L3_IPMC_1m, NULL,
        INVALIDr,
        L3_IPMC_1_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_1_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MA_INDEX_PAR_ERRf,
        MA_INDEX_PAR_ERRf,
        MA_INDEXm, NULL,
        INVALIDr,
        MA_INDEX_PARITY_CONTROLr, PARITY_ENf,
        MA_INDEX_PARITY_STATUS_INTRr, NULL,
        MA_INDEX_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RMEP_PAR_ERRf,
        RMEP_PAR_ERRf,
        RMEPm, NULL,
        INVALIDr,
        RMEP_PARITY_CONTROLr, PARITY_ENf,
        RMEP_PARITY_STATUS_INTRr, NULL,
        RMEP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MAID_REDUCTION_PAR_ERRf,
        MAID_REDUCTION_PAR_ERRf,
        MAID_REDUCTIONm, NULL,
        INVALIDr,
        MAID_REDUCTION_PARITY_CONTROLr, PARITY_ENf,
        MAID_REDUCTION_PARITY_STATUS_INTRr, NULL,
        MAID_REDUCTION_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MA_STATE_PAR_ERRf,
        MA_STATE_PAR_ERRf,
        MA_STATEm, NULL,
        INVALIDr,
        MA_STATE_PARITY_CONTROLr, PARITY_ENf,
        MA_STATE_PARITY_STATUS_INTRr, NULL,
        MA_STATE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_OR_VFI_MAC_COUNT_PAR_ERRf,
        VLAN_OR_VFI_MAC_COUNT_PAR_ERRf,
        VLAN_OR_VFI_MAC_COUNTm, NULL,
        INVALIDr,
        VLAN_OR_VFI_MAC_COUNT_PARITY_CONTROLr, PARITY_ENf,
        VLAN_OR_VFI_MAC_COUNT_PARITY_STATUS_INTRr, NULL,
        VLAN_OR_VFI_MAC_COUNT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_OR_VFI_MAC_LIMIT_PAR_ERRf,
        VLAN_OR_VFI_MAC_LIMIT_PAR_ERRf,
        VLAN_OR_VFI_MAC_LIMITm, NULL,
        INVALIDr,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_CONTROLr, PARITY_ENf,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_STATUS_INTRr, NULL,
        VLAN_OR_VFI_MAC_LIMIT_PARITY_STATUS_NACKr, NULL },
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip1_1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RTAG7_PORT_BASED_HASH_PAR_ERRf,
        RTAG7_PORT_BASED_HASH_PAR_ERRf,
        RTAG7_PORT_BASED_HASHm, NULL,
        INVALIDr,
        RTAG7_PORT_BASED_HASH_PARITY_CONTROLr, PARITY_ENf,
        RTAG7_PORT_BASED_HASH_PARITY_STATUS_INTRr, NULL,
        RTAG7_PORT_BASED_HASH_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        RX_PROT_GROUP_TABLE_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_DMA_PAR_ERRf,
        RX_PROT_GROUP_TABLE_DMAm, NULL,
        INVALIDr,
        RX_PROT_GROUP_TABLE_DMA_PARITY_CONTROLr, PARITY_ENf,
        RX_PROT_GROUP_TABLE_DMA_PARITY_STATUS_INTRr, NULL,
        RX_PROT_GROUP_TABLE_DMA_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        MPLS_ENTRY_PAR_ERRf,
        MPLS_ENTRY_PAR_ERRf,
        MPLS_ENTRYm, NULL,
        INVALIDr,
        MPLS_ENTRY_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_mpls_entry_intr_reg,
        INVALIDr, _soc_katana2_mpls_entry_nack_reg },    
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_SUBNET_DATA_ONLY_PAR_ERRf,
        VLAN_SUBNET_DATA_ONLY_PAR_ERRf,
        VLAN_SUBNET_DATA_ONLYm, NULL,
        INVALIDr,
        VLAN_SUBNET_PARITY_CONTROLr, PARITY_ENf,
        VLAN_SUBNET_PARITY_STATUS_INTRr, NULL,
        VLAN_SUBNET_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_PROTOCOL_DATA_PAR_ERRf,
        VLAN_PROTOCOL_DATA_PAR_ERRf,
        VLAN_PROTOCOL_DATAm, NULL,
        INVALIDr,
        VLAN_PROT_PARITY_CONTROLr, PARITY_ENf,
        VLAN_PROT_PARITY_STATUS_INTRr, NULL,
        VLAN_PROT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VFP_POLICY_PAR_ERRf,
        VFP_POLICY_PAR_ERRf,
        VFP_POLICY_TABLEm, NULL,
        INVALIDr,
        VFP_POLICY_PARITY_CONTROLr, PARITY_ENf,
        VFP_POLICY_PARITY_STATUS_INTRr, NULL,
        VFP_POLICY_PARITY_STATUS_NACKr, NULL }, 
    
    { _SOC_PARITY_TYPE_HASH, NULL, 0,
        VLAN_XLATE_PAR_ERRf, 
        VLAN_XLATE_PAR_ERRf,
        VLAN_XLATEm, NULL,
        INVALIDr,
        VLAN_XLATE_PARITY_CONTROLr, PARITY_ENf,
        INVALIDr, _soc_katana2_vlan_xlate_intr_reg,
        INVALIDr, _soc_katana2_vlan_xlate_nack_reg },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        INITIAL_PROT_NHI_TABLE_1_DMA_PAR_ERRf,
        INITIAL_PROT_NHI_TABLE_1_DMA_PAR_ERRf,
        INITIAL_PROT_NHI_TABLE_1_DMAm, NULL,
        INVALIDr,
        INITIAL_PROT_NHI_TABLE_1_DMA_PARITY_CONTROLr, PARITY_ENf,
        INITIAL_PROT_NHI_TABLE_1_DMA_PARITY_STATUS_INTRr, NULL,
        INITIAL_PROT_NHI_TABLE_1_DMA_PARITY_STATUS_NACKr, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L2_MOD_FIFO_INTRf,
        L2_MOD_FIFO_INTRf,
        L2_MOD_FIFOm, NULL,
        INVALIDr,
        L2_MOD_FIFO_PARITY_CONTROLr, PARITY_ENf,
        L2_MOD_FIFO_PARITY_STATUS_INTRr, NULL,
        L2_MOD_FIFO_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MY_STATION_TCAM_DATA_ONLY_PAR_ERRf,
        MY_STATION_TCAM_DATA_ONLY_PAR_ERRf,
        MY_STATION_TCAM_DATA_ONLYm, NULL,
        INVALIDr,
        MY_STATION_DATA_PARITY_CONTROLr, PARITY_ENf,
        MY_STATION_TCAM_DATA_ONLY_PARITY_STATUS_INTRr, NULL,
        MY_STATION_TCAM_DATA_ONLY_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip2_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_METER_PARITY_ERRORf,
        IFP_METER_PARITY_ERRORf,
        FP_METER_TABLEm, NULL,
        INVALIDr,
        IFP_METER_PARITY_CONTROLr, PARITY_ENf,
        IFP_METER_PARITY_STATUS_INTRr, NULL,
        IFP_METER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_COUNTER_PARITY_ERRORf,
        IFP_COUNTER_PARITY_ERRORf,
        FP_COUNTER_TABLEm, NULL,
        INVALIDr,
        IFP_COUNTER_PARITY_CONTROLr, PARITY_ENf,
        IFP_COUNTER_PARITY_STATUS_INTRr, NULL,
        IFP_COUNTER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_POLICY_PARITY_ERRORf,
        IFP_POLICY_PARITY_ERRORf,
        FP_POLICY_TABLEm, NULL,
        INVALIDr,
        IFP_POLICY_PARITY_CONTROLr, PARITY_ENf,
        IFP_POLICY_PARITY_STATUS_INTRr, NULL,
        IFP_POLICY_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IFP_STORM_CONTROL_PARITY_ERRORf,
        IFP_STORM_CONTROL_PARITY_ERRORf,
        FP_STORM_CONTROL_METERSm, NULL,
        INVALIDr,
        IFP_STORM_CONTROL_PARITY_CONTROLr, PARITY_ENf,
        IFP_STORM_CONTROL_PARITY_STATUS_INTRr, NULL,
        IFP_STORM_CONTROL_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_MACROFLOW_TABLE_PARITY_ERRORf,
        SVC_MACROFLOW_TABLE_PARITY_ERRORf,
        SVM_MACROFLOW_INDEX_TABLEm, "SVM MACROFLOW",
        INVALIDr,
        ING_SVM_MACROFLOW_INDEX_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_MACROFLOW_INDEX_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_MACROFLOW_INDEX_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_OFFSET_TABLE_PARITY_ERRORf,
        SVC_OFFSET_TABLE_PARITY_ERRORf,
        SVM_OFFSET_TABLEm, "SVM OFFSET",
        INVALIDr,
        ING_SVM_OFFSET_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_OFFSET_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_OFFSET_TABLE_PARITY_STATUS_NACKr, NULL },
        
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_METER_TABLE_PARITY_ERRORf,
        SVC_METER_TABLE_PARITY_ERRORf,
        SVM_METER_TABLEm, "SVM METER",
        INVALIDr,
        ING_SVM_METER_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_METER_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_METER_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SVC_POLICY_TABLE_PARITY_ERRORf,
        SVC_POLICY_TABLE_PARITY_ERRORf,
        SVM_POLICY_TABLEm, "SVM POLICY",
        INVALIDr,
        ING_SVM_POLICY_TABLE_CONTROLr, PARITY_ENf,
        ING_SVM_POLICY_TABLE_PARITY_STATUS_INTRr, NULL,
        ING_SVM_POLICY_TABLE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip3_parity_info[] = {
    
	{ _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DLB_HGT_FLOWSET_PORT_PAR_ERRf,
        DLB_HGT_FLOWSET_PORT_PAR_ERRf,
        INVALIDm, NULL,
        INVALIDr,
        DLB_HGT_FLOWSET_PORT_PARITY_CONTROLr, PARITY_ENf,
        DLB_HGT_FLOWSET_PORT_PARITY_STATUS_INTRr, NULL,
        DLB_HGT_FLOWSET_PORT_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DLB_HGT_FLOWSET_TIMESTAMP_PAR_ERRf,
        DLB_HGT_FLOWSET_TIMESTAMP_PAR_ERRf,
        INVALIDm, NULL,
        INVALIDr,
        DLB_HGT_FLOWSET_TIMESTAMP_PARITY_CONTROLr, PARITY_ENf,
        DLB_HGT_FLOWSET_TIMESTAMP_PARITY_STATUS_INTRr, NULL,
        DLB_HGT_FLOWSET_TIMESTAMP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PAR_ERRf,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PAR_ERRf,
        INVALIDm, NULL,
        INVALIDr,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_CONTROLr, PARITY_ENf,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_STATUS_INTRr, NULL,
        DLB_HGT_FLOWSET_TIMESTAMP_PAGE_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_ING_L3_NEXT_HOP_PAR_ERRf,
        IRSEL2_ING_L3_NEXT_HOP_PAR_ERRf,
        ING_L3_NEXT_HOPm, NULL,
        INVALIDr,
        ING_L3_NEXT_HOP_PARITY_CONTROLr, PARITY_ENf,
        ING_L3_NEXT_HOP_PARITY_STATUS_INTRr, NULL,
        ING_L3_NEXT_HOP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_IPMC_REMAP_PAR_ERRf,
        IRSEL2_L3_IPMC_REMAP_PAR_ERRf,
        L3_IPMC_REMAPm, NULL,
        INVALIDr,
        L3_IPMC_REMAP_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_REMAP_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_REMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_IPMC_PAR_ERRf,
        IRSEL2_L3_IPMC_PAR_ERRf,
        L3_IPMCm, NULL,
        INVALIDr,
        L3_IPMC_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L2MC_PAR_ERRf,
        IRSEL2_L2MC_PAR_ERRf,
        L2MCm, NULL,
        INVALIDr,
        L2MC_PARITY_CONTROLr, PARITY_ENf,
        L2MC_PARITY_STATUS_INTRr, NULL,
        L2MC_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_IFP_REDIRECTION_PROFILE_PAR_ERRf,
        IRSEL2_IFP_REDIRECTION_PROFILE_PAR_ERRf,
        IFP_REDIRECTION_PROFILEm, NULL,
        INVALIDr,
        IFP_REDIRECTION_PROFILE_PARITY_CONTROLr, PARITY_ENf,
        IFP_REDIRECTION_PROFILE_PARITY_STATUS_INTRr, NULL,
        IFP_REDIRECTION_PROFILE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_ECMP_GROUP_PAR_ERRf,
        IRSEL2_L3_ECMP_GROUP_PAR_ERRf,
        L3_ECMP_COUNTm, NULL,
        INVALIDr,
        L3_ECMP_GROUP_PARITY_CONTROLr, PARITY_ENf,
        L3_ECMP_GROUP_PARITY_STATUS_INTRr, NULL,
        L3_ECMP_GROUP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_ECMP_PAR_ERRf,
        IRSEL2_L3_ECMP_PAR_ERRf,
        L3_ECMPm, NULL,
        INVALIDr,
        L3_ECMP_PARITY_CONTROLr, PARITY_ENf,
        L3_ECMP_PARITY_STATUS_INTRr, NULL,
        L3_ECMP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_EGR_MASK_MODBASE_PAR_ERRf,
        IRSEL2_EGR_MASK_MODBASE_PAR_ERRf,
        EGR_MASK_MODBASEm, NULL,
        INVALIDr,
        EGR_MASK_MODBASE_PARITY_CONTROLr, PARITY_ENf,
        EGR_MASK_MODBASE_PARITY_STATUS_INTRr, NULL,
        EGR_MASK_MODBASE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ICONTROL_OPCODE_BITMAP_PAR_ERRf,
        ICONTROL_OPCODE_BITMAP_PAR_ERRf,
        ICONTROL_OPCODE_BITMAPm, NULL,
        INVALIDr,
        ICONTROL_OPCODE_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        ICONTROL_OPCODE_BITMAP_PARITY_STATUS_INTRr, NULL,
        ICONTROL_OPCODE_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_0_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_0_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_0m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_0r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_0r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_1_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_1_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_1m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_1r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_1r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_1r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_2_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_2_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_2m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_2r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_2r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_2r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_3_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_3_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_3m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_3r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_3r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_3r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_4_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_4_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_4m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_4r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_4r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_4r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_5_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_5_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_5m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_5r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_5r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_5r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_6_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_6_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_6m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_6r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_6r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_6r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_7_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_7_OFFSET_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_OFFSET_TABLE_7m, NULL,
        INVALIDr,
        ING_FLEX_CTR_OFFSET_TABLE_CONTROL_7r, PARITY_ENf,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_INTR_7r, NULL,
        ING_FLEX_CTR_OFFSET_TABLE_PARITY_STATUS_NACK_7r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_0_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_0_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_0m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_0r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_0r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_0r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_1_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_1_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_1m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_1r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_1r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_1r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_2_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_2_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_2m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_2r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_2r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_2r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_3_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_3_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_3m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_3r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_3r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_3r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_4_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_4_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_4m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_4r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_4r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_4r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_5_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_5_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_5m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_5r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_5r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_5r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_6_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_6_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_6m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_6r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_6r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_6r, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_POOL_7_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_POOL_7_COUNTER_TABLE_INTR_STATUSf,
        ING_FLEX_CTR_COUNTER_TABLE_7m, NULL,
        INVALIDr,
        ING_FLEX_CTR_COUNTER_TABLE_CONTROL_7r, PARITY_ENf,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_INTR_7r, NULL,
        ING_FLEX_CTR_COUNTER_TABLE_PARITY_STATUS_NACK_7r, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SFLOW_ING_THRESHOLD_PAR_ERRf,
        SFLOW_ING_THRESHOLD_PAR_ERRf,
        INVALIDm, NULL,
        SFLOW_ING_THRESHOLDr,
        SFLOW_ING_THRESHOLD_PARITY_CONTROLr, PARITY_ENf,
        SFLOW_ING_THRESHOLD_PARITY_STATUS_INTRr, NULL,
        SFLOW_ING_THRESHOLD_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip3_1_parity_info[] = {
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EGR_MASK_PAR_ERRf,
        EGR_MASK_PAR_ERRf,
        EGR_MASKm, NULL,
        INVALIDr,
        EGR_MASK_PARITY_CONTROLr, PARITY_ENf,
        EGR_MASK_PARITY_STATUS_INTRr, NULL,
        EGR_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRUNK_BITMAP_PAR_ERRf,
        TRUNK_BITMAP_PAR_ERRf,
        TRUNK_BITMAPm, NULL,
        INVALIDr,
        TRUNK_BITMAP_TABLE_PARITY_CONTROLr, PARITY_ENf,
        TRUNK_BITMAP_TABLE_PARITY_STATUS_INTRr, NULL,
        TRUNK_BITMAP_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf,
        NONUCAST_TRUNK_BLOCK_MASK_PAR_ERRf,
        NONUCAST_TRUNK_BLOCK_MASKm, NULL,
        INVALIDr,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        NONUCAST_TRUNK_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MAC_BLOCK_TABLE_PAR_ERRf,
        MAC_BLOCK_TABLE_PAR_ERRf,
        MAC_BLOCKm, NULL,
        INVALIDr,
        MAC_BLOCK_TABLE_PARITY_CONTROLr, PARITY_ENf,
        MAC_BLOCK_TABLE_PARITY_STATUS_INTRr, NULL,
        MAC_BLOCK_TABLE_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_SW_PAR_ERRf,
        MODPORT_MAP_SW_PAR_ERRf,
        MODPORT_MAP_SWm, NULL,
        INVALIDr,
        MODPORT_MAP_SW_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_SW_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_SW_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M0_PAR_ERRf,
        MODPORT_MAP_M0_PAR_ERRf,
        MODPORT_MAP_M0m, NULL,
        INVALIDr,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M0_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M1_PAR_ERRf,
        MODPORT_MAP_M1_PAR_ERRf,
        MODPORT_MAP_M1m, NULL,
        INVALIDr,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M1_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M2_PAR_ERRf,
        MODPORT_MAP_M2_PAR_ERRf,
        MODPORT_MAP_M2m, NULL,
        INVALIDr,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M2_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M2_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        MODPORT_MAP_M3_PAR_ERRf,
        MODPORT_MAP_M3_PAR_ERRf,
        MODPORT_MAP_M3m, NULL,
        INVALIDr,
        MODPORT_MAP_MIRROR_PARITY_CONTROLr, PARITY_ENf,
        MODPORT_MAP_M3_PARITY_STATUS_INTRr, NULL,
        MODPORT_MAP_M3_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SRC_MODID_INGRESS_BLOCK_PAR_ERRf,
        SRC_MODID_INGRESS_BLOCK_PAR_ERRf,
        SRC_MODID_INGRESS_BLOCKm, NULL,
        INVALIDr,
        SRC_MODID_INGRESS_BLOCK_PARITY_CONTROLr, PARITY_ENf,
        SRC_MODID_INGRESS_BLOCK_PARITY_STATUS_INTRr, NULL,
        SRC_MODID_INGRESS_BLOCK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SRC_MODID_EGRESS_PAR_ERRf,
        SRC_MODID_EGRESS_PAR_ERRf,
        SRC_MODID_EGRESSm, NULL,
        INVALIDr,
        SRC_MODID_EGRESS_PARITY_CONTROLr, PARITY_ENf,
        SRC_MODID_EGRESS_PARITY_STATUS_INTRr, NULL,
        SRC_MODID_EGRESS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ALTERNATE_EMIRROR_BITMAP_PAR_ERRf,
        ALTERNATE_EMIRROR_BITMAP_PAR_ERRf,
        ALTERNATE_EMIRROR_BITMAPm, NULL,
        INVALIDr,
        ALTERNATE_EMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUS_INTRr, NULL,
        ALTERNATE_EMIRROR_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PORT_LAG_FAILOVER_SET_PAR_ERRf,
        PORT_LAG_FAILOVER_SET_PAR_ERRf,
        PORT_LAG_FAILOVER_SETm, NULL,
        INVALIDr,
        PORT_LAG_FAILOVER_SET_PARITY_CONTROLr, PARITY_ENf,
        PORT_LAG_FAILOVER_SET_PARITY_STATUS_INTRr, NULL,
        PORT_LAG_FAILOVER_SET_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        VLAN_PROFILE_2_PAR_ERRf,
        VLAN_PROFILE_2_PAR_ERRf,
        VLAN_PROFILE_2m, NULL,
        INVALIDr,
        VLAN_PROFILE_2_PARITY_CONTROLr, PARITY_ENf,
        VLAN_PROFILE_2_PARITY_STATUS_INTRr, NULL,
        VLAN_PROFILE_2_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        L3_MTU_VALUES_PAR_ERRf,
        L3_MTU_VALUES_PAR_ERRf,
        L3_MTU_VALUESm, NULL,
        INVALIDr,
        L3_MTU_VALUES_PARITY_CONTROLr, PARITY_ENf,
        L3_MTU_VALUES_PARITY_STATUS_INTRr, NULL,
        L3_MTU_VALUES_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_PW_TERM_SEQ_NUM_PAR_ERRf,
        ING_PW_TERM_SEQ_NUM_PAR_ERRf,
        ING_PW_TERM_SEQ_NUMm, NULL,
        INVALIDr,
        ING_PW_TERM_SEQ_NUM_PARITY_CONTROLr, PARITY_ENf,
        ING_PW_TERM_SEQ_NUM_PARITY_STATUS_INTRr, NULL,
        ING_PW_TERM_SEQ_NUM_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_FLEX_CTR_PKT_RES_MAP_PAR_ERRf,
        ING_FLEX_CTR_PKT_RES_MAP_PAR_ERRf,
        ING_FLEX_CTR_PKT_RES_MAPm, NULL,
        INVALIDr,
        ING_FLEX_CTR_PKT_RES_MAP_PARITY_CONTROLr, PARITY_ENf,
        ING_FLEX_CTR_PKT_RES_MAP_PARITY_STATUS_INTRr, NULL,
        ING_FLEX_CTR_PKT_RES_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IRSEL2_L3_IPMC_2_PAR_ERRf,
        IRSEL2_L3_IPMC_2_PAR_ERRf,
        L3_IPMC_2m, NULL,
        INVALIDr,
        L3_IPMC_2_PARITY_CONTROLr, PARITY_ENf,
        L3_IPMC_2_PARITY_STATUS_INTRr, NULL,
        L3_IPMC_2_PARITY_STATUS_NACKr, NULL },

    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SERVICE_COS_MAP_PAR_ERRf,
        SERVICE_COS_MAP_PAR_ERRf,
        SERVICE_COS_MAPm, NULL,
        INVALIDr,
        SERVICE_COS_MAP_PARITY_CONTROLr, PARITY_ENf,
        SERVICE_COS_MAP_PARITY_STATUS_INTRr, NULL,
        SERVICE_COS_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        E2E_HOL_STATUS_PAR_ERRf,
        E2E_HOL_STATUS_PAR_ERRf,
        E2E_HOL_STATUSm, NULL,
        INVALIDr,
        E2E_HOL_STATUS_PARITY_CONTROLr, PARITY_ENf,
        E2E_HOL_STATUS_PARITY_STATUS_INTRr, NULL,
        E2E_HOL_STATUS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        E2E_HOL_STATUS_1_PAR_ERRf,
        E2E_HOL_STATUS_1_PAR_ERRf,
        E2E_HOL_STATUS_1m, NULL,
        INVALIDr,
        E2E_HOL_STATUS_1_PARITY_CONTROLr, PARITY_ENf,
        E2E_HOL_STATUS_1_PARITY_STATUS_INTRr, NULL,
        E2E_HOL_STATUS_1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        UNKNOWN_UCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_UCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_UCAST_BLOCK_MASKm, NULL,
        INVALIDr,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        UNKNOWN_UCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        UNKNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        UNKNOWN_MCAST_BLOCK_MASKm, NULL,
        INVALIDr,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        UNKNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        BCAST_BLOCK_MASK_PAR_ERRf,
        BCAST_BLOCK_MASK_PAR_ERRf,
        BCAST_BLOCK_MASKm, NULL,
        INVALIDr,
        BCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        BCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        BCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        KNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        KNOWN_MCAST_BLOCK_MASK_PAR_ERRf,
        KNOWN_MCAST_BLOCK_MASKm, NULL,
        INVALIDr,
        KNOWN_MCAST_BLOCK_MASK_PARITY_CONTROLr, PARITY_ENf,
        KNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_INTRr, NULL,
        KNOWN_MCAST_BLOCK_MASK_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_EGRMSKBMAP_PAR_ERRf,
        ING_EGRMSKBMAP_PAR_ERRf,
        ING_EGRMSKBMAPm, NULL,
        INVALIDr,
        ING_EGRMSKBMAP_PARITY_CONTROLr, PARITY_ENf,
        ING_EGRMSKBMAP_PARITY_STATUS_INTRr, NULL,
        ING_EGRMSKBMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBMm, NULL,
        INVALIDr,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_CONTROLr, PARITY_ENf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_STATUS_INTRr, NULL,
        LOCAL_SW_DISABLE_DEFAULT_PBM_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PAR_ERRf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRRm, NULL,
        INVALIDr,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_CONTROLr, PARITY_ENf,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_STATUS_INTRr, NULL,
        LOCAL_SW_DISABLE_DEFAULT_PBM_MIRR_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        IMIRROR_BITMAP_PAR_ERRf,
        IMIRROR_BITMAP_PAR_ERRf,
        IMIRROR_BITMAPm, NULL,
        INVALIDr,
        IMIRROR_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        IMIRROR_BITMAP_PARITY_STATUS_INTRr, NULL,
        IMIRROR_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        UNKNOWN_HGI_BITMAP_PAR_ERRf,
        UNKNOWN_HGI_BITMAP_PAR_ERRf,
        UNKNOWN_HGI_BITMAPm, NULL,
        INVALIDr,
        UNKNOWN_HGI_BITMAP_PARITY_CONTROLr, PARITY_ENf,
        UNKNOWN_HGI_BITMAP_PARITY_STATUS_INTRr, NULL,
        UNKNOWN_HGI_BITMAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRUNK_MEMBER_PAR_ERRf,
        TRUNK_MEMBER_PAR_ERRf,
        TRUNK_MEMBERm, NULL,
        INVALIDr,
        TRUNK_MEMBER_PARITY_CONTROLr, PARITY_ENf,
        TRUNK_MEMBER_PARITY_STATUS_INTRr, NULL,
        TRUNK_MEMBER_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        PHB2_COS_MAP_PAR_ERRf,
        PHB2_COS_MAP_PAR_ERRf,
        PHB2_COS_MAPm, NULL,
        INVALIDr,
        PHB2_COS_MAP_PARITY_CONTROLr, PARITY_ENf,
        PHB2_COS_MAP_PARITY_STATUS_INTRr, NULL,
        PHB2_COS_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC _soc_katana2_parity_info_t _soc_katana2_ip3_2_parity_info[] = {
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL_PAR_ERRf,
        EMIRROR_CONTROL_PAR_ERRf,
        EMIRROR_CONTROLm, NULL,
        INVALIDr,
        EMIRROR_CONTROL_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL_PARITY_STATUS_NACKr, NULL },
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL1_PAR_ERRf,
        EMIRROR_CONTROL1_PAR_ERRf,
        EMIRROR_CONTROL1m, NULL,
        INVALIDr,
        EMIRROR_CONTROL1_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL1_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL1_PARITY_STATUS_NACKr, NULL },
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL2_PAR_ERRf,
        EMIRROR_CONTROL2_PAR_ERRf,
        EMIRROR_CONTROL2m, NULL,
        INVALIDr,
        EMIRROR_CONTROL2_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL2_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL2_PARITY_STATUS_NACKr, NULL },
  
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        EMIRROR_CONTROL3_PAR_ERRf,
        EMIRROR_CONTROL3_PAR_ERRf,
        EMIRROR_CONTROL3m, NULL,
        INVALIDr,
        EMIRROR_CONTROL3_PARITY_CONTROLr, PARITY_ENf,
        EMIRROR_CONTROL3_PARITY_STATUS_INTRr, NULL,
        EMIRROR_CONTROL3_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SW2_EOP_BUFFER_A_PAR_ERRf,
        SW2_EOP_BUFFER_A_PAR_ERRf,
        INVALIDm, "SW2_EOP_BUFFER_A",
        INVALIDr,
        SW2_EOP_BUFFER_A_PARITY_CONTROLr, PARITY_ENf,
        SW2_EOP_BUFFER_A_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
     
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SW2_EOP_BUFFER_B_PAR_ERRf,
        SW2_EOP_BUFFER_B_PAR_ERRf,
        INVALIDm, "SW2_EOP_BUFFER_B",
        INVALIDr,
        SW2_EOP_BUFFER_B_PARITY_CONTROLr, PARITY_ENf,
        SW2_EOP_BUFFER_B_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        OAM_LM_COUNTERS_0_PAR_ERRf,
        OAM_LM_COUNTERS_0_PAR_ERRf,
        OAM_LM_COUNTERS_0m, "OAM_LM_COUNTERS_1",
        INVALIDr,
        OAM_LM_COUNTERS_0_PARITY_CONTROLr, PARITY_ENf,
        OAM_LM_COUNTERS_0_PARITY_STATUS_INTRr, NULL,
        OAM_LM_COUNTERS_0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        IP_COUNTERS_PAR_ERRf,
        IP_COUNTERS_PAR_ERRf,
        INVALIDm, "Ingress Pipeline Counter",
        INVALIDr,
        IP_COUNTERS_PARITY_CONTROLr, PARITY_ENf,
        IP_COUNTERS_PARITY_STATUS_INTRr, NULL,
        IP_COUNTERS_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        RDBGC_MEM_INST0_PAR_ERRf,
        RDBGC_MEM_INST0_PAR_ERRf,
        INVALIDm, "Ingress Pipeline Counter",
        INVALIDr,
        RDBGC_MEM_INST0_PARITY_CONTROLr, PARITY_ENf,
        RDBGC_MEM_INST0_PARITY_STATUS_INTRr, NULL,
        RDBGC_MEM_INST0_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        RDBGC_MEM_INST1_PAR_ERRf,
        RDBGC_MEM_INST1_PAR_ERRf,
        INVALIDm, "RX Debug Counter",
        INVALIDr,
        RDBGC_MEM_INST1_PARITY_CONTROLr, PARITY_ENf,
        RDBGC_MEM_INST1_PARITY_STATUS_INTRr, NULL,
        RDBGC_MEM_INST1_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        RDBGC_MEM_INST2_PAR_ERRf,
        RDBGC_MEM_INST2_PAR_ERRf,
        INVALIDm, "RX Debug Counter",
        INVALIDr,
        RDBGC_MEM_INST2_PARITY_CONTROLr, PARITY_ENf,
        RDBGC_MEM_INST2_PARITY_STATUS_INTRr, NULL,
        RDBGC_MEM_INST2_PARITY_STATUS_NACKr, NULL }, 

    { _SOC_PARITY_TYPE_COUNTER, NULL, 0,
        HG_COUNTERS_PAR_ERRf,
        HG_COUNTERS_PAR_ERRf,
        INVALIDm, "Ingress Pipeline HG Counter",
        INVALIDr,
        HG_COUNTERS_PARITY_CONTROLr, PARITY_ENf,
        HG_COUNTERS_PARITY_STATUS_INTRr, NULL,
        HG_COUNTERS_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NIV_ERROR_DROP_PAR_ERRf,
        NIV_ERROR_DROP_PAR_ERRf,
        INVALIDm, "ING_NIV_RX_FRAMES_ERROR_DROP",
        ING_NIV_RX_FRAMES_ERROR_DROPr,
        NIV_ERROR_DROP_PARITY_CONTROLr, PARITY_ENf,
        NIV_ERROR_DROP_PARITY_STATUS_INTRr, NULL,
        NIV_ERROR_DROP_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NIV_FORWARDING_DROP_PAR_ERRf,
        NIV_FORWARDING_DROP_PAR_ERRf,
        INVALIDm, "ING_NIV_RX_FRAMES_FORWARDING_DROP",
        ING_NIV_RX_FRAMES_FORWARDING_DROPr,
        NIV_FORWARDING_DROP_PARITY_CONTROLr, PARITY_ENf,
        NIV_FORWARDING_DROP_PARITY_STATUS_INTRr, NULL,
        NIV_FORWARDING_DROP_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        NIV_VLAN_TAGGED_PAR_ERRf,
        NIV_VLAN_TAGGED_PAR_ERRf,
        INVALIDm, "ING_NIV_RX_FRAMES_VLAN_TAGGED",
        ING_NIV_RX_FRAMES_VLAN_TAGGEDr,
        NIV_VLAN_TAGGED_PARITY_CONTROLr, PARITY_ENf,
        NIV_VLAN_TAGGED_PARITY_STATUS_INTRr, NULL,
        NIV_VLAN_TAGGED_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRILL_RX_PKTS_PAR_ERRf,
        TRILL_RX_PKTS_PAR_ERRf,
        INVALIDm, "ING_TRILL_RX_PKTS",
        ING_TRILL_RX_PKTSr,
        TRILL_RX_PKTS_PARITY_CONTROLr, PARITY_ENf,
        TRILL_RX_PKTS_PARITY_STATUS_INTRr, NULL,
        TRILL_RX_PKTS_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PAR_ERRf,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PAR_ERRf,
        INVALIDm, "ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED",
        ING_TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDEDr,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_CONTROLr, PARITY_ENf,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_STATUS_INTRr, NULL,
        TRILL_RX_ACCESS_PORT_TRILL_PKTS_DISCARDED_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PAR_ERRf,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PAR_ERRf,
        INVALIDm, "ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED",
        ING_TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDEDr,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_CONTROLr, PARITY_ENf,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_STATUS_INTRr, NULL,
        TRILL_RX_NETWORK_PORT_NON_TRILL_PKTS_DISCARDED_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        CPB_PAR_ERRf,
        CPB_PAR_ERRf,
        INVALIDm, "CPB",
        INVALIDr,
        CPB_PARITY_CONTROLr, PARITY_ENf,
        CPB_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        ING_QUEUE_MAP_PAR_ERRf,
        ING_QUEUE_MAP_PAR_ERRf,
        ING_QUEUE_MAPm, "ING_QUEUE_MAP",
        INVALIDr,
        ING_QUEUE_MAP_PARITY_CONTROLr, PARITY_ENf,
        ING_QUEUE_MAP_PARITY_STATUS_INTRr, NULL,
        ING_QUEUE_MAP_PARITY_STATUS_NACKr, NULL },
    
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        OAM_LM_COUNTERS_1_PAR_ERRf,
        OAM_LM_COUNTERS_1_PAR_ERRf,
        OAM_LM_COUNTERS_1m, "OAM_LM_COUNTERS_1",
        INVALIDr,
        OAM_LM_COUNTERS_1_PARITY_CONTROLr, PARITY_ENf,
        OAM_LM_COUNTERS_1_PARITY_STATUS_INTRr, NULL,
        OAM_LM_COUNTERS_1_PARITY_STATUS_NACKr, NULL },
   
    { _SOC_PARITY_TYPE_PARITY, NULL, 0,
        SW2_EOP_BUFFER_C_PAR_ERRf,
        SW2_EOP_BUFFER_C_PAR_ERRf,
        INVALIDm, "SW2_EOP_BUFFER_C",
        INVALIDr,
        SW2_EOP_BUFFER_C_PARITY_CONTROLr, PARITY_ENf,
        SW2_EOP_BUFFER_C_PARITY_STATUS_INTRr, NULL,
        INVALIDr, NULL },
   
    { _SOC_PARITY_TYPE_NONE } /* table terminator */
};

STATIC const
_soc_katana2_parity_route_block_t  _soc_katana2_parity_route_blocks[] = {
    { 0x00000001, /* MMU_TO_CMIC_MEMFAIL_INTR */
        SOC_BLK_MMU, MMU_INTR_MASKr, MMU_INTRr,
        NULL, 0},
        
    { 0x00000002, /* EP1_TO_CMIC_PERR_INTR */
        SOC_BLK_EPIPE, EGR_INTR0_ENABLEr, EGR_INTR0_STATUSr,
        _soc_katana2_ep0_parity_info, 0},
       
    { 0x00000004, /* EP2_TO_CMIC_PERR_INTR */
        SOC_BLK_EPIPE, EGR_INTR1_ENABLEr, EGR_INTR1_STATUSr,
        _soc_katana2_ep1_parity_info, 0},
    
    { 0x00000004, /* EP2_TO_CMIC_PERR_INTR */
        SOC_BLK_EPIPE, EGR_INTR2_ENABLEr, EGR_INTR2_STATUSr,
        _soc_katana2_ep2_parity_info, 0},
         
    { 0x00000008, /* IP0_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP0_INTR_ENABLEr, IP0_INTR_STATUSr,
        _soc_katana2_ip0_parity_info, 0},
        
    { 0x00000010, /* IP1_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP1_INTR_ENABLEr, IP1_INTR_STATUSr,
        _soc_katana2_ip1_parity_info, 0},
    
    { 0x00000010, /* IP1_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP1_INTR_ENABLE_1r, IP1_INTR_STATUS_1r,
        _soc_katana2_ip1_1_parity_info, 0},
        
    { 0x00000020, /* IP2_TO_CMIC_PERR_INTR */
        SOC_BLK_IPIPE, IP2_INTR_ENABLEr, IP2_INTR_STATUSr,
        _soc_katana2_ip2_parity_info, 0},

    /* MXQ0_TO_CMIC_PERR_INTR */
    { 0x00000080,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 0},
   
    /* MXQ1_TO_CMIC_PERR_INTR */
    { 0x00000100,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 1},
    
    /* MXQ2_TO_CMIC_PERR_INTR */
    { 0x00000200,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 2},
    
    /* MXQ3_TO_CMIC_PERR_INTR */
    { 0x00000400,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 3},
    
    { 0x00000800,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 4},
    
    { 0x00001000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 5},
    
    { 0x00002000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 6},
    
    { 0x00004000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 7},
    
    { 0x00008000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 8},
        
    { 0x00010000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 9},
    
    { 0x00020000,
        SOC_BLK_MXQPORT, XPORT_INTR_ENABLEr, XPORT_INTR_STATUSr,
        _soc_katana2_xport_parity_info, 10},

    { 0x00040000,
        SOC_BLK_RXLP, RXLP_ECC_INTERRUPT_ENABLEr, RXLP_ECC_INTERRUPT_STATUSr,
        _soc_katana2_rxlp_parity_info, 0},

    { 0x00080000,
        SOC_BLK_RXLP, RXLP_ECC_INTERRUPT_ENABLEr, RXLP_ECC_INTERRUPT_STATUSr,
        _soc_katana2_rxlp_parity_info, 1},
    
    { 0x00100000,
        SOC_BLK_TXLP, TXLP_INTR_ENABLEr, TXLP_INTR_STATUSr,
        _soc_katana2_txlp_parity_info, 0},
    
    { 0x00200000,
        SOC_BLK_TXLP, TXLP_INTR_ENABLEr, TXLP_INTR_STATUSr,
        _soc_katana2_txlp_parity_info, 1},

    /* IP3_TO_CMIC_PERR_INTR */
    { 0x00400000,
        SOC_BLK_IPIPE, IP3_INTR_ENABLEr, IP3_INTR_STATUSr,
        _soc_katana2_ip3_parity_info, 0},
    
    /* IP3_TO_CMIC_PERR_INTR */
    { 0x00400000,
        SOC_BLK_IPIPE, IP3_INTR_ENABLE_1r, IP3_INTR_STATUS_1r,
        _soc_katana2_ip3_1_parity_info, 0},
    
    /* IP3_TO_CMIC_PERR_INTR */
    { 0x00400000,
        SOC_BLK_IPIPE, IP3_INTR_ENABLE_2r, IP3_INTR_STATUS_2r,
        _soc_katana2_ip3_2_parity_info, 0},
    /* 0x00000800 PULL_DOWN */

    { 0 } /* table terminator */
};


#define _SOC_KT2_SER_REG 1
#define _SOC_KT2_SER_MEM 0
#define KT2_OAM_INTR_MASK 0xFF
#define KT2_OAM_CMIC_INTR_MASK 0x00000010
#define SB2_OAM_CMIC_INTR_MASK 0x00001000
#define KT2_RXLP_INTR_MASK 0x7FFF

typedef union _kt2_ser_nack_reg_mem_u {
    soc_reg_t reg;
    soc_mem_t mem;
} _kt2_ser_nack_reg_mem_t;

static int _stat_error_fixed[SOC_MAX_NUM_DEVICES];

STATIC int
_soc_katana2_parity_enable_info(int unit, soc_port_t port, 
                                soc_reg_t group_reg,
                                uint32 *group_rval,
                                const _soc_katana2_parity_info_t *info_list,
                                int enable);

void soc_kt2_oam_interrupt_process(int unit);

int
_bcm_kt2_is_pp_port_linkphy_subtag(int unit, int pp_port)
{
    int pp_port_index_min = SOC_INFO(unit).pp_port_index_min;
    int pp_port_index_max = SOC_INFO(unit).pp_port_index_max;
    if (!(soc_feature(unit, soc_feature_linkphy_coe) ||
        soc_feature(unit, soc_feature_subtag_coe))) {
        return FALSE;
    } 
#if defined BCM_METROLITE_SUPPORT
    if (soc_feature(unit, soc_feature_discontinuous_pp_port)) {
        if (_SOC_IS_PP_PORT_LINKPHY_SUBTAG(unit, pp_port)) {
            return TRUE;
        }
    } else
#endif
    {
        if ((pp_port >= pp_port_index_min) &&
                        (pp_port <= pp_port_index_max)) {
            return TRUE;
        }
    }
    return FALSE;
}

STATIC
int _soc_katana2_get_max_stream_ids(int unit) 
{
    int linkphy_pbmp_count = 0;
    int num_of_steams = 2;
    int num_subport = 0;
    soc_pbmp_t  pbmp_linkphy;
    pbmp_linkphy = soc_property_get_pbmp(unit, spn_PBMP_LINKPHY, 0);
    SOC_PBMP_COUNT(pbmp_linkphy, linkphy_pbmp_count);
    num_subport =
        soc_property_port_get(unit, 0, spn_NUM_SUBPORTS, 0);

    return (linkphy_pbmp_count * num_of_steams * num_subport); 
}

STATIC
int _soc_katana2_ci_block_get(int unit, 
                              _soc_katana2_mmu_subblock_type_t sub_block, 
                              soc_block_t* block)
{
    switch(sub_block){
    case _SOC_KT2_MMU_SUBBLOCK_CI5:
    *block = CI5_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI4:
    *block = CI4_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI3:
    *block = CI3_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI2:
    *block = CI2_BLOCK(unit);
        break;
    
    case _SOC_KT2_MMU_SUBBLOCK_CI1:
    *block = CI1_BLOCK(unit);
        break;
        
    case _SOC_KT2_MMU_SUBBLOCK_CI0:
    *block = CI0_BLOCK(unit);
        break;
    
    default:
        break;	
    }
    return SOC_E_NONE;
}

STATIC 
void _soc_katana2_mem_parity_info(int unit, int block_idx, int pipe,
                                  soc_field_t field_enum, uint32 *minfo)
{
    *minfo = (SOC_BLOCK2SCH(unit, block_idx) << SOC_ERROR_BLK_BP)
        | ((pipe & 0xff) << SOC_ERROR_PIPE_BP)
        | (field_enum & SOC_ERROR_FIELD_ENUM_MASK);
}

STATIC
int _soc_katana2_process_sb_mmu_leaf_parity_enable(int unit,
                          soc_port_t port,
                          soc_reg_t leaf_enable_reg,
                          _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info,
                          int enable)
{
    uint32 en_rval;
    int index;
    soc_field_t enable_field;
    _soc_katana2_mmu_sub_block_leaf_info_t * info;
    
    /* leaf_info contains a list of leaf block, each leaf has a bit 
       in leaf_enable_reg */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, leaf_enable_reg, port, 0, 
                                      &en_rval));
    
    for (index = 0; ; index++) {
        info = &leaf_info[index];
        if(info->intr_bit == 0) {
            /* End of leaf table */
            break;
        }
        enable_field = info->enable_field;
        
        if (SOC_REG_FIELD_VALID(unit, leaf_enable_reg, enable_field)) {
            if (enable_field == FLUSH_COMPLETE_DISINTf) {
            continue;
            }
            /* set corresponding field for a leaf block */
            soc_reg_field_set(unit, leaf_enable_reg, &en_rval, enable_field, 
                              enable ? 0 : 1);
        }
    }
    
    /* write back enable register */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, leaf_enable_reg, port, 0, en_rval));
    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_one_level_mmu_parity_enable(int unit, 
                        soc_reg_t mmu_en_reg,
                        _soc_katana2_mmu_sub_block_one_level_t * sub_block_info,
                        int enable)
{
    uint32 en_rval;
    soc_block_t block = SOC_BLOCK_ANY;
    soc_port_t port = REG_PORT_ANY;
    soc_reg_t leaf_enable_reg;
    _soc_katana2_mmu_subblock_type_t sub_block_type;
    _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of one level sub block table */
        return SOC_E_NONE;
    }

    sub_block_type = sub_block_info->mmu_sub_block;
    if ((sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI5)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI4)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI3)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI2)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI1)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI0)){
    	  
    	  if (soc_feature(unit, soc_feature_ddr3)){
    	      _soc_katana2_ci_block_get (unit, sub_block_type, &block);
            port = SOC_BLOCK_PORT(unit, block);
    	  } else {
    	      return SOC_E_NONE;
    	  }
    }
    
    leaf_info = sub_block_info->info;
    
    /* enable for this sub block */
    leaf_enable_reg = sub_block_info->leaf_enable_reg;
    SOC_IF_ERROR_RETURN
        (_soc_katana2_process_sb_mmu_leaf_parity_enable (unit, port, 
                               leaf_enable_reg, leaf_info, enable));
    
    /* set MMU_INTR_MASK */
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, &en_rval));
    soc_reg_field_set(unit, mmu_en_reg, &en_rval, 
                      sub_block_info->mmu_enable_field, enable ? 0 : 1);
    SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, mmu_en_reg, REG_PORT_ANY, 0, en_rval));
    
    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_two_level_mmu_parity_enable(int unit, 
                       soc_reg_t mmu_en_reg,
                       _soc_katana2_mmu_sub_block_two_level_t * sub_block_info,
                       int enable)
{
    uint32 en_rval;
    soc_reg_t internal_enable_reg;
    soc_reg_t leaf_enable_reg;
    soc_field_t internal_enable_field;
    int internal_index;
    soc_port_t port = REG_PORT_ANY;
    _soc_katana2_mmu_sub_block_internal_info_t * internal_info;
    _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of two level sub block table */
        return SOC_E_NONE;
    }
    
    internal_info = sub_block_info->info;
    internal_enable_reg = sub_block_info->internal_enable_reg;
    
    /* get mask register of level 1 sub block */    
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, internal_enable_reg, 
                                      REG_PORT_ANY, 0, &en_rval));
    }

    for (internal_index = 0; ; internal_index++) {
        internal_info = &sub_block_info->info[internal_index];
        if(internal_info->intr_bit == 0) {
            /* End of internal_info table */
            break;
        }

        internal_enable_field = internal_info->internal_enable_field;
        
        if ((internal_enable_reg != 0) && 
        	 (SOC_REG_FIELD_VALID(unit, internal_enable_reg, 
        	                      internal_enable_field))) {
            soc_reg_field_set(unit, internal_enable_reg, &en_rval, 
                              internal_enable_field, enable ? 0 : 1);
        }
        
        /* get mask register of level 2 sub mask */
        leaf_enable_reg = internal_info->leaf_enable_reg;
        leaf_info = internal_info->info;
                                                    
        SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_mmu_leaf_parity_enable (unit, port,
                                   leaf_enable_reg, leaf_info, enable));
    }
    
    /* write back mask register of level 1 sub block */
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, internal_enable_reg, 
                                          REG_PORT_ANY, 0, en_rval));
    }
    
    /* set MMU_INTR_MASK */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, 
                                      &en_rval));
    soc_reg_field_set(unit, mmu_en_reg, &en_rval, 
                      sub_block_info->mmu_enable_field, enable ? 0 : 1);
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_en_reg, REG_PORT_ANY, 0, 
                                      en_rval));
    
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_enable_mmu(int unit, soc_reg_t mmu_en_reg, int enable)
{
    int index;
    uint32 sub_block_num;
    _soc_katana2_mmu_sub_block_one_level_t * sub_block;
    _soc_katana2_mmu_sub_block_two_level_t * two_level_sub_block;

    sub_block_num = SOC_DDR3_NUM_MEMORIES(unit);
                     
    for (index = 0; index < sub_block_num; index++) {
         sub_block = &_soc_katana2_mmu_sub_blocks_type_1[index];
         if ((sub_block->mmu_sub_block == _SOC_KT2_MMU_SUBBLOCK_CI5) ||
             (sub_block->mmu_sub_block == _SOC_KT2_MMU_SUBBLOCK_CI4) ||
             (sub_block->mmu_sub_block == _SOC_KT2_MMU_SUBBLOCK_CI3) ||
             (sub_block->mmu_sub_block == _SOC_KT2_MMU_SUBBLOCK_CI2) ||
             (sub_block->mmu_sub_block == _SOC_KT2_MMU_SUBBLOCK_CI1) ||
             (sub_block->mmu_sub_block == _SOC_KT2_MMU_SUBBLOCK_CI0)) {
             if (!soc_feature(unit, soc_feature_ddr3)) {
                  continue;
             }
         }
         SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_one_level_mmu_parity_enable(unit, 
                                       mmu_en_reg, sub_block, enable));
    }

    sub_block_num = COUNTOF(_soc_katana2_mmu_sub_blocks_type_2);

    for (index = 0; index < sub_block_num; index++) {
        two_level_sub_block = &_soc_katana2_mmu_sub_blocks_type_2[index];
        if (two_level_sub_block->mmu_sub_block == _SOC_KT2_MMU_SUBBLOCK_EMC) {
            if (!soc_feature(unit, soc_feature_ddr3)) {
                 continue;
            }
        }
        SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_two_level_mmu_parity_enable(unit, 
                            mmu_en_reg, two_level_sub_block, enable));	
    }
    return SOC_E_NONE;
}


STATIC int
_soc_katana2_mmu_is_parity_interrupt (int unit, soc_reg_t mmu_status_reg, soc_field_t mmu_status_field)
{
    int retVal = 0;
    if ( (!SOC_REG_IS_VALID(unit, mmu_status_reg) ||
          !soc_reg_field_valid(unit, mmu_status_reg, mmu_status_field)))  {
        return retVal;
    }

    switch(mmu_status_reg) 
    {
        case RDE_SER_STATUSr:
            if ((ECC_1B_BITMAPf == mmu_status_field) || (ECC_2B_BITMAPf == mmu_status_field)) {
                retVal = 1;
            }
            break;
        case CI_ERRORr:
            if ((WFIFO_CTL_CORRECTED_ERRORf == mmu_status_field) || 
                (WFIFO_CTL_UNCORRECTED_ERRORf == mmu_status_field) ||
                (RFIFO_CTL_CORRECTED_ERRORf == mmu_status_field) || 
                (RFIFO_CTL_UNCORRECTED_ERRORf == mmu_status_field)) {
                retVal = 1;
            }
            break;
        case WRED_PARITY_ERROR_BITMAPr:
            if (UPDATE_INTRPT_STATUSf != mmu_status_field) {
                retVal = 1;
            }
            break;
        case CTR_ERRORr:
            if ((CTR_RQE_FIFO_OVERFLOW_ERRORf == mmu_status_field) || 
                (CTR_ENQ_WRAP_ERRORf == mmu_status_field) || 
                (CTR_DEQ_WRAP_ERRORf == mmu_status_field)) {                
                retVal = 0;
            } else {
                retVal = 1;
            }
            break;
        case CCP_ERRORr:
            if ((CCPI_RQE_UPD_NEGATIVEf != mmu_status_field) &&
                (CCPE_RQE_UPD_NEGATIVEf != mmu_status_field)) {
                retVal = 1;
            }
            break;
        case CFAPI_ECC_ERRORr:
            if (DUPLICATE_PTRf != mmu_status_field) {
                retVal = 1;
            }
            break;
        case CFAPE_ECC_ERRORr:
            if (DUPLICATE_PTRf != mmu_status_field) {
                retVal = 1;
            }
            break;
        case RQE_SER_STATUSr:
            if ((ECC_1B_BITMAPf == mmu_status_field) || (ECC_2B_BITMAPf == mmu_status_field)) {
                retVal = 1;
            }
            break;
        case EMC_ERROR_3r:
            if ((EMC_CI0_FIXED_PATTERN_ERRORf == mmu_status_field) || 
                (EMC_CI1_FIXED_PATTERN_ERRORf == mmu_status_field) ||
                (EMC_CI2_FIXED_PATTERN_ERRORf == mmu_status_field) ||
                (EMC_CI3_FIXED_PATTERN_ERRORf == mmu_status_field) ||
                (EMC_CI4_FIXED_PATTERN_ERRORf == mmu_status_field) ||
                (EMC_CI5_FIXED_PATTERN_ERRORf == mmu_status_field)) {
                retVal = 0;
            } else {
                retVal = 1;
            }
            break;
        case QSTRUCT_FAP_MEM_ERRORr:
            if ((FAP_LOADING_ERRORf == mmu_status_field) || 
                (FAP0_DUPLICATE_PTR_ERRORf == mmu_status_field) ||
                (FAP1_DUPLICATE_PTR_ERRORf == mmu_status_field) ||
                (FAP2_DUPLICATE_PTR_ERRORf == mmu_status_field) ||
                (FAP3_DUPLICATE_PTR_ERRORf == mmu_status_field)) {
                retVal = 0;
            } else {
                retVal = 1;
            }
            break;
        case MMU_ITE_CFG_ECC_ERROR_0r:
        case MMU_ENQ_CFG_ECC_ERROR_0r:
        case MMU_ENQ_FAP_ECC_ERROR_0r:
        case THDO_PARITY_ERROR_STATUS1r:
        case THDO_PARITY_ERROR_STATUS2r:
        case LLS_PORT_ECC_ERRORr:
        case LLS_L0_ECC_ERROR1r:
        case LLS_L1_ECC_ERROR1r:
        case LLS_L2_ECC_ERROR1r:
        case LLS_MISC_ECC_ERROR1r:
        case EMC_ERROR_1r:
        case EMC_ERROR_2r:
        case DEQ_ERROR_3r:
        case DEQ_ERROR_4r:
        case QSTRUCT_QENTRY_UPPER_ERRORr:
        case QSTRUCT_QENTRY_LOWER_ERRORr:
        case QSTRUCT_QBLOCK_NEXT_ERRORr:
        case TOQ_ERROR1r:
        case MMU_IPCTR_ECC_ERROR_0r:
        case MMU_ADM_ECC_ERROR_0r:
            retVal = 1;
            break;
        case MMU_E2EFC_ERROR_0r:
        case MMU_THDI_INTRr:
        case MMU_ENQ_ERROR_0r:
        case AGING_ERROR_INTr:
        case AGING_ERROR_EXTr:
        case LLS_ERRORr:
        case LLS_ERROR2r:
        case LLS_ERROR_UPD2r:
        case RQE_EXTQ_REPLICATION_COUNTr:
        case EMC_ERROR_0r:
        case DEQ_ERROR_0r:
        case DEQ_ERROR_1r:
        case DEQ_ERROR_2r:
        case TOQ_ERROR2r:
            retVal = 0;
            break;
        default:
            break;
    }

    return retVal;
}

STATIC
int _soc_katana2_process_sb_mmu_leaf_parity_error (int unit, 
                      _soc_katana2_mmu_subblock_type_t sub_block_type,
                      soc_port_t port,
                      soc_reg_t leaf_enable_reg,
                      soc_reg_t leaf_status_reg,
                      _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info)
{
    uint32 stat_rval, en_rval, minfo;
    uint32 intr_bit;
    int index = 0, block_idx;
    _soc_katana2_mmu_sub_block_leaf_info_t *info;
    char prefix_str[10];
    char *reg_str;
    char *field_str;
    
    sal_sprintf(prefix_str, "unit %d", unit);
    
    /* A _soc_katana2_mmu_sub_block_leaf_info_t object corresponds to
       a list of leaf blocks share the common enable and status register.
       each memory has a bit in enable and status register. usually, the 
       bit position is same, but for in some case, they are not equal.
       in this case, we need to do specical handling. */
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, leaf_status_reg, port, 0, &stat_rval));
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, leaf_enable_reg, port, 0, &en_rval));
    
    if (leaf_status_reg == RQE_EXTQ_REPLICATION_COUNTr) {
        stat_rval &= ((~en_rval) << 11);
    } else {
        stat_rval &= (~en_rval);
    }

    if (stat_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE; 
    }
    SOC_BLOCK_ITER(unit, block_idx, SOC_BLK_MMU) {
        if (SOC_BLOCK_INFO(unit, block_idx).number == 0) {
            break;
        }
    }
    /* We really need handle the parity, because it trigger status register and we 
       do not mask it. Go over all the memories in the list. 
       a _soc_katana2_mmu_sub_block_leaf_info_t corresponds to a memory instance
       its intr_bit specify its bit position in status register */
    for (index = 0; ; index++) {
        info = &leaf_info[index];
        intr_bit = info->intr_bit;
        if(intr_bit == 0) {
            /* reach the end of leaf table */
            return SOC_E_NONE;
        }
        
        /* get a match */
        if (stat_rval & intr_bit) {
             field_str = SOC_FIELD_NAME(unit, info->status_field);
             reg_str = SOC_REG_NAME(unit, leaf_status_reg);
             if(_soc_katana2_mmu_is_parity_interrupt(unit, leaf_status_reg, info->status_field)) {
                 _soc_katana2_mem_parity_info(unit, block_idx, 0,
                                     info->status_field, &minfo);
                 soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                    SOC_SWITCH_EVENT_DATA_ERROR_UNCORRECTABLE,
                                    0, minfo);
                 LOG_ERROR(BSL_LS_SOC_COMMON,
                           (BSL_META_U(unit,
                           "%s MMU subblock %x reg %s field %s(value = 0x%x) has MMU parity error\n"),
                            prefix_str, sub_block_type, reg_str, 
                            field_str, stat_rval));
             } else {
                 LOG_ERROR(BSL_LS_SOC_COMMON,
                           (BSL_META_U(unit,
                           "%s MMU subblock %x reg %s field %s(value = 0x%x) has been set.\n"),
                            prefix_str, sub_block_type, reg_str, 
                            field_str, stat_rval));
             }
             /* clear the parity error bit */
             SOC_IF_ERROR_RETURN
                 (soc_reg32_set(unit, leaf_status_reg, port, 0, intr_bit));
        }
    }
    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_one_level_mmu_parity_error(int unit,
                      _soc_katana2_mmu_sub_block_one_level_t * sub_block_info)
{
    soc_reg_t leaf_enable_reg;
    soc_reg_t leaf_status_reg; 
    _soc_katana2_mmu_subblock_type_t sub_block_type;
    soc_block_t block = SOC_BLOCK_ANY;
    soc_port_t port = REG_PORT_ANY;
    _soc_katana2_mmu_sub_block_leaf_info_t * leaf_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of one level sub block table */
        return SOC_E_NONE;
    }
    sub_block_type = sub_block_info->mmu_sub_block;
    
    if ((sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI5)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI4)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI3)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI2)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI1)||
    	  (sub_block_type == _SOC_KT2_MMU_SUBBLOCK_CI0)){
    	  
    	  if (soc_feature(unit, soc_feature_ddr3)){
    	      _soc_katana2_ci_block_get (unit, sub_block_type, &block);
            port = SOC_BLOCK_PORT(unit, block);
    	  } else {
    	      return SOC_E_NONE;
    	  }
    }
    
    leaf_enable_reg = sub_block_info->leaf_enable_reg;
    leaf_status_reg = sub_block_info->leaf_status_reg;
    leaf_info = sub_block_info->info;

    /* process this sub block */
    SOC_IF_ERROR_RETURN
        (_soc_katana2_process_sb_mmu_leaf_parity_error (unit, sub_block_type,
                         port, leaf_enable_reg, leaf_status_reg, leaf_info));

    return SOC_E_NONE;
}

STATIC
int _soc_katana2_process_sb_two_level_mmu_parity_error(int unit,
                          _soc_katana2_mmu_sub_block_two_level_t * sub_block_info)
{
    uint32 en_rval;
    uint32 status_rval;
    soc_reg_t internal_status_reg;
    soc_reg_t internal_enable_reg;
    int internal_index;
    soc_port_t port = REG_PORT_ANY;
    _soc_katana2_mmu_subblock_type_t sub_block_type;
    _soc_katana2_mmu_sub_block_internal_info_t * internal_info;
    
    if(sub_block_info->mmu_bit == 0) {
        /* reach the end of two level sub block table */
        return SOC_E_NONE;
    }
    sub_block_type = sub_block_info->mmu_sub_block;
    
    /* get status register of level 1 sub block */
    internal_status_reg = sub_block_info->internal_status_reg;
    SOC_IF_ERROR_RETURN
        (soc_reg32_get(unit, internal_status_reg, REG_PORT_ANY, 0, 
                                                       &status_rval));
    /* get mask register of level 1 sub block */
    internal_enable_reg = sub_block_info->internal_enable_reg;
    if (internal_enable_reg != 0) {
        SOC_IF_ERROR_RETURN
            (soc_reg32_get(unit, internal_enable_reg, REG_PORT_ANY, 0, 
                                                               &en_rval));
        /* remove masked */
        status_rval &= (~en_rval);
    }
    
    if (status_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE; 
    }
    
    for (internal_index = 0; ; internal_index++) {
        internal_info = &sub_block_info->info[internal_index];
        
        if(internal_info->intr_bit == 0) {
            break;
        }
        if (status_rval & internal_info->intr_bit){
        /* process this sub block */
        SOC_IF_ERROR_RETURN
            (_soc_katana2_process_sb_mmu_leaf_parity_error (unit, 
            sub_block_type, port, internal_info->leaf_enable_reg,
            internal_info->leaf_status_reg, internal_info->info));
        
        /* clear the parity error bit */
        SOC_IF_ERROR_RETURN
        (soc_reg32_set(unit, internal_status_reg, REG_PORT_ANY, 0, 
                                                  internal_info->intr_bit));
        }
    }
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_mmu(int unit, soc_reg_t mmu_en_reg, 
                               soc_reg_t mmu_stat_reg, char *prefix_str)
{
    uint32 en_rval, stat_rval, mmu_bit;
    int index;
    uint32 sub_block_num;
    _soc_katana2_mmu_sub_block_one_level_t * sub_block;
    _soc_katana2_mmu_sub_block_two_level_t * sub_block_2;

    /* get MMU INTR and MASK */
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_en_reg, REG_PORT_ANY, 0, &en_rval));
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, mmu_stat_reg, REG_PORT_ANY, 0, &stat_rval));
    
    /* remove masked */
    stat_rval &= (~en_rval);
    if (stat_rval == 0) {
        /* How did this interrupt get asserted then??? */
        return SOC_E_NONE;
    }
    
    sub_block_num = COUNTOF(_soc_katana2_mmu_sub_blocks_type_1);
    for (index = 0; index < sub_block_num; index++){
        sub_block = &_soc_katana2_mmu_sub_blocks_type_1[index];
        if(sub_block->mmu_bit == 0) {
            /* End of table */
            break;
        }
        mmu_bit = sub_block->mmu_bit;
        
        if ((sub_block->mmu_bit & (stat_rval)) == 0) {
            /* No interrupts in this sub-block */
            continue;
        }
        
        _soc_katana2_process_sb_one_level_mmu_parity_error(unit, sub_block);
                                      
        /* clear the MMU parity error bit */
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_stat_reg, REG_PORT_ANY, 0, mmu_bit));
    }
    
    sub_block_num = COUNTOF(_soc_katana2_mmu_sub_blocks_type_2);
    for (index = 0; index < sub_block_num; index++) {
        sub_block_2 = &_soc_katana2_mmu_sub_blocks_type_2[index];
        if(sub_block_2->mmu_bit == 0) {
            /* End of table */
            break;
        }
        mmu_bit = sub_block_2->mmu_bit;
        
        if ((mmu_bit & (stat_rval)) == 0) {
            /* No interrupts in this sub-block */
            continue;
        }
        
         _soc_katana2_process_sb_two_level_mmu_parity_error(unit, sub_block_2);
        /* clear the MMU parity error bit */
        SOC_IF_ERROR_RETURN(soc_reg32_set(unit, mmu_stat_reg, REG_PORT_ANY, 0, mmu_bit));
    }
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_enable_info(int unit, soc_port_t port,
                                soc_reg_t group_reg,
                                uint32 *group_rval,
                                const _soc_katana2_parity_info_t *info_list,
                                int enable)
{
    const _soc_katana2_parity_info_t *info;
    int info_index;
    soc_reg_t reg;
    uint32 rval;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Enable the info entry in the group register */
        soc_reg_field_set(unit, group_reg, group_rval,
                          info->group_reg_enable_field, enable ? 1 : 0);

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
        case _SOC_PARITY_TYPE_ECC:
        case _SOC_PARITY_TYPE_HASH:
        case _SOC_PARITY_TYPE_EDATABUF:
        case _SOC_PARITY_TYPE_COUNTER:
            reg = info->enable_reg;
            if (!SOC_REG_IS_VALID(unit, reg)) {
                continue;
            }

            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
            soc_reg_field_set(unit, reg, &rval, info->enable_field,
                              enable ? 1 : 0);
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, rval));
            break;
        case _SOC_PARITY_TYPE_GENERIC:
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the route block */

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_enable_all(int unit, int enable)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index, block_idx;
    soc_port_t port;
    soc_reg_t route_block_en_reg;
    uint32 cmic_rval, route_block_rval;
    uint32 cmic_bit;
    uint32 rval;

    port = REG_PORT_ANY;
    cmic_rval = 0;
    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }
        /* Enable the route block entry in the CMIC register */
        if (enable) {
            cmic_rval |= cmic_bit;
        }

        route_block_en_reg = route_block->enable_reg;
        
        /* Get block and port for MXQ and RXLP and TXLP */
        if ((route_block->blocktype == SOC_BLK_MXQPORT) ||
            (route_block->blocktype == SOC_BLK_TXLP) ||
            (route_block->blocktype == SOC_BLK_RXLP)) {
            SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                    port = SOC_BLOCK_PORT(unit, block_idx);
                    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_en_reg,
                                        port, 0, &route_block_rval));
                    SOC_IF_ERROR_RETURN(_soc_katana2_parity_enable_info(
                                        unit, port, route_block_en_reg,
                                        &route_block_rval, 
                                        route_block->info, enable));
                    /* Write per route block parity enable register */
                    SOC_IF_ERROR_RETURN(soc_reg32_set(
                                        unit, route_block_en_reg, 
                                        port, 0, route_block_rval));
                    break;
                }
            }
        } else if (route_block->blocktype == SOC_BLK_MMU) {
            SOC_IF_ERROR_RETURN(_soc_katana2_parity_enable_mmu(unit, 
                                route_block_en_reg, enable));

        } else {
            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_en_reg,
                                port, 0, &route_block_rval));
            SOC_IF_ERROR_RETURN(_soc_katana2_parity_enable_info(
                                unit, port, route_block_en_reg,
                                &route_block_rval, 
                                route_block->info, enable));
            /* Write per route block parity enable register */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, 
                                port, 0, route_block_rval));
        }
    } /* Loop through each place-and-route block entry */

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_THDO_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, STAT_CLEARf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_STAT_CLRf, 1);
    SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_RQE_GLOBAL_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_STAT_CLRf, 1);
    SOC_IF_ERROR_RETURN(WRITE_RQE_GLOBAL_CONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_CHK_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_GEN_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, MISCCONFIGr, &rval, PARITY_STAT_CLEARf, 0);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_THDO_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, PARITY_CHK_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, PARITY_GEN_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, STAT_CLEARf, 0);
    SOC_IF_ERROR_RETURN(WRITE_THDO_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_CHK_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_GEN_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, PARITY_STAT_CLRf, 0);
    SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_RQE_GLOBAL_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_CHK_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_GEN_ENf, 
            enable ? 1 : 0);
    soc_reg_field_set(unit, RQE_GLOBAL_CONFIGr, &rval, PARITY_STAT_CLRf, 0);
    SOC_IF_ERROR_RETURN(WRITE_RQE_GLOBAL_CONFIGr(unit, rval));

    if (enable)
    {	
        /* Write CMIC enable register */
        (void)soc_cmicm_intr2_enable(unit, cmic_rval);
    } else {
        /* Disabling fully SER,TXLP and RXLP parity for time-being */
        SOC_IF_ERROR_RETURN(WRITE_SER_RANGE_ENABLEr(unit, 0));
        if (SOC_PORT_VALID(unit, 27)) {
            SOC_IF_ERROR_RETURN(WRITE_TXLP_ECC_PARITY_CONTROLr(unit,27, 0));
            SOC_IF_ERROR_RETURN(WRITE_RXLP_ECC_PARITY_CONTROLr(unit,27, 0));
        }	
        if (SOC_PORT_VALID(unit, 28)) {
            SOC_IF_ERROR_RETURN(WRITE_TXLP_ECC_PARITY_CONTROLr(unit,28, 0));
            SOC_IF_ERROR_RETURN(WRITE_RXLP_ECC_PARITY_CONTROLr(unit,28, 0));
        }
        /* Write CMIC disable register */
        (void)soc_cmicm_intr2_disable(unit, cmic_rval);
    }
    return SOC_E_NONE;
}

void
_soc_katana2_mem_rename(soc_mem_t *memory)
{
    soc_mem_t mem = *memory;
    
    switch(*memory) {
    case VLAN_SUBNETm:
        mem = VLAN_SUBNET_DATA_ONLYm;
        break;
    case L2Xm:
        mem = L2_ENTRY_ONLYm;
        break;
    case L3_DEFIPm:
        mem = L3_DEFIP_DATA_ONLYm;
        break;
    case L3_DEFIP_128m:
        mem = L3_DEFIP_128_DATA_ONLYm;
        break;
    case EGR_IP_TUNNEL_IPV6m:
    case EGR_IP_TUNNEL_MPLSm:
        mem = EGR_IP_TUNNELm;
        break;
    case VLAN_MACm:
        mem = VLAN_XLATEm;
        break;
    default:
        /* Do nothing, keep memory as provided */
        break;
    }
    *memory = mem;
}

int
_soc_katana2_mem_parity_control(int unit, soc_mem_t mem, int copyno,
                                int enable)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index;
    uint32 cmic_bit;
    int info_index;
    soc_reg_t reg;
    uint32 rval;
    const _soc_katana2_parity_info_t *info;

    if (!soc_property_get(unit, spn_PARITY_ENABLE, FALSE)) {
        /* Parity checking is not enabled, nothing to do */
        return SOC_E_NONE;
    }

    /* Convert component/aggregate memories to the table for which
     * the parity registers correspond. */
    _soc_katana2_mem_rename(&mem);

    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }

        if (route_block->blocktype == SOC_BLK_MMU) {
            SOC_IF_ERROR_RETURN(_soc_katana2_parity_enable_mmu(unit, 
                                         route_block->enable_reg, enable));
            continue;
        }

        /* Loop through each info entry in the list */
        for (info_index = 0; ; info_index++) {
            info = &route_block->info[info_index];
            if (info->type == _SOC_PARITY_TYPE_NONE) {
                /* End of table */
                break;
            }
            if (mem != INVALIDm && info->mem != mem) {
                continue;
            }

            /* Handle different parity error reporting style */
            switch (info->type) {
            case _SOC_PARITY_TYPE_PARITY:
            case _SOC_PARITY_TYPE_ECC:
            case _SOC_PARITY_TYPE_HASH:
            case _SOC_PARITY_TYPE_EDATABUF:
            case _SOC_PARITY_TYPE_COUNTER:
                reg = info->enable_reg;
                if (!SOC_REG_IS_VALID(unit, reg)) {
                    continue;
                }
                
                SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
                soc_reg_field_set(unit, reg, &rval, info->enable_field,
                                  enable ? 1 : 0);
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, REG_PORT_ANY, 0, rval));
                break;
            case _SOC_PARITY_TYPE_GENERIC:
            default:
                break;
            }
        }
    }

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_info(int unit, soc_port_t port, soc_reg_t reg,
                                 uint32 status,
                                 const _soc_katana2_parity_info_t *info_list,
                                 char *prefix_str, soc_block_t block_type,
                                 int block_idx);

STATIC int
_soc_katana2_parity_ser_correction(int unit, const _soc_katana2_parity_info_t *info,
                                   char *prefix_str, char *mem_str_ptr,
                                   uint32 entry_idx, uint32 multiple,
                                   soc_block_t block_type, int schan)
{
    int rv = SOC_E_NONE;
    _soc_ser_correct_info_t spci = {0};
    
    LOG_ERROR(BSL_LS_SOC_COMMON,
              (BSL_META_U(unit,
                          "%s %s entry %d parity error\n"), prefix_str, 
                          mem_str_ptr, entry_idx));
    if (multiple) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s has multiple parity errors\n"),
                              prefix_str, mem_str_ptr));
    }
    if (info->mem != INVALIDm) {
        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
        if (schan) {
            spci.flags |= SOC_SER_ERR_CPU;
        }
        spci.reg = INVALIDr;
        spci.mem = info->mem;
        spci.blk_type = block_type;
        spci.index = entry_idx;
        rv = soc_ser_correction(unit, &spci);
    } else if (info->reg != INVALIDr) {
        spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
        if (schan) {
            spci.flags |= SOC_SER_ERR_CPU;
        }
        spci.reg = info->reg;
        spci.mem = INVALIDm;
        spci.blk_type = block_type;
        spci.port = entry_idx;
        rv = soc_ser_correction(unit, &spci);
    }
    
    return rv;
}

int
_soc_kt2_mem_index_remap(int unit, soc_mem_t mem, int index)
{
    switch (mem) {
        case L3_DEFIPm:
        case L3_DEFIP_PAIR_128m:    
        case L3_DEFIP_ONLYm:    
        case L3_DEFIP_PAIR_128_ONLYm:
        case L3_DEFIP_DATA_ONLYm:    
        case L3_DEFIP_PAIR_128_DATA_ONLYm:
            return soc_kt2_l3_defip_index_remap(unit, mem, index);
        default:
            return index;
    }
}

STATIC int
_soc_katana2_parity_process_parity(int unit, soc_port_t port,
                                   const _soc_katana2_parity_info_t *info,
                                   int schan, char *prefix_str, char *mem_str, 
                                   soc_block_t block_type, int block_idx)
{
    _soc_katana2_parity_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple, entry_idx, idx, has_error;
    char *mem_str_ptr;
    int rv = SOC_E_NONE;

    if (schan) {
        /* Some table does not have NACK register */
        if (info->nack_status_reg == INVALIDr &&
            info->nack_status_reg_list == NULL) {
            return rv;
        }
        reg_entry[0].reg = info->nack_status_reg;
        reg_entry[0].mem_str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return rv;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_valid(unit, reg, PARITY_ERRf)) {
            if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
                has_error = TRUE;
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
                if (soc_reg_field_valid(unit, reg, ADDRESSf)) {
                    entry_idx = soc_reg_field_get(unit, reg, rval, ADDRESSf);
                } else {
                    entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
                }
                /* Convert physical index to logical index */
                entry_idx = _soc_kt2_mem_index_remap(unit, info->mem, entry_idx);

                _soc_katana2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                   entry_idx, minfo);
                rv = _soc_katana2_parity_ser_correction(unit, info, prefix_str, 
                                                        mem_str_ptr, entry_idx, 
                                                        multiple, block_type,
                                                        schan);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
                /* Clear parity status */
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
            }
        } else if (soc_reg_field_valid(unit, reg, PARITY_ERR_Af)) {
            /* For registers RX_PROT_GROUP_TABLE_DMA_PARITY_STATUS_INTR/NACK
               they have fileds PARITY_ERR_A and PARITY_ERR_B */
            if (soc_reg_field_get(unit, reg, rval, PARITY_ERR_Af)) {
                has_error = TRUE;
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_Af);
                entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDX_Af);
                _soc_katana2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                   entry_idx, minfo);
                rv = _soc_katana2_parity_ser_correction(unit, info, prefix_str, 
                                                        mem_str_ptr, entry_idx, 
                                                        multiple, block_type,
                                                        schan);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
            }
            if (soc_reg_field_get(unit, reg, rval, PARITY_ERR_Bf)) {
                has_error = TRUE;
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERR_Bf);
                entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDX_Bf);
                _soc_katana2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                   SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                   entry_idx, minfo);
                rv = _soc_katana2_parity_ser_correction(unit, info, prefix_str, 
                                                        mem_str_ptr, entry_idx, 
                                                        multiple, block_type,
                                                        schan);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
            }
            if (has_error == TRUE) {    
                /* Clear parity status */
                SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
            }
        } else {
            return rv;
        }
    }
                
    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s parity hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return rv;
} /*_soc_katana_parity_process_parity*/

STATIC int
_soc_katana2_parity_process_ecc(int unit, soc_port_t port,
                                const _soc_katana2_parity_info_t *info,
                                int schan, char *prefix_str, char *mem_str, 
                                soc_block_t block_type, int block_idx)
{
    int rv = SOC_E_NONE;
    _soc_katana2_parity_reg_t reg_entry[2], *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 multiple = 0;
    uint32 double_bit = 0;
    uint32 entry_idx = 0;
    uint32 idx, has_error;
    char *mem_str_ptr;
    _soc_ser_correct_info_t spci = {0};

    if (schan) {
        /* Some table does not have NACK register */
        if (info->nack_status_reg == INVALIDr &&
            info->nack_status_reg_list == NULL) {
            return rv;
        }
        reg_entry[0].reg = info->nack_status_reg;
        reg_entry[0].mem_str = NULL;
        reg_entry[1].reg = INVALIDr;
        reg_ptr = reg_entry;
    } else {
        if (info->intr_status_reg != INVALIDr) {
            reg_entry[0].reg = info->intr_status_reg;
            reg_entry[0].mem_str = NULL;
            reg_entry[1].reg = INVALIDr;
            reg_ptr = reg_entry;
        } else if (info->intr_status_reg_list != NULL) {
            reg_ptr = info->intr_status_reg_list;
        } else {
            return rv;
        }
    }

    has_error = FALSE;
    for (idx = 0; reg_ptr[idx].reg != INVALIDr; idx++) {
        reg = reg_ptr[idx].reg;
        mem_str_ptr = reg_ptr[idx].mem_str != NULL ?
            reg_ptr[idx].mem_str : mem_str;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

        if (soc_reg_field_get(unit, reg, rval, ECC_ERRf)) {
            has_error = TRUE;
            if (SOC_REG_FIELD_VALID(unit, reg, MULTIPLE_ERRf)) {
                multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
            } else if (SOC_REG_FIELD_VALID(unit, reg, ECC_ERR_MULTIf)) {
                multiple = soc_reg_field_get(unit, reg, rval, ECC_ERR_MULTIf);
            }    
            if (SOC_REG_FIELD_VALID(unit, reg, DOUBLE_BIT_ERRf)) {
                double_bit = soc_reg_field_get(unit, reg, rval, DOUBLE_BIT_ERRf);
            } else if (SOC_REG_FIELD_VALID(unit, reg, ECC_ERR_2Bf)) {
                double_bit = soc_reg_field_get(unit, reg, rval, ECC_ERR_2Bf);
            }    
            if (SOC_REG_FIELD_VALID(unit, reg, ENTRY_IDXf)) {
                entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);
            }
            if (double_bit) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d double-bit ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
                spci.double_bit = 1;
            } else if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple ECC errors\n"),
                           prefix_str, mem_str_ptr));
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s entry %d ECC error\n"),
                           prefix_str, mem_str_ptr, entry_idx));
            }
            _soc_katana2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_ECC, 
                               entry_idx, minfo);
            if (info->mem != INVALIDm) {
                spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                if (schan) {
                    spci.flags |= SOC_SER_ERR_CPU;
                }
                spci.reg = INVALIDr;
                spci.mem = info->mem; 
                spci.blk_type = block_type;
                spci.index = entry_idx;
                spci.parity_type = SOC_PARITY_TYPE_ECC;
                rv = soc_ser_correction(unit, &spci);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
        }

    }

    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return rv;
}

int
_soc_katana2_l3_entry_idx_map(soc_mem_t mem, int entry_idx) 
{
    int new_id = entry_idx;
    
    switch (mem) {
        case L3_ENTRY_IPV6_UNICASTm:
        case L3_ENTRY_IPV4_MULTICASTm:
            new_id = entry_idx/2;
            break;
        case L3_ENTRY_IPV6_MULTICASTm:
            new_id = entry_idx/4;
            break;
        default:
            break;
    }
    return new_id;
}

STATIC int
_soc_katana2_parity_process_hash(int unit, soc_port_t port,
                                 const _soc_katana2_parity_info_t *info,
                                 int schan, char *prefix_str, char *mem_str,
                                 soc_block_t block_type, int block_idx)
{
    int rv = SOC_E_NONE;
    _soc_katana2_parity_reg_t *reg_ptr;
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 bitmap, multiple, bucket_idx;
    int bucket_size, entry_idx = -1, idx, bank_bkt_idx, bits, has_error;
    _soc_ser_correct_info_t spci = {0};
    soc_field_t efield = PARITY_ERR_BMf;
    soc_field_t bfield = BUCKET_IDXf;
    soc_field_t mfield = MULTIPLE_ERRf;

    if (schan) {
        reg_ptr = info->nack_status_reg_list;
    } else {
        reg_ptr = info->intr_status_reg_list;
    }

    has_error = FALSE;
    for (idx = 0; idx < 2; idx ++) {
        reg = reg_ptr[idx].reg;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));
        /* Some memories have this field named differently */
        if (soc_reg_field_valid(unit, reg, PARITY_ERR_BMf)) {
            efield = PARITY_ERR_BMf;
            bfield = BUCKET_IDXf;
            mfield = MULTIPLE_ERRf;
        } else if (soc_reg_field_valid(unit, reg, PARITY_ERR_BM_0f)) {
            efield = PARITY_ERR_BM_0f;
            bfield = BUCKET_IDX_0f;
            mfield = MULTIPLE_ERR_0f;
        } else if (soc_reg_field_valid(unit, reg, PARITY_ERR_BM_1f)) {
            efield = PARITY_ERR_BM_1f;
            bfield = BUCKET_IDX_1f;
            mfield = MULTIPLE_ERR_1f;
        }        

        bitmap = soc_reg_field_get(unit, reg, rval, efield);
        if (bitmap != 0) {
            has_error = TRUE;
            multiple = soc_reg_field_get(unit, reg, rval, mfield);
            bucket_size = soc_reg_field_length(unit, reg, efield);
            bucket_idx = soc_reg_field_get(unit, reg, rval, bfield) * 
                bucket_size * 2;
            bank_bkt_idx = idx * bucket_size + bucket_idx;
            for (bits = 0; bits < bucket_size; bits++) {
                if (bitmap & (1 << bits)) {
                    entry_idx = bank_bkt_idx + bits;
                    entry_idx = _soc_katana2_l3_entry_idx_map(info->mem, entry_idx);
                    _soc_katana2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                                       SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                                       entry_idx, minfo);
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s %s entry %d parity error\n"),
                                          prefix_str, mem_str, entry_idx));
                    if ((info->mem != INVALIDm) && (entry_idx != -1)) {
                        spci.flags = SOC_SER_SRC_MEM | SOC_SER_REG_MEM_KNOWN;
                        if (schan) {
                            spci.flags |= SOC_SER_ERR_CPU;
                        }
                        spci.reg = INVALIDr;
                        spci.mem = info->mem == L2_ENTRY_ONLYm ? L2Xm : info->mem;
                        spci.blk_type = block_type;
                        spci.index = entry_idx;
                        rv = soc_ser_correction(unit, &spci);
                        if (SOC_FAILURE(rv)) {
                            soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                                SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                                entry_idx, minfo);
                        }
                    }
                }
            }
            if (multiple) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s has multiple parity errors\n"),
                           prefix_str, mem_str));
            }
            /* Clear parity status */
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));
        }
    }

    if (!has_error) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s parity hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    return rv;
}

STATIC int
_soc_katana2_parity_process_edatabuf(int unit, soc_port_t port,
                                     const _soc_katana2_parity_info_t *info,
                                     int schan, char *prefix_str,
                                     char *mem_str, int block_idx)
{
    soc_reg_t reg;
    uint32 rval, minfo;
    uint32 double_bit, multiple;

    if (schan) {
        /* Some table may not have NACK status register */
        if (info->nack_status_reg == INVALIDr) {
            return SOC_E_NONE;
        }
        reg = info->nack_status_reg;
    } else {
        reg = info->intr_status_reg;
    }
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

    if (soc_reg_field_get(unit, reg, rval, ECC_ERR_MGRPf)) {
        double_bit = soc_reg_field_get(unit, reg, rval, ECC_ERR_2B_MGRPf);
        multiple = soc_reg_field_get(unit, reg, rval, ECC_MULTI_MGRPf);
        _soc_katana2_mem_parity_info(unit, block_idx, 0,
                             info->group_reg_status_field, &minfo);
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                           SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 0, 
                           minfo);
        if (double_bit) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s double-bit ECC error\n"),
                       prefix_str, mem_str));
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s ECC error\n"),
                       prefix_str, mem_str));
        }
        if (multiple) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s has multiple ECC errors\n"),
                       prefix_str, mem_str));
        }
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s ECC hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_counter(int unit, soc_port_t port,
                                    const _soc_katana2_parity_info_t *info,
                                    int schan, char *prefix_str, char *mem_str,
                                    soc_block_t block_type, int block_idx)
{
    int rv = SOC_E_NONE;
    soc_cmap_t *cmap = NULL;
    soc_reg_t reg, counter_reg;
    uint32 rval, minfo;
    uint32 multiple, counter_idx, port_idx, entry_idx;
    char *counter_name;
    _soc_ser_correct_info_t spci = {0};

    if (schan) {
        reg = info->nack_status_reg;
    } else {
        reg = info->intr_status_reg;
    }
    
    SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, port, 0, &rval));

    if (soc_reg_field_get(unit, reg, rval, PARITY_ERRf)) {
        multiple = soc_reg_field_get(unit, reg, rval, MULTIPLE_ERRf);
        counter_idx = soc_reg_field_get(unit, reg, rval, COUNTER_IDXf);
        port_idx = soc_reg_field_get(unit, reg, rval, PORT_IDXf);
        entry_idx = soc_reg_field_get(unit, reg, rval, ENTRY_IDXf);

        /* TDBGC starts at index 0x1A of counter DMA table */
        if (info->group_reg_status_field == EGR_STATS_COUNTER_TABLE_PAR_ERRf) {
            counter_idx += 0x1A;
        }
        cmap = soc_port_cmap_get(unit, port_idx);
        
        if (cmap != NULL) {
            counter_reg = cmap->cmap_base[counter_idx].reg;
            if (SOC_REG_IS_VALID(unit, counter_reg)) {
                _soc_katana2_mem_parity_info(unit, block_idx, 0,
                                 info->group_reg_status_field, &minfo);
                soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR, 
                               SOC_SWITCH_EVENT_DATA_ERROR_PARITY, 
                               entry_idx, minfo);
                counter_name = SOC_REG_NAME(unit, counter_reg);
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s port %d %s entry %d parity error\n"),
                           prefix_str, mem_str, port_idx, counter_name,
                           entry_idx));
                if (multiple) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%s %s has multiple parity errors\n"),
                               prefix_str, mem_str));
                }
                spci.flags = SOC_SER_SRC_REG | SOC_SER_REG_MEM_KNOWN;
                if (schan) {
                    spci.flags |= SOC_SER_ERR_CPU;
                }
                spci.reg = counter_reg;
                spci.mem = INVALIDm;
                spci.blk_type = block_type;
                spci.port = port_idx;
                rv = soc_ser_correction(unit, &spci);
                if (SOC_FAILURE(rv)) {
                    soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                        SOC_SWITCH_EVENT_DATA_ERROR_FAILEDTOCORRECT,
                        entry_idx, minfo);
                }
                _stat_error_fixed[unit]++;
            } else {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "%s %s parity hardware inconsistency\n"),
                           prefix_str, mem_str));
            }
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "cmap is NULL\n")));
        }
    } else if (!schan) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "%s %s parity hardware inconsistency\n"),
                   prefix_str, mem_str));
    }

    /* Clear parity status */
    SOC_IF_ERROR_RETURN(soc_reg32_set(unit, reg, port, 0, 0));

    return rv;
}

STATIC int
_soc_katana2_parity_process_info(int unit, soc_port_t port,
                                 soc_reg_t group_reg,
                                 uint32 group_rval,
                                 const _soc_katana2_parity_info_t *info_list,
                                 char *prefix_str,
                                 soc_block_t block_type,
                                 int block_idx)
{
    const _soc_katana2_parity_info_t *info;
    int info_index;
    char *mem_str;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }

        /* Check status for the info entry in the group register */
        if (!soc_reg_field_get(unit, group_reg, group_rval,
                               info->group_reg_status_field)) {
            continue;
        }

        if (info->mem_str) {
            mem_str = info->mem_str;
        } else if (info->mem != INVALIDm) {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        } else {
            mem_str = SOC_FIELD_NAME(unit, info->group_reg_status_field);
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_GENERIC:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%s %s asserted\n"), prefix_str, mem_str));
            break;
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_parity(unit, port, info, FALSE,
                                                    prefix_str, mem_str, 
                                                    block_type, block_idx));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_ecc(unit, port, info, FALSE,
                                                 prefix_str, mem_str, 
                                                 block_type, block_idx));
            break;
        case _SOC_PARITY_TYPE_HASH:
            /* PARITY_ERR_BMf, MULTIPLE_ERRf, BUCKET_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_hash(unit, port, info, FALSE,
                                                  prefix_str, mem_str, 
                                                  block_type, block_idx));
            break;
        case _SOC_PARITY_TYPE_EDATABUF:
            /* ECC_ERR_MGRPf, ECC_ERR_2B_MGRPf, ECC_MULTI_MGRPf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_edatabuf(unit, port, info, FALSE,
                                                      prefix_str, mem_str,
                                                      block_idx));
            break;
        case _SOC_PARITY_TYPE_COUNTER:
            /* PARITY_ERRf, MULTIPLE_ERRf, COUNTER_IDXf, PORT_IDX,
               ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_counter(unit, port, info, FALSE,
                                                     prefix_str, mem_str, 
                                                     block_type, block_idx));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_parity_process_all(int unit)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index, block_idx;
    soc_port_t port;
    soc_reg_t route_block_en_reg, route_block_reg;
    uint32 cmic_rval, route_block_rval, rval = 0;
    uint32 route_block_enable;
    uint32 cmic_bit;
    char prefix_str[10];
    soc_info_t *si = &SOC_INFO(unit);
    
    port = REG_PORT_ANY;
    sal_sprintf(prefix_str, "unit %d", unit);

    /* Read CMIC parity status register */
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN
        (READ_CMIC_CMC0_IRQ_STAT2r(unit, &cmic_rval));
    if (cmic_rval == 0) {
        return SOC_E_NONE;
    }

    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }

        /* Check status for the route block in the CMIC register */
        if (!(cmic_rval & cmic_bit)) {
            /* No interrupt bit asserted for the route block */
            continue;
        }

        /* get block and port for MXQ and RXLP and TXLP */
        if ((route_block->blocktype == SOC_BLK_MXQPORT) ||
            (route_block->blocktype == SOC_BLK_TXLP) ||
            (route_block->blocktype == SOC_BLK_RXLP)) {
            SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                    port = SOC_BLOCK_PORT(unit, block_idx);
                    break;
                }
            }
        } else {
            SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
                if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                    break;
                }
            }
        }

        /* Read per route block parity status register */
        route_block_reg = route_block->status_reg;
        route_block_en_reg = route_block->enable_reg;
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_reg, port, 0, 
                                          &route_block_rval));
        if (route_block_rval == 0) {
            continue;
        }
        if (route_block->blocktype == SOC_BLK_MMU) {
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_mmu(unit, route_block_en_reg, 
                                                 route_block_reg, prefix_str));
        } else {

            SOC_IF_ERROR_RETURN(soc_reg32_get(unit, route_block_en_reg, port, 0,
                                              &route_block_enable));
            route_block_rval &= route_block_enable;
            route_block_enable &= ~route_block_rval;
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, port, 0,
                                              route_block_enable));

            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_info(unit, port, route_block_reg,
                                                  route_block_rval,
                                                  route_block->info,
                                                  prefix_str,
                                                  route_block->blocktype,
                                                  block_idx));

            route_block_enable |= route_block_rval;
            SOC_IF_ERROR_RETURN(soc_reg32_set(unit, route_block_en_reg, port, 0, 
                                              route_block_enable));
        }
    } /* Loop through each place-and-route block entry */

    /* Handle LINK-PHY interrupt */
    SOC_PBMP_ITER(si->linkphy_pbm, port) {
        if (SOC_REG_PORT_VALID(unit, RXLP_INTERRUPT_STATUSr, port)) {

            if (READ_RXLP_INTERRUPT_STATUSr(unit, port, &rval)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "unit %d: Error reading %s reg !!\n"),
                         unit, SOC_REG_NAME(unit, RXLP_INTERRUPT_STATUSr)));
                return SOC_E_INTERNAL;
            }
            if (rval & KT2_RXLP_INTR_MASK) {
                /* Call Linkphy interrupt handler */
                soc_kt2_rxlp_interrupt_process(unit, port, rval);
            }
        }
    }

    rval = 0;

    /* Handle OAM interrupt */
    if (READ_IP1_INTR_STATUS_1r(unit, &rval)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error reading %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP1_INTR_STATUS_1r)));
        return SOC_E_INTERNAL;
    }
    if (rval & KT2_OAM_INTR_MASK) {
       /* Call OAM interrupt handler */
        soc_kt2_oam_interrupt_process(unit);
    }

    return SOC_E_NONE;
}

void
soc_katana2_parity_error(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);

    (void)_soc_katana2_parity_process_all(unit);
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr2_enable(unit, PTR_TO_INT(d2));
    }
}

void
soc_katana2_oam_event_process(void *unit_vp, void *d1, void *d2, void *d3, void *d4)
{
    int unit = PTR_TO_INT(unit_vp);
    uint32 rval;
    /* Handle OAM interrupt */
    if (READ_IP1_INTR_STATUS_1r(unit, &rval) == SOC_E_NONE) {
        if (rval & KT2_OAM_INTR_MASK) {
            /* Call OAM interrupt handler */
            soc_kt2_oam_interrupt_process(unit);
        }
    } else {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error reading %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP1_INTR_STATUS_1r)));
    }
    sal_usleep(SAL_BOOT_QUICKTURN ? 100000 : 1000); /* Don't reenable too soon */
    if (d2 != NULL) {
        (void)soc_cmicm_intr2_enable(unit, PTR_TO_INT(d2));
    }
}

STATIC int
_soc_katana2_mem_nack_process_info(int unit, int reg_mem,
                                   _kt2_ser_nack_reg_mem_t nack_reg_mem,
                                   const _soc_katana2_parity_info_t *info_list,
                                   char *prefix_str, soc_block_t block_type, 
                                   int block_idx)
{
    const _soc_katana2_parity_info_t *info;
    int info_index;
    char *mem_str;
    soc_port_t port = REG_PORT_ANY;

    /* Loop through each info entry in the list */
    for (info_index = 0; ; info_index++) {
        info = &info_list[info_index];
        if (info->type == _SOC_PARITY_TYPE_NONE) {
            /* End of table */
            break;
        }
        if (reg_mem == _SOC_KT2_SER_MEM && info->mem != nack_reg_mem.mem) {
            continue;
        }
        if (info->mem_str) {
            mem_str = info->mem_str;
        } else {
            mem_str = SOC_MEM_NAME(unit, info->mem);
        }

        if (reg_mem == _SOC_KT2_SER_REG && info->reg != nack_reg_mem.reg) {
            continue;
        }

        /* Handle different parity error reporting style */
        switch (info->type) {
        case _SOC_PARITY_TYPE_PARITY:
            /* PARITY_ERRf, MULTIPLE_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_parity(unit, port, info, TRUE,
                                                    prefix_str, mem_str, block_type,
                                                    block_idx));
            break;
        case _SOC_PARITY_TYPE_ECC:
            /* ECC_ERRf, MULTIPLE_ERRf, DOUBLE_BIT_ERRf, ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_ecc(unit, port, info, TRUE,
                                                 prefix_str, mem_str, block_type,
                                                 block_idx));
            break;
        case _SOC_PARITY_TYPE_HASH:
            /* PARITY_ERR_BMf, MULTIPLE_ERRf, BUCKET_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_hash(unit, port, info, TRUE,
                                                  prefix_str, mem_str, block_type,
                                                  block_idx));
            break;
        case _SOC_PARITY_TYPE_EDATABUF:
            /* ECC_ERR_MGRPf, ECC_ERR_2B_MGRPf, ECC_MULTI_MGRPf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_edatabuf(unit, port, info, TRUE,
                                                      prefix_str, mem_str,
                                                      block_idx));
            break;
        case _SOC_PARITY_TYPE_COUNTER:
            /* PARITY_ERRf, MULTIPLE_ERRf, COUNTER_IDXf, PORT_IDX,
               ENTRY_IDXf */
            SOC_IF_ERROR_RETURN
                (_soc_katana2_parity_process_counter(unit, port, info, TRUE,
                                                     prefix_str, mem_str, block_type,
                                                     block_idx));
            break;
        default:
            break;
        } /* Handle different parity error reporting style */
    } /* Loop through each info entry in the list */

    return SOC_E_NONE;
}


STATIC int
_soc_katana2_mem_nack_error_process(int unit, 
                                   _kt2_ser_nack_reg_mem_t nack_reg_mem,  
                                   int reg_mem)
{
    const _soc_katana2_parity_route_block_t *route_block;
    int route_block_index, block_idx;
    uint32 cmic_bit;
    char prefix_str[10];

    sal_sprintf(prefix_str, "unit %d", unit);

    /* Loop through each place-and-route block entry */
    for (route_block_index = 0; ; route_block_index++) {
        route_block = &_soc_katana2_parity_route_blocks[route_block_index];
        cmic_bit = route_block->cmic_bit;
        if (cmic_bit == 0) {
            /* End of table */
            break;
        }

        if (route_block->info == NULL) {
            continue;
        }
        SOC_BLOCK_ITER(unit, block_idx, route_block->blocktype) {
            if (SOC_BLOCK_INFO(unit, block_idx).number == route_block->id) {
                break;
            }
        }
        SOC_IF_ERROR_RETURN
            (_soc_katana2_mem_nack_process_info(unit, 
                                                reg_mem, nack_reg_mem,
                                                route_block->info,
                                                prefix_str, route_block->blocktype,
                                                block_idx));
    } /* Loop through each place-and-route block entry */

    return SOC_E_NONE;
}

void
soc_katana2_stat_nack(int unit, int *fixed)
{
    int rv;
    _kt2_ser_nack_reg_mem_t nack_reg_mem;

    nack_reg_mem.mem = INVALIDm;
    nack_reg_mem.reg = INVALIDr;
    _stat_error_fixed[unit] = 0;

    if ((rv = _soc_katana2_mem_nack_error_process(unit, nack_reg_mem, 
        _SOC_KT2_SER_REG)) < 0) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d STAT SCHAN NACK analysis failure.\n"), unit));
    }
    *fixed = _stat_error_fixed[unit];
}

void
soc_katana2_mem_nack(void *unit_vp, void *addr_vp, void *blk_vp, 
                     void *d3, void *d4)
{
    soc_mem_t mem = INVALIDm;
    int reg_mem = PTR_TO_INT(d3);
    int rv, unit = PTR_TO_INT(unit_vp);
    uint32 address = PTR_TO_INT(addr_vp);
    uint32 block = PTR_TO_INT(blk_vp);
    uint32 offset = 0, min_addr = 0, max_addr = 0;
    soc_regaddrinfo_t ainfo;
    _kt2_ser_nack_reg_mem_t nack_reg_mem;
    nack_reg_mem.mem = INVALIDm;
    nack_reg_mem.reg = INVALIDr;

    if (reg_mem == _SOC_KT2_SER_REG) {
        if (address) {
            soc_regaddrinfo_get(unit, &ainfo, address);
            nack_reg_mem.reg = ainfo.reg;
        }
    } else {
        offset = address & ~0xC0f00000; /* Strip block ID */
        mem = soc_addr_to_mem_extended(unit, block, 0, address);
        if (mem == INVALIDm) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d mem decode failed, "
                                  "SCHAN NACK analysis failure\n"), unit));
            return;
        }
        
        _soc_katana2_mem_rename(&mem);
       
       /* If reading a 'L3_TUNNEL_DATA_ONLY' entry has parity error,
        * 'L3_TUNNEL_PARITY_STATUS_NACK' will not report correct information
        * <PARITY_ERR=0,MULTIPLE_ERR=0,ENTRY_IDX=0> and SBUS NACK can reply to cpu. 
        * If read this entry with 'L3_TUNNEL" view, 'L3_TUNNEL_PARITY_STATUS_NACK' can
        * report correct value. So create test data with 'L3_TUNNEL' for tr 144.
        * In nack processing, rename 'L3_TUNNEL' to 'L3_TUNNEL_DATA_ONLY' for get 
        * correct ser control information in _soc_katana2_ip0_parity_info.
        */
        if (mem == L3_TUNNELm) {
            mem = L3_TUNNEL_DATA_ONLYm;
        }
       
        nack_reg_mem.mem = mem;

        min_addr = max_addr = SOC_MEM_INFO(unit, mem).base;
        min_addr += SOC_MEM_INFO(unit, mem).index_min;
        max_addr += SOC_MEM_INFO(unit, mem).index_max;
    }

    if ((rv = _soc_katana2_mem_nack_error_process(unit, nack_reg_mem,
        reg_mem)) < 0) {
        if (reg_mem == _SOC_KT2_SER_REG) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d REG SCHAN NACK analysis failure\n"),
                       unit));
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d %s entry %d SCHAN NACK analysis failure\n"),
                       unit, SOC_MEM_NAME(unit, mem),
                       min_addr - offset));
        }
    }
    
    if (reg_mem == _SOC_KT2_SER_REG) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "unit %d REG SCHAN NACK analysis\n"),
                       unit));
    } else {
        LOG_INFO(BSL_LS_SOC_SCHAN,
                 (BSL_META_U(unit,
                             "unit %d %s entry %d SCHAN NACK analysis\n"),
                  unit, SOC_MEM_NAME(unit, mem),
                  min_addr - offset));
    }
}

/* SER processing for TCAMs */
STATIC _soc_generic_ser_info_t _soc_kt2_tcam_ser_info_template[] = {
    
    { MY_STATION_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 80}, {1, 80}, {81, 160}, {82, 160} }, 0, 0, 0, 0, 
      _SOC_SER_FLAG_XY_READ },
    { L2_USER_ENTRYm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 61}, {1, 61}, {62, 122}, {63, 122} }, 0, 0, 0, 0, 
      _SOC_SER_FLAG_XY_READ },
    { VLAN_SUBNETm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { L3_DEFIPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 95}, {1, 95}, {96, 189}, {97, 189} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ | _SOC_SER_FLAG_SIZE_VERIFY |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ},
    { L3_DEFIP_PAIR_128m, INVALIDm, _SOC_SER_TYPE_PARITY,
      _SOC_SER_PARITY_8BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 95}, {96, 189}, {190, 285}, {286, 379} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ |
      _SOC_SER_FLAG_NO_DMA | _SOC_SER_FLAG_REMAP_READ  |
      _SOC_SER_FLAG_SIZE_VERIFY},
    { CPU_COS_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 140}, {1, 140}, {141, 280}, {142, 280} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { EFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { FP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_1BIT,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { VFP_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_MOD2, 
      { {0, 235}, {1, 235}, {236, 469}, {237, 469} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { FP_UDF_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 69}, {1, 69}, {70, 138}, {71, 160} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { SUBPORT_TAG_TO_PP_PORT_MAPm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 64}, {1, 64}, {65, 128}, {66, 128} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { L3_TUNNELm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 106}, {1, 106}, {107, 212}, {108, 212} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { FP_GLOBAL_MASK_TCAMm, INVALIDm, _SOC_SER_TYPE_PARITY, _SOC_SER_PARITY_4BITS,
      _SOC_SER_INTERLEAVE_NONE,
      { {0, 197}, {1, 197}, {198, 393}, {199, 393} }, 0, 0, 0, 0,
      _SOC_SER_FLAG_XY_READ },
    { INVALIDm },
};

#define SOC_KT2_SER_MEM_AVAILABLE (4096 * 32)  /* bits */
static _soc_generic_ser_info_t *_soc_kt2_tcam_ser_info[SOC_MAX_NUM_DEVICES];

#if defined (SER_TR_TEST_SUPPORT)
soc_ser_test_functions_t ser_katana2_test_fun;
#endif

STATIC int
_soc_katana2_ser_init(int unit)
{
    int alloc_size;
    
    /* First, make per-unit copy of the master TCAM list */
    alloc_size = sizeof(_soc_kt2_tcam_ser_info_template);
    if (NULL == _soc_kt2_tcam_ser_info[unit]) {
        if ((_soc_kt2_tcam_ser_info[unit] =
             sal_alloc(alloc_size, "kt2 tcam list")) == NULL) {
            return SOC_E_MEMORY;
        }
    }
    /* Make a fresh copy of the TCAM template info */
    sal_memcpy(_soc_kt2_tcam_ser_info[unit],
               &(_soc_kt2_tcam_ser_info_template),
               alloc_size);
    return soc_generic_ser_init(unit, _soc_kt2_tcam_ser_info[unit]);
}

void
soc_kt2_ser_fail(int unit)
{
    soc_generic_ser_process_error(unit, _soc_kt2_tcam_ser_info[unit],
                                       _SOC_PARITY_TYPE_SER);
    return;
}

STATIC int
_soc_katana2_parity_block_port(int unit, soc_block_t block, soc_port_t *port)
{
    *port = SOC_BLOCK_PORT(unit, block);
    if ((*port != REG_PORT_ANY) && !SOC_PORT_VALID(unit, *port)) {
        return SOC_E_PORT;
    }

    return SOC_E_NONE;
}

int
_soc_katana2_mem_nack_error_test(int unit, _soc_ser_test_t test_type, int *testErrors)
{
    int group, table, rv;
    _soc_katana2_parity_info_t *info;
    soc_mem_t mem;
    soc_port_t block_port = 0;
    soc_block_t blk;
    uint32 test_count = 0;
    ser_test_data_t test_data;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];

    /* loop through each group */
    for (group = 0; _soc_katana2_parity_route_blocks[group].cmic_bit; group++) {
        info = _soc_katana2_parity_route_blocks[group].info;
        
        if (_soc_katana2_parity_route_blocks[group].blocktype == SOC_BLK_MMU) {
            continue;
        } else {
            SOC_BLOCK_ITER(unit, blk,_soc_katana2_parity_route_blocks[group].blocktype) {
                if (_soc_katana2_parity_block_port(unit, blk, &block_port) < 0) {
                    continue;
                }
                
                for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                    mem = info[table].mem;
                    if (mem == INVALIDm) {
                        continue;
                    }
                    if (SOC_MEM_INFO(unit, mem).flags & SOC_MEM_FLAG_SER_SPECIAL) {
                        continue;
                    }

                    if ((info[table].enable_reg == INVALIDr) ||
                        !soc_reg_field_valid(unit, info[table].enable_reg,
                                             info[table].enable_field)) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "unit %d %s has no parity toggle\n"),
                                   unit, SOC_MEM_NAME(unit, mem)));
                        continue;
                    }
                    switch (info[table].type) {
                        case _SOC_PARITY_TYPE_PARITY:
                        case _SOC_PARITY_TYPE_COUNTER:
                        break;
                        
                        default:
                        /* No field to check. */
                        continue;
                    }
                    test_count++;
                    LOG_CLI((BSL_META_U(unit,
                                        " nack test mem: %s); %d\n"),
                             SOC_MEM_NAME(unit, mem), mem));
                    /* If reading a 'L3_TUNNEL_DATA_ONLY' entry has parity error,
                     * 'L3_TUNNEL_PARITY_STATUS_NACK' canot report correct information
                     * <PARITY_ERR=0,MULTIPLE_ERR=0,ENTRY_IDX=0> and SBUS NACK 
                     * can reply to cpu. If read this entry with 'L3_TUNNEL" view, 
                     * 'L3_TUNNEL_PARITY_STATUS_NACK' can report correct value. 
                     * So create test data with 'L3_TUNNEL' for tr 144.
                     */
                    if (mem == L3_TUNNEL_DATA_ONLYm) {
                        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                                 info[table].enable_reg,
                                                 SOC_INVALID_TCAM_PARITY_BIT,
                                                 info[table].enable_field,
                                                 L3_TUNNELm, EVEN_PARITYf,
                                                 MEM_BLOCK_ANY,
                                                 REG_PORT_ANY,
                                                 _SOC_ACC_TYPE_PIPE_ANY, 0,
                                                 &test_data);
                    } else {
                        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                                 info[table].enable_reg,
                                                 SOC_INVALID_TCAM_PARITY_BIT,
                                                 info[table].enable_field,
                                                 mem, INVALIDf,
                                                 MEM_BLOCK_ANY,
                                                 block_port,
                                                 _SOC_ACC_TYPE_PIPE_ANY, 0,
                                                 &test_data);
                    }

                    rv = ser_test_mem(unit, 0, &test_data, test_type, 
                                      testErrors);
 
                    if (rv != SOC_E_NONE) {
                        LOG_CLI((BSL_META_U(unit,
                                            "Error during H/W test.  Aborting.\n")));
                        return rv;
                    }
                }
            }
        }
    }
    LOG_CLI((BSL_META_U(unit,
                        "Hardware SER memories tested: %u\n"),test_count));
    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_katana2_ser_mem_test
 * Purpose:
 *      Performs a SER test on a single TR2 memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 */
int soc_katana2_ser_mem_test(int unit, soc_mem_t mem, _soc_ser_test_t test_type, 
                             int cmd) 
{
    int group, table, i, rv;
    _soc_katana2_parity_info_t *info;
    soc_mem_t memTable;
    soc_port_t block_port=0;
    soc_block_t blk;
    int testErrors = 0;
    ser_test_data_t test_data;
    soc_field_t test_field;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], field_data[SOC_MAX_MEM_FIELD_WORDS];
    /*Prevent compiler error for common function signature.*/
    (void) cmd;
    sal_memset(&test_data, 0, sizeof(test_data));
    _soc_katana2_mem_rename(&mem);
    /*TCAM_test*/
    if (_soc_kt2_tcam_ser_info[unit] != NULL) {
        for (i = 0; _soc_kt2_tcam_ser_info[unit][i].mem != INVALIDm; i++) {
            if (_soc_kt2_tcam_ser_info[unit][i].mem == mem) {
                if (mem == L3_DEFIPm) {
                    test_field = VALID0f;
                } else if (mem == L3_DEFIP_PAIR_128m) {
                    test_field = VALID0_LWRf;
                } else {
                    test_field = VALIDf;
                }
                soc_ser_create_test_data(unit, tmp_entry, field_data,
                                         SER_RANGE_ENABLEr, i, INVALIDf, mem,
                                         test_field, MEM_BLOCK_ANY, REG_PORT_ANY,
                                         _SOC_ACC_TYPE_PIPE_ANY, 0, &test_data);
                rv = ser_test_mem(unit, 0, &test_data, test_type, &testErrors);
                            
                if (rv != SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "Error during TCAM test.  Aborting.\n")));
                    return rv;
                }
            }
        }
    }
    
    /*H/W memory Test*/
    for (group = 0; _soc_katana2_parity_route_blocks[group].cmic_bit; group++) {
        info = _soc_katana2_parity_route_blocks[group].info;
        
        if (_soc_katana2_parity_route_blocks[group].blocktype == SOC_BLK_MMU) {
            continue;
        } else {
            SOC_BLOCK_ITER(unit, blk,_soc_katana2_parity_route_blocks[group].blocktype) {
                if (_soc_katana2_parity_block_port(unit, blk, &block_port) < 0) {
                    continue;
                }

                for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                    memTable = info[table].mem;
                    if (memTable == INVALIDm) {
                        continue;
                    }
                    if (memTable == mem) {
                        soc_ser_create_test_data(unit, tmp_entry, field_data,
                                                 info[table].enable_reg,
                                                 SOC_INVALID_TCAM_PARITY_BIT,
                                                 info[table].enable_field,
                                                 mem, EVEN_PARITYf, blk,
                                                 block_port, 
                                                 _SOC_ACC_TYPE_PIPE_ANY, 0,
                                                 &test_data);
                        rv = ser_test_mem(unit, 0, &test_data, test_type, 
                                          &testErrors);
                        if (rv != SOC_E_NONE) {
                            LOG_CLI((BSL_META_U(unit,
                                                "Error during H/W test.  Aborting.\n")));
                            return rv;
                        }
                    }
                }
            }
        }
    }
    if (testErrors == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test passed on unit: %d for memory %s\n "),
                 unit, SOC_MEM_NAME(unit,mem)));
    } else {
        LOG_CLI((BSL_META_U(unit,
                            "SER Test failed on unit: %d for memory %s\n"),
                 unit, SOC_MEM_NAME(unit,mem)));
        return SOC_E_MEMORY;
    }
    return SOC_E_NONE;
}

/*
 * Function:
 *      soc_katana2_set_test_field
 * Purpose:
 *      Specified the field of a memory . It is used to inject a parity error in the entry. 
 * Parameters:
 *      memory       - (IN) The memory id
 *      field        - (IN) The field id of the memory
 */
STATIC 
soc_field_t soc_katana2_set_test_field(soc_mem_t memory, soc_field_t field)
{
    soc_field_t test_field = field;

    switch(memory) {
    /* TCAM fields*/
    case MY_STATION_TCAMm:
    case L2_USER_ENTRYm:
    case VLAN_SUBNETm:
    case CPU_COS_MAPm:
    case EFP_TCAMm:
    case VFP_TCAMm:
    case FP_UDF_TCAMm:
    case SUBPORT_TAG_TO_PP_PORT_MAPm:
    case L3_TUNNELm:
        test_field = MASKf;
        break;
    case L3_DEFIPm:
        test_field = MASK0f;
        break;
    case L3_DEFIP_PAIR_128m:
        test_field = MASK0_LWRf;
        break;
    case FP_TCAMm:
    case FP_GLOBAL_MASK_TCAMm:
        test_field = VALIDf;
        break;
    default:
        break;
    }

    return test_field;
}


/*
 * Function:
 *      soc_katana2_ser_test
 * Purpose:
 *      Performs a SER test on all TR2 Memories
 * Parameters:
 *      unit               - (IN) Device Number
 *      test_type        - (IN) Determines how comprehensive of a test to run
 */
int soc_katana2_ser_test(int unit, _soc_ser_test_t test_type) {
    int i, rv;
    int numTCAMErr   = 0;
    int numNACKErr   = 0;
    soc_field_t tcam_field;

    /*This is a NACK test for hardware-monitored memories*/
    rv = _soc_katana2_mem_nack_error_test(unit, test_type, &numNACKErr);
    if (rv != SOC_E_NONE) {
        LOG_CLI((BSL_META_U(unit,
                    "TR 144 test failed. Error during H/W test.  Aborting.\n")));
        return rv;
    }
    /*This is a NACK test for TCAM memories*/
    /*Test each TCAM memory*/
    if (_soc_kt2_tcam_ser_info[unit] != NULL) {
        for (i = 0; _soc_kt2_tcam_ser_info[unit][i].mem != INVALIDm; i++) {

            tcam_field = soc_katana2_set_test_field(_soc_kt2_tcam_ser_info[unit][i].mem,INVALIDf);

            /* coverity[negative_returns : FALSE] */
            rv = ser_test_mem_pipe(unit, SER_RANGE_ENABLEr, i, -1,
                                   _soc_kt2_tcam_ser_info[unit][i].mem, tcam_field,
                                   test_type, MEM_BLOCK_ANY, REG_PORT_ANY, -1,
                                   &numTCAMErr);
            if (rv != SOC_E_NONE) {
                LOG_CLI((BSL_META_U(unit,
                            "TR 144 test failed. Error during TCAM test.  Aborting.\n")));
                return rv;
            }
        }
    }

    if((numTCAMErr != 0) || (numNACKErr != 0)) {
        LOG_CLI((BSL_META_U(unit,
            "TR 144 test failed.\n")));
    }

    LOG_CLI((BSL_META_U(unit,
                        "Total H/W parity errors on unit %d: %d\n"),unit, numNACKErr));
    LOG_CLI((BSL_META_U(unit,
                        "Total TCAM errors on unit %d: %d\n"), unit, numTCAMErr));
    return SOC_E_NONE;
}

STATIC soc_error_t
_soc_katana2_ser_mem_info_get(int unit, soc_mem_t mem,
                              void** ser_mem_info)
{
    int i, j;
    _soc_katana2_parity_info_t *info = NULL;

    for (i = 0; _soc_katana2_parity_route_blocks[i].cmic_bit != 0; i++) {
        info = _soc_katana2_parity_route_blocks[i].info;
        if (_soc_katana2_parity_route_blocks[i].blocktype == SOC_BLK_MMU) {
            continue;
        }
        for (j = 0; info[j].type != _SOC_PARITY_TYPE_NONE; j++) {
            if (info[j].mem != INVALIDm && info[j].mem == mem) {
                *ser_mem_info = &info[j];
                return SOC_E_NONE;
            }
        }
    }
    return SOC_E_UNAVAIL;
}

STATIC soc_error_t
_soc_katana2_tcam_ser_mem_info_get(int unit, soc_mem_t mem,
                                   int * index_p)
{
    int i;
    _soc_generic_ser_info_t *tcams = _soc_kt2_tcam_ser_info[unit];

    for (i = 0; tcams[i].mem != INVALIDm; i++) {
        if (tcams[i].mem == mem) {
            *index_p = i;
            return SOC_E_NONE;
        }
    }
    return SOC_E_UNAVAIL;
}

/*
 * Function:
 *      soc_katana2_ser_error_injection_support
 * Purpose:
 *      Checks if a memory is supported by error injection interface
 *
 * Parameters:
 *      unit        - (IN) Device Number
 *      memory      - (IN) Test data required for SER test
 *      pipe        - (IN) How many indices to test for each memory
 *
 * Returns:
 *  SOC_E_NONE if memory / reg is supported, SOC_E_UNAVAIL if unsupported
 */
soc_error_t
soc_katana2_ser_error_injection_support(int unit, soc_mem_t mem,
                                        int pipe)
{
    int rv = SOC_E_UNAVAIL;
    void * ser_mem_info = NULL;
    int  tcam_idx = 0;

    rv = _soc_katana2_ser_mem_info_get(unit, mem, &ser_mem_info);
    if (rv == SOC_E_NONE) {
        return rv;
    }

    rv = _soc_katana2_tcam_ser_mem_info_get(unit, mem, &tcam_idx);
    if (rv == SOC_E_NONE) {
        return rv;
    }

    return rv;
}

/*
 * Function:
 *      soc_katana2_ser_inject_error
 * Purpose:
 *      Performs a SER test on a single TR2 memory
 * Parameters:
 *      unit               - (IN) Device Number
 *      mem                - (IN) The memory to test
 *      test_type        - (IN) How many indices in the memory to test
 */
int soc_katana2_ser_inject_error(int unit, uint32 flags,
                                 soc_mem_t mem, int pipeTarget,
                                 int block, int index)
{
    int group, table, i;
    _soc_katana2_parity_info_t *info;
    soc_mem_t memTable;
    soc_port_t block_port = 0;
    soc_block_t blk;
    ser_test_data_t test_data;
    soc_field_t field;
    uint32 tmp_entry[SOC_MAX_MEM_WORDS], fieldData[SOC_MAX_MEM_FIELD_WORDS];
    sal_memset(&test_data, 0, sizeof(test_data));
    _soc_katana2_mem_rename(&mem);

    /* Check if memory support ser inject operation */
    if (ser_katana2_test_fun.injection_support) {
        SOC_IF_ERROR_RETURN(
            soc_katana2_ser_error_injection_support(unit, mem, pipeTarget));
    }

    /*TCAM_test*/
    if (_soc_kt2_tcam_ser_info[unit] != NULL) {
        for (i = 0; _soc_kt2_tcam_ser_info[unit][i].mem != INVALIDm; i++) {
            if (_soc_kt2_tcam_ser_info[unit][i].mem == mem) {
                if (mem == L3_DEFIPm) {
                    field = VALID0f;
                } else if (mem == L3_DEFIP_PAIR_128m) {
                    field = VALID0_LWRf;
                } else {
                    field = VALIDf;
                }
                soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                         SER_RANGE_ENABLEr, i, VALIDf, mem,
                                         field, MEM_BLOCK_ANY, REG_PORT_ANY,
                                         _SOC_ACC_TYPE_PIPE_ANY, index, &test_data);
                /*Read the memory for successful injection*/
                SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
                /*Disable parity*/
                SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
                /*Inject error*/            
                SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
                /*Enable parity*/
                SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
                return SOC_E_NONE;
            }
        }
    }
    
    /*H/W memory Test*/
    for (group = 0; _soc_katana2_parity_route_blocks[group].cmic_bit; group++) {
        info = _soc_katana2_parity_route_blocks[group].info;
        if (_soc_katana2_parity_route_blocks[group].blocktype == SOC_BLK_MMU) {
            continue;
        } else {
            SOC_BLOCK_ITER(unit, blk,_soc_katana2_parity_route_blocks[group].blocktype) {
                if (_soc_katana2_parity_block_port(unit, blk, &block_port) < 0) {
                    continue;
                }
                for (table = 0; info[table].type != _SOC_PARITY_TYPE_NONE; table++) {
                    memTable = info[table].mem;
                    if (memTable == INVALIDm) {
                        continue;
                    }
                    if (memTable == mem) {
                        if((blk == block) || (block == MEM_BLOCK_ANY)) {
                            /*Inject error*/
                            if (mem == SOURCE_TRUNK_MAP_TABLEm) {
                                field = ECCf;
                                flags |= SOC_INJECT_ERROR_2BIT_ECC;
                            } else if (mem == PORT_TABm || mem == LPORT_TABm) {
                                field = ECC_0f;
                                flags |= SOC_INJECT_ERROR_2BIT_ECC;
                            } else {
                                field = EVEN_PARITYf;
                            }
                            soc_ser_create_test_data(unit, tmp_entry, fieldData,
                                                     info[table].enable_reg,
                                                     SOC_INVALID_TCAM_PARITY_BIT,
                                                     info[table].enable_field,
                                                     mem, field, blk,
                                                     block_port, 
                                                     _SOC_ACC_TYPE_PIPE_ANY, index, 
                                                     &test_data);
                            /*Read the memory for successful injection*/
                            SOC_IF_ERROR_RETURN(ser_test_mem_read(unit, 0, &test_data));
                            /*Disable parity*/
                            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 0));
                            /*Inject error*/
                            SOC_IF_ERROR_RETURN(soc_ser_test_inject_full(unit, flags, &test_data));
                            /*Enable parity*/
                            SOC_IF_ERROR_RETURN(_ser_test_parity_control(unit, &test_data, 1));
                       }
                   }
               } 
           } 
       } 
   }
    return SOC_E_NONE;
}

STATIC soc_kt2_oam_handler_t kt2_oam_handler[SOC_MAX_NUM_DEVICES] = {NULL};
STATIC soc_kt2_linkphy_handler_t kt2_linkphy_handler[SOC_MAX_NUM_DEVICES] = {NULL};
STATIC soc_kt2_oam_ser_handler_t kt2_oam_ser_handler[SOC_MAX_NUM_DEVICES] = {NULL};

extern int _soc_ddr_shmoo_prepare_for_shmoo(int unit, int ci);
typedef struct _soc_katana2_ci_parama_s {
    uint32          speed;
    uint32          grade;
} _soc_katana2_ci_parama_t;

/* 56450 TDM sequence */

/* Same for 56456,55450,55455 */
/* Cfg 0 is not advertised: Total 16(Actually 17 0..16) Configs */
#define BCM56450_DEVICE_ID_OFFSET_CFG 0
#define BCM56450_DEVICE_ID_DEFAULT_CFG 4
#define BCM56450_DEVICE_ID_MAX_CFG 16

/* Same for 56457 Total 10 Configs(1..10 <== 16+1=17..26) */
#define BCM56452_DEVICE_ID_OFFSET_CFG 16
#define BCM56452_DEVICE_ID_DEFAULT_CFG 17
#define BCM56452_DEVICE_ID_MAX_CFG 26

/* Same for 56458 Total 2 Configs(1..2)  26+1=27..28     */
#define BCM56454_DEVICE_ID_OFFSET_CFG 26
#define BCM56454_DEVICE_ID_DEFAULT_CFG 27
#define BCM56454_DEVICE_ID_MAX_CFG 28

/*                Total 1 Configs(1..1)  28+1=29..29    */
#define BCM56455_DEVICE_ID_OFFSET_CFG 28
#define BCM56455_DEVICE_ID_DEFAULT_CFG 29
#define BCM56455_DEVICE_ID_MAX_CFG 30

/* Same for 56450(First 16(0..15) ) Total 18(0..17) <== 30+0=30..47 Configs  */
#define BCM56248_DEVICE_ID_OFFSET_CFG 31
#define BCM56248_DEVICE_ID_DEFAULT_CFG 35
#define BCM56248_DEVICE_ID_MAX_CFG 48

/* typedef uint32 mxqspeeds_t[KT2_MAX_MXQBLOCKS][KT2_MAX_MXQPORTS_PER_BLOCK]; */

const static  mxqspeeds_t mxqspeeds_s = {
              {10000,2500,0,2500},{10000,2500,0,2500},{10000,2500,0,2500},
              {10000,2500,0,2500},{10000,2500,0,2500},{10000,2500,0,2500},
              {13000,2500,0,2500},{13000,2500,0,2500},
              {21000,10000,0,2500},{21000,10000,0,2500},
              {2500,0,0,0}};
mxqspeeds_t *mxqspeeds[SOC_MAX_NUM_DEVICES]={NULL};

uint32 kt2_current_tdm[256]={0};
uint32 kt2_current_tdm_size=0;

int mxqblock_max_startaddr[KT2_MAX_MXQBLOCKS]={0};
int mxqblock_max_endaddr[KT2_MAX_MXQBLOCKS]={0};

static uint8  old_tdm_no[SOC_MAX_NUM_DEVICES]={0};

/* bcm5645x_config=0 */
/* Deprecated=0 24x GE + 16*2.5GE(HG-LIT) */
/* 24xGE(1..24) + 16*2.5GE(HG-LIT)(25..40) */
static uint32 kt2_tdm_56450config_deprecated0[88]= {
1,              5,      9,      13,     17,     21,25,26,27,28,KT2_LPBK_PORT,
2,              6,      10,     14,     18,     22,35,38,32,29,KT2_CMIC_PORT,
3,              7,      11,     15,     19,     23,36,39,33,30,KT2_IDLE,
4,              8,      12,     16,     20,     24,37,40,34,31,KT2_IDLE1,
KT2_IDLE1,    KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,25,26,27,28,
KT2_LPBK_PORT,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,35,38,32,29,
KT2_CMIC_PORT,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,36,39,33,30,
KT2_IDLE,     KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,KT2_IDLE,37,40,34,31
};

/* 24xGE(1..24) + 16*2.5GE(HG-LIT)(25..40) */
/* typedef uint32 kt2_speed_t[KT2_MAX_PHYSICAL_PORTS]; */
const static kt2_speed_t kt2_tdm_56450speed_deprecated0= {
       2500,2500,2500,2500,     /* 1 - 4   */
       2500,2500,2500,2500,     /* 5 - 8   */
       2500,2500,2500,2500,     /* 9 - 12  */
       2500,2500,2500,2500,     /* 13 - 16 */
       2500,2500,2500,2500,     /* 17 - 20 */
       2500,2500,2500,2500,     /* 21 - 24 */
       2500,2500,2500,2500,     /* 25 - 28 */
       2500,2500,2500,2500,     /* 29 - 32 */
       2500,2500,2500,2500,     /* 33 - 36 */
       2500,2500,2500,2500};    /* 37 - 40 */
const static soc_port_details_t kt2_port_details_deprecated0[]={
    {1,24,1,GE_PORT,2500},
    {25,40,1,HGL_PORT|STK_PORT,2500}, 
    {0,0,0,0} /* End */
};

const static uint32 kt2_tdm_56450AA_ref[88]= {
1,              5,      9,      13,     17,     21,25,26,27,28,KT2_LPBK_PORT,
2,              6,      10,     14,     18,     22,35,38,32,29,KT2_CMIC_PORT,
3,              7,      11,     15,     19,     23,36,39,33,30,KT2_IDLE,
4,              8,      12,     16,     20,     24,37,40,34,31,KT2_IDLE1,
KT2_IDLE1,      1,      5,      9,      13,     17,21,25,26,27,28,
KT2_LPBK_PORT,  2,      6,      10,     14,     18,22,35,38,32,29,
KT2_CMIC_PORT,  3,      7,      11,     15,     19,23,36,39,33,30,
KT2_IDLE,       4,      8,      12,     16,     20,24,37,40,34,31
};


const static uint32 kt2_tdm_56450A_ref[88]= {
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_LPBK_PORT,
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_CMIC_PORT,
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_OLP_PORT,
1,              5,      9,      27,     30,     13,17,21,33,28,KT2_IDLE1,
KT2_IDLE1,      1,      5,      9,      27,     30,13,17,21,33,28,
KT2_LPBK_PORT,  1,      5,      9,      27,     30,13,17,21,33,28,
KT2_CMIC_PORT,  1,      5,      9,      27,     30,13,17,21,33,28,
KT2_OLP_PORT,   1,      5,      9,      27,     30,13,17,21,33,28
};

#define  BCM_KT2_TDM_A1_NUM_SLOTS 176
const static uint32 kt2_tdm_56450A1_ref[BCM_KT2_TDM_A1_NUM_SLOTS]= {
26,  9,   27,  28,  5,   13,  25,  28,  27,   26,   KT2_LPBK_PORT,
1,   9,   27,  28,  25,  13,  26,  28,  27,   KT2_CMIC_PORT,  KT2_OLP_PORT,
28,  27,  9,   25,  26,  13,  28,  27,  KT2_IDLE1,  KT2_IDLE1,  28,
25,  27,  9,   26,  28,  13,  3,   27,  7,    25,   28,
26,  9,   27,  28,  6,   13,  25,  28,  27,   26,   KT2_LPBK_PORT,
2,   9,   27,  28,  25,  13,  26,  28,  27,   KT2_CMIC_PORT,  KT2_OLP_PORT,
28,  27,  9,   25,  26,  13,  28,  27,  KT2_IDLE,   KT2_IDLE,  28,
25,  27,  9,   26,  28,  13,  4,   27,  8,    25,   28,
26,  9,   27,  28,  5,   13,  25,  28,  27,   26,   KT2_LPBK_PORT,
1,   9,   27,  28,  25,  13,  26,  28,  27,   KT2_CMIC_PORT,  KT2_OLP_PORT,
28,  27,  9,   25,  26,  13,  28,  27,  KT2_IDLE,   KT2_IDLE,  28,
25,  27,  9,   26,  28,  13,  3,   27,  7,    25,   28,
26,  9,   27,  28,  6,   13,  25,  28,  27,   26,   KT2_LPBK_PORT,
2,   9,   27,  28,  25,  13,  26,  28,  27,   KT2_CMIC_PORT,  KT2_OLP_PORT,
28,  27,  9,   25,  26,  13,  28,  27,  KT2_IDLE,   KT2_IDLE,  28,
25,  27,  9,   26,  28,  13,  4,   27,  8,    25,   28
};

#define BCM_KT2_TDM_A1A_NUM_SLOTS 108
const static uint32 kt2_tdm_56450A1A_ref[BCM_KT2_TDM_A1A_NUM_SLOTS]= {
1,             25, 27,            28,            11,            26, KT2_IDLE,      27,        28,
KT2_OLP_PORT,  25, KT2_CMIC_PORT, 27,            28,            26, 15,            19,        27,
28,            25, KT2_IDLE1,     KT2_IDLE1,     27,            26, 28,            20,        23,
27,            25, 28,            8,             KT2_CMIC_PORT, 26, 27,            28,        KT2_LPBK_PORT,
2,             25, 27,            28,            12,            26, 16,            27,        28,
KT2_OLP_PORT,  25, 4,             27,            28,            26, 17,            21,        27,
28,            25, 5,             9,             27,            26, 28,            KT2_IDLE1, KT2_IDLE1,
27,            25, 28,            KT2_CMIC_PORT, 13,            26, 27,            28,        KT2_LPBK_PORT,
3,             25, 27,            28,            14,            26, 18,            27,        28,
KT2_OLP_PORT,  25, 6,             27,            28,            26, KT2_CMIC_PORT, 22,        27,
28,            25, 7,             KT2_IDLE,      27,            26, 28,            KT2_IDLE,  24,
27,            25, 28,            10,            KT2_IDLE,      26, 27,            28,        KT2_LPBK_PORT
};

const static uint32 kt2_tdm_56450A2_ref[216]= {
KT2_IDLE1,     28, 9,  25, 21,            26, 17,            27, 13,
KT2_CMIC_PORT, 28, 1,  25,  9,            26, 21,            27, 17,
KT2_OLP_PORT,  28, 13, 25, KT2_LPBK_PORT, 26,  9,            27, 21,
2,             28, 17, 25, 13,            26, KT2_CMIC_PORT, 27,  9,
3,             28, 21, 25, 17,            26, 13,            27,  7,
9,             28,  4, 25, 21,            26, 17,            27, 13,
KT2_OLP_PORT,  28,  9, 25, KT2_LPBK_PORT, 26, 21,            27, 17,
13,            28,  5, 25,  9,            26, KT2_CMIC_PORT, 27, 21,
17,            28, 13, 25,  6,            26,  9,            27, KT2_IDLE,
21,            28, 17, 25, 13,            26, KT2_LPBK_PORT, 27,  9,
KT2_OLP_PORT,  28, 21, 25, 17,            26, 13,            27,  8,
9,             28, 21, 25, 17,            26, 13,            27, KT2_IDLE,
KT2_IDLE,      28,  9, 25, 21,            26, 17,            27, 13,
KT2_CMIC_PORT, 28,  1, 25,  9,            26, 21,            27, 17,
KT2_OLP_PORT,  28, 13, 25, KT2_LPBK_PORT, 26,  9,            27, 21,
2,             28, 17, 25, 13,            26, KT2_CMIC_PORT, 27,  9,
3,             28, 21, 25, 17,            26, 13,            27,  7,
9,             28,  4, 25, 21,            26, 17,            27, 13,
KT2_OLP_PORT,  28,  9, 25, KT2_LPBK_PORT, 26, 21,            27, 17,
13,            28,  5, 25,  9,            26, KT2_CMIC_PORT, 27, 21,
17,            28, 13, 25,  6,            26,  9,            27, KT2_IDLE,
21,            28, 17, 25, 13,            26, KT2_LPBK_PORT, 27, 9,
KT2_OLP_PORT,  28, 21, 25, 17,            26, 13,            27, 8,
9,             28, 21, 25, 17,            26, 13,            27, KT2_IDLE1
};

const static uint32 kt2_tdm_56450A3_ref[88] = {
KT2_IDLE1,     9, 28, 13, 25, 17,  5, 21, 28, 27, KT2_LPBK_PORT,
25,	       9, 28, 13,  1, 17, 25, 21, 28, 27, KT2_OLP_PORT,
KT2_CMIC_PORT, 9, 28, 13, 25, 17,  6, 21, 28, 27, KT2_IDLE,
25,	       9, 28, 13,  2, 17, 25, 21, 28, 27, KT2_LPBK_PORT,
KT2_OLP_PORT,  9, 28, 13, 25, 17,  7, 21, 28, 27, KT2_IDLE,
25,	       9, 28, 13,  3, 17, 25, 21, 28, 27, KT2_LPBK_PORT,
KT2_CMIC_PORT, 9, 28, 13, 25, 17,  8, 21, 28, 27, KT2_OLP_PORT,
25,	       9, 28, 13,  4, 17, 25, 21, 28, 27, KT2_IDLE1
};

#define  BCM_KT2_TDM_A4_NUM_SLOTS 88
const static uint32 kt2_tdm_56450A4_ref[88] = {
KT2_IDLE1,      1,  28,  27,  25,  17,  26,  13,  28,  27,  KT2_OLP_PORT,
KT2_LPBK_PORT, 25,  28,  27,  26,  17,   9,  14,  28,  27,  25,
KT2_IDLE,      26,  28,  27,   5,  17,  10,  25,  28,  27,  26,
KT2_CMIC_PORT,  2,  28,  27,   6,  17,  25,  26,  28,  27,  KT2_LPBK_PORT,
KT2_IDLE,       3,  28,  27,  25,  17,  26,  15,  28,  27,  KT2_OLP_PORT,
KT2_IDLE,      25,  28,  27,  26,  17,  11,  16,  28,  27,  25,
KT2_LPBK_PORT, 26,  28,  27,   7,  17,  12,  25,  28,  27,  26,
KT2_CMIC_PORT,  4,  28,  27,   8,  17,  25,  26,  28,  27,  KT2_IDLE1
};

const static uint32 kt2_tdm_56450F_ref[88]= {
KT2_IDLE,      25,       KT2_IDLE, 1,        KT2_IDLE, 5,	 KT2_IDLE, 26,       27,       28,       KT2_LPBK_PORT,
KT2_IDLE,      35,       KT2_IDLE, 2,        KT2_IDLE, 6,	 KT2_IDLE, 38,       KT2_IDLE, 28,       KT2_CMIC_PORT,
KT2_IDLE,      36,       KT2_IDLE, 3,        KT2_IDLE, 7,	 KT2_IDLE, 39,       KT2_IDLE, 28,       KT2_IDLE,
KT2_IDLE,      37,       KT2_IDLE, 4,        KT2_IDLE, 8,	 KT2_IDLE, 40,       KT2_IDLE, 28,       KT2_IDLE1,
KT2_IDLE1,     KT2_IDLE, 25,	   KT2_IDLE, 1,        KT2_IDLE, 5,        KT2_IDLE, 26,       27,       28,
KT2_LPBK_PORT, KT2_IDLE, 35,       KT2_IDLE, 2,        KT2_IDLE, 6,        KT2_IDLE, 38,       KT2_IDLE, 28,
KT2_CMIC_PORT, KT2_IDLE, 36,       KT2_IDLE, 3,        KT2_IDLE, 7,        KT2_IDLE, 39,       KT2_IDLE, 28,
KT2_IDLE,      KT2_IDLE, 37,	   KT2_IDLE, 4,        KT2_IDLE, 8,        KT2_IDLE, 40,       KT2_IDLE, 28,
};

const static uint32 kt2_tdm_56452B_new_ref[90]= {
KT2_CMIC_PORT,1,27,           28,5, KT2_LPBK_PORT, 25,            26, 28,
27,	      2,KT2_IDLE,     28,6, 25,            KT2_CMIC_PORT, 38, 27,
28,	      3,KT2_LPBK_PORT,25,7, 28,	           27,	          39, KT2_IDLE,
28,	      4,25,	      40,8, 27,	           28,	          26, 5,
25,	      1,28,	      27,6, 2,	           28,	          38, 25,
KT2_CMIC_PORT,3,27,	      28,7, KT2_LPBK_PORT, 25,	          39, 28,
27,	      4,KT2_IDLE1,    KT2_IDLE1,28,8,      25,            40, 27,
28,	      1,KT2_IDLE,     25,5,28,	           27,	          26, 6,
28,	      2,25,	      38,7,27,	           28,39,	  KT2_LPBK_PORT,
25,	      3,28,	      27,8,4,	           28,	          40, 25
};

const static uint32 kt2_tdm_56452B1_ref[60]= {
1,	  27,	25,	       28, 5,	      1,	     27, KT2_IDLE,     28, KT2_IDLE,
25,	  27,	5,	       28, 1,	      KT2_CMIC_PORT, 27, 25,	       28, KT2_LPBK_PORT,
5,	  27,	1,	       28, KT2_IDLE,  25,	     27, KT2_OLP_PORT, 28, 5,
1,	  27,	25,	       28, KT2_IDLE1, KT2_IDLE1,     27, 5,	       28, 1,
25,	  27,	KT2_CMIC_PORT, 28, 5,	      1,             27, 25,	       28, KT2_LPBK_PORT,
KT2_IDLE, 27,	5,	       28, 1,	      25,            27, KT2_OLP_PORT, 28, 5
};

const static uint32 kt2_tdm_56452B2_ref[72]= {
KT2_IDLE1, 9,  13,	28,	26,	21,	17,	30,	KT2_LPBK_PORT,
1,	   10, 14,	28,	26,	21,	17,	30,	KT2_CMIC_PORT,
2,	   11, 15,	28,	26,	21,	17,	30,	KT2_OLP_PORT,
3,	   12, 16,	28,	26,	21,	17,	30,	4,
5,	   9,  13,	28,	26,	21,	17,	30,	KT2_LPBK_PORT,
6,	   10, 14,	28,	26,	21,	17,	30,	KT2_CMIC_PORT,
7,	   11, 15,	28,	26,	21,	17,	30,	KT2_OLP_PORT,
8,	   12, 16,	28,	26,	21,	17,	30,	KT2_IDLE1
};


const static uint32 kt2_tdm_56455C_ref[84]= {
KT2_LPBK_PORT,  9,	      17,	        25,	26,	27,	28,
KT2_CMIC_PORT, 10,	      18,	        25,	26,	27,	28,
1,	       KT2_LPBK_PORT, 19,	        25,	26,	27,	28,
2,	       11,            20,	        25,	26,	27,	28,
3,	       12,	      KT2_LPBK_PORT,	25,	26,	27,	28,
4,	       13,	      KT2_CMIC_PORT,	25,	26,	27,	28,
KT2_LPBK_PORT, 14,	      21,	        25,	26,	27,	28,
KT2_IDLE,      15,	      22,	        25,	26,	27,	28,
5,	       KT2_LPBK_PORT, 23,	        25,	26,	27,	28,
6,	       KT2_CMIC_PORT, 24,	        25,	26,	27,	28,
7,	       16,	      KT2_LPBK_PORT,	25,	26,	27,	28,
8,	       KT2_IDLE1,     KT2_IDLE1,	25,	26,	27,	28
};

const static uint32 kt2_tdm_56452C1_ref[64]= {
1, 9,	KT2_LPBK_PORT, 20,	     27,	28,	25,	26,
2, 10,	17,	       KT2_OLP_PORT, 27,	28,	25,	26,
3, 11,	KT2_CMIC_PORT, 21,	     27,	28,	25,	26,
4, 12,	18,	       22,	     27,	28,	25,	26,
5, 13,	KT2_LPBK_PORT, 23,	     27,	28,	25,	26,
6, 14,	19,	       KT2_OLP_PORT, 27,	28,	25,	26,
7, 15,	KT2_CMIC_PORT, 24,	     27,	28,	25,	26,
8, 16,	KT2_IDLE1,     KT2_IDLE1,    27,	28,	25,	26
};

#if 0
const static uint32 kt2_tdm_56454D_ref[20] = {
KT2_IDLE1,	1,	5,	27,	28,	
2,		6,	27,	28,	KT2_LPBK_PORT,
3,		7,	27,	28,	KT2_CMIC_PORT,
4,		8,	27,	28,	KT2_IDLE1,
};
#endif

const static uint32 kt2_tdm_56454D1_ref[40] = {
1,	        5,	27,	28,	KT2_LPBK_PORT,
1,	        5,	27,	28,	KT2_CMIC_PORT,
1,	        5,	27,	28,	KT2_OLP_PORT,
1,	        5,	27,	28,	KT2_IDLE1,
KT2_IDLE1,      1,	5,	27,	28,
KT2_LPBK_PORT,  1,	5,	27,	28,
KT2_CMIC_PORT,  1,	5,	27,	28,
KT2_OLP_PORT,   1,	5,	27,     28
};
const static uint32 kt2_tdm_56248D2_ref[40] = {
1,             9,  13, 27,	    KT2_LPBK_PORT,
2,             10, 17, 28,	    KT2_CMIC_PORT,
3,             11, 21, 29,	    KT2_OLP_PORT,
4,             12, 25, KT2_IDLE,    KT2_IDLE1,
KT2_IDLE1,      9,  13, 27,	    5,
KT2_LPBK_PORT, 10, 17, 28,	    6,
KT2_CMIC_PORT, 11, 21, 29,	    7,
KT2_OLP_PORT,  12, 25, KT2_IDLE,    8
};

				


/* bcm5645x_config=1 */

/* 8 x F.XAUI(1,,5,9,13,17,21,25,26)    2 x W10G = 2 x XFI (27,28) */
static uint32 kt2_tdm_A_56450_1[88]={0}; /* Will be filled-up at run time */
const  static kt2_speed_t kt2_speed_56450_1 = {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       0000,0000,0000,0000,      /* 29 - 32  */
       0000,0000,0000,0000,      /* 33 - 36  */
       0000,0000,0000,0000};     /* 37 - 40  */

/* Config=1 8xF.XAUI  2xW10G */
/* 2 XFI */
const static soc_port_details_t kt2_port_details_56450_1[]={
    {1,25,4,XE_PORT,10000}, /* 7 F.XAUI */
    {26,28,1,XE_PORT,10000},/* 1 F.XAUI + 2 XFI */
    {0,0,0,0} /* End */
};  

/* bcm5645x_config=2 */

/* 7 x F.XAUI + 1 x XAUI(1,5,9,13,17,21,25,26)  2 x W10G = 2 x XFI (27,28) */
static uint32 kt2_tdm_A_56450_2[88]={0}; /* Will be filled-up at run time */
const  static kt2_speed_t kt2_speed_56450_2 = {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       0000,0000,0000,0000,      /* 29 - 32  */
       0000,0000,0000,0000,      /* 33 - 36  */
       0000,0000,0000,2500};     /* 37 - 40  */
/* Config=2 7 x F.XAUI + 1 x XAUI + 2 x W10G */
/* 2XFI + OLP */
const static soc_port_details_t kt2_port_details_56450_2[]={
    {1,25,4,XE_PORT,10000}, /* 7 F.XAUI */
    {26,28,1,XE_PORT,10000},/* 1 XAUI Fixed + 2 XFI*/
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=3 */

/* 7 x F.XAUI(1,5,9,13,17,21,25)        1xW10G + 1xW20G (3 x XFI)(27,28,30) */
static uint32 kt2_tdm_A_56450_3[88]={0}; /* Will be filled-up at run time */
const  static kt2_speed_t kt2_speed_56450_3= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       10000,0000,10000,10000,   /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,      /* 33 - 36  */
       0000,0000,0000,2500};     /* 37 - 40  */
/* Config=3 7 x F.XAUI	1 x W10G + 1 x W20G */
/* 3XFI + OLP */
const static soc_port_details_t kt2_port_details_56450_3[]={
    {1,25,4,XE_PORT,10000}, /* 7 F.XAUI */
    {27,28,1,XE_PORT,10000},/* 2 XFI */
    {30,30,1,XE_PORT,10000},/* 1 XFI */
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=4 */

/* 6 x F.XAUI(1,5,9,13,17,21)   2 x W20G (4 x XFI) 27,33,28,30 */
static uint32 kt2_tdm_A_56450_4[88]={0};
const static kt2_speed_t kt2_speed_56450_4= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       0000,0000,10000,10000,    /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       10000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};     /* 37 - 40  */
/* Config=4 6 x F.XAUI	2 x W20G */
/* 4XFI + OLP */
const static soc_port_details_t kt2_port_details_56450_4[]={
    {1,21,4,XE_PORT,10000}, /* 6 F.XAUI */
    {27,28,1,XE_PORT,10000},/* 2 XFI */
    {30,33,3,XE_PORT,10000}, /* 2 XFI */
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=5 */

/* 4 x F.XAUI(1,5,9,13) 1 x W40G(27,25,36,33) + 1 x W20G (28,30)         */
/* MXQ8:27,33 MXQ9:28,30 */
/* ##MXQ7:26,39 Indirectly used */
/* ##MXQ6(25,36) Not used       */
static uint32 kt2_tdm_A_56450_5[88]={0};
const static kt2_speed_t kt2_speed_56450_5= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,      /* 17 - 20  */
       0000,0000,0000,0000,      /* 21 - 24  */
       10000,0000,10000,10000,   /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       10000,0000,0000,10000,    /* 33 - 36  */
       0000,0000,10000,2500};    /* 37 - 40  */
/* Config=5 4 x F.XAUI	1 x W20G + 1 x W40G */
/* 6XFI + OLP */
const static soc_port_details_t kt2_port_details_56450_5[]={
    {1,13,4,XE_PORT,10000}, /* 4 F.XAUI */
    {25,36,11,XE_PORT,10000}, /* 2 XFI */
    {27,33,6,XE_PORT,10000}, /* 2 XFI */
    {28,30,2,XE_PORT,10000}, /* 4 XFI */
    {40,40,1,OLP_PORT,2500}, /* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=6 */

/* 2 x F.XAUI (1,5)     2 x W40G=8 XFI (25,36,26,39,27,33,28,30) */
/* MXQ6=25,36      MXQ7=26,39      MXQ8=27,33      MXQ9=28,30 */
static uint32 kt2_tdm_A_56450_6[88]={0};
const static kt2_speed_t kt2_speed_56450_6= {
       10000,0000,0000,0000,     /* 1  - 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,      /* 9  - 12  */
       0000,0000,0000,0000,      /* 13 - 16  */
       0000,0000,0000,0000,      /* 17 - 20  */
       0000,0000,0000,0000,      /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       10000,0000,0000,10000,    /* 33 - 36  */
       0000,0000,10000,/* 2500 */ 0000};    /* 37 - 40  */
/* Config=6 2 x F.XAUI	2 x W40G */
/* 8XFI + OLP */
/* ##MXQ7:26,39 Indirectly used */
/* ##MXQ6(25,36) Indirectly used       */
const static soc_port_details_t kt2_port_details_56450_6[]={
    {1,5,4,XE_PORT,10000},
    {25,28,1,XE_PORT,10000},
    {30,39,3,XE_PORT,10000},
    /* {40,40,1,OLP_PORT,2500}, */ /* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=7 */

/* 24GE + 1 F.XAUI      W20G(27,33) + W20G (28,30, 26, 39)    */

static uint32 kt2_tdm_A_56450_7[88]={0};
const static kt2_speed_t kt2_speed_56450_7= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       10000,10000,10000,10000,  /* 25 - 28  */
       0000,10000,0000,0000,    /* 29 - 32  */
       10000,0000,0000,0000,   /* 33 - 36  */
       0000,0000,10000,0000};    /* 37 - 40  */
/* Config=7 24 x GE   1 x F.XAUI 1 x W40G  1 x W20G */
/* SP3 */
/* Assuming 6 XFI + OLP */
/* MXQ6:25,36 MXQ8:27,33 MXQ9:28,30 ##MXQ7(26,39) Not used*/
const static soc_port_details_t kt2_port_details_56450_7[]={
    {1,24,1,GE_PORT,1000},
    {25,25,1,XE_PORT,10000} , /* 1 F.XAUI */
    {27,33,6,XE_PORT,10000}, /* 1 F.XAUI */
    {28,30,2,XE_PORT,10000}, /* 2 XFI */
    {26,39,13,XE_PORT,10000}, /* 1 XFI */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=8 */

/* 8x GE + 2x F-XAUI + 2x HG13 + 2x HG21 + OLP */
static uint32 kt2_tdm_A1_56450_8[BCM_KT2_TDM_A1_NUM_SLOTS]={0};
const static kt2_speed_t kt2_speed_56450_8= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,21000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=8 8 x GE 2 x F.XAUI 1 x F.HG13  1 x X.HG13  2 x W21G */
const static soc_port_details_t kt2_port_details_56450_8[]={
    {1,8,1,GE_PORT,1000},
    {9,13,4,XE_PORT,10000}, /* 2 F.XAUI */
    {25,26,1,HG_PORT|STK_PORT,13000}, /* 26 Fixed XAUI */
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=9 */

/* 24x GE + 2x HG13 + 2x HG21 + OLP */
static uint32 kt2_tdm_A1A_56450_9[108]={0};
const static kt2_speed_t kt2_speed_56450_9= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,21000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=9 24 x GE 1 x F.HG13  1 x X.HG13  2 x W21G */
const static soc_port_details_t kt2_port_details_56450_9[]={
    {1,24,1,GE_PORT,1000},
    {25,26,1,HG_PORT|STK_PORT,13000},  /* 26 Fixed XAUI */
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};


/* bcm5645x_config=10 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 
   1 x HG[13] + 1 x F.HG[13](25,26)   2 x W13G(27,28)(NO OLP) */
static uint32 kt2_tdm_A2_56450_10[216]={0};
const static kt2_speed_t kt2_speed_56450_10= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
/* Config=10 8 x GE 4 x F.XAUI  2 x F.HG13  2 x W13G */
const static soc_port_details_t kt2_port_details_56450_10[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000}, /* 4  F.XAUI */
    {25,28,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};

/* bcm5645x_config=11 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 1 x HG[13] + */
/* 1 x F.HG[13](25,26)   2 x W13G(27,28) */
static uint32 kt2_tdm_A2_56450_11[216]={0};
const static kt2_speed_t kt2_speed_56450_11= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=11 8 x 1GbE + 4 x F.XAUI + 1 x F.HG[13] + 1 x X.HG[13] 2 x W13G */
const static soc_port_details_t kt2_port_details_56450_11[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000}, /* 4  F.XAUI */
    {25,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=12 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 1 x HG[13](25) */
/* 1x W13G(27) 1xW21G(28) */
static uint32 kt2_tdm_A3_56450_12[88]={0};
const static kt2_speed_t kt2_speed_56450_12= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       13000,0000,13000,21000,  /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=12 8 x 1GbE + 4 x F.XAUI + 1 x F.HG[13] 1 x W13G 1 x W21G*/
/* 2xHG13 + 1xHG21 */
const static soc_port_details_t kt2_port_details_56450_12[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000}, /* 4 F.XAUI */
    {25,27,2,HG_PORT|STK_PORT,13000},
    {28,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=13 */

/* 8 x 1GbE(1..8) + 4 x F.XAUI(9,13,17,21) + 2 x W21G(27,28) */
static uint32 kt2_tdm_A2_56450_13[216]={0};
const static kt2_speed_t kt2_speed_56450_13= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       10000,0000,0000,0000,    /* 21 - 24  */
       0000,0000,21000,21000,   /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=13 8 x 1GbE + 4 x F.XAUI + 2 x W21G*/
const static soc_port_details_t kt2_port_details_56450_13[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,10000},
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};


/* bcm5645x_config=14 */

/* 8 x 1GbE(1..8) + 2 x F.XAUI(9,13) + 2xHG13(25,26) 2 x W20G(27,28) */
static uint32 kt2_tdm_A1_56450_14[BCM_KT2_TDM_A1_NUM_SLOTS]={0};
const static kt2_speed_t kt2_speed_56450_14= {
       1000,1000,1000,1000,     /* 1  - 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,    /* 9  - 12  */
       10000,0000,0000,0000,    /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,21000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=14 8 x 1GbE + 2 x F.XAUI + 1 x F.HG[13] + 1 x X.HG[13]  2 x W20G */
/* TN2 */
/* Actually 4 XFI but treating as 2HG13 only!! */
const static soc_port_details_t kt2_port_details_56450_14[]={
    {1,8,1,GE_PORT,1000},
    {9,13,4,XE_PORT,10000}, /* 2 F.XAUI */
    {25,26,1,HG_PORT|STK_PORT,13000},
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=15 */

/* 16 x 1GbE(1..16) + 1 x F.XAUI(17) + 2xHG13(25,26) 2 x W21G(27,28) */
static uint32 kt2_tdm_A4_56450_15[216]={0};
const static kt2_speed_t kt2_speed_56450_15= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       10000,0000,0000,0000,    /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
/* Config=15 16 x 1GbE + 1 x F.XAUI + 1 x F.HG[13] + 1 x X.HG[13]  2 x W20G */
/* TN2 */
/* Assuming 4 XFI */
const static soc_port_details_t kt2_port_details_56450_15[]={
    {1,16,1,GE_PORT,1000},
    {17,17,1,XE_PORT,10000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* bcm5645x_config=16 */

/* 16x2.5G(1..8, 25.35,36,37 26,38,39,40) + 1xXAUI(28)   */
static uint32 kt2_tdm_F_56450_16[88]={0};
const static kt2_speed_t kt2_speed_56450_16= {
       2500,2500,2500,2500,     /* 1 .- 4   */
       2500,2500,2500,2500,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,    /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       2500,2500,1000,10000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,2500,2500,     /* 33 - 36  */
       2500,2500,2500,2500};    /* 37 - 40  */

const static soc_port_details_t kt2_port_details_56450_16[]={
    {1,8,1,GE_PORT,2500},
    {25,26,1,GE_PORT,2500},
    {27,27,1,GE_PORT,1000},
    {35,40,1,GE_PORT,2500},
    {28,28,1,XE_PORT,10000},
    {0,0,0,0} /* End */
};

/* 24x GE + 4x HG[13] /4x XAUI / 16x 2.5G */
static uint32 kt2_tdm_C_56452_1[84]={0};
const static kt2_speed_t kt2_speed_56452_1= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_1[]={
    {1,24,1,GE_PORT,1000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};
/* 24x GE + 4x HG[13] /4x XAUI / 16x 2.5G + OLP */
static uint32 kt2_tdm_C1_56452_2[64]={0};
const static kt2_speed_t kt2_speed_56452_2= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_2[]={
    {1,24,1,GE_PORT,1000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* 2x XE + 4x HG[13] /4x XAUI / 16x 2.5G  */
static uint32 kt2_tdm_C1_56452_3[64]={0};
const static kt2_speed_t kt2_speed_56452_3= {
       10000,0000,0000,0000,     /* 1 .- 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_3[]={
    {1,5,4,XE_PORT,10000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};

/* 2x XE + 4x HG[13] /4x XAUI / 16x 2.5G  + OLP*/
static uint32 kt2_tdm_C1_56452_4[64]={0};
const static kt2_speed_t kt2_speed_56452_4= {
       10000,0000,0000,0000,     /* 1 .- 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_4[]={
    {1,5,4,XE_PORT,10000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* 24x GE + HG[13] - HG[13] HG[21]  + OLP */
static uint32 kt2_tdm_B_56452_5[90]={0};
const static kt2_speed_t kt2_speed_56452_5= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,0000,13000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_5[]={
    {1,24,1,GE_PORT,1000},
    {25,27,2,HG_PORT|STK_PORT,13000},
    {28,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};
/* 24x GE + - - HG[21] HG[21]  + OLP */
static uint32 kt2_tdm_B1_56452_6[60]={0};
const static kt2_speed_t kt2_speed_56452_6= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       0000,0000,21000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_6[]={
    {1,24,1,GE_PORT,1000},
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* 24x GE + - - HG[13] HG[21]  + OLP */
static uint32 kt2_tdm_B_56452_7[90]={0};
const static kt2_speed_t kt2_speed_56452_7= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       0000,0000,13000,21000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_7[]={
    {1,24,1,GE_PORT,1000},
    {27,27,1,HG_PORT|STK_PORT,13000},
    {28,28,1,HG_PORT|STK_PORT,21000},
    {0,0,0,0} /* End */
};

/* 16*2.5G(XC0,XC1,XC6,XC7) + 1*1G debug port(WC0) +1*10G/20G DXAUI port(WC1)*/
static uint32 kt2_tdm_B_56452_8[90]={0};
const static kt2_speed_t kt2_speed_56452_8= {
       2500,2500,2500,2500,     /* 1 .- 4   */
       2500,2500,2500,2500,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       2500,2500,13000,20000,    /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,2500,2500,     /* 33 - 36  */
       2500,2500,2500,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_8[]={
    {1,8,1,GE_PORT,2500},
    {25,26,1,GE_PORT,2500},
    {27,27,1,HG_PORT|STK_PORT,13000},
    {28,28,1,XE_PORT,20000},
    {35,40,1,GE_PORT,2500},
    {0,0,0,0} /* End */
};

/* 2x XE + HG[13] - HG[21] HG[21]  + OLP */
static uint32 kt2_tdm_B1_56452_9[60]={0};
const static kt2_speed_t kt2_speed_56452_9= {
       10000,0000,0000,0000,     /* 1 .- 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,0000,21000,21000,  /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_9[]={
    {1,5,4,XE_PORT,10000},
    {25,25,1,HG_PORT|STK_PORT,13000},
    {27,28,1,HG_PORT|STK_PORT,21000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* 8x GE + 8x2.5GE + 2xXAUI - XAUI +  2xXFI  + OLP */
static uint32 kt2_tdm_B2_56452_10[72]={0};
const static kt2_speed_t kt2_speed_56452_10= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       2500,2500,2500,2500,     /* 9  - 12  */
       2500,2500,2500,2500,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       0000,10000,0000,10000, /* 25 - 28  */
       0000,10000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56452_10[]={
    {1,8,1,GE_PORT,1000},
    {9,16,1,GE_PORT,2500},
    {17,21,4,XE_PORT,10000},
    {26,26,1,XE_PORT,10000},
    {28,30,2,XE_PORT,10000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};



/* 2xF.XAUI + 2xHG13 */
static uint32 kt2_tdm_D1_56454_1[40]={0};
const static kt2_speed_t kt2_speed_56454_1= {
       10000,0000,0000,0000,     /* 1 .- 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       0000,0000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56454_1[]={
    {1,5,4,XE_PORT,10000},
    {27,28,1,HG_PORT|STK_PORT,13000},
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

/* 2xF.XAUI + 2xHG13 */
static uint32 kt2_tdm_D1_56454_2[40]={0};
const static kt2_speed_t kt2_speed_56454_2= {
       10000,0000,0000,0000,     /* 1 .- 4   */
       10000,0000,0000,0000,     /* 5  - 8   */
       0000,0000,0000,0000,     /* 9  - 12  */
       0000,0000,0000,0000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,0000,0000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56454_2[]={
    {1,5,4,XE_PORT,10000},
    {25,26,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};


/* 24x GE + 4x HG[13] /4x XAUI / 16x 2.5G */
static uint32 kt2_tdm_C_56455_1[84]={0};
const static kt2_speed_t kt2_speed_56455_1= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,13000,13000, /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56455_1[]={
    {1,24,1,GE_PORT,1000},
    {25,28,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};

static uint32 kt2_tdm_C_56455_2[84]={0};
const static kt2_speed_t kt2_speed_56455_2= {
       0000,0000,0000,0000,     /* 1 .- 4   */
       0000,0000,0000,0000,     /* 5  - 8   */
       1000,1000,1000,1000,     /* 9  - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       0000,0000,0000,0000,     /* 17 - 20  */
       0000,0000,0000,0000,     /* 21 - 24  */
       13000,13000,0000,0000,   /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,0000};    /* 37 - 40  */
const static soc_port_details_t kt2_port_details_56455_2[]={
    {9,16,1,GE_PORT,1000},
    {25,26,1,HG_PORT|STK_PORT,13000},
    {0,0,0,0} /* End */
};

static uint32 kt2_tdm_A3_56248_16[88]={0};
const static kt2_speed_t kt2_speed_56248_16= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       10000,0000,0000,0000,     /* 9  - 12  */
       10000,0000,0000,0000,     /* 13 - 16  */
       10000,0000,0000,0000,     /* 17 - 20  */
       10000,0000,0000,0000,     /* 21 - 24  */
       10000,0000,10000,21000,   /* 25 - 28  */
       0000,0000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500      /* 37 - 40  */
};
const static soc_port_details_t kt2_port_details_56248_16[]={
    {1,8,1,GE_PORT,1000},
    {9,21,4,XE_PORT,1000},
    {25,27,2,XE_PORT,10000},
    {28,28,1,HG_PORT|STK_PORT,21000}, 
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};

static uint32 kt2_tdm_D2_56248_17[40]={0};
const static kt2_speed_t kt2_speed_56248_17= {
       1000,1000,1000,1000,     /* 1 .- 4   */
       1000,1000,1000,1000,     /* 5  - 8   */
       1000,2500,2500,2500,     /* 9  - 12  */
       2500,0000,0000,0000,     /* 13 - 16  */
       2500,0000,0000,0000,     /* 17 - 20  */
       2500,0000,0000,0000,     /* 21 - 24  */
       2500,0000,2500,1000,     /* 25 - 28  */
       0000,1000,0000,0000,     /* 29 - 32  */
       0000,0000,0000,0000,     /* 33 - 36  */
       0000,0000,0000,2500      /* 37 - 40  */
};
const static soc_port_details_t kt2_port_details_56248_17[]={
    {1,8,1,GE_PORT,1000},
    {9,9,1,GE_PORT,1000},
    {10,12,1,GE_PORT,2500},
    {13,25,4,GE_PORT,2500},
    {27,27,1,GE_PORT,2500},
    {28,30,2,GE_PORT,1000}, 
    {40,40,1,OLP_PORT,2500},/* OLP */
    {0,0,0,0} /* End */
};


static uint32 kt2_tdm_mxqblock_ports_used[KT2_MAX_MXQBLOCKS]={0};
static uint32 kt2_tdm_position_mxq_mask[90]={0};
/* typedef uint32 kt2_port_to_mxqblock_t[KT2_MAX_PHYSICAL_PORTS]; */
static kt2_port_to_mxqblock_t kt2_port_to_mxqblock_s={0,0,0,0, /* 1-4   mxq0*/
                                        1,1,1,1, /* 5-8   mxq1*/
                                        2,2,2,2, /* 9-12  mxq2*/
                                        3,3,3,3, /* 13-16 mxq3*/
                                        4,4,4,4, /* 17-20 mxq4*/
                                        5,5,5,5, /* 21-24 mxq5*/
                                        6,7,8,9, /* 25-28 mxq6-9 */
                                        9,9,9,8, /* 29-32 mxq9,9,9-8 */
                                        8,8,6,6, /* 33-36 mxq8,8,6-6 */
                                        6,7,7,7  /* 37-40 mxq6,7,7,7 */
                                       };
static kt2_port_to_mxqblock_t *kt2_port_to_mxqblock[SOC_MAX_NUM_DEVICES]={NULL};

kt2_tdm_pos_info_t kt2_tdm_pos_info[KT2_MAX_MXQBLOCKS]={{0}};

/* typedef uint32 kt2_port_to_mxqblock_subports_t[KT2_MAX_PHYSICAL_PORTS]; */
kt2_port_to_mxqblock_subports_t kt2_port_to_mxqblock_subports_s={
                                                 0,1,2,3, /* 1-4   mxq0*/
                                                 0,1,2,3, /* 5-8   mxq1*/
                                                 0,1,2,3, /* 9-12  mxq2*/
                                                 0,1,2,3, /* 13-16 mxq3*/
                                                 0,1,2,3, /* 17-20 mxq4*/
                                                 0,1,2,3, /* 21-24 mxq5*/
                                                 0,0,0,0, /* 25-28 mxq6-9 */
                                                 1,2,3,1, /* 29-32 mxq9,9,9-8 */
                                                 2,3,1,2, /* 33-36 mxq8,8,6-6 */
                                                 3,1,2,3  /* 37-40 mxq6,7,7,7 */
                                                };
kt2_port_to_mxqblock_subports_t *kt2_port_to_mxqblock_subports[SOC_MAX_NUM_DEVICES]={NULL};

soc_field_t kt2_srcport_field_names[KT2_MAX_LOGICAL_PORTS]={
            SRCPORT_0f,  
            SRCPORT_1f,  SRCPORT_2f,  SRCPORT_3f,  SRCPORT_4f,  
            SRCPORT_5f,  SRCPORT_6f,  SRCPORT_7f,  SRCPORT_8f,  
            SRCPORT_9f,  SRCPORT_10f, SRCPORT_11f, SRCPORT_12f, 
            SRCPORT_13f, SRCPORT_14f, SRCPORT_15f, SRCPORT_16f, 
            SRCPORT_17f, SRCPORT_18f, SRCPORT_19f, SRCPORT_20f, 
            SRCPORT_21f, SRCPORT_22f, SRCPORT_23f, SRCPORT_24f, 
            SRCPORT_25f, SRCPORT_26f, SRCPORT_27f, SRCPORT_28f, 
            SRCPORT_29f, SRCPORT_30f, SRCPORT_31f, SRCPORT_32f, 
            SRCPORT_33f, SRCPORT_34f, SRCPORT_35f, SRCPORT_36f, 
            SRCPORT_37f, SRCPORT_38f, SRCPORT_39f, SRCPORT_40f,
            SRCPORT_41f
            };                 
uint8 kt2_tdm_update_flag=1;



uint32 kt2_tdm_0[78] = { 1,9,25,26,27,28,
                        17,2,25,26,27,28,
                        0,10,18,25,26,27,
                        28,3,11,25,26,27,
                        28,35,19,4,25,26,
                        27,28,12,20,25,26,
                        27,28,63,5,13,25,
                        26,27,28,21,6,25,
                        26,27,28,0,14,22,
                        25,26,27,28,7,15,
                        25,26,27,28,35,23,
                        8,25,26,27,28,16,
                        24,25,26,27,28,35
                      };


/* typedef uint32 kt2_mxqblock_ports_t[KT2_MAX_MXQBLOCKS]
                                      [KT2_MAX_MXQPORTS_PER_BLOCK]; */
kt2_mxqblock_ports_t kt2_mxqblock_ports_s=
             {{1,2,3,4},
              {5,6,7,8},
              {9,10,11,12},
              {13,14,15,16},
              {17,18,19,20},
              {21,22,23,24},
              {25,35,36,37},
              {26,38,39,40},
              {27,32,33,34},
              {28,29,30,31},
              {0xFF,0xFF,0xFF,0xFF},
             };
kt2_mxqblock_ports_t *kt2_mxqblock_ports[SOC_MAX_NUM_DEVICES]={NULL};

tdm_cycles_info_t kt2_tdm_cycles_info[KT2_MAX_TDM_FREQUENCY][KT2_MAX_SPEEDS]={
                  /*0:205MHz: 216 Used */
                  {{108,108,2},{56,54,4},{44,43,5},{11,11,20},
                   {9,9,24},{6,4,44},{6,4,44}},  

                  /*1:123MHz: 40Cycles Used*/
                  {{40,40,1},{33,20,2},{26,20,2},{6,6,6},
                   {5,4,8},{3,2,14},{3,2,14}},      

                  /*2:176MHz: 72 Used*/
                  {{84,84,1},{48,36,2},{39,36,2},{10,8,8},
                   {8,7,9},{5,3,15},{5,3,15}},  

                  /*3:176MHz: 60Cycles Used */
                  {{80,80,1},{48,30,2},{38,30 ,2 },{10,9,6},
                   {8,7,8},{5,4,12},{5,4,12}},  

                  /*4:176MHz: 90Cycles Used*/
                  {{90,90,1},{48,45,2},{38,30,3},{10,9,9}, 
                   {8,7,12},{5,4,18},{5,4,18}},  
                  /*5:205MHz: 108 Used */
                  {{108,108,1},{56,52,2},{44,34,3},{11,10,10},
                   {9,9,12},{5,4,21},{5,4,21}},  
                  /*6:205MHz: 88 Used */
                  {{88,88,1},{56,42,2},{44,42,2},{11,10,8},
                   {10,10,8},{5,4,16},{5,4,16}},
                  /*7:176MHz:64 Used */
                  {{64,64,1},{52,32,2},{41,32,2},{10,9,7},
                   {8,7,8},{5,4,13},{5,4,13}},
                  /*8:166MHz: 84 Used */
                  {{84,84,1},{52,42,2},{41,28,3},{10,9,9},
                   {8,6,12},{5,4,17},{5,4,17}},
                  /*9:205MHz: 176 Used */
                  {{88, 88, 2},
                   {44, 44, 4},{44, 44, 4},{11, 11, 16},
                   {9, 8, 20},{6, 4, 32},{6, 4, 32}},
                  /*10:205MHz: 88 Used */
                  {{88,88,1},{52,34,2},{52,34,2},{10,10,8},
                   {9,7,10},{5,4,16},{5,4,16}},
                  };

tdm_cycles_info_t kt2_current_tdm_cycles_info[KT2_MAX_SPEEDS]={{0}};

typedef struct tdm_port_slots_info_s  {
        int32                        position;
        struct tdm_port_slots_info_s *prev;
        struct tdm_port_slots_info_s *next;
}tdm_port_slots_info_t;

tdm_port_slots_info_t kt2_tdm_port_slots_info[KT2_MAX_LOGICAL_PORTS];

static uint32 *bcm56450_tdm[]={
               kt2_tdm_56450config_deprecated0,  /*56450 Cfg=0:IntCfg=0 */
               kt2_tdm_A_56450_1,                /*56450 Cfg=1:IntCfg=1 */ 
               kt2_tdm_A_56450_2,                /*56450 Cfg=2:IntCfg=2 */
               kt2_tdm_A_56450_3,                /*56450 Cfg=3:IntCfg=3 */
               kt2_tdm_A_56450_4,                /*56450 Cfg=4:IntCfg=4 */
               kt2_tdm_A_56450_5,                /*56450 Cfg=5:IntCfg=5 */
               kt2_tdm_A_56450_6,                /*56450 Cfg=6:IntCfg=6 */
               kt2_tdm_A_56450_7,                /*56450 Cfg=7:IntCfg=7 */
               kt2_tdm_A1_56450_8,               /*56450 Cfg=8:IntCfg=8 */
               kt2_tdm_A1A_56450_9,               /*56450 Cfg=9:IntCfg=9 */
               kt2_tdm_A2_56450_10,              /*56450 Cfg=10:IntCfg=10 */
               kt2_tdm_A2_56450_11,              /*56450 Cfg=11:IntCfg=11 */
               kt2_tdm_A3_56450_12,              /*56450 Cfg=12:IntCfg=12 */
               kt2_tdm_A2_56450_13,              /*56450 Cfg=13:IntCfg=13 */
               kt2_tdm_A1_56450_14,              /*56450 Cfg=14:IntCfg=14 */
               kt2_tdm_A4_56450_15,              /*56450 Cfg=15:IntCfg=15 */
               kt2_tdm_F_56450_16,               /*56450 Cfg=16:IntCfg=16 */
               kt2_tdm_C_56452_1,                /*56452 Cfg=1:IntCfg=17 */
               kt2_tdm_C1_56452_2,               /*56452   Cfg=2:IntCfg=18 */
               kt2_tdm_C1_56452_3,               /*56452   Cfg=3:IntCfg=19 */
               kt2_tdm_C1_56452_4,               /*56452   Cfg=4:IntCfg=20 */
               kt2_tdm_B_56452_5,                /*56452   Cfg=5:IntCfg=21 */
               kt2_tdm_B1_56452_6,               /*56452   Cfg=6:IntCfg=22 */
               kt2_tdm_B_56452_7,                /*56452   Cfg=7:IntCfg=23 */
               kt2_tdm_B_56452_8,                /*56452   Cfg=8:IntCfg=24 */
               kt2_tdm_B1_56452_9,               /*56452   Cfg=9:IntCfg=25 */
               kt2_tdm_B2_56452_10,              /*56452   Cfg=10:IntCfg=26 */
               kt2_tdm_D1_56454_1,               /*56454   Cfg=1:IntCfg=27 */
               kt2_tdm_D1_56454_2,               /*56454   Cfg=2:IntCfg=28 */
               kt2_tdm_C_56455_1,                /*56455   Cfg=1:IntCfg=29 */
               kt2_tdm_C_56455_2,                /*56455   Cfg=2:IntCfg=30 */
               kt2_tdm_56450config_deprecated0,  /*56248 Cfg=0:IntCfg=31 */
               kt2_tdm_A_56450_1,                /*56248 Cfg=1:IntCfg=32 */ 
               kt2_tdm_A_56450_2,                /*56248 Cfg=2:IntCfg=33 */
               kt2_tdm_A_56450_3,                /*56248 Cfg=3:IntCfg=34 */
               kt2_tdm_A_56450_4,                /*56248 Cfg=4:IntCfg=35 */
               kt2_tdm_A_56450_5,                /*56248 Cfg=5:IntCfg=36 */
               kt2_tdm_A_56450_6,                /*56248 Cfg=6:IntCfg=37 */
               kt2_tdm_A_56450_7,                /*56248 Cfg=7:IntCfg=38 */
               kt2_tdm_A1_56450_8,               /*56248 Cfg=8:IntCfg=39 */
               kt2_tdm_A1A_56450_9,               /*56248 Cfg=9:IntCfg=40 */
               kt2_tdm_A2_56450_10,              /*56248 Cfg=10:IntCfg=41 */
               kt2_tdm_A2_56450_11,              /*56248 Cfg=11:IntCfg=42 */
               kt2_tdm_A3_56450_12,              /*56248 Cfg=12:IntCfg=43 */
               kt2_tdm_A2_56450_13,              /*56248 Cfg=13:IntCfg=44 */
               kt2_tdm_A1_56450_14,              /*56248 Cfg=14:IntCfg=45 */
               kt2_tdm_A4_56450_15,              /*56248 Cfg=15:IntCfg=46 */
               kt2_tdm_A3_56248_16,              /*56248 Cfg=16:IntCfg=47 */
               kt2_tdm_D2_56248_17               /*56248 Cfg=17:IntCfg=48 */
#ifdef BCM_WARM_BOOT_SUPPORT
               ,kt2_scache_tdm[0] /*Dummy TDM reserved for WB */
#endif
};
const static uint32 *bcm56450_speed_s[]={
               kt2_tdm_56450speed_deprecated0,    /*56450 Cfg=0:IntCfg=0 */
               kt2_speed_56450_1,                 /*56450 Cfg=1:IntCfg=1 */ 
               kt2_speed_56450_2,                 /*56450 Cfg=2:IntCfg=2 */
               kt2_speed_56450_3,                 /*56450 Cfg=3:IntCfg=3 */
               kt2_speed_56450_4,                 /*56450 Cfg=4:IntCfg=4 */
               kt2_speed_56450_5,                 /*56450 Cfg=5:IntCfg=5 */
               kt2_speed_56450_6,                 /*56450 Cfg=6:IntCfg=6 */
               kt2_speed_56450_7,                 /*56450 Cfg=7:IntCfg=7 */
               kt2_speed_56450_8,                 /*56450 Cfg=8:IntCfg=8 */
               kt2_speed_56450_9,                 /*56450 Cfg=9:IntCfg=9 */
               kt2_speed_56450_10,                /*56450 Cfg=10:IntCfg=10 */
               kt2_speed_56450_11,                /*56450 Cfg=11:IntCfg=11 */
               kt2_speed_56450_12,                /*56450 Cfg=12:IntCfg=12 */
               kt2_speed_56450_13,                /*56450 Cfg=13:IntCfg=13 */
               kt2_speed_56450_14,                /*56450 Cfg=14:IntCfg=14 */
               kt2_speed_56450_15,                /*56450 Cfg=15:IntCfg=15 */
               kt2_speed_56450_16,                /*56450 Cfg=16:IntCfg=16 */
               kt2_speed_56452_1,                 /*56452 Cfg=1:IntCfg=17 */
               kt2_speed_56452_2,                 /*56452 Cfg=2:IntCfg=18 */
               kt2_speed_56452_3,                 /*56452   Cfg=3:IntCfg=19 */
               kt2_speed_56452_4,                 /*56452   Cfg=4:IntCfg=20 */
               kt2_speed_56452_5,                 /*56452   Cfg=5:IntCfg=20 */
               kt2_speed_56452_6,                 /*56452   Cfg=6:IntCfg=22 */
               kt2_speed_56452_7,                 /*56452   Cfg=7:IntCfg=23 */
               kt2_speed_56452_8,                 /*56452   Cfg=8:IntCfg=24 */
               kt2_speed_56452_9,                 /*56452   Cfg=9:IntCfg=25 */
               kt2_speed_56452_10,                /*56452   Cfg=10:IntCfg=26 */
               kt2_speed_56454_1,                 /*56454   Cfg=1:IntCfg=27 */
               kt2_speed_56454_2,                 /*56454   Cfg=2:IntCfg=28 */
               kt2_speed_56455_1,                 /*56455   Cfg=1:IntCfg=29 */
               kt2_speed_56455_2,                 /*56455   Cfg=2:IntCfg=30 */
               kt2_tdm_56450speed_deprecated0,    /*56248 Cfg=0:IntCfg=31 */
               kt2_speed_56450_1,                 /*56248 Cfg=1:IntCfg=32 */ 
               kt2_speed_56450_2,                 /*56248 Cfg=2:IntCfg=33 */
               kt2_speed_56450_3,                 /*56248 Cfg=3:IntCfg=34 */
               kt2_speed_56450_4,                 /*56248 Cfg=4:IntCfg=35 */
               kt2_speed_56450_5,                 /*56248 Cfg=5:IntCfg=36 */
               kt2_speed_56450_6,                 /*56248 Cfg=6:IntCfg=37 */
               kt2_speed_56450_7,                 /*56248 Cfg=7:IntCfg=38 */
               kt2_speed_56450_8,                 /*56248 Cfg=8:IntCfg=39 */
               kt2_speed_56450_9,                 /*56248 Cfg=9:IntCfg=40 */
               kt2_speed_56450_10,                /*56248 Cfg=10:IntCfg=41 */
               kt2_speed_56450_11,                /*56248 Cfg=11:IntCfg=42 */
               kt2_speed_56450_12,                /*56248 Cfg=12:IntCfg=43 */
               kt2_speed_56450_13,                /*56248 Cfg=13:IntCfg=44 */
               kt2_speed_56450_14,                /*56248 Cfg=14:IntCfg=45 */
               kt2_speed_56450_15,                /*56248 Cfg=15:IntCfg=46 */
               kt2_speed_56248_16,                /*56248 Cfg=16:IntCfg=47 */
               kt2_speed_56248_17                 /*56248 Cfg=17:IntCfg=48 */
#ifdef BCM_WARM_BOOT_SUPPORT
               ,kt2_scache_speed[0] /* Dummy speed reserved for WB*/
#endif
};
static kt2_speed_t *bcm56450_speed[SOC_MAX_NUM_DEVICES]={NULL};

const static soc_port_details_t  *kt2_port_details[]={
               kt2_port_details_deprecated0,      /*56450 Cfg=0:IntCfg=0 */
               kt2_port_details_56450_1,          /*56450 Cfg=1:IntCfg=1 */ 
               kt2_port_details_56450_2,          /*56450 Cfg=2:IntCfg=2 */
               kt2_port_details_56450_3,          /*56450 Cfg=3:IntCfg=3 */
               kt2_port_details_56450_4,          /*56450 Cfg=4:IntCfg=4 */
               kt2_port_details_56450_5,          /*56450 Cfg=5:IntCfg=5 */
               kt2_port_details_56450_6,          /*56450 Cfg=6:IntCfg=6 */
               kt2_port_details_56450_7,          /*56450 Cfg=7:IntCfg=7 */
               kt2_port_details_56450_8,          /*56450 Cfg=8:IntCfg=8 */
               kt2_port_details_56450_9,          /*56450 Cfg=9:IntCfg=9 */
               kt2_port_details_56450_10,         /*56450 Cfg=10:IntCfg=10 */
               kt2_port_details_56450_11,         /*56450 Cfg=11:IntCfg=11 */
               kt2_port_details_56450_12,         /*56450 Cfg=12:IntCfg=12 */
               kt2_port_details_56450_13,         /*56450 Cfg=13:IntCfg=13 */
               kt2_port_details_56450_14,         /*56450 Cfg=14:IntCfg=14 */
               kt2_port_details_56450_15,         /*56450 Cfg=15:IntCfg=15 */
               kt2_port_details_56450_16,         /*56450 Cfg=16:IntCfg=16 */
               kt2_port_details_56452_1,          /*56452 Cfg=1:IntCfg=17 */
               kt2_port_details_56452_2,          /*56452   Cfg=2:IntCfg=18 */
               kt2_port_details_56452_3,          /*56452   Cfg=3:IntCfg=19 */
               kt2_port_details_56452_4,          /*56452   Cfg=4:IntCfg=20 */
               kt2_port_details_56452_5,          /*56452   Cfg=5:IntCfg=21 */
               kt2_port_details_56452_6,          /*56452   Cfg=6:IntCfg=22 */
               kt2_port_details_56452_7,          /*56452   Cfg=7:IntCfg=23 */
               kt2_port_details_56452_8,          /*56452   Cfg=8:IntCfg=24 */
               kt2_port_details_56452_9,          /*56452   Cfg=9:IntCfg=25 */
               kt2_port_details_56452_10,         /*56452   Cfg=10:IntCfg=26 */
               kt2_port_details_56454_1,          /*56454   Cfg=1:IntCfg=27 */
               kt2_port_details_56454_2,          /*56454   Cfg=2:IntCfg=28 */
               kt2_port_details_56455_1,          /*56455   Cfg=1:IntCfg=29 */
               kt2_port_details_56455_2,          /*56455   Cfg=2:IntCfg=30 */
               kt2_port_details_deprecated0,      /*56248 Cfg=0:IntCfg=31 */
               kt2_port_details_56450_1,          /*56248 Cfg=1:IntCfg=32 */ 
               kt2_port_details_56450_2,          /*56248 Cfg=2:IntCfg=33 */
               kt2_port_details_56450_3,          /*56248 Cfg=3:IntCfg=34 */
               kt2_port_details_56450_4,          /*56248 Cfg=4:IntCfg=35 */
               kt2_port_details_56450_5,          /*56248 Cfg=5:IntCfg=36 */
               kt2_port_details_56450_6,          /*56248 Cfg=6:IntCfg=37 */
               kt2_port_details_56450_7,          /*56248 Cfg=7:IntCfg=38 */
               kt2_port_details_56450_8,          /*56248 Cfg=8:IntCfg=39 */
               kt2_port_details_56450_9,          /*56248 Cfg=9:IntCfg=40 */
               kt2_port_details_56450_10,         /*56248 Cfg=10:IntCfg=41 */
               kt2_port_details_56450_11,         /*56248 Cfg=11:IntCfg=42 */
               kt2_port_details_56450_12,         /*56248 Cfg=12:IntCfg=43 */
               kt2_port_details_56450_13,         /*56248 Cfg=13:IntCfg=44 */
               kt2_port_details_56450_14,         /*56248 Cfg=14:IntCfg=45 */
               kt2_port_details_56450_15,         /*56248 Cfg=15:IntCfg=46 */
               kt2_port_details_56248_16,         /*56248 Cfg=16:IntCfg=47 */
               kt2_port_details_56248_17          /*56248 Cfg=17:IntCfg=48 */
#ifdef BCM_WARM_BOOT_SUPPORT
               /* Dummy port details reserved for WB */
               ,kt2_scache_port_details[0]
#endif
};
static bcm56450_tdm_info_t bcm56450_tdm_info[]={
               {205, 88, 8, 11},                     /*56450 Cfg=0:IntCfg=0 */
               {205, 88, 8, 11},                     /*56450 Cfg=1:IntCfg=1 */ 
               {205, 88, 8, 11},                     /*56450 Cfg=2:IntCfg=2 */
               {205, 88, 8, 11},                     /*56450 Cfg=3:IntCfg=3 */
	       {205, 88, 8, 11},                     /*56450 Cfg=4:IntCfg=4 */
               {205, 88, 8, 11},                     /*56450 Cfg=5:IntCfg=5 */
               {205, 88, 8, 11},                     /*56450 Cfg=6:IntCfg=6 */
               {205, 88, 8, 11},                     /*56450 Cfg=7:IntCfg=7 */
              {205, BCM_KT2_TDM_A1_NUM_SLOTS, 16, 11},/*56450 Cfg=8:IntCfg=8 */
               {205, 108, 12, 9},                    /*56450 Cfg=9:IntCfg=9 */
               {205, 216, 24, 9},                    /*56450 Cfg=10:IntCfg=10 */
               {205, 216, 24, 9},                    /*56450 Cfg=11:IntCfg=11 */
               {205, 88, 8, 11},                    /*56450 Cfg=12:IntCfg=12 */
               {205, 216, 24, 9},                    /*56450 Cfg=13:IntCfg=13 */
              {205, BCM_KT2_TDM_A1_NUM_SLOTS, 16, 11},/*56450 Cfg=14:IntCfg=14 */
              {205, BCM_KT2_TDM_A4_NUM_SLOTS, 8, 11}, /*56450 Cfg=15:IntCfg=15 */
               {205, 88, 8, 11},                     /*56450 Cfg=16:IntCfg=16 */
               {166, 84, 12, 7},                     /*56452 Cfg=1:IntCfg=17 */
               {176, 64, 8, 8},                      /*56452 Cfg=2:IntCfg=18 */
               {176, 64, 8, 8},                      /*56452 Cfg=3:IntCfg=19 */
               {176, 64, 8, 8},                      /*56452 Cfg=4:IntCfg=20 */
               {176, 90, 10, 9},                     /*56452 Cfg=5:IntCfg=21 */
               {176, 60, 6, 10},                     /*56452 Cfg=6:IntCfg=22 */
               {176, 90, 10, 9},                     /*56452 Cfg=7:IntCfg=23 */
               {176, 90, 10, 9},                     /*56452 Cfg=8:IntCfg=24 */
               {176, 60, 6, 10},                     /*56452 Cfg=9:IntCfg=25 */
               {176, 72, 8, 9},                      /*56452 Cfg=10:IntCfg=26 */
               {123, 40, 8, 5},                      /*56454 Cfg=1:IntCfg=27 */
               {123, 40, 8, 5},                      /*56454 Cfg=2:IntCfg=28 */
               {166, 84, 12, 7},                     /*56455 Cfg=1:IntCfg=29 */
               {166, 84, 12, 7},                     /*56455 Cfg=2:IntCfg=30 */
               {205, 88, 8, 11},                     /*56248 Cfg=0:IntCfg=31 */
               {205, 88, 8, 11},                     /*56248 Cfg=1:IntCfg=32 */ 
               {205, 88, 8, 11},                     /*56248 Cfg=2:IntCfg=33 */
               {205, 88, 8, 11},                     /*56248 Cfg=3:IntCfg=34 */
               {205, 88, 8, 11},                     /*56248 Cfg=4:IntCfg=35 */
               {205, 88, 8, 11},                     /*56248 Cfg=5:IntCfg=36 */
               {205, 88, 8, 11},                     /*56248 Cfg=6:IntCfg=37 */
               {205, 88, 8, 11},                     /*56248 Cfg=7:IntCfg=38 */
              {205, BCM_KT2_TDM_A1_NUM_SLOTS, 16, 11},/*56248 Cfg=8:IntCfg=39 */
               {205, 108, 12, 9},                    /*56248 Cfg=9:IntCfg=40 */
               {205, 216, 24, 9},                    /*56248 Cfg=10:IntCfg=41 */
               {205, 216, 24, 9},                    /*56248 Cfg=11:IntCfg=42 */
               {205,  88, 12, 9},                    /*56248 Cfg=12:IntCfg=43 */
               {205, 216, 24, 9},                    /*56248 Cfg=13:IntCfg=44 */
              {205, BCM_KT2_TDM_A1_NUM_SLOTS, 16, 11},/*56450 Cfg=14:IntCfg=14 */
              {205, BCM_KT2_TDM_A4_NUM_SLOTS, 8, 11}, /*56248 Cfg=15:IntCfg=46 */
               {205, 88, 8, 11},                     /*56248 Cfg=16:IntCfg=47 */
               {123, 40, 8, 5}                       /*56248 Cfg=16:IntCfg=48 */
#ifdef BCM_WARM_BOOT_SUPPORT
               ,{0,0,0,0}   /*kt2_scache_tdm_info *//*Dummy:Reserved for WB  */
#endif
}; 

#ifdef UNDER_TESTING
char tdm_config_string[80]={0};
/* 4xGE(1..4) 2xF-XAUI(5,9) 2xF-HG[13](25,26) 2x21G[G.INT](27,28) */
uint32 kt2_tdm_56450_test_speed0[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4 */
       10000,0000 ,0000 ,0000,     /* 5 - 8 */
       10000,0000 ,0000 ,0000,     /* 9 - 12 */
       0000 ,0000 ,0000 ,0000,     /* 13 - 16 */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20 */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24 */
       13000,13000,21000,21000,    /* 25 - 28 */
       0,    0,    0,    0,        /* 29 - 32 */
       0,    0,    0,    0,        /* 33 - 36 */
       0,    0,    0,    0};       /* 37 - 40 */

/* 24xGE(1..24) 2xF-HG[13](25,26) 2x21G[G.INT](27,28) */
uint32 kt2_tdm_56450_test_speed1[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4 */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8 */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12 */
       1000 ,1000 ,1000 ,1000,     /* 13 - 16 */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20 */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24 */
       13000,13000,21000,21000,    /* 25 - 28 */
       0,    0,    0,    0,        /* 29 - 32 */
       0,    0,    0,    0,        /* 33 - 36 */
       0,    0,    0,    0};       /* 37 - 40 */

/* 16x 2.5G(1..8 25,26,35..40) + 2x HG21(27..28)  */
uint32 kt2_tdm_56450_test_speed2[40]= {
       2500,2500,2500 ,2500 ,     /* 1 - 4 */
       2500,2500,2500 ,2500 ,     /* 5 - 8 */
       0000,0000,0000 ,0000 ,     /* 9 - 12 */
       0000,0000,0000 ,0000 ,     /* 13 - 16 */
       0000,0000,0000 ,0000 ,     /* 17 - 20 */
       0000,0000,0000 ,0000 ,     /* 21 - 24 */
       2500,2500,21000,21000,     /* 25 - 28 */
       0000,0000,0000 ,0000 ,     /* 29 - 32 */
       0000,0000,2500 ,2500 ,     /* 33 - 36 */
       2500,2500,2500 ,2500 };    /* 37 - 40 */

/* 24x GE(1..24) 8*2.5GE (25..26,35..40) + 2x HG21(27..28)  */
uint32 kt2_tdm_56450_test_speed3[40]= {
       1000,1000,1000 ,1000 ,     /* 1 - 4   */
       1000,1000,1000 ,1000 ,     /* 5 - 8   */
       1000,1000,1000 ,1000 ,     /* 9 - 12  */
       1000,1000,1000 ,1000 ,     /* 13 - 16 */
       1000,1000,1000 ,1000 ,     /* 17 - 20 */
       1000,1000,1000 ,1000 ,     /* 21 - 24 */
       2500,2500,21000,21000,     /* 25 - 28 */
       0000,0000,0000 ,0000 ,     /* 29 - 32 */
       0000,0000,2500 ,2500 ,     /* 33 - 36 */
       2500,2500,2500 ,2500 };    /* 37 - 40 */

/* 24x GE(1..24) 16*2.5GE (25..40) */
uint32 kt2_tdm_56450_test_speed4[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       1000,1000,1000,1000,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       1000,1000,1000,1000,     /* 13 - 16 */
       1000,1000,1000,1000,     /* 17 - 20 */
       1000,1000,1000,1000,     /* 21 - 24 */
       2500,2500,2500,2500,     /* 25 - 28 */
       2500,2500,2500,2500,     /* 29 - 32 */
       2500,2500,2500,2500,     /* 33 - 36 */
       2500,2500,2500,2500};    /* 37 - 40 */

/* 12x GE(1..4,5..8,17..20) 12*2.5GE (5..8,13..16,21..24),4*10G(25..28) */
uint32 kt2_tdm_56450_test_speed5[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       2500,2500,2500,2500,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       2500,2500,2500,2500,     /* 13 - 16 */
       1000,1000,1000,1000,     /* 17 - 20 */
       2500,2500,2500,2500,     /* 21 - 24 */
       10000,10000,10000,10000,     /* 25 - 28 */
       0000,0000,0000,0000,     /* 29 - 32 */
       0000,0000,0000,0000,     /* 33 - 36 */
       0000,0000,0000,0000};    /* 37 - 40 */

/* 8*10G(1,5,9,13,17,21,25,26) */
uint32 kt2_tdm_56450_test_speed6[40]= {
       10000,0000,0000,0000,     /* 1 - 4   */
       10000,0000,0000,0000,     /* 5 - 8   */
       10000,0000,0000,0000,     /* 9 - 12  */
       10000,0000,0000,0000,     /* 13 - 16 */
       10000,0000,0000,0000,     /* 17 - 20 */
       10000,0000,0000,0000,     /* 21 - 24 */
       10000,10000,0000,0000,     /* 25 - 28 */
       0000,0000,0000,0000,     /* 29 - 32 */
       0000,0000,0000,0000,     /* 33 - 36 */
       0000,0000,0000,0000};    /* 37 - 40 */

/* 24* 2G(1..24) 4*10G(25..28) */
uint32 kt2_tdm_56450_test_speed7[40]= {
       2000,2000,2000,2000,     /* 1 - 4   */
       2000,2000,2000,2000,     /* 5 - 8   */
       2000,2000,2000,2000,     /* 9 - 12  */
       2000,2000,2000,2000,     /* 13 - 16 */
       2000,2000,2000,2000,     /* 17 - 20 */
       2000,2000,2000,2000,     /* 21 - 24 */
       10000,10000,10000,10000,     /* 25 - 28 */
       0000,0000,0000,0000,     /* 29 - 32 */
       0000,0000,0000,0000,     /* 33 - 36 */
       0000,0000,0000,0000};    /* 37 - 40 */

/* 24*GE(1..24) 4*13G(25..28) */
uint32 kt2_tdm_56450_test_speed8[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       1000,1000,1000,1000,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,1000,1000,     /* 17 - 20  */
       1000,1000,1000,1000,     /* 21 - 24  */
       13000,13000,13000,13000,     /* 25- 28 */
       00,00,00,00,     /* 29 - 32  */
       00,00,00,00,     /* 33 - 36  */
       00,00,00,00};     /* 37 - 40  */

/* 18*GE(1..18) 6*2.5G(19..24) 4*13G(25..28) */
uint32 kt2_tdm_56450_test_speed9[40]= {
       1000,1000,1000,1000,     /* 1 - 4   */
       1000,1000,1000,1000,     /* 5 - 8   */
       1000,1000,1000,1000,     /* 9 - 12  */
       1000,1000,1000,1000,     /* 13 - 16  */
       1000,1000,2500,2500,     /* 17 - 20  */
       2500,2500,2500,2500,     /* 21 - 24  */
       13000,13000,13000,13000,     /* 25- 28 */
       00,00,00,00,     /* 29 - 32  */
       00,00,00,00,     /* 33 - 36  */
       00,00,00,00};     /* 37 - 40  */


/* 4xGE + 2x F-XAUI + 2x F-HG[13] + 2x F-HG[21] */
uint32 kt2_tdm_56450_test_speed10[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       10000,0000 ,0000 ,0000,     /* 5 - 8   */
       10000,0000 ,0000 ,0000,     /* 9 - 12  */
       0000 ,0000 ,0000 ,0000,     /* 13 - 16  */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       13000,13000,21000,21000,     /* 25- 28 */
       00,00,00,00,     /* 29 - 32  */
       00,00,00,00,     /* 33 - 36  */
       00,00,00,00};     /* 37 - 40  */

/* 8xGE + 16x 2.5GE + 8x2.5G-HGL + 8x2.5G[G.INT] */
uint32 kt2_tdm_56450_test_speed11[40]= {
       1000 ,1000 ,2500 ,2500,     /* 1 - 4   */
       1000 ,1000 ,2500 ,2500,     /* 5 - 8   */
       1000 ,1000 ,2500 ,2500,     /* 9 - 12  */
       1000 ,1000 ,2500 ,2500,     /* 13 - 16  */
       2500 ,2500 ,2500 ,2500,     /* 17 - 20  */
       2500 ,2500 ,2500 ,2500,     /* 21 - 24  */
       2500 ,2500 ,2500 ,2500,     /* 25- 28 */
       2500 ,2500 ,2500 ,2500,     /* 29 - 32  */
       2500 ,2500 ,2500 ,2500,     /* 33 - 36  */
       2500 ,2500 ,2500 ,2500};     /* 37 - 40  */

/* 8xGE + 8x XFI / 8x F-XAUI / 4x F-XAUI + 4x XFI */
uint32 kt2_tdm_56450_test_speed12[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       10000 ,0000 ,0000 ,0000,     /* 9 - 12  */
       10000 ,0000 ,0000 ,0000,     /* 13- 16  */
       10000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       10000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       10000 ,10000 ,10000 ,10000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 2*13G + 2*21G + 24*G */
uint32 kt2_tdm_56450_test_speed13[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,0000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,0000,     /* 13- 16  */
       1000 ,1000 ,1000 ,0000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,0000,     /* 21 - 24  */
       13000 ,13000 ,21000 ,21000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 24x GE + 4x HG[13]  */
uint32 kt2_tdm_56450_test_speed14[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,1000,     /* 13- 16  */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24  */
       13000 ,13000 ,13000 ,13000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 24x GE + 4x XAUI / 16x 2.5G */
uint32 kt2_tdm_56450_test_speed15[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,1000,     /* 13- 16  */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24  */
       10000 ,10000 ,10000 ,10000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 24x GE + 16x 2.5G */
uint32 kt2_tdm_56450_test_speed16[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       1000 ,1000 ,1000 ,1000,     /* 9 - 12  */
       1000 ,1000 ,1000 ,1000,     /* 13- 16  */
       1000 ,1000 ,1000 ,1000,     /* 17 - 20  */
       1000 ,1000 ,1000 ,1000,     /* 21 - 24  */
       2500 ,2500 ,2500 ,2500,     /* 25 - 28 */
       2500 ,2500 ,2500 ,2500,     /* 29 - 32 */
       2500 ,2500 ,2500 ,2500,     /* 33 - 36  */
       2500 ,2500 ,2500 ,2500};     /* 37 - 40  */

/* 8x GE + 2  * 10G */
uint32 kt2_tdm_56450_test_speed17[40]= {
       1000 ,1000 ,1000 ,1000,     /* 1 - 4   */
       1000 ,1000 ,1000 ,1000,     /* 5 - 8   */
       0000 ,0000 ,0000 ,0000,     /* 9 - 12  */
       0000 ,0000 ,0000 ,0000,     /* 13- 16  */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       10000 ,10000 ,0000 ,0000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 4x 2.5GE + 1  * 13G 1 * 10G */
uint32 kt2_tdm_56450_test_speed18[40]= {
       2500 ,2500 ,2500 ,0000,     /* 1 - 4   */
       0000 ,0000 ,0000 ,0000,     /* 5 - 8   */
       0000 ,0000 ,0000 ,0000,     /* 9 - 12  */
       0000 ,0000 ,0000 ,0000,     /* 13- 16  */
       0000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       0000 ,0000 ,0000 ,0000,     /* 21 - 24  */   
       13000 ,10000 ,0000 ,0000,     /* 25 - 28 */
       0000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */

/* 4x 2.5GE + 4  * 1g */
uint32 kt2_tdm_56450_test_speed19[40]= {
       2500 ,0000 ,0000 ,0000,     /* 1 - 4   */
       2500 ,0000 ,0000 ,0000,     /* 5 - 8   */
       2500 ,0000 ,0000 ,0000,     /* 9 - 12  */
       2500 ,0000 ,0000 ,0000,     /* 13- 16  */
       1000 ,0000 ,0000 ,0000,     /* 17 - 20  */
       1000 ,0000 ,0000 ,0000,     /* 21 - 24  */
       1000 ,0000 ,0000 ,0000,     /* 25 - 28 */
       1000 ,0000 ,0000 ,0000,     /* 29 - 32 */
       0000 ,0000 ,0000 ,0000,     /* 33 - 36  */
       0000 ,0000 ,0000 ,0000};     /* 37 - 40  */










uint32 kt2_tdm_under_testing[90]= {KT2_IDLE};
uint32 kt2_tdm_under_testing_idle[180]= {KT2_IDLE};
#endif

/* *************************************************************** */
/* KATANA2 MMU HELPER  --- START(As per Katana2_MMU_Setting_v8.xls */
/* *************************************************************** */
/* Dynamic/SetLater Parameter */
typedef struct _soc_kt2_mmu_params {
               uint32 mmu_min_pkt_size;                   /*C5*/
               uint32 mmu_ethernet_mtu_bytes;             /*C6*/
               uint32 mmu_max_pkt_size;                   /*C7*/
               uint32 mmu_jumbo_frame_size;               /*C8*/
               uint32 mmu_int_buf_cell_size;              /*C9*/
               /* mmu_ext_buf_cell_size = (mmu_int_buf_cell_size+2)*15;   */
               uint32 mmu_ext_buf_cell_size;              /*C10=2880*/
               uint32 mmu_pkt_header_size;                /*C11*/
               uint32 packing_mode_d_c;                   /* C12:Dynamic */
               uint32 max_pkt_size_support_packing;        /* C13:Dynamic */
               uint32 lossless_mode_d_c;                  /* C14:Dynamic */
               uint32 pfc_pause_mode_d_c;                 /* C15:Dynamic */
               uint32 mmu_lossless_pg_num;                /*C16*/
               uint32 extbuf_used_d_c;                    /* C17:Dynamic */
               uint32 num_ge_ports_d;                     /* C19:Dynamic */
               uint32 mmu_line_rate_ge;                   /*C20*/
               uint32 num_ge_int_ports_d;                 /* C21:Dynamic */
               uint32 num_egr_queue_per_int_ge_port_d;    /* C22:Dynamic */
               uint32 num_ge_ext_ports_d;                 /* C23:Dynamic */
               uint32 num_egr_queue_per_ext_ge_port_d;    /* C24:Dynamic */
               uint32 num_hg_ports_d;                     /* C25:Dynamic */
               uint32 mmu_line_rate_hg;                   /*C26*/
               uint32 num_hg_int_ports_d;                 /* C27:Dynamic */
               uint32 num_egr_queue_per_int_hg_port_d;    /* C28:Dynamic */
               uint32 num_hg_ext_ports_d;                 /* C29:Dynamic */
               uint32 num_egr_queue_per_ext_hg_port_d;    /* C30:Dynamic */
               uint32 mmu_num_cpu_port;                   /*C31*/
               uint32 mmu_num_cpu_queue;                  /*C32*/
               uint32 cpu_port_int_ext_bounding_d_c;      /* C33:Dynamic */
               uint32 mmu_num_loopback_port;              /*C34*/
               uint32 mmu_num_loopback_queue;             /*C35*/
               uint32 mmu_num_ep_redirection_queue;       /*C36*/
               uint32 mmu_num_olp_port_d;                 /*C37*/
               uint32 mmu_num_olp_queue;                  /*C38*/
               uint32 olp_port_int_ext_bounding_d_c;      /* C39:Dynamic */
               uint32 mmu_int_buf_size;                   /*C41:2048KB=2MB*/
               uint32 mmu_available_int_buf_size_d;       /*C42:1434KB */
               uint32 mmu_reserved_int_buf_cells;         /*C43:100 Cells */
               uint32 mmu_reserved_int_buf_ema_pool_size_d; /*C44:614KB */
               uint32 internal_buffer_reduction_d_c;        /* C45:Dynamic */
               uint32 mmu_ext_buf_size;                   /*C46*/
               uint32 mmu_egress_queue_entries;           /*C47*/
               uint32 mmu_ep_redirect_queue_entries;      /*C48*/
               uint32 mmu_exp_num_of_repl_per_pkt;        /*C49*/
               uint32 mmu_repl_engine_work_queue_entries; /*C50*/
               uint32 mmu_repl_engine_work_queue_in_device;/*C51*/
               uint32 mmu_ema_queues;                     /*C52*/
/*
float  kt2_baf_profile_indexes[]={0.015625,0.03125,0.0625,
                                  0.125,0.25,0.5,1.0,2.0,4.0,8.0};
 */
               uint32 num_cells_rsrvd_ing_ext_buf;        /* C54:Dynamic */     
               uint32 per_cos_res_cells_for_int_buff_d;   /* C55:Dynamic */
               uint32 per_cos_res_cells_for_ext_buff_d;   /* C56:Dynamic */
               uint32 mmu_ing_port_dyn_thd_param;         /*C57*/
               uint32 mmu_ing_pg_dyn_thd_param;           /*C58*/
               uint32 mmu_egr_queue_dyn_thd_param;        /*C59*/
               uint32 mmu_egr_pg_dyn_thd_param;           /*C60*/
               uint32 mmu_ing_cell_buf_reduction;         /*C61 */
               uint32 mmu_ing_pkt_buf_reduction;          /*C62 */
} _soc_kt2_mmu_params_t;
_soc_kt2_mmu_params_t _soc_kt2_mmu_params={0};

typedef struct _general_info {
    uint32 max_packet_size_in_cells;                         /* C68 */
    uint32 jumbo_frame_for_int_buff;                         /* C69 */
    uint32 jumbo_frame_for_ext_buff;                         /* C70 */
    uint32 ether_mtu_cells_for_int_buff;                     /* C72 */
    uint32 ether_mtu_cells_for_ext_buff;                     /* C73 */
    uint32 total_num_of_ports;                               /* C75 */
    uint32 total_num_of_ports_excl_lpbk;                     /* C76 */
    uint32 total_num_of_ports_excl_lpbk_olp;                 /* C77 */
    uint32 total_num_of_ports_excl_lpbk_olp_cpu;             /* C78 */
    uint32 port_bw_bound_to_ext_buff;                        /* C79 */
    uint32 total_egr_queues_for_a_int_ge_ports;              /* C80 */
    uint32 total_egr_queues_for_a_ext_ge_ports;              /* C81 */
    uint32 total_egr_queues_for_a_int_hg_ports;              /* C82 */
    uint32 total_egr_queues_for_a_ext_hg_ports;              /* C83 */
    uint32 total_cpu_queues;                                 /* C84 */
    uint32 total_int_buff_queues;                            /* C85 */
    uint32 total_ext_buff_queues;                            /* C86 */
    uint32 total_ema_queues;                                 /* C87 */
    uint32 total_egr_queues_in_device;                       /* C90 */
    uint32 max_int_cell_buff_size;                           /* C91 */
    uint32 int_cell_buff_size_after_limitation;              /* C92 */
    uint32 src_packing_fifo;                                 /* C93 */
    uint32 int_buff_pool;                                    /* C94 */
    uint32 ema_pool;                                         /* C95 */
    uint32 max_ext_cell_buff_size;                           /* C96 */
    uint32 ratio_of_ext_buff_to_int_buff_size;               /* C99 */
    uint32 int_buff_cells_per_avg_size_pkt;                  /* C100 */
    uint32 ext_buff_cells_per_avg_size_pkt;                  /* C101 */
    uint32 max_prop_of_buff_used_by_one_queue_port;          /* C102*/
}_general_info_t;

typedef struct _input_port_threshold_t {
    uint32 global_hdrm_cells_for_int_buff_pool;              /* C107 */
    uint32 global_hdrm_cells_for_ext_buff_pool;              /* C108 */
    uint32 global_hdrm_cells_for_RE_WQEs;                    /* C109 */
    uint32 global_hdrm_cells_for_EQEs;                       /* C110 */

    uint32 hdrm_int_buff_cells_for_10G_PG;                   /* C112 */
    uint32 hdrm_ext_buff_cells_for_10G_PG;                   /* C113 */
    uint32 hdrm_RE_WQEs_pkts_for_10G_PG;                     /* C114 */
    uint32 hdrm_EQEs_pkts_for_10G_PG;                        /* C115 */

    uint32 hdrm_int_buff_cells_for_10G_total_PG;             /* C117 */
    uint32 hdrm_ext_buff_cells_for_10G_total_PG;             /* C118 */
    uint32 hdrm_RE_WQEs_pkts_for_10G_total_PG;               /* C119 */
    uint32 hdrm_EQEs_pkts_for_10G_total_PG;                  /* C120 */

    uint32 hdrm_int_buff_cells_for_1G_PG;                    /* C122 */
    uint32 hdrm_ext_buff_cells_for_1G_PG;                    /* C123 */
    uint32 hdrm_RE_WQEs_pkts_for_1G_PG;                      /* C124 */
    uint32 hdrm_EQEs_pkts_for_1G_PG;                         /* C125 */

    uint32 hdrm_int_buff_cells_for_1G_total_PG;              /* C127 */
    uint32 hdrm_ext_buff_cells_for_1G_total_PG;              /* C128 */
    uint32 hdrm_RE_WQEs_pkts_for_1G_total_PG;                /* C129 */
    uint32 hdrm_EQEs_pkts_for_1G_total_PG;                   /* C130 */

    uint32 hdrm_int_buff_cells_for_olp_port;                 /* C132 */
    uint32 hdrm_ext_buff_cells_for_olp_port;                 /* C133 */
    uint32 hdrm_RE_WQEs_pkts_for_olp_port;                   /* C134 */
    uint32 hdrm_EQEs_pkts_for_olp_port;                      /* C135 */

    uint32 hdrm_int_buff_cells_for_lpbk_port;                /* C137 */
    uint32 hdrm_ext_buff_cells_for_lpbk_port;                /* C138 */
    uint32 hdrm_RE_WQEs_pkts_for_lpbk_port;                  /* C139 */
    uint32 hdrm_EQEs_pkts_for_lpbk_port;                     /* C140 */

    uint32 hdrm_int_buff_cells_for_cpu_port;                 /* C142 */
    uint32 hdrm_ext_buff_cells_for_cpu_port;                 /* C143 */
    uint32 hdrm_RE_WQEs_pkts_for_cpu_port;                   /* C144 */
    uint32 hdrm_EQEs_pkts_for_cpu_port;                      /* C145 */

    uint32 total_hdrm_int_buff_cells;                        /* C147 */
    uint32 total_hdrm_int_buff_ema_pool_cells;               /* C148 */
    uint32 total_hdrm_ext_buff_cells;                        /* C149 */
    uint32 total_hdrm_RE_WQEs_pkts;                          /* C150 */
    uint32 total_hdrm_EQEs_pkts;                             /* C151 */

    uint32 min_int_buff_cells_per_PG;                        /* C153 */
    uint32 min_int_buff_ema_pool_cells_per_PG;               /* C154 */
    uint32 min_ext_buff_cells_per_PG;                        /* C155 */
    uint32 min_RE_WQEs_pkt_per_PG;                           /* C156 */
    uint32 min_EQEs_pkt_per_PG;                              /* C157 */

    uint32 min_int_buff_cells_for_total_PG;                  /* C159 */
    uint32 min_int_buff_ema_pool_cells_for_total_PG;         /* C160 */
    uint32 min_ext_buff_cells_for_total_PG;                  /* C161 */
    uint32 min_RE_WQEs_pkts_for_total_PG;                    /* C162 */
    uint32 min_EQEs_pkts_for_total_PG;                       /* C163 */

    uint32 min_int_buff_cells_for_a_port;                    /* C165 */
    uint32 min_int_buff_ema_pool_cells_for_a_port;           /* C166 */
    uint32 min_ext_buff_cells_for_a_port;                    /* C167 */
    uint32 min_RE_WQEs_pkts_for_a_port;                      /* C168 */
    uint32 min_EQEs_pkts_for_a_port;                         /* C169 */

    uint32 min_int_buff_cells_for_total_port;                /* C171 */
    uint32 min_int_buff_ema_pool_cells_for_total_port;       /* C172 */
    uint32 min_ext_buff_cells_for_total_port;                /* C173 */
    uint32 min_RE_WQEs_pkts_for_total_port;                  /* C174 */
    uint32 min_EQEs_pkts_for_total_port;                     /* C175 */

    uint32 total_min_int_buff_cells;                         /* C177 */
    uint32 total_min_int_buff_ema_pool_cells;                /* C178 */
    uint32 total_min_ext_buff_cells;                         /* C179 */
    uint32 total_min_RE_WQEs_pkts;                           /* C180 */
    uint32 total_min_EQEs_pkts;                              /* C181 */

    uint32 total_shared_ing_buff_pool;                       /* C183 */
    uint32 total_shared_EMA_buff;                            /* C184 */
    uint32 total_shared_ext_buff;                            /* C185 */
    uint32 total_shared_RE_WQEs_buff;                        /* C186 */
    uint32 total_shared_EQEs_buff;                           /* C187 */

    uint32 ingress_burst_cells_size_for_one_port;            /* C189 */
    uint32 ingress_burst_pkts_size_for_one_port;             /* C190 */
    uint32 ingress_burst_cells_size_for_all_ports;           /* C191 */
    uint32 ingress_total_shared_cells_use_for_all_port;      /* C192 */
    uint32 ingress_burst_pkts_size_for_all_port;             /* C193 */
    uint32 ingress_total_shared_pkts_use_for_all_port;       /* C194 */
    uint32 ingress_total_shared_hdrm_cells_use_for_all_port; /* C195 */
    uint32 ingress_total_shared_hdrm_pkts_use_for_all_port;  /* C196 */

}_input_port_threshold_t;

typedef struct _output_port_threshold_t {
    uint32 min_grntd_res_queue_cells_int_buff;               /* C201 */
    uint32 min_grntd_res_queue_cells_ext_buff;               /* C202 */
    uint32 min_grntd_res_queue_cells_EQEs;                   /* C203 */
    uint32 min_grntd_res_EMA_queue_cells;                    /* C204 */
    uint32 min_grntd_res_RE_WQs_cells;                       /* C205 */
    uint32 min_grntd_res_RE_WQs_queue_cells_for_int_buff;    /* C206 */
    uint32 min_grntd_res_RE_WQs_queue_cells_for_ext_buff;    /* C207 */
    uint32 min_grntd_res_EP_redirect_queue_entry_cells;      /* C208 */

    uint32 min_grntd_tot_res_queue_cells_int_buff;           /* C210 */
    uint32 min_grntd_tot_res_queue_cells_ext_buff;           /* C211 */
    uint32 min_grntd_tot_res_queue_cells_EQEs;               /* C212 */
    uint32 min_grntd_tot_res_EMA_queue_cells;                /* C213 */
    uint32 min_grntd_tot_res_RE_WQs_cells;                   /* C214 */
    uint32 min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff;/* C215 */
    uint32 min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff;/* C216 */
    uint32 min_grntd_tot_res_EP_redirect_queue_entry_cells;  /* C217 */

    uint32 min_grntd_tot_shr_queue_cells_int_buff;           /* C219 */
    uint32 min_grntd_tot_shr_queue_cells_ext_buff;           /* C220 */
    uint32 min_grntd_tot_shr_queue_cells_EQEs;               /* C221 */
    uint32 min_grntd_tot_shr_EMA_queue_cells;                /* C222 */
    uint32 min_grntd_tot_shr_RE_WQs_cells;                   /* C223 */
    uint32 min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff;/* C224 */
    uint32 min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff;/* C225 */
    uint32 min_grntd_tot_shr_EP_redirect_queue_entry_cells;  /* C226 */

    uint32 egress_queue_dynamic_threshold_parameter;         /* C227 */
    uint32 egress_burst_cells_size_for_one_queue;            /* C228 */
    uint32 egress_burst_pkts_size_for_one_queue;             /* C229 */
    uint32 egress_burst_cells_size_for_all_ports;            /* C230 */
    uint32 egress_burst_pkts_size_for_all_ports;             /* C231 */
    uint32 egress_burst_cells_size_for_all_queues;           /* C232 */
    uint32 egress_burst_pkts_size_for_all_queues;            /* C233 */
    uint32 egress_total_use_in_cells_for_all_queues;         /* C234 */
    uint32 egress_total_use_in_pkts_for_all_queues;          /* C235 */
    uint32 egress_remaining_cells_for_all_queues;            /* C236 */
    uint32 egress_remaining_pkts_for_all_queues;             /* C237 */

}_output_port_threshold_t;

typedef struct _soc_kt2_mmu_intermediate_results {
    _general_info_t           general_info;
    _input_port_threshold_t   input_port_threshold;
    _output_port_threshold_t  output_port_threshold;
}_soc_kt2_mmu_intermediate_results_t;
_soc_kt2_mmu_intermediate_results_t _soc_kt2_mmu_intermediate_results={{0}};

static soc_ser_functions_t _kt2_ser_functions;
static soc_oam_event_functions_t _kt2_oam_event_functions;

#ifdef BCM_WARM_BOOT_SUPPORT
static
void _soc_kt2_mem_config_set(int unit, char *config_str, char *config_value);
#endif
void _soc_kt2_mem_config(int unit);

typedef enum {
    _SOC_COUNTER_TYPE_DROP_ENQ,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ,
    _SOC_COUNTER_TYPE_DROP_ENQ_GREEN,
    _SOC_COUNTER_TYPE_DROP_ENQ_YELLOW,
    _SOC_COUNTER_TYPE_DROP_ENQ_RED,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ_YELLOW,
    _SOC_COUNTER_TYPE_ACCEPT_ENQ_RED,
    _SOC_COUNTER_TYPE_ACCEPT_DEQ,
    _SOC_COUNTER_TYPE_MAX
} _soc_katana2_counter_type_t;

typedef struct _soc_katana2_counter_info_s {
    _soc_katana2_counter_type_t type;
    int index;
    int segment;
} _soc_katana2_counter_info_t;

STATIC _soc_katana2_counter_info_t _soc_katana2_counter_info[] = {
    { _SOC_COUNTER_TYPE_DROP_ENQ, 0x0, 0 },
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ, 0x0, 0 },
    /* green pkt drops, index = ACCEPT=1'b0, COLOR=2'b00 */
    { _SOC_COUNTER_TYPE_DROP_ENQ_GREEN, 0x0, 0 },
    /* yellow pkt drops, index = ACCEPT=1'b0, COLOR=2'b11 */
    { _SOC_COUNTER_TYPE_DROP_ENQ_YELLOW, 0x3, 0 },
    /* red pkt drops, index = ACCEPT=1'b0, COLOR=2'b01 */
    { _SOC_COUNTER_TYPE_DROP_ENQ_RED, 0x1, 0 },
    /* green accepted pkts, index = ACCEPT=1'b1, COLOR=2'b00 */
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN, 0x4, 0 },
    /* yellow accepted pkts, index = ACCEPT=1'b1, COLOR=2'b11 */
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ_YELLOW, 0x7, 0 },
    /* red accepted pkts, index = ACCEPT=1'b1, COLOR=2'b01 */
    { _SOC_COUNTER_TYPE_ACCEPT_ENQ_RED, 0x5, 0 },
    { _SOC_COUNTER_TYPE_ACCEPT_DEQ, 0, 0 }
};

#define _SOC_WC40_RX_LANE_MAP_DEFAULT 0x3210 
#define _SOC_UNICORE_RX_LANE_MAP_DEFAULT 0x0123 

int 
_soc_kt2_l1_port_mx_lane_map_init(int unit) 
{ 
    bcm_port_t port; 
    uint32 default_lane_map, lane_map; 
    int mxqblk_update[KT2_MAX_MXQBLOCKS] = {0,0,0,0,0,0,0,0,0,0};
    int mxqblock_port;
   
    for (port = 1; port < COUNTOF(_kt2_l1_port_mx_lane_map); port++) { 
        uint32 i, mxqblock, mxqblock_i, lane[4]; 

        mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
        if (mxqblk_update[mxqblock] == 1) {
            continue;
        }
        /* Get lane map, if it is default value, then go to next */ 
        default_lane_map = _kt2_l1_port_mx_lane_map[port].unicore_or_warpcore ?
                        _SOC_WC40_RX_LANE_MAP_DEFAULT : _SOC_UNICORE_RX_LANE_MAP_DEFAULT;
        lane_map = soc_property_port_get(unit, port, 
                                      spn_XGXS_RX_LANE_MAP, default_lane_map);
        if (lane_map == default_lane_map) { 
            continue; 
        } 
     
        /* Decouple the lane number for lane map */ 
        for (i = 0; i < 4; i++) { 
            if (_kt2_l1_port_mx_lane_map[port].unicore_or_warpcore) { 
                lane[i] = (lane_map >> (i*4)) & 0xf; 
            } else { 
                 lane[i] = (lane_map >> ((3-i)*4)) & 0xf; 
            } 
        } 
         
        /* set _kt2_l1_port_mx_lane_map based on lane map */
        for (i = 0; i < 4; i++) { 
             mxqblock_port = (*kt2_mxqblock_ports[unit])[mxqblock][i];
             /* coverity[overrun-local : FALSE] */
             mxqblock_i = (*kt2_port_to_mxqblock[unit])[mxqblock_port-1];
             if (mxqblock_i != mxqblock) {
                 /*Don't remap if port+i belongs to different block*/
                 break;
             }

             /* coverity[overrun-local : FALSE] */
            _kt2_l1_port_mx_lane_map[mxqblock_port].lane_num = lane[i];
        }
        /*Update each block only once*/  
        mxqblk_update[mxqblock] = 1; 
    } 
    return BCM_E_NONE; 
} 

#define KT2_MAX_SERVICE_POOLS 4
#define KT2_MAX_PRIORITY_GROUPS 8

soc_error_t _katana2_get_wc_phy_info(int unit, 
                                    soc_port_t port,
                                    uint8 *phy_mode)
{
  bcmMxqCorePortMode_t mode = bcmMxqCorePortModeSingle;
  char *intf_type = NULL;
  uint32 rxaui = 0;
  soc_info_t *si;
  bcmMxqPhyPortMode_t p_mode = bcmMxqPhyPortModeSingle;

  *phy_mode = PHYCTRL_QUAD_LANE_PORT; /* XAUI */
  si = &SOC_INFO(unit);

  if (IS_GE_PORT(unit, port)) {
      LOG_VERBOSE(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,"\n GE port so forced Single Lane GMII\n")));
      if (si->port_speed_max[port] == 2500) {
          SOC_IF_ERROR_RETURN(
              soc_katana2_get_phy_port_mode(unit, port, 2500, &p_mode));
              *phy_mode = (p_mode == bcmMxqPhyPortModeDual)? PHYCTRL_SINGLE_LANE_IN_DUAL_PORT_MODE : PHYCTRL_ONE_LANE_PORT;
      } else {
          *phy_mode = PHYCTRL_ONE_LANE_PORT;
      }
      return SOC_E_NONE;
  }
  if (IS_HG_PORT(unit, port)) {
      LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                  "\n HG port so Forced Four Lanes XGMII \n")));
      *phy_mode = PHYCTRL_QUAD_LANE_PORT;
      return SOC_E_NONE;
  }
  if (IS_XE_PORT(unit, port)) {
      SOC_IF_ERROR_RETURN(
          soc_katana2_get_core_port_mode(unit, port, &mode));
      if (mode == bcmMxqCorePortModeQuad) {
          LOG_WARN(BSL_LS_SOC_COMMON,
                   (BSL_META_U(unit,
                   "\n Internal Error. 4 XE ports not possible \n")));
          return SOC_E_INTERNAL;
      }
      LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                  "\n Checking %s config setting \n"), spn_SERDES_IF_TYPE));
      intf_type= soc_property_port_get_str(unit, port, spn_SERDES_IF_TYPE);

      if (intf_type != NULL) {
          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                      "\n As per %s config setting \n"), spn_SERDES_IF_TYPE));
          if ((sal_strcmp(intf_type, "XAUI") == 0) ||
              (sal_strcmp(intf_type, "xaui") == 0)) {
              if (mode == bcmMxqCorePortModeSingle) {
                  *phy_mode = PHYCTRL_QUAD_LANE_PORT;
                  return SOC_E_NONE;
              } else {
                  LOG_WARN(BSL_LS_SOC_COMMON,
                           (BSL_META_U(unit,
                           "Discarded XAUI setting.Faliing through\n")));
              }
          }
          if ((sal_strcmp(intf_type, "RXAUI") == 0) ||
              (sal_strcmp(intf_type, "rxaui") == 0)) {
              *phy_mode = PHYCTRL_DUAL_LANE_PORT;
              return SOC_E_NONE;
          }
          if ((sal_strcmp(intf_type, "XFI") == 0) ||
              (sal_strcmp(intf_type, "xfi") == 0)) {
              *phy_mode = PHYCTRL_ONE_LANE_PORT;
              return SOC_E_NONE;
          }
          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                       "\n Interface Type: %s "
                       "Supports only XAUI,RXAUI & XFI so falling through"),
                       intf_type));
      } 
      LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                  "\n Checking %s config setting \n"), spn_SERDES_RXAUI_MODE));
      rxaui =  soc_property_port_get(unit, port, 
                                     spn_SERDES_RXAUI_MODE, 0xFF);
      if ((rxaui == 0) || (rxaui == 1)) {
           LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                       "\nAs per %s config setting\n"), spn_SERDES_RXAUI_MODE));
           if (rxaui == 1) {
               *phy_mode = PHYCTRL_DUAL_LANE_PORT; /* Reduced XAUI */
           } else {
               *phy_mode = PHYCTRL_QUAD_LANE_PORT; /* XAUI */
           }
           return SOC_E_NONE;
      } 
      if (rxaui == 0xFF) { /* Not defined */
          if (mode == bcmMxqCorePortModeDual) {
               LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                           "\n Two XE ports so Could be either RXAUI/XFI"
                           "\n so assuing XFI \n")));
               *phy_mode = PHYCTRL_ONE_LANE_PORT; /* XFI */
               return SOC_E_NONE;
          }
          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
             "\nOne XE ports so decision as per original config=%s setting\n"),
             spn_PORTGROUP));
          return SOC_E_EMPTY; /* Not Sure what to do */

          /* if (mode == bcmMxqCorePortModeSingle)  */
          /* Fall through and go as per original setting */
      }
  }
  return SOC_E_NONE;
}

STATIC int
soc_flex_io_operation_status_get(int unit, int *flex_io_operation_ongoing)
{

  SOC_FLEXIO_LOCK;
  *flex_io_operation_ongoing = flex_io_operation_busy[unit];
  SOC_FLEXIO_UNLOCK;
  return SOC_E_NONE;
}

int soc_flex_io_operation_status_set(int unit, int value)
{
  SOC_FLEXIO_LOCK;
  flex_io_operation_busy[unit] = value;
  SOC_FLEXIO_UNLOCK;
  return SOC_E_NONE;
}

soc_error_t katana2_get_wc_phy_info(int unit, 
                                    soc_port_t port,
                                    uint8 *lane_num, 
                                    uint8 *phy_mode, 
                                    uint8 *chip_num)
{
  uint32 mxqblock=0;
  uint32 num_lanes=0;
  bcmMxqConnection_t connection=bcmMqxConnectionUniCore;
  soc_error_t rv = SOC_E_NONE;
  int flex_io_operation_ongoing = 0;

  /*
     pc->chip_num = 0;
     pc->lane_num = 0;
     pc->phy_mode = PHYCTRL_ONE_LANE_PORT | 
                    PHYCTRL_DUAL_LANE_PORT | 
                    PHYCTRL_QUAD_LANE_PORT;
  */ 
  mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
  if ((mxqblock == 6) || (mxqblock == 7)) {
      /* Check XFI mode then */
      SOC_IF_ERROR_RETURN(soc_katana2_get_phy_connection_mode(
                          unit,port,mxqblock,&connection));
      if (connection == bcmMqxConnectionUniCore) {
          return SOC_E_PARAM;
      }
      if (mxqblock == 6) {
          *chip_num = 0;
      } else {
          *chip_num = 1;
      }
      *lane_num = (((*kt2_port_to_mxqblock_subports[unit])[port-1])+1);
  } else {
  if (!((mxqblock == 8)  || (mxqblock == 9))) {
      return SOC_E_PARAM;
  }
  if (mxqblock == 8) {
      *chip_num = 0;
  } else {
      *chip_num = 1;
  }
  *lane_num = (*kt2_port_to_mxqblock_subports[unit])[port-1];
  }
  soc_flex_io_operation_status_get(unit, &flex_io_operation_ongoing);

#ifdef BCM_WARM_BOOT_SUPPORT
  if (SOC_WARM_BOOT(unit)) {
      /* Phy info can be different after flexport warmboot */
      flex_io_operation_ongoing = 1;
  }
#endif

  if (flex_io_operation_ongoing) {
      rv = _katana2_get_wc_phy_info(unit, port, phy_mode);
      if (rv != SOC_E_EMPTY) {
          return rv;
      }
  }


  LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
              "Checking config %s settings \n"), spn_PORTGROUP));
  num_lanes = soc_property_port_get(unit, port, spn_PORTGROUP, 0);
  switch(num_lanes) {
  case 1: *phy_mode = PHYCTRL_ONE_LANE_PORT;
          break;
  case 2: *phy_mode = PHYCTRL_DUAL_LANE_PORT;
          break;
  case 4: *phy_mode = PHYCTRL_QUAD_LANE_PORT;
          break;
  default: 
          if (!flex_io_operation_ongoing) {
              rv =  _katana2_get_wc_phy_info(unit, port, phy_mode);
              if (rv == SOC_E_EMPTY) {
                  LOG_WARN(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                  "\nWARN:Unpredictable results could be observed "
                  "\nPlease use below serdes config variables for WC port:%d\n"
                  "either serdes_rxaui_mode, portgroup or serdes_if_type\n"),
                   port));
              }
          }
  }
  return SOC_E_NONE;
}

/* kt2_mmu_ext_buf_cell_size = (kt2_mmu_int_buf_cell_size+2)*15;*/
STATIC 
uint32 ceil_func(uint32 numerators , uint32 denominator)
{
    uint32  result;
    if (denominator == 0) {
        return 0xFFFFFFFF;
    }
    result = numerators / denominator;
    if (numerators % denominator != 0) {
        result++; 
    }
    return result;
}
STATIC 
uint32 floor_func(uint32 numerators , uint32 denominator)
{
    uint32  result;
    if (denominator == 0) {
        return 0xFFFFFFFF;
    }
    result = numerators / denominator;
/*
    if (numerators % denominator != 0) {
        result--; 
    }
*/
    return result;
}
STATIC 
int _soc_katana2_mmu_config_extra_queue(int unit, uint32 queue)
{
     mmu_thdo_qconfig_cell_entry_t       mmu_thdo_qconfig_cell_entry={{0}};
     mmu_thdo_qoffset_cell_entry_t       mmu_thdo_qoffset_cell_entry={{0}};
     mmu_thdo_qconfig_qentry_entry_t     mmu_thdo_qconfig_qentry_entry={{0}};
     mmu_thdo_qoffset_qentry_entry_t     mmu_thdo_qoffset_qentry_entry={{0}};
     /* 1. MMU_THDO_QCONFIG_CELL */
     SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_CELLm(unit,
                         MEM_BLOCK_ANY, queue, 
                         &mmu_thdo_qconfig_cell_entry));
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                         &mmu_thdo_qconfig_cell_entry, 
                         Q_MIN_CELLf, 0);
     /* output_port_threshold->min_grntd_res_queue_cells_int_buff);*/
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                         &mmu_thdo_qconfig_cell_entry, 
                         Q_SHARED_LIMIT_CELLf, 7);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                         &mmu_thdo_qconfig_cell_entry, 
                         Q_LIMIT_DYNAMIC_CELLf, 1);
     /* _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1); */
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                         &mmu_thdo_qconfig_cell_entry, 
                         Q_LIMIT_ENABLE_CELLf, 1);
     /* _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1); */
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                         &mmu_thdo_qconfig_cell_entry, 
                         Q_COLOR_ENABLE_CELLf,0);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                         &mmu_thdo_qconfig_cell_entry, 
                         Q_COLOR_LIMIT_DYNAMIC_CELLf, 1);
     /* _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1); */
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                         &mmu_thdo_qconfig_cell_entry, 
                         LIMIT_YELLOW_CELLf, 0);
     SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_CELLm(unit,
                         MEM_BLOCK_ALL, queue, 
                         &mmu_thdo_qconfig_cell_entry));

     /* 2. MMU_THDO_QOFFSET_CELL */
     SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_CELLm(unit,
                         MEM_BLOCK_ANY,queue, &mmu_thdo_qoffset_cell_entry));
     soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                         &mmu_thdo_qoffset_cell_entry, 
                         RESET_OFFSET_CELLf,2);
     soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                         &mmu_thdo_qoffset_cell_entry, 
                         RESET_OFFSET_YELLOW_CELLf, 2);
     soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                         &mmu_thdo_qoffset_cell_entry, 
                         RESET_OFFSET_RED_CELLf, 2);
     SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_CELLm(unit,
                         MEM_BLOCK_ALL,queue, &mmu_thdo_qoffset_cell_entry));

     /* 3. MMU_THDO_QCONFIG_QENTRY */
     SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_QENTRYm(unit,
                         MEM_BLOCK_ANY,queue, &mmu_thdo_qconfig_qentry_entry));
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm,
                         &mmu_thdo_qconfig_qentry_entry, 
                         Q_MIN_QENTRYf, 0);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm,
                         &mmu_thdo_qconfig_qentry_entry, 
                         Q_SHARED_LIMIT_QENTRYf, 7);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm,
                         &mmu_thdo_qconfig_qentry_entry, 
                         Q_LIMIT_DYNAMIC_QENTRYf, 1);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm,
                         &mmu_thdo_qconfig_qentry_entry, 
                         Q_LIMIT_ENABLE_QENTRYf, 1);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm,
                         &mmu_thdo_qconfig_qentry_entry, 
                         Q_COLOR_ENABLE_QENTRYf, 0);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm,
                         &mmu_thdo_qconfig_qentry_entry, 
                         Q_COLOR_LIMIT_DYNAMIC_QENTRYf, 1);
     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm,
                         &mmu_thdo_qconfig_qentry_entry, 
                         LIMIT_YELLOW_QENTRYf, 1);
     SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_QENTRYm(unit,
                         MEM_BLOCK_ALL,queue, &mmu_thdo_qconfig_qentry_entry));

     /* 4. MMU_THDO_QOFFSET_QENTRY */
     SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_QENTRYm(unit,
                         MEM_BLOCK_ANY,queue, &mmu_thdo_qoffset_qentry_entry));
     soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm,
                         &mmu_thdo_qoffset_qentry_entry, 
                         RESET_OFFSET_QENTRYf, 1);
     soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm,
                         &mmu_thdo_qoffset_qentry_entry, 
                         RESET_OFFSET_YELLOW_QENTRYf, 1);
     soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm,
                         &mmu_thdo_qoffset_qentry_entry, 
                         RESET_OFFSET_RED_QENTRYf, 1);
     SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_QENTRYm(unit,
                         MEM_BLOCK_ALL,queue, &mmu_thdo_qoffset_qentry_entry));
     return SOC_E_NONE;
}

int
_soc_kt2_packing_port_config_set(int unit, bcm_port_t port, int set)
{
    uint32 mode = 0;
    mmu_toq_qpack_mode_entry_t qpack_entry;
    pbmp_t ext_pbmp;
    uint32 *bmap;
    int  word, word_count, bit;
    int index = 0;

    ext_pbmp = soc_property_get_pbmp(unit, spn_PBMP_EXT_MEM, 0);
    if (SOC_PBMP_MEMBER(ext_pbmp, port)) {
        bmap = SOC_CONTROL(unit)->port_lls_l2_bmap[port];
        word_count = _SHR_BITDCLSIZE(soc_mem_index_count(unit, LLS_L2_PARENTm));
        for (word = 0; word < word_count; word++) {
            if (bmap[word] == 0) {
                continue;
            }
            for (bit = 0; bit < SHR_BITWID; bit++) {
                if (!(bmap[word] & (1 << bit))) {
                    continue;
                }
                index = word * SHR_BITWID + bit;
                SOC_IF_ERROR_RETURN
                    (READ_MMU_TOQ_QPACK_MODEm(unit, MEM_BLOCK_ALL,
                                              index/16, &qpack_entry));
                soc_mem_field_get(unit, MMU_TOQ_QPACK_MODEm,
                        (uint32 *)&qpack_entry,
                        QMODEf, &mode);

                if (set) {
                    mode |= (1 << (index % 16));
                } else {
                    mode &= ~(1 << (index % 16));
                }

                soc_mem_field32_set(unit, MMU_TOQ_QPACK_MODEm,
                        &qpack_entry, QMODEf, mode);
                SOC_IF_ERROR_RETURN
                    (WRITE_MMU_TOQ_QPACK_MODEm(unit, MEM_BLOCK_ALL,
                                               index/16, &qpack_entry));
            }
        }
    }
    return BCM_E_NONE;
}

int
_soc_katana2_mmu_init_ext_mem_dyn_port(int unit,int port)
{
    uint32 rval=0;
    soc_info_t *si= &SOC_INFO(unit);
    int depth = 0;
    int thereshold = 0;
    uint8 mxqblock=0;
    soc_pbmp_t my_pbmp_xport_xe;
    int num_lanes = 0;
    int speed = 0;
    uint8 loop;
    uint8 try_loop;
    int mxqblock_port;
    uint32 rval1 = 0;
    uint32 rval2 = 0;
    uint32 start_addr = 0;
    uint32 end_addr = 0;
    txlp_port_addr_map_table_entry_t txlp_port_addr_map_table_entry={{0}};
    soc_field_t mmu_intf_reset_fld[] = {
        XQ0_MMU_INTF_RESETf, XQ1_MMU_INTF_RESETf,
        XQ2_MMU_INTF_RESETf, XQ3_MMU_INTF_RESETf,
        XQ4_MMU_INTF_RESETf, XQ5_MMU_INTF_RESETf,
        XQ6_MMU_INTF_RESETf, XQ7_MMU_INTF_RESETf};
    uint32 try_count = 0;
    soc_timeout_t to = {0};
    sal_usecs_t timeout_usec = 100000;
    int min_polls = 100;

    SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(
                        unit,port,&mxqblock));
    for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK;loop++) {
         mxqblock_port=(*kt2_mxqblock_ports[unit])[mxqblock][loop];
         if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), mxqblock_port)) {
             if (!(IS_CPU_PORT(unit,mxqblock_port) || IS_LB_PORT(unit,
                 mxqblock_port))) {
                 SOC_PBMP_CLEAR(my_pbmp_xport_xe);
                 my_pbmp_xport_xe = soc_property_get_pbmp_default(unit,
                                    spn_PBMP_XPORT_XE, my_pbmp_xport_xe);
                 SOC_IF_ERROR_RETURN(_bcm_kt2_port_lanes_get(unit,
                                     mxqblock_port, &num_lanes));
                 if((SOC_PBMP_MEMBER(my_pbmp_xport_xe, mxqblock_port)) &&
                    ((mxqblock == 8) || (mxqblock == 9))) {
                    speed = (*mxqspeeds[unit])[mxqblock][num_lanes - 1];
                 }
             }
             if (speed == 0) {
                 speed = si->port_speed_max[mxqblock_port];
             }
             SOC_IF_ERROR_RETURN(READ_DEQ_EFIFO_CFGr(unit, mxqblock_port,
                                                     &rval));
             if (speed <= 1000) {
                 depth = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 10 : 2;
                 thereshold = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 8 : 0;
             } else if (speed <= 2500) {
                 depth = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 14 : 2;
                 thereshold = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 12 : 0;
             } else if (speed <= 13000) {
                 depth = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 56 : 10;
                 thereshold = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 49 : 0;
             } else { /* > 13G */
                 depth = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 112 : 16;
                 thereshold = (IS_EXT_MEM_PORT(unit, mxqblock_port)) ? 85 : 0;
             }
             if ((IS_EXT_MEM_PORT(unit, mxqblock_port)) &&
                 !(PBMP_MEMBER(si->linkphy_pbm, mxqblock_port))) {
                 soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval,
                                   EGRESS_FIFO_XMIT_OVERSPEED_RATE_LIMITERf, 1);
             } else {
                 soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval,
                                   EGRESS_FIFO_XMIT_OVERSPEED_RATE_LIMITERf, 0);
             }
             soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval,
                               EGRESS_FIFO_XMIT_THRESHOLDf, thereshold);
             soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval,
                               EGRESS_FIFO_DEPTHf, depth);
             if (SOC_PBMP_MEMBER(si->linkphy_pbm, mxqblock_port)) {
                 soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval,
                                   EGRESS_FIFO_LINK_PHYf, 1);
             }
             SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFGr(unit, mxqblock_port,
                                                      rval));
             SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase4_port(unit,
                                 mxqblock_port));
             /* Port BW Ctrl */
             SOC_IF_ERROR_RETURN(READ_TOQ_PORT_BW_CTRLr(unit, mxqblock_port,
                                                        &rval));
             if (IS_CPU_PORT(unit,mxqblock_port) || IS_LB_PORT(unit,
                 mxqblock_port)) {
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   PORT_BWf, 50);
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   START_THRESHOLDf, 127);
             } else if (speed >= 10000) {
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   PORT_BWf, 500);
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   START_THRESHOLDf, 34);
             } else if (speed == 2500) {
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   PORT_BWf, 125);
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   START_THRESHOLDf, 19);
             } else {
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   PORT_BWf, 50);
                 soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval,
                                   START_THRESHOLDf, 7);
             }
             SOC_IF_ERROR_RETURN(WRITE_TOQ_PORT_BW_CTRLr(unit, mxqblock_port,
                                                         rval));
         } else {
             if (SOC_PORT_VALID(unit, mxqblock_port)) {
                 SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFGr(unit, mxqblock_port,
                                                          0));
                 SOC_IF_ERROR_RETURN(WRITE_TOQ_PORT_BW_CTRLr(unit,
                                                             mxqblock_port, 0));
             }
         }
    }
    /* WORK-AROUND for port-flushing i.e. need to repeat below step twice */
    for (try_loop = 0; try_loop < 2; try_loop++) {
         /* EP Reset */
         if (SAL_BOOT_SIMULATION) {
             BCM_IF_ERROR_RETURN(WRITE_DYNAMIC_PORT_RECFG_VECTOR_CFG_31_00r(
                                 unit, 0));
             BCM_IF_ERROR_RETURN(WRITE_DYNAMIC_PORT_RECFG_VECTOR_CFG_41_32r(
                                 unit, 0));
         }
         for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK;loop++) {
              mxqblock_port=(*kt2_mxqblock_ports[unit])[mxqblock][loop];
              if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), mxqblock_port)) {
                  if (mxqblock_port <= 31) {
                      rval1 |= (1 << mxqblock_port);
                  } else {
                      rval2 |= (1 << (mxqblock_port-32));
                  }
              }
         }
         BCM_IF_ERROR_RETURN(WRITE_DYNAMIC_PORT_RECFG_VECTOR_CFG_31_00r(
                             unit, rval1));
         BCM_IF_ERROR_RETURN(WRITE_DYNAMIC_PORT_RECFG_VECTOR_CFG_41_32r(
                             unit, rval2));
         if (SAL_BOOT_SIMULATION) {
             BCM_IF_ERROR_RETURN(WRITE_DYNAMIC_PORT_RECFG_VECTOR_CFG_31_00r(
                                 unit, 0));
             BCM_IF_ERROR_RETURN(WRITE_DYNAMIC_PORT_RECFG_VECTOR_CFG_41_32r(
                                 unit, 0));
         }
         try_count = 0;
         do {
             soc_timeout_init(&to, timeout_usec, min_polls);
             if(soc_timeout_check(&to)) {
                 LOG_ERROR(BSL_LS_BCM_PORT,
                         (BSL_META_U(unit,
                                     "TimeOut InternalError\n")));
                 return BCM_E_INTERNAL;
             }
             try_count++;
             BCM_IF_ERROR_RETURN(READ_DYNAMIC_PORT_RECFG_VECTOR_CFG_31_00r(
                                 unit, &rval1));
             BCM_IF_ERROR_RETURN(READ_DYNAMIC_PORT_RECFG_VECTOR_CFG_41_32r(
                                 unit, &rval2));
             if ((rval1 == 0) && (rval2 == 0)) {
                 break;
             }
         } while (try_count != 3);
         if (try_count == 3) {
             return BCM_E_TIMEOUT;
         }
    }

    if (mxqblock <= 7) {
        READ_EDATABUF_DBG_MMU_INTF_RESETr(unit, &rval);
        soc_reg_field_set(unit, EDATABUF_DBG_MMU_INTF_RESETr,
                          &rval,  mmu_intf_reset_fld[mxqblock], 1);
        WRITE_EDATABUF_DBG_MMU_INTF_RESETr(unit, rval);
        READ_EDATABUF_DBG_MMU_INTF_RESETr(unit, &rval);
        soc_reg_field_set(unit, EDATABUF_DBG_MMU_INTF_RESETr,
                          &rval,  mmu_intf_reset_fld[mxqblock], 0);
        WRITE_EDATABUF_DBG_MMU_INTF_RESETr(unit, rval);
    }
    if ((mxqblock >= 8) && (mxqblock <= 9)) {
        for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK;loop++) {
             sal_memset(&txlp_port_addr_map_table_entry,0,
                        sizeof(txlp_port_addr_map_table_entry_t));
             mxqblock_port=(*kt2_mxqblock_ports[unit])[mxqblock][loop];
             if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), mxqblock_port)) {
                 /*  As each cell-occupies "4" lines in buffer, [end-start+1]
                     must be a integral multiple of "4". */
                 if (si->port_speed_max[mxqblock_port]<= 2500) {
                     end_addr = start_addr + (( 6 * 4) - 1); /* 6 Cells */
                 } else if (si->port_speed_max[mxqblock_port] <= 10000) {
                     end_addr = start_addr + ((12 * 4) - 1); /* 12 Cells */
                 } else if (si->port_speed_max[mxqblock_port] <= 13000) {
                     end_addr = start_addr + ((16 * 4) - 1); /* 16 Cells */
                 } else if (si->port_speed_max[mxqblock_port] <= 21000) {
                     end_addr = start_addr + ((20 * 4) - 1); /* 20 Cells */
                 }
                 soc_TXLP_PORT_ADDR_MAP_TABLEm_field_set(unit,
                       &txlp_port_addr_map_table_entry,START_ADDRf,&start_addr);
                 soc_TXLP_PORT_ADDR_MAP_TABLEm_field_set(unit,
                       &txlp_port_addr_map_table_entry,END_ADDRf,&end_addr);
                 start_addr = end_addr+1;
             }
             BCM_IF_ERROR_RETURN(WRITE_TXLP_PORT_ADDR_MAP_TABLEm(
                                 unit,SOC_INFO(unit).txlp_block[mxqblock-8],
                                 loop, &txlp_port_addr_map_table_entry));
        }
    }
    return SOC_E_NONE;
}


/* Dynamic Helper function for MMU settings based on
 * memory selection (internal/external) 
 * The memory selection is done using port config property bcmPortControlBufferExternalEnable 
 */
int _soc_katana2_mmu_init_helper_dyn(int unit, int port, int ext_mem_enable)
{
    uint32        op_node=0;
    uint32        port_max_opnodes = 0;
    uint8         port_index = 0;
    soc_pbmp_t    valid_port_cpu_pbmp;
    uint8 port_list[]={KT2_CMIC_PORT, KT2_LPBK_PORT ,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
        11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
        21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
        31, 32, 33, 34, 35, 36, 37, 38, 39, 40};
    soc_port_t    port_iter=0;
    soc_info_t    *si= &SOC_INFO(unit); 
    uint32        op_node_offset=0;
    mmu_thdo_opnconfig_cell_entry_t     mmu_thdo_opnconfig_cell_entry={{0}};
    uint32        temp_val;
    uint32        queue;
    mmu_thdo_qconfig_cell_entry_t       mmu_thdo_qconfig_cell_entry={{0}};
    mmu_thdo_qoffset_cell_entry_t       mmu_thdo_qoffset_cell_entry={{0}};
    _output_port_threshold_t *output_port_threshold =
        &_soc_kt2_mmu_intermediate_results.output_port_threshold;
    _general_info_t *general_info = 
        &_soc_kt2_mmu_intermediate_results.general_info;
#if defined (INCLUDE_L3)
    uint32 entry[SOC_MAX_MEM_FIELD_WORDS];
    int ipmc_id;
#endif
    uint32 *bmap;
    int  word, word_count, bit;

    uint32   ext_mem_port_count = 0;
    uint32   mem_idx=0;
    uint32   rval=0;
    uint32   service_pool=0;
    uint32   priority_group=0;
    thdi_port_sp_config_entry_t thdi_port_sp_config={{0}};
    thdi_port_pg_config_entry_t thdi_port_pg_config={{0}};
    thdiext_thdi_port_sp_config_entry_t thdiext_thdi_port_sp_config={{0}};
    thdiext_thdi_port_pg_config_entry_t thdiext_thdi_port_pg_config={{0}};

    _input_port_threshold_t *input_port_threshold =
                           &_soc_kt2_mmu_intermediate_results.input_port_threshold;


    SOC_PBMP_CLEAR (valid_port_cpu_pbmp);
    SOC_PBMP_ASSIGN(valid_port_cpu_pbmp, PBMP_ALL(unit));

    if (soc_feature(unit, soc_feature_mmu_packing)) {
        _soc_kt2_mmu_params.packing_mode_d_c =  1;
    }

    /* 2.1 Internal Buffer              */
    if (!ext_mem_enable) {
        if (SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port)) {
            SOC_PBMP_PORT_REMOVE(PBMP_EXT_MEM (unit), port);
        } else {
            return SOC_E_NONE;
        }
        if ((((port == 30) || (port == 33) ||
            (port == 36) || (port == 39))) ||
            ((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0)) {
            priority_group = 7;
        } else {
            priority_group = 0;
        }

        sal_memset(&thdi_port_sp_config,0,sizeof(thdi_port_sp_config));
        mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
        SOC_IF_ERROR_RETURN(soc_mem_read(unit, THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL,
                                         mem_idx, &thdi_port_sp_config));
        rval = soc_mem_field32_get(unit, THDI_PORT_SP_CONFIGm,
                                   &thdi_port_sp_config, PORT_SP_MAX_LIMITf);
        if (rval == 0) {
            sal_memset(&thdi_port_sp_config,0,sizeof(thdi_port_sp_config));
            soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm,
                    &thdi_port_sp_config, PORT_SP_MIN_LIMITf,
                    input_port_threshold->min_int_buff_cells_for_a_port);
            soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm,
                    &thdi_port_sp_config, PORT_SP_MAX_LIMITf,
                    input_port_threshold->total_shared_ing_buff_pool);
            SOC_IF_ERROR_RETURN(READ_PORT_MAX_PKT_SIZEr (unit, port, &rval));
            soc_reg_field_set(unit, PORT_MAX_PKT_SIZEr, &rval,
                    PORT_MAX_PKT_SIZEf,
                    general_info->max_packet_size_in_cells);
            SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr (unit, port, rval));

            soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm,
                    &thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
                    input_port_threshold->total_shared_ing_buff_pool -
                    (2 *  general_info->ether_mtu_cells_for_int_buff));

            SOC_IF_ERROR_RETURN (soc_mem_write(
                        unit, THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL,
                        mem_idx, &thdi_port_sp_config));

        }
        sal_memset(&thdi_port_pg_config,0,sizeof(thdi_port_pg_config));
        mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
        SOC_IF_ERROR_RETURN(soc_mem_read(unit, THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL,
                    mem_idx, &thdi_port_pg_config));
        rval =  soc_mem_field32_get(unit, THDI_PORT_PG_CONFIGm,
                &thdi_port_pg_config, PG_MIN_LIMITf);
        if (rval == 0) {
            sal_memset(&thdi_port_pg_config,0,sizeof(thdi_port_pg_config));
            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, PG_MIN_LIMITf,
                    input_port_threshold->min_int_buff_cells_per_PG);

            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
            } else {
                temp_val = input_port_threshold->total_shared_ing_buff_pool;
            }
            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, PG_SHARED_LIMITf, temp_val);

            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, PG_RESET_OFFSETf,
                    (2 * general_info->ether_mtu_cells_for_int_buff));

            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, PG_RESET_FLOORf, 0);

            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = 1;
            } else {
                temp_val = 0;
            }
            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, PG_SHARED_DYNAMICf,temp_val);

            if (IS_GE_PORT(unit, port) || IS_LB_PORT(unit,port)) {
                temp_val = input_port_threshold->hdrm_int_buff_cells_for_1G_PG;
            } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) ) {
                temp_val = input_port_threshold->hdrm_int_buff_cells_for_10G_PG;
            }
            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = 0;
            } else {
                temp_val = 1;
            }

            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, PG_GBL_HDRM_ENf ,temp_val);


            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

            soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm,
                    &thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);

            SOC_IF_ERROR_RETURN (soc_mem_write(
                        unit, THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL,
                        mem_idx, &thdi_port_pg_config));

        }
        op_node = 0;
        port_max_opnodes = 0;
        for(port_index = 0, op_node = 0 ;
                port_index < COUNTOF(port_list);
                port_index++, op_node += port_max_opnodes ) {

            port_iter = port_list[port_index];
            port_max_opnodes = ceil_func(si->port_num_uc_cosq[port_iter],8);

            if (!SOC_PBMP_MEMBER(valid_port_cpu_pbmp, port_iter)) {
                continue;
            }
            if (port != port_iter) {
                continue;
            }

            if (!SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port_iter) &&
                    (port_iter >= KT2_CMIC_PORT) && (port_iter <= KT2_LPBK_PORT)) {
                for (op_node_offset = 0;
                        op_node_offset < port_max_opnodes ;
                        op_node_offset++) {
                    SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                                MEM_BLOCK_ANY,op_node + op_node_offset,
                                &mmu_thdo_opnconfig_cell_entry));
                    /* C394:THDO_OPNCONFIG_CELL.OPN_SHARED_LIMIT_CELL = =$C$219 */
                    soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                            &mmu_thdo_opnconfig_cell_entry,
                            OPN_SHARED_LIMIT_CELLf,
                            output_port_threshold->
                            min_grntd_tot_shr_queue_cells_int_buff);

                    /* C395:THDO_OPNCONFIG_CELL.OP_SHARED_RESET_VALUE_CELL
                       = C394-2*$C$72 */
                    temp_val = output_port_threshold->
                        min_grntd_tot_shr_queue_cells_int_buff -
                        (2 * general_info->ether_mtu_cells_for_int_buff);
                    soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                            &mmu_thdo_opnconfig_cell_entry,
                            OPN_SHARED_RESET_VALUE_CELLf, temp_val);

                    /* C396:THDO_OPNCONFIG_CELL.PORT_LIMIT_ENABLE_CELL
                       = 0 */
                    soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                            &mmu_thdo_opnconfig_cell_entry,
                            PORT_LIMIT_ENABLE_CELLf, 0);
                    /* PIDf :Updated by cosq scheduler code while attaching node */
                    /*
                       soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                       &mmu_thdo_opnconfig_cell_entry,
                       PIDf, port_iter);
                       */
                    SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                                MEM_BLOCK_ALL,op_node + op_node_offset,
                                &mmu_thdo_opnconfig_cell_entry));
                }

                bmap = SOC_CONTROL(unit)->port_lls_l2_bmap[port_iter];
                word_count = _SHR_BITDCLSIZE(soc_mem_index_count(unit, LLS_L2_PARENTm));
                for (word = 0; word < word_count; word++) {
                    if (bmap[word] == 0) {
                        continue;
                    }
                    for (bit = 0; bit < SHR_BITWID; bit++) {
                        if (!(bmap[word] & (1 << bit))) {
                            continue;
                        }
                        queue = word * SHR_BITWID + bit;
                        SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_CELLm(unit,
                                    MEM_BLOCK_ANY,queue,
                                    &mmu_thdo_qconfig_cell_entry));
                        /* C397:THDO_QCONFIG_CELL.Q_MIN_CELL
                           = =$C$201 */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_MIN_CELLf,
                                output_port_threshold->min_grntd_res_queue_cells_int_buff);

                        /* C398:THDO_QCONFIG_CELL.Q_SHARED_LIMIT_CELL
                           =IF($C$14,$C$219,$C$60) */
                        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                            temp_val = output_port_threshold->
                                min_grntd_tot_shr_queue_cells_int_buff;
                        } else {
                            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
                        }
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf,
                                temp_val);

                        /* C400:THDO_QCONFIG_CELL.Q_LIMIT_DYNAMIC_CELL
                           =IF($C$14, 0, 1) */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_LIMIT_DYNAMIC_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                        /* C401:THDO_QCONFIG_CELL.Q_LIMIT_ENABLE_CELL
                           =IF($C$14, 0, 1) */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_LIMIT_ENABLE_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                        /* C402:THDO_QCONFIG_CELL.Q_COLOR_ENABLE_CELL = 0 */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_COLOR_ENABLE_CELLf,0);

                        /* C403: THDO_QCONFIG_CELL.Q_COLOR_LIMIT_DYNAMIC_CELL
                           =IF($C$14, 0, 1) */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_COLOR_LIMIT_DYNAMIC_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                        /* C404: THDO_QCONFIG_CELL.LIMIT_YELLOW_CELL=
                           if lossless= C398/8 else C398 */
                        temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, LIMIT_YELLOW_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ?
                                ceil_func(temp_val, 8) : temp_val);
                        SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_CELLm(unit,
                                    MEM_BLOCK_ALL,queue,
                                    &mmu_thdo_qconfig_cell_entry));

                        SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_CELLm(unit,
                                    MEM_BLOCK_ANY,queue,
                                    &mmu_thdo_qoffset_cell_entry));
                        /* C399:THDO_QOFFSET_CELL.RESET_OFFSET_CELL =2 */
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_CELLf, 2);

                        /* C405: THDO_QOFFSET_CELL.LIMIT_RED_CELL  =
                           if lossless= C398/8 else C398 */
                        temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, LIMIT_RED_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ?
                                ceil_func(temp_val, 8) : temp_val);

                        /* C406: THDO_QOFFSET_CELL.RESET_OFFSET_YELLOW_CELL =2 */
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_YELLOW_CELLf,2);
                        /* C407: THDO_QOFFSET_CELL.RESET_OFFSET_RED_CELL =2 */
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_RED_CELLf,2);

                        SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_CELLm(unit,
                                    MEM_BLOCK_ALL,queue,
                                    &mmu_thdo_qoffset_cell_entry));
                    }
                }
            }
        }
        if (_soc_kt2_mmu_params.packing_mode_d_c) {
            SOC_IF_ERROR_RETURN(_soc_kt2_packing_port_config_set(unit, port, 0));
        }
        SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_ext_mem_dyn_port(unit, port));
    } else {
        /* 2.2 External Buffer              */
        if (SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port)) {
            return SOC_E_NONE;
        }

        SOC_PBMP_PORT_ADD(PBMP_EXT_MEM (unit), port);

        if ((((port == 30) || (port == 33) ||
            (port == 36) || (port == 39))) ||
              ((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0)) {
            priority_group = 7;
        } else {
            priority_group = 0;
        }


        sal_memset(&thdiext_thdi_port_sp_config,0,
                sizeof(thdiext_thdi_port_sp_config));
        mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
        SOC_IF_ERROR_RETURN(soc_mem_read(unit, THDIEXT_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL,
                            mem_idx, &thdiext_thdi_port_sp_config));
        rval = soc_mem_field32_get(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                                   &thdiext_thdi_port_sp_config, PORT_SP_MAX_LIMITf);
        if (rval == 0) {
            soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                    &thdiext_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
                    input_port_threshold->min_ext_buff_cells_for_a_port);

            soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                    &thdiext_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
                    input_port_threshold->total_shared_ext_buff);

            SOC_IF_ERROR_RETURN(READ_THDIEXT_PORT_MAX_PKT_SIZEr (
                        unit, port, &rval));
            soc_reg_field_set(unit, THDIEXT_PORT_MAX_PKT_SIZEr, &rval,
                    PORT_MAX_PKT_SIZEf,
                    general_info->jumbo_frame_for_ext_buff);
            SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_MAX_PKT_SIZEr (
                        unit, port, rval));
            soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                    &thdiext_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
                    input_port_threshold->total_shared_ext_buff -
                    (2 *  general_info->ether_mtu_cells_for_ext_buff));
            SOC_IF_ERROR_RETURN (soc_mem_write(unit,
                        THDIEXT_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL,
                        mem_idx, &thdiext_thdi_port_sp_config));
        }
        sal_memset(&thdiext_thdi_port_pg_config,0,
                sizeof(thdiext_thdi_port_pg_config));
        mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
        SOC_IF_ERROR_RETURN(soc_mem_read(unit, THDIEXT_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL,
                    mem_idx, &thdiext_thdi_port_pg_config));
        rval = soc_mem_field32_get(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                &thdiext_thdi_port_pg_config, PG_MIN_LIMITf);
        if (rval == 0) {
            sal_memset(&thdiext_thdi_port_pg_config,0,
                       sizeof(thdiext_thdi_port_pg_config));
            if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
                soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                        &thdiext_thdi_port_pg_config, PG_MIN_LIMITf,
                        input_port_threshold->min_ext_buff_cells_per_PG);

                if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                    temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
                } else {
                    temp_val = input_port_threshold->total_shared_ext_buff;;
                }
                soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                        &thdiext_thdi_port_pg_config,
                        PG_SHARED_LIMITf, temp_val);

                soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                        &thdiext_thdi_port_pg_config, PG_RESET_OFFSETf,
                        (2 * general_info->ether_mtu_cells_for_ext_buff));

                soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                        &thdiext_thdi_port_pg_config, PG_RESET_FLOORf, 0);

                if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                    temp_val = 1;
                } else {
                    temp_val = 0;
                }
                soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                        &thdiext_thdi_port_pg_config, PG_SHARED_DYNAMICf,
                        temp_val);

                if (IS_GE_PORT(unit, port) || IS_LB_PORT(unit,port)) {
                    temp_val = input_port_threshold->hdrm_ext_buff_cells_for_1G_PG;
                } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
                    temp_val= input_port_threshold->hdrm_ext_buff_cells_for_10G_PG;
                }
                soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                        &thdiext_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

                if (_soc_kt2_mmu_params.lossless_mode_d_c ||
                        _soc_kt2_mmu_params.packing_mode_d_c) {
                    temp_val = 0;
                } else {
                    temp_val = 1;
                }
                soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                        &thdiext_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
                        temp_val);
            }
            soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                    &thdiext_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

            soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                    &thdiext_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);

            SOC_IF_ERROR_RETURN (soc_mem_write(
                        unit, THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL,
                        mem_idx, &thdi_port_pg_config));
            SOC_IF_ERROR_RETURN (soc_mem_write(unit,
                        THDIEXT_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL,
                        mem_idx, &thdiext_thdi_port_pg_config));
        }

        for(port_index = 0, op_node = 0 ;
                port_index < COUNTOF(port_list);
                port_index++, op_node += port_max_opnodes ) {

            port_iter = port_list[port_index];
            port_max_opnodes = ceil_func(si->port_num_uc_cosq[port_iter],8);

            if (!SOC_PBMP_MEMBER(valid_port_cpu_pbmp, port_iter)) {
                continue;
            }
            if (port != port_iter) {
                continue;
            }

            if (!IS_CPU_PORT(unit, port_iter) &&
                    (port_iter > KT2_CMIC_PORT) && (port_iter <= KT2_LPBK_PORT) &&
                    SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port_iter)) {

                SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                            MEM_BLOCK_ANY,op_node , &mmu_thdo_opnconfig_cell_entry));
                /* C409:THDO_OPNCONFIG_CELL.OPN_SHARED_LIMIT_CELL = =$C$220 */
                soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                        &mmu_thdo_opnconfig_cell_entry,
                        OPN_SHARED_LIMIT_CELLf,
                        output_port_threshold->
                        min_grntd_tot_shr_queue_cells_ext_buff);

                /* C410:THDO_OPNCONFIG_CELL.OP_SHARED_RESET_VALUE_CELL
                   = =$C$409-2*$C$73 */
                temp_val = output_port_threshold->
                    min_grntd_tot_shr_queue_cells_ext_buff -
                    (2 * general_info->ether_mtu_cells_for_ext_buff);
                soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                        &mmu_thdo_opnconfig_cell_entry,
                        OPN_SHARED_RESET_VALUE_CELLf, temp_val);

                /* C411:THDO_OPNCONFIG_CELL.PORT_LIMIT_ENABLE_CELL = 0 */
                soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                        &mmu_thdo_opnconfig_cell_entry,
                        PORT_LIMIT_ENABLE_CELLf, 0);
                /* PIDf :Updated by cosq scheduler code while attaching node */
                /*
                   soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                   &mmu_thdo_opnconfig_cell_entry,
                   PIDf, port_iter);
                   */
                SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                            MEM_BLOCK_ALL,op_node,
                            &mmu_thdo_opnconfig_cell_entry));

                bmap = SOC_CONTROL(unit)->port_lls_l2_bmap[port_iter];
                word_count = _SHR_BITDCLSIZE(soc_mem_index_count(unit, LLS_L2_PARENTm));
                for (word = 0; word < word_count; word++) {
                    if (bmap[word] == 0) {
                        continue;
                    }
                    for (bit = 0; bit < SHR_BITWID; bit++) {
                        if (!(bmap[word] & (1 << bit))) {
                            continue;
                        }
                        queue = word * SHR_BITWID + bit;
                        SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_CELLm(unit,
                                    MEM_BLOCK_ANY,queue,
                                    &mmu_thdo_qconfig_cell_entry));
                        /* C412:THDO_QCONFIG_CELL.Q_MIN_CELL
                           = =$C$202 */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_MIN_CELLf,
                                output_port_threshold->min_grntd_res_queue_cells_ext_buff);

                        /* C413:THDO_QCONFIG_CELL.Q_SHARED_LIMIT_CELL
                           =IF($C$14,$C$220,$C$60) */
                        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                            temp_val = output_port_threshold->
                                min_grntd_tot_shr_queue_cells_ext_buff;
                        } else {
                            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
                        }
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf,
                                temp_val);

                        /* C415:THDO_QCONFIG_CELL.Q_LIMIT_DYNAMIC_CELL
                           =IF($C$14, 0, 1) */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_LIMIT_DYNAMIC_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                        /* C416:THDO_QCONFIG_CELL.Q_LIMIT_ENABLE_CELL
                           =IF($C$14, 0, 1) */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_LIMIT_ENABLE_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                        /* C417:THDO_QCONFIG_CELL.Q_COLOR_ENABLE_CELL = 0 */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_COLOR_ENABLE_CELLf,0);

                        /* C418: THDO_QCONFIG_CELL.Q_COLOR_LIMIT_DYNAMIC_CELL
                           =IF($C$14, 0, 1) */
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_COLOR_LIMIT_DYNAMIC_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                        /* C419: THDO_QCONFIG_CELL.LIMIT_YELLOW_CELL=
                           if lossless= CEILING(C413/8) else C413 */
                        temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                        soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, LIMIT_YELLOW_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ?
                                ceil_func(temp_val, 8) : temp_val);
                        SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_CELLm(unit,
                                    MEM_BLOCK_ALL,queue,
                                    &mmu_thdo_qconfig_cell_entry));

                        SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_CELLm(unit,
                                    MEM_BLOCK_ANY,queue,
                                    &mmu_thdo_qoffset_cell_entry));
                        /* C414:THDO_QOFFSET_CELL.RESET_OFFSET_CELL =2 */
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_CELLf, 2);

                        /* C420: THDO_QOFFSET_CELL.LIMIT_RED_CELL  =
                           if lossless= CEILING(C413/8) else C413 */
                        temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm,
                                &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, LIMIT_RED_CELLf,
                                _soc_kt2_mmu_params.lossless_mode_d_c ?
                                ceil_func(temp_val, 8) : temp_val);

                        /* C421: THDO_QOFFSET_CELL.RESET_OFFSET_YELLOW_CELL =2 */
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_YELLOW_CELLf,2);
                        /* C422: THDO_QOFFSET_CELL.RESET_OFFSET_RED_CELL =2 */
                        soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm,
                                &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_RED_CELLf,2);

                        SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_CELLm(unit,
                                    MEM_BLOCK_ALL,queue,
                                    &mmu_thdo_qoffset_cell_entry));
                    }
                }
            }
        }
        if (_soc_kt2_mmu_params.packing_mode_d_c) {
            SOC_IF_ERROR_RETURN(_soc_kt2_packing_port_config_set(unit, port, 1));
        }
        SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_ext_mem_dyn_port(unit, port));
    }


#if defined (INCLUDE_L3)
    /* IPMC configuration */
    soc_mem_lock(unit, L3_IPMCm);
    for (ipmc_id = soc_mem_index_min(unit, L3_IPMCm);
             ipmc_id <= soc_mem_index_max(unit, L3_IPMCm);
             ipmc_id++) {
        if (_bcm_kt_ipmc_port_ext_queue_count(unit, ipmc_id, port)) {
            BCM_IF_ERROR_RETURN(soc_mem_read(unit, L3_IPMCm, MEM_BLOCK_ANY,
                                             ipmc_id, entry));
            soc_mem_field32_set(unit, L3_IPMCm, entry, EXT_Q_INTERNALf, 0);
            soc_mem_field32_set(unit, L3_IPMCm, entry, EXT_Q_EXTERNALf, 0);
            if (!ext_mem_enable) {
                SOC_PBMP_ITER (PBMP_EXT_MEM (unit), port_iter) {
                    if (_bcm_kt_ipmc_port_ext_queue_count(unit, ipmc_id, port_iter))  {
                        soc_mem_field32_set(unit, L3_IPMCm, entry, EXT_Q_EXTERNALf, 1);
                    }
                }
                soc_mem_field32_set(unit, L3_IPMCm, entry, EXT_Q_INTERNALf, 1);
            } else {
                PBMP_ITER(PBMP_PORT_ALL(unit), port_iter){
                   if (!SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port_iter) &&
                          _bcm_kt_ipmc_port_ext_queue_count(unit, ipmc_id, port_iter))
                       soc_mem_field32_set(unit, L3_IPMCm, entry, EXT_Q_INTERNALf, 1);
                }
                soc_mem_field32_set(unit, L3_IPMCm, entry, EXT_Q_EXTERNALf, 1);
            }
            BCM_IF_ERROR_RETURN(soc_mem_write(unit, L3_IPMCm, 
                                      MEM_BLOCK_ALL, ipmc_id, &entry));
            BCM_IF_ERROR_RETURN(_bcm_kt2_ipmc_subscriber_egress_queue_ext_set
                                (unit, port, ipmc_id, ext_mem_enable));
        }
    }
    soc_mem_unlock(unit, L3_IPMCm);
#endif
    return BCM_E_NONE;
}

/* Helper function for MMU settings based on
 * memory selection (internal/external/both) and mode (lossless/lossy)
 * The memory selection is done using config variable  'pbmp_ext_mem'
 * and the mode is selected based on config variable 'lossless_mode'
 */
STATIC 
int _soc_katana2_mmu_init_helper(int unit, soc_port_t flex_port)
{
    soc_info_t    *si= &SOC_INFO(unit);
    int idx;
    uint16 dev_id=0;
    uint8  rev_id=0;
    uint32    ext_mem_port_count = 0;
    uint32    valid_port_count = 0;
    soc_pbmp_t    pbmp_int_ge;
    uint32        pbmp_int_ge_count=0;
    soc_pbmp_t    pbmp_int_hg;
    uint32        pbmp_int_hg_count=0;
    soc_pbmp_t    pbmp_ext_ge;
    uint32        pbmp_ext_ge_count=0;
    soc_pbmp_t    pbmp_ext_hg;
    uint32        pbmp_ext_hg_count=0;
    uint32        mmu_num_olp_port=0;
    soc_pbmp_t    valid_port_cpu_pbmp;
    soc_port_t    sub_port=0;
    soc_port_t    port=0;
    uint32        available_internal_buffer=100;
    uint32        reserve_internal_buffer=0;
    uint32        temp_val;
    uint32        rval=0;
    uint32        service_pool=0;
    uint32        priority_group=0;
    uint32        op_buffer_shared_limit_celli;
    uint32        op_buffer_shared_limit_resume_celli;
    uint32        op_buffer_shared_limit_celle;
    uint32        op_buffer_shared_limit_resume_celle;
    uint32        op_buffer_shared_limit;
    uint32        op_buffer_shared_limit_resume;
    soc_field_info_t *fieldp;
    uint32        queue;
    uint32        op_node=0;
    uint32        op_node_offset=0;
    uint32        cos;
    uint64        r64val;
    uint64        val64;
    int           min = 0, max = 0;
    int adjust_min_grntd;
    _soc_mmu_cfg_buf_t *buf;
    _soc_mmu_device_info_t devcfg;
    _soc_mmu_cfg_buf_port_t *buf_port;
    _soc_mmu_cfg_buf_queue_t *buf_queue;
    _soc_mmu_cfg_buf_mcengine_queue_t *buf_rqe_queue;
 
    /* soc_reg_info_t   *regp; */

    /* Per Port  Settings */
    uint32                      mem_idx=0;
    thdi_port_sp_config_entry_t thdi_port_sp_config={{0}};
                                /*
                                (KT2_MAX_PHYSICAL_PORTS+2) *
                                 KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                 */
    thdi_port_pg_config_entry_t thdi_port_pg_config={{0}};
                                /*
                                (KT2_MAX_PHYSICAL_PORTS+2) *
                                 KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                 */

    thdiext_thdi_port_sp_config_entry_t thdiext_thdi_port_sp_config={{0}};
                                        /* 
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdiext_thdi_port_pg_config_entry_t thdiext_thdi_port_pg_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */
    thdiema_thdi_port_sp_config_entry_t thdiema_thdi_port_sp_config = {{0}};
                                        /* 
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdiema_thdi_port_pg_config_entry_t thdiema_thdi_port_pg_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */
    thdirqe_thdi_port_sp_config_entry_t thdirqe_thdi_port_sp_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdirqe_thdi_port_pg_config_entry_t thdirqe_thdi_port_pg_config={{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */
    thdiqen_thdi_port_sp_config_entry_t thdiqen_thdi_port_sp_config = {{0}};
                                        /* 
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_SERVICE_POOLS] = {{{0}}};
                                         */
    thdiqen_thdi_port_pg_config_entry_t thdiqen_thdi_port_pg_config = {{0}};
                                        /*
                                        (KT2_MAX_PHYSICAL_PORTS+2) *
                                         KT2_MAX_PRIORITY_GROUPS] = {{{0}}};
                                         */

    mmu_thdo_opnconfig_cell_entry_t     mmu_thdo_opnconfig_cell_entry={{0}};
    mmu_thdo_qconfig_cell_entry_t       mmu_thdo_qconfig_cell_entry={{0}};
    mmu_thdo_qoffset_cell_entry_t       mmu_thdo_qoffset_cell_entry={{0}};

    mmu_thdo_opnconfig_qentry_entry_t   mmu_thdo_opnconfig_qentry_entry={{0}};
    mmu_thdo_qconfig_qentry_entry_t     mmu_thdo_qconfig_qentry_entry={{0}};
    mmu_thdo_qoffset_qentry_entry_t     mmu_thdo_qoffset_qentry_entry={{0}};

    _general_info_t *general_info = 
                    &_soc_kt2_mmu_intermediate_results.general_info;
    _input_port_threshold_t *input_port_threshold =
                       &_soc_kt2_mmu_intermediate_results.input_port_threshold;
    _output_port_threshold_t *output_port_threshold = 
                       &_soc_kt2_mmu_intermediate_results.output_port_threshold;

    uint8 port_list[]={KT2_CMIC_PORT, KT2_LPBK_PORT ,
                       1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                       11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                       21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
                       31, 32, 33, 34, 35, 36, 37, 38, 39, 40};
    uint32        port_max_opnodes = 0;
    uint8         port_index = 0;
    int mmu_config_enabled = 0;

    buf = soc_mmu_cfg_alloc(unit);
    if (!buf) {
        return SOC_E_MEMORY;
    }
    sal_memset(&devcfg, 0, sizeof(_soc_mmu_device_info_t));

    if (soc_property_get(unit, spn_MMU_CONFIG_OVERRIDE, 1) == 0) {
        _soc_mmu_cfg_buf_read(unit, buf, &devcfg);
        mmu_config_enabled = 1; 
    } else {
        mmu_config_enabled = 0; 
    }

    sal_memset(&_soc_kt2_mmu_intermediate_results,0,sizeof(_soc_kt2_mmu_intermediate_results_t));
    sal_memset(&_soc_kt2_mmu_params,0,sizeof(_soc_kt2_mmu_params_t));

    /* Fixed Parameter */
    _soc_kt2_mmu_params.mmu_min_pkt_size = 64;              /*C5*/
    _soc_kt2_mmu_params.mmu_ethernet_mtu_bytes=1536;      /*C6*/
    _soc_kt2_mmu_params.mmu_max_pkt_size = 9216;            /*C7*/
    _soc_kt2_mmu_params.mmu_jumbo_frame_size = 9216;        /*C8*/
    _soc_kt2_mmu_params.mmu_int_buf_cell_size = 190;        /*C9*/
    /* C10  = (C9+2)*15 */
    _soc_kt2_mmu_params.mmu_pkt_header_size = 62;           /*C11*/
    _soc_kt2_mmu_params.mmu_lossless_pg_num = 1;            /*C16*/
    _soc_kt2_mmu_params.mmu_line_rate_ge = 1;               /*C20*/
    _soc_kt2_mmu_params.mmu_line_rate_hg = 13;              /*C26*/
    _soc_kt2_mmu_params.mmu_num_cpu_port = 1;               /*C31*/
    _soc_kt2_mmu_params.mmu_num_cpu_queue = 48;             /*C32*/
    _soc_kt2_mmu_params.mmu_num_loopback_port = 1;          /*C34*/
    _soc_kt2_mmu_params.mmu_num_loopback_queue = 8;         /*C35*/
    _soc_kt2_mmu_params.mmu_num_ep_redirection_queue = 16;  /*C36*/
    _soc_kt2_mmu_params.mmu_num_olp_queue = 8;              /*C38*/
    _soc_kt2_mmu_params.mmu_int_buf_size = 2;               /*C41:2048KB=2MB*/
    _soc_kt2_mmu_params.mmu_reserved_int_buf_cells = 100;   /*C43:100 Cells */
    _soc_kt2_mmu_params.mmu_ext_buf_size = 
        SOC_DDR3_NUM_MEMORIES(unit) *
        SOC_DDR3_NUM_ROWS(unit) *
        SOC_DDR3_NUM_COLUMNS(unit) * 
        SOC_DDR3_NUM_BANKS(unit) /
        (1024 * 1024) *
        (16 / 8);  /* 16b datawidth to bytes */ 
    si->mmu_ext_buf_size  = _soc_kt2_mmu_params.mmu_ext_buf_size;
    if (_soc_kt2_mmu_params.mmu_ext_buf_size > 720) {
        /* Maximum external buffer size is 720MB.
         * 256K pointers * 2880 byte cells = 720MB */
        _soc_kt2_mmu_params.mmu_ext_buf_size = 720;
    }
    if ((_soc_kt2_mmu_params.mmu_ext_buf_size <= 192) && (!soc_feature(unit, soc_feature_mmu_packing))) {
        /* For small packet buffer configurations, use smaller cell size
         * to reduce cell quantization loss */
        _soc_kt2_mmu_params.mmu_ext_buf_cell_size = 768;
    } else {
        _soc_kt2_mmu_params.mmu_ext_buf_cell_size = 2880;
    }
    _soc_kt2_mmu_params.mmu_ep_redirect_queue_entries = 1000;/*C48*/
    _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt = 27;    /*C49*/
    _soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries = 8;    /*C50*/
    _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device = 12;    /*C51*/
    _soc_kt2_mmu_params.mmu_ema_queues = 8;    /*C52*/
/*
static const float  kt2_baf_profile_indexes[]={0.015625,0.03125,0.0625,
                                               0.125,0.25,0.5,1.0,2.0,4.0,8.0};
 */
    _soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param = 2; /*C57*/
    _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param = 7;  /*C58*/
    _soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param = 2; /*C59*/
    _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param = 7;  /*C60*/
    _soc_kt2_mmu_params.mmu_ing_cell_buf_reduction = 0; /*C61 */
    _soc_kt2_mmu_params.mmu_ing_pkt_buf_reduction = 0; /*C62 */

    SOC_PBMP_CLEAR (pbmp_int_ge);
    SOC_PBMP_CLEAR (pbmp_int_hg);
    SOC_PBMP_CLEAR (pbmp_ext_ge);
    SOC_PBMP_CLEAR (pbmp_ext_hg);

    SOC_PBMP_CLEAR (valid_port_cpu_pbmp);
    SOC_PBMP_ASSIGN(valid_port_cpu_pbmp, PBMP_ALL(unit));
    /* SOC_PBMP_PORT_ADD(valid_port_cpu_pbmp, KT2_CMIC_PORT); */

    soc_cm_get_id(unit, &dev_id, &rev_id);
    /* C12 */
    if (soc_feature(unit, soc_feature_mmu_packing)) {
        _soc_kt2_mmu_params.packing_mode_d_c =  1;
        /* soc_property_get(unit, spn_MMU_MULTI_PACKETS_PER_CELL, 0); */
    }

    /* C13 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Packing mode enabled \n")));
        _soc_kt2_mmu_params.max_pkt_size_support_packing = 10;
    } else {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Packing mode disabled \n")));
    }
    
    /* C14 */
    _soc_kt2_mmu_params.lossless_mode_d_c =  (soc_property_get(unit,
                                                          spn_LOSSLESS_MODE, 1) &
                                              soc_property_get(unit,
                                                          spn_MMU_LOSSLESS, 1));
    /* C15 */
    _soc_kt2_mmu_params.pfc_pause_mode_d_c =  soc_property_get(unit, 
                                                          "pfc_pause_mode", 0);

    SOC_PBMP_COUNT(PBMP_PORT_ALL (unit), valid_port_count);
    SOC_PBMP_COUNT(PBMP_EXT_MEM (unit), ext_mem_port_count);/*spn_PBMP_EXT_MEM*/

    if (!ext_mem_port_count) {
       if (SOC_DDR3_NUM_MEMORIES(unit)) {
           ext_mem_port_count = 1;
       } 
    }

    /* C17 */
    if (ext_mem_port_count == 0) {
        _soc_kt2_mmu_params.extbuf_used_d_c =  0;
    } else {
        _soc_kt2_mmu_params.extbuf_used_d_c =  1;
    } 

    SOC_PBMP_ASSIGN(pbmp_int_ge,PBMP_GE_ALL(unit));
    if (SOC_INFO(unit).olp_port[0]) {
        SOC_PBMP_PORT_REMOVE(pbmp_int_ge,KT2_OLP_PORT);
        mmu_num_olp_port=1;
    }
    SOC_PBMP_ASSIGN(pbmp_int_hg,PBMP_HG_ALL(unit));
    SOC_PBMP_OR(pbmp_int_hg,PBMP_XE_ALL(unit));
    SOC_PBMP_ITER (PBMP_EXT_MEM (unit), port) {
        if (IS_GE_PORT(unit, port)) {
            SOC_PBMP_PORT_ADD(pbmp_ext_ge,port);
            SOC_PBMP_PORT_REMOVE(pbmp_int_ge,port);
        } 
        if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
            SOC_PBMP_PORT_ADD(pbmp_ext_hg,port);
            SOC_PBMP_PORT_REMOVE(pbmp_int_hg,port);
        }
    }
    SOC_PBMP_COUNT(pbmp_ext_ge,pbmp_ext_ge_count);
    SOC_PBMP_COUNT(pbmp_int_ge,pbmp_int_ge_count);
    SOC_PBMP_COUNT(pbmp_ext_hg,pbmp_ext_hg_count);
    SOC_PBMP_COUNT(pbmp_int_hg,pbmp_int_hg_count);

    /* C19 */
    _soc_kt2_mmu_params.num_ge_ports_d = pbmp_int_ge_count + pbmp_ext_ge_count;
    /* C21 */
    _soc_kt2_mmu_params.num_ge_int_ports_d = pbmp_int_ge_count;
    /* C22 */
    _soc_kt2_mmu_params.num_egr_queue_per_int_ge_port_d = pbmp_int_ge_count ? 8:0;
    /* C23 */
    _soc_kt2_mmu_params.num_ge_ext_ports_d = pbmp_ext_ge_count;
    /* C24 */
    _soc_kt2_mmu_params.num_egr_queue_per_ext_ge_port_d = pbmp_ext_ge_count ? 
                        (_soc_kt2_mmu_params.packing_mode_d_c ? 16:8):0;
    /* C25 */
    _soc_kt2_mmu_params.num_hg_ports_d = pbmp_int_hg_count + pbmp_ext_hg_count;
    /* C27 */
    _soc_kt2_mmu_params.num_hg_int_ports_d = pbmp_int_hg_count ;
    /* C28 */
    _soc_kt2_mmu_params.num_egr_queue_per_int_hg_port_d = pbmp_int_hg_count ? 8:0;
    /* C29 */
    _soc_kt2_mmu_params.num_hg_ext_ports_d = pbmp_ext_hg_count ;
    /* C30 */
    _soc_kt2_mmu_params.num_egr_queue_per_ext_hg_port_d = pbmp_ext_hg_count ?
                        (_soc_kt2_mmu_params.packing_mode_d_c ? 16:8):0;
    /* C33 */
    _soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c = soc_property_get(unit, 
                                                    "cpu_port_bounding",0);
    /* C37 */
    _soc_kt2_mmu_params.mmu_num_olp_port_d = mmu_num_olp_port;
    /* C39 */
    _soc_kt2_mmu_params.olp_port_int_ext_bounding_d_c = soc_property_get(unit, 
                                                    "olp_port_bounding",0);

    if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
       available_internal_buffer=70;
       reserve_internal_buffer=30;
    } else {
       available_internal_buffer=100;
       reserve_internal_buffer=0;
    }
    /* C42 */
    _soc_kt2_mmu_params.mmu_available_int_buf_size_d=available_internal_buffer;
    /* (_soc_kt2_mmu_params.mmu_int_buf_size*available_internal_buffer)/100; */
    /* C44 */
    _soc_kt2_mmu_params.mmu_reserved_int_buf_ema_pool_size_d=
                        reserve_internal_buffer;
    /* (_soc_kt2_mmu_params.mmu_int_buf_size*reserve_internal_buffer)/100; */

    /* C45 */
    _soc_kt2_mmu_params.internal_buffer_reduction_d_c = soc_property_get(unit, 
                                              "internal_buffer_reduction",0);
 
    /* C46 */    /* Reduce for KT packing mode only..*/
    if ((dev_id == BCM56454_DEVICE_ID) || (dev_id == BCM56455_DEVICE_ID)) {
        if (_soc_kt2_mmu_params.packing_mode_d_c) {
            _soc_kt2_mmu_params.mmu_ext_buf_size = 360;
        }
    }

    /* C47 */
    _soc_kt2_mmu_params.mmu_egress_queue_entries = 
                                _soc_kt2_mmu_params.packing_mode_d_c ? 128:256;

    /* C55 = CEILING((C6*1024+C11)/C9, 1) */
    _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d = 
            ceil_func((_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes + 
                       _soc_kt2_mmu_params.mmu_pkt_header_size),
                      _soc_kt2_mmu_params.mmu_int_buf_cell_size);

    /* C56 = =IF(C12=0,CEILING(C53/15,1),CEILING((C6*1024+C11+2)/C10,1)) */
    if (_soc_kt2_mmu_params.packing_mode_d_c == 0) {
        _soc_kt2_mmu_params.per_cos_res_cells_for_ext_buff_d = 
            ceil_func(_soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d,15);
    } else {
        _soc_kt2_mmu_params.per_cos_res_cells_for_ext_buff_d = 
            ceil_func((_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes + 
                       _soc_kt2_mmu_params.mmu_pkt_header_size + 2),
                      _soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    }

    /* Intermediate Results Processing Now */
    /* Fill up general info */
    /* C68 = CEILING((C7+C11)/C9,1) */
    general_info->max_packet_size_in_cells = ceil_func(
           (_soc_kt2_mmu_params.mmu_max_pkt_size + 
            _soc_kt2_mmu_params.mmu_pkt_header_size),
            _soc_kt2_mmu_params.mmu_int_buf_cell_size);
    /* C69 = CEILING((C8+C11)/C9,1) */
    general_info->jumbo_frame_for_int_buff = ceil_func(
           (_soc_kt2_mmu_params.mmu_jumbo_frame_size +
            _soc_kt2_mmu_params.mmu_pkt_header_size),
            _soc_kt2_mmu_params.mmu_int_buf_cell_size);
    /* C70 = IF(C12=0,CEILING(C69/15,1),CEILING((C8+C11+2)/C10,1)) */
    if (_soc_kt2_mmu_params.packing_mode_d_c == 0) {
        general_info->jumbo_frame_for_ext_buff = ceil_func(
                      general_info->jumbo_frame_for_int_buff,15);
    } else {
        general_info->jumbo_frame_for_ext_buff = ceil_func(
                      _soc_kt2_mmu_params.mmu_jumbo_frame_size +
                      _soc_kt2_mmu_params.mmu_pkt_header_size + 2,
                      _soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    }
    /* C72 = CEILING((C6*1024+C11)/C9, 1) */
    general_info->ether_mtu_cells_for_int_buff = ceil_func(
                  (_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes) +
                   _soc_kt2_mmu_params.mmu_pkt_header_size,
                  _soc_kt2_mmu_params.mmu_int_buf_cell_size);

    /* C73 = IF(C12=0,CEILING(C72/15,1),CEILING((C6*1024+C11+2)/C10,1)) */
    if (_soc_kt2_mmu_params.packing_mode_d_c == 0) {
        general_info->ether_mtu_cells_for_ext_buff = ceil_func(
                      general_info->ether_mtu_cells_for_int_buff,15);
    } else {
        general_info->ether_mtu_cells_for_ext_buff = ceil_func(
                      (_soc_kt2_mmu_params.mmu_ethernet_mtu_bytes)+
                      _soc_kt2_mmu_params.mmu_pkt_header_size+2,
                      _soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    }
  
    /* C75 = C19+C25+C31+C34+C37 */
    general_info->total_num_of_ports = 
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d + 
                  _soc_kt2_mmu_params.mmu_num_cpu_port + 
                  _soc_kt2_mmu_params.mmu_num_loopback_port + 
                  _soc_kt2_mmu_params.mmu_num_olp_port_d;

    /* C76 = C19+C25+C31+C37 ) */
    general_info->total_num_of_ports_excl_lpbk = 
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d + 
                  _soc_kt2_mmu_params.mmu_num_cpu_port + 
                  _soc_kt2_mmu_params.mmu_num_olp_port_d;

    /* C77 = C19+C25+C31 */
    general_info->total_num_of_ports_excl_lpbk_olp =
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d + 
                  _soc_kt2_mmu_params.mmu_num_cpu_port;

    /* C78 = C19+C25 */
    general_info->total_num_of_ports_excl_lpbk_olp_cpu = 
                  _soc_kt2_mmu_params.num_ge_ports_d +
                  _soc_kt2_mmu_params.num_hg_ports_d;

    /* C79 = C23*C20+C29*C26 */
    general_info->port_bw_bound_to_ext_buff = 
                  (_soc_kt2_mmu_params.num_ge_ext_ports_d *
                   _soc_kt2_mmu_params.mmu_line_rate_ge) +
                  (_soc_kt2_mmu_params.num_hg_ext_ports_d *
                   _soc_kt2_mmu_params.mmu_line_rate_hg) ;

    /* C80 = C22*C21 */
    general_info->total_egr_queues_for_a_int_ge_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_int_ge_port_d *
                   _soc_kt2_mmu_params.num_ge_int_ports_d);

    /* C81 = C24*C23 */
    general_info->total_egr_queues_for_a_ext_ge_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_ext_ge_port_d *
                   _soc_kt2_mmu_params.num_ge_ext_ports_d);

    /* C82 = C28*C27 */
    general_info->total_egr_queues_for_a_int_hg_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_int_hg_port_d *
                   _soc_kt2_mmu_params.num_hg_int_ports_d);

    /* C83 = C30*C29 */
    general_info->total_egr_queues_for_a_ext_hg_ports = 
                  (_soc_kt2_mmu_params.num_egr_queue_per_ext_hg_port_d *
                   _soc_kt2_mmu_params.num_hg_ext_ports_d);

    /* C84 = C31*C32 */
    general_info->total_cpu_queues = 
                  (_soc_kt2_mmu_params.mmu_num_cpu_port *
                   _soc_kt2_mmu_params.mmu_num_cpu_queue);

    /* C85 = $C$80+$C$82+IF(C33=0,C84,0)+IF(C39=0,C38,0)+C35+C36/2 */
    general_info->total_int_buff_queues = 
                  (general_info->total_egr_queues_for_a_int_ge_ports +
                   general_info->total_egr_queues_for_a_int_hg_ports);
    if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c == 0) {
        general_info->total_int_buff_queues += general_info->total_cpu_queues; 
    }
    if (_soc_kt2_mmu_params.olp_port_int_ext_bounding_d_c == 0) {
        general_info->total_int_buff_queues += 
                      _soc_kt2_mmu_params.mmu_num_olp_queue; 
    }
    general_info->total_int_buff_queues += 
                  _soc_kt2_mmu_params.mmu_num_loopback_queue;
    general_info->total_int_buff_queues += 
                  (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue / 2);

    /* C86 = $C$81+$C$83+IF(C33=1,C84,0)+IF(C39=1,C38,0)+IF(C17=1,C36/2,0) */
    general_info->total_ext_buff_queues =
             (general_info->total_egr_queues_for_a_ext_ge_ports +
              general_info->total_egr_queues_for_a_ext_hg_ports);
    if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c) {
        general_info->total_ext_buff_queues += general_info->total_cpu_queues; 
    }
    if (_soc_kt2_mmu_params.olp_port_int_ext_bounding_d_c) {
        general_info->total_ext_buff_queues += 
                      _soc_kt2_mmu_params.mmu_num_olp_queue;
    }
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        general_info->total_ext_buff_queues += 
                      (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue/2);
    }

    /* C54 = =($C$81+$C$83+IF(C33=1,C84,0)+IF(C39=1,C38,0)+IF(C17=1,C36/2,0))*2 */
    /*     = C86 * 2 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        _soc_kt2_mmu_params.num_cells_rsrvd_ing_ext_buf = 
                                        general_info->total_ext_buff_queues * 2;
    }

    /* C87 = C52 */
    general_info->total_ema_queues = _soc_kt2_mmu_params.mmu_ema_queues;

    /* C90 = C85+C86 */ 
    general_info->total_egr_queues_in_device = 
                  general_info->total_int_buff_queues + 
                  general_info->total_ext_buff_queues;
   
    /* C91 = FLOOR($C$41*1024*1024/($C$9+2),1)-C43 */
    general_info->max_int_cell_buff_size = floor_func(
                  _soc_kt2_mmu_params.mmu_int_buf_size*1024*1024,
                  _soc_kt2_mmu_params.mmu_int_buf_cell_size+2) ;
    general_info->max_int_cell_buff_size -= 
                  _soc_kt2_mmu_params.mmu_reserved_int_buf_cells;

    /* C92 = C91 */
    general_info->int_cell_buff_size_after_limitation = 
                  general_info->max_int_cell_buff_size;

    /* C93 = C75*C13 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        general_info->src_packing_fifo = general_info->total_num_of_ports *
                               _soc_kt2_mmu_params.max_pkt_size_support_packing;
    }
    
    /* C94 = FLOOR($C$42 *( IF($C$45, $C$92, $C$91) , 1) */
    if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c) {
        temp_val = general_info->int_cell_buff_size_after_limitation;
    } else {
        temp_val = general_info->max_int_cell_buff_size;
    }
    /* temp_val -=  input_port_threshold->total_hdrm_int_buff_cells; */
    temp_val = (_soc_kt2_mmu_params.mmu_available_int_buf_size_d * temp_val)/100;
    /* Packed : C94 = FLOOR($C$42 *( IF($C$45, $C$92, $C$91) , 1) - C93 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        temp_val -= general_info->src_packing_fifo;
    }
    general_info->int_buff_pool = temp_val;

    /* C95 = IF($C$45,$C$92,$C$91)-C94 */
    if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c) {
        temp_val = general_info->int_cell_buff_size_after_limitation;
    } else {
        temp_val = general_info->max_int_cell_buff_size;;
    }
    temp_val = temp_val - general_info->int_buff_pool;
    /* Packed : C95 = IF($C$45,$C$92,$C$91)-C94-C93 */
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        temp_val -= general_info->src_packing_fifo;
    }
    general_info->ema_pool = temp_val;

    /* C96 = IF($C$17,$C$46*1024*1024/$C$10,0) */
    if  (_soc_kt2_mmu_params.extbuf_used_d_c) {
         general_info->max_ext_cell_buff_size = 
                       (_soc_kt2_mmu_params.mmu_ext_buf_size*1024*1024)/
                       (_soc_kt2_mmu_params.mmu_ext_buf_cell_size);
    } 

    /* C99 = $C$10/($C$9+2) */
    general_info->ratio_of_ext_buff_to_int_buff_size = 
                  _soc_kt2_mmu_params.mmu_ext_buf_cell_size /
                  (_soc_kt2_mmu_params.mmu_int_buf_cell_size + 2);
    
    /* C100 = 1 */
    general_info->int_buff_cells_per_avg_size_pkt = 1;

    /* C101 = 1 */
    general_info->ext_buff_cells_per_avg_size_pkt = 1;

    /* C102 = 0.75 but normalized to 1 */
    general_info->max_prop_of_buff_used_by_one_queue_port = 75;


    /* Fill up input threshold info */
    /* C107 = CEILING(20*1024/C9, 1) */
    input_port_threshold->global_hdrm_cells_for_int_buff_pool = ceil_func(
             (20*1024),_soc_kt2_mmu_params.mmu_int_buf_cell_size);
 
    /* C108 = CEILING( IF($C$17, $C$107/$C$99, 0),1) */
    if ( _soc_kt2_mmu_params.extbuf_used_d_c &&
         (_soc_kt2_mmu_params.packing_mode_d_c == 0)) {
        input_port_threshold->global_hdrm_cells_for_ext_buff_pool = ceil_func(
                      input_port_threshold->global_hdrm_cells_for_int_buff_pool,
                      general_info->ratio_of_ext_buff_to_int_buff_size);
    }
    /* C109,110 = 0 */
    /* C112-C115 values are zero for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
            /* C112*/
            input_port_threshold->hdrm_int_buff_cells_for_10G_PG = 76; 
            /* C113*/
            input_port_threshold->hdrm_ext_buff_cells_for_10G_PG =  67;
            /* C114*/
            input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG = 67;
        } else {
            /* C112*/
            input_port_threshold->hdrm_int_buff_cells_for_10G_PG = 180;
            /* C113*/
            input_port_threshold->hdrm_ext_buff_cells_for_10G_PG = 0;
            /* C114*/
            input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG = 159;
        }
        /* C115 = C114*C49 */
        input_port_threshold->hdrm_EQEs_pkts_for_10G_PG = 
            input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG * 
            _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    }
 
    /* C117 = C25*C16*$C$112 */
    input_port_threshold->hdrm_int_buff_cells_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_int_buff_cells_for_10G_PG);
 
    /* C118 = C25*C16*C113 */
    input_port_threshold->hdrm_ext_buff_cells_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_ext_buff_cells_for_10G_PG);
 
    /* C119 = C25*C16*C114 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG);
 
    /* C120 = C25*C16*C115 */
    input_port_threshold->hdrm_EQEs_pkts_for_10G_total_PG = 
               (_soc_kt2_mmu_params.num_hg_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_EQEs_pkts_for_10G_PG);
 
    /* C122-C125 values are zero for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
            /* C122 */
            input_port_threshold->hdrm_int_buff_cells_for_1G_PG = 26; 
            /* C123 */
            input_port_threshold->hdrm_ext_buff_cells_for_1G_PG =  23;
            /* C124 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG = 23;
        } else {
            /* C122 */
            input_port_threshold->hdrm_int_buff_cells_for_1G_PG = 130;
            /* C123 */
            input_port_threshold->hdrm_ext_buff_cells_for_1G_PG = 0;
            /* C124 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG = 115;
        }
        /* C125 = C124*C49 */
        input_port_threshold->hdrm_EQEs_pkts_for_1G_PG = 
            input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG * 
            _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    }
 
    /* C127 = C19*C16*$C$122 */
    input_port_threshold->hdrm_int_buff_cells_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_int_buff_cells_for_1G_PG);
 
    /* C128 = C19*C16*$C$123 */
    input_port_threshold->hdrm_ext_buff_cells_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_ext_buff_cells_for_1G_PG);
 
    /* C129 = C19*C16*$C$124 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG);
 
    /* C130 = C19*C16*$C$125 */
    input_port_threshold->hdrm_EQEs_pkts_for_1G_total_PG = 
               (_soc_kt2_mmu_params.num_ge_ports_d *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->hdrm_EQEs_pkts_for_1G_PG);
 
    /* C132-C135 values are zero for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
            /* C132 */
            input_port_threshold->hdrm_int_buff_cells_for_olp_port = 76; 
            /* C133 */
            input_port_threshold->hdrm_ext_buff_cells_for_olp_port =  67;
            /* C134 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port = 67;
        } else {
            /* C132 */
            input_port_threshold->hdrm_int_buff_cells_for_olp_port = 180;
            /* C133 */
            input_port_threshold->hdrm_ext_buff_cells_for_olp_port = 0;
            /* C134 */
            input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port = 159;
        }
        /* C135 = C134*C49 */
        input_port_threshold->hdrm_EQEs_pkts_for_olp_port = 
            input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port * 
            _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
    }
 
    /* C137 = 46 */
    input_port_threshold->hdrm_int_buff_cells_for_lpbk_port =  46;
 
    /* C138 = 40 for external buffer  */
    if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
        input_port_threshold->hdrm_ext_buff_cells_for_lpbk_port =  40;
    }
 
    /* C139 = 40 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_lpbk_port =  40;
 
    /* C140 = C139*C49 */
    input_port_threshold->hdrm_EQEs_pkts_for_lpbk_port =  
          input_port_threshold->hdrm_RE_WQEs_pkts_for_lpbk_port *
          _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
 
    /* C142 = 46 */
    input_port_threshold->hdrm_int_buff_cells_for_cpu_port =  46;
 
    /* C143 = 40 for external buffer  */
    if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
        input_port_threshold->hdrm_ext_buff_cells_for_cpu_port =  40;
    }
 
    /* C144 = 40 */
    input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port =  40;
 
    /* C145 = C144*C49 */
    input_port_threshold->hdrm_EQEs_pkts_for_cpu_port =  
          input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port *
          _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
     
    /* C147 = $C$107+$C$117+$C$127+C132+C137+C142 */
    input_port_threshold->total_hdrm_int_buff_cells = 
              input_port_threshold->global_hdrm_cells_for_int_buff_pool +
              input_port_threshold->hdrm_int_buff_cells_for_10G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_1G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_olp_port +
              input_port_threshold->hdrm_int_buff_cells_for_lpbk_port +
              input_port_threshold->hdrm_int_buff_cells_for_cpu_port;
 
    /* C148 = $C$107+$C$117+$C$127+C132+C137+C142. For internal memory=0*/
    if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
        input_port_threshold->total_hdrm_int_buff_ema_pool_cells = 
              input_port_threshold->global_hdrm_cells_for_int_buff_pool +
              input_port_threshold->hdrm_int_buff_cells_for_10G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_1G_total_PG +
              input_port_threshold->hdrm_int_buff_cells_for_olp_port +
              input_port_threshold->hdrm_int_buff_cells_for_lpbk_port +
              input_port_threshold->hdrm_int_buff_cells_for_cpu_port;
    }
 
    /* C149 = $C$108+$C$118+$C$128++C133+C138+C143 */
    input_port_threshold->total_hdrm_ext_buff_cells = 
               input_port_threshold->global_hdrm_cells_for_ext_buff_pool+
               input_port_threshold->hdrm_ext_buff_cells_for_10G_total_PG+
               input_port_threshold->hdrm_ext_buff_cells_for_1G_total_PG+
               input_port_threshold->hdrm_ext_buff_cells_for_olp_port+
               input_port_threshold->hdrm_ext_buff_cells_for_lpbk_port+
               input_port_threshold->hdrm_ext_buff_cells_for_cpu_port;
 
    /* C150 = $C$109+$C$119+$C$129+C134+C139+C144 */
    input_port_threshold->total_hdrm_RE_WQEs_pkts =
               input_port_threshold->global_hdrm_cells_for_RE_WQEs+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_total_PG+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_total_PG+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_lpbk_port+
               input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port;
 
    /* C151 = $C$110+$C$120+$C$130+C135+C140+C145 */
    input_port_threshold->total_hdrm_EQEs_pkts = 
               input_port_threshold->global_hdrm_cells_for_EQEs+
               input_port_threshold->hdrm_EQEs_pkts_for_10G_total_PG+
               input_port_threshold->hdrm_EQEs_pkts_for_1G_total_PG+
               input_port_threshold->hdrm_EQEs_pkts_for_olp_port+
               input_port_threshold->hdrm_EQEs_pkts_for_lpbk_port+
               input_port_threshold->hdrm_EQEs_pkts_for_cpu_port;
 
    /* C153 = $C$69 */
    if (_soc_kt2_mmu_params.lossless_mode_d_c &&
        (_soc_kt2_mmu_params.packing_mode_d_c ||
         _soc_kt2_mmu_params.extbuf_used_d_c) ) {
        /* As per MMU team's suggestion  for avoiding #crash# */
        input_port_threshold->min_int_buff_cells_per_PG = 9;
    } else {
        input_port_threshold->min_int_buff_cells_per_PG = 
                          general_info->jumbo_frame_for_int_buff;
    }
 
    /* C154 = IF($C$17, $C$153, 0) */
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        input_port_threshold->min_int_buff_ema_pool_cells_per_PG = 
                              input_port_threshold->min_int_buff_cells_per_PG;
    }
    
    /* C155 = CEILING(IF($C$17, $C$153/$C$99, 0), 1) */
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        input_port_threshold->min_ext_buff_cells_per_PG = ceil_func(
                              input_port_threshold->min_int_buff_cells_per_PG,
                              general_info->ratio_of_ext_buff_to_int_buff_size);
    }
 
    /* C156 = $C$153/$C$100 */
    input_port_threshold->min_RE_WQEs_pkt_per_PG = 
                              input_port_threshold->min_int_buff_cells_per_PG/
                              general_info->int_buff_cells_per_avg_size_pkt;
 
    /* C157 = $C$153/$C$100*C49 */
    input_port_threshold->min_EQEs_pkt_per_PG = 
               (input_port_threshold->min_int_buff_cells_per_PG/
                general_info->int_buff_cells_per_avg_size_pkt) *
                _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
 
    /* C159 = C75*C16*$C$153 */
    input_port_threshold->min_int_buff_cells_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_int_buff_cells_per_PG) ;
 
    /* C160 = C75*C16*$C$154 */
    input_port_threshold->min_int_buff_ema_pool_cells_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_int_buff_ema_pool_cells_per_PG);
 
    /* C161 = C75*C16*$C$155 */
    input_port_threshold->min_ext_buff_cells_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_ext_buff_cells_per_PG);
 
    /* C162 = C75*C16*$C$156 */
    input_port_threshold->min_RE_WQEs_pkts_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_RE_WQEs_pkt_per_PG) ;
 
    /* C163 = C75*C16*$C$157 */
    input_port_threshold->min_EQEs_pkts_for_total_PG =
               (general_info->total_num_of_ports *
                _soc_kt2_mmu_params.mmu_lossless_pg_num *
                input_port_threshold->min_EQEs_pkt_per_PG) ;
 
   /* C165 = 0 */
   input_port_threshold->min_int_buff_cells_for_a_port = 0;
 
   /* C166 = IF($C$17, $C$165, 0) */
   if (_soc_kt2_mmu_params.extbuf_used_d_c) {
       input_port_threshold->min_int_buff_ema_pool_cells_for_a_port =
         input_port_threshold->min_int_buff_cells_for_a_port ;
   }

   /* C167 = CEILING(IF($C$17, $C$165/$C$99, 0),1) */
   if (_soc_kt2_mmu_params.extbuf_used_d_c) {
       input_port_threshold->min_ext_buff_cells_for_a_port = 
                  input_port_threshold->min_int_buff_cells_for_a_port/    
                  general_info->ratio_of_ext_buff_to_int_buff_size;
   } 
 
   /* C168 = $C$165/$C$100 */
   input_port_threshold->min_RE_WQEs_pkts_for_a_port = 
                         input_port_threshold->min_int_buff_cells_for_a_port /
                         general_info->int_buff_cells_per_avg_size_pkt;
 
   /* C169 = $C$165/$C$100*C49 */
   input_port_threshold->min_EQEs_pkts_for_a_port = 
                         (input_port_threshold->min_int_buff_cells_for_a_port /
                          general_info->int_buff_cells_per_avg_size_pkt) *
                         _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
 

   /* C171 = $C$75*$C$165 */
   input_port_threshold->min_int_buff_cells_for_total_port = 
                         (general_info->total_num_of_ports *
                          input_port_threshold->min_int_buff_cells_for_a_port);
 
   /* C172 = $C$75*$C$166 */
   input_port_threshold->min_int_buff_ema_pool_cells_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_int_buff_ema_pool_cells_for_a_port);
 
   /* C173 = $C$75*$C$167 */
   input_port_threshold->min_ext_buff_cells_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_ext_buff_cells_for_a_port);
 
   /* C174 = $C$75*$C$168 */
   input_port_threshold->min_RE_WQEs_pkts_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_RE_WQEs_pkts_for_a_port);
 
   /* C175 = $C$75*$C$169 */
   input_port_threshold->min_EQEs_pkts_for_total_port = 
                (general_info->total_num_of_ports *
                 input_port_threshold->min_EQEs_pkts_for_a_port);
 
   /* C177 = $C$159+$C$171 */
   input_port_threshold->total_min_int_buff_cells = 
              input_port_threshold->min_int_buff_cells_for_total_PG + 
              input_port_threshold->min_int_buff_cells_for_total_port;

   /* C178 = $C$160+$C$172 */
   input_port_threshold->total_min_int_buff_ema_pool_cells = 
              input_port_threshold->min_int_buff_ema_pool_cells_for_total_PG + 
              input_port_threshold->min_int_buff_ema_pool_cells_for_total_port;

   /* C179 = $C$161+$C$173 */
   input_port_threshold->total_min_ext_buff_cells = 
              input_port_threshold->min_ext_buff_cells_for_total_PG + 
              input_port_threshold->min_ext_buff_cells_for_total_port;

   /* C180 = $C$162+$C$174 */
   input_port_threshold->total_min_RE_WQEs_pkts = 
              input_port_threshold->min_RE_WQEs_pkts_for_total_PG + 
              input_port_threshold->min_RE_WQEs_pkts_for_total_port;

   /* C181 = $C$163+$C$175 */
   input_port_threshold->total_min_EQEs_pkts = 
              input_port_threshold->min_EQEs_pkts_for_total_PG + 
              input_port_threshold->min_EQEs_pkts_for_total_port;

    /* Need to Defer as C183-C196 value depend on C208,C211,C209,C212,C210 values */
                
    /* Fill up output threshold info */
    /* C201 = C55 for lossy mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        output_port_threshold->min_grntd_res_queue_cells_int_buff = 
            _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d;
    }
    
    /* C202 = CEILING(IF($C$14, 0, IF($C$17, $C$201/$C$99, 0)),1) */
    if ((_soc_kt2_mmu_params.lossless_mode_d_c == 0) ||
         _soc_kt2_mmu_params.packing_mode_d_c) { 
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_res_queue_cells_ext_buff = 
                  _soc_kt2_mmu_params.mmu_ext_buf_cell_size == 2880 ?
                  12 : /* LCM of all possible cell usage */
                  ceil_func((output_port_threshold->
                             min_grntd_res_queue_cells_int_buff),
                            (general_info->ratio_of_ext_buff_to_int_buff_size));
        }
    }

    /* C203 = $C$55/$C$100(for lossy:external), $C$55/$C$101(for lossy:internal */
    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_res_queue_cells_EQEs = 
                       _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d/
                       general_info->int_buff_cells_per_avg_size_pkt;
        } else {
            output_port_threshold->min_grntd_res_queue_cells_EQEs = 
                       _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d/
                       general_info->ext_buff_cells_per_avg_size_pkt;

        }
    }

    /* C204 = IF($C$14, 0, IF($C$17, $C$55, 0)) */
    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_res_EMA_queue_cells = 
                  _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d;
        }
    }

    /* C205 = C201 */
    output_port_threshold->min_grntd_res_RE_WQs_cells =
           output_port_threshold->min_grntd_res_queue_cells_int_buff;

    /* C206 = C201 */
    output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff =
           output_port_threshold->min_grntd_res_queue_cells_int_buff;

    /* C207 = CEILING(IF($C$14, 0, IF($C$17, C206/$C$99, 0)),1) */
/* Raj:    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) {  */
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->
                   min_grntd_res_RE_WQs_queue_cells_for_ext_buff = ceil_func(
                   output_port_threshold->
                          min_grntd_res_RE_WQs_queue_cells_for_int_buff,
                   general_info->ratio_of_ext_buff_to_int_buff_size);
        }
/*    } */

    /* C208 = 4 */
    output_port_threshold->min_grntd_res_EP_redirect_queue_entry_cells = 4;
    adjust_min_grntd = 0;
    for(port_index = 0 ; 
        port_index < COUNTOF(port_list);
        port_index++) {

        port = port_list[port_index];

        if (!SOC_PBMP_MEMBER(valid_port_cpu_pbmp, port)) {
            continue;
        }

        buf_port = &buf->ports[port];
      
        for (queue = si->port_uc_cosq_base[port];
                queue < si->port_uc_cosq_base[port] + 
                si->port_num_uc_cosq[port];
                queue++) {
            /* caluculating idx as per the mmu_config tool*/
            idx = si->port_num_cosq[port] + queue - si->port_uc_cosq_base[port];
            buf_queue = &buf_port->queues[idx];
            if (buf_queue->guarantee) {
                adjust_min_grntd += 
                    (buf_queue->guarantee - 
                    output_port_threshold->min_grntd_res_queue_cells_int_buff);
            }

        }
    }

    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        /* C210 = C85*$C$201 */
        output_port_threshold->min_grntd_tot_res_queue_cells_int_buff =
              general_info->total_int_buff_queues *
              output_port_threshold->min_grntd_res_queue_cells_int_buff;
    } else {
        /* C210 = ($C$80+C82)*$C$201+IF(C33=0,C32*C31*C72)+(C35+C36/2)*C72 */
        output_port_threshold->min_grntd_tot_res_queue_cells_int_buff = 
                   (general_info->total_egr_queues_for_a_int_ge_ports + 
                    general_info->total_egr_queues_for_a_int_hg_ports) *
                   output_port_threshold->min_grntd_res_queue_cells_int_buff;
        if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c == 0) {
            output_port_threshold->min_grntd_tot_res_queue_cells_int_buff += 
                        _soc_kt2_mmu_params.mmu_num_cpu_queue *
                        _soc_kt2_mmu_params.mmu_num_cpu_port *
                        general_info->ether_mtu_cells_for_int_buff;
        } 
        output_port_threshold->min_grntd_tot_res_queue_cells_int_buff +=
               (_soc_kt2_mmu_params.mmu_num_loopback_queue + 
                (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue/2)) *
               general_info->ether_mtu_cells_for_int_buff;
    }

    output_port_threshold->min_grntd_tot_res_queue_cells_int_buff += adjust_min_grntd;

    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        /* C211 = $C$86*$C$202 */
        output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff =
              general_info->total_ext_buff_queues *
              output_port_threshold->min_grntd_res_queue_cells_ext_buff;
    } else {
        /* C211 = ($C$81+C83)*$C$202+IF(C33=1,C32*C31, 0)*C72+IF(C17=1, (C36/2)*C72, 0) */
        /* Packed Lossless : C211 = ($C$81+C83-C19*8)*$C$202+IF(C33=1,C32*C31, 0)*C72+IF(C17=1, (C36/2)*C72, 0) */
        output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff =
               (general_info->total_egr_queues_for_a_ext_ge_ports  + 
                general_info->total_egr_queues_for_a_ext_hg_ports);
        output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff *=
                    output_port_threshold->min_grntd_res_queue_cells_ext_buff;
        if (_soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c) {
            output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff +=
                  (_soc_kt2_mmu_params.mmu_num_cpu_queue * 
                   _soc_kt2_mmu_params.mmu_num_cpu_port * 
                   general_info->ether_mtu_cells_for_int_buff);
        }
        if (_soc_kt2_mmu_params.extbuf_used_d_c) {
            output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff +=
                  (_soc_kt2_mmu_params.mmu_num_ep_redirection_queue/2)*
                   general_info->ether_mtu_cells_for_int_buff;
        }
    }
    adjust_min_grntd = 0;
    for(port_index = 0 ; 
            port_index < COUNTOF(port_list);
            port_index++ ) {

        port = port_list[port_index];

        if (!SOC_PBMP_MEMBER(valid_port_cpu_pbmp, port)) {
            continue;
        }

        buf_port = &buf->ports[port];
        for (queue = si->port_uc_cosq_base[port];
                queue < si->port_uc_cosq_base[port] + si->port_num_uc_cosq[port];
                queue++) {
            idx = si->port_num_cosq[port] + queue - si->port_uc_cosq_base[port];
            buf_queue = &buf_port->queues[idx];
            if (buf_queue->pkt_guarantee) {
                adjust_min_grntd += 
                    (buf_queue->pkt_guarantee - 
                     output_port_threshold->min_grntd_res_queue_cells_EQEs);
            }

        }
    }

    if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) { 
        /* C212 = C90*$C$203 */
        /* Packed Lossy : C212 = (C90-C19*8)*$C$203 */
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs = 
              general_info->total_egr_queues_in_device;
        if (_soc_kt2_mmu_params.packing_mode_d_c) {
            output_port_threshold->min_grntd_tot_res_queue_cells_EQEs -= 
                _soc_kt2_mmu_params.num_ge_ports_d * 8;
        }
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs *=
              output_port_threshold->min_grntd_res_queue_cells_EQEs;
    } else {
        /* C212 = =SUM(C80:C83)*$C$203+C32*C31*C72+C37*C38*C203+(C35+C36)*C72 */
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs = 
               (general_info->total_egr_queues_for_a_int_ge_ports +
                general_info->total_egr_queues_for_a_ext_ge_ports +
                general_info->total_egr_queues_for_a_int_hg_ports +
                general_info->total_egr_queues_for_a_int_hg_ports) *
                output_port_threshold->min_grntd_res_queue_cells_EQEs;
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs +=
                  (_soc_kt2_mmu_params.mmu_num_cpu_queue * 
                   _soc_kt2_mmu_params.mmu_num_cpu_port * 
                   general_info->ether_mtu_cells_for_int_buff);
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs +=
                   _soc_kt2_mmu_params.mmu_num_olp_port_d * 
                   _soc_kt2_mmu_params.mmu_num_olp_queue * 
                   output_port_threshold->min_grntd_res_queue_cells_EQEs;
        output_port_threshold->min_grntd_tot_res_queue_cells_EQEs +=
                  (_soc_kt2_mmu_params.mmu_num_loopback_queue +
                   _soc_kt2_mmu_params.mmu_num_ep_redirection_queue) *
                   general_info->ether_mtu_cells_for_int_buff;
    }
    output_port_threshold->min_grntd_tot_res_queue_cells_EQEs += adjust_min_grntd;

    /* C213 = $C$52*$C$204 */
    output_port_threshold->min_grntd_tot_res_EMA_queue_cells = 
              _soc_kt2_mmu_params.mmu_ema_queues *
              output_port_threshold->min_grntd_res_EMA_queue_cells;

    adjust_min_grntd = 0;
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEQr); cos++) {
        buf_rqe_queue = &buf->rqe_queues[cos];
        if (buf_rqe_queue->pkt_guarantee) {
            adjust_min_grntd +=  (buf_rqe_queue->pkt_guarantee -
                    output_port_threshold->min_grntd_res_RE_WQs_cells);
        }
    } 
    /* C214 = $C$51*$C$205 */
    output_port_threshold->min_grntd_tot_res_RE_WQs_cells = 
              _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device *
              output_port_threshold->min_grntd_res_RE_WQs_cells;
    output_port_threshold->min_grntd_tot_res_RE_WQs_cells += adjust_min_grntd; 
    
    adjust_min_grntd = 0;
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEIr); cos++) {
        buf_rqe_queue = &buf->rqe_queues[cos];
        
        if (buf_rqe_queue->guarantee) {
            adjust_min_grntd += (buf_rqe_queue->guarantee -
                    output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff);
        }
    }   
    /* C215 = $C$51*$C$206 */
    output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff = 
           _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device *
           output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff;

    output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff += adjust_min_grntd;
   
    adjust_min_grntd = 0;
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEEr); cos++) {
        buf_rqe_queue = &buf->rqe_queues[cos];
        if (buf_rqe_queue->ext_guarantee) {
            adjust_min_grntd += (buf_rqe_queue->ext_guarantee -
                    output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_ext_buff);
        }
    }
 
    /* C216 = $C$51*$C$207 */
    output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff = 
           _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device *
           output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_ext_buff;
    
    output_port_threshold->
        min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff += adjust_min_grntd; 

    /* C217 = C208*(C36) */
    output_port_threshold->min_grntd_tot_res_EP_redirect_queue_entry_cells = 
           _soc_kt2_mmu_params.mmu_num_ep_redirection_queue *
           output_port_threshold->min_grntd_res_EP_redirect_queue_entry_cells;

    /* Resuming C183-C196 values as C210,C213,C211,C214,C212 values are 
       available  now*/

    /* For Lossless : C183 = $C$94-$C$177 -$C$147 -$C$210 */
    /* For Lossy    : C183 = $C$94-$C$177 -$C$147 */
    input_port_threshold->total_shared_ing_buff_pool =
           general_info->int_buff_pool - 
           input_port_threshold->total_min_int_buff_cells -
           input_port_threshold->total_hdrm_int_buff_cells;
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if ( input_port_threshold->total_shared_ing_buff_pool <
                output_port_threshold->min_grntd_tot_res_queue_cells_int_buff) {
            return BCM_E_RESOURCE;
        }
        input_port_threshold->total_shared_ing_buff_pool -=
              output_port_threshold->min_grntd_tot_res_queue_cells_int_buff;
    }

    /* C184 = $C$95-$C$178-$C$213 */
    /* IntMemLossy       =  =IF(C17,$C$95-$C$178-$C$148,0) */ 
    /* IntMemLossless       =IF(C17,$C$95-$C$178-$C$148 -$C$213,0) */
    /* IntExtMemLossy       ==      $C$95-$C$178-$C$148 */
    /* IntExtMemLossless    ==      $C$95-$C$178-$C$148 -$C$213 */
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        input_port_threshold->total_shared_EMA_buff =
           general_info->ema_pool - 
           input_port_threshold->total_min_int_buff_ema_pool_cells -
           input_port_threshold->total_hdrm_int_buff_ema_pool_cells;
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            input_port_threshold->total_shared_EMA_buff -=
               output_port_threshold->min_grntd_tot_res_EMA_queue_cells;
        }
    }

    /* C185 = if (lossless)     $C$96-$C$149-$C$179-$C$211 
              if (lossy)        $C$96-$C$149-$C$179
              Packed Lossless   $C$96-$C$149-$C$179-$C$211-C54  
              Packed Lossy      $C$96-$C$149-$C$179-C54 */
    input_port_threshold->total_shared_ext_buff =
           general_info->max_ext_cell_buff_size - 
           input_port_threshold->total_hdrm_ext_buff_cells -
           input_port_threshold->total_min_ext_buff_cells;
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        input_port_threshold->total_shared_ext_buff -=
           output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff;
    }
    if (_soc_kt2_mmu_params.packing_mode_d_c) {
        input_port_threshold->total_shared_ext_buff -=
           _soc_kt2_mmu_params.num_cells_rsrvd_ing_ext_buf;
    }

    /* C186 = if (lossless)     ($C$50*1024)-$C$150-$C$180-$C$214
              if (lossy)        ($C$50*1024)-$C$150-$C$180       */
    input_port_threshold->total_shared_RE_WQEs_buff =
              (_soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries*1024) -
              input_port_threshold->total_hdrm_RE_WQEs_pkts -
              input_port_threshold->total_min_RE_WQEs_pkts;
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if (input_port_threshold->total_shared_RE_WQEs_buff <
                output_port_threshold->min_grntd_tot_res_RE_WQs_cells) {
            return SOC_E_RESOURCE;
        }
        input_port_threshold->total_shared_RE_WQEs_buff -=
           output_port_threshold->min_grntd_tot_res_RE_WQs_cells;
    }

    /* C187 = if (lossless)     ($C$47*1024)-$C$151-$C$181-$C$212
              if (lossy)        ($C$47*1024)-$C$151-$C$181    */
    input_port_threshold->total_shared_EQEs_buff =
             (_soc_kt2_mmu_params.mmu_egress_queue_entries * 1024) -
             input_port_threshold->total_hdrm_EQEs_pkts - 
             input_port_threshold->total_min_EQEs_pkts; 
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        if (input_port_threshold->total_shared_EQEs_buff <
                output_port_threshold->min_grntd_tot_res_queue_cells_EQEs) {
            return BCM_E_RESOURCE;
        }
        input_port_threshold->total_shared_EQEs_buff -=
           output_port_threshold->min_grntd_tot_res_queue_cells_EQEs;
    }

    /* C189 = FLOOR(($C$57*$C$183)/(1+($C$57*1)),1) */
    input_port_threshold->ingress_burst_cells_size_for_one_port = floor_func(
              (_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param * 
               input_port_threshold->total_shared_ing_buff_pool),
              (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*1)));

    /* C190 = FLOOR(($C$57*$C$187)/(1+($C$57*1)),1) */
    input_port_threshold->ingress_burst_pkts_size_for_one_port = floor_func(
              (_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param *
               input_port_threshold->total_shared_EQEs_buff),
              (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*1)));

    /* C191 = FLOOR(($C$57*$C$183)/(1+($C$57*$C$75)),1) */
    input_port_threshold->ingress_burst_cells_size_for_all_ports = floor_func(
                         (_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param *
                          input_port_threshold->total_shared_ing_buff_pool),
                         (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*
                             general_info->total_num_of_ports)));

    /* C192 = ($C$191+$C$165)*$C$75 */
    input_port_threshold->ingress_total_shared_cells_use_for_all_port = 
          (input_port_threshold->ingress_burst_cells_size_for_all_ports + 
           input_port_threshold->min_int_buff_cells_for_a_port) * 
           general_info->total_num_of_ports;

    /* C193 = FLOOR(($C$57*$C$187)/(1+($C$57*$C$75)),1) */
    input_port_threshold->ingress_burst_pkts_size_for_all_port = floor_func(
           _soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param *
           input_port_threshold->total_shared_EQEs_buff,
           (1+(_soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param*
               general_info->total_num_of_ports)));

    /* C194 = ($C$193+$C$169)*$C$75 */
    input_port_threshold->ingress_total_shared_pkts_use_for_all_port =
              (input_port_threshold->ingress_burst_pkts_size_for_all_port+
               input_port_threshold->min_EQEs_pkts_for_a_port) * 
              general_info->total_num_of_ports;

    if ((ext_mem_port_count == 0) &&
        (_soc_kt2_mmu_params.lossless_mode_d_c == 0) &&
        (_soc_kt2_mmu_params.packing_mode_d_c == 0)) { 
        /* C195 = $C$192+C147 */
        input_port_threshold->ingress_total_shared_hdrm_cells_use_for_all_port =
          input_port_threshold->ingress_total_shared_cells_use_for_all_port +
          input_port_threshold->total_hdrm_int_buff_cells;
    } else {
        /* C195 = $C$192+C132 */
        input_port_threshold->ingress_total_shared_hdrm_cells_use_for_all_port =
          input_port_threshold->ingress_total_shared_cells_use_for_all_port +
          input_port_threshold->hdrm_int_buff_cells_for_olp_port;
    }

    if ((ext_mem_port_count == 0) &&
        (_soc_kt2_mmu_params.lossless_mode_d_c == 0) &&
        (_soc_kt2_mmu_params.packing_mode_d_c == 0)) { 
        /* C196 = $C$194+C151 */
        input_port_threshold->ingress_total_shared_hdrm_pkts_use_for_all_port = 
          input_port_threshold->ingress_total_shared_pkts_use_for_all_port +
          input_port_threshold->total_hdrm_EQEs_pkts;
    } else {
        /* C196 = $C$194+C135 */
        input_port_threshold->ingress_total_shared_hdrm_pkts_use_for_all_port = 
          input_port_threshold->ingress_total_shared_pkts_use_for_all_port +
          input_port_threshold->hdrm_EQEs_pkts_for_olp_port;
    }

    if ((_soc_kt2_mmu_params.lossless_mode_d_c == 0) && 
        (_soc_kt2_mmu_params.extbuf_used_d_c)) {
        /* C219 = =$C$94-$C$210-C215 */
        if ( general_info->int_buff_pool < ( output_port_threshold->
                    min_grntd_tot_res_queue_cells_int_buff +
                    output_port_threshold->
                    min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff)) {
            return BCM_E_RESOURCE;
        }
        output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff = 
                  general_info->int_buff_pool -
                  output_port_threshold->
                         min_grntd_tot_res_queue_cells_int_buff-
                  output_port_threshold->
                         min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff;
    } else { 
        /* C219 = IF($C$45, $C$92, $C$91)-$C$210-C215 */
        if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c ) {
            output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff = 
                  general_info->int_cell_buff_size_after_limitation;
        } else {
            output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff = 
                  general_info->max_int_cell_buff_size ;
        }
        if ( output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff <
                (output_port_threshold->min_grntd_tot_res_queue_cells_int_buff +
                output_port_threshold->
                                  min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff)) {
            return BCM_E_RESOURCE;
        }
        output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff -= 
           output_port_threshold->min_grntd_tot_res_queue_cells_int_buff ;
        output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff -= 
           output_port_threshold->
                  min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff;
    }

    /* C220 = $C$96-$C$211-C216 */
    output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff = 
       general_info->max_ext_cell_buff_size -
       output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff;
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        if (output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff  <
                output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff) {
            return SOC_E_RESOURCE;
        }
       output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff -= 
       output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff;
    }

    if ((_soc_kt2_mmu_params.mmu_egress_queue_entries*1024) <
             output_port_threshold->min_grntd_tot_res_queue_cells_EQEs) {
        return SOC_E_RESOURCE;
    }
    /* C221  = $C$47*1024-$C$212 */
    output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs =
                (_soc_kt2_mmu_params.mmu_egress_queue_entries*1024) -
                output_port_threshold->min_grntd_tot_res_queue_cells_EQEs;

    if ((_soc_kt2_mmu_params.lossless_mode_d_c) && 
        (_soc_kt2_mmu_params.extbuf_used_d_c)) {
        /* C222 = IF($C$45,$C$92,$C$91)-$C$213 */
        if (_soc_kt2_mmu_params.internal_buffer_reduction_d_c ) {
            output_port_threshold->min_grntd_tot_shr_EMA_queue_cells =
                              general_info->int_cell_buff_size_after_limitation;
        } else {
            output_port_threshold->min_grntd_tot_shr_EMA_queue_cells =
                              general_info->max_int_cell_buff_size;
        }
        output_port_threshold->min_grntd_tot_shr_EMA_queue_cells -=
                    output_port_threshold->min_grntd_tot_res_EMA_queue_cells;
    } else {
        /* C222 = =$C$95-$C$213 */
        output_port_threshold->min_grntd_tot_shr_EMA_queue_cells =
                   general_info->ema_pool - 
                   output_port_threshold->min_grntd_tot_res_EMA_queue_cells;
    }
    if ((_soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries * 1024) <
             output_port_threshold->min_grntd_tot_res_RE_WQs_cells) {
        return SOC_E_RESOURCE;
    }
    /* C223 = =$C$50*1024-$C$214 */
    output_port_threshold->min_grntd_tot_shr_RE_WQs_cells = 
                (_soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries * 1024)-
                output_port_threshold->min_grntd_tot_res_RE_WQs_cells;

    /* C224 = =C219 */
    output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff = 
           output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff ;

    /* C225 =  =C220*/
    if (_soc_kt2_mmu_params.extbuf_used_d_c) {
        output_port_threshold->
        min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff = 
           output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff ;
    } else {
        /* C225 = =$C$95-$C$216 */
        output_port_threshold->
               min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff = 
                 general_info->ema_pool -  
                 output_port_threshold->
                        min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff;

    }

    /* C226 = =C48-C217 */
    output_port_threshold->min_grntd_tot_shr_EP_redirect_queue_entry_cells =
         _soc_kt2_mmu_params.mmu_ep_redirect_queue_entries - 
         output_port_threshold->min_grntd_tot_res_EP_redirect_queue_entry_cells; 
    /* C227 = 2 */
    output_port_threshold->egress_queue_dynamic_threshold_parameter = 2;

    /* C228 = =FLOOR( ($C$59*$C$219)/(1+($C$59*1)), 1) */
    output_port_threshold->egress_burst_cells_size_for_one_queue = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param * 
                 output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param*1)));

    /* C229 = =FLOOR( ($C$59*$C$221)/(1+($C$59*1)), 1) */
    output_port_threshold->egress_burst_pkts_size_for_one_queue = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param * 1)));

    /* C230 = =FLOOR( ($C$59*$C$219)/(1+($C$59*$C$75)), 1) */
    output_port_threshold->egress_burst_cells_size_for_all_ports = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_num_of_ports)));

    /* C231 = =FLOOR( ($C$59*$C$221)/(1+($C$59*$C$75)), 1) */
    output_port_threshold->egress_burst_pkts_size_for_all_ports = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_num_of_ports)));

    /* C232 = =FLOOR( ($C$59*$C$219)/(1+($C$59*C90)), 1) */
    output_port_threshold->egress_burst_cells_size_for_all_queues = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_egr_queues_in_device)));
    
    /* C233 = =FLOOR( ($C$59*$C$221)/(1+($C$59*C90)), 1) */
    output_port_threshold->egress_burst_pkts_size_for_all_queues = floor_func(
                (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *  
                 output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs),
                (1 + (_soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param *
                      general_info->total_egr_queues_in_device)));

    /* C234 = =C90*$C$232 */
    output_port_threshold->egress_total_use_in_cells_for_all_queues =
           general_info->total_egr_queues_in_device *
           output_port_threshold->egress_burst_cells_size_for_all_queues;

    /* C235 = =C90*$C$233 */
    output_port_threshold->egress_total_use_in_pkts_for_all_queues =
           general_info->total_egr_queues_in_device *
           output_port_threshold->egress_burst_pkts_size_for_all_queues;

    /* C236 =$C$219-C234 */
    output_port_threshold->egress_remaining_cells_for_all_queues =
           output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff -
           output_port_threshold->egress_total_use_in_cells_for_all_queues;

    /* C237 = =$C$221-C235 */
    output_port_threshold->egress_remaining_pkts_for_all_queues =
           output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs -
           output_port_threshold->egress_total_use_in_pkts_for_all_queues;

#if 0
        LOG_CLI((BSL_META_U(unit,
                            "C5 %d\n"), _soc_kt2_mmu_params.mmu_min_pkt_size));                   /*C5*/
        LOG_CLI((BSL_META_U(unit,
                            "C6 %d\n"), _soc_kt2_mmu_params.mmu_ethernet_mtu_bytes));             /*C6*/
        LOG_CLI((BSL_META_U(unit,
                            "C7 %d\n"), _soc_kt2_mmu_params.mmu_max_pkt_size));                   /*C7*/
        LOG_CLI((BSL_META_U(unit,
                            "C8 %d\n"), _soc_kt2_mmu_params.mmu_jumbo_frame_size));               /*C8*/
        LOG_CLI((BSL_META_U(unit,
                            "C9 %d\n"), _soc_kt2_mmu_params.mmu_int_buf_cell_size));              /*C9*/
        LOG_CLI((BSL_META_U(unit,
                            "C10 %d\n"), _soc_kt2_mmu_params.mmu_ext_buf_cell_size));              /*C10=2880*/
        LOG_CLI((BSL_META_U(unit,
                            "C11 %d\n"), _soc_kt2_mmu_params.mmu_pkt_header_size));                /*C11*/
        LOG_CLI((BSL_META_U(unit,
                            "C12 %d\n"), _soc_kt2_mmu_params.packing_mode_d_c));                   /* C12:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C13 %d\n"), _soc_kt2_mmu_params.max_pkt_size_support_packing));        /* C13:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C14 %d\n"), _soc_kt2_mmu_params.lossless_mode_d_c));                  /* C14:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C15 %d\n"), _soc_kt2_mmu_params.pfc_pause_mode_d_c));                 /* C15:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C16 %d\n"), _soc_kt2_mmu_params.mmu_lossless_pg_num));                /*C16*/
        LOG_CLI((BSL_META_U(unit,
                            "C17 %d\n"), _soc_kt2_mmu_params.extbuf_used_d_c));                    /* C17:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C19 %d\n"), _soc_kt2_mmu_params.num_ge_ports_d));                     /* C19:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C20 %d\n"), _soc_kt2_mmu_params.mmu_line_rate_ge));                   /*C20*/
        LOG_CLI((BSL_META_U(unit,
                            "C21 %d\n"), _soc_kt2_mmu_params.num_ge_int_ports_d));                 /* C21:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C22 %d\n"), _soc_kt2_mmu_params.num_egr_queue_per_int_ge_port_d));    /* C22:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C23 %d\n"), _soc_kt2_mmu_params.num_ge_ext_ports_d));                 /* C23:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C25 %d\n"), _soc_kt2_mmu_params.num_egr_queue_per_ext_ge_port_d));    /* C24:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C25 %d\n"), _soc_kt2_mmu_params.num_hg_ports_d));                     /* C25:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C26 %d\n"), _soc_kt2_mmu_params.mmu_line_rate_hg));                   /*C26*/
        LOG_CLI((BSL_META_U(unit,
                            "C27 %d\n"), _soc_kt2_mmu_params.num_hg_int_ports_d));                 /* C27:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C28 %d\n"), _soc_kt2_mmu_params.num_egr_queue_per_int_hg_port_d));    /* C28:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C29 %d\n"), _soc_kt2_mmu_params.num_hg_ext_ports_d));                 /* C29:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C30 %d\n"), _soc_kt2_mmu_params.num_egr_queue_per_ext_hg_port_d));    /* C30:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C31 %d\n"), _soc_kt2_mmu_params.mmu_num_cpu_port));                   /*C31*/
        LOG_CLI((BSL_META_U(unit,
                            "C32 %d\n"), _soc_kt2_mmu_params.mmu_num_cpu_queue));                  /*C32*/
        LOG_CLI((BSL_META_U(unit,
                            "C33 %d\n"), _soc_kt2_mmu_params.cpu_port_int_ext_bounding_d_c));      /* C33:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C34 %d\n"), _soc_kt2_mmu_params.mmu_num_loopback_port));              /*C34*/
        LOG_CLI((BSL_META_U(unit,
                            "C35 %d\n"), _soc_kt2_mmu_params.mmu_num_loopback_queue));             /*C35*/
        LOG_CLI((BSL_META_U(unit,
                            "C36 %d\n"), _soc_kt2_mmu_params.mmu_num_ep_redirection_queue));       /*C36*/
        LOG_CLI((BSL_META_U(unit,
                            "C37 %d\n"), _soc_kt2_mmu_params.mmu_num_olp_port_d));                 /*C37*/
        LOG_CLI((BSL_META_U(unit,
                            "C38 %d\n"), _soc_kt2_mmu_params.mmu_num_olp_queue));                  /*C38*/
        LOG_CLI((BSL_META_U(unit,
                            "C39 %d\n"), _soc_kt2_mmu_params.olp_port_int_ext_bounding_d_c));      /* C39:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C41 %d\n"), _soc_kt2_mmu_params.mmu_int_buf_size));                   /*C41:2048KB=2MB*/
        LOG_CLI((BSL_META_U(unit,
                            "C42 %d\n"), _soc_kt2_mmu_params.mmu_available_int_buf_size_d));       /*C42:1434KB */
        LOG_CLI((BSL_META_U(unit,
                            "C43 %d\n"), _soc_kt2_mmu_params.mmu_reserved_int_buf_cells));         /*C43:100 Cells */
        LOG_CLI((BSL_META_U(unit,
                            "C44 %d\n"), _soc_kt2_mmu_params.mmu_reserved_int_buf_ema_pool_size_d)); /*C44:614KB */
        LOG_CLI((BSL_META_U(unit,
                            "C45 %d\n"), _soc_kt2_mmu_params.internal_buffer_reduction_d_c));        /* C45:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C46 %d\n"), _soc_kt2_mmu_params.mmu_ext_buf_size));                   /*C46:737280KB=720MB*/
        LOG_CLI((BSL_META_U(unit,
                            "C47 %d\n"), _soc_kt2_mmu_params.mmu_egress_queue_entries));           /*C47*/
        LOG_CLI((BSL_META_U(unit,
                            "C48 %d\n"), _soc_kt2_mmu_params.mmu_ep_redirect_queue_entries));      /*C48*/
        LOG_CLI((BSL_META_U(unit,
                            "C49 %d\n"), _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt));        /*C49*/
        LOG_CLI((BSL_META_U(unit,
                            "C50 %d\n"), _soc_kt2_mmu_params.mmu_repl_engine_work_queue_entries)); /*C50*/
        LOG_CLI((BSL_META_U(unit,
                            "C51 %d\n"), _soc_kt2_mmu_params.mmu_repl_engine_work_queue_in_device));/*C51*/
        LOG_CLI((BSL_META_U(unit,
                            "C52 %d\n"), _soc_kt2_mmu_params.mmu_ema_queues));                     /*C52*/
        LOG_CLI((BSL_META_U(unit,
                            "C54 %d\n"), _soc_kt2_mmu_params.num_cells_rsrvd_ing_ext_buf));        /* C54:Dynamic */     
        LOG_CLI((BSL_META_U(unit,
                            "C55 %d\n"), _soc_kt2_mmu_params.per_cos_res_cells_for_int_buff_d));   /* C55:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C56 %d\n"), _soc_kt2_mmu_params.per_cos_res_cells_for_ext_buff_d));   /* C56:Dynamic */
        LOG_CLI((BSL_META_U(unit,
                            "C57 %d\n"), _soc_kt2_mmu_params.mmu_ing_port_dyn_thd_param));         /*C57*/
        LOG_CLI((BSL_META_U(unit,
                            "C58 %d\n"), _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param));           /*C58*/
        LOG_CLI((BSL_META_U(unit,
                            "C59 %d\n"), _soc_kt2_mmu_params.mmu_egr_queue_dyn_thd_param));        /*C59*/
        LOG_CLI((BSL_META_U(unit,
                            "C60 %d\n"), _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param));           /*C60*/
        LOG_CLI((BSL_META_U(unit,
                            "C61 %d\n"), _soc_kt2_mmu_params.mmu_ing_cell_buf_reduction));         /*C61 */
        LOG_CLI((BSL_META_U(unit,
                            "C62 %d\n"), _soc_kt2_mmu_params.mmu_ing_pkt_buf_reduction));          /*C62 */
        
        LOG_CLI((BSL_META_U(unit,
                            "C68 %d\n"), general_info->max_packet_size_in_cells));                         /* C68 */
        LOG_CLI((BSL_META_U(unit,
                            "C69 %d\n"), general_info->jumbo_frame_for_int_buff));                         /* C69 */
        LOG_CLI((BSL_META_U(unit,
                            "C70 %d\n"), general_info->jumbo_frame_for_ext_buff));                         /* C70 */
        LOG_CLI((BSL_META_U(unit,
                            "C72 %d\n"), general_info->ether_mtu_cells_for_int_buff));                     /* C72 */
        LOG_CLI((BSL_META_U(unit,
                            "C73 %d\n"), general_info->ether_mtu_cells_for_ext_buff));                     /* C73 */
        LOG_CLI((BSL_META_U(unit,
                            "C75 %d\n"), general_info->total_num_of_ports));                               /* C75 */
        LOG_CLI((BSL_META_U(unit,
                            "C76 %d\n"), general_info->total_num_of_ports_excl_lpbk));                     /* C76 */
        LOG_CLI((BSL_META_U(unit,
                            "C77 %d\n"), general_info->total_num_of_ports_excl_lpbk_olp));                 /* C77 */
        LOG_CLI((BSL_META_U(unit,
                            "C78 %d\n"), general_info->total_num_of_ports_excl_lpbk_olp_cpu));             /* C78 */
        LOG_CLI((BSL_META_U(unit,
                            "C79 %d\n"), general_info->port_bw_bound_to_ext_buff));                        /* C79 */
        LOG_CLI((BSL_META_U(unit,
                            "C80 %d\n"), general_info->total_egr_queues_for_a_int_ge_ports));              /* C80 */
        LOG_CLI((BSL_META_U(unit,
                            "C81 %d\n"), general_info->total_egr_queues_for_a_ext_ge_ports));              /* C81 */
        LOG_CLI((BSL_META_U(unit,
                            "C82 %d\n"), general_info->total_egr_queues_for_a_int_hg_ports));              /* C82 */
        LOG_CLI((BSL_META_U(unit,
                            "C83 %d\n"), general_info->total_egr_queues_for_a_ext_hg_ports));              /* C83 */
        LOG_CLI((BSL_META_U(unit,
                            "C84 %d\n"), general_info->total_cpu_queues));                                 /* C84 */
        LOG_CLI((BSL_META_U(unit,
                            "C85 %d\n"), general_info->total_int_buff_queues));                            /* C85 */
        LOG_CLI((BSL_META_U(unit,
                            "C86 %d\n"), general_info->total_ext_buff_queues));                            /* C86 */
        LOG_CLI((BSL_META_U(unit,
                            "C87 %d\n"), general_info->total_ema_queues));                                 /* C87 */
        LOG_CLI((BSL_META_U(unit,
                            "C90 %d\n"), general_info->total_egr_queues_in_device));                       /* C90 */
        LOG_CLI((BSL_META_U(unit,
                            "C91 %d\n"), general_info->max_int_cell_buff_size));                           /* C91 */
        LOG_CLI((BSL_META_U(unit,
                            "C92 %d\n"), general_info->int_cell_buff_size_after_limitation));              /* C92 */
        LOG_CLI((BSL_META_U(unit,
                            "C93 %d\n"), general_info->src_packing_fifo));                                 /* C93 */
        LOG_CLI((BSL_META_U(unit,
                            "C94 %d\n"), general_info->int_buff_pool));                                    /* C94 */
        LOG_CLI((BSL_META_U(unit,
                            "C95 %d\n"), general_info->ema_pool));                                         /* C95 */
        LOG_CLI((BSL_META_U(unit,
                            "C96 %d\n"), general_info->max_ext_cell_buff_size));                           /* C96 */
        LOG_CLI((BSL_META_U(unit,
                            "C99 %d\n"), general_info->ratio_of_ext_buff_to_int_buff_size));               /* C99 */
        LOG_CLI((BSL_META_U(unit,
                            "C100 %d\n"), general_info->int_buff_cells_per_avg_size_pkt));                  /* C100 */
        LOG_CLI((BSL_META_U(unit,
                            "C101 %d\n"), general_info->ext_buff_cells_per_avg_size_pkt));                  /* C101 */
        LOG_CLI((BSL_META_U(unit,
                            "C102 %d\n"), general_info->max_prop_of_buff_used_by_one_queue_port));          /* C102*/
        
        LOG_CLI((BSL_META_U(unit,
                            "C107 %d\n"), input_port_threshold->global_hdrm_cells_for_int_buff_pool));              /* C107 */
        LOG_CLI((BSL_META_U(unit,
                            "C108 %d\n"), input_port_threshold->global_hdrm_cells_for_ext_buff_pool));              /* C108 */
        LOG_CLI((BSL_META_U(unit,
                            "C109 %d\n"), input_port_threshold->global_hdrm_cells_for_RE_WQEs));                    /* C109 */
        LOG_CLI((BSL_META_U(unit,
                            "C110 %d\n"), input_port_threshold->global_hdrm_cells_for_EQEs));                       /* C110 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C112 %d\n"), input_port_threshold->hdrm_int_buff_cells_for_10G_PG));                   /* C112 */
        LOG_CLI((BSL_META_U(unit,
                            "C113 %d\n"), input_port_threshold->hdrm_ext_buff_cells_for_10G_PG));                   /* C113 */
        LOG_CLI((BSL_META_U(unit,
                            "C114 %d\n"), input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG));                     /* C114 */
        LOG_CLI((BSL_META_U(unit,
                            "C115 %d\n"), input_port_threshold->hdrm_EQEs_pkts_for_10G_PG));                        /* C115 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C117 %d\n"), input_port_threshold->hdrm_int_buff_cells_for_10G_total_PG));             /* C117 */
        LOG_CLI((BSL_META_U(unit,
                            "C118 %d\n"), input_port_threshold->hdrm_ext_buff_cells_for_10G_total_PG));             /* C118 */
        LOG_CLI((BSL_META_U(unit,
                            "C119 %d\n"), input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_total_PG));               /* C119 */
        LOG_CLI((BSL_META_U(unit,
                            "C120 %d\n"), input_port_threshold->hdrm_EQEs_pkts_for_10G_total_PG));                  /* C120 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C122 %d\n"), input_port_threshold->hdrm_int_buff_cells_for_1G_PG));                    /* C122 */
        LOG_CLI((BSL_META_U(unit,
                            "C123 %d\n"), input_port_threshold->hdrm_ext_buff_cells_for_1G_PG));                    /* C123 */
        LOG_CLI((BSL_META_U(unit,
                            "C124 %d\n"), input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG));                      /* C124 */
        LOG_CLI((BSL_META_U(unit,
                            "C125 %d\n"), input_port_threshold->hdrm_EQEs_pkts_for_1G_PG));                         /* C125 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C127 %d\n"), input_port_threshold->hdrm_int_buff_cells_for_1G_total_PG));              /* C127 */
        LOG_CLI((BSL_META_U(unit,
                            "C128 %d\n"), input_port_threshold->hdrm_ext_buff_cells_for_1G_total_PG));              /* C128 */
        LOG_CLI((BSL_META_U(unit,
                            "C129 %d\n"), input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_total_PG));                /* C129 */
        LOG_CLI((BSL_META_U(unit,
                            "C130 %d\n"), input_port_threshold->hdrm_EQEs_pkts_for_1G_total_PG));                   /* C130 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C132 %d\n"), input_port_threshold->hdrm_int_buff_cells_for_olp_port));                 /* C132 */
        LOG_CLI((BSL_META_U(unit,
                            "C133 %d\n"), input_port_threshold->hdrm_ext_buff_cells_for_olp_port));                 /* C133 */
        LOG_CLI((BSL_META_U(unit,
                            "C134 %d\n"), input_port_threshold->hdrm_RE_WQEs_pkts_for_olp_port));                   /* C134 */
        LOG_CLI((BSL_META_U(unit,
                            "C135 %d\n"), input_port_threshold->hdrm_EQEs_pkts_for_olp_port));                      /* C135 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C137 %d\n"), input_port_threshold->hdrm_int_buff_cells_for_lpbk_port));                /* C137 */
        LOG_CLI((BSL_META_U(unit,
                            "C138 %d\n"), input_port_threshold->hdrm_ext_buff_cells_for_lpbk_port));                /* C138 */
        LOG_CLI((BSL_META_U(unit,
                            "C139 %d\n"), input_port_threshold->hdrm_RE_WQEs_pkts_for_lpbk_port));                  /* C139 */
        LOG_CLI((BSL_META_U(unit,
                            "C140 %d\n"), input_port_threshold->hdrm_EQEs_pkts_for_lpbk_port));                     /* C140 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C142 %d\n"), input_port_threshold->hdrm_int_buff_cells_for_cpu_port));                 /* C142 */
        LOG_CLI((BSL_META_U(unit,
                            "C143 %d\n"), input_port_threshold->hdrm_ext_buff_cells_for_cpu_port));                 /* C143 */
        LOG_CLI((BSL_META_U(unit,
                            "C144 %d\n"), input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port));                   /* C144 */
        LOG_CLI((BSL_META_U(unit,
                            "C145 %d\n"), input_port_threshold->hdrm_EQEs_pkts_for_cpu_port));                      /* C145 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C147 %d\n"), input_port_threshold->total_hdrm_int_buff_cells));                        /* C147 */
        LOG_CLI((BSL_META_U(unit,
                            "C148 %d\n"), input_port_threshold->total_hdrm_int_buff_ema_pool_cells));               /* C148 */
        LOG_CLI((BSL_META_U(unit,
                            "C149 %d\n"), input_port_threshold->total_hdrm_ext_buff_cells));                        /* C149 */
        LOG_CLI((BSL_META_U(unit,
                            "C150 %d\n"), input_port_threshold->total_hdrm_RE_WQEs_pkts));                          /* C150 */
        LOG_CLI((BSL_META_U(unit,
                            "C151 %d\n"), input_port_threshold->total_hdrm_EQEs_pkts));                             /* C151 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C153 %d\n"), input_port_threshold->min_int_buff_cells_per_PG));                        /* C153 */
        LOG_CLI((BSL_META_U(unit,
                            "C154 %d\n"), input_port_threshold->min_int_buff_ema_pool_cells_per_PG));               /* C154 */
        LOG_CLI((BSL_META_U(unit,
                            "C155 %d\n"), input_port_threshold->min_ext_buff_cells_per_PG));                        /* C155 */
        LOG_CLI((BSL_META_U(unit,
                            "C156 %d\n"), input_port_threshold->min_RE_WQEs_pkt_per_PG));                           /* C156 */
        LOG_CLI((BSL_META_U(unit,
                            "C157 %d\n"), input_port_threshold->min_EQEs_pkt_per_PG));                              /* C157 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C159 %d\n"), input_port_threshold->min_int_buff_cells_for_total_PG));                  /* C159 */
        LOG_CLI((BSL_META_U(unit,
                            "C160 %d\n"), input_port_threshold->min_int_buff_ema_pool_cells_for_total_PG));         /* C160 */
        LOG_CLI((BSL_META_U(unit,
                            "C161 %d\n"), input_port_threshold->min_ext_buff_cells_for_total_PG));                  /* C161 */
        LOG_CLI((BSL_META_U(unit,
                            "C162 %d\n"), input_port_threshold->min_RE_WQEs_pkts_for_total_PG));                    /* C162 */
        LOG_CLI((BSL_META_U(unit,
                            "C163 %d\n"), input_port_threshold->min_EQEs_pkts_for_total_PG));                       /* C163 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C165 %d\n"), input_port_threshold->min_int_buff_cells_for_a_port));                    /* C165 */
        LOG_CLI((BSL_META_U(unit,
                            "C166 %d\n"), input_port_threshold->min_int_buff_ema_pool_cells_for_a_port));           /* C166 */
        LOG_CLI((BSL_META_U(unit,
                            "C167 %d\n"), input_port_threshold->min_ext_buff_cells_for_a_port));                    /* C167 */
        LOG_CLI((BSL_META_U(unit,
                            "C168 %d\n"), input_port_threshold->min_RE_WQEs_pkts_for_a_port));                      /* C168 */
        LOG_CLI((BSL_META_U(unit,
                            "C169 %d\n"), input_port_threshold->min_EQEs_pkts_for_a_port));                         /* C169 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C171 %d\n"), input_port_threshold->min_int_buff_cells_for_total_port));                /* C171 */
        LOG_CLI((BSL_META_U(unit,
                            "C172 %d\n"), input_port_threshold->min_int_buff_ema_pool_cells_for_total_port));       /* C172 */
        LOG_CLI((BSL_META_U(unit,
                            "C173 %d\n"), input_port_threshold->min_ext_buff_cells_for_total_port));                /* C173 */
        LOG_CLI((BSL_META_U(unit,
                            "C174 %d\n"), input_port_threshold->min_RE_WQEs_pkts_for_total_port));                  /* C174 */
        LOG_CLI((BSL_META_U(unit,
                            "C175 %d\n"), input_port_threshold->min_EQEs_pkts_for_total_port));                     /* C175 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C177 %d\n"), input_port_threshold->total_min_int_buff_cells));                         /* C177 */
        LOG_CLI((BSL_META_U(unit,
                            "C178 %d\n"), input_port_threshold->total_min_int_buff_ema_pool_cells));                /* C178 */
        LOG_CLI((BSL_META_U(unit,
                            "C179 %d\n"), input_port_threshold->total_min_ext_buff_cells));                         /* C179 */
        LOG_CLI((BSL_META_U(unit,
                            "C180 %d\n"), input_port_threshold->total_min_RE_WQEs_pkts));                           /* C180 */
        LOG_CLI((BSL_META_U(unit,
                            "C181 %d\n"), input_port_threshold->total_min_EQEs_pkts));                              /* C181 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C183 %d\n"), input_port_threshold->total_shared_ing_buff_pool));                       /* C183 */
        LOG_CLI((BSL_META_U(unit,
                            "C184 %d\n"), input_port_threshold->total_shared_EMA_buff));                            /* C184 */
        LOG_CLI((BSL_META_U(unit,
                            "C185 %d\n"), input_port_threshold->total_shared_ext_buff));                            /* C185 */
        LOG_CLI((BSL_META_U(unit,
                            "C186 %d\n"), input_port_threshold->total_shared_RE_WQEs_buff));                        /* C186 */
        LOG_CLI((BSL_META_U(unit,
                            "C187 %d\n"), input_port_threshold->total_shared_EQEs_buff));                           /* C187 */
        
        LOG_CLI((BSL_META_U(unit,
                            "C189 %d\n"), input_port_threshold->ingress_burst_cells_size_for_one_port));            /* C189 */
        LOG_CLI((BSL_META_U(unit,
                            "C190 %d\n"), input_port_threshold->ingress_burst_pkts_size_for_one_port));             /* C190 */
        LOG_CLI((BSL_META_U(unit,
                            "C191 %d\n"), input_port_threshold->ingress_burst_cells_size_for_all_ports));           /* C191 */
        LOG_CLI((BSL_META_U(unit,
                            "C192 %d\n"), input_port_threshold->ingress_total_shared_cells_use_for_all_port));      /* C192 */
        LOG_CLI((BSL_META_U(unit,
                            "C193 %d\n"), input_port_threshold->ingress_burst_pkts_size_for_all_port));             /* C193 */
        LOG_CLI((BSL_META_U(unit,
                            "C194 %d\n"), input_port_threshold->ingress_total_shared_pkts_use_for_all_port));       /* C194 */
        LOG_CLI((BSL_META_U(unit,
                            "C195 %d\n"), input_port_threshold->ingress_total_shared_hdrm_cells_use_for_all_port)); /* C195 */
        LOG_CLI((BSL_META_U(unit,
                            "C196 %d\n"), input_port_threshold->ingress_total_shared_hdrm_pkts_use_for_all_port));  /* C196 */

        LOG_CLI((BSL_META_U(unit,
                            "C201 %d\n"), output_port_threshold->min_grntd_res_queue_cells_int_buff));               /* C201 */
        LOG_CLI((BSL_META_U(unit,
                            "C202 %d\n"), output_port_threshold->min_grntd_res_queue_cells_ext_buff));               /* C202 */
        LOG_CLI((BSL_META_U(unit,
                            "C203 %d\n"), output_port_threshold->min_grntd_res_queue_cells_EQEs));                   /* C203 */
        LOG_CLI((BSL_META_U(unit,
                            "C204 %d\n"), output_port_threshold->min_grntd_res_EMA_queue_cells));                    /* C204 */
        LOG_CLI((BSL_META_U(unit,
                            "C205 %d\n"), output_port_threshold->min_grntd_res_RE_WQs_cells));                       /* C205 */
        LOG_CLI((BSL_META_U(unit,
                            "C206 %d\n"), output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff));    /* C206 */
        LOG_CLI((BSL_META_U(unit,
                            "C207 %d\n"), output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_ext_buff));    /* C207 */
        LOG_CLI((BSL_META_U(unit,
                            "C208 %d\n"), output_port_threshold->min_grntd_res_EP_redirect_queue_entry_cells));      /* C208 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C210 %d\n"), output_port_threshold->min_grntd_tot_res_queue_cells_int_buff));           /* C210 */
        LOG_CLI((BSL_META_U(unit,
                            "C211 %d\n"), output_port_threshold->min_grntd_tot_res_queue_cells_ext_buff));           /* C211 */
        LOG_CLI((BSL_META_U(unit,
                            "C212 %d\n"), output_port_threshold->min_grntd_tot_res_queue_cells_EQEs));               /* C212 */
        LOG_CLI((BSL_META_U(unit,
                            "C213 %d\n"), output_port_threshold->min_grntd_tot_res_EMA_queue_cells));                /* C213 */
        LOG_CLI((BSL_META_U(unit,
                            "C214 %d\n"), output_port_threshold->min_grntd_tot_res_RE_WQs_cells));                   /* C214 */
        LOG_CLI((BSL_META_U(unit,
                            "C215 %d\n"), output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_int_buff));/* C215 */
        LOG_CLI((BSL_META_U(unit,
                            "C216 %d\n"), output_port_threshold->min_grntd_tot_res_RE_WQs_queue_cells_for_ext_buff));/* C216 */
        LOG_CLI((BSL_META_U(unit,
                            "C217 %d\n"), output_port_threshold->min_grntd_tot_res_EP_redirect_queue_entry_cells));  /* C217 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C219 %d\n"), output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff));           /* C219 */
        LOG_CLI((BSL_META_U(unit,
                            "C220 %d\n"), output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff));           /* C220 */
        LOG_CLI((BSL_META_U(unit,
                            "C221 %d\n"), output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs));               /* C221 */
        LOG_CLI((BSL_META_U(unit,
                            "C222 %d\n"), output_port_threshold->min_grntd_tot_shr_EMA_queue_cells));                /* C222 */
        LOG_CLI((BSL_META_U(unit,
                            "C223 %d\n"), output_port_threshold->min_grntd_tot_shr_RE_WQs_cells));                   /* C223 */
        LOG_CLI((BSL_META_U(unit,
                            "C224 %d\n"), output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff));/* C224 */
        LOG_CLI((BSL_META_U(unit,
                            "C225 %d\n"), output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff));/* C225 */
        LOG_CLI((BSL_META_U(unit,
                            "C226 %d\n"), output_port_threshold->min_grntd_tot_shr_EP_redirect_queue_entry_cells));  /* C226 */
    
        LOG_CLI((BSL_META_U(unit,
                            "C227 %d\n"), output_port_threshold->egress_queue_dynamic_threshold_parameter));         /* C227 */
        LOG_CLI((BSL_META_U(unit,
                            "C228 %d\n"), output_port_threshold->egress_burst_cells_size_for_one_queue));            /* C228 */
        LOG_CLI((BSL_META_U(unit,
                            "C229 %d\n"), output_port_threshold->egress_burst_pkts_size_for_one_queue));             /* C229 */
        LOG_CLI((BSL_META_U(unit,
                            "C230 %d\n"), output_port_threshold->egress_burst_cells_size_for_all_ports));            /* C230 */
        LOG_CLI((BSL_META_U(unit,
                            "C231 %d\n"), output_port_threshold->egress_burst_pkts_size_for_all_ports));             /* C231 */
        LOG_CLI((BSL_META_U(unit,
                            "C232 %d\n"), output_port_threshold->egress_burst_cells_size_for_all_queues));           /* C232 */
        LOG_CLI((BSL_META_U(unit,
                            "C233 %d\n"), output_port_threshold->egress_burst_pkts_size_for_all_queues));            /* C233 */
        LOG_CLI((BSL_META_U(unit,
                            "C234 %d\n"), output_port_threshold->egress_total_use_in_cells_for_all_queues));         /* C234 */
        LOG_CLI((BSL_META_U(unit,
                            "C235 %d\n"), output_port_threshold->egress_total_use_in_pkts_for_all_queues));          /* C235 */
        LOG_CLI((BSL_META_U(unit,
                            "C236 %d\n"), output_port_threshold->egress_remaining_cells_for_all_queues));            /* C236 */
        LOG_CLI((BSL_META_U(unit,
                            "C237 %d\n"), output_port_threshold->egress_remaining_pkts_for_all_queues));             /* C237 */
#endif

            /* ===================== */
            /* Device Wide Registers */
            /* ===================== */

            /* C241: CFAPIFULLSETPOINT.CFAPIFULLSETPOINT = =C92 */
            SOC_IF_ERROR_RETURN(READ_CFAPIFULLSETPOINTr(unit, &rval));
            soc_reg_field_set(unit, CFAPIFULLSETPOINTr, &rval, CFAPIFULLSETPOINTf,
                    general_info->int_cell_buff_size_after_limitation);
            SOC_IF_ERROR_RETURN(WRITE_CFAPIFULLSETPOINTr(unit, rval));

            /* C242: CFAPIFULLRESETPOINT.CFAPIFULLRESETPOINT = =C241-C69*2 */
            SOC_IF_ERROR_RETURN(READ_CFAPIFULLRESETPOINTr(unit, &rval));
            soc_reg_field_set(unit, CFAPIFULLRESETPOINTr, &rval, CFAPIFULLRESETPOINTf,
                    general_info->int_cell_buff_size_after_limitation -
                    (2* general_info->jumbo_frame_for_int_buff));
            SOC_IF_ERROR_RETURN(WRITE_CFAPIFULLRESETPOINTr(unit, rval));

            assert(_soc_kt2_mmu_params.mmu_ext_buf_cell_size == 2880 ||
                    _soc_kt2_mmu_params.mmu_ext_buf_cell_size == 768);

            /* C243: MISCCONFIG.BUFFER_SIZE based on external cell size */
            SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
            soc_reg_field_set(unit, MISCCONFIGr, &rval, BUFFER_SIZEf,
                    _soc_kt2_mmu_params.mmu_ext_buf_cell_size == 2880 ? 1 : 0);
            SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

            if (_soc_kt2_mmu_params.packing_mode_d_c) {
                /* C243: MISCCONFIG.BUFFER_SIZE  = 0x01 */
                SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
                soc_reg_field_set(unit, MISCCONFIGr, &rval, BUFFER_SIZEf, 1);
                SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

                /* C244: TOP_SW_BOND_OVRD_CTRL1.MMU_PACKING_ENABLE = 0x01 */
                SOC_IF_ERROR_RETURN(READ_TOP_SW_BOND_OVRD_CTRL1r(unit, &rval));
                soc_reg_field_set(unit, TOP_SW_BOND_OVRD_CTRL1r, &rval, MMU_PACKING_ENABLEf, 1);
                SOC_IF_ERROR_RETURN(WRITE_TOP_SW_BOND_OVRD_CTRL1r(unit, rval));

                /* C245: MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESH.THRESH_PROFILE_[0..3] = 0x0A */
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr(unit, &rval));
                soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_0f, 0x0a);
                soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_1f, 0x0a);
                soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_2f, 0x0a);
                soc_reg_field_set(unit, MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr, &rval, THRESH_PROFILE_3f, 0x0a);
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_PROFILE_THRESHr(unit, rval));

                /* C246: MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_[0/1/2].SRCPORT_[0..41] = 0 */
                rval = 0;
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_0r(unit, rval));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_1r(unit, rval));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PACKING_REAS_FIFO_THRESH_PROFILE_2r(unit, rval));

                /* C247: THDO_MISCCONFIG.UCMC_SEPARATION = 0 */
                SOC_IF_ERROR_RETURN(READ_THDO_MISCCONFIGr(unit, &rval));
                soc_reg_field_set(unit, THDO_MISCCONFIGr, &rval, UCMC_SEPARATIONf, 0);
                SOC_IF_ERROR_RETURN(WRITE_THDO_MISCCONFIGr(unit, rval));

                /* C248: WRED_MISCCONFIG.UCMC_SEPARATION = 0 */
                SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
                soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, UCMC_SEPARATIONf, 0);
                SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

                /* C249: MISCCONFIG.THDI_ROLLOVER_COUNT = 0xB4 */
                SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
                soc_reg_field_set(unit, MISCCONFIGr, &rval, THDI_ROLLOVER_COUNTf, 0xb4);
                SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
            }

            /* Input port thresholds */
            /* C251: COLOR_AWARE.ENABLE = 0 */
            SOC_IF_ERROR_RETURN(READ_COLOR_AWAREr (unit, &rval));
            soc_reg_field_set(unit, COLOR_AWAREr, &rval, ENABLEf, 0);
            SOC_IF_ERROR_RETURN(WRITE_COLOR_AWAREr (unit, rval));


            /* Internal Buffer Ingress Pool */
            /* C253: GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = =$C$107 */

            SOC_IF_ERROR_RETURN(READ_GLOBAL_HDRM_LIMITr (unit, &rval));
            soc_reg_field_set(unit, GLOBAL_HDRM_LIMITr, &rval, GLOBAL_HDRM_LIMITf,
                    input_port_threshold->global_hdrm_cells_for_int_buff_pool);
            SOC_IF_ERROR_RETURN(WRITE_GLOBAL_HDRM_LIMITr (unit, rval));

            /* C254: BUFFER_CELL_LIMIT_SP.LIMIT =  =$C$183 */
            SOC_IF_ERROR_RETURN(READ_BUFFER_CELL_LIMIT_SPr (unit, service_pool, &rval));
            soc_reg_field_set(unit, BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                    input_port_threshold->total_shared_ing_buff_pool);
            SOC_IF_ERROR_RETURN(WRITE_BUFFER_CELL_LIMIT_SPr (unit, service_pool, rval));

            /* C255: CELL_RESET_LIMIT_OFFSET_SP.OFFSET = CEILING(C75/4*C71, 1) */
            SOC_IF_ERROR_RETURN(READ_CELL_RESET_LIMIT_OFFSET_SPr (unit, 
                        service_pool, &rval));
            temp_val = ceil_func(general_info->total_num_of_ports,4) *
                general_info->ether_mtu_cells_for_int_buff;
            soc_reg_field_set(unit, CELL_RESET_LIMIT_OFFSET_SPr, &rval, 
                    OFFSETf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_CELL_RESET_LIMIT_OFFSET_SPr (unit, 
                        service_pool, rval));

            /* External Buffer */
            if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
                /* C257: THDIEXT_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = =C108 */
                SOC_IF_ERROR_RETURN(READ_THDIEXT_GLOBAL_HDRM_LIMITr (unit, &rval));
                soc_reg_field_set(unit, THDIEXT_GLOBAL_HDRM_LIMITr, &rval,
                        GLOBAL_HDRM_LIMITf, 
                        input_port_threshold->global_hdrm_cells_for_ext_buff_pool);
                SOC_IF_ERROR_RETURN(WRITE_THDIEXT_GLOBAL_HDRM_LIMITr (unit, rval));

                /* C258:  THDIEXT_BUFFER_CELL_LIMIT_SP.LIMIT =C185*/
                SOC_IF_ERROR_RETURN(READ_THDIEXT_BUFFER_CELL_LIMIT_SPr (
                            unit, service_pool, &rval));
                soc_reg_field_set(unit, THDIEXT_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                        input_port_threshold->total_shared_ext_buff);
                SOC_IF_ERROR_RETURN(WRITE_THDIEXT_BUFFER_CELL_LIMIT_SPr (unit, 0,rval));

                /* C259:THDIEXT_CELL_RESET_LIMIT_OFFSET_SP.OFFSET=CEILING(C75/4*C73,1)*/
                SOC_IF_ERROR_RETURN(READ_THDIEXT_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, &rval));
                temp_val = (general_info->total_num_of_ports * 
                        general_info->ether_mtu_cells_for_ext_buff) / 4;
                if (general_info->total_num_of_ports % 4) {
                    temp_val++;
                }
                soc_reg_field_set(unit, 
                        THDIEXT_CELL_RESET_LIMIT_OFFSET_SPr, &rval, OFFSETf, temp_val);
                SOC_IF_ERROR_RETURN(WRITE_THDIEXT_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, rval));


                /* EMA pool */
                /* C261: THDIEMA_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT==C107 */
                SOC_IF_ERROR_RETURN(READ_THDIEMA_GLOBAL_HDRM_LIMITr (unit, &rval));
                soc_reg_field_set(unit, THDIEMA_GLOBAL_HDRM_LIMITr, &rval,
                        GLOBAL_HDRM_LIMITf,
                        input_port_threshold->global_hdrm_cells_for_int_buff_pool);
                SOC_IF_ERROR_RETURN(WRITE_THDIEMA_GLOBAL_HDRM_LIMITr (unit, rval));

                /* C262:  THDIEMA_BUFFER_CELL_LIMIT_SP.LIMIT = =C184 */
                SOC_IF_ERROR_RETURN(READ_THDIEMA_BUFFER_CELL_LIMIT_SPr (
                            unit, service_pool, &rval));
                soc_reg_field_set(unit, THDIEMA_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                        input_port_threshold->total_shared_EMA_buff);
                SOC_IF_ERROR_RETURN(WRITE_THDIEMA_BUFFER_CELL_LIMIT_SPr (unit, 0,rval));

                /* C263:THDIEMA_CELL_RESET_LIMIT_OFFSET_SP.OFFSET=CEILING(C75/4*C72,1)*/
                SOC_IF_ERROR_RETURN(READ_THDIEMA_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, &rval));
                temp_val = ceil_func(general_info->total_num_of_ports,4) *
                    general_info->ether_mtu_cells_for_int_buff ;
                soc_reg_field_set(
                        unit, THDIEMA_CELL_RESET_LIMIT_OFFSET_SPr, &rval, OFFSETf,
                        temp_val);
                SOC_IF_ERROR_RETURN(WRITE_THDIEMA_CELL_RESET_LIMIT_OFFSET_SPr (
                            unit, service_pool, rval));
            }

            /* RE WQEs */
            /* C265: THDIRQE_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = C109 */
            SOC_IF_ERROR_RETURN(READ_THDIRQE_GLOBAL_HDRM_LIMITr (unit, &rval));
            soc_reg_field_set(unit, THDIRQE_GLOBAL_HDRM_LIMITr, &rval,
                    GLOBAL_HDRM_LIMITf, 
                    input_port_threshold->global_hdrm_cells_for_RE_WQEs);
            SOC_IF_ERROR_RETURN(WRITE_THDIRQE_GLOBAL_HDRM_LIMITr (unit, rval));

            /* C266:  THDIRQE_BUFFER_CELL_LIMIT_SP.LIMIT =$C$186  */
            SOC_IF_ERROR_RETURN(READ_THDIRQE_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, &rval));
            soc_reg_field_set(unit, THDIRQE_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                    input_port_threshold->total_shared_RE_WQEs_buff);
            SOC_IF_ERROR_RETURN(WRITE_THDIRQE_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, rval));

            /* C267: = THDIRQE_CELL_RESET_LIMIT_OFFSET_SP.OFFSET = CEILING(C75/4, 1) */
            SOC_IF_ERROR_RETURN(READ_THDIRQE_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,&rval));
            soc_reg_field_set(unit, THDIRQE_CELL_RESET_LIMIT_OFFSET_SPr, &rval,
                    OFFSETf, ceil_func(general_info->total_num_of_ports , 4));
            SOC_IF_ERROR_RETURN(WRITE_THDIRQE_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,rval));

            /* EQEs */
            /* C269: THDIQEN_GLOBAL_HDRM_LIMIT.GLOBAL_HDRM_LIMIT = C110 */
            SOC_IF_ERROR_RETURN(READ_THDIQEN_GLOBAL_HDRM_LIMITr (unit, &rval));
            soc_reg_field_set(unit, THDIQEN_GLOBAL_HDRM_LIMITr, &rval,
                    GLOBAL_HDRM_LIMITf,
                    input_port_threshold->global_hdrm_cells_for_EQEs);
            SOC_IF_ERROR_RETURN(WRITE_THDIQEN_GLOBAL_HDRM_LIMITr (unit, rval));

            /* C270:  THDIQEN_BUFFER_CELL_LIMIT_SP.LIMIT =$C$187  */
            SOC_IF_ERROR_RETURN(READ_THDIQEN_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, &rval));
            soc_reg_field_set(unit, THDIQEN_BUFFER_CELL_LIMIT_SPr, &rval, LIMITf,
                    input_port_threshold->total_shared_EQEs_buff);
            SOC_IF_ERROR_RETURN(WRITE_THDIQEN_BUFFER_CELL_LIMIT_SPr (
                        unit, service_pool, rval));

            /* C271: THDIQEN_CELL_RESET_LIMIT_OFFSET_SP.OFFSET= CEILING(C75/4*C49, 1)*/
            SOC_IF_ERROR_RETURN(READ_THDIQEN_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,&rval));
            temp_val = ceil_func(general_info->total_num_of_ports, 4)  * 
                _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt;
            soc_reg_field_set(unit, THDIQEN_CELL_RESET_LIMIT_OFFSET_SPr, &rval, OFFSETf,
                    temp_val);
            SOC_IF_ERROR_RETURN(WRITE_THDIQEN_CELL_RESET_LIMIT_OFFSET_SPr(
                        unit,service_pool,rval));

            /* Ouput port thresholds */
            /* Internal buffer Egress pool */
            /* C274: OP_BUFFER_SHARED_LIMIT_CELLI.OP_BUFFER_SHARED_LIMIT_CELLI = C219 */
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLIr (unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLIr, &rval,
                    OP_BUFFER_SHARED_LIMIT_CELLIf, 
                    output_port_threshold->min_grntd_tot_shr_queue_cells_int_buff);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_CELLIr (unit, rval));
            op_buffer_shared_limit_celli = output_port_threshold->
                min_grntd_tot_shr_queue_cells_int_buff;

            /* C275: OP_BUFFER_SHARED_LIMIT_RESUME_CELLI.
               OP_BUFFER_SHARED_LIMIT_RESUME_CELLI */
            temp_val = op_buffer_shared_limit_celli;
            if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
                /* C275 = =C274-CEILING(C75/4,1)*C72 */
                temp_val = temp_val - (ceil_func(general_info->total_num_of_ports,4) 
                        * general_info->ether_mtu_cells_for_int_buff);
            } else {
                if (_soc_kt2_mmu_params.lossless_mode_d_c == 0) {
                    /* C275 = =C274-CEILING(C78/4, 1)*C72 */
                    temp_val = temp_val - 
                        (ceil_func(general_info->
                                   total_num_of_ports_excl_lpbk_olp_cpu,4) 
                         * general_info->ether_mtu_cells_for_int_buff);
                } else {
                    /* C275 = =C274-CEILING(C76/4, 1)*C72 */
                    temp_val = temp_val - 
                        (ceil_func(general_info->total_num_of_ports_excl_lpbk,4)
                         * general_info->ether_mtu_cells_for_int_buff);
                }
            }

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr(unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr, &rval,
                    OP_BUFFER_SHARED_LIMIT_RESUME_CELLIf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr(unit, rval));
            op_buffer_shared_limit_resume_celli = temp_val;

            /* C276: OP_BUFFER_LIMIT_YELLOW_CELLI.OP_BUFFER_LIMIT_YELLOW_CELLI =
               =CEILING(C274/8, 1) */
            /* C278: OP_BUFFER_LIMIT_RED_CELLI.OP_BUFFER_LIMIT_RED_CELLI =
               =CEILING(C274/8, 1) */
            temp_val = op_buffer_shared_limit_celli;
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_CELLIr (unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_CELLIr, &rval,
                    OP_BUFFER_LIMIT_YELLOW_CELLIf, ceil_func(temp_val,8));
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_CELLIr (unit, rval));

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_CELLIr (unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_CELLIr, &rval,
                    OP_BUFFER_LIMIT_RED_CELLIf, ceil_func( temp_val,8));
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_CELLIr (unit, rval));


            /* C277: OP_BUFFER_LIMIT_RESUME_YELLOW_CELLI.
               OP_BUFFER_LIMIT_RESUME_YELLOW_CELLI =CEILING(C275/8, 1) */
            /* C279: OP_BUFFER_LIMIT_RESUME_RED_CELLI.
               OP_BUFFER_LIMIT_RESUME_RED_CELLI =CEILING(C275/8, 1) */
            temp_val = op_buffer_shared_limit_resume_celli;
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIr (
                        unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIr, &rval,
                    OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIf, ceil_func(temp_val,8));
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLIr (
                        unit, rval));

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_CELLIr (unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_CELLIr, &rval,
                    OP_BUFFER_LIMIT_RESUME_RED_CELLIf, ceil_func(temp_val,8));
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_CELLIr (unit, rval));

            /* External Buffer */
            if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
                /* C281: 
                   OP_BUFFER_SHARED_LIMIT_CELLE.OP_BUFFER_SHARED_LIMIT_CELLE = C220 */
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r (
                            unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r, &rval,
                        OP_BUFFER_SHARED_LIMIT_CELLEf, 
                        output_port_threshold->min_grntd_tot_shr_queue_cells_ext_buff);
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r (
                            unit, rval));
                op_buffer_shared_limit_celle = output_port_threshold->
                    min_grntd_tot_shr_queue_cells_ext_buff;

                /* C282: OP_BUFFER_SHARED_LIMIT_RESUME_CELLE.
                   OP_BUFFER_SHARED_LIMIT_RESUME_CELLE =C281-CEILING(C75/4, 1)*C73 */
                temp_val = op_buffer_shared_limit_celle - 
                    (ceil_func(general_info->total_num_of_ports ,4) *
                     general_info->ether_mtu_cells_for_ext_buff);
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r(
                            unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r, 
                        &rval,OP_BUFFER_SHARED_LIMIT_RESUME_CELLEf, temp_val);
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r(
                            unit, rval));
                op_buffer_shared_limit_resume_celle = temp_val;

                /* C283: OP_BUFFER_LIMIT_YELLOW_CELLE.OP_BUFFER_LIMIT_YELLOW_CELLE =
                   =CEILING(C281/8, 1) */
                /* C285: OP_BUFFER_LIMIT_RED_CELLE.OP_BUFFER_LIMIT_RED_CELLE =
                   =CEILING(C281/8, 1) */
                temp_val = op_buffer_shared_limit_celle;
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_CELLE_POOL0r (
                            unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_CELLE_POOL0r, &rval,
                        OP_BUFFER_LIMIT_YELLOW_CELLEf, ceil_func(temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_CELLE_POOL0r (
                            unit, rval));

                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_CELLE_POOL0r(unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_CELLE_POOL0r, &rval,
                        OP_BUFFER_LIMIT_RED_CELLEf, ceil_func( temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_CELLE_POOL0r(unit, rval));


                /* C284: OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE.
                   OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE ==CEILING(C282/8, 1) */
                /* C286: OP_BUFFER_LIMIT_RESUME_RED_CELLE.
                   OP_BUFFER_LIMIT_RESUME_RED_CELLE ==CEILING(C282/8, 1) */
                temp_val = op_buffer_shared_limit_resume_celle;
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE_POOL0r (
                            unit, &rval));
                soc_reg_field_set(unit, 
                        OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE_POOL0r, &rval,
                        OP_BUFFER_LIMIT_RESUME_YELLOW_CELLEf, ceil_func(temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_CELLE_POOL0r (
                            unit, rval));

                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_CELLE_POOL0r (
                            unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_CELLE_POOL0r, &rval,
                        OP_BUFFER_LIMIT_RESUME_RED_CELLEf, ceil_func(temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_CELLE_POOL0r (
                            unit, rval));

                /* EMA pool */
                /* C288: 
                   OP_BUFFER_SHARED_LIMIT_THDOEMA.OP_BUFFER_SHARED_LIMIT_CELLE = C222 */
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_THDOEMAr (unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_THDOEMAr, &rval,
                        OP_BUFFER_SHARED_LIMITf, 
                        output_port_threshold->min_grntd_tot_shr_EMA_queue_cells);
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_THDOEMAr (unit, rval));
                op_buffer_shared_limit = output_port_threshold->
                    min_grntd_tot_shr_EMA_queue_cells;

                /* C289: OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMA.
                   OP_BUFFER_SHARED_LIMIT_RESUME_CELLE = C288-CEILING(C75/4,1)*C72 */
                temp_val = op_buffer_shared_limit;
                temp_val = temp_val - (ceil_func(general_info->total_num_of_ports,4) *
                        general_info->ether_mtu_cells_for_int_buff);
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMAr(
                            unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMAr, &rval,
                        OP_BUFFER_SHARED_LIMIT_RESUMEf, temp_val);
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_THDOEMAr(
                            unit, rval));
                op_buffer_shared_limit_resume = temp_val;

                /* C290: OP_BUFFER_LIMIT_YELLOW_THDOEMA.OP_BUFFER_LIMIT_YELLOW =
                   =CEILING(C288/8, 1) */
                /* C292: OP_BUFFER_LIMIT_RED_THDOEMA.OP_BUFFER_LIMIT_RED =
                   =CEILING(C288/8, 1) */
                temp_val = op_buffer_shared_limit;
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_THDOEMAr (unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_THDOEMAr, &rval,
                        OP_BUFFER_LIMIT_YELLOWf, ceil_func(temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_THDOEMAr (unit, rval));

                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_THDOEMAr (unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_THDOEMAr, &rval,
                        OP_BUFFER_LIMIT_REDf, ceil_func( temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_THDOEMAr (unit, rval));


                /* C291: OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMA.
                   OP_BUFFER_LIMIT_RESUME_YELLOW==CEILING(C289/8, 1) */
                /* C293: OP_BUFFER_LIMIT_RESUME_RED_THDOEMA.
                   OP_BUFFER_LIMIT_RESUME_RED==CEILING(C289/8, 1) */
                temp_val = op_buffer_shared_limit_resume;
                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMAr (
                            unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMAr, &rval,
                        OP_BUFFER_LIMIT_RESUME_YELLOWf, ceil_func(temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_THDOEMAr (
                            unit, rval));

                SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_THDOEMAr (
                            unit, &rval));
                soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_THDOEMAr, &rval,
                        OP_BUFFER_LIMIT_RESUME_REDf, ceil_func(temp_val,8));
                SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_THDOEMAr (
                            unit, rval));
            }
            /* RE WQEs*/
            /* C295: 
               OP_BUFFER_SHARED_LIMIT_THDORQEQ.OP_BUFFER_SHARED_LIMIT_CELLE = C223 */

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_THDORQEQr (unit, &rval));
            SOC_FIND_FIELD(OP_BUFFER_SHARED_LIMITf,
                    SOC_REG_INFO(unit, OP_BUFFER_SHARED_LIMIT_THDORQEQr).fields,
                    SOC_REG_INFO(unit, OP_BUFFER_SHARED_LIMIT_THDORQEQr).nFields,
                    fieldp);
            temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_cells; 
            if (temp_val >= (1 << fieldp->len)) {
                temp_val = (1 << fieldp->len) - 1;
            }
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_THDORQEQr, &rval,
                    OP_BUFFER_SHARED_LIMITf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_THDORQEQr (unit, rval));
            op_buffer_shared_limit = temp_val;

            /* C296: OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQ.
               OP_BUFFER_SHARED_LIMIT_RESUME = CEILING(C223-C75/4, 1) */
            temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_cells;
            if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
                /* =C223-CEILING(C75/4, 1) */
                temp_val -= ceil_func(general_info->total_num_of_ports,4);
            } else {
                if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                    /* =C223-CEILING(C76/4, 1) */
                    temp_val -= ceil_func(general_info->total_num_of_ports_excl_lpbk,4);
                } else {
                    /* =C223-CEILING(C78/4, 1) */
                    temp_val -= ceil_func(
                            general_info->total_num_of_ports_excl_lpbk_olp_cpu,4);
                }
            }
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQr(
                        unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQr, &rval,
                    OP_BUFFER_SHARED_LIMIT_RESUMEf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_THDORQEQr(
                        unit, rval));
            op_buffer_shared_limit_resume = temp_val;

            /* C297: OP_BUFFER_LIMIT_YELLOW_THDORQEQ.OP_BUFFER_LIMIT_YELLOW =
               =CEILING(C295/8, 1)-1 */
            temp_val = ceil_func(op_buffer_shared_limit,8) ;
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val -= 1;
            }
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_THDORQEQr (unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_THDORQEQr, &rval,
                    OP_BUFFER_LIMIT_YELLOWf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_THDORQEQr (unit, rval));

            /* C298: OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQ.
               OP_BUFFER_LIMIT_RESUME_YELLOW = C297-1 */
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQr (
                        unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQr, &rval,
                    OP_BUFFER_LIMIT_RESUME_YELLOWf, temp_val-1);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORQEQr (
                        unit, rval));

            /* C299: OP_BUFFER_LIMIT_RED_THDORQEQ.OP_BUFFER_LIMIT_RED =
               =CEILING(C295/8, 1) */
            temp_val = ceil_func(op_buffer_shared_limit,8);
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val -= 1;
            }
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_THDORQEQr (unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_THDORQEQr, &rval,
                    OP_BUFFER_LIMIT_REDf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_THDORQEQr (unit, rval));


            /* C300: OP_BUFFER_LIMIT_RESUME_RED_THDORQEQ.
               OP_BUFFER_LIMIT_RESUME_RED==C299 -1 */
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_THDORQEQr (
                        unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_THDORQEQr, &rval,
                    OP_BUFFER_LIMIT_RESUME_REDf, temp_val-1);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_THDORQEQr (
                        unit, rval));

            /* EQEs */
            /* C302: OP_BUFFER_SHARED_LIMIT_QENTRY.OP_BUFFER_SHARED_LIMIT_QENTRY =C221*/
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_QENTRYr (unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_QENTRYr, &rval,
                    OP_BUFFER_SHARED_LIMIT_QENTRYf, 
                    output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_QENTRYr (unit, rval));

            temp_val = output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs;

            /* C304: OP_BUFFER_LIMIT_YELLOW_QENTRY.OP_BUFFER_LIMIT_YELLOW_QENTRY
               = CEILING(C302/8, 1)  */
            /* C306: OP_BUFFER_LIMIT_RED_QENTRY.OP_BUFFER_LIMIT_RED_QENTRY
               = CEILING(C302/8, 1)  */
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_QENTRYr(unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RED_QENTRYr, &rval,
                    OP_BUFFER_LIMIT_RED_QENTRYf, ceil_func(temp_val,8));
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_QENTRYr(unit, rval));

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_QENTRYr(unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_YELLOW_QENTRYr, &rval,
                    OP_BUFFER_LIMIT_YELLOW_QENTRYf, ceil_func(temp_val,8));
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_QENTRYr(unit, rval));
            /* C303: OP_BUFFER_SHARED_LIMIT_RESUME_QENTRY = 
               =C221-CEILING(C78/4, 1)*C49
               =C221-CEILING(C76/4, 1)*C49
               =C221-CEILING(C75/4, 1)*C49 */
            temp_val= output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs;
            if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
                /* C303     =C221-CEILING(C75/4, 1)*C49 */
                temp_val = temp_val - (ceil_func(general_info->total_num_of_ports,4) *
                        _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);
            } else {
                if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                    /* =C221-CEILING(C76/4, 1)*C49 */
                    temp_val = temp_val - 
                        (ceil_func(
                                   general_info->total_num_of_ports_excl_lpbk,4) *
                         _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);
                } else {
                    /* =C221-CEILING(C78/4, 1)*C49 */
                    temp_val = temp_val - 
                        (ceil_func(
                                   general_info->total_num_of_ports_excl_lpbk_olp_cpu,4) *
                         _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);
                }
            }
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYr(
                        unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYr, 
                    &rval,
                    OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_QENTRYr(
                        unit, rval));

            /* C305: OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRY.
               OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRY = =CEILING(C303/8, 1) */
            /* C307: OP_BUFFER_LIMIT_RESUME_RED_QENTRY.
               OP_BUFFER_LIMIT_RESUME_RED_QENTRY = =CEILING(C303/8, 1) */
            SOC_IF_ERROR_RETURN(
                    READ_OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYr(unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYr, &rval,
                    OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYf, 
                    ceil_func(temp_val,8));
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_QENTRYr(unit, rval));

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_QENTRYr(unit, &rval));
            soc_reg_field_set(unit, OP_BUFFER_LIMIT_RESUME_RED_QENTRYr, &rval,
                    OP_BUFFER_LIMIT_RESUME_RED_QENTRYf, 
                    ceil_func(temp_val,8));
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_QENTRYr(unit, rval));

            /* EP Redirection Packets */
            /* C309 : OP_BUFFER_SHARED_LIMIT_THDORDEQ.OP_BUFFER_SHARED_LIMIT = C226 */
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_THDORDEQr(unit, &rval));
            soc_reg_field_set(unit,OP_BUFFER_SHARED_LIMIT_THDORDEQr,&rval,
                    OP_BUFFER_SHARED_LIMITf,
                    output_port_threshold->min_grntd_tot_shr_EP_redirect_queue_entry_cells);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_THDORDEQr(unit, rval));
            op_buffer_shared_limit= output_port_threshold->
                min_grntd_tot_shr_EP_redirect_queue_entry_cells;

            /* C311: OP_BUFFER_LIMIT_YELLOW_THDORDEQ.OP_BUFFER_LIMIT_YELLOW
               = CEILING(C309/8, 1) */
            /* C313: OP_BUFFER_LIMIT_RED_THDORDEQ.OP_BUFFER_LIMIT_RED
               = CEILING(C309/8, 1) */
            temp_val = ceil_func(op_buffer_shared_limit,8);
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_YELLOW_THDORDEQr(unit, &rval));
            soc_reg_field_set(unit,OP_BUFFER_LIMIT_YELLOW_THDORDEQr,&rval,
                    OP_BUFFER_LIMIT_YELLOWf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_YELLOW_THDORDEQr(unit, rval));

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RED_THDORDEQr(unit, &rval));
            soc_reg_field_set(unit,OP_BUFFER_LIMIT_RED_THDORDEQr,&rval,
                    OP_BUFFER_LIMIT_REDf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RED_THDORDEQr(unit, rval));

            /* C312: OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQ.
               OP_BUFFER_LIMIT_RESUME_YELLOW = =C311-1 */
            /* C314: OP_BUFFER_LIMIT_RESUME_RED_THDORDEQ.
               OP_BUFFER_LIMIT_RESUME_RED = =C313-1 */
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQr(
                        unit, &rval));
            soc_reg_field_set(unit,OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQr,&rval,
                    OP_BUFFER_LIMIT_RESUME_YELLOWf, temp_val-1);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQr(
                        unit, rval));
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_LIMIT_RESUME_RED_THDORDEQr(unit, &rval));
            soc_reg_field_set(unit,OP_BUFFER_LIMIT_RESUME_RED_THDORDEQr,&rval,
                    OP_BUFFER_LIMIT_RESUME_REDf, temp_val-1);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_LIMIT_RESUME_RED_THDORDEQr(unit, rval));

            /*C310: OP_BUFFER_SHARED_LIMIT_TRESUME_THDORDEQr.
              OP_BUFFER_SHARED_LIMIT_RESUMEf = =C226-4 */
            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_THDORDEQr(
                        unit, &rval));
            soc_reg_field_set(unit,OP_BUFFER_SHARED_LIMIT_RESUME_THDORDEQr,&rval,
                    OP_BUFFER_SHARED_LIMIT_RESUMEf,
                    output_port_threshold->
                    min_grntd_tot_shr_EP_redirect_queue_entry_cells - 4);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_THDORDEQr(
                        unit, rval));
            /* C312: OP_BUFFER_LIMIT_RESUME_YELLOW_THDORDEQ.
               OP_BUFFER_LIMIT_RESUME_YELLOW = =C302-1 */
            /* C314: OP_BUFFER_LIMIT_RESUME_RED_THDORDEQ.
               OP_BUFFER_LIMIT_RESUME_RED = =C302-1 */


    /* Per Port Registers */
    /* ######################## */
    /* 1. Input Port Thresholds */
    /* ######################## */

    /* 1.1 Internal Buffer Ingress Pool */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only priority_group = 0 is used on single PG ports */
    /* Assuming only priority_group = 7 is used on eight PG ports */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         if (((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
            (((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0) ||
            (port == 30) || (port == 33) ||
            (port == 36) || (port == 39))) || (IS_LB_PORT(unit,port))) {
            priority_group = 7;
         } else {
            priority_group = 0;
         }
         if( (flex_port != -1) && (flex_port != port) ) {
             continue;
         }

         sal_memset(&thdi_port_sp_config,0,sizeof(thdi_port_sp_config));
         mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
         /* C320 : THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT = =$C$165 */
         soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, 
             &thdi_port_sp_config, PORT_SP_MIN_LIMITf, 
             input_port_threshold->min_int_buff_cells_for_a_port);
         /* C321 : THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = =$C$254 <==C183 */
         soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, 
             &thdi_port_sp_config, PORT_SP_MAX_LIMITf, 
             input_port_threshold->total_shared_ing_buff_pool);
         /* C322 : PORT_MAX_PKT_SIZE.PORT_MAX_PKT_SIZE = =$C$68 */
         SOC_IF_ERROR_RETURN(READ_PORT_MAX_PKT_SIZEr (unit, port, &rval));
         soc_reg_field_set(unit, PORT_MAX_PKT_SIZEr, &rval,
                           PORT_MAX_PKT_SIZEf,
                           general_info->max_packet_size_in_cells);
         SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr (unit, port, rval));

         /* C323: THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT = =$C$321-2*C72 */
         soc_mem_field32_set(unit, THDI_PORT_SP_CONFIGm, 
             &thdi_port_sp_config, PORT_SP_RESUME_LIMITf, 
             input_port_threshold->total_shared_ing_buff_pool - 
             (2 *  general_info->ether_mtu_cells_for_int_buff));

         SOC_IF_ERROR_RETURN (soc_mem_write(
                         unit, THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                         mem_idx, &thdi_port_sp_config));

         sal_memset(&thdi_port_pg_config,0,sizeof(thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         /* C324: THDI_PORT_PG_CONFIG.PG_MIN_LIMIT (PG0) = =$C$153 */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_MIN_LIMITf, 
             input_port_threshold->min_int_buff_cells_per_PG);

         /* C325: THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT=IF($C$14, $C$58, $C$254)*/
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
         } else {
             /* $C$254 = =$C$183 */
             temp_val = input_port_threshold->total_shared_ing_buff_pool;
         } 
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_SHARED_LIMITf, temp_val);

         /* C326: THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = 2*$C$72 */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_RESET_OFFSETf, 
             (2 * general_info->ether_mtu_cells_for_int_buff));

         /* C327: THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_RESET_FLOORf, 0);

         /* C328: THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= =IF($C$14, 1, 0) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 1;
         } else {
             temp_val = 0;
         }
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_SHARED_DYNAMICf,temp_val);

         /* C329: THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT=
                  For Ge:$C122 For Hg:$C112 For Cpu:$C142 */
         if (IS_CPU_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_int_buff_cells_for_cpu_port;
         } else if (IS_GE_PORT(unit, port) || IS_LB_PORT(unit,port)) {
             temp_val = input_port_threshold->hdrm_int_buff_cells_for_1G_PG;
         } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port) ) {
             temp_val = input_port_threshold->hdrm_int_buff_cells_for_10G_PG;
         }
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

         /* C330 : THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = for lossy=1 else 0 */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 0;
         } else {
             temp_val = 1;
         }
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, PG_GBL_HDRM_ENf ,temp_val);

         /* C331: THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE = 
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */

         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C332: THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDI_PORT_PG_CONFIGm, 
             &thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);

         SOC_IF_ERROR_RETURN (soc_mem_write(
                         unit, THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                         mem_idx, &thdi_port_pg_config));
    }
     
    /* 1.2 External Buffer              */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only priority_group = 0 is used on single PG ports */
    /* Assuming only priority_group = 7 is used on eight PG ports */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
             if (((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
                (((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0) ||
                (port == 30) || (port == 33) ||
                (port == 36) || (port == 39))) || (IS_LB_PORT(unit,port))) {
                 priority_group = 7;
             } else {
                 priority_group = 0;
             }
             if( (flex_port != -1) && (flex_port != port) ) {
                 continue;
             }

             sal_memset(&thdiext_thdi_port_sp_config,0,
                        sizeof(thdiext_thdi_port_sp_config));
             mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
             /* C335: THDIEXT_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$167 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                 &thdiext_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
                 input_port_threshold->min_ext_buff_cells_for_a_port);

             /* C336: THDIEXT_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = 
                      $C$258 <== =C185  */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                 &thdiext_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
                 input_port_threshold->total_shared_ext_buff);

             /* C337: THDIEXT_PORT_MAX_PKT_SIZE.PORT_MAX_PKT_SIZE = =$C$70 */
             SOC_IF_ERROR_RETURN(READ_THDIEXT_PORT_MAX_PKT_SIZEr (
                                 unit, port, &rval));
             soc_reg_field_set(unit, THDIEXT_PORT_MAX_PKT_SIZEr, &rval,
                               PORT_MAX_PKT_SIZEf,
                               general_info->jumbo_frame_for_ext_buff);
             SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_MAX_PKT_SIZEr (
                                 unit, port, rval));
             /* C338: THDIEXT_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                      =$C$336-2*$C$73 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_SP_CONFIGm,
                 &thdiext_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
                 input_port_threshold->total_shared_ext_buff -
                 (2 *  general_info->ether_mtu_cells_for_ext_buff));
             SOC_IF_ERROR_RETURN (soc_mem_write(unit, 
                THDIEXT_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                mem_idx, &thdiext_thdi_port_sp_config));
         }
         sal_memset(&thdiext_thdi_port_pg_config,0,
                    sizeof(thdiext_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
             /* C339: THDIEXT_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = =$C$155 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_MIN_LIMITf,
                 input_port_threshold->min_ext_buff_cells_per_PG);


             /* C340: THDIEXT_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                      IF($C$14, $C$58, $C$258) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
             } else {
                 /* $C$258 = =$C$185 */
                 temp_val = input_port_threshold->total_shared_ext_buff;;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, 
                 PG_SHARED_LIMITf, temp_val);

             /* C341: THDIEXT_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = =2*$C$72 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_RESET_OFFSETf,
                 (2 * general_info->ether_mtu_cells_for_ext_buff));

             /* C342: THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_RESET_FLOORf, 0);

             /* C343: THDIEXT_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                      IF($C$14, 1, 0) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = 1;
             } else {
                 temp_val = 0;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
                 &thdiext_thdi_port_pg_config, PG_SHARED_DYNAMICf,
                 temp_val);

             /* C344: THDIEXT_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                      For Ge:$C123 For Hg:$C113 For Cpu:$C143 */
             if (IS_CPU_PORT(unit, port)) {
                 temp_val = input_port_threshold->
                            hdrm_ext_buff_cells_for_cpu_port;
             } else if (IS_GE_PORT(unit, port) || IS_LB_PORT(unit,port)) {
                 temp_val = input_port_threshold->hdrm_ext_buff_cells_for_1G_PG;
             } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
                 temp_val= input_port_threshold->hdrm_ext_buff_cells_for_10G_PG;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
               &thdiext_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

             /* C345: THDIEXT_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                      for lossy=1 else 0
                      For Packed : 0 */
             if (_soc_kt2_mmu_params.lossless_mode_d_c || 
                 _soc_kt2_mmu_params.packing_mode_d_c) {
                 temp_val = 0;
             } else {
                 temp_val = 1;
             }
             soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm, 
                 &thdiext_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
                 temp_val);
         }
         /* C346: THDIEXT_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
             &thdiext_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C347: THDIEXT_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEXT_THDI_PORT_PG_CONFIGm,
             &thdiext_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);

         SOC_IF_ERROR_RETURN (soc_mem_write(unit, 
                THDIEXT_THDI_PORT_PG_CONFIGm, MEM_BLOCK_ALL, 
                mem_idx, &thdiext_thdi_port_pg_config));
    }
    /* 1.3 EMA Pool                     */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only priority_group = 0 is used on single PG ports */
    /* Assuming only priority_group = 7 is used on eight PG ports */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
             if (((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
                (((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0) ||
                (port == 30) || (port == 33) ||
                (port == 36) || (port == 39))) || (IS_LB_PORT(unit,port))) {
                 priority_group = 7;
             } else {
                 priority_group = 0;
             }
             if( (flex_port != -1) && (flex_port != port) ) {
                 continue;
             }
             sal_memset(&thdiema_thdi_port_sp_config,0,
                        sizeof(thdiema_thdi_port_sp_config));
             mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
             /* C350: THDIEMA_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$166 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_SP_CONFIGm,
                 &thdiema_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
                 input_port_threshold->min_int_buff_ema_pool_cells_for_a_port);

             /* C351: THDIEMA_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = 
                      $C$262 <== =C184  */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_SP_CONFIGm,
                 &thdiema_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
                 input_port_threshold->total_shared_EMA_buff);

             /* C352: THDIEMA_PORT_MAX_PKT_SIZE.PORT_MAX_PKT_SIZE = =$C$68 */
             SOC_IF_ERROR_RETURN(READ_THDIEMA_PORT_MAX_PKT_SIZEr (
                                 unit, port, &rval));
             soc_reg_field_set(unit, THDIEMA_PORT_MAX_PKT_SIZEr, &rval,
                               PORT_MAX_PKT_SIZEf,
                               general_info->max_packet_size_in_cells);
             SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_MAX_PKT_SIZEr (
                                 unit, port, rval));
             /* C353: THDIEMA_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                      =$C$351-2*$C$72 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_SP_CONFIGm,
                 &thdiema_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
                 input_port_threshold->total_shared_EMA_buff -
                 (2 *  general_info->ether_mtu_cells_for_int_buff));
             SOC_IF_ERROR_RETURN(soc_mem_write(unit, 
                        THDIEMA_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx, &thdiema_thdi_port_sp_config));
         }
         sal_memset(&thdiema_thdi_port_pg_config,0,
                    sizeof(thdiema_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
             /* C354: THDIEMA_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = =$C$154 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_MIN_LIMITf,
                 input_port_threshold->min_int_buff_ema_pool_cells_per_PG);


             /* C355: THDIEMA_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                      IF($C$14, $C$58, $C$262) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
             } else {
                 /* $C$262 = =$C$184 */
                 temp_val = input_port_threshold->total_shared_EMA_buff;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, 
                 PG_SHARED_LIMITf, temp_val);

             /* C356: THDIEMA_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = =2*$C$72 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_RESET_OFFSETf,
                 (2 * general_info->ether_mtu_cells_for_int_buff));

             /* C357: THDIEMA_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_RESET_FLOORf, 0);

             /* C358: THDIEMA_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                      IF($C$14, 1, 0) */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = 1;
             } else {
                 temp_val = 0;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
                 &thdiema_thdi_port_pg_config, PG_SHARED_DYNAMICf,
                 temp_val);

             /* C359: THDIEMA_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                      For Ge:$C122 For Hg:$C112 For Cpu:$C142 */
             if (IS_CPU_PORT(unit, port)) {
                 temp_val = input_port_threshold->
                            hdrm_int_buff_cells_for_cpu_port;
             } else if (IS_GE_PORT(unit, port) || IS_LB_PORT(unit,port)) {
                 temp_val = input_port_threshold->hdrm_int_buff_cells_for_1G_PG;
             } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit,port)) {
                 temp_val= input_port_threshold->hdrm_int_buff_cells_for_10G_PG;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
               &thdiema_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

             /* C360: THDIEMA_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                      for lossy=1 else 0 */
             if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                 temp_val = 0;
             } else {
                 temp_val = 1;
             }
             soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm, 
                 &thdiema_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
                 temp_val);
         }
         /* C361: THDIEMA_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
             &thdiema_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C362: THDIEMA_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIEMA_THDI_PORT_PG_CONFIGm,
             &thdiema_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);
         SOC_IF_ERROR_RETURN(soc_mem_write(
                        unit, THDIEMA_THDI_PORT_PG_CONFIGm, 
                        MEM_BLOCK_ALL, mem_idx,
                        &thdiema_thdi_port_pg_config));
    }
    /* 1.4 RE WQEs                      */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only priority_group = 0 is used on single PG ports */
    /* Assuming only priority_group = 7 is used on eight PG ports */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         if (((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
            (((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0) ||
            (port == 30) || (port == 33) ||
            (port == 36) || (port == 39))) || (IS_LB_PORT(unit,port))) {
             priority_group = 7;
         } else {
             priority_group = 0;
         }
         if( (flex_port != -1) && (flex_port != port) ) {
             continue;
         }
         sal_memset(&thdirqe_thdi_port_sp_config , 0,
                    sizeof(thdirqe_thdi_port_sp_config));
  
         mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
         /* C365: THDIRQE_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$168 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_SP_CONFIGm,
             &thdirqe_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
             input_port_threshold->min_RE_WQEs_pkts_for_a_port);

         /* C366: THDIRQE_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = $C$186 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_SP_CONFIGm,
             &thdirqe_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
             input_port_threshold->total_shared_RE_WQEs_buff);

         /* C367: THDIRQE_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                  =$C$366 -2 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_SP_CONFIGm,
             &thdirqe_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
             input_port_threshold->total_shared_RE_WQEs_buff - 2);
         SOC_IF_ERROR_RETURN(soc_mem_write(
                        unit, THDIRQE_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx, &thdirqe_thdi_port_sp_config));

         sal_memset(&thdirqe_thdi_port_pg_config , 0,
                    sizeof(thdirqe_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         /* C368: THDIRQE_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = =$C$156 */
         temp_val = input_port_threshold->min_RE_WQEs_pkt_per_PG;
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_MIN_LIMITf,temp_val);

         /* C369: THDIRQE_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                  IF($C$14, $C$58, $C$186) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
         } else {
             temp_val = input_port_threshold->total_shared_RE_WQEs_buff;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, 
             PG_SHARED_LIMITf, temp_val);

         /* C370: THDIRQE_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = 2 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_RESET_OFFSETf,2);

         /* C371: THDIRQE_THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_RESET_FLOORf, 0);

         /* C372: THDIRQE_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                  IF($C$14, 1, 0) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 1;
         } else {
             temp_val = 0;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, PG_SHARED_DYNAMICf,
             temp_val);

         /* C373: THDIRQE_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                  For Ge:$C124 For Hg:$C114 For Cpu:$C144 */
         if (IS_CPU_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_RE_WQEs_pkts_for_cpu_port;
         } else if (IS_GE_PORT(unit, port) || IS_LB_PORT(unit,port)) {
             temp_val = input_port_threshold->hdrm_RE_WQEs_pkts_for_1G_PG;
         } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
             temp_val= input_port_threshold->hdrm_RE_WQEs_pkts_for_10G_PG;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
           &thdirqe_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

         /* C374: THDIRQE_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                  for lossy=1 else 0
                  Packed : 0 */
         if (_soc_kt2_mmu_params.lossless_mode_d_c ||
             _soc_kt2_mmu_params.packing_mode_d_c) {
             temp_val = 0;
         } else {
             temp_val = 1;
         }
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm, 
             &thdirqe_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
             temp_val);

         /* C375: THDIRQE_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
             &thdirqe_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C376: THDIRQE_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIRQE_THDI_PORT_PG_CONFIGm,
                 &thdirqe_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);
   
         SOC_IF_ERROR_RETURN(soc_mem_write(unit, THDIRQE_THDI_PORT_PG_CONFIGm, 
                        MEM_BLOCK_ALL, mem_idx, &thdirqe_thdi_port_pg_config));

    }
    /* 1.5 EQEs                         */
    /* Assuming only service_pool = 0 is used */
    /* Assuming only priority_group = 0 is used on single PG ports */
    /* Assuming only priority_group = 7 is used on eight PG ports */
    SOC_PBMP_ITER (valid_port_cpu_pbmp, port) {
         if (((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
            (((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0) ||
            (port == 30) || (port == 33) ||
            (port == 36) || (port == 39))) || (IS_LB_PORT(unit,port))) {
             priority_group = 7;
         } else {
             priority_group = 0;
         }
         if( (flex_port != -1) && (flex_port != port) ) {
             continue;
         }
         sal_memset(&thdiqen_thdi_port_sp_config,0,
                    sizeof(thdiqen_thdi_port_sp_config));
         mem_idx= (port * KT2_MAX_SERVICE_POOLS) + service_pool;
         /* C379: THDIQEN_THDI_PORT_SP_CONFIG.PORT_SP_MIN_LIMIT  = $C$169 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_SP_CONFIGm,
             &thdiqen_thdi_port_sp_config, PORT_SP_MIN_LIMITf,
             input_port_threshold->min_EQEs_pkts_for_a_port);

         /* C380: THDIQEN_THDI_PORT_SP_CONFIG.PORT_SP_MAX_LIMIT = $C$187 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_SP_CONFIGm,
             &thdiqen_thdi_port_sp_config, PORT_SP_MAX_LIMITf,
             input_port_threshold->total_shared_EQEs_buff);

         /* C381: THDIQEN_THDI_PORT_SP_CONFIG.PORT_SP_RESUME_LIMIT =
                  =C380-2*C49 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_SP_CONFIGm,
             &thdiqen_thdi_port_sp_config, PORT_SP_RESUME_LIMITf,
             input_port_threshold->total_shared_EQEs_buff - 
             (2 * _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt));
         SOC_IF_ERROR_RETURN(soc_mem_write(unit, 
                        THDIQEN_THDI_PORT_SP_CONFIGm, MEM_BLOCK_ALL, 
                        mem_idx, &thdiqen_thdi_port_sp_config));
         sal_memset(&thdiqen_thdi_port_pg_config,0,
                    sizeof(thdiqen_thdi_port_pg_config));
         mem_idx= (port * KT2_MAX_PRIORITY_GROUPS) + priority_group;
         /* C382: THDIQEN_THDI_PORT_PG_CONFIG.PG_MIN_LIMIT(PG0) = 
                   =$C$157 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_MIN_LIMITf,
             input_port_threshold->min_EQEs_pkt_per_PG);


         /* C383: THDIQEN_THDI_PORT_PG_CONFIG.PG_SHARED_LIMIT =
                  =IF($C$14, $C$58, $C$187) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = _soc_kt2_mmu_params.mmu_ing_pg_dyn_thd_param;
         } else {
             temp_val = input_port_threshold->total_shared_EQEs_buff;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, 
             PG_SHARED_LIMITf, temp_val);

         /* C384: THDIQEN_THDI_PORT_PG_CONFIG.PG_RESET_OFFSET = =2*C49 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_RESET_OFFSETf,
             2 * _soc_kt2_mmu_params.mmu_exp_num_of_repl_per_pkt);

         /* C385: THDIQEN_THDI_PORT_PG_CONFIG.PG_RESET_FLOOR = 0 */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_RESET_FLOORf, 0);

         /* C386: THDIQEN_THDI_PORT_PG_CONFIG.PG_SHARED_DYNAMIC= 
                  IF($C$14, 1, 0) */
         if (_soc_kt2_mmu_params.lossless_mode_d_c) {
             temp_val = 1;
         } else {
             temp_val = 0;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, PG_SHARED_DYNAMICf,
             temp_val);

         /* C387: THDIQEN_THDI_PORT_PG_CONFIG.PG_HDRM_LIMIT
                  For Ge:$C125 For Hg:$C115 For Cpu:$C145 */
         if (IS_CPU_PORT(unit, port)) {
             temp_val = input_port_threshold->hdrm_EQEs_pkts_for_cpu_port;
         } else if (IS_GE_PORT(unit, port) || IS_LB_PORT(unit,port)) {
             temp_val = input_port_threshold->hdrm_EQEs_pkts_for_1G_PG;
         } else if (IS_HG_PORT(unit, port) || IS_XE_PORT(unit, port)) {
             temp_val= input_port_threshold->hdrm_EQEs_pkts_for_10G_PG;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
           &thdiqen_thdi_port_pg_config, PG_HDRM_LIMITf,temp_val);

         /* C388: THDIQEN_THDI_PORT_PG_CONFIG.PG_GBL_HDRM_EN = 
                  for lossy=1 else 0 
                  Packed : 0 */
         if (_soc_kt2_mmu_params.lossless_mode_d_c  ||
             _soc_kt2_mmu_params.packing_mode_d_c) {
             temp_val = 0;
         } else {
             temp_val = 1;
         }
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm, 
             &thdiqen_thdi_port_pg_config, PG_GBL_HDRM_ENf ,
             temp_val);

         /* C389: THDIQEN_THDI_PORT_PG_CONFIG.SP_SHARED_MAX_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
             &thdiqen_thdi_port_pg_config, SP_SHARED_MAX_ENABLEf ,1);

         /* C390: THDIQEN_THDI_PORT_PG_CONFIG.SP_MIN_PG_ENABLE =
                  For Ge:1 For Hg,Cpu: Ge Value only!!! */
         soc_mem_field32_set(unit, THDIQEN_THDI_PORT_PG_CONFIGm,
                 &thdiqen_thdi_port_pg_config, SP_MIN_PG_ENABLEf ,1);
         SOC_IF_ERROR_RETURN(soc_mem_write( unit, THDIQEN_THDI_PORT_PG_CONFIGm, 
                        MEM_BLOCK_ALL, mem_idx, &thdiqen_thdi_port_pg_config));

    }
     
    /* ######################## */
    /* 2. Output Port Thresholds */
    /* ######################## */
    /* 2.1 Internal Buffer              */
    op_node = 0;
    port_max_opnodes = 0;
    for(port_index = 0, op_node = 0 ; 
        port_index < COUNTOF(port_list);
        port_index++, op_node += port_max_opnodes ) {

        port = port_list[port_index];
        port_max_opnodes = ceil_func(si->port_num_uc_cosq[port],8);

        if (!SOC_PBMP_MEMBER(valid_port_cpu_pbmp, port)) {
            continue;
        }
        if( (flex_port != -1) && (flex_port != port) ) {
            continue;
        }

        if (!SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port) &&
            (port >= KT2_CMIC_PORT) && (port <= KT2_LPBK_PORT)) {
            for (op_node_offset = 0; 
                 op_node_offset < port_max_opnodes ;
                 op_node_offset++) {
                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,op_node + op_node_offset,
                                     &mmu_thdo_opnconfig_cell_entry));
                 /* C394:THDO_OPNCONFIG_CELL.OPN_SHARED_LIMIT_CELL = =$C$219 */
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     OPN_SHARED_LIMIT_CELLf,
                                     output_port_threshold->
                                     min_grntd_tot_shr_queue_cells_int_buff);

                 /* C395:THDO_OPNCONFIG_CELL.OP_SHARED_RESET_VALUE_CELL
                         = C394-2*$C$72 */
                 temp_val = output_port_threshold->
                            min_grntd_tot_shr_queue_cells_int_buff -
                            (2 * general_info->ether_mtu_cells_for_int_buff);
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     OPN_SHARED_RESET_VALUE_CELLf, temp_val);

                 /* C396:THDO_OPNCONFIG_CELL.PORT_LIMIT_ENABLE_CELL
                    = 0 */
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     PORT_LIMIT_ENABLE_CELLf, 0);
                 /* PIDf :Updated by cosq scheduler code while attaching node */
                 /*
                 soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                     &mmu_thdo_opnconfig_cell_entry, 
                                     PIDf, port);
                  */
                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                                     MEM_BLOCK_ALL,op_node + op_node_offset,
                                     &mmu_thdo_opnconfig_cell_entry));
            }

            buf_port = &buf->ports[port];

            for (queue = si->port_uc_cosq_base[port];
                 queue < si->port_uc_cosq_base[port] + 
                         si->port_num_uc_cosq[port];
                 queue++) {
                /* caluculating idx as per the mmu_config tool*/
                idx = si->port_num_cosq[port] + queue - si->port_uc_cosq_base[port];
                buf_queue = &buf_port->queues[idx];
                SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qconfig_cell_entry));
                 /* C397:THDO_QCONFIG_CELL.Q_MIN_CELL
                    = =$C$201 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_MIN_CELLf,
                     buf_queue->guarantee > 0 ? buf_queue->guarantee :
                     output_port_threshold->min_grntd_res_queue_cells_int_buff);

                 /* C398:THDO_QCONFIG_CELL.Q_SHARED_LIMIT_CELL
                         =IF($C$14,$C$219,$C$60) */
                 if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                     temp_val = output_port_threshold->
                                       min_grntd_tot_shr_queue_cells_int_buff;
                 } else {
                     temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
                 }
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf, 
                     temp_val);

                 if ((buf_queue->pool_scale != -1) && 
                         mmu_config_enabled) {
                     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                             &mmu_thdo_qconfig_cell_entry, Q_LIMIT_DYNAMIC_CELLf, 
                             1);
                     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                             &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf, 
                             buf_queue->pool_scale);
                 } else {
                     /* C400:THDO_QCONFIG_CELL.Q_LIMIT_DYNAMIC_CELL
                        =IF($C$14, 0, 1) */
                     soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                             &mmu_thdo_qconfig_cell_entry, Q_LIMIT_DYNAMIC_CELLf, 
                             _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);
                 }

                 /* C401:THDO_QCONFIG_CELL.Q_LIMIT_ENABLE_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_LIMIT_ENABLE_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C402:THDO_QCONFIG_CELL.Q_COLOR_ENABLE_CELL = 0 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_ENABLE_CELLf,0); 

                 /* C403: THDO_QCONFIG_CELL.Q_COLOR_LIMIT_DYNAMIC_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_LIMIT_DYNAMIC_CELLf,
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C404: THDO_QCONFIG_CELL.LIMIT_YELLOW_CELL= 
                          if lossless= C398/8 else C398 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, LIMIT_YELLOW_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);
                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ALL,queue,
                                     &mmu_thdo_qconfig_cell_entry));

                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qoffset_cell_entry));
                 /* C399:THDO_QOFFSET_CELL.RESET_OFFSET_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_CELLf, 2);

                 /* C405: THDO_QOFFSET_CELL.LIMIT_RED_CELL  = 
                          if lossless= C398/8 else C398 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, LIMIT_RED_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);

                 /* C406: THDO_QOFFSET_CELL.RESET_OFFSET_YELLOW_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_YELLOW_CELLf,2); 
                 /* C407: THDO_QOFFSET_CELL.RESET_OFFSET_RED_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_RED_CELLf,2); 

                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ALL,queue,
                                     &mmu_thdo_qoffset_cell_entry));
            }
        }
    }
    /* 2.2 External Buffer              */
    for(port_index = 0, op_node = 0 ; 
        port_index < COUNTOF(port_list);
        port_index++, op_node += port_max_opnodes ) {

        port = port_list[port_index];
        port_max_opnodes = ceil_func(si->port_num_uc_cosq[port],8);

        if (!SOC_PBMP_MEMBER(valid_port_cpu_pbmp, port)) {
            continue;
        }
        if( (flex_port != -1) && (flex_port != port) ) {
            continue;
        }

        if (!IS_CPU_PORT(unit, port) &&
            (port > KT2_CMIC_PORT) && (port <= KT2_LPBK_PORT) &&
            SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port)) {

            SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                MEM_BLOCK_ANY,op_node , &mmu_thdo_opnconfig_cell_entry));
            /* C409:THDO_OPNCONFIG_CELL.OPN_SHARED_LIMIT_CELL = =$C$220 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                OPN_SHARED_LIMIT_CELLf,
                                output_port_threshold->
                                min_grntd_tot_shr_queue_cells_ext_buff);

            /* C410:THDO_OPNCONFIG_CELL.OP_SHARED_RESET_VALUE_CELL
                    = =$C$409-2*$C$73 */
            temp_val = output_port_threshold->
                       min_grntd_tot_shr_queue_cells_ext_buff -
                       (2 * general_info->ether_mtu_cells_for_ext_buff);
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                OPN_SHARED_RESET_VALUE_CELLf, temp_val);

            /* C411:THDO_OPNCONFIG_CELL.PORT_LIMIT_ENABLE_CELL = 0 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                PORT_LIMIT_ENABLE_CELLf, 0);
            /* PIDf :Updated by cosq scheduler code while attaching node */
            /* 
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm, 
                                &mmu_thdo_opnconfig_cell_entry, 
                                PIDf, port);
             */
            SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                                MEM_BLOCK_ALL,op_node,
                                &mmu_thdo_opnconfig_cell_entry));

            for (queue = si->port_uc_cosq_base[port];
                 queue < si->port_uc_cosq_base[port] + 
                         si->port_num_uc_cosq[port];
                 queue++) {
                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qconfig_cell_entry));
                 /* C412:THDO_QCONFIG_CELL.Q_MIN_CELL
                    = =$C$202 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_MIN_CELLf,
                     output_port_threshold->min_grntd_res_queue_cells_ext_buff);

                 /* C413:THDO_QCONFIG_CELL.Q_SHARED_LIMIT_CELL
                         =IF($C$14,$C$220,$C$60) */
                 if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                     temp_val = output_port_threshold->
                                       min_grntd_tot_shr_queue_cells_ext_buff;
                 } else {
                     temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
                 }
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf, 
                     temp_val);

                 /* C415:THDO_QCONFIG_CELL.Q_LIMIT_DYNAMIC_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_LIMIT_DYNAMIC_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C416:THDO_QCONFIG_CELL.Q_LIMIT_ENABLE_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_LIMIT_ENABLE_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C417:THDO_QCONFIG_CELL.Q_COLOR_ENABLE_CELL = 0 */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_ENABLE_CELLf,0); 

                 /* C418: THDO_QCONFIG_CELL.Q_COLOR_LIMIT_DYNAMIC_CELL
                         =IF($C$14, 0, 1) */
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, Q_COLOR_LIMIT_DYNAMIC_CELLf,
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

                 /* C419: THDO_QCONFIG_CELL.LIMIT_YELLOW_CELL= 
                          if lossless= CEILING(C413/8) else C413 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QCONFIG_CELLm, 
                     &mmu_thdo_qconfig_cell_entry, LIMIT_YELLOW_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);
                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_CELLm(unit,
                                     MEM_BLOCK_ALL,queue,
                                     &mmu_thdo_qconfig_cell_entry));

                 SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ANY,queue,
                                     &mmu_thdo_qoffset_cell_entry));
                 /* C414:THDO_QOFFSET_CELL.RESET_OFFSET_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_CELLf, 2);

                 /* C420: THDO_QOFFSET_CELL.LIMIT_RED_CELL  = 
                          if lossless= CEILING(C413/8) else C413 */
                 temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_CELLm, 
                            &mmu_thdo_qconfig_cell_entry, Q_SHARED_LIMIT_CELLf);
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, LIMIT_RED_CELLf, 
                     _soc_kt2_mmu_params.lossless_mode_d_c ? 
                     ceil_func(temp_val, 8) : temp_val);

                 /* C421: THDO_QOFFSET_CELL.RESET_OFFSET_YELLOW_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_YELLOW_CELLf,2); 
                 /* C422: THDO_QOFFSET_CELL.RESET_OFFSET_RED_CELL =2 */
                 soc_mem_field32_set(unit, MMU_THDO_QOFFSET_CELLm, 
                     &mmu_thdo_qoffset_cell_entry, RESET_OFFSET_RED_CELLf,2); 

                 SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_CELLm(unit,
                                     MEM_BLOCK_ALL,queue,
                                     &mmu_thdo_qoffset_cell_entry));
            }
        }
    }
    /* 2.3 EMA Pool                     */
    if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDOEMAr); cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDOEMAr(
                        unit, cos, &rval));
            /* C424:OP_QUEUE_CONFIG1_THDOEMA.Q_MIN = C204 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDOEMAr, &rval,
                    Q_MINf, 
                    output_port_threshold->min_grntd_res_EMA_queue_cells);

            /* C429:OP_QUEUE_CONFIG1_THDOEMA.Q_COLOR_ENABLE  = 0 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDOEMAr, &rval,
                    Q_COLOR_ENABLEf, 0);

            /* C430:OP_QUEUE_CONFIG1_THDOEMA.Q_COLOR_DYNAMIC lossless=0 else 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDOEMAr, &rval,
                    Q_COLOR_DYNAMICf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDOEMAr(
                        unit, cos, rval));
        }

        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDOEMAr); cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDOEMAr(
                        unit, cos, &rval));
            /* C425:OP_QUEUE_CONFIG_THDOEMA.Q_SHARED_LIMIT
               =IF($C$14,$C$222,$C$60)..Can be put outside loop */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->
                    min_grntd_tot_shr_EMA_queue_cells;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDOEMAr, &rval,
                    Q_SHARED_LIMITf, temp_val);

            /*C427: OP_QUEUE_CONFIG_THDOEMA.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/

            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDOEMAr, &rval,
                    Q_LIMIT_DYNAMICf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);

            /*C428:OP_QUEUE_CONFIG_THDOEMA.Q_LIMIT_ENABLE:=lossless=0 else 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDOEMAr, &rval,
                    Q_LIMIT_ENABLEf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDOEMAr(
                        unit, cos, rval));

        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDOEMAr); cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_THDOEMAr(unit, cos,&rval));
            /*C422: OP_QUEUE_RESET_OFFSET_THDOEMA.Q_RESET_OFFSET == 2 */
            soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDOEMAr, &rval,
                    Q_RESET_OFFSETf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_THDOEMAr(unit, cos,rval));
        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDOEMAr); 
                cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDOEMAr(
                        unit, cos,&rval));
            /* C431: OP_QUEUE_LIMIT_YELLOW_THDOEMA.Q_LIMIT_YELLOW
               for lossless =CEILING(C425/8, 1)    else C425 */
            /* HG Port has temp_val/8++ !! */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->
                    min_grntd_tot_shr_EMA_queue_cells;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }	
            soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDOEMAr, &rval,
                    Q_LIMIT_YELLOWf, _soc_kt2_mmu_params.lossless_mode_d_c?
                    ceil_func(temp_val,8): temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDOEMAr(
                        unit, cos,rval));
        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDOEMAr); 
                cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDOEMAr(
                        unit, cos,&rval));
            /* C432: OP_QUEUE_LIMIT_RED_THDOEMA.Q_LIMIT_RED
               for lossless =CEILING(C425/8, 1)    else C425 */
            /* HG Port has temp_val/8++ !! */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->
                    min_grntd_tot_shr_EMA_queue_cells;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }	
            soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDOEMAr, &rval,
                    Q_LIMIT_REDf, _soc_kt2_mmu_params.lossless_mode_d_c?
                    ceil_func(temp_val,8): temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDOEMAr(
                        unit, cos,rval));
        }
        for(cos=0; 
                cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr); 
                cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr(unit, cos,&rval));
            /*C433:OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMA.RESUME_OFFSET_YELLOW=2*/
            soc_reg_field_set(unit,
                    OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr, &rval,
                    RESUME_OFFSET_YELLOWf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDOEMAr(unit, cos,rval));
        }
        for(cos=0; 
                cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDOEMAr); 
                cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_RED_THDOEMAr(unit, cos,&rval));
            /*C434:OP_QUEUE_RESET_OFFSET_RED_THDOEMA.RESUME_OFFSET_RED=2*/
            soc_reg_field_set(unit,
                    OP_QUEUE_RESET_OFFSET_RED_THDOEMAr, &rval,
                    RESUME_OFFSET_REDf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_RED_THDOEMAr(unit, cos,rval));
        }
    }
    /* 2.4 RE WQEs                      */
    /* 2.4.1 RQEQ */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEQr); cos++) {
        buf_rqe_queue = &buf->rqe_queues[cos];
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORQEQr(
                    unit, cos, &rval));
        if (buf_rqe_queue->pkt_guarantee) {
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEQr, &rval,
                    Q_MINf, 
                    buf_rqe_queue->pkt_guarantee);
        } else {
            /* C436:OP_QUEUE_CONFIG1_THDORQEQ.Q_MIN = C205 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEQr, &rval,
                    Q_MINf, 
                    output_port_threshold->min_grntd_res_RE_WQs_cells);
        }

        /* C441:OP_QUEUE_CONFIG1_THDORQEQ.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEQr, &rval,
                Q_COLOR_ENABLEf, 0);

        /* C442:OP_QUEUE_CONFIG1_THDORQEQ.Q_COLOR_DYNAMIC lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEQr, &rval,
                Q_COLOR_DYNAMICf, 
                _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORQEQr(
                    unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORQEQr); cos++) {
        buf_rqe_queue = &buf->rqe_queues[cos];
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORQEQr(
                    unit, cos, &rval));
        /* C437:OP_QUEUE_CONFIG_THDORQEQ.Q_SHARED_LIMIT
           =IF($C$14,$C$223-1,$C$60)..Can be put outside loop */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = output_port_threshold->
                min_grntd_tot_shr_RE_WQs_cells - 1;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	

        if ((buf_rqe_queue->pkt_pool_scale != -1) && 
                mmu_config_enabled) {
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                    Q_SHARED_LIMITf, buf_rqe_queue->pkt_pool_scale);
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                    Q_LIMIT_DYNAMICf, 1); 

        } else {
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                    Q_SHARED_LIMITf, temp_val);
            /*C439: OP_QUEUE_CONFIG_THDORQEQ.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/

            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                    Q_LIMIT_DYNAMICf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        }    
        /*C440:OP_QUEUE_CONFIG_THDORQEQ.Q_LIMIT_ENABLE:=lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEQr, &rval,
                Q_LIMIT_ENABLEf, 
                _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORQEQr(
                    unit, cos, rval));

    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORQEQr); cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_THDORQEQr(unit, cos,&rval));
        /*C438: OP_QUEUE_RESET_OFFSET_THDORQEQ.Q_RESET_OFFSET == 1 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORQEQr, &rval,
                Q_RESET_OFFSETf, 1);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_THDORQEQr(unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORQEQr(
                    unit, cos,&rval));
        /* C443: OP_QUEUE_LIMIT_YELLOW_THDORQEQ.Q_LIMIT_YELLOW
           for lossless =CEILING(C437/8, 1)-1    else C437 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->
                    min_grntd_tot_shr_RE_WQs_cells,8) - 1;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEQr, &rval,
                Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORQEQr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORQEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORQEQr(
                    unit, cos,&rval));
        /* C444: OP_QUEUE_LIMIT_RED_THDORQEQ.Q_LIMIT_RED
           for lossless =CEILING(C437/8, 1)-1    else C437 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->
                    min_grntd_tot_shr_RE_WQs_cells,8) - 1;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORQEQr, &rval,
                Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORQEQr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr(unit, cos,&rval));
        /*C445:OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQ.RESUME_OFFSET_YELLOW=1*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr, &rval,
                RESUME_OFFSET_YELLOWf, 1);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEQr(unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORQEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_RED_THDORQEQr(unit, cos,&rval));
        /*C446:OP_QUEUE_RESET_OFFSET_RED_THDORQEQ.RESUME_OFFSET_RED=1*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_RED_THDORQEQr, &rval,
                RESUME_OFFSET_REDf, 1);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORQEQr(unit, cos,rval));
    }
    /* 2.4.2 RQEI */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEIr); cos++) {
        buf_rqe_queue = &buf->rqe_queues[cos];
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORQEIr(
                    unit, cos, &rval));
        if (buf_rqe_queue->guarantee) {
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEIr, &rval, Q_MINf,
                    buf_rqe_queue->guarantee);

        } else {
            /* C447:OP_QUEUE_CONFIG1_THDORQEI.Q_MIN = C206 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEIr, &rval, Q_MINf, 
                    output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff);
        }

        /* C452:OP_QUEUE_CONFIG1_THDORQEI.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEIr, &rval,
                Q_COLOR_ENABLEf, 0);

        /* C453:OP_QUEUE_CONFIG1_THDORQEI.Q_COLOR_DYNAMIC lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEIr, &rval,
                Q_COLOR_DYNAMICf, 
                _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORQEIr(
                    unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORQEIr); cos++) {
        buf_rqe_queue = &buf->rqe_queues[cos];
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORQEIr(
                    unit, cos, &rval));
        /* C448:OP_QUEUE_CONFIG_THDORQEI.Q_SHARED_LIMIT
           =IF($C$14,$C$224,$C$60)..Can be put outside loop */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff;
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /*
           SOC_FIND_FIELD(Q_SHARED_LIMITf,
           SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEIr).fields,
           SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEIr).nFields,
           fieldp);
           if (temp_val >= (1 << fieldp->len)) {
           temp_val = (1 << fieldp->len) - 1;
           }
         */
        if ((buf_rqe_queue->pool_scale != -1 ) && 
                mmu_config_enabled) {
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                    Q_SHARED_LIMITf, buf_rqe_queue->pool_scale);
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                    Q_LIMIT_DYNAMICf, 
                    1);

        } else {
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                    Q_SHARED_LIMITf, temp_val);

            /*C450: OP_QUEUE_CONFIG_THDORQEI.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                    Q_LIMIT_DYNAMICf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        }

        /*C451:OP_QUEUE_CONFIG_THDORQEI.Q_LIMIT_ENABLE:=lossless=0 else 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEIr, &rval,
                Q_LIMIT_ENABLEf, 
                _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORQEIr(
                    unit, cos, rval));

    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORQEIr); cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_THDORQEIr(unit, cos,&rval));
        /*C449: OP_QUEUE_RESET_OFFSET_THDORQEI.Q_RESET_OFFSET == 2 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORQEIr, &rval,
                Q_RESET_OFFSETf, 2);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_THDORQEIr(unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORQEIr(
                    unit, cos,&rval));
        /* C454: OP_QUEUE_LIMIT_YELLOW_THDORQEI.Q_LIMIT_YELLOW
           for lossless =CEILING(C448/8, 1)    else C448 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff,8);
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /* 
           SOC_FIND_FIELD(Q_LIMIT_YELLOWf,
           SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr).fields,
           SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr).nFields,
           fieldp);
           if (temp_val >= (1 << fieldp->len)) {
           temp_val = (1 << fieldp->len) - 1;
           }
         */
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEIr, &rval,
                Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORQEIr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORQEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORQEIr(
                    unit, cos,&rval));
        /* C455: OP_QUEUE_LIMIT_RED_THDORQEI.Q_LIMIT_RED
           for lossless =CEILING(C448/8, 1)    else C448 */
        if (_soc_kt2_mmu_params.lossless_mode_d_c) {
            temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_int_buff,8);
        } else {
            temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
        }	
        /* 
           SOC_FIND_FIELD(Q_LIMIT_REDf,
           SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEIr).fields,
           SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEIr).nFields,
           fieldp);
           if (temp_val >= (1 << fieldp->len)) {
           temp_val = (1 << fieldp->len) - 1;
           }
         */
        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORQEIr, &rval,
                Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORQEIr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr(unit, cos,&rval));
        /*C456:OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEI.RESUME_OFFSET_YELLOW=2*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr, &rval,
                RESUME_OFFSET_YELLOWf, 2);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEIr(unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORQEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_RED_THDORQEIr(unit, cos,&rval));
        /*C457:OP_QUEUE_RESET_OFFSET_RED_THDORQEI.RESUME_OFFSET_RED=2*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_RED_THDORQEIr, &rval,
                RESUME_OFFSET_REDf, 2);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORQEIr(unit, cos,rval));
    }
    /* 2.4.3 RQEE */
    if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORQEEr); cos++) {
            buf_rqe_queue = &buf->rqe_queues[cos];
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORQEEr(
                        unit, cos, &rval));
            /* C458:OP_QUEUE_CONFIG1_THDORQEE.Q_MIN = C207 */
            if (buf_rqe_queue->ext_guarantee) {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEEr, &rval, Q_MINf, 
                        buf_rqe_queue->ext_guarantee);
            } else {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEEr, &rval, Q_MINf, 
                        output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_ext_buff);
            }
            /* C463:OP_QUEUE_CONFIG1_THDORQEE.Q_COLOR_ENABLE  = 0 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEEr, &rval,
                    Q_COLOR_ENABLEf, 0);

            /* C464:OP_QUEUE_CONFIG1_THDORQEE.Q_COLOR_DYNAMIC lossless=0 else 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORQEEr, &rval,
                    Q_COLOR_DYNAMICf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORQEEr(
                        unit, cos, rval));
        }

        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORQEEr); cos++) {
            buf_rqe_queue = &buf->rqe_queues[cos];
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORQEEr(
                        unit, cos, &rval));
            /* C459:OP_QUEUE_CONFIG_THDORQEE.Q_SHARED_LIMIT
               =IF($C$14,$C$225,$C$60)..Can be put outside loop */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }	
            /* 
               SOC_FIND_FIELD(Q_SHARED_LIMITf,
               SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEEr).fields,
               SOC_REG_INFO(unit, OP_QUEUE_CONFIG_THDORQEEr).nFields,
               fieldp);
               if (temp_val >= (1 << fieldp->len)) {
               temp_val = (1 << fieldp->len) - 1;
               }
             */

            if ((buf_rqe_queue->ext_pool_scale != -1) && 
                    mmu_config_enabled) {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                        Q_SHARED_LIMITf, buf_rqe_queue->ext_pool_scale);
                soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                        Q_LIMIT_DYNAMICf, 
                        1);
            } else {
                soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                        Q_SHARED_LIMITf, temp_val);
                /*C461: OP_QUEUE_CONFIG_THDORQEE.Q_LIMIT_DYNAMIC:=lossless=0 else 1*/
                soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                        Q_LIMIT_DYNAMICf, 
                        _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            }    
            /*C462:OP_QUEUE_CONFIG_THDORQEE.Q_LIMIT_ENABLE:=lossless=0 else 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORQEEr, &rval,
                    Q_LIMIT_ENABLEf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 0 : 1);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORQEEr(
                        unit, cos, rval));

        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORQEEr); cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_THDORQEEr(unit, cos,&rval));
            /*C460: OP_QUEUE_RESET_OFFSET_THDORQEE.Q_RESET_OFFSET == 2 */
            soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORQEEr, &rval,
                    Q_RESET_OFFSETf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_THDORQEEr(unit, cos,rval));
        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORQEEr(
                        unit, cos,&rval));
            /* C465: OP_QUEUE_LIMIT_YELLOW_THDORQEE.Q_LIMIT_YELLOW
               for lossless =CEILING(C459/8, 1)    else C459*/
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff,8);
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }	
            /* 
               SOC_FIND_FIELD(Q_LIMIT_YELLOWf,
               SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr).fields,
               SOC_REG_INFO(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr).nFields,
               fieldp);
               if (temp_val >= (1 << fieldp->len)) {
               temp_val = (1 << fieldp->len) - 1;
               }
             */
            soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORQEEr, &rval,
                    Q_LIMIT_YELLOWf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORQEEr(
                        unit, cos,rval));
        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORQEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORQEEr(
                        unit, cos,&rval));
            /* C466: OP_QUEUE_LIMIT_RED_THDORQEE.Q_LIMIT_RED
               for lossless =CEILING(C459/8, 1)    else C459 */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = ceil_func(output_port_threshold->min_grntd_tot_shr_RE_WQs_queue_cells_for_ext_buff,8);
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }	
            /* 
               SOC_FIND_FIELD(Q_LIMIT_REDf,
               SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEEr).fields,
               SOC_REG_INFO(unit, OP_QUEUE_LIMIT_RED_THDORQEEr).nFields,
               fieldp);
               if (temp_val >= (1 << fieldp->len)) {
               temp_val = (1 << fieldp->len) - 1;
               }
             */
            soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORQEEr, &rval,
                    Q_LIMIT_REDf, temp_val);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORQEEr(
                        unit, cos,rval));
        }
        for(cos=0; 
                cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr(unit, cos,&rval));
            /*C467:OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEE.RESUME_OFFSET_YELLOW=2*/
            soc_reg_field_set(unit,
                    OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr, &rval,
                    RESUME_OFFSET_YELLOWf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORQEEr(unit, cos,rval));
        }
        for(cos=0; 
                cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORQEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_RED_THDORQEEr(unit, cos,&rval));
            /*C468:OP_QUEUE_RESET_OFFSET_RED_THDORQEE.RESUME_OFFSET_RED=2*/
            soc_reg_field_set(unit,
                    OP_QUEUE_RESET_OFFSET_RED_THDORQEEr, &rval,
                    RESUME_OFFSET_REDf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORQEEr(unit, cos,rval));
        }
    }
    /* 2.5 EQEs                         */
    port_max_opnodes = 0;
    for(port_index = 0, op_node = 0 ; 
            port_index < COUNTOF(port_list);
            port_index++, op_node += port_max_opnodes ) {

        port = port_list[port_index];
        port_max_opnodes = ceil_func(si->port_num_uc_cosq[port],8);

        if (!SOC_PBMP_MEMBER(valid_port_cpu_pbmp, port)) {
            continue;
        }
        if( (flex_port != -1) && (flex_port != port) ) {
            continue;
        }

        for (op_node_offset = 0; 
                op_node_offset < port_max_opnodes;
                op_node_offset++) {
            SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_QENTRYm(unit,
                        MEM_BLOCK_ANY,op_node + op_node_offset,
                        &mmu_thdo_opnconfig_qentry_entry));
            /* C470:THDO_OPNCONFIG_QENTRY.OPN_SHARED_LIMIT_QENTRY = =$C$221 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
                    &mmu_thdo_opnconfig_qentry_entry, OPN_SHARED_LIMIT_QENTRYf,
                    output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs);

            /* C471:THDO_OPNCONFIG_QENTRY.OP_SHARED_RESET_VALUE_QENTRY
               = =$C$470 -2 */
            temp_val = output_port_threshold->
                min_grntd_tot_shr_queue_cells_EQEs - 2;
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
                    &mmu_thdo_opnconfig_qentry_entry, 
                    OPN_SHARED_RESET_VALUE_QENTRYf, temp_val);

            /* C472:THDO_OPNCONFIG_QENTRY.PORT_LIMIT_ENABLE_QENTRY
               = 0 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
                    &mmu_thdo_opnconfig_qentry_entry, 
                    PORT_LIMIT_ENABLE_QENTRYf, 0);
            /* PIDf :Updated by cosq scheduler code while attaching node */
            /* 
               soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm, 
               &mmu_thdo_opnconfig_qentry_entry, 
               PIDf, port);
             */
            SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_QENTRYm(unit,
                        MEM_BLOCK_ALL,op_node + op_node_offset,
                        &mmu_thdo_opnconfig_qentry_entry));
        }

        buf_port = &buf->ports[port];
        for (queue = si->port_uc_cosq_base[port];
                queue < si->port_uc_cosq_base[port] + si->port_num_uc_cosq[port];
                queue++) {
            idx = si->port_num_cosq[port] + queue - si->port_uc_cosq_base[port];
            buf_queue = &buf_port->queues[idx];

            SOC_IF_ERROR_RETURN(READ_MMU_THDO_QCONFIG_QENTRYm(unit,
                        MEM_BLOCK_ANY,queue,
                        &mmu_thdo_qconfig_qentry_entry));
            /* C473:THDO_QCONFIG_QENTRY.Q_MIN_QENTRY = =$C$203 */
            soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                    &mmu_thdo_qconfig_qentry_entry, Q_MIN_QENTRYf,
                    buf_queue->pkt_guarantee > 0 ? buf_queue->pkt_guarantee :
                    output_port_threshold->min_grntd_res_queue_cells_EQEs);

            /* C474:THDO_QCONFIG_QENTRY.Q_SHARED_LIMIT_QENTRY
               =IF($C$14,$C$221,$C$60) */
            if (_soc_kt2_mmu_params.lossless_mode_d_c) {
                temp_val = output_port_threshold->
                    min_grntd_tot_shr_queue_cells_EQEs;
            } else {
                temp_val = _soc_kt2_mmu_params.mmu_egr_pg_dyn_thd_param;
            }
            if ((buf_queue->pkt_pool_scale != -1) && 
                    mmu_config_enabled) {
                soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                        &mmu_thdo_qconfig_qentry_entry, Q_LIMIT_DYNAMIC_QENTRYf, 
                        1);
                soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                        &mmu_thdo_qconfig_qentry_entry, Q_SHARED_LIMIT_QENTRYf, 
                        buf_queue->pkt_pool_scale);
            } else {
                soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                        &mmu_thdo_qconfig_qentry_entry, Q_SHARED_LIMIT_QENTRYf, temp_val);

                /* C476:THDO_QCONFIG_QENTRY.Q_LIMIT_DYNAMIC_QENTRY
                   =IF($C$14, 0, 1) */
                soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                        &mmu_thdo_qconfig_qentry_entry, Q_LIMIT_DYNAMIC_QENTRYf, 
                        _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);
            }

            /* C477:THDO_QCONFIG_QENTRY.Q_LIMIT_ENABLE_QENTRY
               =IF($C$14, 0, 1) */
            soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                    &mmu_thdo_qconfig_qentry_entry, Q_LIMIT_ENABLE_QENTRYf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

            /* C478:THDO_QCONFIG_QENTRY.Q_COLOR_ENABLE_QENTRY = 0 */
            soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                    &mmu_thdo_qconfig_qentry_entry, Q_COLOR_ENABLE_QENTRYf,0); 

            /* C479: THDO_QCONFIG_QENTRY.Q_COLOR_LIMIT_DYNAMIC_QENTRY
               =IF($C$14, 0, 1) */
            soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                    &mmu_thdo_qconfig_qentry_entry, 
                    Q_COLOR_LIMIT_DYNAMIC_QENTRYf,
                    _soc_kt2_mmu_params.lossless_mode_d_c ? 0 : 1);

            /* C480: THDO_QCONFIG_QENTRY.LIMIT_YELLOW_QENTRY= 
               if lossless= C474/8 else C474 */
            temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_QENTRYm, 
                    &mmu_thdo_qconfig_qentry_entry, Q_SHARED_LIMIT_QENTRYf);
            soc_mem_field32_set(unit, MMU_THDO_QCONFIG_QENTRYm, 
                    &mmu_thdo_qconfig_qentry_entry, LIMIT_YELLOW_QENTRYf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c ? 
                    ceil_func(temp_val, 8) : temp_val);
            SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QCONFIG_QENTRYm(unit,
                        MEM_BLOCK_ALL,queue,
                        &mmu_thdo_qconfig_qentry_entry));

            SOC_IF_ERROR_RETURN(READ_MMU_THDO_QOFFSET_QENTRYm(unit,
                        MEM_BLOCK_ANY,queue,
                        &mmu_thdo_qoffset_qentry_entry));
            /* C475:THDO_QOFFSET_QENTRY.RESET_OFFSET_QENTRY =1 */
            soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                    &mmu_thdo_qoffset_qentry_entry, RESET_OFFSET_QENTRYf, 1);

            /* C481: THDO_QOFFSET_QENTRY.LIMIT_RED_QENTRY  = 
               if lossless= C474/8 else C474 */
            temp_val = soc_mem_field32_get(unit, MMU_THDO_QCONFIG_QENTRYm, 
                    &mmu_thdo_qconfig_qentry_entry, Q_SHARED_LIMIT_QENTRYf);
            soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                    &mmu_thdo_qoffset_qentry_entry, LIMIT_RED_QENTRYf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c ? 
                    ceil_func(temp_val, 8) : temp_val);

            /* C482: THDO_QOFFSET_QENTRY.RESET_OFFSET_YELLOW_QENTRY =1 */
            soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                    &mmu_thdo_qoffset_qentry_entry,RESET_OFFSET_YELLOW_QENTRYf,1); 
            /* C483: THDO_QOFFSET_QENTRY.RESET_OFFSET_RED_QENTRY =1 */
            soc_mem_field32_set(unit, MMU_THDO_QOFFSET_QENTRYm, 
                    &mmu_thdo_qoffset_qentry_entry, RESET_OFFSET_RED_QENTRYf,1); 

            SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_QOFFSET_QENTRYm(unit,
                        MEM_BLOCK_ALL,queue,
                        &mmu_thdo_qoffset_qentry_entry));
        }
    }
    /* 2.5 Redirect Port                */
    /* 2.5.1 RDEQ */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORDEQr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORDEQr(
                    unit, cos, &rval));
        /* C485:OP_QUEUE_CONFIG1_THDORDEQ.Q_MIN = 9 (C205) */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEQr, &rval,
                Q_MINf, 9);
        /* output_port_threshold->min_grntd_res_RE_WQs_cells); */

        /* C490:OP_QUEUE_CONFIG1_THDORDEQ.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEQr, &rval,
                Q_COLOR_ENABLEf, 0);

        /* C491:OP_QUEUE_CONFIG1_THDORDEQ.Q_COLOR_DYNAMIC = 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEQr, &rval,
                Q_COLOR_DYNAMICf, 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORDEQr(
                    unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORDEQr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEQr(
                    unit, cos, &rval));
        /* C486:OP_QUEUE_CONFIG_THDORDEQ.Q_SHARED_LIMIT = 7 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEQr, &rval,
                Q_SHARED_LIMITf, 7);

        /*C488: OP_QUEUE_CONFIG_THDORDEQ.Q_LIMIT_DYNAMIC:=1 */

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEQr, &rval,
                Q_LIMIT_DYNAMICf,1); 

        /*C489:OP_QUEUE_CONFIG_THDORDEQ.Q_LIMIT_ENABLE:=0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEQr, &rval,
                Q_LIMIT_ENABLEf, 0);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORDEQr(
                    unit, cos, rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORDEQr); cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_THDORDEQr(unit, cos,&rval));
        /*C487: OP_QUEUE_RESET_OFFSET_THDORDEQ.Q_RESET_OFFSET == 1 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORDEQr, &rval,
                Q_RESET_OFFSETf, 1);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_THDORDEQr(unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORDEQr(
                    unit, cos,&rval));
        /* C492: OP_QUEUE_LIMIT_YELLOW_THDORDEQ.Q_LIMIT_YELLOW = C486 ==>7 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEQr(
                    unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEQr, rval,
                Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEQr, &rval,
                Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORDEQr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORDEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORDEQr(
                    unit, cos,&rval));
        /* C493: OP_QUEUE_LIMIT_RED_THDORDEQ.Q_LIMIT_RED = C486 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEQr(
                    unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEQr, rval,
                Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORDEQr, &rval,
                Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORDEQr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr(unit, cos,&rval));
        /*C494:OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQ.RESUME_OFFSET_YELLOW=1*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr, &rval,
                RESUME_OFFSET_YELLOWf, 1);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEQr(unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORDEQr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_RED_THDORDEQr(unit, cos,&rval));
        /*C495:OP_QUEUE_RESET_OFFSET_RED_THDORDEQ.RESUME_OFFSET_RED=1*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_RED_THDORDEQr, &rval,
                RESUME_OFFSET_REDf, 1);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORDEQr(unit, cos,rval));
    }
    /* 2.5.2 RDEI */
    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORDEIr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORDEIr(
                    unit, cos, &rval));
        /* C496:OP_QUEUE_CONFIG1_THDORDEI.Q_MIN = 9 (C206) */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEIr, &rval, Q_MINf, 
                _soc_kt2_mmu_params.lossless_mode_d_c? 9 :
                output_port_threshold->min_grntd_res_RE_WQs_queue_cells_for_int_buff);

        /* C501:OP_QUEUE_CONFIG1_THDORDEI.Q_COLOR_ENABLE  = 0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEIr, &rval,
                Q_COLOR_ENABLEf, 0);

        /* C491:OP_QUEUE_CONFIG1_THDORDEI.Q_COLOR_DYNAMIC = 1*/
        soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEIr, &rval,
                Q_COLOR_DYNAMICf, 1);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORDEIr(
                    unit, cos, rval));
    }

    for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORDEIr); cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEIr(
                    unit, cos, &rval));
        /* C497:OP_QUEUE_CONFIG_THDORDEI.Q_SHARED_LIMIT = 7 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEIr, &rval,
                Q_SHARED_LIMITf, 7);

        /*C499: OP_QUEUE_CONFIG_THDORDEI.Q_LIMIT_DYNAMIC:=1 */

        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEIr, &rval,
                Q_LIMIT_DYNAMICf,1); 

        /*C500:OP_QUEUE_CONFIG_THDORDEI.Q_LIMIT_ENABLE:=0 */
        soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEIr, &rval,
                Q_LIMIT_ENABLEf, 0);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORDEIr(
                    unit, cos, rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORDEIr); cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_THDORDEIr(unit, cos,&rval));
        /*C498: OP_QUEUE_RESET_OFFSET_THDORDEI.Q_RESET_OFFSET == 2 */
        soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORDEIr, &rval,
                Q_RESET_OFFSETf, 2);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_THDORDEIr(unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORDEIr(
                    unit, cos,&rval));
        /* C503: OP_QUEUE_LIMIT_YELLOW_THDORDEI.Q_LIMIT_YELLOW = C497 ==>7 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEIr(
                    unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEIr, rval,
                Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEIr, &rval,
                Q_LIMIT_YELLOWf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORDEIr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORDEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORDEIr(
                    unit, cos,&rval));
        /* C504: OP_QUEUE_LIMIT_RED_THDORDEI.Q_LIMIT_RED = C497 */
        SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEIr(
                    unit, cos, &rval));
        temp_val = soc_reg_field_get(unit, OP_QUEUE_CONFIG_THDORDEIr, rval,
                Q_SHARED_LIMITf);

        soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORDEIr, &rval,
                Q_LIMIT_REDf, temp_val);
        SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORDEIr(
                    unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr(unit, cos,&rval));
        /*C505:OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEI.RESUME_OFFSET_YELLOW=2*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr, &rval,
                RESUME_OFFSET_YELLOWf, 2);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEIr(unit, cos,rval));
    }
    for(cos=0; 
            cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORDEIr); 
            cos++) {
        SOC_IF_ERROR_RETURN(
                READ_OP_QUEUE_RESET_OFFSET_RED_THDORDEIr(unit, cos,&rval));
        /*C506:OP_QUEUE_RESET_OFFSET_RED_THDORDEI.RESUME_OFFSET_RED=2*/
        soc_reg_field_set(unit,
                OP_QUEUE_RESET_OFFSET_RED_THDORDEIr, &rval,
                RESUME_OFFSET_REDf, 2);
        SOC_IF_ERROR_RETURN(
                WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORDEIr(unit, cos,rval));
    }

    /* 2.5.2 RDEE */
    if ((ext_mem_port_count) || (_soc_kt2_mmu_params.packing_mode_d_c)) {
        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG1_THDORDEEr); cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG1_THDORDEEr(
                        unit, cos, &rval));
            /* C507:OP_QUEUE_CONFIG1_THDORDEE.Q_MIN =  lossless=9 lossy:C485*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEEr, &rval, Q_MINf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 9 :
                    output_port_threshold->min_grntd_res_RE_WQs_cells);

            /* C512:OP_QUEUE_CONFIG1_THDORDEE.Q_COLOR_ENABLE  = 0 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEEr, &rval,
                    Q_COLOR_ENABLEf, 0);

            /* C513:OP_QUEUE_CONFIG1_THDORDEE.Q_COLOR_DYNAMIC = 1*/
            soc_reg_field_set(unit, OP_QUEUE_CONFIG1_THDORDEEr, &rval,
                    Q_COLOR_DYNAMICf, 1);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG1_THDORDEEr(
                        unit, cos, rval));
        }

        for(cos=0; cos<SOC_REG_NUMELS(unit, OP_QUEUE_CONFIG_THDORDEEr); cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_CONFIG_THDORDEEr(
                        unit, cos, &rval));
            /* C508:OP_QUEUE_CONFIG_THDORDEE.Q_SHARED_LIMIT = 7 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEEr, &rval,
                    Q_SHARED_LIMITf, 7);

            /*C510: OP_QUEUE_CONFIG_THDORDEE.Q_LIMIT_DYNAMIC:=1 */

            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEEr, &rval,
                    Q_LIMIT_DYNAMICf,1); 

            /*C511:OP_QUEUE_CONFIG_THDORDEE.Q_LIMIT_ENABLE:=0 */
            soc_reg_field_set(unit, OP_QUEUE_CONFIG_THDORDEEr, &rval,
                    Q_LIMIT_ENABLEf, 0);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_CONFIG_THDORDEEr(
                        unit, cos, rval));
        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_THDORDEEr); cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_THDORDEEr(unit, cos,&rval));
            /*C509:OP_QUEUE_RESET_OFFSET_THDORDEE.Q_RESET_OFFSETlossless=2 else 1 */
            soc_reg_field_set(unit, OP_QUEUE_RESET_OFFSET_THDORDEEr, &rval,
                    Q_RESET_OFFSETf, 
                    _soc_kt2_mmu_params.lossless_mode_d_c? 2 : 1);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_THDORDEEr(unit, cos,rval));
        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_YELLOW_THDORDEEr(
                        unit, cos,&rval));
            /* C514: OP_QUEUE_LIMIT_YELLOW_THDORDEE.Q_LIMIT_YELLOW = 7 */

            soc_reg_field_set(unit, OP_QUEUE_LIMIT_YELLOW_THDORDEEr, &rval,
                    Q_LIMIT_YELLOWf, 7);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_YELLOW_THDORDEEr(
                        unit, cos,rval));
        }
        for(cos=0; 
                cos<SOC_REG_NUMELS(unit, OP_QUEUE_LIMIT_RED_THDORDEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(READ_OP_QUEUE_LIMIT_RED_THDORDEEr(
                        unit, cos,&rval));
            /* C515: OP_QUEUE_LIMIT_RED_THDORDEE.Q_LIMIT_RED = 7 */
            soc_reg_field_set(unit, OP_QUEUE_LIMIT_RED_THDORDEEr, &rval,
                    Q_LIMIT_REDf, 7);
            SOC_IF_ERROR_RETURN(WRITE_OP_QUEUE_LIMIT_RED_THDORDEEr(
                        unit, cos,rval));
        }
        for(cos=0; 
                cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr(unit, cos,&rval));
            /*C516:OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEE.RESUME_OFFSET_YELLOW=2*/
            soc_reg_field_set(unit,
                    OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr, &rval,
                    RESUME_OFFSET_YELLOWf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_YELLOW_THDORDEEr(unit, cos,rval));
        }
        for(cos=0; 
                cos < SOC_REG_NUMELS(unit, OP_QUEUE_RESET_OFFSET_RED_THDORDEEr); 
                cos++) {
            SOC_IF_ERROR_RETURN(
                    READ_OP_QUEUE_RESET_OFFSET_RED_THDORDEEr(unit, cos,&rval));
            /*C517:OP_QUEUE_RESET_OFFSET_RED_THDORDEE.RESUME_OFFSET_RED=2*/
            soc_reg_field_set(unit,
                    OP_QUEUE_RESET_OFFSET_RED_THDORDEEr, &rval,
                    RESUME_OFFSET_REDf, 2);
            SOC_IF_ERROR_RETURN(
                    WRITE_OP_QUEUE_RESET_OFFSET_RED_THDORDEEr(unit, cos,rval));
        }
    }
    /* Enable back pressure status from MMU for lossless mode */
    if (_soc_kt2_mmu_params.lossless_mode_d_c) {
        COMPILER_64_SET(val64, 0x3ff, 0xfffffffe); /* 0 to 41 ports */
        COMPILER_64_ZERO(r64val);
        soc_reg64_field_set(unit, THDIEXT_PORT_PAUSE_ENABLE_64r, &r64val,
                PORT_PAUSE_ENABLEf, val64);
        SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PAUSE_ENABLE_64r(
                    unit, r64val));

        COMPILER_64_ZERO(r64val);
        soc_reg64_field_set(unit, THDIQEN_PORT_PAUSE_ENABLE_64r, &r64val,
                PORT_PAUSE_ENABLEf, val64);
        SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PAUSE_ENABLE_64r(unit, r64val));

        COMPILER_64_ZERO(r64val);
        soc_reg64_field_set(unit, THDIRQE_PORT_PAUSE_ENABLE_64r, &r64val,
                PORT_PAUSE_ENABLEf, val64);
        SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PAUSE_ENABLE_64r(unit, r64val));

        COMPILER_64_ZERO(r64val);
        soc_reg64_field_set(unit, THDIEMA_PORT_PAUSE_ENABLE_64r, &r64val,
                PORT_PAUSE_ENABLEf, val64);
        SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PAUSE_ENABLE_64r(unit, r64val));

        COMPILER_64_ZERO(r64val);
        soc_reg64_field_set(unit, PORT_PAUSE_ENABLE_64r, &r64val,
                PORT_PAUSE_ENABLEf, val64);
        SOC_IF_ERROR_RETURN(WRITE_PORT_PAUSE_ENABLE_64r(unit, r64val));
    }

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
    /* OpNode related config for remaining OpNodes                 */
    /* (assuming internal memory settings)                         */
    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
    for (op_node = soc_mem_index_min(unit,MMU_THDO_OPNCONFIG_CELLm);
            op_node <= soc_mem_index_max(unit,MMU_THDO_OPNCONFIG_CELLm);
            op_node++) {
        temp_val = 0 ; /* Not required but */
        SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                    MEM_BLOCK_ANY,op_node ,
                    &mmu_thdo_opnconfig_cell_entry));
        temp_val = soc_mem_field32_get(unit, MMU_THDO_OPNCONFIG_CELLm,
                &mmu_thdo_opnconfig_cell_entry,
                OPN_SHARED_LIMIT_CELLf);
        if (temp_val == 0) {
            /* Empty Entry */
            /* C394:THDO_OPNCONFIG_CELL.OPN_SHARED_LIMIT_CELL = =$C$219 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                    &mmu_thdo_opnconfig_cell_entry,
                    OPN_SHARED_LIMIT_CELLf,
                    output_port_threshold->
                    min_grntd_tot_shr_queue_cells_int_buff);
            /* C395:THDO_OPNCONFIG_CELL.OP_SHARED_RESET_VALUE_CELL
               = C394-2*$C$72 */
            temp_val = output_port_threshold->
                min_grntd_tot_shr_queue_cells_int_buff -
                (2 * general_info->ether_mtu_cells_for_int_buff);
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                    &mmu_thdo_opnconfig_cell_entry,
                    OPN_SHARED_RESET_VALUE_CELLf, temp_val);
            /* C396:THDO_OPNCONFIG_CELL.PORT_LIMIT_ENABLE_CELL
               = 0 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                    &mmu_thdo_opnconfig_cell_entry,
                    PORT_LIMIT_ENABLE_CELLf, 0);
            /*
               soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
               &mmu_thdo_opnconfig_cell_entry,
               PIDf, port);
             */
            SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                        MEM_BLOCK_ALL,op_node,
                        &mmu_thdo_opnconfig_cell_entry));
        }
    }
    for (op_node = soc_mem_index_min(unit,MMU_THDO_OPNCONFIG_QENTRYm);
            op_node <= soc_mem_index_max(unit,MMU_THDO_OPNCONFIG_QENTRYm);
            op_node++) {
        temp_val = 0 ; /* Not required but */
        SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_QENTRYm(unit,
                    MEM_BLOCK_ANY,op_node ,
                    &mmu_thdo_opnconfig_qentry_entry));
        /* C470:THDO_OPNCONFIG_QENTRY.OPN_SHARED_LIMIT_QENTRY = =$C$221 */
        temp_val = soc_mem_field32_get(unit, MMU_THDO_OPNCONFIG_QENTRYm,
                &mmu_thdo_opnconfig_qentry_entry, 
                OPN_SHARED_LIMIT_QENTRYf);
        if (temp_val == 0) {
            /* Empty Entry */
            /* C470:THDO_OPNCONFIG_QENTRY.OPN_SHARED_LIMIT_QENTRY = =$C$221 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm,
                    &mmu_thdo_opnconfig_qentry_entry, OPN_SHARED_LIMIT_QENTRYf,
                    output_port_threshold->min_grntd_tot_shr_queue_cells_EQEs);

            /* C471:THDO_OPNCONFIG_QENTRY.OP_SHARED_RESET_VALUE_QENTRY
               = =$C$470 -2 */
            temp_val = output_port_threshold->
                min_grntd_tot_shr_queue_cells_EQEs - 2;
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm,
                    &mmu_thdo_opnconfig_qentry_entry,
                    OPN_SHARED_RESET_VALUE_QENTRYf, temp_val);

            /* C472:THDO_OPNCONFIG_QENTRY.PORT_LIMIT_ENABLE_QENTRY
               = 0 */
            soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm,
                    &mmu_thdo_opnconfig_qentry_entry,
                    PORT_LIMIT_ENABLE_QENTRYf, 0);
            /*
               soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_QENTRYm,
               &mmu_thdo_opnconfig_qentry_entry,
               PIDf, port);
             */
            SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_QENTRYm(unit,
                        MEM_BLOCK_ALL,op_node ,
                        &mmu_thdo_opnconfig_qentry_entry));
        }
    }
    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
    /* Subport queue Settings                                      */
    /* (Assuming lossless-internal memory operation)               */
    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
    for (sub_port = SOC_KT2_MIN_SUBPORT_INDEX;
            sub_port <= SOC_KT2_MAX_SUBPORT_INDEX;
            sub_port ++) {
        if ( si->port_uc_cosq_base[sub_port]  != 0) {
            for (queue =  si->port_uc_cosq_base[sub_port];
                    queue <  si->port_uc_cosq_base[sub_port] +
                    si->port_num_uc_cosq[sub_port];
                    queue++) {
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "sub_port:%d queue:%d"), sub_port, queue));
                SOC_IF_ERROR_RETURN(_soc_katana2_mmu_config_extra_queue(
                            unit, queue));
            }
        }
    }
    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
    /* Extended Queue(BCM_COSQ_GPORT_SUBSCRIBE) Settings           */
    /* (Assuming lossless-internal memory operation)               */
    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
    if (flex_port == -1) {
        min =  si->port_uc_cosq_base[KT2_MAX_PHYSICAL_PORTS] +
               si->port_num_uc_cosq[KT2_MAX_PHYSICAL_PORTS];
        max = soc_mem_index_max(unit,MMU_THDO_QCONFIG_CELLm);
    } else {
        min =  si->port_uc_cosq_base[flex_port];
        max =  si->port_uc_cosq_base[flex_port] +
               si->port_num_uc_cosq[flex_port];
    }
    for (queue = min; queue <= max; queue++) {
        SOC_IF_ERROR_RETURN(_soc_katana2_mmu_config_extra_queue(unit, queue));
    }
    soc_mmu_cfg_free(unit, buf);

    return SOC_E_NONE;
}


static 
void soc_katana2_save_tdm_pos(int unit, uint8 new_tdm_size,uint32 *new_tdm);
void kt2_tdm_replace(uint32 *tdm, uint32 total_tdm_slots,
                     uint32  src, uint32 dst,uint32 one_time)
{
     uint32 index=0;
     for (index=0; index < total_tdm_slots ; index++ ) {
          if (tdm[index] == src) {
              tdm[index] = dst;
              if (one_time) {
                  break;
              }
          }
     }
}

void kt2_tdm_swap(uint32 *tdm, uint32 total_tdm_slots,
                  uint32  src, uint32 dst)
{
     uint32 index=0;
     uint32 temp_index=0;
     uint32 temp=0;
     for (index=0; index < total_tdm_slots ; index++ ) {
          if (tdm[index] == src) {
              temp_index=index;
          }
          if (tdm[index] == dst) {
              temp = tdm[temp_index];
              tdm[temp_index]=dst;
              tdm[index]=temp;
          }
     }
}

int
soc_katana2_pipe_mem_clear(int unit)
{
    uint32              rval;
    int                 index, pipe_init_usec;
    soc_timeout_t       to;
    
    static const soc_mem_t cam[] = {
        MY_STATION_TCAMm,
        L2_USER_ENTRYm,
        VLAN_SUBNETm,
        L3_DEFIP_PAIR_128m,
        L3_DEFIPm,
        CPU_COS_MAPm,
        EFP_TCAMm,
        FP_TCAMm,
        VFP_TCAMm,
        FP_UDF_TCAMm,
        SUBPORT_TAG_TO_PP_PORT_MAPm,
        L3_TUNNELm,
        FP_GLOBAL_MASK_TCAMm,
    };
    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries in largest IPIPE table (L2X) */
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, 32768);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r (unit, &rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
        if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : ING_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);

    /* Wait for EPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
        if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : EGR_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);

    SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 0);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, CMIC_REQ_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 0);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));
    
    for (index = 0; index < COUNTOF(cam); index++) {
        SOC_IF_ERROR_RETURN(soc_mem_clear(unit, cam[index], COPYNO_ALL, TRUE));
    }
    return SOC_E_NONE;
}

int soc_katana2_linkphy_mem_clear(int unit)
{
    uint32 rval;
    int try_count = 0;
    int port = 1;
    int id;
    int block_idx;

    soc_mem_t mem[32] = {
        RXLP_INTERNAL_STREAM_MAP_PORT_0m,
        RXLP_INTERNAL_STREAM_MAP_PORT_1m,
        RXLP_INTERNAL_STREAM_MAP_PORT_2m,
        RXLP_INTERNAL_STREAM_MAP_PORT_3m,
        TXLP_PORT_STREAM_BITMAP_TABLEm,
        TXLP_INT2EXT_STREAM_MAP_TABLEm,
        DEVICE_STREAM_ID_TO_PP_PORT_MAPm,
        PP_PORT_TO_PHYSICAL_PORT_MAPm,
        TXLP_DEBUG_COUNTER0m,
        TXLP_DEBUG_COUNTER1m,
        TXLP_DEBUG_COUNTER2m,
        TXLP_DEBUG_COUNTER3m,
        TXLP_DEBUG_COUNTER4m,
        TXLP_DEBUG_COUNTER5m,
        TXLP_DEBUG_COUNTER6m,
        TXLP_DEBUG_COUNTER7m,
        TXLP_DEBUG_COUNTER8m,
        TXLP_DEBUG_COUNTER9m,
        TXLP_DEBUG_COUNTER10m,
        TXLP_DEBUG_COUNTER11m,
        RXLP_DEBUG_COUNTER0m,
        RXLP_DEBUG_COUNTER1m,
        RXLP_DEBUG_COUNTER2m,
        RXLP_DEBUG_COUNTER3m,
        RXLP_DEBUG_COUNTER4m,
        RXLP_DEBUG_COUNTER5m,
        RXLP_DEBUG_COUNTER6m,
        RXLP_DEBUG_COUNTER7m,
        RXLP_DEBUG_COUNTER8m,
        RXLP_DEBUG_COUNTER9m,
        RXLP_DEBUG_COUNTER10m,
        RXLP_DEBUG_COUNTER11m};
  
    SOC_BLOCK_ITER(unit, block_idx, SOC_BLK_RXLP) {
        port = SOC_BLOCK_PORT(unit, block_idx);
        
        SOC_IF_ERROR_RETURN(READ_RXLP_HW_RESET_CONTROLr(unit, port, &rval));
        soc_reg_field_set(unit, RXLP_HW_RESET_CONTROLr, &rval, VALIDf, 1);
        soc_reg_field_set(unit, RXLP_HW_RESET_CONTROLr, &rval, START_ADDRESSf, 0);
        soc_reg_field_set(unit, RXLP_HW_RESET_CONTROLr, &rval, COUNTf, 0x7D0);
        SOC_IF_ERROR_RETURN(WRITE_RXLP_HW_RESET_CONTROLr(unit, port, rval));

        if((SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM || SAL_BOOT_XGSSIM)) {
            SOC_IF_ERROR_RETURN(READ_RXLP_HW_RESET_CONTROLr(unit, port, &rval));
            soc_reg_field_set(unit, RXLP_HW_RESET_CONTROLr, &rval, DONEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_RXLP_HW_RESET_CONTROLr(unit, port, rval));
        }

        /* Now wait for HW to set DONEf */
        do {
            SOC_IF_ERROR_RETURN(READ_RXLP_HW_RESET_CONTROLr(unit, port, &rval));
            if (soc_reg_field_get(unit, RXLP_HW_RESET_CONTROLr, rval, DONEf) == 1) {
                break;
            }
            sal_usleep(1000);
            try_count++;
        } while(try_count < 3);

        if (try_count == 3) {
            LOG_ERROR(BSL_LS_SOC_COMMON, (BSL_META_U(unit, "RXLP HW RESET Failed\n")));
            return SOC_E_TIMEOUT;
        }
    } 

    SOC_BLOCK_ITER(unit, block_idx, SOC_BLK_TXLP) {
        port = SOC_BLOCK_PORT(unit, block_idx);
        SOC_IF_ERROR_RETURN(READ_TXLP_HW_RESET_CONTROL_1r(unit, port, &rval));
        soc_reg_field_set(unit, TXLP_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
        soc_reg_field_set(unit, TXLP_HW_RESET_CONTROL_1r, &rval, COUNTf, 0x84);
        soc_reg_field_set(unit, TXLP_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 0x1);
        SOC_IF_ERROR_RETURN(WRITE_TXLP_HW_RESET_CONTROL_1r(unit, port, rval));

        if((SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM || SAL_BOOT_XGSSIM)) {
            SOC_IF_ERROR_RETURN(READ_TXLP_HW_RESET_CONTROL_1r(unit, port, &rval));
            soc_reg_field_set(unit, TXLP_HW_RESET_CONTROL_1r, &rval, DONEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TXLP_HW_RESET_CONTROL_1r(unit, port, rval));
        }

        /* Now wait for HW to set DONEf */
        try_count = 0;
        do {
            SOC_IF_ERROR_RETURN(READ_TXLP_HW_RESET_CONTROL_1r(unit, port, &rval));
            if (soc_reg_field_get(unit, TXLP_HW_RESET_CONTROL_1r, rval, DONEf) == 1) {
                break;
            }
            sal_usleep(1000);
            try_count++;
        } while(try_count < 3);

        if (try_count == 3) {
            LOG_ERROR(BSL_LS_SOC_COMMON, (BSL_META_U(unit, "TXLP HW RESET Failed\n")));
            return SOC_E_TIMEOUT;
        }
    }

    for (id = 0; id < 32; id++) {
        SOC_IF_ERROR_RETURN(soc_mem_clear(unit, mem[id], COPYNO_ALL, TRUE));
    }

    return SOC_E_NONE;
}
soc_error_t kt2_tdm_verify(int unit,
                           uint32 *tdm,
                           uint32 total_tdm_slots,
                           uint32 tdm_freq,    /* In MHHz */
                           uint32 *port_speed,
                           uint32 olp_port_flag,  
                           uint32 *offender_port)
{
    /* Following rules need to be met */
    /* Rule1 : Each Loopback port need 2.5G bandwidth */
    /* Rule2 : Each CMIC port need 2G bandwidth       */
    /* Rule3 : Loopback (LPBK) ports require min 3 cycle spacing among LPBK or 
               CMIC ports */ 
    /* Rule4 : Each subport in MXQPORT operates with 4 cycle TDM */
    /* Rule5 : Each 10G-XAUI ports should be able to operate in 4x2.5G with 4 
               slots allocated to each subport from the same MXQPORT */
    soc_error_t           rv=SOC_E_NONE;
    uint32                index=0;
    uint32                expected_tdm_cycles_min=0;
    uint32                expected_tdm_cycles_max=0;
    uint32                tdm_freq_index=0;
    uint32                speed_index=0;
    uint32                port=0;
    uint32                speed=0;
    uint32                worse_tdm_slot_spacing=0;
    uint32                prev_tdm_slot_spacing=0;
    uint32                next_tdm_slot_spacing=0;
    uint32                tdm_slot_spacing=0;
    uint32                min_tdm_cycles=0; /* To Meet BW */
    uint32                count=0; 
    uint32                skip_count=0; 
    uint32                mxqblock=0;
    uint32                outer_port=0;
    uint32                inner_port=0;
    uint32                spacing=0;
    uint32                loop=0;
    tdm_port_slots_info_t *head=NULL;
    tdm_port_slots_info_t *head1=NULL;
    tdm_port_slots_info_t *current=NULL;
    tdm_port_slots_info_t *current1=NULL;
    tdm_port_slots_info_t *prev = NULL;
    tdm_port_slots_info_t *temp=NULL;
    uint32                idle_flag=0;
    uint32                idle_rule=0;
    int                   cfg_num = -1;


   /* Possible TDM frequencies 
      80MHz(16Cycles) ,120MHz(20Cycles),155MHz(84Cycles),
      185MHz(80Cycles),185MHz(90Cycles) 
    */
    switch(tdm_freq) {
    case 123:
        tdm_freq_index=1;
        expected_tdm_cycles_min=40;
        expected_tdm_cycles_max=40;
        break;
    case 155:
        tdm_freq_index=2;
        expected_tdm_cycles_min=84;
        expected_tdm_cycles_max=168;
        break;
    case 176:
        expected_tdm_cycles_min=60;
        expected_tdm_cycles_max=90;
        if (total_tdm_slots == 64) {
            tdm_freq_index=7; 
        }
        if (total_tdm_slots == 90) {
            tdm_freq_index=4; 
        }
        if (total_tdm_slots == 60) {
            tdm_freq_index=3; 
        }
        if (total_tdm_slots == 72) {
            tdm_freq_index=2; 
        }

        /*
         * Index to be used in kt2_tdm_cycles_info
         * for TDM slots spacing information.
         */
        if (total_tdm_slots == BCM_KT2_TDM_A1_NUM_SLOTS) {
            tdm_freq_index = 9;
        }
        break;
    case 205:
        expected_tdm_cycles_min=88;
        expected_tdm_cycles_max=216;
        if (total_tdm_slots == 108 ) {
            tdm_freq_index=5;
        }
        if (total_tdm_slots == 88 ) {
            cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG,0xFF);
            if (cfg_num == 15) {
                tdm_freq_index=10;
            } else {
                tdm_freq_index=6;
            }
        }
        if (total_tdm_slots == 216 ) {
            tdm_freq_index=0;
        }

        /*
         * Index to be used in kt2_tdm_cycles_info
         * for TDM slots spacing information.
         */
        if (total_tdm_slots == BCM_KT2_TDM_A1_NUM_SLOTS ) {
            tdm_freq_index = 9;
        }
        break;
    case 166:
        tdm_freq_index=8;
        expected_tdm_cycles_min=84;
        expected_tdm_cycles_max=84;
        break;
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Unsupported tdm frequency:%d\n"),
                   tdm_freq));
        return SOC_E_FAIL;
    }
   if (!((total_tdm_slots >= expected_tdm_cycles_min) && 
         (total_tdm_slots <= expected_tdm_cycles_max))) {
          LOG_ERROR(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Unsupported tdm cycles:%d (min:%d max:%d\n"),
                     total_tdm_slots,
                     expected_tdm_cycles_min,expected_tdm_cycles_max));
          return SOC_E_FAIL; 
   }

    idle_flag=0;
    idle_rule = 0;
    /* Initialize list */
    for (port=0;port < KT2_MAX_LOGICAL_PORTS ; port++) {
         kt2_tdm_port_slots_info[port].prev=&kt2_tdm_port_slots_info[port];
         kt2_tdm_port_slots_info[port].next=&kt2_tdm_port_slots_info[port];
         kt2_tdm_port_slots_info[port].position = -1;
    }
    for (index=0; index < total_tdm_slots; index++) {
         if ((tdm[index] == KT2_IDLE1) ||
             (tdm[index] == KT2_IDLE)) {
             if (tdm[index] == KT2_IDLE1) {
                 if (idle_flag == 1) {
                     idle_rule = 1;
                 }
                 idle_flag=1;
             }
             skip_count++;
             continue;
         }
         if (((index - 1) != 0) && (index != total_tdm_slots - 1) && 
             (idle_flag == 1) && (idle_rule == 0)) {
              LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                          "### Internal Error: TDM Verification failed \n"
                          "### Two consecutive idle not found at position:%d\n"
                          "### TCAM Atomicity might get affected.\n"),
                          index - 1));
             *offender_port = KT2_IDLE1;
             return SOC_E_CONFIG;
         }
         idle_flag=0;
         port = tdm[index];
         if (kt2_tdm_port_slots_info[port].position == -1) {
             /* First Entry */
             kt2_tdm_port_slots_info[port].position = index;
             skip_count++;
             continue;
         }
         head = current = &kt2_tdm_port_slots_info[port];
         while(current->next !=head) {
               current = current->next;
         } 
         current->next=sal_alloc(sizeof(tdm_port_slots_info_t),"TDM Pointer");
         count++;
         LOG_VERBOSE(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "Count=%d SkipCount:%d  Port:%d  Addr:%p\n"),
                      count,skip_count,port,(void *)current->next));

         current->next->position=index;
         current->next->prev=current;
         current->next->next=head;
         head->prev=current->next;
   }
   if (idle_rule == 0) {
       /* Special case */
       if (!((tdm[0] == KT2_IDLE1) &&
             (tdm[total_tdm_slots-1] == KT2_IDLE1))) {
              LOG_ERROR(BSL_LS_SOC_COMMON,
                       (BSL_META_U(unit,
                       "### Internal Error: TDM Verification failed \n"
                       "### Two consecutive idle not found at Edges \n"
                       "### TCAM Atomicity might get affected.\n")));
           *offender_port = KT2_IDLE1;
           return SOC_E_CONFIG;
       }
   }
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Final Count=%d SkipCount:%d\n"),count,skip_count));
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Verifying rule  \n")));
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Rule3: Loopback (LPBK) ports require min 3 cycle spacing "
                           "among LPBK or CMIC ports \n")));
   if (kt2_tdm_port_slots_info[KT2_LPBK_PORT].position == -1) {
       LOG_CLI((BSL_META_U(unit,
                           "Loopback port  missing in configuration \n")));
       return SOC_E_FAIL;
   }
   if (kt2_tdm_port_slots_info[KT2_CMIC_PORT].position == -1) {
       LOG_CLI((BSL_META_U(unit,
                           "CMIC port  missing in configuration \n")));
       return SOC_E_FAIL;
   }
   if (olp_port_flag) {
       if (kt2_tdm_port_slots_info[KT2_OLP_PORT].position == -1) {
           LOG_CLI((BSL_META_U(unit,
                               "OLP port  missing in configuration \n")));
           return SOC_E_FAIL;
       }
   }
   head = current = &kt2_tdm_port_slots_info[KT2_LPBK_PORT];
   do {
      prev = current->prev;
      if ( current->position != prev->position ) {
           prev_tdm_slot_spacing = 
                          (current->position - prev->position) > 0 ?
                          (current->position - prev->position)-1:
                          (total_tdm_slots - prev->position + 
                           current->position) - 1;
           next_tdm_slot_spacing = 
                          (current->next->position - current->position) >0 ?
                          (current->next->position - current->position)-1:
                          (total_tdm_slots - current->position +
                           current->next->position) - 1;
      if (prev_tdm_slot_spacing <= 3) {
          LOG_ERROR(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Loopback Ports need min 3 spacing but(prev)found"
                                "(current:%d , prev:%d)=%d\n"),
                     current->position,prev->position,prev_tdm_slot_spacing));
          rv = SOC_E_FAIL;
          continue;
      } 
      if (next_tdm_slot_spacing < 3) {
          LOG_ERROR(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "Loopback Ports need min 3 spacing but(next)found"
                                "(current:%d , prev:%d)=%d\n"),
                     current->position,prev->position,next_tdm_slot_spacing));
          rv = SOC_E_CONFIG;
          *offender_port = KT2_LPBK_PORT;
          continue;
      } 
      } else {
          prev_tdm_slot_spacing = next_tdm_slot_spacing = 0;
      }
      head1 = current1 = &kt2_tdm_port_slots_info[KT2_CMIC_PORT];
      do {
         tdm_slot_spacing = (current->position - current1->position) > 0 ?
                          (current->position - current1->position)-1:
                          (total_tdm_slots - current1->position + 
                           current->position) - 1  ;
         if (tdm_slot_spacing < 3) {
             LOG_ERROR(BSL_LS_SOC_COMMON,
                       (BSL_META_U(unit,
                                   "Loopback and CMIC ports need min 3 spacing but "
                                   "found:%u" "(Loopack current:%d , CMIC Current:%d)\n"),
                        tdm_slot_spacing,
                        current->position,current1->position));
             rv = SOC_E_CONFIG;
             *offender_port=KT2_LPBK_PORT;
             continue;
         }
         current1 = current1->next;
      }while ((current1 !=head1) && (rv == SOC_E_NONE));
      current = current->next;
   } while ((current !=head) && (rv == SOC_E_NONE));
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Verifying rules \n")));
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Rule1 : Each Loopback port need 2.5G bandwidth \n")));
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Rule2 : Each CMIC port need 2G bandwidth       \n")));
   for (index=0;index < KT2_MAX_LOGICAL_PORTS && rv == SOC_E_NONE ;index++ ) {
        port = index ;
        if (kt2_tdm_port_slots_info[port].position == -1) {
            continue;
        }
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                " %d ==>\n\n"),port));
        switch(port) {
        case KT2_CMIC_PORT:
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "CMIM \n")));
            speed =2000; 
            break;
        case KT2_LPBK_PORT:
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "LOOPBAKC \n")));
            speed =2500; 
            break;
        default:
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    " Port:%d Speed %d ==>\n\n"),
                         port,port_speed[port-1]));
            speed = port_speed[port-1];
            break;
        }
        switch(speed) {
        case 1000:
            speed_index=0;
            break;
        case 2000:
            speed_index=1;
            break;
        case 2500:
            speed_index=2;
            break;
        case 10000:
            speed_index=3;
            break;
        case 13000:
            speed_index=4;
            break;
        case 20000:
            speed_index=5;
            break;
        case 21000:
            speed_index=6;
            break;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Unsupported speed:%d \n"),speed));
            return SOC_E_FAIL;
        }
        worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                               worse_tdm_slot_spacing;
        min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                       min_tdm_cycles;

        count=0;
        head = current = &kt2_tdm_port_slots_info[port];
        do {
           prev = current->prev;
           if (current->position != prev->position ) {
               prev_tdm_slot_spacing = 
                          (current->position - prev->position)> 0 ?
                          (current->position - prev->position)-1:
                          (total_tdm_slots - prev->position + 
                           current->position) - 1  ;
               next_tdm_slot_spacing = 
                          (current->next->position - current->position) > 0 ?
                          (current->next->position - current->position)-1:
                          (total_tdm_slots - current->position + 
                           current->next->position) - 1;
           } else {
               prev_tdm_slot_spacing = next_tdm_slot_spacing = 0;
           }
           LOG_VERBOSE(BSL_LS_SOC_COMMON,
                       (BSL_META_U(unit,
                                   "Pos:%d Spacing (Prev %d - %d =  )%d"
                                   "(Next %d - %d =  )%d\n"), current->position,
                        current->position , prev->position ,
                        prev_tdm_slot_spacing, current->next->position , 
                        current->position , next_tdm_slot_spacing));
           if ((prev_tdm_slot_spacing > worse_tdm_slot_spacing) ||
               (next_tdm_slot_spacing > worse_tdm_slot_spacing)) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "WorseSpacing:%d NOK !!!! port:%d\n"),
                           worse_tdm_slot_spacing,port));
                rv = SOC_E_CONFIG;
                *offender_port=port;
                continue;
           }
           count++;
           current = current->next;
        } while ((current !=head) && (rv == SOC_E_NONE)) ;
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "TDM Cycles: %d \n"),count));
        if (count < min_tdm_cycles) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "min_tdm_cycles:%dNOK  !!!! port:%d\n"),
                       min_tdm_cycles,port));
            rv =  SOC_E_CONFIG;
            *offender_port=port;
            continue;
        }
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "n== %d <==\n\n"),port));
   }

   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Verifying rule  \n")));
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Rule4 : Each subport in MXQPORT operates with 4 cycle TDM \n")));
   LOG_VERBOSE(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
                           "Verifying MXQports spacing concern\n")));
   for(mxqblock=0;mxqblock<(KT2_MAX_MXQBLOCKS-1) && rv == SOC_E_NONE ;mxqblock++) {
       for(index=0;
           index<KT2_MAX_MXQPORTS_PER_BLOCK && rv == SOC_E_NONE;
           index++) {
           outer_port = (*kt2_mxqblock_ports[unit])[mxqblock][index];
           if (outer_port == 0xFF) {
               if ((mxqblock == 7)  && (index == 3)) {
                    outer_port = 40;
               } else {
                   continue;
               }
           }
#if 0
           /* Ignore MXQSpacing issue for OLP Port */
           if ((outer_port == KT2_OLP_PORT) && (olp_port_flag)) {
                continue;
           }
#endif
           if (kt2_tdm_port_slots_info[outer_port].position == -1) {
               continue;
           }
           head = current = &kt2_tdm_port_slots_info[outer_port];
           do {
              for(loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
                  inner_port=(*kt2_mxqblock_ports[unit])[mxqblock][loop];
                  if (inner_port == 0xFF) {
                      if ((mxqblock == 7)  && (loop == 3)) {
                           inner_port = 40;
                      } else {
                          continue;
                      }
                  }
#if 0
                  /* Ignore MXQSpacing issue for OLP Port */
                  if ((inner_port == KT2_OLP_PORT) && (olp_port_flag)) {
                       continue;
                  }
#endif
                  if ( inner_port == outer_port) {
                       continue;
                  }
                  if (kt2_tdm_port_slots_info[inner_port].position == -1) {
                      continue;
                  }
                  head1 = current1 = &kt2_tdm_port_slots_info[inner_port];
                  do {
                       spacing = (current->position - current1->position) > 0 ?
                                 (current->position - current1->position)-1:
                                 (total_tdm_slots - current1->position +
                                  current->position) - 1;
                       if (spacing < 3) {
                           LOG_ERROR(BSL_LS_SOC_COMMON,
                                     (BSL_META_U(unit,
                                                 "Outer Port:%d Inner Port:%d "
                                                 "MXQSpacing Issue"
                                                 "Expected > 4 but observed %d\n"),
                                      outer_port,inner_port,spacing));
                           rv = SOC_E_CONFIG;
                           *offender_port=outer_port;
                           continue;
                       }
                       current1 = current1->next;
                  } while ((current1 !=head1) && (rv == SOC_E_NONE));
              }
              current = current->next;
         } while ((current !=head) && (rv == SOC_E_NONE));
      }
  }

  /* Free allocated resources */
  count=0;
  for (port=0;port < KT2_MAX_LOGICAL_PORTS ; port++) {
       head = current = &kt2_tdm_port_slots_info[port];
       do {
          temp = current->next;
          if (current != head) {
              count++;
              LOG_VERBOSE(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "Freed count :%d\n"),count));
              sal_free(current);
          }          
          current = temp;
       } while (current != head);
       kt2_tdm_port_slots_info[port].prev=NULL;
       kt2_tdm_port_slots_info[port].next=NULL;
       kt2_tdm_port_slots_info[port].position = -1;
  }
  sal_memcpy(&kt2_current_tdm_cycles_info,
             &kt2_tdm_cycles_info[tdm_freq_index][0],
             sizeof(tdm_cycles_info_t)*KT2_MAX_SPEEDS);
  return rv;
}
static soc_error_t 
kt2_tdm_position_mask(int unit,
                      uint32 port, 
                      int32  pos, 
                      uint32 total_tdm_slots,
                      uint32 *tdm_position_mask)
{
    uint32 count=0;
    uint32 mxqblock=0;
    int32  pos1=0;
    int32  pos2=0;

    if (!((port >=  1) && (port <= KT2_MAX_PHYSICAL_PORTS))) {
         return SOC_E_PORT;
    }
    mxqblock=(*kt2_port_to_mxqblock[unit])[port-1];
    for (count=0;count < 4; count++) {
         pos1 = (pos + count+1)%total_tdm_slots;
         tdm_position_mask[pos1] |= (1 << mxqblock);
         pos2 = (int32)(pos - (count+1));
         if (pos2 < 0) {
             pos2 = pos2 + total_tdm_slots;
         }
         tdm_position_mask[pos2] |= (1 << mxqblock);
    }
    return SOC_E_NONE;
}
void kt2_fill_pos(int unit,
                  uint32 *tdm, 
                  uint32 total_tdm_slots,
                  int32  pos, 
                  uint32 port,
                  uint32 port_type,
                  uint32 min_tdm_cycles,
                  uint32 worse_tdm_slot_spacing,
                  uint32 optimal_tdm_slot_spacing)
{
    uint32 negative_flag=0;
    uint32 fill_count=0;
    uint32 optimal_pos=pos;
    uint32 no_optimal_flag=0;
    int32 mxqblock=0;
    static uint32 last_port_type;
    static uint32 previous_position[18]={0};

    if ((port != KT2_LPBK_PORT) && (port != KT2_CMIC_PORT)) {
         mxqblock=(*kt2_port_to_mxqblock[unit])[port-1];
    }
    if (pos == -1) {
        no_optimal_flag=1;
        pos = 0;
        if (last_port_type != port_type) { 
            for(fill_count=0;fill_count<18;fill_count++) {
                previous_position[fill_count]=0;
            }
        }
    }
    last_port_type=port_type;

    for(fill_count=0;fill_count<min_tdm_cycles;fill_count++) {
        if (no_optimal_flag == 1) {
            if ( previous_position[fill_count] != 0) {
                 pos = previous_position[fill_count]+1;
            }
        }
        while (1) {
               if (tdm[pos] == KT2_IDLE) {
                   if ((port == KT2_LPBK_PORT) || (port == KT2_CMIC_PORT)) {
                       break;
                   }
                   if ((kt2_tdm_position_mxq_mask[pos] & (1<<mxqblock))==0) {
                        break;
                   }
                   if (kt2_tdm_mxqblock_ports_used[(*kt2_port_to_mxqblock[unit])[port]] 
                       == 1) {
                        break;
                   }
               }
               if (no_optimal_flag == 0) {
                   if ((negative_flag == 0) && (fill_count != 0)) {
                        pos--;
                   } else {
                        pos++;
                        negative_flag=0;
                   }
               } else {
                   pos++;
               }
        }
        if (pos < optimal_pos) {
               negative_flag=1;
        }
        tdm[pos]=port;
        previous_position[fill_count]=pos;
        if (!((port == KT2_LPBK_PORT) || (port == KT2_CMIC_PORT))) {
               kt2_tdm_position_mask(unit,
                                     port,
                                     pos,
                                     total_tdm_slots,
                                     kt2_tdm_position_mxq_mask);
        }
        pos = optimal_pos = pos + optimal_tdm_slot_spacing + 1;
        if (pos >= total_tdm_slots) {
            pos = total_tdm_slots -1;
            negative_flag = 0; /* forced too */
        }
    }
    if (no_optimal_flag == 0) {
            for(fill_count=0;fill_count<18;fill_count++) {
                previous_position[fill_count]=0;
            }
    }
}

void kt2_tdm_display(int unit,
                     uint32 *tdm,
                     uint32 total_tdm_slots,
                     uint32 row, uint32 col)
{
     uint32 inner_index=0;
     uint32 outer_index=0;

     LOG_VERBOSE(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "\n")));
     LOG_VERBOSE(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "\t\t\t\t======TDM======\n")));
     for (outer_index=0;outer_index < col ; outer_index ++ ) {
          LOG_VERBOSE(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "\t%d"),outer_index));
     }
     LOG_VERBOSE(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "\n")));
     for (outer_index=0;outer_index < col ; outer_index ++ ) {
          LOG_VERBOSE(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "\t%d#"),outer_index));
     }
     LOG_VERBOSE(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "\n")));

     for (outer_index=0; outer_index < total_tdm_slots ; outer_index +=col ) {
          LOG_VERBOSE(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "%d==>\t"),outer_index/col));
          for (inner_index=0;
               (inner_index < col) && 
               ((outer_index+inner_index) < total_tdm_slots) ; 
               inner_index++ ) {
              switch(tdm[outer_index+inner_index]) {
              case KT2_IDLE :
                  LOG_VERBOSE(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "IDLE\t"))); 
                  break;
              case KT2_IDLE1 :
                  LOG_VERBOSE(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "IDLE1\t"))); 
                  break;
              case KT2_LPBK_PORT :
                  LOG_VERBOSE(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "LPBK\t"))); 
                  break;
              case KT2_CMIC_PORT :
                  LOG_VERBOSE(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "CMIC\t"))); 
                  break;
              case KT2_OLP_PORT :
                  if (SOC_INFO(unit).olp_port[0]) {
                      LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                  (BSL_META_U(unit,
                                              "OLP\t"))); 
                      break;
                  }
              default :
                  LOG_VERBOSE(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                                          "%d\t"),
                                          tdm[outer_index+inner_index]));
                  break;
              }
          }
          LOG_VERBOSE(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "\n")));
     }
}
soc_error_t kt2_tdm_generate(
            int    unit,
            uint32 *port_speed,
            uint32 total_ports, 
            uint32 tdm_freq       , /* In MHHz */
            uint32 total_tdm_slots,
            uint32 *tdm, 
            char  *tdm_config_string)
{
    char temp_string[80];
    uint32 reserved_flag=0;
    uint32 optimal_pos=0;
    uint32 mxqblock;
    uint32 next_mxqblock;
    uint32 temp;
    uint32 total_bw=0;
    uint32 port=0;
    uint32 count=0;
    uint32 index=0;
    uint32 index1=0;

    int32  pos=0;

    uint32 kt2_1g_ports=0;
    uint32 kt2_1g_ports_array[40]={0};
    uint32 kt2_1g_ports_mxqflags[10]={0};
    /* int    kt2_1g_ports_pos[2]={0}; */
    uint32 kt2_2g_ports=0;
    uint32 kt2_2g_ports_array[40]={0};
    uint32 kt2_2g_ports_mxqflags[10]={0};

    uint32 kt2_2_5g_ports=0;
    uint32 kt2_2_5g_ports_array[40]={0};
    uint32 kt2_2_5g_ports_mxqflags[10]={0};

    uint32 kt2_10g_ports=0;
    uint32 kt2_10g_ports_array[40]={0};
    uint32 kt2_13g_ports=0;
    uint32 kt2_13g_ports_array[40]={0};
    /*
    uint32 kt2_20g_ports=0;
    uint32 kt2_20g_ports_array[40]={0};
    */
    uint32 kt2_21g_ports=0;
    uint32 kt2_21g_ports_array[40]={0};

    uint32 kt2_21g_reserved_position[2]={0,2};
    /* uint32 kt2_20g_reserved_position[2]={0,2}; */
    uint32 kt2_13g_reserved_position[2]={1,4};
    uint32 kt2_10g_reserved_position[2]={3,8};
    uint32 tdm_freq_index=0; 
    uint32 min_tdm_cycles=0; 
    uint32 lpbk_min_tdm_cycles=0; 
    uint32 cmic_min_tdm_cycles=0; 
    uint32 worse_tdm_slot_spacing=0; 
    uint32 optimal_tdm_slot_spacing=0; 
    /* uint32 min_tdm_slot_spacing=0; */
    uint32 speed_index=0; 
    uint32 speed_index_1g=0; 
    uint32 speed_index_2g=1; 
    uint32 speed_index_2_5g=2; 
    uint32 speed_index_10g=3; 
    uint32 speed_index_13g=4; 
    /* uint32 speed_index_20g=5;  */
    uint32 speed_index_21g=6; 
    uint32 total_slots=0;
    /* Keeping row variable for future reference but unused
    unsigned int row=0; */
    unsigned int col=0;

    for(index=0;index<10;index++) {
        kt2_tdm_mxqblock_ports_used[index]=0;
    }
    switch(tdm_freq) {
    case 80:
        tdm_freq_index=0;
        /* row=4; */
        col=4;
        break;
    case 120:
        tdm_freq_index=1;
        /* row=4; */
        col=5;
        break;
    case 155:
        tdm_freq_index=2;
        /* row=12; */
        col=7;
        break;
    case 185:
        if (total_tdm_slots == 80 ) {
            /* row=16; */
            col=5;
            tdm_freq_index=3; 
        } else {
            tdm_freq_index=4; 
            /* row=18; */
            col=5;
        }
        reserved_flag=1;
        break;
    default:
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Unsupported tdm frequency:%d \n"),
                   tdm_freq));
        return SOC_E_FAIL;
    }

    for (port=0;port<total_ports;port++) {
        switch(port_speed[port]) {
        case 1000:
            kt2_1g_ports_array[kt2_1g_ports]=port+1;
            kt2_1g_ports++;
            kt2_1g_ports_mxqflags[(*kt2_port_to_mxqblock[unit])[port]]=1;
            total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                [speed_index_1g].min_tdm_cycles;
            break;
        case 2000:
            kt2_2g_ports_array[kt2_2g_ports]=port+1;
            kt2_2g_ports++;
            kt2_2g_ports_mxqflags[(*kt2_port_to_mxqblock[unit])[port]]=1;
            total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                [speed_index_2g].min_tdm_cycles;
            break;
        case 2500:
            kt2_2_5g_ports_array[kt2_2_5g_ports]=port+1;
            kt2_2_5g_ports++;
            kt2_2_5g_ports_mxqflags[(*kt2_port_to_mxqblock[unit])[port]]=1;
            total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                [speed_index_2_5g].min_tdm_cycles;
            break;
        case 10000:
            kt2_10g_ports_array[kt2_10g_ports]=port+1;kt2_10g_ports++;
            total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                [speed_index_10g].min_tdm_cycles;
            break;
        case 13000:
            kt2_13g_ports_array[kt2_13g_ports]=port+1;kt2_13g_ports++;
            total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                [speed_index_13g].min_tdm_cycles;
            break;
        case 20000:
        case 21000:
            kt2_21g_ports_array[kt2_21g_ports]=port+1;kt2_21g_ports++;
            total_slots += kt2_tdm_cycles_info[tdm_freq_index]
                [speed_index_21g].min_tdm_cycles;
            break;
        case 0:
            continue;
        default:
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Unsupported speed%d\n"),port_speed[port]));
            return SOC_E_FAIL;
        }     
        kt2_tdm_mxqblock_ports_used[(*kt2_port_to_mxqblock[unit])[port]]++;
    }
    /*
     * Multiply each base speed by 10 and then divide the total
     * bandwidth by 10 in order to avoid floating point (2.5G).
     */
    total_bw = (10 * kt2_1g_ports + 
                20 * kt2_2g_ports +
                25 * kt2_2_5g_ports +
                100 * kt2_10g_ports +
                130 * kt2_13g_ports +
                210 * kt2_21g_ports) / 10;
    if (total_bw > 92) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Exceeded max bw:92 %d \n"),total_bw));
        return SOC_E_FAIL;
    }
    speed_index=speed_index_2_5g;
    lpbk_min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                        min_tdm_cycles;
    speed_index=speed_index_2g;
    cmic_min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                        min_tdm_cycles;
    if (total_slots > (total_tdm_slots -
                       lpbk_min_tdm_cycles - cmic_min_tdm_cycles)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Exceeded max slots:%d %d \n"),
                              (total_tdm_slots-
                   lpbk_min_tdm_cycles-cmic_min_tdm_cycles),total_slots));
        return SOC_E_FAIL;
    }
    if (tdm_config_string == NULL) {
        return SOC_E_INTERNAL;
    }
    tdm_config_string[0] = '\0';
    if(kt2_21g_ports) {
       sal_sprintf(temp_string," %d*21HG ",kt2_21g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_13g_ports) {
       sal_sprintf(temp_string,"  %d*13HG ",kt2_13g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_10g_ports) {
       sal_sprintf(temp_string,"  %d*10HG ",kt2_10g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_2_5g_ports) {
       sal_sprintf(temp_string,"  %d*2.5G ",kt2_2_5g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_2g_ports) {
       sal_sprintf(temp_string,"  %d*2G ",kt2_2g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    if(kt2_1g_ports) {
       sal_sprintf(temp_string,"  %d*1G ",kt2_1g_ports);
       sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
    }
    sal_sprintf(temp_string,"TotalBw=%d",total_bw);
    sal_sprintf(tdm_config_string,"%s%s",tdm_config_string,temp_string);
                              
    for(pos=0;pos<total_tdm_slots;pos++) {
        tdm[pos]=KT2_IDLE;
        kt2_tdm_position_mxq_mask[pos]=0;
    }
    /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    /* 1. First fill-up 10G ports */ 
    speed_index=speed_index_10g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    count=0;
    /* MAX 4 (2HG*2) 10G ports can be filled-up over here */
    for(index=kt2_21g_ports;index<2;index++) {
        for(index1=0;index1<2 && count<kt2_10g_ports;index1++,count++) {
            if (reserved_flag == 1) {
                /* 5=(9+1)/2 */
                pos = kt2_21g_reserved_position[index] + col*index1;
            } else {
                pos = optimal_pos= 0;
            }
            kt2_fill_pos(unit,tdm, total_tdm_slots, 
                         pos,  kt2_10g_ports_array[index],10000,min_tdm_cycles,
                         worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
            /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
        }
    }
    /* MAX 2 10G ports can be filled-up over here */
    for(index1=0;count<kt2_10g_ports;index1++,count++) {
        if (reserved_flag == 1) {
            if (index1 == 2) {
                break;
            }
            pos = kt2_10g_reserved_position[index1] ;
        } else {
            pos = optimal_pos = 0;
        }
        kt2_fill_pos(unit,tdm, total_tdm_slots, pos,  
                     kt2_10g_ports_array[count],10000,min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    /* 10G ports can still be used(2 more) if 13G ports are not used !! */
    if (count < kt2_10g_ports) {
        if (kt2_13g_ports != 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "13G ports being used.."
                                  "max 10G port can be 6 only\n")));
            return SOC_E_FAIL;
        }
        for(index1=0; index1<2 && count<kt2_10g_ports; index1++,count++) {
             if (reserved_flag == 1) {
                 pos = kt2_13g_reserved_position[0] + col*index1;/*5=(9+1)/2*/
             } else {
                 pos = 0;
             }
             kt2_fill_pos(unit,tdm, total_tdm_slots, pos,  
                          kt2_10g_ports_array[count],10000,min_tdm_cycles,
                          worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
             /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
        }
    }
    speed_index=speed_index_21g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    /* 2. Fill-up 21,20G ports now */ 
    for(index=0;index<kt2_21g_ports;index++) {
        if (reserved_flag == 1) {
            pos = kt2_21g_reserved_position[index] ;
        } else {
            pos = 0;
        }
        kt2_fill_pos(unit,tdm, total_tdm_slots, pos,  
                     kt2_21g_ports_array[index],21000,min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    speed_index=speed_index_13g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    /* 3. Fill-up 13G ports now */ 
    for(index=0;index<kt2_13g_ports;index++) {
        if (reserved_flag == 1) {
        switch(index) {
        case 0:
        case 1: pos = kt2_13g_reserved_position[index] ; break;
        case 2:
        case 3: if (tdm[kt2_21g_reserved_position[0]] == KT2_IDLE) {
                    pos = kt2_21g_reserved_position[0] ; break;
                }
                if (tdm[kt2_10g_reserved_position[0]] == KT2_IDLE) {
                    pos = kt2_10g_reserved_position[0] ; break;
                }
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "21G  and 10G ports Slots are not free :%d \n"),
                           index));
                return SOC_E_FAIL;
        }
        } else {
            pos = 0;
        }
        kt2_fill_pos(unit,tdm, total_tdm_slots, pos,  
                     kt2_13g_ports_array[index],13000,min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    /* 3. Fill-up Loopback ports now */ 
    speed_index=speed_index_2_5g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    kt2_fill_pos(unit,tdm, total_tdm_slots, -1,  KT2_LPBK_PORT,2500, min_tdm_cycles,
                 worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
    /* 4. Fill-up CMIC ports now */ 
    speed_index=speed_index_2g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;
    /* min_tdm_slot_spacing=optimal_tdm_slot_spacing-(worse_tdm_slot_spacing);*/
    pos = 0;
    while (tdm[pos] != KT2_LPBK_PORT) {
           pos++;
    }
    pos = pos + 3 + 1; /* Minimum 3 spacing */
    while (tdm[pos] != KT2_IDLE) {
           pos++;
    }
    tdm[pos] = KT2_CMIC_PORT;
    /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    kt2_fill_pos(unit,tdm, total_tdm_slots, pos+optimal_tdm_slot_spacing+1,  
                 KT2_CMIC_PORT,2000, min_tdm_cycles-1,
                 worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
    /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */

    /* 5. Fill-up remaining 2.5G ports now */ 

    /* 5.1 First Re-arrange 2.5g ports */
    port = kt2_2_5g_ports_array[0];
    for (index=1;index < kt2_2_5g_ports;index++) {
         mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
         next_mxqblock=mxqblock;
         do {
             next_mxqblock=(next_mxqblock+1)%10;
             if (kt2_2_5g_ports_mxqflags[next_mxqblock] == 1) {
                 break;
             }
         }while (next_mxqblock != mxqblock);
         /* Swap entry with next mxqblock */
         index1=index;
         do {
             port = kt2_2_5g_ports_array[index1];
             if ( (*kt2_port_to_mxqblock[unit])[port-1] == next_mxqblock) {
                  break;
             }
             index1=(index1+1)%kt2_2_5g_ports;
         } while ( index1 != index);
         temp = kt2_2_5g_ports_array[index1];
         kt2_2_5g_ports_array[index1]= kt2_2_5g_ports_array[index];
         kt2_2_5g_ports_array[index]= temp;
    }

    /* 5.2 Now update tdm for 2.5g ports */
    speed_index=speed_index_2_5g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    for(index=0;index<kt2_2_5g_ports;index++) {
        port = kt2_2_5g_ports_array[index];
        kt2_fill_pos(unit,tdm, total_tdm_slots, -1,  
                     port,2500, min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }

    /* 6. Fill-up 2G ports now */ 

    /* 6.1 Re-arrange 2g ports first */
    port = kt2_2g_ports_array[0];
    for (index=1;index < kt2_2g_ports;index++) {
         mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
         next_mxqblock=mxqblock;
         do {
             next_mxqblock=(next_mxqblock+1)%10;
             if (kt2_2g_ports_mxqflags[next_mxqblock] == 1) {
                 break;
             }
         }while (next_mxqblock != mxqblock);
         /* Swap entry with next mxqblock */
         index1=index;
         do {
             port = kt2_2g_ports_array[index1];
             if ( (*kt2_port_to_mxqblock[unit])[port-1] == next_mxqblock) {
                  break;
             }
             index1=(index1+1)%kt2_2g_ports;
         } while ( index1 != index);
         temp = kt2_2g_ports_array[index1];
         kt2_2g_ports_array[index1]= kt2_2g_ports_array[index];
         kt2_2g_ports_array[index]= temp;
    }

    /* 6.2 Now update tdm for 2g ports  */
    speed_index=speed_index_2g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;

    for(index=0;index<kt2_2g_ports;index++) {
        port = kt2_2g_ports_array[index];
        kt2_fill_pos(unit,tdm, total_tdm_slots, -1,  
                     port,2000, min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }

    /* Re-arrange 1g ports */
    port = kt2_1g_ports_array[0];
    for (index=1;index < kt2_1g_ports;index++) {
         mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
         next_mxqblock=mxqblock;
         do {
             next_mxqblock=(next_mxqblock+1)%10;
             if (kt2_1g_ports_mxqflags[next_mxqblock] == 1) {
                 break;
             }
         }while (next_mxqblock != mxqblock);
         /* Swap entry with next mxqblock */
         index1=index;
         do {
             port = kt2_1g_ports_array[index1];
             if ( (*kt2_port_to_mxqblock[unit])[port-1] == next_mxqblock) {
                  break;
             }
             index1=(index1+1)%kt2_1g_ports;
         } while ( index1 != index);
         temp = kt2_1g_ports_array[index1];
         kt2_1g_ports_array[index1]= kt2_1g_ports_array[index];
         kt2_1g_ports_array[index]= temp;
    } 
    speed_index=speed_index_1g;
    min_tdm_cycles=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                   min_tdm_cycles;
    worse_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                           worse_tdm_slot_spacing;
    optimal_tdm_slot_spacing=kt2_tdm_cycles_info[tdm_freq_index][speed_index].
                             optimal_tdm_slot_spacing;
    /* 6. Fill-up 1G ports now */ 
    for(index=0;index<kt2_1g_ports;index++) {
        port = kt2_1g_ports_array[index];
        kt2_fill_pos(unit,tdm, total_tdm_slots, 0,  port,1000, min_tdm_cycles,
                     worse_tdm_slot_spacing,optimal_tdm_slot_spacing);
        /* kt2_tdm_display(unit,tdm,total_tdm_slots,row,col);  */
    }
    return SOC_E_NONE;
}



 STATIC soc_error_t
_soc_katana2_mmu_tdm_init(int unit)
{
    uint32 *arr;
    uint32 olp_port_flag=0;
    uint32 offender_port=0;
    soc_error_t retVal=SOC_E_NONE;
    uint32 port=0;
    uint32 outer_index=0;
    uint32 inner_index=0;
    uint32 tdm_index=0;
    uint32  row=18;
    uint32  col=5;
    uint8  mxqblock=0;
    int num_lanes = 0;
    bcmMxqCorePortMode_t mode = bcmMxqCorePortModeSingle;

#ifdef UNDER_TESTING
    uint32 bcm56450_test_selection=0;
    uint32 *bcm56450_test_speed[]={kt2_tdm_56450_test_speed0,
                                   kt2_tdm_56450_test_speed1,
                                   kt2_tdm_56450_test_speed2,
                                   kt2_tdm_56450_test_speed3,
                                   kt2_tdm_56450_test_speed4,
                                   kt2_tdm_56450_test_speed5,
                                   kt2_tdm_56450_test_speed6,
                                   kt2_tdm_56450_test_speed7,
                                   kt2_tdm_56450_test_speed8,
                                   kt2_tdm_56450_test_speed9,
                                   kt2_tdm_56450_test_speed10,
                                   kt2_tdm_56450_test_speed11,
                                   kt2_tdm_56450_test_speed12,
                                   kt2_tdm_56450_test_speed13,
                                   kt2_tdm_56450_test_speed14,
                                   kt2_tdm_56450_test_speed15,
                                   kt2_tdm_56450_test_speed16,
                                   kt2_tdm_56450_test_speed17,
                                   kt2_tdm_56450_test_speed18,
                                   kt2_tdm_56450_test_speed19,
                                   };
    uint32  pos=0;
    uint32  index=0;
    uint32  freq=0;


#endif
    int i, tdm_size,tdm_freq, cfg_num, cfg_offset = 0, temp_cfg_num = 0;
    iarb_tdm_table_entry_t iarb_tdm;
    lls_port_tdm_entry_t lls_tdm;
    uint32 rval, arr_ele;
    uint16 dev_id;
    uint8 rev_id;
    uint32 port_enable_value=0;

    soc_cm_get_id(unit, &dev_id, &rev_id);
    SOC_IF_ERROR_RETURN(_soc_katana2_get_cfg_num(unit, &cfg_num));
    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        LOG_CLI((BSL_META_U(unit,
                            "Wrong cfg_num:%d exceeding max cfg_num: %d\n"),
                 cfg_num, 
                 (int)(sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))));
        return SOC_E_FAIL;
    } 
    
    switch(dev_id) {
    case BCM55450_DEVICE_ID:
    case BCM55455_DEVICE_ID:
    case BCM56248_DEVICE_ID:
    case BCM56450_DEVICE_ID:
    case BCM56452_DEVICE_ID:
    case BCM56454_DEVICE_ID:
    case BCM56455_DEVICE_ID:
    case BCM56456_DEVICE_ID:
    case BCM56457_DEVICE_ID:
    case BCM56458_DEVICE_ID:
         tdm_size= bcm56450_tdm_info[cfg_num].tdm_size;
         tdm_freq= bcm56450_tdm_info[cfg_num].tdm_freq;
         row= bcm56450_tdm_info[cfg_num].row;
         col= bcm56450_tdm_info[cfg_num].col;
         LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                             "Cfg=%d freq=%d size=%d raw=%d col=%d \n"),
                  cfg_num,tdm_freq,tdm_size,row,col));
         arr = bcm56450_tdm[cfg_num];
         switch(cfg_num) { /* Will be later changed to switch(cfg_num) */
         case BCM56248_DEVICE_ID_OFFSET_CFG + 0:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 0:
                                           /* kt2_tdm_56450config_deprecated0 */
             LOG_CLI((BSL_META_U(unit,
                                 "kt2_tdm_56450speed_deprecated0\n")));
                sal_memcpy(arr,
                          &kt2_tdm_56450AA_ref[0], sizeof(kt2_tdm_56450AA_ref));
                olp_port_flag=0;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 1:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 1:/* kt2_tdm_A_56450_1 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A_56450_1 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0],sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_replace(arr,88,KT2_OLP_PORT,KT2_IDLE,0);
                kt2_tdm_replace(arr,tdm_size,33,25,0);
                kt2_tdm_replace(arr,tdm_size,30,26,0);
                olp_port_flag=0;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 2:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 2:/* kt2_tdm_A_56450_2 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A_56450_2 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_replace(arr,88,33,25,0);
                kt2_tdm_replace(arr,88,30,26,0);
                olp_port_flag=1;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 3:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 3:/* kt2_tdm_A_56450_3 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A_56450_3 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0],sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_replace(arr,88,33,25,0);
                olp_port_flag=1;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 4:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 4:/* kt2_tdm_A_56450_4 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A_56450_4 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                olp_port_flag=1;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 5:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 5:/* kt2_tdm_A_56450_5 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A_56450_5 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_display(unit,arr, tdm_size,  row,  col);
                kt2_tdm_swap(arr,88,21,33);
                kt2_tdm_display(unit,arr, tdm_size,  row,  col);
                kt2_tdm_swap(arr,88,30,13);
                kt2_tdm_display(unit,arr, tdm_size,  row,  col);
                kt2_tdm_replace(arr,88,13,25,0);
                kt2_tdm_display(unit,arr, tdm_size,  row,  col);
                kt2_tdm_replace(arr,88,21,36,0);
                kt2_tdm_display(unit,arr, tdm_size,  row,  col);
                kt2_tdm_replace(arr,88,17,13,0);
                kt2_tdm_display(unit,arr, tdm_size,  row,  col);
                olp_port_flag=1;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 6:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 6:/*  kt2_tdm_A_56450_6 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A_56450_6 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_swap(arr,88,1,17);
                kt2_tdm_swap(arr,88,13,21);
                kt2_tdm_replace(arr,88,17,39,0);
                kt2_tdm_replace(arr,88,21,26,0);
                kt2_tdm_replace(arr,88,9,25,0);
                kt2_tdm_replace(arr,88,13,36,0);
                kt2_tdm_replace(arr,88,40,KT2_IDLE,0);
                olp_port_flag=0;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 7:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 7:/* kt2_tdm_A_56450_7 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A_56450_7 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A_ref[0], sizeof(kt2_tdm_56450A_ref));
                kt2_tdm_swap(arr,88,9,17);
                kt2_tdm_replace(arr,88,17,26,0);
                kt2_tdm_replace(arr,88,21,39,0);
                kt2_tdm_replace(arr,88,13,25,0); 

                kt2_tdm_replace(arr,88,13,KT2_IDLE,0);
                kt2_tdm_replace(arr,88,1,KT2_IDLE,0);
                kt2_tdm_replace(arr,88,5,KT2_IDLE,0);
                kt2_tdm_replace(arr,88,9,KT2_IDLE,0);
                kt2_tdm_replace(arr,88,40,KT2_IDLE,0);
                tdm_index=0;
                for (outer_index=1;outer_index<=4;outer_index++) {
                     for (inner_index=0;inner_index < 6;inner_index++) {
                          port = outer_index + inner_index*4;
                          while(arr[tdm_index] != KT2_IDLE) {
                                tdm_index++;
                          }
                          arr[tdm_index]=port;
                     }
                }
                olp_port_flag=0;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 8:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 8:/* kt2_tdm_A1_56450_8 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A1_56450_8 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A1_ref[0], 
                           sizeof(kt2_tdm_56450A1_ref));
                olp_port_flag=1;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 9:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 9:/* kt2_tdm_A1A_56450_9 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A1A_56450_9 \n")));
                sal_memcpy(arr,
                           &kt2_tdm_56450A1A_ref[0],
                           sizeof(kt2_tdm_56450A1A_ref));
                olp_port_flag=1;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 10:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 10: /* kt2_tdm_A2_56450_10 */
                  LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                      "kt2_tdm_A2_56450_10 \n")));
                  sal_memcpy(arr,
                             &kt2_tdm_56450A2_ref[0],
                             sizeof(kt2_tdm_56450A2_ref));
                  kt2_tdm_replace(arr,tdm_size,KT2_OLP_PORT,KT2_IDLE,0);
                  olp_port_flag=0;
                  break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 11:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 11: /* kt2_tdm_A2_56450_11 */
                  LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                      "kt2_tdm_A2_56450_11 \n")));
                  sal_memcpy(arr,
                            &kt2_tdm_56450A2_ref[0],
                            sizeof(kt2_tdm_56450A2_ref));
                  olp_port_flag=1;
                  break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 12:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 12: /* kt2_tdm_A3_56450_12 */
                  LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                      "kt2_tdm_A3_56450_12 \n")));
                  sal_memcpy(arr,
                             &kt2_tdm_56450A3_ref[0],
                             sizeof(kt2_tdm_56450A3_ref));
                  olp_port_flag=1;
                  break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 13:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 13: /* kt2_tdm_A2_56450_13 */
                  LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                      "kt2_tdm_A2_56450_13 \n")));
                  sal_memcpy(arr,
                             &kt2_tdm_56450A2_ref[0],
                             sizeof(kt2_tdm_56450A2_ref));
                  kt2_tdm_replace(arr,tdm_size,26,28,0);
                  kt2_tdm_replace(arr,tdm_size,25,27,0);
                  olp_port_flag=1;
                  break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 14:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 14: /* kt2_tdm_A1_56450_14 */
                  LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                      "kt2_tdm_A1_56450_14 \n")));
                  sal_memcpy(arr,
                             &kt2_tdm_56450A1_ref[0],
                             sizeof(kt2_tdm_56450A1_ref));
                  olp_port_flag=1;
                  break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 15:
         case BCM56450_DEVICE_ID_OFFSET_CFG + 15: /* kt2_tdm_A4_56450_15 */
                  LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                      "kt2_tdm_A4_56450_15 \n")));
                  memcpy(arr,
                         &kt2_tdm_56450A4_ref[0],
                         sizeof(kt2_tdm_56450A4_ref));
                  olp_port_flag=1;
                  break;
         case BCM56450_DEVICE_ID_OFFSET_CFG + 16: /* kt2_tdm_F_56450_16 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_F_56450_16 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56450F_ref[0], sizeof(kt2_tdm_56450F_ref));
                olp_port_flag=0;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 1:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_C_56452_1 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56455C_ref[0], sizeof(kt2_tdm_56455C_ref));
                olp_port_flag=0;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 2:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_C1_56452_2 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56452C1_ref[0], sizeof(kt2_tdm_56452C1_ref));
                olp_port_flag=1;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 3:
         case BCM56452_DEVICE_ID_OFFSET_CFG + 4:
                sal_memcpy(arr,
                          &kt2_tdm_56452C1_ref[0], sizeof(kt2_tdm_56452C1_ref));
                for(port=2;port<=8;port++) {
                    kt2_tdm_replace(arr,64,port,1,0);
                }
                for(port=9;port<=16;port++) {
                    kt2_tdm_replace(arr,64,port,5,0);
                }
                for(port=17;port<=24;port++) {
                    kt2_tdm_replace(arr,64,port,KT2_IDLE,0);
                }
                if (cfg_num == BCM56452_DEVICE_ID_OFFSET_CFG + 3) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                        "kt2_tdm_C1_56452_3 \n")));
                    olp_port_flag=0;
                    kt2_tdm_replace(arr,64,KT2_OLP_PORT,KT2_IDLE,0);
                } else {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                        "kt2_tdm_C1_56452_4 \n")));
                    olp_port_flag=1;
                }
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 5:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_B_56452_5 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56452B_new_ref[0],
                          sizeof(kt2_tdm_56452B_new_ref));
                for(port=1;port<=8;port++) {
                    kt2_tdm_replace(arr,90,port,KT2_IDLE,0);
                }
                tdm_index=0;
                for (outer_index=1;outer_index<=4;outer_index++) {
                    for (inner_index=0;inner_index < 6;inner_index++) {
                        port = outer_index + inner_index*4;/* 1,5,9,13,17,21
                                                              2,6,10,14,18,22,
                                                              3,7,11,15,19,23,
                                                              4,8,12,16,20,24
                                                            */
                        while(arr[tdm_index] != KT2_IDLE) {
                            tdm_index++;
                        }
                        arr[tdm_index]=port;
                    }
                }

                kt2_tdm_replace(arr,90,26,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,38,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,39,KT2_IDLE,0);
                olp_port_flag=1;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 6:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_B1_56452_6 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56452B1_ref[0], sizeof(kt2_tdm_56452B1_ref));
                kt2_tdm_replace(arr,60,1,60,0);
                kt2_tdm_replace(arr,60,5,60,0);
                kt2_tdm_replace(arr,60,25,60,0);
                for (inner_index=1;inner_index <= 4;inner_index++) {
                     for (outer_index=0;outer_index< 6;outer_index++) {
                          port = inner_index + outer_index*4;
                          kt2_tdm_replace(arr,60,60,port,1);
                     }
                }
                kt2_tdm_replace(arr,60,60,KT2_IDLE,0);
                olp_port_flag=1;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 7:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_B_56452_7 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56452B_new_ref[0], 
                          sizeof(kt2_tdm_56452B_new_ref));
               for(port=1;port<=8;port++) {
                    kt2_tdm_replace(arr,90,port,KT2_IDLE,0);
               }
               tdm_index=0;
               for (outer_index=1;outer_index<=4;outer_index++) {
                    for (inner_index=0;inner_index < 6;inner_index++) {
                         port = outer_index + inner_index*4;/* 1,5,9,13,17,21
                                                               2,6,10,14,18,22,
                                                               3,7,11,15,19,23,
                                                               4,8,12,16,20,24
                                                             */
                         while(arr[tdm_index] != KT2_IDLE) {
                               tdm_index++;
                         }
                         arr[tdm_index]=port;
                    }
                }

                kt2_tdm_replace(arr,90,25,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,35,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,36,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,37,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,26,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,38,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,39,KT2_IDLE,0);
                kt2_tdm_replace(arr,90,40,KT2_IDLE,0);
                olp_port_flag=0;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 8:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_B_56452_8 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56452B_new_ref[0], 
                          sizeof(kt2_tdm_56452B_new_ref));
                mxqblock = 6;
                outer_index= 0; 
                for (inner_index=0; inner_index < 90; inner_index++) {
                     if (arr[inner_index] == 25) {
                         arr[inner_index] = (*kt2_mxqblock_ports[unit])
                                              [mxqblock][outer_index];
                         outer_index = (outer_index + 1) % 4;
                     }
                }
                olp_port_flag=0;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 9:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_B1_56452_9 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56452B1_ref[0], sizeof(kt2_tdm_56452B1_ref));
                olp_port_flag=1;
                break;
         case BCM56452_DEVICE_ID_OFFSET_CFG + 10:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_B2_56452_10 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56452B2_ref[0], sizeof(kt2_tdm_56452B2_ref));
                olp_port_flag=1;
                break;
         case BCM56454_DEVICE_ID_OFFSET_CFG + 1: /* kt2_tdm_D_56454_1 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_D1_56454_1 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56454D1_ref[0], sizeof(kt2_tdm_56454D1_ref));
                olp_port_flag=1;
                break;
         case BCM56454_DEVICE_ID_OFFSET_CFG + 2: /* kt2_tdm_D_56454_2 */
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_D2_56454_2 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56454D1_ref[0], sizeof(kt2_tdm_56454D1_ref));
                kt2_tdm_replace(arr,40,27,25,0);
                kt2_tdm_replace(arr,40,28,26,0);
                kt2_tdm_replace(arr,40,KT2_OLP_PORT,KT2_IDLE,0);
                olp_port_flag=0;
                break;
         case BCM56455_DEVICE_ID_OFFSET_CFG + 1:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_C_56455_1 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56455C_ref[0], sizeof(kt2_tdm_56455C_ref));
                olp_port_flag = 0;
                break;
         case BCM56455_DEVICE_ID_OFFSET_CFG + 2:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_C_56455_2 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56455C_ref[0], sizeof(kt2_tdm_56455C_ref));
                kt2_tdm_swap(arr, 84, 26, 28);
                kt2_tdm_replace(arr, 84, 27, KT2_IDLE, 0);
                kt2_tdm_replace(arr, 84, 28, KT2_IDLE, 0);
                for (port = 1; port <= 8; port++) {
                     kt2_tdm_replace(arr, 84, port, KT2_IDLE, 0);
                     kt2_tdm_replace(arr, 84, port + 16, KT2_IDLE, 0);
                }
                olp_port_flag = 0;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 16:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_A3_56450_16 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56450A3_ref[0], sizeof(kt2_tdm_56450A3_ref));
                olp_port_flag=1;
                break;
         case BCM56248_DEVICE_ID_OFFSET_CFG + 17:
                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                    "kt2_tdm_D2_56248_17 \n")));
                sal_memcpy(arr,
                          &kt2_tdm_56248D2_ref[0], sizeof(kt2_tdm_56248D2_ref));
                kt2_tdm_replace(arr,40,9,KT2_IDLE,1);
                kt2_tdm_replace(arr,40,28,KT2_IDLE,1);
                kt2_tdm_replace(arr,40,29,KT2_IDLE,1);
                kt2_tdm_replace(arr,40,29,30,1);
                olp_port_flag=1;
                break;
#ifdef BCM_WARM_BOOT_SUPPORT
         case COUNTOF(bcm56450_tdm_info) - 1:
                if (SOC_WARM_BOOT(unit)) {
                    tdm_size = kt2_scache_tdm_info[unit].tdm_size;
                    tdm_freq = kt2_scache_tdm_info[unit].tdm_freq;
                    row = kt2_scache_tdm_info[unit].row;
                    col = kt2_scache_tdm_info[unit].col;
                    arr = kt2_scache_tdm[unit];
                    sal_memcpy(arr, &kt2_scache_tdm[unit][0],
                               sizeof(kt2_scache_tdm[unit]));
                    break;
                }
#endif
         default: olp_port_flag=0;
                LOG_CLI((BSL_META_U(unit,
                                    "Not Supported Cfg Value%d \n"),cfg_num));
                return SOC_E_FAIL;
         }
         kt2_tdm_display(unit, arr, tdm_size,  row,  col);
         /* speed = bcm56450_speed[cfg_num]; */
         retVal=kt2_tdm_verify(unit, arr, tdm_size, tdm_freq,
                               (uint32 *)bcm56450_speed[unit][cfg_num],
                               olp_port_flag,&offender_port);  
         SOC_IF_ERROR_RETURN(retVal);
         /* ######################## */
         /* Just for testing purpose */
         /* ######################## */
#ifdef UNDER_TESTING
         for(bcm56450_test_selection=0;
             bcm56450_test_selection < sizeof(bcm56450_test_speed)/
                                       sizeof(bcm56450_test_speed[0]);
             bcm56450_test_selection++) {
             if ((bcm56450_test_selection >=0) &&
                 (bcm56450_test_selection <=10)) {
                 pos = 90; row = 18; col = 5;freq=185;
             }
             if ((bcm56450_test_selection >=11) &&
                 (bcm56450_test_selection <=13)) {
                 pos = 80; row = 16; col = 5;freq=185;
             }
             if ((bcm56450_test_selection >=14) &&
                 (bcm56450_test_selection <=16)) {
                 pos = 84; row = 12; col = 7;freq=155;
             }
             if ((bcm56450_test_selection >=17) &&
                 (bcm56450_test_selection <=18)) {
                 pos = 20; row = 4; col = 5;freq=120;
             }
             if ((bcm56450_test_selection >=19) &&
                 (bcm56450_test_selection <=19)) {
                 pos = 16; row = 4; col = 4;freq=80;
             }
             LOG_WARN(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "\n###############\n")));
             SOC_IF_ERROR_RETURN(kt2_tdm_generate(
                                 bcm56450_test_speed[bcm56450_test_selection],
                                 40,freq,pos,
                                 kt2_tdm_under_testing,tdm_config_string));
             retVal = kt2_tdm_verify(
                                 unit,
                                 kt2_tdm_under_testing,pos,freq, 
                                 bcm56450_test_speed[bcm56450_test_selection],
                                 olp_port_flag,&offender_port);
             for(index=0;index<180;index++) {
                  kt2_tdm_under_testing_idle[index]=KT2_IDLE;
             }
             sal_memcpy(kt2_tdm_under_testing_idle,kt2_tdm_under_testing,
                        sizeof(uint32)*pos);
             if ((retVal == SOC_E_CONFIG) && (offender_port == KT2_IDLE)) {
                 do {
                    switch(offender_port) {
                    case KT2_IDLE:
                         if (kt2_tdm_under_testing_idle[pos-1] == KT2_IDLE) {
                             pos++;
                         } else {
                             pos+=2;
                         }
                         break;
                    default:kt2_tdm_under_testing_idle[pos-2]=offender_port;
                            pos++;
                            break; 
                    }
                    if (pos == 180) {
                        break;
                    }
                    retVal = kt2_tdm_verify(
                                 unit, 
                                 kt2_tdm_under_testing_idle,pos, freq, 
                                 bcm56450_test_speed[bcm56450_test_selection],
                                 olp_port_flag,&offender_port);
                  }while(retVal == SOC_E_CONFIG);
             } 
             SOC_IF_ERROR_RETURN(retVal);
             LOG_WARN(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Configuration:%d:(freq:%d Cycles:%d) %s"),
                                  bcm56450_test_selection,freq,pos,
                       tdm_config_string));
             kt2_tdm_display(unit,kt2_tdm_under_testing_idle,pos,row,col);
             LOG_WARN(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "###############\n")));
         } 
#endif
         break; 
    default:
        return SOC_E_FAIL;
    }

    /* Disable IARB TDM before programming... */
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
                      tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    for (i = 0; i < tdm_size; i++) {
        arr_ele = arr[i];
        if (arr_ele <= 41) { /* Non Idle Slots */
            port_enable_value = 1;
        } else {
            port_enable_value = 0;
        }

        sal_memset(&iarb_tdm, 0, sizeof(iarb_tdm_table_entry_t));
        soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                                        arr_ele);
        SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i, 
                                                  &iarb_tdm));

        if (0 == (i%2)) {
            /* Two entries per mem entry */
            sal_memset(&lls_tdm, 0, sizeof(lls_port_tdm_entry_t));
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_0f, arr_ele);
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, 
                                          PORT_ID_0_ENABLEf, port_enable_value);
        } else {
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, PORT_ID_1f, arr_ele);
            soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm, 
                                          PORT_ID_1_ENABLEf, port_enable_value);
            SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, (i/2),
                                                      &lls_tdm));
            SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, 128+(i/2),
                                                      &lls_tdm));
        }
    }
    if (tdm_size % 2) {
        LOG_CLI((BSL_META_U(unit,
                            "Info:Odd TDM Size%d \n"),tdm_size));
        SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, (i/2),
                                                &lls_tdm));
        SOC_IF_ERROR_RETURN(WRITE_LLS_PORT_TDMm(unit, SOC_BLOCK_ALL, 128+(i/2),
                                                &lls_tdm));
    }
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
                      tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    
    rval = 0;
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, END_Af, tdm_size - 1);
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, END_Bf, tdm_size - 1);
    soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval, ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFGr(unit, rval));
    soc_katana2_save_tdm_pos(unit, tdm_size,arr);
    temp_cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG,0xFF);
    if (temp_cfg_num == 0xFF) {
        (*mxqspeeds[unit])[6][0]= bcm56450_speed[unit][cfg_num][25-1];
        (*mxqspeeds[unit])[7][0]= bcm56450_speed[unit][cfg_num][26-1];
        (*mxqspeeds[unit])[8][0]= bcm56450_speed[unit][cfg_num][27-1];
        (*mxqspeeds[unit])[9][0]= bcm56450_speed[unit][cfg_num][28-1];
    } else {
        switch(dev_id) {
            case BCM55450_DEVICE_ID:
            case BCM55455_DEVICE_ID:
            case BCM56450_DEVICE_ID:
            case BCM56456_DEVICE_ID:
                 cfg_offset = BCM56450_DEVICE_ID_OFFSET_CFG + temp_cfg_num;
                 break;
            case BCM56452_DEVICE_ID:
            case BCM56457_DEVICE_ID:
                 cfg_offset = BCM56452_DEVICE_ID_OFFSET_CFG + temp_cfg_num;
                 break;
            case BCM56454_DEVICE_ID:
            case BCM56458_DEVICE_ID:
                 cfg_offset = BCM56454_DEVICE_ID_OFFSET_CFG + temp_cfg_num;
                 break;
            case BCM56455_DEVICE_ID:
                 cfg_offset = BCM56455_DEVICE_ID_OFFSET_CFG + temp_cfg_num;
                 break;
            case BCM56248_DEVICE_ID:
                 cfg_offset = BCM56248_DEVICE_ID_OFFSET_CFG + temp_cfg_num;
                 break;
            default:
                 break;
        }

        (*mxqspeeds[unit])[6][0]= bcm56450_speed[unit][cfg_offset][25-1];
        (*mxqspeeds[unit])[7][0]= bcm56450_speed[unit][cfg_offset][26-1];
        (*mxqspeeds[unit])[8][0]= bcm56450_speed[unit][cfg_offset][27-1];
        (*mxqspeeds[unit])[9][0]= bcm56450_speed[unit][cfg_offset][28-1];
    }

    /* In few bcm5645x_configs, WC ports interface type is XFI. In those
     * configs, if the phy mode and core mode of the port is operating in single
     * port mode, then port can operate at 13g speed.
     */
    soc_katana2_get_core_port_mode(unit, 27, &mode);
    num_lanes = soc_property_port_get(unit, 27, spn_PORTGROUP, 0);
    if ((mode == bcmMxqCorePortModeSingle) && (num_lanes == 4) &&
        ((*mxqspeeds[unit])[8][0] == 10000)) {
        (*mxqspeeds[unit])[8][0] = 13000;
    }

    soc_katana2_get_core_port_mode(unit, 28, &mode);
    num_lanes = soc_property_port_get(unit, 28, spn_PORTGROUP, 0);
    if ((mode == bcmMxqCorePortModeSingle) && (num_lanes == 4) &&
        ((*mxqspeeds[unit])[9][0] == 10000)) {
        (*mxqspeeds[unit])[9][0] = 13000;
    }

    switch((*mxqspeeds[unit])[8][0]) {
    case 21000: 
        (*mxqspeeds[unit])[8][1]= 10000;
        (*mxqspeeds[unit])[8][3]= 2500;
        break;
    case 13000: 
        (*mxqspeeds[unit])[8][1]= 2500;
        (*mxqspeeds[unit])[8][3]= 2500;
        break;
    case 10000:
        if (bcm56450_speed[unit][cfg_num][33-1] == 10000) {
            /* We can handle but doubt about TDM mxqspeeds[8][0]= 21000; */
            (*mxqspeeds[unit])[8][1]= 10000;
            (*mxqspeeds[unit])[8][3]= 2500;
        } else {
            (*mxqspeeds[unit])[8][1]= 2500;
            (*mxqspeeds[unit])[8][3]= 2500;
        } 
        break;
    }
    switch((*mxqspeeds[unit])[9][0]) {
    case 21000: 
        (*mxqspeeds[unit])[9][1]= 10000;
        (*mxqspeeds[unit])[9][3]= 2500;
        break;
    case 13000: 
        (*mxqspeeds[unit])[9][1]= 2500;
        (*mxqspeeds[unit])[9][3]= 2500;
        break;
    case 10000:
        if (bcm56450_speed[unit][cfg_num][30-1] == 10000) {
            /* We can handle but doubt about TDM mxqspeeds[9][0]= 21000; */
            (*mxqspeeds[unit])[9][1]= 10000;
            (*mxqspeeds[unit])[9][3]= 2500;
        } else {
            (*mxqspeeds[unit])[9][1]= 2500;
            (*mxqspeeds[unit])[9][3]= 2500;
        } 
        break;
    }
    return SOC_E_NONE;
}
soc_error_t 
soc_katana2_port_enable_set(int unit, soc_port_t port, int enable)
{
   uint8 mxqblock ;
   uint8 loop ;
   uint32 entry[SOC_MAX_MEM_WORDS];
   soc_info_t *si= &SOC_INFO(unit);
   uint32  port_enable = 0;
   uint32 regval=0;

   SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(unit,port,&mxqblock));
   if (!SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
       return SOC_E_PORT; 
   }
   for(loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
       if ((*kt2_mxqblock_ports[unit])[mxqblock][loop] == port) {
           break;
       } 
   }
   if (loop == KT2_MAX_MXQPORTS_PER_BLOCK) {
       return SOC_E_PORT; 
   }

   /*
    * For MXQ blocks 8 and 9, PORT_ENABLEf in TXLP_PORT_ENABLEr has to
    * be set to enable TXLP-2_MMU requests. LP_ENABLEf is set if
    * the port is set linkphy_pbm and config property LINKPHY_ENABLE
    * is set.
    */
   if (SOC_REG_PORT_VALID(unit, TXLP_PORT_ENABLEr, port)) {
       SOC_IF_ERROR_RETURN(READ_TXLP_PORT_ENABLEr(unit, port, &regval));
       port_enable = soc_reg_field_get(unit, TXLP_PORT_ENABLEr,
                                       regval, PORT_ENABLEf);
       port_enable |= (1 << loop);
       soc_reg_field_set(unit, TXLP_PORT_ENABLEr, &regval,
                         PORT_ENABLEf,port_enable);
       LOG_VERBOSE(BSL_LS_SOC_COMMON,
                   (BSL_META_U(unit,
                   "TXLP port_enable=%d\n"),
                   port_enable));
       SOC_IF_ERROR_RETURN(WRITE_TXLP_PORT_ENABLEr(unit, port, regval));
   }

   sal_memset(entry, 0, sizeof(egr_enable_entry_t));
   if ((port == KT2_OLP_PORT) && (si->olp_port[0] == 1) ) {
        /*
        LOG_CLI((BSL_META_U(unit,
                            "QUICKTURN:ATTN:Olp Trick Continue"
                 "Need RegfileChange MXQ:%d:\n"),mxqblock));
         */
        loop = 0; /* Port 0 Field */
   }
   if (enable) {
       soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, port, entry));

   } else {
       soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 0);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, port, entry));
   }

   return SOC_E_NONE;
}
void soc_katana2_mxqblock_reset(int unit, uint8 mxqblock,int active_low)
{
    uint32 rval;
    soc_field_t hot_swap_reset_fld[]={
                TOP_MXQ0_HOTSWAP_RST_Lf,TOP_MXQ1_HOTSWAP_RST_Lf,
                TOP_MXQ2_HOTSWAP_RST_Lf,TOP_MXQ3_HOTSWAP_RST_Lf,
                TOP_MXQ4_HOTSWAP_RST_Lf,TOP_MXQ5_HOTSWAP_RST_Lf,
                TOP_MXQ6_HOTSWAP_RST_Lf,TOP_MXQ7_HOTSWAP_RST_Lf,
                TOP_MXQ8_HOTSWAP_RST_Lf,TOP_MXQ9_HOTSWAP_RST_Lf};

    if (READ_TOP_SOFT_RESET_REGr(unit, &rval) != SOC_E_NONE) {
        LOG_CLI((BSL_META_U(unit,
                            "ATTN: Reading TOP_SOFT_RESET_REG failed \n")));
        return;
    }
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, 
                      hot_swap_reset_fld[mxqblock],active_low);
    WRITE_TOP_SOFT_RESET_REGr(unit, rval);

}
soc_error_t 
soc_katana2_reconfigure_tdm(int unit,uint32 new_tdm_size,uint32 *new_tdm)
{
    uint8                new_tdm_no=0;
    soc_mem_t            tdm_table[]={IARB_TDM_TABLEm , IARB_TDM_TABLE_1m};
    soc_field_t          wrap_ptr[]={TDM_WRAP_PTRf , TDM_1_WRAP_PTRf};
    /* 
    lls_port_tdm_entry_t   lls_tdm[128]={{{0}}};
    iarb_tdm_table_entry_t iarb_tdm[256]={{{0}}};
    */
    uint32                 lls_tdm_size=0;
    lls_port_tdm_entry_t   *lls_tdm=NULL;
    uint32                 iarb_size=0;
    iarb_tdm_table_entry_t *iarb_tdm=NULL;
    int                  cfg_num=0; 
    int                  iter=0; 

    uint8                index;
    uint32               rval;

    if (new_tdm_size > 216) {
        return SOC_E_PARAM;
    }
    /*
    if (sal_memcmp(&kt2_current_tdm[0],&new_tdm[0],
                   sizeof(kt2_current_tdm[0])) == 0) {
        return SOC_E_NONE;
    }
    */
    SOC_IF_ERROR_RETURN(_soc_katana2_get_cfg_num(unit, &cfg_num));
    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        return SOC_E_FAIL;
    } 

    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    old_tdm_no[unit] = soc_reg_field_get(unit, IARB_TDM_CONTROLr, rval, SELECT_TDMf);
    new_tdm_no = (old_tdm_no[unit] + 1)%2;

#if 0
    /* Disable IARB TDM before programming... */
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));
#endif
    iarb_size =  soc_mem_index_count(unit,IARB_TDM_TABLEm) *
                 sizeof(iarb_tdm_table_entry_t);
    iarb_tdm = soc_cm_salloc(unit,iarb_size, "iarb_tdm_table_entry_t");
    if (iarb_tdm == NULL) {
        return SOC_E_MEMORY;
    }
    sal_memset(iarb_tdm,0,iarb_size);
    lls_tdm_size =  soc_mem_index_count(unit,LLS_PORT_TDMm) *
                    sizeof(lls_port_tdm_entry_t);
    lls_tdm = soc_cm_salloc(unit,lls_tdm_size, "lls_port_tdm_entry_t");
    if (lls_tdm == NULL) {
        soc_cm_sfree(unit,iarb_tdm);
        return SOC_E_MEMORY;
    }
    sal_memset(lls_tdm,0,lls_tdm_size);

    for (index = 0; index < new_tdm_size; index++) {
        soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm[index], PORT_NUMf,
                                        new_tdm[index]);
    }
    SOC_IF_ERROR_RETURN(soc_mem_write_range(unit, tdm_table[new_tdm_no], MEM_BLOCK_ALL, 0,
                        new_tdm_size, iarb_tdm));
    soc_cm_sfree(unit,iarb_tdm);

    for (index = 0; index < new_tdm_size/2; index++) {
         soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index], 
                                       PORT_ID_0f, new_tdm[index*2]);
         if ( new_tdm[index*2] <= 41) {
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index], 
                                            PORT_ID_0_ENABLEf, 1);
         } else {
              LOG_VERBOSE(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "IDLE SLOTs so PORT_ID_0_ENABLEf=0 for index=%d\n"),
                                      index));
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index], 
                                            PORT_ID_0_ENABLEf, 0);
         }
         soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index],     
                                       PORT_ID_1f, new_tdm[(index*2) + 1]);
         if ( new_tdm[(index*2)+1] <= 41) {
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index],   
                                            PORT_ID_1_ENABLEf, 1);
         } else {
              LOG_VERBOSE(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                                      "IDLE SLOTs so PORT_ID_1_ENABLEf=0 for index=%d\n"),
                           index));
              soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index],   
                                            PORT_ID_1_ENABLEf, 0);
         }
    }
    if (new_tdm_size % 2) {
        LOG_CLI((BSL_META_U(unit,
                            "ODD TDM SIZE \n")));
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index*2], 
                                      PORT_ID_0_ENABLEf, 1);
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[index*2],     
                                      PORT_ID_0f, new_tdm[(index*2)]);
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[(index*2)+1], 
                                      PORT_ID_1_ENABLEf, 0);
        soc_LLS_PORT_TDMm_field32_set(unit, &lls_tdm[(index*2)+1],     
                                      PORT_ID_1f, 0);
        index++;
    }
    SOC_IF_ERROR_RETURN(soc_mem_write_range(unit, LLS_PORT_TDMm, MEM_BLOCK_ALL,
                        new_tdm_no*128, (new_tdm_no*128) + index, 
                        lls_tdm));
    soc_cm_sfree(unit,lls_tdm);


    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, 
                      wrap_ptr[new_tdm_no],new_tdm_size -1);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, SELECT_TDMf, new_tdm_no);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));
    if (bsl_check(bslLayerSoc, bslSourceCommon, bslSeverityVerbose, unit)) {
        kt2_tdm_display(unit,new_tdm,new_tdm_size,
                        bcm56450_tdm_info[cfg_num].row,
                        bcm56450_tdm_info[cfg_num].col);
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFG_SWITCHr(unit, 1));
    if ((SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM)) {
        SOC_IF_ERROR_RETURN(READ_LLS_TDM_CAL_CFGr(unit, &rval));
        soc_reg_field_set(unit, LLS_TDM_CAL_CFGr, &rval,
                          CURRENT_CALENDARf,new_tdm_no);
        SOC_IF_ERROR_RETURN(WRITE_LLS_TDM_CAL_CFGr(unit, rval));
    }
    do {
        SOC_IF_ERROR_RETURN(READ_LLS_TDM_CAL_CFGr(unit, &rval));
        sal_udelay(100);
        if (soc_reg_field_get(unit, LLS_TDM_CAL_CFGr, rval, 
                              CURRENT_CALENDARf) == new_tdm_no) {
            break;
        }
    } while (iter++ < 100000);
    if (iter >= 100000) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "LLS Calendar switch failed !!\n")));
        return SOC_E_INTERNAL;
    }
    old_tdm_no[unit] = new_tdm_no;
#if 1
    soc_katana2_save_tdm_pos(unit, new_tdm_size,new_tdm);
#endif

    return SOC_E_NONE;
}
static 
void soc_katana2_save_tdm_pos(int unit, uint8 new_tdm_size,uint32 *new_tdm)
{
    uint8 pos=0;
    uint8 port=0;
    uint8 mxqblock=0;
    uint8 total_slots=0;
    sal_memset(kt2_tdm_pos_info,0,sizeof(kt2_tdm_pos_info));
    for (pos=0;pos < new_tdm_size ; pos++) {
         port= new_tdm[pos];
         if ((port == KT2_IDLE) || (port == KT2_IDLE1) || 
             (port == KT2_LPBK_PORT) || (port == KT2_CMIC_PORT) /* ||
             (port == KT2_OLP_PORT) */) { /* QUICKTURN:ATTN */
              continue;
         }
         mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
         total_slots = kt2_tdm_pos_info[mxqblock].total_slots;
         kt2_tdm_pos_info[mxqblock].pos[total_slots]=pos;
         kt2_tdm_pos_info[mxqblock].total_slots++;
    }
    sal_memcpy(kt2_current_tdm,new_tdm,new_tdm_size*sizeof(new_tdm[0]));
    old_tdm_no[unit]=0;
    kt2_current_tdm_size=new_tdm_size;
}

static soc_error_t 
_soc_katana2_tdm_feasibility_check(int unit, soc_port_t port, int speed,
                                   uint8 *mxqblock, uint8 *sub_port,
                                   uint8 *min_tdm_cycles)
{
    uint8  mxqblock_local=0;
    uint8  sub_port_local=0;
    uint32 speed_index=0;
    soc_field_t wc_xfi_mode_sel_fld[]={WC0_8_XFI_MODE_SELf,WC1_8_XFI_MODE_SELf};
    uint32      wc_8_xfi_mode_sel_val = 0;
    uint32      top_misc_control_1_val = 0;
    if (kt2_tdm_update_flag == 0) {
        return SOC_E_NONE;
    }
    SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(unit,port,
                                                      &mxqblock_local));
    sub_port_local = (*kt2_port_to_mxqblock_subports[unit])[port-1]; 
    switch(speed) {
    case 1000:
        speed_index=0;
        break;
    case 2500:
        speed_index=2;
        break;
    case 10000:
        speed_index=3;
        break;
    case 13000:
        speed_index=4;
        break;
    case 21000:
        speed_index=6;
        break;
    default:
        LOG_CLI((BSL_META_U(unit,
                            "Check:Invalid Speed:%d \n"), speed));
        return SOC_E_CONFIG;
    }
    if (kt2_current_tdm_cycles_info[speed_index].min_tdm_cycles == 0) {
        LOG_CLI((BSL_META_U(unit,
                            "Check:Invalid Minimum TDM Cycles=0 \n")));
        return SOC_E_CONFIG;
    }
    if (kt2_tdm_pos_info[mxqblock_local].total_slots == 0) {
        if (((mxqblock_local == 8) || (mxqblock_local == 9)) &&
            ((sub_port_local == 1) || (sub_port_local == 3))) {
             /*Need To Check XFI Mode then */
             SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(
                                     unit,&top_misc_control_1_val));
             wc_8_xfi_mode_sel_val = soc_reg_field_get(
                                     unit, TOP_MISC_CONTROL_1r,
                                     top_misc_control_1_val,
                                     wc_xfi_mode_sel_fld[mxqblock_local-8]);
             if (wc_8_xfi_mode_sel_val == 0) {
                 LOG_CLI((BSL_META_U(unit,
                                     "Check:Total Slots in corresponding"
                                     " MXQBlock=%d is zero \n"), mxqblock_local));
                 return SOC_E_CONFIG;
             }
             mxqblock_local -= 2;
             sub_port_local  -= 1;
             if (kt2_tdm_pos_info[mxqblock_local].total_slots ==0) {
                 LOG_CLI((BSL_META_U(unit,
                                     "Check:Total Slots in corresponding"
                                     " MXQBlock=%d is zero \n"), mxqblock_local));
                 return SOC_E_CONFIG;
             }
        } else {
            LOG_CLI((BSL_META_U(unit,
                                "Check: Total Slots in corresponding MXQBlock=%d"
                                " is zero \n"), mxqblock_local));
            return SOC_E_CONFIG;
        }
    }
    if(mxqblock != NULL) {
       *mxqblock = mxqblock_local;
    }
    if(sub_port != NULL) {
       *sub_port = sub_port_local;
    }
    if(min_tdm_cycles != NULL) {
       *min_tdm_cycles = kt2_current_tdm_cycles_info[speed_index].
                         min_tdm_cycles; 
    }
    return SOC_E_NONE;
}

int
_soc_katana2_perq_flex_counters_init(int unit, uint32 drop_mask)
{
    _soc_katana2_counter_info_t *counter_info;
    uint32 rval;
    int index, field_index, i, j, i_max = 3, j_max = 16;
    int flags = 0, num_elem = 0, enq_stats = 0;
    int counter_index = 0, elem_size = 4, size = 0;
    _soc_katana2_counter_type_t type = _SOC_COUNTER_TYPE_MAX;
    soc_counter_non_dma_id_t non_dma_id;
    _sb2_cosq_counter_mem_map_t *mem_map;
    soc_reg_t   dtype_reg[] = {
                                CTR_DEQ_DTYPE_TBL0r,
                                CTR_DEQ_DTYPE_TBL1r,
                                CTR_DEQ_DTYPE_TBL2r
                              };
    soc_field_t dtype_field[] = {
                                  DTYPE0f, DTYPE1f, DTYPE2f, 
                                  DTYPE3f, DTYPE4f, DTYPE5f, 
                                  DTYPE6f, DTYPE7f, DTYPE8f, 
                                  DTYPE9f, DTYPE10f, DTYPE11f,
                                  DTYPE12f, DTYPE13f,DTYPE14f,
                                  DTYPE15f
                                };
    soc_field_t act_field[3] = {ACTIVE0f, ACTIVE1f, ACTIVE2f};
    soc_field_t seg_field[3] = {SEG0f, SEG1f, SEG2f};
    soc_sb2_cosq_counter_mem_map_get(unit, &num_elem, &mem_map);

    /* Setup MMU counter pool segment start address, consider each 1K block
       as separate segment */
    for (i = 0; i < 12; i++) {
        if ((!soc_feature(unit, soc_feature_cosq_gport_stat_ability) &&
            ((i % 4) != 0)) ||
            ((soc_feature(unit, soc_feature_counter_toggled_read) &&
            (i == 8)))) {
            /*
             * Create 3 segments each with 4K counters
             * Seg0(total enq drop pkts) seg_start address 0
             * Seg4(red enq drop pkts)  seg_start address 4 * 1024
             * Seg8(deq stats)) seg_start_address 8 * 1024
             */
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, CTR_SEGMENT_STARTr, &rval, SEG_STARTf, (i * 1024));
        SOC_IF_ERROR_RETURN
            (soc_reg32_set(unit, CTR_SEGMENT_STARTr,REG_PORT_ANY, i, rval));
    }

    /* Default Configuration */
    /* Cosq_stats -
     * CTR_FLEX_COUNT_0 = Total ENQ discarded
     * CTR_FLEX_COUNT_4  = Red ENQ discarded
     * CTR_FLEX_COUNT_8  = Total DEQ
     */

    /* Cosq_gport_stats -
     * CTR_FLEX_COUNT_1 = Total ENQ Accepted
     * CTR_FLEX_COUNT_2 = Green ENQ discarded
     * CTR_FLEX_COUNT_3 = Yellow ENQ discarded
     * CTR_FLEX_COUNT_5 = Green ENQ Accepted
     * CTR_FLEX_COUNT_6 = Yellow ENQ Accepted
     * CTR_FLEX_COUNT_7 = Red ENQ Accepted
     */

    counter_info = _soc_katana2_counter_info;

    /* reset the previously configured registers*/
    rval = 0;
    for ( i = 0; i < 3; i++) {
        soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, act_field[i], 0);
        soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, seg_field[i], 0);
        SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, CTR_ENQ_STATS_CFGr,REG_PORT_ANY,0, rval));
        if (i < 2) {
            soc_reg_field_set(unit, CTR_DEQ_STATS_CFGr, &rval, act_field[i], 0);
            soc_reg_field_set(unit, CTR_DEQ_STATS_CFGr, &rval, seg_field[i], 0);
            SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, CTR_DEQ_STATS_CFGr, REG_PORT_ANY,0 , rval));
        }
    }

    size = (sizeof(_soc_katana2_counter_info) / sizeof(_soc_katana2_counter_info[0]));
    /*intializing the segment in counter info */
    for ( i = 0; i < size; i++) {
        _soc_katana2_counter_info[i].segment = 0;
    }

    for (counter_index = 0; counter_index < num_elem; counter_index+=elem_size) {

        non_dma_id = mem_map[counter_index].non_dma_id;
        field_index = counter_index/elem_size;
        rval = 0;
        if ((non_dma_id == SOC_COUNTER_NON_DMA_COSQ_DROP_PKT)||
                (non_dma_id == SOC_COUNTER_NON_DMA_COSQ_ACCEPT_PKT)) {
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, act_field[field_index], 1);
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, seg_field[field_index], counter_index);
        }
        switch (non_dma_id){
            case SOC_COUNTER_NON_DMA_COSQ_DROP_PKT:
                type = _SOC_COUNTER_TYPE_DROP_ENQ;
                for ( i = _SOC_COUNTER_TYPE_DROP_ENQ_GREEN;
                        i <= _SOC_COUNTER_TYPE_DROP_ENQ_RED; i++) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_set(unit, CTR_ENQ_STATS_CFGr,
                                       REG_PORT_ANY,
                                       counter_info[i].index,
                                       rval));
                    flags |= (1 << i);
                }
                break;
            case SOC_COUNTER_NON_DMA_COSQ_ACCEPT_PKT:
                type = _SOC_COUNTER_TYPE_ACCEPT_ENQ;
                for ( i = _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN;
                        i <= _SOC_COUNTER_TYPE_ACCEPT_ENQ_RED; i++) {
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_set(unit, CTR_ENQ_STATS_CFGr,
                                       REG_PORT_ANY,
                                       counter_info[i].index,
                                       rval));
                    flags |= (1 << i);
                }
                break;
            case SOC_COUNTER_NON_DMA_COSQ_DROP_PKT_GREEN:
                type = _SOC_COUNTER_TYPE_DROP_ENQ_GREEN;
                break;

            case SOC_COUNTER_NON_DMA_COSQ_DROP_PKT_RED:
                type = _SOC_COUNTER_TYPE_DROP_ENQ_RED;
                break;

            case SOC_COUNTER_NON_DMA_COSQ_DROP_PKT_YELLOW:
                type = _SOC_COUNTER_TYPE_DROP_ENQ_YELLOW;
                break;

            case SOC_COUNTER_NON_DMA_COSQ_ACCEPT_PKT_GREEN:
                type = _SOC_COUNTER_TYPE_ACCEPT_ENQ_GREEN;
                break;

            case SOC_COUNTER_NON_DMA_COSQ_ACCEPT_PKT_RED:
                type = _SOC_COUNTER_TYPE_ACCEPT_ENQ_RED;
                break;

            case SOC_COUNTER_NON_DMA_COSQ_ACCEPT_PKT_YELLOW:
                type = _SOC_COUNTER_TYPE_ACCEPT_ENQ_YELLOW;
                break;

            case SOC_COUNTER_NON_DMA_EGR_PERQ_XMT_PKT:
                type = _SOC_COUNTER_TYPE_ACCEPT_DEQ;
                /* enable deq stats */
                for (i = 0; i < i_max; i++) {
                    rval = 0;
                    for (j = 0; j < j_max; j++) {
                        if ((dtype_reg[i] == CTR_DEQ_DTYPE_TBL2r) && (j > 9)) {
                            continue;
                        }
                        soc_reg_field_set(unit, dtype_reg[i], &rval, dtype_field[j], 2);
                    }
                    SOC_IF_ERROR_RETURN
                        (soc_reg32_set(unit, dtype_reg[i], REG_PORT_ANY, 0, rval));
                }
                /* set deq stats config */
                rval = 0;
                index = counter_info[type].index;
                soc_reg_field_set(unit, CTR_DEQ_STATS_CFGr, &rval, ACTIVE0f, 1);
                soc_reg_field_set(unit, CTR_DEQ_STATS_CFGr, &rval, SEG0f, counter_index);
                SOC_IF_ERROR_RETURN
                    (soc_reg32_set(unit, CTR_DEQ_STATS_CFGr, REG_PORT_ANY, index, rval));

                enq_stats++;
                break;
            default:
                /*should not reach here*/
                break;
        }

        if (type < size) {
            _soc_katana2_counter_info[type].segment = counter_index;
        }
        if ((type >= _SOC_COUNTER_TYPE_DROP_ENQ_GREEN)
                && (type <= _SOC_COUNTER_TYPE_ACCEPT_ENQ_RED)){

            rval = 0;
            index = counter_info[type].index;
            if (flags & (1 << type)) {
               SOC_IF_ERROR_RETURN
                (soc_reg32_get(unit, CTR_ENQ_STATS_CFGr,
                               REG_PORT_ANY, index, &rval));
            }
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, act_field[field_index-enq_stats], 1);
            soc_reg_field_set(unit, CTR_ENQ_STATS_CFGr, &rval, seg_field[field_index-enq_stats], counter_index);
            SOC_IF_ERROR_RETURN
                (soc_reg32_set(unit, CTR_ENQ_STATS_CFGr,
                               REG_PORT_ANY,
                               counter_info[type].index,
                               rval));
        }
    }
    /* This is set to 1 so that we count only thdo drops in the out drops*/
    SOC_IF_ERROR_RETURN(READ_THDO_DROP_CTR_CONFIGr(unit, &rval));

    /*drop mask eliminates the packet drop counts for masked out drop types.*/
    soc_reg_field_set(unit, THDO_DROP_CTR_CONFIGr, &rval, OP_DROP_MASKf,drop_mask);
    soc_reg_field_set(unit, THDO_DROP_CTR_CONFIGr, &rval, OP_CNT_CFGf, 1);

    SOC_IF_ERROR_RETURN(WRITE_THDO_DROP_CTR_CONFIGr(unit, rval));

    return SOC_E_NONE;
}

soc_error_t 
soc_katana2_tdm_feasibility_check(int unit, soc_port_t port, int speed)
{
    return _soc_katana2_tdm_feasibility_check(unit, port, speed,NULL,NULL,NULL);
}
soc_error_t 
soc_katana2_update_tdm(int unit, soc_port_t port, int speed)
{
    uint8  mxqblock=0;
    uint8  sub_port=0;
    uint8  min_tdm_cycles=0;
    uint8  available_tdm_slots=0;
    uint32 *new_tdm = NULL;
    uint8  spacing=0;
    uint8  loop=0;
    uint8  pos=0;
    if (kt2_tdm_update_flag == 0) {
        return SOC_E_NONE;
    }
    SOC_IF_ERROR_RETURN(_soc_katana2_tdm_feasibility_check(
                        unit, port, speed, 
                        &mxqblock , &sub_port,&min_tdm_cycles));
    if (min_tdm_cycles == 0) {
        /*Shouldn't have been here.. */
        return SOC_E_INTERNAL;
    }
    new_tdm = soc_cm_salloc(unit, 256 * sizeof(uint32),
                                         "oob new_tdm");
    if (new_tdm == NULL) {
        return BCM_E_MEMORY;
    }

    available_tdm_slots=kt2_tdm_pos_info[mxqblock].total_slots;
    sal_memcpy(&new_tdm[0],&kt2_current_tdm[0],
               kt2_current_tdm_size *sizeof(kt2_current_tdm[0]));
    spacing = available_tdm_slots / min_tdm_cycles;
    for (loop=0; loop < available_tdm_slots; loop++) {
         pos = kt2_tdm_pos_info[mxqblock].pos[loop];
         if (loop % spacing == 0) {
             new_tdm[pos]= port;
         } else {
             new_tdm[pos]= KT2_IDLE;
         }
    }
    soc_katana2_reconfigure_tdm(unit,kt2_current_tdm_size,new_tdm); 
    sal_memcpy(kt2_current_tdm,new_tdm,
               kt2_current_tdm_size*sizeof(new_tdm[0]));
    soc_cm_sfree(unit, new_tdm);
    return SOC_E_NONE;
}
soc_error_t soc_katana2_get_port_mxqblock(
            int unit, soc_port_t port,uint8 *mxqblock)
{
   if (!((port >=1) && (port <= 40))) {
       return SOC_E_PORT;
   }
   *mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
   return SOC_E_NONE; 
}
soc_error_t soc_katana2_get_core_port_mode(
            int unit,soc_port_t port,bcmMxqCorePortMode_t *mode)
{
   uint8      mxqblock = 0;
   uint8      loop =0;
   uint8      mxqport_used = 0;

   SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(unit,port,&mxqblock));
   for(loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
       if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                            (*kt2_mxqblock_ports[unit])[mxqblock][loop])) {
           mxqport_used++;
       } 
   }
   switch(mxqport_used){
   case 0: return SOC_E_PARAM;
   case 1: *mode=bcmMxqCorePortModeSingle; /* 0=SINGLE */
           break; 
   case 2: *mode=bcmMxqCorePortModeDual;   /* 1=DUAL   */
           break; 
   case 3: 
   case 4: *mode=bcmMxqCorePortModeQuad;   /* 2=QUAD   */
           break;
   }
   return SOC_E_NONE; 
}
soc_error_t 
soc_katana2_get_phy_connection_mode(int unit,soc_port_t port,int mxqblock,
                                    bcmMxqConnection_t *connection)
{
   /* port is not being used..Might remove it later */

   soc_field_t wc_xfi_mode_sel_fld[]={WC0_8_XFI_MODE_SELf,WC1_8_XFI_MODE_SELf};
   uint32      wc_8_xfi_mode_sel_val = 0;
   uint32      top_misc_control_1_val = 0;


   if (mxqblock <= 5) {   /* MXQPORT is connected to Unicore */
       *connection=bcmMqxConnectionUniCore;
       return SOC_E_NONE; 
   } 
   if ((mxqblock >= 6) && (mxqblock <= 7)) {
       /*Need To Check XFI Mode then */
       if (!(SOC_CONTROL(unit)->soc_flags & SOC_F_INITED)) {
           /* Not Initialized yet so OK to return UNICORE */
           *connection=bcmMqxConnectionUniCore;
           return SOC_E_NONE; 
       }
       SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(
                                             unit,&top_misc_control_1_val));
       wc_8_xfi_mode_sel_val = soc_reg_field_get(
                                       unit, TOP_MISC_CONTROL_1r,
                                       top_misc_control_1_val,
                                       wc_xfi_mode_sel_fld[mxqblock-6]);
       if (wc_8_xfi_mode_sel_val) {
           *connection=bcmMqxConnectionWarpCore;
       } else {     
           *connection=bcmMqxConnectionUniCore;
       }
       return SOC_E_NONE; 
   }
   if ((mxqblock >= 8) && (mxqblock <= 9)) {/*MXQPORT is connected to Warpcore*/
       *connection=bcmMqxConnectionWarpCore;
       return SOC_E_NONE; 
   } 
   return SOC_E_PARAM; 
}
soc_error_t soc_katana2_get_phy_port_mode(
            int unit, soc_port_t port,int speed, bcmMxqPhyPortMode_t *mode)
{
   int mxqblock=0;
   bcmMxqConnection_t connection;
   soc_info_t *si=&SOC_INFO(unit);
   int lanes = 0;
   phy_ctrl_t *int_pc;

   if (!((port >=1) && (port <= 40))) {
       return SOC_E_PORT;
   }
   if (!SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
       return SOC_E_PORT;
   }
   si = &SOC_INFO(unit);
   SOC_IF_ERROR_RETURN(_bcm_kt2_port_lanes_get(unit, port, &lanes));
   int_pc = INT_PHY_SW_STATE(unit, port);
   /* If speed is less than 2.5G, irrespective of unicore,warpcore,phy_mode 
      will be zero */
   if (speed <= 2500) {
       /* Set PHY_PORT_MODE to dual port mode when dual port speed is 1G or 2.5G at 6.25G VCO */
       if ((lanes == 2) && soc_property_port_get(unit, port, spn_SERDES_1000X_AT_6250_VCO, 0)) {
           *mode = bcmMxqPhyPortModeDual;
           if (int_pc) {
               int_pc->phy_mode = PHYCTRL_SINGLE_LANE_IN_DUAL_PORT_MODE;
           }
       } else {
           *mode = bcmMxqPhyPortModeQuad;
           if (int_pc) {
               int_pc->phy_mode = PHYCTRL_ONE_LANE_PORT;
           }
       }

       return SOC_E_NONE; 
   }

   mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
   SOC_IF_ERROR_RETURN(soc_katana2_get_phy_connection_mode(
                       unit,port,mxqblock,&connection));
   switch(connection) {
   case bcmMqxConnectionUniCore:
        if ((speed == 10000) || (speed==12000) || (speed==13000)) {
             *mode=bcmMxqPhyPortModeSingle;
             return SOC_E_NONE; 
        }
        break;
   case bcmMqxConnectionWarpCore:
        if (SOC_IS_KATANA2(unit) && SAL_BOOT_QUICKTURN) {
                if ((speed == 10000)) {
                     if (SOC_PBMP_MEMBER(si->linkphy_pbm, port)) { 
                         LOG_CLI((BSL_META_U(unit,
                                             "QUICKTURN:ATTN:LinkPhyPortDualMode")));
                     } else {
                         LOG_CLI((BSL_META_U(unit,
                                             "QUICKTURN:ATTN:NonLinkPhyPortDualMode")));
                     }
                     *mode=bcmMxqPhyPortModeDual;
                     if (int_pc) {
                         int_pc->phy_mode = PHYCTRL_DUAL_LANE_PORT;
                     }
                     return SOC_E_NONE; 
                }
            /* } */
        }
        if ((speed == 12000) || (speed==13000) || (speed==15000) || (speed==16000) ||
            (speed == 20000) || (speed==21000)) {
             *mode=bcmMxqPhyPortModeSingle;
             if (int_pc) {
                 int_pc->phy_mode = PHYCTRL_QUAD_LANE_PORT;
             }
             return SOC_E_NONE; 
        }
        if ((speed == 10000)) {
             *mode=bcmMxqPhyPortModeQuad;
             if (int_pc) {
                 int_pc->phy_mode = PHYCTRL_ONE_LANE_PORT;
             }
             return SOC_E_NONE; 
        }
        break;
   }
   return SOC_E_CONFIG; 
}
void 
soc_katana2_pbmp_init(int unit, kt2_pbmp_t kt2_pbmp)
{
    int port;
    soc_pbmp_t          my_pbmp_xport_xe;
    soc_pbmp_t          my_pbmp_xport_ge;
    soc_port_details_t  *kt2_selected_port_details=NULL;
    int                 kt2_port_details_index=0;
    uint32              loop_index=0;
    uint8               kt2_port_used_flags[40]={0};
    int mxqblock = 0, num_lanes = 0, lane_num = 0;
    bcmMxqCorePortMode_t mode = bcmMxqCorePortModeSingle;
    /* =============================== */
    /* Begin: Unit Specific Allocation */
    /* =============================== */
    if (mxqspeeds[unit] != NULL) {
        sal_free(mxqspeeds[unit]);
        mxqspeeds[unit] = NULL;
    }
    mxqspeeds[unit] =  sal_alloc(sizeof(mxqspeeds_s), "mxqspeed_t");
    if (mxqspeeds[unit] == NULL) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Resource issue: Couldn't allocate memory=%d \n"),
                   (int)sizeof(mxqspeeds_t)));
        return ;
    }
    sal_memcpy(mxqspeeds[unit],mxqspeeds_s,sizeof(mxqspeeds_s));

    if (bcm56450_speed[unit] != NULL) {
        sal_free(bcm56450_speed[unit]);
        bcm56450_speed[unit] = NULL;
    }
    bcm56450_speed[unit] =  sal_alloc(sizeof(kt2_speed_t) * 
                                      (sizeof(bcm56450_speed_s) /
                                       sizeof(bcm56450_speed_s[0])), 
                                      "bcm56450_speed");
    if (bcm56450_speed[unit] == NULL) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Resource issue: Couldn't allocate memory=%d \n"),
                   (int)sizeof(mxqspeeds_t)));
        return ;
    }
    for (loop_index = 0 ; 
         loop_index < sizeof(bcm56450_speed_s ) / 
                      sizeof(bcm56450_speed_s[0]);
                      loop_index++) {
        sal_memcpy(bcm56450_speed[unit][loop_index],
                bcm56450_speed_s[loop_index],
                sizeof(kt2_speed_t));

    }
    if (kt2_port_to_mxqblock[unit] != NULL) {
        sal_free(kt2_port_to_mxqblock[unit]);
        kt2_port_to_mxqblock[unit] = NULL;
    }
    kt2_port_to_mxqblock[unit] =  sal_alloc(sizeof(kt2_port_to_mxqblock_s), "kt2_port_to_mxqblock_t");
    if (kt2_port_to_mxqblock[unit] == NULL) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Resource issue: Couldn't allocate memory=%d \n"),
                   (int)sizeof(kt2_port_to_mxqblock)));
        return ;
    }
    sal_memcpy(kt2_port_to_mxqblock[unit],kt2_port_to_mxqblock_s,sizeof(kt2_port_to_mxqblock_s));
    if (kt2_port_to_mxqblock_subports[unit] != NULL) {
        sal_free(kt2_port_to_mxqblock_subports[unit]);
        kt2_port_to_mxqblock_subports[unit] = NULL;
    }
    kt2_port_to_mxqblock_subports[unit] =  sal_alloc(sizeof(kt2_port_to_mxqblock_subports_s), "kt2_port_to_mxqblock_t");
    if (kt2_port_to_mxqblock_subports[unit] == NULL) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Resource issue: Couldn't allocate memory=%d \n"),
                   (int)sizeof(kt2_port_to_mxqblock_subports)));
        return ;
    }
    sal_memcpy(kt2_port_to_mxqblock_subports[unit],kt2_port_to_mxqblock_subports_s,sizeof(kt2_port_to_mxqblock_subports_s));
    if (kt2_mxqblock_ports[unit] != NULL) {
        sal_free(kt2_mxqblock_ports[unit]);
        kt2_mxqblock_ports[unit] = NULL;
    }
    kt2_mxqblock_ports[unit] =  sal_alloc(sizeof(kt2_mxqblock_ports_s), "kt2_mxqblock_ports_t");
    if (kt2_mxqblock_ports[unit] == NULL) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Resource issue: Couldn't allocate memory=%d \n"),
                   (int)sizeof(kt2_mxqblock_ports)));
        return ;
    }
    sal_memcpy(kt2_mxqblock_ports[unit],kt2_mxqblock_ports_s,sizeof(kt2_mxqblock_ports_s));

    /* =============================== */
    /* End: Unit Specific Allocation */
    /* =============================== */

    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_gport_stack);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq1g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq2p5g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq10g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq13g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_mxq21g);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_xport_xe);
    /* SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_valid); */
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_pp);
    SOC_PBMP_CLEAR(*kt2_pbmp.pbmp_linkphy);
    if (_soc_katana2_get_cfg_num(unit,&kt2_port_details_index) != BCM_E_NONE) {
        LOG_CLI((BSL_META_U(unit,
                            "Retrieved WRONG CFG VALUE =%d\n"), kt2_port_details_index));
        return ;
    }
    if (kt2_port_details_index >= (sizeof(bcm56450_tdm)/
                                   sizeof(bcm56450_tdm[0]))) {
        LOG_CLI((BSL_META_U(unit,
                            "INTERNAL: WRONG CFG VALUE =%d\n"), kt2_port_details_index));
        return ;
    } 
    SOC_INFO(unit).olp_port[0] = 0;
    /* ### NonOLP Port=40 is on MXQ7:Lane3 ### */
    (*kt2_port_to_mxqblock[unit])[40-1]=7;
    (*kt2_port_to_mxqblock_subports[unit])[40-1]=3;
    (*kt2_mxqblock_ports[unit])[7][3]=40;
    /* Make it unavailable for MXQ10:Lane2 */
    (*kt2_mxqblock_ports[unit])[10][2]=0xFF;

    SOC_PBMP_CLEAR(my_pbmp_xport_xe);
    SOC_PBMP_CLEAR(my_pbmp_xport_ge);
    my_pbmp_xport_xe = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_XE,
                                                     my_pbmp_xport_xe);
    my_pbmp_xport_ge = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_GE,
            my_pbmp_xport_ge);

    kt2_selected_port_details = (soc_port_details_t *)
        kt2_port_details[kt2_port_details_index];


    if (kt2_selected_port_details == NULL) {
        LOG_CLI((BSL_META_U(unit,
                            "INTERNAL: Not Supported CFG VALUE =%d\n"), 
                 kt2_port_details_index));
        return ;
    }
    loop_index=0;
    while(kt2_selected_port_details[loop_index].port_speed != 0) {
          LOG_VERBOSE(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "start:%d end:%d incr:%d type:%d speed:%d\n"),
                                  kt2_selected_port_details[loop_index].start_port_no,
                       kt2_selected_port_details[loop_index].end_port_no,
                       kt2_selected_port_details[loop_index].port_incr,
                       kt2_selected_port_details[loop_index].port_type,
                       kt2_selected_port_details[loop_index].port_speed));
          for (port =  kt2_selected_port_details[loop_index].start_port_no;
               port <= kt2_selected_port_details[loop_index].end_port_no;
               port += kt2_selected_port_details[loop_index].port_incr) {
               if (kt2_selected_port_details[loop_index].port_type == 0) {
                   break;
               }
               if (kt2_selected_port_details[loop_index].port_type &
                     GE_PORT) {
                     switch(kt2_selected_port_details[loop_index].port_speed) {
                     case 1000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq1g, port); break;
                     case 2500: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port); break;
                     default:break;/*error */
                     }
               }
               if (kt2_selected_port_details[loop_index].port_type & XE_PORT) {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq10g, port);
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_xport_xe, port);
                   
                   /* In BCM56452 config 8, 20G DXAUI WC1 ethernet port is used.
                    * It has been configured to XE with 20G speed support. Though 
                    * it is conventional to use XE only upto 10G, this is treated 
                    *  as a special case. */
                   if(kt2_selected_port_details[loop_index].port_speed == 20000) {
                       SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq21g, port);
                   }
                   /* In few bcm5645x_configs, WC ports interface type is XFI.
                    * In those configs, if the phy mode and core mode of the
                    * port is operating in single port mode, then port can
                    * operate at 13g speed.
                    */
                   mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
                   if ((mxqblock == 8) || (mxqblock == 9)) {
                       soc_katana2_get_core_port_mode(unit, port, &mode);
                       num_lanes = soc_property_port_get(unit, port,
                                                         spn_PORTGROUP, 0);
                       lane_num = ((*kt2_port_to_mxqblock_subports[unit])
                                   [port-1]);
                       if ((mode == bcmMxqCorePortModeSingle) &&
                           (num_lanes == 4) &&
                           (lane_num == 0)) {
                           SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq13g, port);
                       }
                   }
               }
               if (kt2_selected_port_details[loop_index].port_type & HG_PORT) {
                   if (SOC_PBMP_MEMBER(my_pbmp_xport_xe, port)) {
                       SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_xport_xe, port);
                   } 
                   switch(kt2_selected_port_details[loop_index].port_speed) {
                   case 10000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq10g, port);break;
                   case 13000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq13g, port);break;
                   case 20000:
                   case 21000: SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq21g, port);break;
                   default:break;/*error */
                   }
               }
               if (kt2_selected_port_details[loop_index].port_type & HGL_PORT) {
                   if (SOC_PBMP_MEMBER(my_pbmp_xport_ge, port)) {
                       SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port);
                   } else {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port);
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_gport_stack, port);
               }
               }
               if (kt2_selected_port_details[loop_index].port_type & STK_PORT) {
                   if (!(SOC_PBMP_MEMBER(my_pbmp_xport_xe, port) ||
                         SOC_PBMP_MEMBER(my_pbmp_xport_ge, port))) {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_gport_stack, port);
               }
               }
               /* Currently not taking action on CES,OLP */
               if (kt2_selected_port_details[loop_index].port_type &
                   LPHY_PORT) {
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_linkphy, port);
               }
               if (kt2_selected_port_details[loop_index].port_type & OLP_PORT) {
                   SOC_INFO(unit).olp_port[0] = 1;
                    /* ### OLP Port=40 is on MXQ10:Lane2 ### */
                    (*kt2_port_to_mxqblock[unit])[40-1]=10;
                    (*kt2_port_to_mxqblock_subports[unit])[40-1]=2;
                    /* Make it unavailable for MXQ7:Lane3 */
                    (*kt2_mxqblock_ports[unit])[7][3]=0xFF;
                    /* ### OLP Port is on MXQ10:Lane2 ### */
                    (*kt2_mxqblock_ports[unit])[10][2]=40;
                   SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq2p5g, port); 
               }
               SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_mxq, port);
               kt2_port_used_flags[port-1]=1;
          }
          loop_index++;
      }
      for (port = 1; port <= 40; port++) {
           if (kt2_port_used_flags[port-1] == 0) {
               SOC_PBMP_PORT_REMOVE(*kt2_pbmp.pbmp_valid, port);
           }
      }
      for (port = 0; port < 170; port++) {
           SOC_PBMP_PORT_ADD(*kt2_pbmp.pbmp_pp, port);
      }
}

void
soc_katana2_subport_init(int unit)
{
    soc_port_t port, lp_port, prev_port, pp_port;
    soc_pbmp_t pbmp_subport, pbmp_linkphy;
    soc_pbmp_t pbmp_linkphy_xlp0;
    soc_info_t *si=&SOC_INFO(unit);
    int num_subport = 0, available_subport = 0;
    int port_subport_index_start = 0;
    int port_subport_index_end = 0;
    int first_half_subport_index_max = 0;
    int second_half_subport_index_max = 0;
    int lp_index = 0, lp_block = 0;
    int num_subports_valid = 0;
    int s1_xlp0_index = 0;
    int s1_xlp1_index = 0;
    int num_subports_first_half = 0;
    int num_subports_second_half = 0;
    int rv = SOC_E_NONE;

    SOC_PBMP_CLEAR(pbmp_subport);
    SOC_PBMP_CLEAR(pbmp_linkphy);
    SOC_PBMP_CLEAR(pbmp_linkphy_xlp0);
    /*SOC_PBMP_CLEAR(pbmp_linkphy_xlp1);*/
    SOC_PBMP_CLEAR(si->linkphy_pbm);
    SOC_PBMP_CLEAR(si->lp.bitmap);
    SOC_PBMP_CLEAR(si->linkphy_allowed_pbm);
    SOC_PBMP_CLEAR(si->subtag_pbm);
    SOC_PBMP_CLEAR(si->subtag_allowed_pbm);
    SOC_PBMP_CLEAR(si->subtag.bitmap);
    SOC_PBMP_CLEAR(si->linkphy_pp_port_pbm);
    SOC_PBMP_CLEAR(si->enabled_linkphy_pp_port_pbm);
    SOC_PBMP_CLEAR(si->subtag_pp_port_pbm);
    SOC_PBMP_CLEAR(si->enabled_subtag_pp_port_pbm);
    si->subtag_enabled = 0;
    si->linkphy_enabled = 0;

    for (port = 1; port <= KT2_MAX_PHYSICAL_PORTS; port++) {
        si->port_num_subport[port] = 0;
        si->port_subport_base[port] = 0;
        si->port_linkphy_s1_base[port] = 0;
    }

    pbmp_subport = soc_property_get_pbmp(unit, spn_PBMP_SUBPORT, 0);
    pbmp_linkphy = soc_property_get_pbmp(unit, spn_PBMP_LINKPHY, 0);

    SOC_PBMP_ASSIGN(si->subtag_allowed_pbm, pbmp_subport);
    SOC_PBMP_ASSIGN(si->linkphy_allowed_pbm, pbmp_linkphy);

    if (SOC_PBMP_NOT_NULL(pbmp_subport)) {
        /* All members of pbmp_linkphy should also be
         *  member of pbmp_subport */
        if (SOC_PBMP_NOT_NULL(pbmp_linkphy)) {
            /*
             * Check if pbmp_linkphy members are valid for
             * supporting LinkPHY.
             * For Katana2(BCM56450) port 27 to 34 only support LinkPHY 
             */
            SOC_PBMP_ITER(pbmp_linkphy, port) {
                if (!SOC_REG_PORT_VALID(unit, RXLP_PORT_ENABLEr, port)) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                               "\nCONFIG ERROR\n"
                               "pbmp_linkphy member port %d is invalid for "
                               "LinkPHY support - invalidating "
                               "subtag, linkphy pbmp\n\n"), port));

                    SOC_PBMP_CLEAR(si->subtag_allowed_pbm);
                    SOC_PBMP_CLEAR(si->linkphy_allowed_pbm);
                    return;
                }
                SOC_PBMP_PORT_ADD(si->linkphy_allowed_pbm, port);
            }

            SOC_PBMP_ITER(pbmp_linkphy, port) {
                if (!SOC_PBMP_MEMBER(pbmp_subport, port)) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                               "\nCONFIG ERROR\n"
                               "pbmp_linkphy member port %d is not member of "
                               "pbmp_subport support - invalidating "
                               "subtag, linkphy pbmp\n\n"), port));

                    SOC_PBMP_CLEAR(si->subtag_allowed_pbm);
                    SOC_PBMP_CLEAR(si->linkphy_allowed_pbm);
                    return;
                }
                SOC_PBMP_PORT_REMOVE(si->subtag_allowed_pbm, port);
            }
        }
    } else {
        if (SOC_PBMP_NOT_NULL(pbmp_linkphy)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                       "\nCONFIG ERROR\n"
                       "config variable pbmp_linkphy should be sub-set of "
                       "config variable pbmp_subport\n\n")));
        }
    }

    available_subport = SOC_KT2_MAX_SUBPORTS;
    prev_port = 0;
    si->port_num_subport[prev_port] = 0;
    si->port_subport_base[prev_port] = SOC_KT2_MIN_SUBPORT_INDEX;

    if (SOC_PBMP_NOT_NULL(si->linkphy_allowed_pbm)) {

        /* Constraint:
        * If physical port type is LinkPHY then both the
        * subport base and subport end indices should entirely be
        * either in first half or second half.
        * KT2 can support max 128 subports.
        * So a single LinkPHY port can support maximum 64 subports.
        */
        first_half_subport_index_max =
            SOC_KT2_MIN_SUBPORT_INDEX + SOC_KT2_MAX_LINKPHY_SUBPORTS_PER_PORT - 1;

        second_half_subport_index_max =
            SOC_KT2_MIN_SUBPORT_INDEX + SOC_KT2_MAX_SUBPORTS - 1;

        s1_xlp0_index = 0;
        s1_xlp1_index = SOC_KT2_MAX_SUBPORTS;

        /* Iterate through LinkPHY members first and reserve subport indices */
        SOC_PBMP_ITER(si->linkphy_allowed_pbm, port) {
            if (port < SOC_MAX_NUM_PORTS) {
                num_subport =
                    soc_property_port_get(unit, port, spn_NUM_SUBPORTS, 0);

                if (num_subport > SOC_KT2_MAX_LINKPHY_SUBPORTS_PER_PORT) {
                    num_subport = SOC_KT2_MAX_LINKPHY_SUBPORTS_PER_PORT;
                }

                if (num_subport == 0) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                               "\nCONFIG ERROR\n"
                               "num_subports_%d should be non-zero for "
                               "LinkPHY port %d\n\n"), port, port));
                    SOC_PBMP_PORT_REMOVE(si->linkphy_allowed_pbm, port);
                    continue;
                }
                /*
                 * get the MXQ block for the linkphy port
                 */ 
                rv = soc_kt2_linkphy_port_blk_idx_get(unit, port,
                                                      &lp_block,
                                                      &lp_index);
                if (SOC_FAILURE(rv)) {
                    LOG_ERROR(BSL_LS_BCM_SUBPORT,
                              (BSL_META_U(unit,
                             "ERROR: LinkPHY block, "
                             "index get failed for port %d\n"), port));
                    return;
                }


                if (num_subport > available_subport) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                               "\nCONFIG ERROR\n"
                               "num_subports_%d=%d unavailable for "
                               "LinkPHY port\n\n"), port, num_subport));
                    SOC_PBMP_PORT_REMOVE(si->linkphy_allowed_pbm, port);
                    return;
                }

                /*
                 * Assigning PP_PORT for the subports
                 * range is from 42 to 169, which is the
                 * maximum number of logical ports supported.
                 */
                port_subport_index_start =
                    (si->port_subport_base[prev_port] +
                     si->port_num_subport[prev_port]);

                port_subport_index_end =
                    port_subport_index_start + num_subport - 1;

                /*
                 * Maximum number of subports per MXQ block is 64. 
                 */ 
                if (lp_block) {
                    if ((num_subports_second_half + num_subport) <=
                         SOC_KT2_MAX_LINKPHY_SUBPORTS_PER_PORT) {
                         num_subports_second_half += num_subport;
                         num_subports_valid = 1;
                    } 
                } else {
                    if ((num_subports_first_half + num_subport) <= 
                         SOC_KT2_MAX_LINKPHY_SUBPORTS_PER_PORT) {
                         num_subports_first_half += num_subport;
                         num_subports_valid = 1;
                    } 
                }

                LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                            "prevport[%d] num_subport[%d] base[%d]\n"
                           "port[%d] - %d->%d max- f[%d]s[%d]\n"
                           "num_subports_first_half[%d] - num_subport[%d\n"
                           "num_subports_second_half[%d] - num_subport[%d\n"),
                            prev_port, si->port_num_subport[prev_port],
                            si->port_subport_base[prev_port],
                            port,
                            port_subport_index_start,
                            port_subport_index_end,
                            first_half_subport_index_max,
                            second_half_subport_index_max,
                            num_subports_first_half, num_subport,
                            num_subports_second_half, num_subport));

                if (num_subports_valid) {
                    si->port_subport_base[port] = port_subport_index_start;
                    si->port_num_subport[port] = num_subport;
                     LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                 "port_subport_base[%d] - %d->%d "
                                 "max[%d]\n"),port, port_subport_index_start,
                                 port_subport_index_end, 
                                 first_half_subport_index_max));

                    available_subport -= num_subport;
                    num_subports_valid = 0;

                    /* For block0 - MXQ8 s1 nodes 0..127 is used
                    * for block1 - MXQ9 s1 nodes 128..255 is used */
                    if (lp_block) { /* XLP1 (MXQ9) */
                        si->port_linkphy_s1_base[port] = s1_xlp1_index;
                        s1_xlp1_index += si->port_num_subport[port] *
                                         BCM_SUBPORT_CONFIG_MAX_STREAMS;
                    } else { /* XLP0 (MXQ8) */
                        SOC_PBMP_PORT_ADD(pbmp_linkphy_xlp0, port);
                        si->port_linkphy_s1_base[port] = s1_xlp0_index;
                        s1_xlp0_index += si->port_num_subport[port] *
                                         BCM_SUBPORT_CONFIG_MAX_STREAMS;
                    }

                    LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                "\nport[%d] s1_b[%d] num_s[%d] "
                                "xlp0[%d] xlp1[%d]\n\n\n"), 
                                port, si->port_linkphy_s1_base[port],
                                si->port_num_subport[port], s1_xlp0_index,
                                s1_xlp1_index));
                } else {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                               "\nCONFIG ERROR\n"
                               "contiguous num_subport=%d unavailable "
                               "for linkphy port %d\n\n"), num_subport, port));
                    SOC_PBMP_PORT_REMOVE(si->linkphy_allowed_pbm, port);
                    continue;
                }
                prev_port = port;
            }
        } /* end SOC_PBMP_ITER(si->linkphy_allowed_pbm, port) */
    }

    prev_port = 0;
    if (SOC_PBMP_NOT_NULL(si->subtag_allowed_pbm)) {
        /* Iterate through SubTag ports and reserve subport indices */
        SOC_PBMP_ITER(si->subtag_allowed_pbm, port) {
            num_subport =
                soc_property_port_get(unit, port, spn_NUM_SUBPORTS, 0);

            if (num_subport == 0) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                          "\nCONFIG ERROR\n"
                          "num_subports_%d should be non-zero for "
                          "SubTag port %d\n\n"), port, port));
                SOC_PBMP_PORT_REMOVE(si->subtag_allowed_pbm, port);
                continue;
            }

            if (num_subport > available_subport) {
                LOG_ERROR(BSL_LS_SOC_COMMON,
                          (BSL_META_U(unit,
                          "\nCONFIG ERROR\n"
                          "num_subports_%d=%d unavailable for SubTag port\n\n"),
                          port, num_subport));
                SOC_PBMP_PORT_REMOVE(si->subtag_allowed_pbm, port);
                continue;
            }

            port_subport_index_start = si->port_subport_base[prev_port] +
                                       si->port_num_subport[prev_port];

            /* Iterate the LinkPHY ports.
             * Skip the LinkPHY ports for which subports are allocated
             * until we get start index of required free subports
             * or reach end of LinkPHY ports. */

            SOC_PBMP_ITER(si->linkphy_allowed_pbm, lp_port) {
                if (lp_port < SOC_MAX_NUM_PORTS) {
                    if (si->port_num_subport[lp_port]) {
                        if (si->port_subport_base[lp_port] ==
                                                    port_subport_index_start) {
                            /* skip the allocated LinkPHY ports */
                            port_subport_index_start =
                                si->port_subport_base[lp_port] +
                                si->port_num_subport[lp_port];
                            continue;
                        } else if (si->port_subport_base[lp_port] >
                                                    port_subport_index_start) {
                            /* check if there is a big enough subport index
                             * chunk unused, between 2 consecutive LinkPHY
                             * enabled ports, to accomodate required subports */
                            if ((si->port_subport_base[lp_port] -
                                 port_subport_index_start) < num_subport) {
                                /* skip the allocated LinkPHY ports */
                                port_subport_index_start =
                                    si->port_subport_base[lp_port]
                                    + si->port_num_subport[lp_port];
                                continue;
                            }
                        }
                    }
                }
            }

            if (port < SOC_MAX_NUM_PORTS) {
                si->port_subport_base[port] = port_subport_index_start;
                si->port_num_subport[port] = num_subport;

                available_subport -= num_subport;
                prev_port = port;
            }
        } /* end SOC_PBMP_ITER(si->subtag_allowed_pbm, port) */
    }

    /* populate LinkPHY pp_port bitmap */
    SOC_PBMP_ITER(si->linkphy_allowed_pbm, port) {
        if (port < SOC_MAX_NUM_PORTS) {
            for (pp_port = 0; pp_port < si->port_num_subport[port]; pp_port++) {
                SOC_PBMP_PORT_ADD(si->linkphy_pp_port_pbm,
                        pp_port + si->port_subport_base[port]);
                /* Set this port in the enabled bmap by default at init */
                SOC_PBMP_PORT_ADD(si->enabled_linkphy_pp_port_pbm,
                        pp_port + si->port_subport_base[port]);
            }
        }
    }
    /* populate SubTag pp_port bitmap */
    SOC_PBMP_ITER(si->subtag_allowed_pbm, port) {
        if (port < SOC_MAX_NUM_PORTS) {
            for (pp_port = 0; pp_port < si->port_num_subport[port]; pp_port++) {
                SOC_PBMP_PORT_ADD(si->subtag_pp_port_pbm,
                        pp_port + si->port_subport_base[port]);
                /* Set this port in the enabled bmap by default at init */
                SOC_PBMP_PORT_ADD(si->enabled_subtag_pp_port_pbm,
                        pp_port + si->port_subport_base[port]);
            }
        }
    }
    if (SOC_PBMP_NOT_NULL (si->subtag_pp_port_pbm)) {
        si->subtag_enabled = 1;
    }
    if (SOC_PBMP_NOT_NULL (si->linkphy_pp_port_pbm)) {
        si->linkphy_enabled = 1;
    }

    /* Initialize the number of modules */
    si->num_coe_modules = soc_property_get(unit, spn_MODULE_NUM_MODIDS, 1);

    /* Check if the num_mods exceeds max allowed, if so flag an error,
       note that the default of '1' is reserved for front-panel physical
       ports */
    if(si->num_coe_modules > (_BCMI_KT2_MAX_COE_MODULES + 1)) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "\nCONFIG ERROR\n"
                              "Number of modules %d exceeds maximum: %d,"
                              "setting to max \n\n"),
                   si->num_coe_modules, _BCMI_KT2_MAX_COE_MODULES));
        si->num_coe_modules = _BCMI_KT2_MAX_COE_MODULES;
    }

    /* If it is a non default value, note that we are in a
       'coe-stacking-mode', wherein we will be supporing stacking for CoE */
    if(si->num_coe_modules != 1) {
        si->coe_stacking_mode = 1;
        /* Since the first module is reserved for physical-ports, reduce the
           num_coe_modules by 1 */
        si->num_coe_modules--;
    }
}

void
_soc_katana2_ci_init(int unit)
{
    uint32 rval;
    LOG_CLI((BSL_META_U(unit,
                        "QUICKTURN:ATTN \n")));

WRITE_CI_CONFIG1r(unit, 0, 0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.0,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.1,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.1,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.2,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.2,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.3,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.3,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.4,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.4,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.5,  0xf0dcf0dc);
WRITE_CI_CONFIG1r(unit,.5,  0xf0dcf0dc);
WRITE_CI_RESETr(unit,.0,  0x00000004);
WRITE_CI_RESETr(unit,.0,  0x00000002);
WRITE_CI_RESETr(unit,.1,  0x00000004);
WRITE_CI_RESETr(unit,.1,  0x00000002);
WRITE_CI_RESETr(unit,.2,  0x00000004);
WRITE_CI_RESETr(unit,.2,  0x00000002);
WRITE_CI_RESETr(unit,.3,  0x00000004);
WRITE_CI_RESETr(unit,.3,  0x00000002);
WRITE_CI_RESETr(unit,.4,  0x00000004);
WRITE_CI_RESETr(unit,.4,  0x00000002);
WRITE_CI_RESETr(unit,.5,  0x00000004);
WRITE_CI_RESETr(unit,.5,  0x00000002);
WRITE_CI_CONFIG0r(unit,.0,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.0,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.1,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.1,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.2,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.2,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.3,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.3,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.4,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.4,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324ab03);
WRITE_CI_CONFIG2r(unit,.0,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.0,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.1,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.1,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.2,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.2,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.3,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.3,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.4,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.4,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0d4860f0);
WRITE_CI_CONFIG3r(unit,.0,  0x00003451);
WRITE_CI_CONFIG3r(unit,.0,  0x00003451);
WRITE_CI_CONFIG3r(unit,.1,  0x00003451);
WRITE_CI_CONFIG3r(unit,.1,  0x00003451);
WRITE_CI_CONFIG3r(unit,.2,  0x00003451);
WRITE_CI_CONFIG3r(unit,.2,  0x00003451);
WRITE_CI_CONFIG3r(unit,.3,  0x00003451);
WRITE_CI_CONFIG3r(unit,.3,  0x00003451);
WRITE_CI_CONFIG3r(unit,.4,  0x00003451);
WRITE_CI_CONFIG3r(unit,.4,  0x00003451);
WRITE_CI_CONFIG3r(unit,.5,  0x00003451);
WRITE_CI_CONFIG3r(unit,.5,  0x00003451);
WRITE_CI_CONFIG6r(unit,.0,  0x36000214);
WRITE_CI_CONFIG6r(unit,.0,  0x36000214);
WRITE_CI_CONFIG6r(unit,.1,  0x36000214);
WRITE_CI_CONFIG6r(unit,.1,  0x36000214);
WRITE_CI_CONFIG6r(unit,.2,  0x36000214);
WRITE_CI_CONFIG6r(unit,.2,  0x36000214);
WRITE_CI_CONFIG6r(unit,.3,  0x36000214);
WRITE_CI_CONFIG6r(unit,.3,  0x36000214);
WRITE_CI_CONFIG6r(unit,.4,  0x36000214);
WRITE_CI_CONFIG6r(unit,.4,  0x36000214);
WRITE_CI_CONFIG6r(unit,.5,  0x36000214);
WRITE_CI_CONFIG6r(unit,.5,  0x36000214);
WRITE_CI_PHY_STRAPS1r(unit,.0,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.0,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.1,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.1,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.2,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.2,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.3,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.3,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.4,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.4,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.5,  0x0004129b);
WRITE_CI_PHY_STRAPS1r(unit,.5,  0x0004129b);
WRITE_CI_RESETr(unit,.0,  0x00000002);
WRITE_CI_RESETr(unit,.0,  0x00000000);
WRITE_CI_RESETr(unit,.1,  0x00000002);
WRITE_CI_RESETr(unit,.1,  0x00000000);
WRITE_CI_RESETr(unit,.2,  0x00000002);
WRITE_CI_RESETr(unit,.2,  0x00000000);
WRITE_CI_RESETr(unit,.3,  0x00000002);
WRITE_CI_RESETr(unit,.3,  0x00000000);
WRITE_CI_RESETr(unit,.4,  0x00000002);
WRITE_CI_RESETr(unit,.4,  0x00000000);
WRITE_CI_RESETr(unit,.5,  0x00000002);
WRITE_CI_RESETr(unit,.5,  0x00000000);
WRITE_CI_DDR_MR0r(unit,.0,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.0,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.0,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.0,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.0,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.0,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.1,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.1,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.1,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.1,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.1,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.1,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.1,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.1,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.2,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.2,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.2,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.2,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.2,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.2,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.2,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.2,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.3,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.3,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.3,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.3,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.3,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.3,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.3,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.3,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.4,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.4,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.4,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.4,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.4,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.4,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.4,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.4,  0x00010210);
WRITE_CI_DDR_MR0r(unit,.5,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.5,  0x00001b60);
WRITE_CI_DDR_MR0r(unit,.5,  0x00001b60);
WRITE_CI_DDR_MR1r(unit,.5,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.5,  0x00008010);
WRITE_CI_DDR_MR1r(unit,.5,  0x00008010);
WRITE_CI_DDR_MR2r(unit,.0,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.5,  0x00010210);
WRITE_CI_DDR_MR2r(unit,.5,  0x00010210);
WRITE_CI_RESETr(unit,.0,  0x00000000);
WRITE_CI_RESETr(unit,.0,  0x00000004);
WRITE_CI_RESETr(unit,.1,  0x00000000);
WRITE_CI_RESETr(unit,.1,  0x00000004);
WRITE_CI_RESETr(unit,.2,  0x00000000);
WRITE_CI_RESETr(unit,.2,  0x00000004);
WRITE_CI_RESETr(unit,.3,  0x00000000);
WRITE_CI_RESETr(unit,.3,  0x00000004);
WRITE_CI_RESETr(unit,.4,  0x00000000);
WRITE_CI_RESETr(unit,.4,  0x00000004);
WRITE_CI_RESETr(unit,.5,  0x00000000);
WRITE_CI_RESETr(unit,.5,  0x00000004);
sal_sleep( 2);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
sal_sleep( 2);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x04a53603);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x04a53603);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a5360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x04a53603);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x04253603);
sal_sleep( 2);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001810);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00001810);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001810);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00001810);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001420);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001810);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000001c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00001810);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000001c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000012);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000002);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000010);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000010);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000014);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000010);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000064);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000068);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000005c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000064);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000068);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000005c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00a6e001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa0000010);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000064);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x03f1ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000064);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000068);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0001ffff);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000068);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000005c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000004);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000005c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00100000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00100000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xe000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0043f000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xe000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x8000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xe000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000003c);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xa000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000040);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xa000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000040);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0043f000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xa000003c);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000040);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000040);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005a4);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000360);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000560);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000364);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000564);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc00005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000360);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000560);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000364);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000564);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc00005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x0000000a);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005a4);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000360);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000360);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000560);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000003);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000560);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000364);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000364);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000564);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000007);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000564);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800003ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc00005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005ac);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x800005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000238);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0xc0000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.0,  0x80000438);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x800005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000238);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0xc0000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.2,  0x80000438);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00000001);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x800005ac);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000238);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000238);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0xc0000438);
WRITE_CI_DDR_PHY_REG_CTRLr(unit,.4,  0x80000438);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.0,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.1,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.2,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.3,  0x00000000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.4,  0x00300000);
WRITE_CI_DDR_PHY_REG_DATAr(unit,.5,  0x00000000);
sal_sleep( 2);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x05a53603);
WRITE_CI_PHY_CONTROLr(unit,.0,  0x05a5360f);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.1,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x05a53603);
WRITE_CI_PHY_CONTROLr(unit,.2,  0x05a5360f);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.3,  0x0425360f);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x05a53603);
WRITE_CI_PHY_CONTROLr(unit,.4,  0x05a5360f);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x04253603);
WRITE_CI_PHY_CONTROLr(unit,.5,  0x0425360f);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000ce);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000bc);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000ce);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000cf);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008e);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000cf);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000cd);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008f);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000cd);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000cc);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008d);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000cc);
sal_sleep( 2);
WRITE_CI_MRS_CMDr(unit,.0,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.0,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.1,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.1,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.2,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.2,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.3,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.3,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.4,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.4,  0x000000fc);
WRITE_CI_MRS_CMDr(unit,.5,  0x0000008c);
WRITE_CI_MRS_CMDr(unit,.5,  0x000000fc);
sal_sleep( 2);
WRITE_CI_CONFIG0r(unit,.3,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.3,  0x0324aa03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324ab03);
WRITE_CI_CONFIG0r(unit,.5,  0x0324aa03);
WRITE_CI_CONFIG2r(unit,.3,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.3,  0x0c4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0d4860f0);
WRITE_CI_CONFIG2r(unit,.5,  0x0c4860f0);
sal_sleep( 2);
if (READ_CI_CONFIG0r(unit, 3, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG0r, &rval, TWLf, 0xa);
WRITE_CI_CONFIG0r(unit, 3, rval);
if (READ_CI_CONFIG0r(unit, 5, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG0r, &rval, TWLf, 0xa);
WRITE_CI_CONFIG0r(unit, 5, rval);
if (READ_CI_CONFIG2r(unit, 3, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG2r, &rval, TREAD_ENBf, 0xc);
WRITE_CI_CONFIG2r(unit, 3, rval);
if (READ_CI_CONFIG2r(unit, 3, &rval) != SOC_E_NONE) {
    return;
}
soc_reg_field_set(unit, CI_CONFIG2r, &rval, TREAD_ENBf, 0xc);
WRITE_CI_CONFIG2r(unit, 3, rval);
sal_sleep( 2);

}

STATIC int
_katana2_ledup_init(int unit)
{
    uint32 rval = 0;
    int ix;
    int pval1, pval2, pval3, pval4;
    struct led_remap {
       uint32 reg_addr;
       uint32 port0;
       uint32 port1;
       uint32 port2;
       uint32 port3;
    } led0_remap[] = {
        {CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r,
         REMAP_PORT_0f,REMAP_PORT_1f,REMAP_PORT_2f,REMAP_PORT_3f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r,
         REMAP_PORT_4f,REMAP_PORT_5f,REMAP_PORT_6f,REMAP_PORT_7f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r,
         REMAP_PORT_8f,REMAP_PORT_9f,REMAP_PORT_10f,REMAP_PORT_11f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r,
         REMAP_PORT_12f,REMAP_PORT_13f,REMAP_PORT_14f,REMAP_PORT_15f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r,
         REMAP_PORT_16f,REMAP_PORT_17f,REMAP_PORT_18f,REMAP_PORT_19f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r,
         REMAP_PORT_20f,REMAP_PORT_21f,REMAP_PORT_22f,REMAP_PORT_23f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r,
         REMAP_PORT_24f,REMAP_PORT_25f,REMAP_PORT_26f,REMAP_PORT_27f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r,
         REMAP_PORT_28f,REMAP_PORT_29f,REMAP_PORT_30f,REMAP_PORT_31f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r,
         REMAP_PORT_32f,REMAP_PORT_33f,REMAP_PORT_34f,REMAP_PORT_35f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r,
         REMAP_PORT_36f,REMAP_PORT_37f,REMAP_PORT_38f,REMAP_PORT_39f}/*,
        {CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r,
         REMAP_PORT_40f,REMAP_PORT_41f,REMAP_PORT_42f,REMAP_PORT_43f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_44_47r,
         REMAP_PORT_44f,REMAP_PORT_45f,REMAP_PORT_46f,REMAP_PORT_47f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_48_51r,
         REMAP_PORT_48f,REMAP_PORT_49f,REMAP_PORT_50f,REMAP_PORT_51f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_52_55r,
         REMAP_PORT_52f,REMAP_PORT_53f,REMAP_PORT_54f,REMAP_PORT_55f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_56_59r,
         REMAP_PORT_56f,REMAP_PORT_57f,REMAP_PORT_58f,REMAP_PORT_59f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_60_63r,
         REMAP_PORT_60f,REMAP_PORT_61f,REMAP_PORT_62f,REMAP_PORT_63f}*/
    };

    /* initialize the led remap register settings. 
     * port 0 entry will not be used for easy index of the physical port starting 1
     */
     
    for (ix = 0; ix < sizeof(led0_remap)/sizeof(led0_remap[0]); ix++) {
        pval1 = ((10-ix) * 4);
        pval2 = pval1 - 1;
        pval3 = pval1 - 2;
        pval4 = pval1 - 3;

        rval = 0;
        soc_reg_field_set(unit, led0_remap[ix].reg_addr, &rval, 
                         led0_remap[ix].port0, pval1);
        soc_reg_field_set(unit, led0_remap[ix].reg_addr, &rval, 
                         led0_remap[ix].port1, pval2);
        soc_reg_field_set(unit, led0_remap[ix].reg_addr, &rval, 
                         led0_remap[ix].port2, pval3);
        soc_reg_field_set(unit, led0_remap[ix].reg_addr, &rval, 
                         led0_remap[ix].port3, pval4);
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN
            (soc_pci_write(unit, 
                soc_reg_addr(unit, led0_remap[ix].reg_addr, REG_PORT_ANY, 0), 
                rval));
    }

    /* Do Raw schan ops because Not all ports may be enabled */
    {
        /* XLPORT_LED_CHAIN_CONFIGr */
        if (!SAL_BOOT_BCMSIM) {
            _soc_reg32_set(unit, 5, 0, (0x2022b00), (0x00000006));
        }
        _soc_reg32_set(unit, 6, 0, (0x2022b00), (0x00000006));
    }

    /* initialize the UP0 data ram */
    rval = 0;
    for (ix = 0; ix < 256; ix++) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit,ix, rval));
    }

    /* Apply LEDUP delays. */
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_LEDUP0_CTRLr(unit, &rval));
    soc_reg_field_set(unit,CMIC_LEDUP0_CTRLr,
                      &rval, LEDUP_SCAN_START_DELAYf, 0x6);
    soc_reg_field_set(unit,CMIC_LEDUP0_CTRLr,
                      &rval, LEDUP_SCAN_INTRA_PORT_DELAYf, 0x5);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_CTRLr(unit, rval));

    return SOC_E_NONE;  
}

int _soc_katana2_misc_init(int unit)
{
    soc_info_t *si;
    uint32 rval;
    uint32 xport_port_enable_reg=0;
    uint32 ext_pbmp_count=0;
    pbmp_t ext_pbmp;
#if 0
    uint32 mxq6_7_rval=0;
#endif
    uint32 entry[SOC_MAX_MEM_WORDS], ing_entry[SOC_MAX_MEM_WORDS];
    txlp_port_addr_map_table_entry_t txlp_port_addr_map_table_entry={{0}};
    uint32                start_addr=0;
    uint32                end_addr=0;
    uint8                 mxqblock_port = 0;
    soc_pbmp_t pbmp, my_pbmp_xport_xe;
    int port, blk_port, blk;
    int count;
    uint64 reg64;
    uint16 dev_id;
    uint8 rev_id;
    int i, val = 0;
    soc_field_t fields[3];
    uint32 values[3];
    int rv;
    int phy_speed = 0;
    bcmMxqCorePortMode_t core_mode = 0;
    bcmMxqPhyPortMode_t  phy_mode;
    int                  any_phy_port=0; 
    uint8                loop=0;             
    int                  cfg_num=0; 
    uint8                mxqblock=0;
    uint8                port_count=0;
    uint32               xfi_mode[2]={0};
    uint8                wc_10g_21g_sel=0;
    uint32               port_speed=0;
    uint32               any_port_speed=0;
    uint32               num_cis = 0;
    uint32               ddr3_clock_mhz = 0;
    uint32               num_rows = 32768;
    uint32               ddr3_mem_grade = 0;
    int my_modid_list[KT2_MAX_MODIDS_PER_TRANSLATION_TABLE] = 
        { 0, 0, 0, 0 };
    int my_modid_valid[KT2_MAX_MODIDS_PER_TRANSLATION_TABLE] = 
        { 1, 0, 0, 0 };
    int my_modid_port_base_ptr[KT2_MAX_MODIDS_PER_TRANSLATION_TABLE] = 
        { 0, 0, 0, 0 };

    soc_field_t port_enable_field[KT2_MAX_MXQPORTS_PER_BLOCK]=
                {PORT0f, PORT1f, PORT2f , PORT3f};
    soc_field_t wc_xfi_mode_sel_fld[]={WC0_8_XFI_MODE_SELf,WC1_8_XFI_MODE_SELf};
    uint32      top_misc_control_1_val = 0;
    int parity_enable;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    si = &SOC_INFO(unit);

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Clear IPIPE/EIPIE Memories */
        SOC_IF_ERROR_RETURN(soc_katana2_pipe_mem_clear(unit));
        SOC_IF_ERROR_RETURN(soc_katana2_linkphy_mem_clear(unit));
    }

    /* Some registers are implemented in memory, need to clear them in order
     * to have correct parity value */
    PBMP_PP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, 0));
        SOC_IF_ERROR_RETURN(WRITE_EGR_IPMC_CFG2r(unit, port, 0));
    }

    /* PP_PORT_GPP_TRANSLATION_x
    *  4 instances one each for icfg, il2lu, isw2 and ipars stages of ipipe
    * EGR_PP_PORT_GPP_TRANSLATION_x
    *  2 instances one each for evlan and ehcpm stages of epipe */
    /* If LinkPHY/SubTag CoE is enabled then all 170 pp_ports cannot be accomodated
     * insingle modid. We will use 2 mod_ids.
     * All pp_port mapped to front_panel port in one module and
     * remaining pp_ports in another module */
    if ((soc_feature(unit, soc_feature_linkphy_coe) &&
         SOC_INFO(unit).linkphy_enabled) ||
         (soc_feature(unit, soc_feature_subtag_coe) &&
          SOC_INFO(unit).subtag_enabled)) {

            my_modid_list[0] = 0;
            my_modid_valid[0] = 1;
            my_modid_port_base_ptr[0] = 0;

            /* If not running in the stacking mode, setup the second module
               as the default one to host all pp_ports, else, the user will
               create the necessary modules with separate APIs */
            if(!SOC_INFO(unit).coe_stacking_mode) {
                my_modid_list[1] = 1;
                my_modid_valid[1] = 1;
                my_modid_port_base_ptr[1] = SOC_KT2_SUBPORT_PP_PORT_INDEX_MIN;
            }
    }

    BCM_IF_ERROR_RETURN(
        bcm_kt2_modid_set_all(unit, my_modid_list, my_modid_valid,
                                my_modid_port_base_ptr));

#if 0
    if (SOC_IS_KATANA2(unit) && SAL_BOOT_QUICKTURN) {
        if (soc_property_get(unit, spn_DDR3_AUTO_TUNE, FALSE)) {
            LOG_CLI((BSL_META_U(unit,
                                "QUICKTURN:ATTN \n")));
            _soc_katana2_ci_init(unit);
        }
    }
#endif

    /* default DDR3 Configuration */
    /* 32K Rows * 1k Col * 8 Banks * 16 bits = 4Gb */
    SOC_DDR3_NUM_COLUMNS(unit) = soc_property_get(unit, spn_EXT_RAM_COLUMNS, 
                                                  1024);
    SOC_DDR3_NUM_BANKS(unit) = soc_property_get(unit,spn_EXT_RAM_BANKS, 8);

    switch(dev_id) {
    case BCM56454_DEVICE_ID:
         num_cis = 3;
         ddr3_clock_mhz = 800;
         si->frequency = 123;
         break;
    case BCM56455_DEVICE_ID:
         num_cis = 3;
         ddr3_clock_mhz = 800;
         si->frequency = 166;
         break;
    case BCM55455_DEVICE_ID: 
    case BCM56456_DEVICE_ID: /*  Need to check si->frequency */
    case BCM56457_DEVICE_ID:
    case BCM56458_DEVICE_ID:
         num_cis = 0;
         ddr3_clock_mhz = 0;
         if (dev_id == BCM56458_DEVICE_ID) {
             si->frequency = 120;
         } else {
             si->frequency = 205;
         }
         break;
    case BCM55450_DEVICE_ID:
    case BCM56248_DEVICE_ID:
    case BCM56450_DEVICE_ID:
    case BCM56452_DEVICE_ID:
    default: /* 56450 */
         num_cis = 6;       
         ddr3_clock_mhz = 933; /* 933 MHz */
         si->frequency = 205;
         break;
    }
    SOC_DDR3_NUM_MEMORIES(unit) = soc_property_get(unit,spn_EXT_RAM_PRESENT, 
                                                   num_cis);
    SOC_DDR3_NUM_ROWS(unit) = soc_property_get(unit,spn_EXT_RAM_ROWS, 
                                                   num_rows);
    SOC_DDR3_CLOCK_MHZ(unit) = soc_property_get(unit, spn_DDR3_CLOCK_MHZ, 
                                                   ddr3_clock_mhz);
    SOC_DDR3_MEM_GRADE(unit) = soc_property_get(unit, spn_DDR3_MEM_GRADE, 
                                                   ddr3_mem_grade);
    LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                        "num_cis=%d num_rows=%d ddr3_clock_mhz=%d ddr3_mem_grade=%d "
                        "num_col=%d num_banks=%d \n"),
             SOC_DDR3_NUM_MEMORIES(unit),
             SOC_DDR3_NUM_ROWS(unit),
             SOC_DDR3_CLOCK_MHZ(unit),
             SOC_DDR3_MEM_GRADE(unit),
             SOC_DDR3_NUM_COLUMNS(unit),
             SOC_DDR3_NUM_BANKS(unit)));

    ext_pbmp = soc_property_get_pbmp(unit, spn_PBMP_EXT_MEM, 0);
    SOC_PBMP_COUNT(ext_pbmp, ext_pbmp_count);
    if (!ext_pbmp_count) {
        if (SOC_DDR3_NUM_MEMORIES(unit)) {
            ext_pbmp_count=1;  
        }
    }

    if (soc_feature(unit, soc_feature_ddr3) && (ext_pbmp_count != 0)) {
        /* CI Init */
        soc_ddr40_set_shmoo_dram_config(unit, ((uint32) 0xFFFFFFFF) >> (32 - SOC_DDR3_NUM_MEMORIES(unit)));
        if ((soc_ddr40_phy_pll_ctl(unit, 0, SOC_DDR3_CLOCK_MHZ(unit), 1, 0) == SOC_E_NONE) &&
            (soc_ddr40_ctlr_ctl(unit, 0, 1, 0) == SOC_E_NONE) &&
            (soc_ddr40_phy_calibrate(unit, 0, 1, 0) == SOC_E_NONE)) {

            if (soc_property_get(unit, spn_DDR3_AUTO_TUNE, FALSE)) {
                for(i = 0; i < SOC_DDR3_NUM_MEMORIES(unit); i += 2) {
                    soc_ddr40_shmoo_ctl(unit, i, 1, 1, 0, 0);
                }
                LOG_CLI((BSL_META_U(unit,
                                    "DDR Tune Completed\n")));
            } else {
                rval = SOC_E_NONE;
                for(i = 0; i < SOC_DDR3_NUM_MEMORIES(unit); i += 2) {
                    rval |= soc_ddr40_shmoo_restorecfg(unit, i);
                }
                if (rval == SOC_E_NONE) {
                    LOG_CLI((BSL_META_U(unit,
                                        "DDR Tune Values Restored\n")));
                } else {
                    LOG_CLI((BSL_META_U(unit,
                                        "DDR Tune Values Restore FAILED\n")));
                }
            }
        }
    }

    /* Reset MXQPORT MIB counter (registers implemented in memory) */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_MXQPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        rval = 0;
        soc_reg_field_set(unit, XPORT_MIB_RESETr, &rval, CLR_CNTf, 0xf); /* All Ports */
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MIB_RESETr(unit, blk_port, rval));
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MIB_RESETr(unit, blk_port, 0));
    }

    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);
    if (parity_enable) {
        (void)_soc_katana2_ser_init(unit);
#ifdef INCLUDE_MEM_SCAN
        soc_mem_scan_ser_list_register(unit, TRUE,
                                       _soc_kt2_tcam_ser_info[unit]);
#endif
        memset(&_kt2_ser_functions, 0, sizeof(soc_ser_functions_t));
        _kt2_ser_functions._soc_ser_stat_nack_f = &soc_katana2_stat_nack;
        _kt2_ser_functions._soc_ser_fail_f = &soc_kt2_ser_fail;
        _kt2_ser_functions._soc_ser_mem_nack_f = &soc_katana2_mem_nack;
        _kt2_ser_functions._soc_ser_parity_error_cmicm_intr_f = 
            &soc_katana2_parity_error;
        soc_ser_function_register(unit, &_kt2_ser_functions);
    } else {
        memset(&_kt2_oam_event_functions, 0, sizeof(soc_oam_event_functions_t));
        _kt2_oam_event_functions._soc_oam_event_intr_f =
                                              &soc_katana2_oam_event_process;
        soc_oam_event_function_register (unit, &_kt2_oam_event_functions);
    }

    _soc_katana2_parity_enable_all(unit, parity_enable ? TRUE : FALSE);
#if defined(SER_TR_TEST_SUPPORT)
    /*Initialize chip-specific functions for SER testing*/
    memset(&ser_katana2_test_fun, 0, sizeof(soc_ser_test_functions_t));
    ser_katana2_test_fun.inject_error_f = &soc_katana2_ser_inject_error;
    ser_katana2_test_fun.test_mem = &soc_katana2_ser_mem_test;
    ser_katana2_test_fun.test     = &soc_katana2_ser_test;
    ser_katana2_test_fun.parity_control = &_ser_test_parity_control_reg_set;
    ser_katana2_test_fun.injection_support = &soc_katana2_ser_error_injection_support;
    soc_ser_test_functions_register(unit, &ser_katana2_test_fun);
#endif /*defined(SER_TR_TEST_SUPPORT*/

    sal_memset(entry, 0, sizeof(cpu_pbm_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBMm, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBMm, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(cpu_pbm_2_entry_t));
    soc_mem_pbmp_field_set(unit, CPU_PBM_2m, entry, BITMAPf, &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, CPU_PBM_2m, MEM_BLOCK_ALL, 0, entry));

    sal_memset(entry, 0, sizeof(multipass_loopback_bitmap_entry_t));
    soc_mem_pbmp_field_set(unit, MULTIPASS_LOOPBACK_BITMAPm, entry, BITMAPf,
                           &PBMP_LB(unit));
    SOC_IF_ERROR_RETURN
        (soc_mem_write(unit, MULTIPASS_LOOPBACK_BITMAPm, MEM_BLOCK_ALL, 0,
                       entry));

    SOC_PBMP_CLEAR(pbmp);
    for (port = 0; port < 42; port++) {
        if (IS_LB_PORT(unit, port) ||
            (si->port_group[port] >= 2 && si->port_group[port] <= 3)) {
            SOC_PBMP_PORT_ADD(pbmp, port);
        }
    }

    sal_memset(entry, 0, sizeof(egr_physical_port_entry_t));
    sal_memset(ing_entry, 0, sizeof(ing_physical_port_table_entry_t));

    soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm, entry, PORT_TYPEf, 1);
    soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm,
            ing_entry, PORT_TYPEf, 1);
    /* Higig ports */
    PBMP_ST_ITER(unit, port) {
        if (soc_feature(unit, soc_feature_higig2) && (IS_HL_PORT(unit,port)
             || soc_property_port_get(unit, port, spn_HIGIG2_HDR_MODE, 0))) {
            SOC_IF_ERROR_RETURN(soc_reg_field32_modify(
                unit, XPORT_CONFIGr, port, HIGIG2_MODEf, 1));
            SOC_IF_ERROR_RETURN(soc_reg_field32_modify(
                unit, XPORT_CONFIGr, port, HIGIG_MODEf, 0));
            soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm,ing_entry,
                                HIGIG2f,1);
            soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm,entry,
                                HIGIG2f,1);
        } else { 
            SOC_IF_ERROR_RETURN(soc_reg_field32_modify(
                unit, XPORT_CONFIGr, port, HIGIG_MODEf, 1));
            SOC_IF_ERROR_RETURN(soc_reg_field32_modify(
                unit, XPORT_CONFIGr, port, HIGIG2_MODEf, 0));
            soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm,ing_entry,
                                HIGIG2f,0);
            soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm,entry,
                                HIGIG2f,0);
        }
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, EGR_PHYSICAL_PORTm,
            MEM_BLOCK_ALL, port, entry));
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_PHYSICAL_PORT_TABLEm, 
            MEM_BLOCK_ALL, port, ing_entry));
    }
  
    /* CMIC higig index */
    /* Setup the cpu_hg_port specifically in HG2 mode */
    soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm, ing_entry,
                        HIGIG2f, 1);
    soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm,entry,
                        HIGIG2f, 1);
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, EGR_PHYSICAL_PORTm, MEM_BLOCK_ALL, si->cpu_hg_index, entry));
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, ING_PHYSICAL_PORT_TABLEm, MEM_BLOCK_ALL,
        si->cpu_hg_index, ing_entry));

    /* Loopback port */
    soc_mem_field32_set(unit, EGR_PHYSICAL_PORTm, entry, PORT_TYPEf, 2);
    soc_mem_field32_set(unit, ING_PHYSICAL_PORT_TABLEm, ing_entry,
        PORT_TYPEf, 2);
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, EGR_PHYSICAL_PORTm, MEM_BLOCK_ALL, LB_PORT(unit), entry));
    SOC_IF_ERROR_RETURN(soc_mem_write(
        unit, ING_PHYSICAL_PORT_TABLEm,
        MEM_BLOCK_ALL, LB_PORT(unit), ing_entry));
    /* ingress physical port to pp_port mapping */
    SOC_IF_ERROR_RETURN(soc_mem_field32_modify(
        unit, ING_PHYSICAL_PORT_TABLEm,
        LB_PORT(unit), PP_PORTf, LB_PORT(unit)));

    /* pp_port to egress physical port mapping */
    SOC_IF_ERROR_RETURN(soc_mem_field32_modify(
        unit, PP_PORT_TO_PHYSICAL_PORT_MAPm,
        LB_PORT(unit), DESTINATIONf,LB_PORT(unit)));

    /* All quad ports in default config */
    
    SOC_IF_ERROR_RETURN(_soc_katana2_get_cfg_num(unit, &cfg_num));
    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        return SOC_E_FAIL;
    } 
    if (bcm56450_tdm[cfg_num] == NULL ) {
        LOG_CLI((BSL_META_U(unit,
                            "Internal: Not implemented Cfg => %d \n"),cfg_num));
        return SOC_E_FAIL;
    }
    /* Check whether MXQ8,9 are in XFI mode or not */
    for (mxqblock=8; mxqblock <=9 ; mxqblock++) {
        port_count=0; 
        xfi_mode[mxqblock-8] = 0;
        if ((mxqblock == 8) || (mxqblock == 9)) {
             for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop+=2) {
                  if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                      (*kt2_mxqblock_ports[unit])[mxqblock][loop])) {
                      if (bcm56450_speed[unit][cfg_num]
                             [(*kt2_mxqblock_ports[unit])[mxqblock][loop]-1] == 10000) {
                          port_count++;
                      }
                  }  
             }
             for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop+=2) {
                  if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                      (*kt2_mxqblock_ports[unit])[mxqblock-2][loop])) {
                      if (bcm56450_speed[unit][cfg_num]
                          [(*kt2_mxqblock_ports[unit])[mxqblock-2][loop]-1] == 10000) {
                          port_count++;
                      }
                  }  
             }
             if (port_count == KT2_MAX_MXQPORTS_PER_BLOCK) {
                /*Need To Set XFI Mode then */
                xfi_mode[mxqblock-8] = 1;
             }
             SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_1r(
                                 unit,&top_misc_control_1_val));
             soc_reg_field_set(unit, TOP_MISC_CONTROL_1r, 
                               &top_misc_control_1_val,
                               wc_xfi_mode_sel_fld[mxqblock-8],
                               xfi_mode[mxqblock-8]);
             SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_1r(
                                 unit,top_misc_control_1_val));
        }
    }
    if ((xfi_mode[0] == 1) || (xfi_mode[1] == 1)) {
        /* Reinitialize katana2 phy addresses */
        SOC_IF_ERROR_RETURN(soc_phyctrl_software_init(unit));
    }
    
    SOC_PBMP_CLEAR(my_pbmp_xport_xe);
    my_pbmp_xport_xe = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_XE,
                                                      my_pbmp_xport_xe);
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_MXQPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        SOC_IF_ERROR_RETURN(soc_katana2_get_port_mxqblock(
                            unit,blk_port,&mxqblock));
        xport_port_enable_reg = 0;
        any_phy_port=0; 
        any_port_speed=0; 
        for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
             if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), 
                            (*kt2_mxqblock_ports[unit])[mxqblock][loop])) {
                 if (((*kt2_mxqblock_ports[unit])[mxqblock][loop] == KT2_OLP_PORT) &&
                     (si->olp_port[0] == 1) ) {
                     /*
                       LOG_CLI((BSL_META_U(unit,
                                           "QUICKTURN:ATTN:Olp Trick"
                                           "Need RegfileChange MXQ:%d:\n"),mxqblock));
                      */
                     soc_reg_field_set(unit, XPORT_PORT_ENABLEr, 
                                   &xport_port_enable_reg,
                                   port_enable_field[0], 1); /*Enable port */
                 } else { 
                     soc_reg_field_set(unit, XPORT_PORT_ENABLEr, 
                                   &xport_port_enable_reg,
                                   port_enable_field[loop], 1); /*Enable port */
                 }
                 if (any_phy_port == 0) {
                     any_phy_port= (*kt2_mxqblock_ports[unit])[mxqblock][loop];
                     any_port_speed= bcm56450_speed[unit][cfg_num]
                                         [(*kt2_mxqblock_ports[unit])[mxqblock][loop]-1];
                 }
             } else {
                 soc_reg_field_set(unit, XPORT_PORT_ENABLEr, 
                                   &xport_port_enable_reg,
                                   port_enable_field[loop], 0);/*Disable port */
             }
        }

        rval = 0;
        phy_speed = bcm56450_speed[unit][cfg_num][any_phy_port-1];
        if (SOC_PBMP_MEMBER(my_pbmp_xport_xe, any_phy_port)) {
            if (phy_speed == 21000) {
                /* 21G HG ports support IEEE encapsulation to speed upto 20G */ 
                phy_speed = 20000;
            } else {
                phy_speed = 10000;
            }
        }
        SOC_IF_ERROR_RETURN(soc_katana2_get_phy_port_mode(
                            unit, any_phy_port,
                            phy_speed, 
                            &phy_mode));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                            PHY_PORT_MODEf, phy_mode);

        SOC_IF_ERROR_RETURN(soc_katana2_get_core_port_mode(
                            unit,blk_port,&core_mode));
        soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                            CORE_PORT_MODEf, core_mode);
        wc_10g_21g_sel = 0;
        if ((mxqblock>=6) && (mxqblock<=9)) {
            for (loop=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK; loop++) {
                 port_speed= bcm56450_speed[unit][cfg_num]
                                      [(*kt2_mxqblock_ports[unit])[mxqblock][loop]-1];
                 if ((mxqblock==8) || (mxqblock==9)) {
                      if ((SAL_BOOT_QUICKTURN) && 
                          (core_mode == bcmMxqCorePortModeSingle) &&
                          (SOC_PBMP_MEMBER(si->linkphy_pbm, 
                               (*kt2_mxqblock_ports[unit])[mxqblock][loop]))) {
                          LOG_CLI((BSL_META_U(unit,
                                              "QUICKTURN: ATTN : 10G_21G_SEL=0 \n")));
                          wc_10g_21g_sel = 0;
                          break;
                      }
                      if ((port_speed == 10000) || (port_speed == 21000)) {
                           wc_10g_21g_sel = 1;
                           break;
                      }
                 }
                 if ((mxqblock==6) || (mxqblock==7)) {
                      if ((port_speed == 10000) && (xfi_mode[mxqblock-6] ==1)) {
                           wc_10g_21g_sel = 1;
                           break;
                      }
                 }
            }
#if 0
            if (xfi_mode) { /* so obvious 10g speed */
                mxq6_7_rval=0;
                soc_reg_field_set(unit, XPORT_MODE_REGr, &mxq6_7_rval,
                                  WC_10G_21G_SELf, wc_10g_21g_sel);
                SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, 
                             (*kt2_mxqblock_ports[unit])[mxqblock-2][0], mxq6_7_rval));
            }
#endif
            soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                               WC_10G_21G_SELf, wc_10g_21g_sel);

        }
        if ((any_port_speed != 0 ) && 
            (any_port_speed < 10000)) {
             soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                               PORT_GMII_MII_ENABLEf, 1);
        } else {
             soc_reg_field_set(unit, XPORT_MODE_REGr, &rval,
                               PORT_GMII_MII_ENABLEf, 0);
        } 
        SOC_IF_ERROR_RETURN(WRITE_XPORT_MODE_REGr(unit, blk_port, rval));
        SOC_IF_ERROR_RETURN(WRITE_XPORT_PORT_ENABLEr(unit, blk_port, 
                                                     xport_port_enable_reg));
    }

    count = 32;

    /* Setup main TDM control */
    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    /* BCMSIM handles Single Cell packets */
    if (SAL_BOOT_BCMSIM) {
        soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    } else {
        soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    }
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf, count);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    if (0) { /* FIXME: Which Devices?   if (dev_id != BCM56450_DEVICE_ID) {} */
        rval = 0;
        soc_reg_field_set(unit, ING_BYPASS_CTRLr, &rval, IFP_BYPASS_ENABLEf,
                          1);
        SOC_IF_ERROR_RETURN(WRITE_ING_BYPASS_CTRLr(unit, rval));

        rval = 0;
        soc_reg_field_set(unit, EGR_BYPASS_CTRLr, &rval, EFP_BYPASSf, 1);
        SOC_IF_ERROR_RETURN(WRITE_EGR_BYPASS_CTRLr(unit, rval));
    }

    SOC_IF_ERROR_RETURN(_soc_kt2_l1_port_mx_lane_map_init(unit)); 

    /* Enable dual hash on L2, L3 and MPLS_ENTRY tables */
    fields[0] = ENABLEf;
    values[0] = 1;
    fields[1] = HASH_SELECTf;
    values[1] = FB_HASH_CRC32_LOWER;
    fields[2] = INSERT_LEAST_FULL_HALFf;
    values[2] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L2_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L3_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, MPLS_ENTRY_HASH_CONTROLr, REG_PORT_ANY,
                                INSERT_LEAST_FULL_HALFf, 1));

    /*
     * IPMC init 
     */

    /*
     * Egress Enable
     */
    sal_memset(entry, 0, sizeof(egr_enable_entry_t));
    soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 0);
    for (port = 0; port < 42; port++) {
        rv = WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, port, entry);
        /* ****************************************************************** */
        
        /* ****************************************************************** */
        if (SOC_FAILURE(rv)) {
            if (SOC_IS_KATANA2(unit) && (rv == _SHR_E_PARAM)) {
                continue;
            }
            return rv;
        }
    }

    sal_memset(entry, 0, sizeof(epc_link_bmap_entry_t));
    SOC_IF_ERROR_RETURN(READ_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0,
                           &entry));
    soc_mem_pbmp_field_set(unit, EPC_LINK_BMAPm, entry, PORT_BITMAPf,
                           &PBMP_CMIC(unit));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAPm(unit, MEM_BLOCK_ALL, 0, entry));

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &reg64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_VALIDATION_ENf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, reg64));

    /* set to allow Mirror bit in Module Header */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, EGR_CONFIG_1r, REG_PORT_ANY, 
                                RING_MODEf, 1));

    SOC_PBMP_ASSIGN(pbmp, PBMP_ALL(unit));
    SOC_PBMP_REMOVE(pbmp, PBMP_LB(unit));
    SOC_IF_ERROR_RETURN(soc_mem_read(unit, ING_EN_EFILTER_BITMAPm,
                                     MEM_BLOCK_ANY, 0, &entry));
    soc_mem_pbmp_field_set(unit, ING_EN_EFILTER_BITMAPm, &entry, BITMAPf,
                           &pbmp);
    SOC_IF_ERROR_RETURN(soc_mem_write(unit, ING_EN_EFILTER_BITMAPm,
                                      MEM_BLOCK_ALL, 0, &entry));

    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_TXBUF_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, CMIC_TXBUF_CONFIGr, &rval,
                            FIRST_SERVE_BUFFERS_WITH_EOP_CELLSf, 0);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_TXBUF_CONFIGr(unit, rval));

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
        (soc_hbx_higig2_mcast_sizes_set(unit,
             soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT)));

    if (soc_mspi_init(unit) != SOC_E_NONE) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d : MSPI Init Failed\n"), unit));
    }

    if (soc_feature(unit, soc_feature_ces)) {
	/*
	 * Add CES TDM ports
	 */
	for (i = 0;i < 16;i++) {
	    int port = 39 + i;
	    SOC_PBMP_PORT_ADD(si->tdm_pbm, port);
	    si->tdm.port[si->tdm.num++] = port;
	    if (si->tdm.min > port || si->tdm.min < 0) {
		si->tdm.min = port;
	    }
	    if (si->tdm.max < port) {
		si->tdm.max = port;
	    }
	    SOC_PBMP_PORT_ADD(si->tdm.bitmap, port);
	}
    }
    /* TXLP_PORT_ADDR_MAP_TABLE */
    for (mxqblock=8;mxqblock<=9;mxqblock++) {
         for (loop=0,start_addr=0;loop<KT2_MAX_MXQPORTS_PER_BLOCK;loop++) {
             sal_memset(&txlp_port_addr_map_table_entry,0,
                        sizeof(txlp_port_addr_map_table_entry_t));
             mxqblock_port=(*kt2_mxqblock_ports[unit])[mxqblock][loop];
             if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), mxqblock_port)) {
                 if (!SOC_PBMP_MEMBER(si->linkphy_pbm, mxqblock_port)) {
                     /*  5.  As each cell-occupies "4" lines in buffer, [end-start+1] must be a integral 
                             multiple of "4". */
                     if (si->port_speed_max[mxqblock_port] <= 2500) {
                         end_addr = start_addr + (( 6 * 4) - 1); /* 6 Cells */
                     } else if (si->port_speed_max[mxqblock_port] <= 10000) {
                         end_addr = start_addr + ((12 * 4) - 1); /* 12 Cells */
                     } else if (si->port_speed_max[mxqblock_port] <= 13000) {
                         end_addr = start_addr + ((16 * 4) - 1); /* 16 Cells */
                     } else if (si->port_speed_max[mxqblock_port] <= 21000) {
                         end_addr = start_addr + ((20 * 4) - 1); /* 20 Cells */
                     }
                     soc_TXLP_PORT_ADDR_MAP_TABLEm_field_set(unit,
                         &txlp_port_addr_map_table_entry,START_ADDRf,&start_addr);
                     soc_TXLP_PORT_ADDR_MAP_TABLEm_field_set(unit,
                         &txlp_port_addr_map_table_entry,END_ADDRf,&end_addr);
                     start_addr = end_addr+1;
                     SOC_IF_ERROR_RETURN(WRITE_TXLP_PORT_ADDR_MAP_TABLEm(
                                         unit,SOC_INFO(unit).txlp_block[mxqblock-8],
                                         loop, &txlp_port_addr_map_table_entry));
                 }
             } 
        }
    }
    SOC_IF_ERROR_RETURN(soc_mem_clear(
                        unit, MMU_RQE_QUEUE_OP_NODE_MAPm, COPYNO_ALL, TRUE));
    SOC_IF_ERROR_RETURN(soc_mem_clear(
                        unit, MMU_WRED_QUEUE_OP_NODE_MAPm, COPYNO_ALL, TRUE));

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    values[0] = 1;
    fields[1] = LAG_RES_ENf;
    values[1] = 1;
    SOC_IF_ERROR_RETURN(soc_reg_fields32_modify(unit,
                SW2_FP_DST_ACTION_CONTROLr, REG_PORT_ANY, 2, fields, values));

    /* initialize LED UP0 */
    if (!SOC_WARM_BOOT(unit)) {
        SOC_IF_ERROR_RETURN(_katana2_ledup_init(unit));
    }
    
    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));
    }
    /* Updating TM setting for FP and VFP TCAMs to improve yield.
     * This is NOT needed for B0 revision.*/
    val = ((rev_id == BCM56450_B0_REV_ID) || (rev_id == BCM56450_B1_REV_ID)) ? 
          0 : 0x30;
    if (SOC_REG_IS_VALID(unit, FP_CAM_CONTROL_TM_13_THRU_0r)) {
        SOC_IF_ERROR_RETURN(READ_FP_CAM_CONTROL_TM_13_THRU_0r_REG32(unit, &rval));
        soc_reg_field_set(unit, FP_CAM_CONTROL_TM_13_THRU_0r,
                          &rval, ALL_TCAMS_TM_13_0f, val);
        soc_reg_field_set(unit, FP_CAM_CONTROL_TM_13_THRU_0r,
                          &rval, ALL_GLOBAL_MASK_TCAMS_TM_13_0f, val);
        SOC_IF_ERROR_RETURN(WRITE_FP_CAM_CONTROL_TM_13_THRU_0r_REG32(unit, rval));
    }
    if (SOC_REG_IS_VALID(unit, VFP_CAM_CONTROL_SLICE_3_0r)) {
        SOC_IF_ERROR_RETURN(READ_VFP_CAM_CONTROL_SLICE_3_0r(unit, &rval));
        soc_reg_field_set(unit, VFP_CAM_CONTROL_SLICE_3_0r,
                          &rval, TMf, val);
        SOC_IF_ERROR_RETURN(WRITE_VFP_CAM_CONTROL_SLICE_3_0r(unit, rval));
    }
    SOC_IF_ERROR_RETURN(READ_AUX_ARB_CONTROL_2r(unit, &rval));
    soc_reg_field_set(unit, AUX_ARB_CONTROL_2r, &rval, 
                      TCAM_ATOMIC_WRITE_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_AUX_ARB_CONTROL_2r(unit, rval));

    /* Initializing subport configurations */
    si->subport_group_max = SOC_KT2_SUBPORT_GROUP_MAX;
    si->pp_port_index_max = SOC_KT2_SUBPORT_PP_PORT_INDEX_MAX;
    si->pp_port_index_min = SOC_KT2_SUBPORT_PP_PORT_INDEX_MIN;
    si->subport_port_max = SOC_KT2_MAX_SUBPORTS;
    si->lp_tx_databuf_start_addr_max = SOC_KT2_LINKPHY_TX_DATA_BUF_START_ADDR_MAX;
    si->lp_tx_databuf_end_addr_min = SOC_KT2_LINKPHY_TX_DATA_BUF_END_ADDR_MIN;
    si->lp_tx_databuf_end_addr_max = SOC_KT2_LINKPHY_TX_DATA_BUF_END_ADDR_MAX;
    si->lp_tx_stream_start_addr_offset = SOC_KT2_LINKPHY_TX_STREAM_START_ADDR_OFFSET;
    si->lp_block_max = SOC_KT2_LINKPHY_BLOCK_MAX;
    si->lp_ports_max = SOC_KT2_MAX_LINKPHY_PORTS;
    si->lp_streams_per_subport = SOC_KT2_MAX_STREAMS_PER_SUBPORT;

    return SOC_E_NONE;
}

#define KA2_MMU_EFIFO_DEPTH             10
#define KA2_MMU_EFIFO_XMIT_THERESHOLD   4


/* Have spilt mmu_init1_port and formed a new funtion to program 
 * requird parts in case of flex io operation.
 * This configures DEST_PORT_CFG_0 and MMU_ENQ_DEST_PPP_CFG_0 registers .
 */ 
int _soc_katana2_mmu_init_phase4_port(int unit,int port)
{

    soc_info_t *si= &SOC_INFO(unit);
    uint32 port_cfg0 = 0;
    uint32 port_cfg1 = 0;
    uint32 port_cfg2 = 0;
    uint32 port_cfg3 = 0;
    uint32 port_cfg4 = 0;
    uint32 port_cfg5 = 0;
    uint32 rval;
    int pp_port;
    int start_pp_port, end_pp_port;
    if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
        if (IS_EXT_MEM_PORT(unit, port)) {
            SOC_IF_ERROR_RETURN(READ_DEST_PORT_CFG_0r(unit, &port_cfg0));
            SOC_IF_ERROR_RETURN(READ_DEST_PORT_CFG_1r(unit, &port_cfg1));
            if (port <= 31) {
                port_cfg0 |= (1 << port);
            } else {
                port_cfg1 |= (1 << (port - 32));
            }

            SOC_IF_ERROR_RETURN(WRITE_DEST_PORT_CFG_0r(unit, port_cfg0));
            SOC_IF_ERROR_RETURN(WRITE_DEST_PORT_CFG_1r(unit, port_cfg1));
            SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_0r(unit, &port_cfg0));
            SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_1r(unit, &port_cfg1));

            if (port <= 31) {
                port_cfg0 |= (1 << port);
            } else {
                port_cfg1 |= (1 << (port - 32));
            }


            SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_0r(unit, port_cfg0));
            SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_1r(unit, port_cfg1));

            SOC_IF_ERROR_RETURN(READ_RQE_PP_PORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, RQE_PP_PORT_CONFIGr, &rval, BUFF_TYPEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_RQE_PP_PORT_CONFIGr(unit, port, rval));

            if (si->port_num_subport[port] > 0) {
                start_pp_port = si->port_subport_base[port];
                end_pp_port = si->port_subport_base[port] + 
                    si->port_num_subport[port];
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_2r(unit, &port_cfg2));
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_3r(unit, &port_cfg3));
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_4r(unit, &port_cfg4));
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_5r(unit, &port_cfg5));

                for (pp_port = start_pp_port; pp_port < end_pp_port; pp_port++) {
                    if (pp_port <= 31) {
                        port_cfg0 |= (1 << pp_port);
                    } else if (pp_port <= 63) {
                        port_cfg1 |= (1 << (pp_port - 32));
                    } else if (pp_port <= 95) {
                        port_cfg2 |= (1 << (pp_port - 64));

                    } else if (pp_port <= 127) {
                        port_cfg3 |= (1 << (pp_port - 96));

                    } else if (pp_port <= 159) {
                        port_cfg4 |= (1 << (pp_port - 128));

                    } else if (pp_port <= 169) {
                        port_cfg5 |= (1 << (pp_port - 160));
                    }

                    SOC_IF_ERROR_RETURN(READ_RQE_PP_PORT_CONFIGr(unit, pp_port, &rval));
                    soc_reg_field_set(unit, RQE_PP_PORT_CONFIGr, &rval, BUFF_TYPEf, 1);
                    SOC_IF_ERROR_RETURN(WRITE_RQE_PP_PORT_CONFIGr(unit, pp_port, rval));
                    /* Add subport in ext_pbmp */
                    SOC_PBMP_PORT_ADD(PBMP_EXT_MEM(unit), pp_port);
                }
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_0r(unit, port_cfg0));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_1r(unit, port_cfg1));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_2r(unit, port_cfg2));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_3r(unit, port_cfg3));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_4r(unit, port_cfg4));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_5r(unit, port_cfg5));

            }
        } else {
            SOC_IF_ERROR_RETURN(READ_DEST_PORT_CFG_0r(unit, &port_cfg0));
            SOC_IF_ERROR_RETURN(READ_DEST_PORT_CFG_1r(unit, &port_cfg1));
            if (port <= 31) {
                port_cfg0 &= ~(1 << port);
            } else {
                port_cfg1 &= ~(1 << (port - 32));
            }

            SOC_IF_ERROR_RETURN(WRITE_DEST_PORT_CFG_0r(unit, port_cfg0));
            SOC_IF_ERROR_RETURN(WRITE_DEST_PORT_CFG_1r(unit, port_cfg1));
            SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_0r(unit, &port_cfg0));
            SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_1r(unit, &port_cfg1));

            if (port <= 31) {
                port_cfg0 &= ~(1 << port);
            } else {
                port_cfg1 &= ~(1 << (port - 32));
            }

            SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_0r(unit, port_cfg0));
            SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_1r(unit, port_cfg1));

            SOC_IF_ERROR_RETURN(READ_RQE_PP_PORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, RQE_PP_PORT_CONFIGr, &rval, BUFF_TYPEf, 0);
            SOC_IF_ERROR_RETURN(WRITE_RQE_PP_PORT_CONFIGr(unit, port, rval));

            if (si->port_num_subport[port] > 0) {
                start_pp_port = si->port_subport_base[port];
                end_pp_port = si->port_subport_base[port] +
                    si->port_num_subport[port];
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_2r(unit, &port_cfg2));
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_3r(unit, &port_cfg3));
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_4r(unit, &port_cfg4));
                SOC_IF_ERROR_RETURN(READ_MMU_ENQ_DEST_PPP_CFG_5r(unit, &port_cfg5));

                for (pp_port = start_pp_port; pp_port < end_pp_port; pp_port++) {
                    if (pp_port <= 31) {
                        port_cfg0 &= ~(1 << pp_port);
                    } else if (pp_port <= 63) {
                        port_cfg1 &= ~(1 << (pp_port - 32));
                    } else if (pp_port <= 95) {
                        port_cfg2 &= ~(1 << (pp_port - 64));

                    } else if (pp_port <= 127) {
                        port_cfg3 &= ~(1 << (pp_port - 96));

                    } else if (pp_port <= 159) {
                        port_cfg4 &= ~(1 << (pp_port - 128));

                    } else if (pp_port <= 169) {
                        port_cfg5 &= ~(1 << (pp_port - 160));
                    }

                    SOC_IF_ERROR_RETURN(READ_RQE_PP_PORT_CONFIGr(unit, pp_port, &rval));
                    soc_reg_field_set(unit, RQE_PP_PORT_CONFIGr, &rval, BUFF_TYPEf, 0);
                    SOC_IF_ERROR_RETURN(WRITE_RQE_PP_PORT_CONFIGr(unit, pp_port, rval));
                    /* Remove subport from ext_pbmp */
                    SOC_PBMP_PORT_REMOVE(PBMP_EXT_MEM(unit), pp_port);
                }
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_0r(unit, port_cfg0));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_1r(unit, port_cfg1));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_2r(unit, port_cfg2));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_3r(unit, port_cfg3));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_4r(unit, port_cfg4));
                SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_DEST_PPP_CFG_5r(unit, port_cfg5));
            }
        }
    }

    return SOC_E_NONE;
}
/* Just splitted _soc_katana2_mmu_init() for flex IO feature */
/* Configure Egress Fifo */
/* Port BW Ctrl */
STATIC int
_soc_katana2_mmu_init_phase1_port(int unit,int port,uint32 *nxtaddr)
{
    uint32     rval=0;
    soc_info_t *si= &SOC_INFO(unit);
    int depth = 0;
    int thereshold = 0;
    int mxqblock=0;
    uint32 max_depth_limit=672;
    soc_pbmp_t my_pbmp_xport_xe;
    int num_lanes = 0;
    int speed = 0;
    int port_temp, padding = 0;

    if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
        if (!(IS_CPU_PORT(unit,port) || IS_LB_PORT(unit,port))) {
            port_temp = (port-1);
            mxqblock = (*kt2_port_to_mxqblock[unit])[port_temp];
            /* Configure Egress Fifo */
            if(mxqblock_max_startaddr[mxqblock] == 0) {
               mxqblock_max_startaddr[mxqblock]= *nxtaddr;
            }
            SOC_PBMP_CLEAR(my_pbmp_xport_xe);
            my_pbmp_xport_xe = soc_property_get_pbmp_default(unit, spn_PBMP_XPORT_XE,
                                                             my_pbmp_xport_xe);
            SOC_IF_ERROR_RETURN(_bcm_kt2_port_lanes_get(unit, port, 
                                                        &num_lanes));
            if((SOC_PBMP_MEMBER(my_pbmp_xport_xe, port)) &&
                    ((mxqblock == 8) || (mxqblock == 9))) {
                speed = (*mxqspeeds[unit])[mxqblock][num_lanes - 1];
            }
        }
        if (speed == 0) {
            speed = si->port_speed_max[port];
        }
        rval = 0;
        soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                          EGRESS_FIFO_START_ADDRESSf, *nxtaddr);
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "port=%d nxtaddr=%d \n"),port,*nxtaddr));
        if (speed <= 1000) {
            depth = (IS_EXT_MEM_PORT(unit, port)) ? 10 : 2;
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 8 : 0;
            padding = 10 - depth;
        } else if (speed <= 2500) {
            depth = (IS_EXT_MEM_PORT(unit, port)) ? 14 : 2; 
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 12 : 0;
            padding = 14 - depth;
        } else if (speed <= 13000) {
            depth = (IS_EXT_MEM_PORT(unit, port)) ? 56 : 10;     
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 49 : 0;
            padding = 56 - depth;
        } else { /* > 13G */
            depth = (IS_EXT_MEM_PORT(unit, port)) ? 112 : 16; 
            thereshold = (IS_EXT_MEM_PORT(unit, port)) ? 85 : 0;
            padding = 112 - depth; 
        }
        if ((IS_EXT_MEM_PORT(unit, port)) && !(PBMP_MEMBER(si->linkphy_pbm, port))) {
            soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                              EGRESS_FIFO_XMIT_OVERSPEED_RATE_LIMITERf, 1);
        } else {
            soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                              EGRESS_FIFO_XMIT_OVERSPEED_RATE_LIMITERf, 0);
        }

        soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                          EGRESS_FIFO_XMIT_THRESHOLDf, thereshold);
        soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                          EGRESS_FIFO_DEPTHf, depth);
        if (SOC_PBMP_MEMBER(si->linkphy_pbm, port)) {
            soc_reg_field_set(unit, DEQ_EFIFO_CFGr, &rval, 
                              EGRESS_FIFO_LINK_PHYf, 1);
        }
        *nxtaddr += depth + padding;
        if (*nxtaddr > max_depth_limit) {
            LOG_CLI((BSL_META_U(unit,
                                "FATAL: Internal Error: Limit=%d crossed "
                                "port:%d depth:%d nxtaddr=%d\n"),
                     max_depth_limit, port, depth, *nxtaddr));
            return SOC_E_RESOURCE;
        }
        SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFGr(unit, port, rval));

        SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase4_port(unit, port)) ;
 
        /* Port BW Ctrl */
        SOC_IF_ERROR_RETURN(READ_TOQ_PORT_BW_CTRLr(unit, port, &rval));
        if (IS_CPU_PORT(unit,port) || IS_LB_PORT(unit,port)) {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 50);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 127);
        } else if (speed >= 10000) {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 500);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 34);
        } else if (speed == 2500) {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 125);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 19);
        } else {
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              PORT_BWf, 50);
            soc_reg_field_set(unit, TOQ_PORT_BW_CTRLr, &rval, 
                              START_THRESHOLDf, 7);
        }
        SOC_IF_ERROR_RETURN(WRITE_TOQ_PORT_BW_CTRLr(unit, port, rval));
        if (!(IS_CPU_PORT(unit,port) || IS_LB_PORT(unit,port))) {
            mxqblock_max_endaddr[mxqblock]=(*nxtaddr)-1;
        }
    } else {
        if (SOC_PORT_VALID(unit, port)) {
            SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFGr(unit, port, 0));
            SOC_IF_ERROR_RETURN(WRITE_TOQ_PORT_BW_CTRLr(unit, port, 0));
        }
    }
    return SOC_E_NONE;
}
STATIC int
_soc_katana2_mmu_init_phase1(int unit) 
{
    uint32 nxtaddr=0;
    int    port=0;
    int    mxqblock=0;
    int    subport=0;

    for (mxqblock=0;mxqblock<KT2_MAX_MXQBLOCKS ; mxqblock++) {
         mxqblock_max_startaddr[mxqblock]=0;
         mxqblock_max_endaddr[mxqblock]=0;
    }

     /* cpu port */
     SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase1_port(unit,0,&nxtaddr));
     /* lb port */
    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase1_port(unit,41,&nxtaddr));
    for (mxqblock=0;mxqblock<KT2_MAX_MXQBLOCKS ; mxqblock++) {
         for (subport=0;subport<KT2_MAX_MXQPORTS_PER_BLOCK; subport++) {
              port = (*kt2_mxqblock_ports[unit])[mxqblock][subport];
              SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase1_port(
                                  unit,port,&nxtaddr));
         }
    }
    for (mxqblock=0;mxqblock<KT2_MAX_MXQBLOCKS ; mxqblock++) {
         LOG_VERBOSE(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "start=%d end=%d \n"),
                                 mxqblock_max_startaddr[mxqblock],
                      mxqblock_max_endaddr[mxqblock]));
    }
    return SOC_E_NONE;
}

/* Just splitted _soc_katana2_mmu_init() for flex IO feature */
STATIC int
_soc_katana2_mmu_init_phase3(int unit, int port)
{
    uint32 rval=0;
    if (SOC_PBMP_MEMBER((PBMP_ALL(unit)), port)) {
        soc_reg_field_set(unit, PORT_MAX_PKT_SIZEr, &rval, 
                PORT_MAX_PKT_SIZEf,49);
    }
    SOC_IF_ERROR_RETURN(WRITE_PORT_MAX_PKT_SIZEr(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_MAX_PKT_SIZEr(unit, port,
                rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_MAX_PKT_SIZEr(unit, port, 
                rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_MAX_PKT_SIZEr(unit, port, 
                rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_MAX_PKT_SIZEr(unit, port, 
                rval));

    rval = 0xffff;
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_XON_ENABLEr(unit, port, 
                rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_XON_ENABLEr(unit, port, 
                rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PRI_XON_ENABLEr(unit, port, 
                rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PRI_XON_ENABLEr(unit, port, 
                rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PRI_XON_ENABLEr(unit, port, 
                rval));

    /* MXQ Ports */
    rval = 0;
    if (((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
                (((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0) ||
                 (port == 30) || (port == 33) || 
                 (port == 36) || (port == 39))) || (IS_LB_PORT(unit,port))) {
        rval = 0xffffffff; /* PRIx_GRP = 0x7 */
    }
    SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_GRP0r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_PORT_PRI_GRP1r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_GRP0r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_PORT_PRI_GRP1r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PRI_GRP0r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_PORT_PRI_GRP1r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PRI_GRP0r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_PORT_PRI_GRP1r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PRI_GRP0r(unit, port, rval));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_PORT_PRI_GRP1r(unit, port, rval));

    /* READ_MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r(unit, rval); */
    rval = 0;
    if (((port > KT2_CMIC_PORT) && (port < KT2_LPBK_PORT) &&
                (((*kt2_port_to_mxqblock_subports[unit])[port-1] == 0) ||
                 (port == 30) || (port == 33) || 
                 (port == 36) || (port == 39))) || (IS_LB_PORT(unit,port))) {
        if (soc_reg_field_valid(unit, MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r, 
                    kt2_srcport_field_names[port])) {
            /* PRIx_GRP = 0x7 */
            soc_reg_field_set(unit, MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r, 
                    &rval,kt2_srcport_field_names[port], 3);
        } else {
            if (!((port == KT2_OLP_PORT) && 
                        (SOC_INFO(unit).olp_port[0] == 1))) {
                LOG_WARN(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "WARN: Suspicious Config: Port=%d\n"),
                         port));
            }
        }
    }
    WRITE_MMU_ENQ_IP_PRI_TO_PG_PROFILE_0r_REG32(unit, rval);
    return SOC_E_NONE;
}

STATIC int
_soc_katana2_mmu_init(int unit)
{
    uint32 rval;
    uint64 r64val, rval64;
    int                 mmu_init_usec, i;
    soc_timeout_t       to;
    /* uint32 entry[SOC_MAX_MEM_WORDS]; */
    mmu_aging_lmt_int_entry_t age_entry;
    int count;
    int port;
    uint16 dev_id;
    uint8 rev_id;
    uint32 ext_pbmp_count=0;
    pbmp_t ext_pbmp;
    int num_source_contexts, max_queues;
    soc_info_t *si;
    uint8 ema_mapping[][8] = {
        {0,0,0,0,0,0,0,0} /* Should never be used */
        , 
            {0,0,0,0,0,0,0,0} 
        
        , /* Max queues = 1 */
            {0,0,0,0,1,1,1,1}

        , /* Max queues = 2 */
            {0,0,0,1,1,1,2,2}

        , /* Max queues = 3 */
            {0,0,1,1,2,2,3,3}

        , /* Max queues = 4 */
            {0,0,1,1,2,2,3,4}

        , /* Max queues = 5 */
            {0,0,1,1,2,3,4,5}

        , /* Max queues = 6 */
            {0,0,1,2,3,4,5,6}

        , /* Max queues = 7 */
            {0,1,2,3,4,5,6,7}
         /* Max queues = 8 */

    };

    si = &SOC_INFO(unit);
    soc_cm_get_id(unit, &dev_id, &rev_id);

    /* Init Link List Scheduler */
    rval = 0;
    soc_reg_field_set(unit, LLS_SOFT_RESETr, &rval, SOFT_RESETf, 0);
    SOC_IF_ERROR_RETURN(WRITE_LLS_SOFT_RESETr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, LLS_INITr, &rval, INITf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_INITr(unit, rval));

    /* Wait for LLS init done. */
    if (SAL_BOOT_SIMULATION) {
        mmu_init_usec = 10000000; /* Simulation  .. 10sec */
    } else {
        mmu_init_usec = 50000;
    }
    soc_timeout_init(&to, mmu_init_usec, 0);
    do {
        SOC_IF_ERROR_RETURN(READ_LLS_INITr(unit, &rval));
        if (soc_reg_field_get(unit, LLS_INITr, rval, INIT_DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : LLS INIT timeout\n"), unit));
            break;
        }
    } while (TRUE);

    /* Setup TDM for MMU Arb & LLS */
    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_tdm_init(unit));

    for(i=0; i<16; i++) {
        SOC_IF_ERROR_RETURN(READ_TOQ_EXT_MEM_BW_MAP_TABLEr(unit, i, &rval));
        
        soc_reg_field_set(unit, TOQ_EXT_MEM_BW_MAP_TABLEr, &rval,
                                            GBL_GUARENTEE_BW_LIMITf, 1450);
        soc_reg_field_set(unit, TOQ_EXT_MEM_BW_MAP_TABLEr, &rval,
                                            WR_PHASEf, 142);/* KT2 */
        soc_reg_field_set(unit, TOQ_EXT_MEM_BW_MAP_TABLEr, &rval,
                                            RD_PHASEf, 138);/* KT2 */
        SOC_IF_ERROR_RETURN(
            WRITE_TOQ_EXT_MEM_BW_MAP_TABLEr(unit,i,rval));
    }

    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase1(unit));

    rval = 0;
    soc_reg_field_set(unit, DEQ_EFIFO_CFG_COMPLETEr, &rval, EGRESS_FIFO_CONFIGURATION_COMPLETEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_DEQ_EFIFO_CFG_COMPLETEr(unit, rval));

    /* Enable LLS */
    rval = 0;
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, DEQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, ENQUEUE_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, FC_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, MIN_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, PORT_SCHEDULER_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_CONFIG0r, &rval, SHAPER_ENABLEf, 1);
    if (SOC_REG_FIELD_VALID(unit, LLS_CONFIG0r, SPRI_VECT_MODE_ENABLEf)) {
        if (soc_feature(unit, soc_feature_vector_based_spri)) {
            soc_reg_field_set(unit, LLS_CONFIG0r, &rval,
                              SPRI_VECT_MODE_ENABLEf, 1);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_LLS_CONFIG0r(unit, rval));

    /* Enable shaper background refresh */
    rval = 0;
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, L0_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, L1_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, L2_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, PORT_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, S0_MAX_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MAX_REFRESH_ENABLEr, &rval, S1_MAX_REFRESH_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_MAX_REFRESH_ENABLEr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, LLS_MIN_REFRESH_ENABLEr, &rval, L0_MIN_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MIN_REFRESH_ENABLEr, &rval, L1_MIN_REFRESH_ENABLEf, 1);
    soc_reg_field_set(unit, LLS_MIN_REFRESH_ENABLEr, &rval, L2_MIN_REFRESH_ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_LLS_MIN_REFRESH_ENABLEr(unit, rval));

    /* RQE configuration */
    rval = 0;
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L0_MCM_MODEf, 1);
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L0_CC_MODEf, 1);
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L0_UCM_MODEf, 1);
    soc_reg_field_set(unit, RQE_SCHEDULER_CONFIGr, &rval,
                      L1_MODEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_RQE_SCHEDULER_CONFIGr(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, RQE_SCHEDULER_WEIGHT_L0_QUEUEr, &rval,
                      WRR_WEIGHTf, 1);
    for(i=0; i<SOC_REG_NUMELS(unit, RQE_SCHEDULER_WEIGHT_L0_QUEUEr); i++) {
        SOC_IF_ERROR_RETURN(WRITE_RQE_SCHEDULER_WEIGHT_L0_QUEUEr(unit, i, 
                                                                 rval));
    }

    rval = 0;
    soc_reg_field_set(unit, RQE_SCHEDULER_WEIGHT_L1_QUEUEr, &rval,
                      WRR_WEIGHTf, 1);
    for(i=0; i<SOC_REG_NUMELS(unit, RQE_SCHEDULER_WEIGHT_L1_QUEUEr); i++) {
        SOC_IF_ERROR_RETURN(WRITE_RQE_SCHEDULER_WEIGHT_L1_QUEUEr(unit, i, 
                                                                 rval));
    }

    /* Enable all ports */
    COMPILER_64_ZERO(r64val);
    COMPILER_64_SET(rval64, 0x3ff, 0xffffffff); /*Bits 0..41 */
    soc_reg64_field_set(unit, INPUT_PORT_RX_ENABLE_64r, &r64val,
                          INPUT_PORT_RX_ENABLEf, rval64);
    SOC_IF_ERROR_RETURN(WRITE_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_INPUT_PORT_RX_ENABLE_64r(unit, r64val));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_INPUT_PORT_RX_ENABLE_64r(unit, r64val));

    SOC_IF_ERROR_RETURN(WRITE_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_THDI_BYPASSr(unit, 0));
    SOC_IF_ERROR_RETURN(WRITE_THDO_BYPASSr(unit, 0));

    ext_pbmp = soc_property_get_pbmp(unit, spn_PBMP_EXT_MEM, 0);
    SOC_PBMP_COUNT(ext_pbmp, ext_pbmp_count);
    if (!ext_pbmp_count) {
        if (SOC_DDR3_NUM_MEMORIES(unit)) {
            ext_pbmp_count=1;  
        }
    }
    if (soc_feature(unit, soc_feature_ddr3) && (ext_pbmp_count != 0)) {
        /* Configure EMC */
        SOC_IF_ERROR_RETURN(READ_EMC_CFGr(unit, &rval));
        soc_reg_field_set(unit, EMC_CFGr, &rval, NUM_CISf, 
            SOC_DDR3_NUM_MEMORIES(unit)); /* Number of CIs attached to EMC */
        soc_reg_field_set(unit, EMC_CFGr, &rval, DRAM_SIZEf, 2); 
        SOC_IF_ERROR_RETURN(WRITE_EMC_CFGr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_EMC_FREE_POOL_SIZESr(unit, &rval));
        soc_reg_field_set(unit, EMC_FREE_POOL_SIZESr, &rval, WTFP_SIZEf, 240);
        soc_reg_field_set(unit, EMC_FREE_POOL_SIZESr, &rval, RSFP_SIZEf, 128);
        SOC_IF_ERROR_RETURN(WRITE_EMC_FREE_POOL_SIZESr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_EMC_IWRB_SIZEr(unit, &rval));
        soc_reg_field_set(unit, EMC_IWRB_SIZEr, &rval, IWRB_SIZEf, 2);
        SOC_IF_ERROR_RETURN(WRITE_EMC_IWRB_SIZEr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_EMC_IRRB_THRESHOLDSr(unit, &rval));
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_Q_XOFF_THRESHOLDf, 0x10);
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_UNDERRUN_Q_XOFF_THRESHOLDf, 0x28);
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_UNDERRUN_Q_XON_THRESHOLDf, 0x18);
        soc_reg_field_set(unit, EMC_IRRB_THRESHOLDSr, &rval, ALL_Q_XON_THRESHOLDf, 8);
        SOC_IF_ERROR_RETURN(WRITE_EMC_IRRB_THRESHOLDSr(unit, rval));
    }

    /* WRED Configuration */
    if (dev_id != BCM56450_DEVICE_ID) { /* And all other 90MHz variants */
        SOC_IF_ERROR_RETURN(READ_WRED_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, WRED_MISCCONFIGr, &rval, BASE_UPDATE_INTERVALf, 7);
        SOC_IF_ERROR_RETURN(WRITE_WRED_MISCCONFIGr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_WRED_PARITY_ERROR_MASKr(unit, &rval));
        soc_reg_field_set(unit, WRED_PARITY_ERROR_MASKr, &rval, UPDATE_INTRPT_MASKf, 0);
        SOC_IF_ERROR_RETURN(WRITE_WRED_PARITY_ERROR_MASKr(unit, rval));

        SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
        soc_reg_field_set(unit, MISCCONFIGr, &rval, REFRESH_ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));
    }
    for(port = 0; port < 42; port++) {
        SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase3(unit, port));
    }

    SOC_IF_ERROR_RETURN(_soc_katana2_perq_flex_counters_init(unit, 0));

    rval = 0xffffffff; /* PRIx_GRP = 0x7 */
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_0_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_0_PRI_GRP1r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_1_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_1_PRI_GRP1r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_2_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_2_PRI_GRP1r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_3_PRI_GRP0r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_PROFILE_3_PRI_GRP1r(unit, rval));

    /* Input port shared space */
/*    rval = 0;
    soc_reg_field_set(unit, USE_SP_SHAREDr, &rval, ENABLEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_USE_SP_SHAREDr(unit, rval));
*/
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEXT_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIEMA_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIRQE_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));
    SOC_IF_ERROR_RETURN(WRITE_THDIQEN_BUFFER_CELL_LIMIT_SP_SHAREDr(unit,0));

    /* Input port per-device global headroom */
    rval = 0;
    SOC_IF_ERROR_RETURN(READ_OP_THR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, OP_THR_CONFIGr, &rval, EARLY_E2E_SELECTf, 0);
    SOC_IF_ERROR_RETURN(WRITE_OP_THR_CONFIGr(unit, rval));

    /* Helper function for MMU settings based on
       memory selection (internal/external/both) and mode (lossless/lossy) */

    if (!SOC_WARM_BOOT(unit)) {
        SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_helper(unit, -1));
    }
 

    /* Initialize MMU internal/external aging limit memory */
    count = soc_mem_index_count(unit, MMU_AGING_LMT_INTm); 
    sal_memset(&age_entry, 0, sizeof(mmu_aging_lmt_int_entry_t));
    for (i=0; i < count; i++) {
        SOC_IF_ERROR_RETURN(WRITE_MMU_AGING_LMT_INTm(unit,
                            MEM_BLOCK_ALL, i, &age_entry));
    }

    count = soc_mem_index_count(unit, MMU_AGING_LMT_EXTm); 
    for (i=0; i < count; i++) {
        SOC_IF_ERROR_RETURN(WRITE_MMU_AGING_LMT_EXTm(unit,
                            MEM_BLOCK_ALL, i, &age_entry));
    }

    SOC_IF_ERROR_RETURN(READ_THDO_DROP_CTR_CONFIGr(unit, &rval));
    soc_reg_field_set(unit, THDO_DROP_CTR_CONFIGr, &rval, OP_CNT_CFGf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_DROP_CTR_CONFIGr(unit, rval));

    _soc_kt2_mem_config(unit);

    SOC_IF_ERROR_RETURN(_soc_katana2_mmu_set_invalid_parent(unit));

    rval = 0;
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_0f, 0);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_1f, 1);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_2f, 2);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_3f, 3);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_4f, 4);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_5f, 5);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_6f, 6);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_0r, &rval, RQE_QUEUE_PRI_7f, 7);
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_RQE_QUEUE_SELECT_0r(unit, rval));


    rval = 0;
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_8f, 7);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_9f, 7);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_10f, 7);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_11f, 7);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_12f, 7);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_13f, 7);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_14f, 7);
    soc_reg_field_set(unit, MMU_ENQ_RQE_QUEUE_SELECT_1r, &rval, RQE_QUEUE_PRI_15f, 7);
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_RQE_QUEUE_SELECT_1r(unit, rval));
    

    /* Configure the internal priority to EMA queue mapping
       0 to 7 use an identity mapping. All other priorities use queue 7*/
    /* Refer point number 1.3.3 in KT2 micro arch doc */ 
    num_source_contexts = _soc_katana2_get_max_stream_ids(unit);
    num_source_contexts += si->lb_port;

    max_queues = KT2_MAX_NUMBER_INTERLEAVED_PKTS / num_source_contexts;
     
    if (max_queues == 0) {
        return SOC_E_INTERNAL;
    }

    if (max_queues > 8 ) {
        max_queues = 8;
    }

    rval = 0;
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval,
            EMA_QUEUE_PRI_0f, ema_mapping[max_queues][0]);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval, 
            EMA_QUEUE_PRI_1f, ema_mapping[max_queues][1]);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval,
            EMA_QUEUE_PRI_2f, ema_mapping[max_queues][2]);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval,
            EMA_QUEUE_PRI_3f, ema_mapping[max_queues][3]);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval, 
            EMA_QUEUE_PRI_4f, ema_mapping[max_queues][4]);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval,
            EMA_QUEUE_PRI_5f, ema_mapping[max_queues][5]);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval, 
            EMA_QUEUE_PRI_6f, ema_mapping[max_queues][6]);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_0r, &rval,
            EMA_QUEUE_PRI_7f, ema_mapping[max_queues][7]);
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_EMA_QUEUE_SELECT_0r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval, 
            EMA_QUEUE_PRI_8f, max_queues - 1);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval,
            EMA_QUEUE_PRI_9f, max_queues - 1);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval,
            EMA_QUEUE_PRI_10f, max_queues - 1);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval,
            EMA_QUEUE_PRI_11f, max_queues - 1);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval,
            EMA_QUEUE_PRI_12f, max_queues - 1);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval,
            EMA_QUEUE_PRI_13f, max_queues - 1);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval,
            EMA_QUEUE_PRI_14f, max_queues - 1);
    soc_reg_field_set(unit, MMU_ENQ_EMA_QUEUE_SELECT_1r, &rval,
            EMA_QUEUE_PRI_15f, max_queues - 1);
    SOC_IF_ERROR_RETURN(WRITE_MMU_ENQ_EMA_QUEUE_SELECT_1r(unit, rval));

    return SOC_E_NONE;
}
int _soc_katana2_mmu_reconfigure(int unit, int port)
{
  SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase4_port(unit, port)); 
  SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_phase3(unit, port)); 
  SOC_IF_ERROR_RETURN(_soc_katana2_mmu_init_helper(unit, port));
  return SOC_E_NONE;
}

STATIC int
_soc_katana2_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    uint32 rval;

    SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &rval));
    *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_ENAf);
    *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, rval, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_age_timer_max_get(int unit, int *max_seconds)
{
    *max_seconds =
        soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_katana2_age_timer_set(int unit, int age_seconds, int enable)
{
    uint32 rval;

    rval = 0;
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_ENAf, enable);
    soc_reg_field_set(unit, L2_AGE_TIMERr, &rval, AGE_VALf, age_seconds);
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, rval));

    return SOC_E_NONE;
}

int kt2_linkphy_port[2][4] = {
    {27, 32, 33, 34}, /* {T,R}XLP0 */
    {28, 29, 30, 31}  /* {T,R}XLP1 */
};

int 
soc_kt2_linkphy_port_reg_blk_idx_get(
    int unit, int port, int blktype, int *block, int *index)
{
    int i,j;
    int blk = -1;
    int idx = -1;

#ifdef BCM_METROLITE_SUPPORT
    if (SOC_IS_METROLITE(unit)) {
        return soc_ml_linkphy_port_reg_blk_idx_get(unit, port,
                    blktype,block,index);
    } else
#endif
#ifdef BCM_SABER2_SUPPORT
     if (SOC_IS_SABER2(unit)) {
         return soc_sb2_linkphy_port_reg_blk_idx_get(unit, port,
                     blktype,block,index);
     }
#endif

    for (i=0; i<2; i++) {
        for(j=0; j<4; j++) {
            if(port == kt2_linkphy_port[i][j]) {
                    blk = i;
                    idx = j;
                    break;
            }
        }
    }

    if (blktype == SOC_BLK_TXLP) {
        if (blk == 0) {
            blk = TXLP0_BLOCK(unit);
        } else if (blk == 1) {
            blk = TXLP1_BLOCK(unit);
        }
    } else if (blktype == SOC_BLK_RXLP) {
        if (blk == 0) {
            blk = RXLP0_BLOCK(unit);
        } else if (blk == 1) {
            blk = RXLP1_BLOCK(unit);
        }
    } else {
        return SOC_E_PARAM;
    }

    if (block != NULL) {
        *block = blk;
    }
    if (index != NULL) {
        *index = idx;
    }
    if ((blk == -1) || (idx == -1)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

int
soc_kt2_linkphy_port_blk_idx_get(
    int unit, int port, int *block, int *index)
{
    int i,j;
    int blk = -1;
    int idx = -1;

    for (i=0; i<2; i++) {
        for(j=0; j<4; j++) {
            if(port == kt2_linkphy_port[i][j]) {
                    blk = i;
                    idx = j;
                    break;
            }
        }
    }

    if (block != NULL) {
        *block = blk;
    }
    if (index != NULL) {
        *index = idx;
    }
    if ((blk == -1) || (idx == -1)) {
        return SOC_E_NOT_FOUND;
    }
    return SOC_E_NONE;
}

int soc_kt2_linkphy_get_portid(int unit, int block, int index) {
    if (index > 3) {
        return -1;
    }
    if ((block == TXLP0_BLOCK(unit)) || (block == RXLP0_BLOCK(unit))) {
        return kt2_linkphy_port[0][index];
    } else if ((block == TXLP1_BLOCK(unit)) || (block == RXLP1_BLOCK(unit))) {
            return kt2_linkphy_port[1][index];
    }
    return -1;
}


/*
 * cpu port (mmu port 0): 48 queues (0-47)
 * loopback port (48-71)
 * hg ports : 24 queues
 * other ports : 8 queues                              
 */

int
soc_katana2_num_cosq_init(int unit)
{
    soc_info_t *si;
    int port, prev_port;
    int numq = 0, i;
    int pp_port_cos;
    int start_pp_port, end_pp_port;
    int packing_mode;
    int max_queue_num = -1;
    int max_port = -1;
    int num_uc_cosq = 0;
    
    si = &SOC_INFO(unit);
    prev_port = 0;
    packing_mode = soc_property_get(unit, spn_MMU_MULTI_PACKETS_PER_CELL, 0); 
    

    max_queue_num = soc_mem_index_max(unit, MMU_THDO_QCONFIG_CELLm);
    if (max_queue_num == 0) {
        /* Possible with first time in soc_init() call */
        /* coverity[dead_error_line:FALSE] */
        return SOC_E_NONE;
    }

    max_port = LB_PORT(unit) + 1;
    for (port = 0; port < max_port; port++) {
        si->port_num_ext_cosq[port] = 0;
        si->port_num_cosq[port] = 0;

        if (IS_CPU_PORT(unit, port)) {
            si->port_cosq_base[port] = 0;
            si->port_uc_cosq_base[port] = 0;
            si->port_num_uc_cosq[port] = NUM_CPU_COSQ(unit);
            si->port_num_ext_cosq[port] = 0;
        } else if (IS_LB_PORT(unit, port)) {
            si->port_cosq_base[port] = 48;
            si->port_uc_cosq_base[port] = 48;
            si->port_num_uc_cosq[port] = 24;
        } else {
            si->port_uc_cosq_base[port] = si->port_uc_cosq_base[prev_port] +
                                          numq;
            si->port_cosq_base[port] = si->port_uc_cosq_base[port];
            if (IS_HG_PORT(unit, port)) {
                si->port_num_uc_cosq[port] = 24;
            } else {
                num_uc_cosq = soc_property_port_get(unit, port,
		    spn_LLS_NUM_L2UC, 8); /* KT2_DEFAULT_NUM_PHYSICAL_QUEUES */
		if (num_uc_cosq < 8) {
		    num_uc_cosq = 8;
		}
		si->port_num_uc_cosq[port] = num_uc_cosq;
            }
        }
        prev_port = port;

        if (IS_CPU_PORT(unit, port)) {
            /* first front panel port needs to start with 72 */
            numq = 72;
        } else {
            numq = si->port_num_uc_cosq[port];
        }
        if (si->port_cosq_base[port] + si->port_num_uc_cosq[port] >
            max_queue_num) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                       "###ATTN:Physical queue assignment for port:%d exceeded"
                       " max value:%d###\n INFO: Start queue:%d End Queue %d\n"), 
                       port, max_queue_num,
                       si->port_cosq_base[port],
                       si->port_cosq_base[port] + si->port_num_uc_cosq[port]));
            return SOC_E_CONFIG;
        }


        pp_port_cos = soc_property_port_get(unit, port,
                                spn_NUM_SUBPORT_COS, 4);

        if (si->port_num_subport[port] > 0) {
            start_pp_port = si->port_subport_base[port];
            end_pp_port = si->port_subport_base[port] + 
                          si->port_num_subport[port];
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,
                                    "start_pp_port:%d end_pp_port:%d \n"),
                         start_pp_port, end_pp_port));

            for (i = start_pp_port; i < end_pp_port; i++) {
                si->port_uc_cosq_base[i] = si->port_uc_cosq_base[port] + numq;
                si->port_cosq_base[i] = si->port_uc_cosq_base[i];
                si->port_num_uc_cosq[i] = pp_port_cos;
                numq += pp_port_cos;
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                           (BSL_META_U(unit,
                           "port:%d port_uc_cosq_base[pp_port%d]:%d:End:%d \n"),
                            port, i, si->port_uc_cosq_base[i],
                            si->port_uc_cosq_base[i] +
                            si->port_num_uc_cosq[i] - 1));
                if (si->port_cosq_base[i] + si->port_num_uc_cosq[i] >
                    max_queue_num) {
                    LOG_ERROR(BSL_LS_SOC_COMMON,
                              (BSL_META_U(unit,
                               "###ATTN:Subport queue assignment for port:%d exceeded"
                               " max value:%d###\n INFO: Start queue:%d End Queue %d \n"), 
                               port, max_queue_num,
                               si->port_cosq_base[i],
                               si->port_cosq_base[i] +
                               si->port_num_uc_cosq[i] - 1));
                    return SOC_E_CONFIG;
                }
                /*if (soc_feature(unit, soc_feature_mmu_packing)) { */
                if (packing_mode) {
                    si->port_cosq_base[i] += (soc_mem_index_count(unit,LLS_L2_PARENTm) >> 1);
                    si->port_num_cosq[i] = si->port_num_uc_cosq[i];
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                                (BSL_META_U(unit,
                                 "Packing Cosq Base:%d Num Cosq:%d \n"),
                                 si->port_cosq_base[i], si->port_num_cosq[i]));
                    if (si->port_cosq_base[i] + si->port_num_cosq[i] >
                        max_queue_num) {
                        LOG_ERROR(BSL_LS_SOC_COMMON,
                                 (BSL_META_U(unit,
                                 "###ATTN:Packing queue assignment for "
                                 "port:%d exceeded max value:%d###\n"
                                 "INFO:Start queue:%d End Queue %d\n"),
                                 port, max_queue_num,
                                 si->port_cosq_base[i],
                                 si->port_cosq_base[i] + si->port_num_cosq[i]));
                        return SOC_E_CONFIG;
                    }
                }
            }
        }

        /*if (soc_feature(unit, soc_feature_mmu_packing)) { */
        if (packing_mode) {
            if (!IS_CPU_PORT(unit, port)) {
                si->port_cosq_base[port] += 2048;
            }
            si->port_num_cosq[port] = si->port_num_uc_cosq[port];    
        }
        
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                                "\nport num %d cosq_base %d num_cosq %d"),
                     port, si->port_cosq_base[port], si->port_num_uc_cosq[port]));
    }
    
    return SOC_E_NONE;
}

soc_blk_ctr_reg_desc_t _soc_kt2_blk_ctr_reg_desc[] =
{
    {
        SOC_BLK_RXLP,
        {
            {RXLP_UNEXPECTED_ETHERTYPEr, 1, 1, 0},
            {RXLP_UNKNOWN_STREAM_IDr, 1, 1, 0},
            {RXLP_DFC_FRAMESr, 1, 1, 0},
            {RXLP_DFC_FRAME_UNEXPECTED_MACDAr, 1, 1, 0},
            {RXLP_DFC_FRAME_UNEXPECTED_MACSAr, 1, 1, 0},
            {RXLP_DFC_HEADER_OPCODE_ERRORr, 1, 1, 0},
            {RXLP_DFC_HEADER_TIME_ERRORr, 1, 1, 0},
            {RXLP_DFC_LENGTH_ERRORr, 1, 1, 0},
            {INVALIDr, 0, 0}
        }
    }
};

void
soc_kt2_blk_counter_config(int unit)
{
    soc_control_t *soc = SOC_CONTROL(unit);
    /* TimeBeing Skipping it due to some NACK issue */
    if (!(SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM)) {
        LOG_CLI((BSL_META_U(unit,
                            "QUICKTURN|BOARD:ATTN:Skipping RXLP Counter(NACK-issue)\n")));
        soc->blk_ctr_desc_count = 0;
    } else {
        soc->blk_ctr_desc_count = COUNTOF(_soc_kt2_blk_ctr_reg_desc);
    }
    soc->blk_ctr_desc = _soc_kt2_blk_ctr_reg_desc;
}

/*
 * Katana chip driver functions.
 */
soc_functions_t soc_katana2_drv_funs = {
    _soc_katana2_misc_init,
    _soc_katana2_mmu_init,
    _soc_katana2_age_timer_get,
    _soc_katana2_age_timer_max_get,
    _soc_katana2_age_timer_set,
};

/* KT2 OAM */
STATIC
soc_field_t _soc_kt2_oam_interrupt_fields[] = {
    SOME_RMEP_CCM_DEFECTf,
    SOME_RDI_DEFECTf,
    ERROR_CCM_DEFECTf,
    XCON_CCM_DEFECTf,
    ANY_RMEP_TLV_INTERFACE_UPf,
    ANY_RMEP_TLV_INTERFACE_DOWNf,
    ANY_RMEP_TLV_PORT_UPf,
    ANY_RMEP_TLV_PORT_DOWNf,
    INVALIDf
};

void
soc_kt2_oam_interrupt_process(int unit)
{
    uint32 rval;
    int rv, found = 0, fidx = 0;
    soc_kt2_oam_handler_t oam_handler_snapshot = kt2_oam_handler[unit];

    rv = READ_IP1_INTR_ENABLE_1r(unit, &rval);
    while (_soc_kt2_oam_interrupt_fields[fidx] != INVALIDf) {
        if (soc_reg_field_get(unit, IP1_INTR_ENABLE_1r, rval,
                          _soc_kt2_oam_interrupt_fields[fidx])) {
            found++;
        }
        fidx++;
    }
    if (!found) {
        LOG_ERROR(BSL_LS_SOC_COMMON, \
                  (BSL_META_U(unit, \
                              "Unexpected interrupt \
                              received for OAM rv=0x%x!!\n"), rv));
    } else {
        if (oam_handler_snapshot != NULL) {
            (void)(oam_handler_snapshot(unit, 
                                       _soc_kt2_oam_interrupt_fields[fidx]));
        }
    }
}

void
soc_kt2_rxlp_interrupt_process(int unit, bcm_port_t port, uint32 rval)
{
    soc_kt2_linkphy_handler_t lp_handler_snapshot = kt2_linkphy_handler[unit];
    int rv = SOC_E_NONE;
    /* Call the registered handler */
    if (lp_handler_snapshot != NULL) {
        rv = lp_handler_snapshot(unit, port, rval);
        if (rv < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON, \
                    (BSL_META_U(unit, \
                                "Interrupt \
                                handler error for LINK PHY rv=0x%x!!\n"), rv));
        }
    }
}

void
soc_kt2_oam_handler_register(int unit, soc_kt2_oam_handler_t handler)
{
    int rv, fidx = 0;
    uint32 rval;

    kt2_oam_handler[unit] = handler;
    
    rv = READ_IP1_INTR_ENABLE_1r(unit, &rval);
    if (rv) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error reading %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP1_INTR_ENABLE_1r)));
    }
    while (_soc_kt2_oam_interrupt_fields[fidx] != INVALIDf) {
        soc_reg_field_set(unit, IP1_INTR_ENABLE_1r, &rval,
                          _soc_kt2_oam_interrupt_fields[fidx], 1);
        fidx++;
    }
    rv = WRITE_IP1_INTR_ENABLE_1r(unit, rval);
    if (rv) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "unit %d: Error writing %s reg !!\n"),
                              unit, SOC_REG_NAME(unit, IP1_INTR_ENABLE_1r)));
    }
    /* Write CMIC enable register for oam event*/
    if (SOC_IS_SABER2(unit)) {
        /* For Saber2 */
        (void)soc_cmicm_intr3_enable(unit, SB2_OAM_CMIC_INTR_MASK);
    } else {
        (void)soc_cmicm_intr2_enable(unit, KT2_OAM_CMIC_INTR_MASK);
    }
}


void
soc_kt2_linkphy_handler_register(int unit, soc_kt2_linkphy_handler_t handler)
{
    kt2_linkphy_handler[unit] = handler;
}


void
soc_kt2_oam_ser_handler_register(int unit, soc_kt2_oam_ser_handler_t handler) 
{
    kt2_oam_ser_handler[unit] = handler;
}

int
soc_kt2_oam_ser_process(int unit, soc_mem_t mem, int index) 
{
    if (kt2_oam_ser_handler[unit]) {
        return kt2_oam_ser_handler[unit](unit, mem, index);
    } else {
        return SOC_E_UNAVAIL;
    }
}



/* soc_kt2_mem_config:
 * Over-ride the default table sizes (from regsfile) for any SKUs here
 */
int
soc_kt2_mem_config(int unit, int dev_id)
{
    int rv = SOC_E_NONE;
    int num_ipv6_128b_entries = 0;
    int config_v6_entries = 0;
    int defip_config = 0;
    soc_persist_t *sop = SOC_PERSIST(unit);

    switch (dev_id) {
        case BCM56248_DEVICE_ID:
        case BCM56456_DEVICE_ID:
            sop->memState[LLS_L2_PARENTm].index_max = 1023;
            sop->memState[LLS_L2_SHAPER_CONFIG_LOWERm].index_max=127;
            sop->memState[LLS_L2_SHAPER_CONFIG_UPPERm].index_max=127;
            sop->memState[MMU_THDO_QCONFIG_CELLm].index_max = 1023;
            sop->memState[MMU_THDO_QCONFIG_QENTRYm].index_max = 1023;
            sop->memState[MMU_THDO_QCOUNT_CELL_0m].index_max = 1023;
            sop->memState[MMU_THDO_QOFFSET_CELLm].index_max = 1023;
            sop->memState[MMU_THDO_QOFFSET_QENTRYm].index_max = 1023;
            sop->memState[MMU_THDO_QRESET_VALUE_CELL_0m].index_max = 1023;
            sop->memState[MMU_THDO_QRESET_VALUE_QENTRY_0m].index_max = 1023;
            sop->memState[MMU_THDO_QSTATUS_CELL_0m].index_max = 1023;
            sop->memState[MMU_THDO_QSTATUS_QENTRY_0m].index_max = 1023;
            sop->memState[MMU_TOQ_STATE_MEM0m].index_max = 1023;
            sop->memState[MMU_TOQ_STATE_MEM1m].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_AVG_QSIZE_BUFFERm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_AVG_QSIZE_QENTRYm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_CONFIG_BUFFERm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_CONFIG_QENTRYm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_DROP_THD_DEQm].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_DROP_THD_ENQ_0m].index_max = 1023;
            sop->memState[MMU_WRED_QUEUE_OP_NODE_MAPm].index_max = 1023;
            sop->memState[THDO_QCOUNT_QENTRY_0m].index_max = 1023;
            if (dev_id == BCM56248_DEVICE_ID) {
                sop->memState[L2Xm].index_max = 32767;
                sop->memState[L2_ENTRY_ONLYm].index_max = 32767;
                sop->memState[L2_HITDA_ONLYm].index_max = 4095;
                sop->memState[L2_HITSA_ONLYm].index_max = 4095;
            }
            break;
        case BCM56457_DEVICE_ID:
        case BCM56458_DEVICE_ID:
            sop->memState[MMU_THDO_QCONFIG_CELLm].index_max = 1023;
            break;
        default:
            break;
    }
    /* L3_DEFIP sizing */
    if (dev_id == BCM55455_DEVICE_ID || dev_id == BCM55450_DEVICE_ID) { 
        SOC_CONTROL(unit)->l3_defip_max_tcams = 0;
        SOC_CONTROL(unit)->l3_defip_tcam_size = 0;
        sop->memState[L3_DEFIP_PAIR_128m].index_max = 0;
        sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max = 0;
        sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max = 0;
        sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max = 0;
        sop->memState[L3_DEFIPm].index_max = 0;
        sop->memState[L3_DEFIP_ONLYm].index_max = 0;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 0;
        sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 0;
        SOC_CONTROL(unit)->l3_defip_index_remap = 0;
    } else {
        SOC_CONTROL(unit)->l3_defip_max_tcams = _SOC_KT2_DEFIP_MAX_TCAMS;
        SOC_CONTROL(unit)->l3_defip_tcam_size = _SOC_KT2_DEFIP_TCAM_DEPTH;
        
        if (soc_property_get(unit, "l3_defip_sizing", TRUE)) {
            defip_config = soc_property_get(unit, spn_IPV6_LPM_128B_ENABLE, 1);
        
            num_ipv6_128b_entries =
                soc_property_get(unit, spn_NUM_IPV6_LPM_128B_ENTRIES,
                    (defip_config ? 1024 : 0));
        
            config_v6_entries = num_ipv6_128b_entries;
        
            if (soc_property_get(unit, spn_LPM_SCALING_ENABLE, 0)) {
                num_ipv6_128b_entries = 0;
                if (!soc_property_get(unit, spn_LPM_IPV6_128B_RESERVED, 1)) {
                     config_v6_entries = SOC_CONTROL(unit)->l3_defip_tcam_size *
                        ((config_v6_entries /
                         SOC_CONTROL(unit)->l3_defip_tcam_size) +
                        ((config_v6_entries %
                         SOC_CONTROL(unit)->l3_defip_tcam_size) ? 1 : 0));
                }
            }
        
            sop->memState[L3_DEFIP_PAIR_128m].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_DATA_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIP_PAIR_128_HIT_ONLYm].index_max =
                                              num_ipv6_128b_entries - 1;
            sop->memState[L3_DEFIPm].index_max =
                                     (SOC_CONTROL(unit)->l3_defip_max_tcams *
                                     SOC_CONTROL(unit)->l3_defip_tcam_size) -
                                     (num_ipv6_128b_entries * 2) - 1;
            sop->memState[L3_DEFIP_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max =
                                          sop->memState[L3_DEFIPm].index_max;
            SOC_CONTROL(unit)->l3_defip_index_remap = num_ipv6_128b_entries;
            
            soc_l3_defip_indexes_init(unit, config_v6_entries);
        }      
    }
    return rv;
}

static const soc_reg_t pvtmon_result_reg[] = {
    TOP_PVTMON_RESULT_0r, TOP_PVTMON_RESULT_1r,
    TOP_PVTMON_RESULT_2r, TOP_PVTMON_RESULT_3r
};

int 
_soc_katana2_temperature_monitor_init(int unit) {
    uint32 rval;
    
    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, PROG_RESISTERf, 3);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, BG_ADJf, 3);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, MEASUREMENT_CALLIBRATIONf, 5);    
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_SELECTf, 0);
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    sal_usleep(1000);

    return SOC_E_NONE;
}    

int
soc_kt2_temperature_monitor_get(int unit,
          int temperature_max,
          soc_switch_temperature_monitor_t *temperature_array,
          int *temperature_count)
{
    uint32 rval;
    soc_reg_t reg;
    int index;
    int fval, cur, peak;
    int num_entries_out;

    *temperature_count = 0;
    if (COUNTOF(pvtmon_result_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        num_entries_out = COUNTOF(pvtmon_result_reg);
    }
    /* Check to see if the thermal monitor is initialized */
    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    if ((soc_reg_field_get(unit, TOP_PVTMON_CTRL_1r, rval, PVTMON_RSTBf) == 0) ||
        (soc_reg_field_get(unit, TOP_PVTMON_CTRL_1r, rval, PVTMON_SELECTf) != 0)) {
        SOC_IF_ERROR_RETURN(_soc_katana2_temperature_monitor_init(unit));
   }

    for (index = 0; index < num_entries_out; index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        cur = (4180000 - (5556 * fval)) / 1000;
        fval = soc_reg_field_get(unit, reg, rval, PEAK_TEMP_DATAf);
        peak = (4180000 - (5556 * fval)) / 1000;
        (temperature_array + index)->curr = cur;
        (temperature_array + index)->peak = peak;
    }
    SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON0_PEAK_DATA_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON1_PEAK_DATA_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON2_PEAK_DATA_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON3_PEAK_DATA_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON0_PEAK_DATA_RST_Lf, 0);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON1_PEAK_DATA_RST_Lf, 0);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON2_PEAK_DATA_RST_Lf, 0);
    soc_reg_field_set(unit, TOP_MISC_CONTROL_0r, &rval,
                      THERMAL_PVTMON3_PEAK_DATA_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_0r(unit, rval));
    *temperature_count=num_entries_out;
    
    return SOC_E_NONE;
}

int
soc_kt2_show_ring_osc(int unit)
{
    soc_reg_t ctrl_reg;
    uint32 rval, fval;
    int core_clk, quo, rem, frac;
    int ring_osc, ring_sel;
    int cmc = SOC_PCI_CMC(unit);

    core_clk = SOC_INFO(unit).frequency * 1024;
    ctrl_reg = TOP_MISC_CONTROL_2r;

    for (ring_osc = 2; ring_osc < 4; ring_osc++) {
        for (ring_sel = 0; ring_sel < 2; ring_sel++) {
            rval = 0;
            SOC_IF_ERROR_RETURN(READ_TOP_MISC_CONTROL_2r(unit, &rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_ENABLEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_ENf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));

            soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_0_SELf, ring_sel);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, IROSC_1_SELf, ring_sel);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));

            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_1_SELf, ring_osc);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_0_SELf, 1);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
            soc_reg_field_set(unit, ctrl_reg, &rval, OSC_0_SELf, 3);
            SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_CONTROL_2r(unit, rval));
        
            sal_usleep(1000);
    
            rval = soc_pci_read(unit, CMIC_CMCx_IRQ_STAT3_OFFSET(cmc));
            /* SOC_IF_ERROR_RETURN(READ_CMIC_CMC0_IRQ_STAT3r(unit, &rval)); */
            fval = rval & 0xffff;
            if (0 == fval) {
                quo = 0;
                frac = 0;
            } else {
                quo = core_clk / fval;
                rem = core_clk - quo * fval;
                frac = (rem * 10000) / fval;
            }
            LOG_CLI((BSL_META_U(unit,
                                "%d: %d.%04d Mhz\n"),
                     ring_osc, quo, frac));
        }
    }
    return SOC_E_NONE;
}

int
soc_kt2_show_material_process(int unit)
{
    soc_reg_t reg;
    int index;
    uint32 rval, fval, nmos[COUNTOF(pvtmon_result_reg)], n_avg, p_avg;

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, FUNC_MODE_SELf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, MEASUREMENT_CALLIBRATIONf, 0x5);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, PROG_RESISTERf, 0x3);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_SELECTf, 0x1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    sal_usleep(1000);

    /* Read NMOS information */
    n_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        nmos[index] = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        n_avg += nmos[index];
    }

    /* Read PMOS information and print both NMOS and PMOS value */
    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_PVTMON_CTRL_0r, REG_PORT_ANY,
                                MEASUREMENT_CALLIBRATIONf, 7));

    sal_usleep(1000);

    p_avg = 0;
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        p_avg += fval;

        LOG_CLI((BSL_META_U(unit,
                            "Material process location %d: NMOS = %3d PMOS = %3d\n"),
                 index, nmos[index], fval));
    }

    LOG_CLI((BSL_META_U(unit,
                        "Average:                     NMOS = %3d PMOS = %3d\n"),
             n_avg / COUNTOF(pvtmon_result_reg),
             p_avg / COUNTOF(pvtmon_result_reg)));

    return SOC_E_NONE;
}

int
soc_kt2_show_voltage(int unit)
{
    soc_reg_t reg;
    int index;
    uint32 rval, fval, avg;

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, FUNC_MODE_SELf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, MEASUREMENT_CALLIBRATIONf, 0x5);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_0r, &rval, PROG_RESISTERf, 0x3);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_0r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_TOP_PVTMON_CTRL_1r(unit, &rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_SELECTf, 0x3);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));
    soc_reg_field_set(unit, TOP_PVTMON_CTRL_1r, &rval, PVTMON_RSTBf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_PVTMON_CTRL_1r(unit, rval));

    sal_usleep(1000);
    avg = 0;
    /* Read Voltages */
    for (index = 0; index < COUNTOF(pvtmon_result_reg); index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));
        fval = soc_reg_field_get(unit, reg, rval, TEMP_DATAf);
        /* (0.99/1024) * 8/7 * TEMP_DATA */
        fval = (fval * 8 * 990) / (1024 * 7);
        avg += fval;
        LOG_CLI((BSL_META_U(unit,
                            "Voltage @ location %d: = %d.%03dV\n"),
                 index, (fval/1000), (fval %1000)));
    }
    avg /= COUNTOF(pvtmon_result_reg);
    LOG_CLI((BSL_META_U(unit,
                        "Average:            = %d.%03dV\n"),
             (avg/1000), (avg %1000)));

    return SOC_E_NONE;
}
#ifdef BCM_WARM_BOOT_SUPPORT
static
void _soc_kt2_mem_config_set(int unit, char *config_str, char *config_value)
{
     /* Calling Wrapper function. */
     /* Can update config.bcm or suggest config variable settings on terminal */
     soc_mem_config_save(unit, config_str, config_value);
}
#endif
int _soc_katana2_get_cfg_num(int unit, int *new_cfg_num)
{
    int cfg_num=-1;
    int max_cfg_num=0;
    int def_cfg_num=0;
    int offset_cfg_num=0;
    uint16 dev_id=0;
    uint8  rev_id=0;

#ifdef BCM_WARM_BOOT_SUPPORT
    if (SOC_WARM_BOOT(unit)) {
       cfg_num = COUNTOF(bcm56450_tdm_info) - 1;
       if (kt2_scache_tdm_info[unit].tdm_size != 0) {
           *new_cfg_num = cfg_num;
           return SOC_E_NONE;       
       }
       /* FAll through */
    }
#endif

    cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG,0xFF);

    soc_cm_get_id(unit, &dev_id, &rev_id);
    switch(dev_id) {
    case BCM55450_DEVICE_ID:
    case BCM55455_DEVICE_ID:
    case BCM56248_DEVICE_ID:
         if ((SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM)) {
              def_cfg_num = 0;
         } else {
              def_cfg_num = BCM56248_DEVICE_ID_DEFAULT_CFG;
         }
         offset_cfg_num = BCM56248_DEVICE_ID_OFFSET_CFG;
         max_cfg_num = BCM56248_DEVICE_ID_MAX_CFG;
         break; 
    case BCM56450_DEVICE_ID:
    case BCM56456_DEVICE_ID:
         if ((SAL_BOOT_BCMSIM || SAL_BOOT_PLISIM)) {
              def_cfg_num = 0;
         } else {
              def_cfg_num = BCM56450_DEVICE_ID_DEFAULT_CFG;
         }
         offset_cfg_num = BCM56450_DEVICE_ID_OFFSET_CFG;
         max_cfg_num = BCM56450_DEVICE_ID_MAX_CFG;
         break; 
    case BCM56452_DEVICE_ID:
    case BCM56457_DEVICE_ID:
         def_cfg_num = BCM56452_DEVICE_ID_DEFAULT_CFG;
         offset_cfg_num = BCM56452_DEVICE_ID_OFFSET_CFG;
         max_cfg_num = BCM56452_DEVICE_ID_MAX_CFG;
         break; 
    case BCM56454_DEVICE_ID:
    case BCM56458_DEVICE_ID:
         def_cfg_num = BCM56454_DEVICE_ID_DEFAULT_CFG;
         offset_cfg_num = BCM56454_DEVICE_ID_OFFSET_CFG;
         max_cfg_num = BCM56454_DEVICE_ID_MAX_CFG;
         break; 
    case BCM56455_DEVICE_ID:
         def_cfg_num = BCM56455_DEVICE_ID_DEFAULT_CFG;
         offset_cfg_num = BCM56455_DEVICE_ID_OFFSET_CFG;
         max_cfg_num = BCM56455_DEVICE_ID_MAX_CFG;
         break; 
    }
    if (cfg_num == 0xFF) {
        *new_cfg_num = def_cfg_num;
    } else {
        if (cfg_num == 0) {
            if (offset_cfg_num != 0) {
                LOG_CLI((BSL_META_U(unit,
                                    "Config=0 is not allowed \n")));
                return BCM_E_PARAM; 
            }
        } 
        *new_cfg_num = cfg_num + offset_cfg_num;
    }
    if (*new_cfg_num > max_cfg_num) {
        LOG_CLI((BSL_META_U(unit,
                            "Cfg_num:%d Internal cfg_num:%d \n"),cfg_num,*new_cfg_num));
        LOG_CLI((BSL_META_U(unit,
                            "Wrong %s ==> cfg_num:%d DEFAULT:%d START:%d MAX:%d \n"),
                 spn_BCM5645X_CONFIG, cfg_num, 
                 def_cfg_num-offset_cfg_num,1,max_cfg_num-offset_cfg_num));
        return BCM_E_PARAM; 
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                        "Info Cfg_num:%d Internal cfg_num:%d \n"),cfg_num,*new_cfg_num)); 
    return BCM_E_NONE;
}

int _soc_kt2_config_get(int unit,
          soc_kt2_sku_config_info_t *conf)
{
   uint16 dev_id=0;
   uint8 rev_id=0;
   int   cfg_num=0;
   soc_field_t wc_xfi_mode_sel_fld[]={WC0_8_XFI_MODE_SELf,WC1_8_XFI_MODE_SELf};
   uint32      top_misc_control_1_val = 0;

   soc_cm_get_id(unit, &dev_id, &rev_id);
   if (_soc_katana2_get_cfg_num(unit, &cfg_num) != BCM_E_NONE) {
       return SOC_E_FAIL;
   }
   conf->config = cfg_num;
   conf->bcm56450_cfg_offset = BCM56450_DEVICE_ID_OFFSET_CFG;
   conf->bcm56452_cfg_offset = BCM56452_DEVICE_ID_OFFSET_CFG;
   conf->bcm56454_cfg_offset = BCM56454_DEVICE_ID_OFFSET_CFG;
   conf->bcm56455_cfg_offset = BCM56455_DEVICE_ID_OFFSET_CFG;
   conf->bcm56248_cfg_offset = BCM56248_DEVICE_ID_OFFSET_CFG;
   conf->xfi_0 = soc_reg_field_get(unit, TOP_MISC_CONTROL_1r,
                                              top_misc_control_1_val,
                                              wc_xfi_mode_sel_fld[0]);
   conf->xfi_1 = soc_reg_field_get(unit, TOP_MISC_CONTROL_1r,
                                              top_misc_control_1_val,
                                              wc_xfi_mode_sel_fld[1]);
   conf->olp_port = SOC_INFO(unit).olp_port[0];
   return SOC_E_NONE;
}

void
_soc_kt2_mem_config(int unit)
{
/* #ifdef BROADCOM_SVK  */
   /* For first 4(UC0-UC3) mxqblock , tx polarity is changed */
   /* For next  4(UC4-UC7) mxqblock , rx polarity is changed */
   uint16 dev_id=0;
   uint8 rev_id=0;
   int   cfg_num=0;

   soc_cm_get_id(unit, &dev_id, &rev_id);
   if (_soc_katana2_get_cfg_num(unit, &cfg_num) != BCM_E_NONE) {
       return ;
   }

   LOG_CLI((BSL_META_U(unit,
            "\n=================================================\n")));
   LOG_CLI((BSL_META_U(unit,
            "INFO:XAUI need all 4 lanes;R-XAUI need 2 & XFI need 1 lane\n")));
   LOG_CLI((BSL_META_U(unit,
       "Cfg:%d IntCfg:%d Recommended PortGroup Config Setting for WC ports\n"),
       soc_property_get(unit, spn_BCM5645X_CONFIG,0xFF), cfg_num));
   LOG_CLI((BSL_META_U(unit,
            "=================================================\n")));
   switch(cfg_num) {
   case BCM56248_DEVICE_ID_OFFSET_CFG + 0:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 0:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"),  unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_29.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_31.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_32.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_33.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_34.%d=1 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 1:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 2:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 1:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 2:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 3:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 3:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 4:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 4:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_33.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 5:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 5:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_33.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_25.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_36.%d=1 \n"), unit));

        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 7:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 7:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_33.%d=1 \n"), unit));

        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_26.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_39.%d=1 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 6:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 6:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_33.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_25.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_36.%d=1 \n"), unit));

        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_26.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_39.%d=1 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 8:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 8:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 9:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 9:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 10:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 10:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 11:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 11:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 12:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 12:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 13:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 13:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 14:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 14:
   case BCM56248_DEVICE_ID_OFFSET_CFG + 15:
   case BCM56450_DEVICE_ID_OFFSET_CFG + 15:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 16:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break;
   case BCM56450_DEVICE_ID_OFFSET_CFG + 16:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break;
   case BCM56248_DEVICE_ID_OFFSET_CFG + 17:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=1 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        break;
   case BCM56452_DEVICE_ID_OFFSET_CFG + 1:
   case BCM56452_DEVICE_ID_OFFSET_CFG + 2:
   case BCM56452_DEVICE_ID_OFFSET_CFG + 3:
   case BCM56452_DEVICE_ID_OFFSET_CFG + 4:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_25.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_26.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break; 
   case BCM56452_DEVICE_ID_OFFSET_CFG + 5:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_25.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break; 
   case BCM56452_DEVICE_ID_OFFSET_CFG + 6:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break;
   case BCM56452_DEVICE_ID_OFFSET_CFG + 7:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break;
   case BCM56452_DEVICE_ID_OFFSET_CFG + 8:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_25.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_26.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break; 
   case BCM56452_DEVICE_ID_OFFSET_CFG + 9:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break; 
   case BCM56452_DEVICE_ID_OFFSET_CFG + 10:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_30.%d=1 \n"), unit));
        break; 
   case BCM56454_DEVICE_ID_OFFSET_CFG + 1:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_27.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_28.%d=4 \n"), unit));
        break;
   case BCM56454_DEVICE_ID_OFFSET_CFG + 2:
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_25.%d=4 \n"), unit));
        LOG_CLI((BSL_META_U(unit,
                 "portgroup_26.%d=4 \n"), unit));
        break;
   default : break;
   }
   LOG_CLI((BSL_META_U(unit,
            "=================================================\n")));

  return;
}

/* Map logical (always starts from 0 and contiguous) index to physical index 
   which can have a starting offset and/or holes.
   Input  : logical index
   Returns: physical index */
int
soc_kt2_l3_defip_index_map(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    
    if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm) {
        wide = 1;
    }

    return soc_l3_defip_index_map(unit, wide, index);
}

/* Reverse map physical index to logical index.
   Input  : physical index
   Returns: logical index */
int
soc_kt2_l3_defip_index_remap(int unit, soc_mem_t mem, int index)
{
    int wide = 0;
    
    if (SOC_CONTROL(unit)->l3_defip_index_remap == 0) {
        return index;
    }

    if (mem == L3_DEFIP_PAIR_128m ||
        mem == L3_DEFIP_PAIR_128_ONLYm ||
        mem == L3_DEFIP_PAIR_128_DATA_ONLYm ||
        mem == L3_DEFIP_PAIR_128_HIT_ONLYm) {
        wide = 1;
    }

    return soc_l3_defip_index_remap(unit, wide, index);
}

/* Given a physical index (always in terms of the narrow entry) 
   return the logical index and memory type */
int
soc_kt2_l3_defip_mem_index_get(int unit, int pindex, soc_mem_t *mem)
{
    return soc_l3_defip_index_mem_map(unit, pindex, mem);
}

#ifdef BCM_WARM_BOOT_SUPPORT

/*
 * Function:
 *      _soc_katana2_default_tdm_recover
 * Description:
 *      This function is called during warmboot to recover the
 *      default tdm settings for the config being used if an
 *      upgrade is detected and tdm settings changed.
 * Parameters:
 *      unit - PCI device unit number (driver internal)
 *      tdm  - (OUT)tdm settings for the config id used.
 * Returns:
 *      SOC_E_NONE - Success.
 *      SOC_E_FAIL - Failure
 */

int _soc_katana2_default_tdm_recover(int unit, uint32 *tdm)
{
    uint32 port = 0;
    uint32 outer_index=0;
    uint32 inner_index=0;
    uint32 tdm_index=0;
    uint32  row=18;
    uint32  col=5;
    uint8  mxqblock=0;
    int    tdm_size, tdm_freq, cfg_num;
    uint16 dev_id;
    uint8 rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    /* Get the value of "bcm5645x_config" from the config file */
    cfg_num = soc_property_get(unit, spn_BCM5645X_CONFIG,0xFF);

    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        LOG_CLI((BSL_META_U(unit,
                 "Wrong cfg_num:%d exceeding max cfg_num: %d\n"),
                 cfg_num,
                 (int)(sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))));
        return SOC_E_FAIL;
    }

    switch(dev_id) {
        case BCM55450_DEVICE_ID:
        case BCM55455_DEVICE_ID:
        case BCM56248_DEVICE_ID:
        case BCM56450_DEVICE_ID:
        case BCM56452_DEVICE_ID:
        case BCM56454_DEVICE_ID:
        case BCM56455_DEVICE_ID:
        case BCM56456_DEVICE_ID:
        case BCM56457_DEVICE_ID:
        case BCM56458_DEVICE_ID:
             tdm_size= bcm56450_tdm_info[cfg_num].tdm_size;
             tdm_freq= bcm56450_tdm_info[cfg_num].tdm_freq;
             row= bcm56450_tdm_info[cfg_num].row;
             col= bcm56450_tdm_info[cfg_num].col;
             LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                         "Recover default TDM for "
                         "Cfg=%d freq=%d size=%d raw=%d col=%d\n"),
                          cfg_num, tdm_freq, tdm_size, row,col));

             switch(cfg_num) {
                 case BCM56248_DEVICE_ID_OFFSET_CFG + 0:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 0:
                     LOG_CLI((BSL_META_U(unit,
                             "kt2_tdm_56450speed_deprecated0\n")));
                      sal_memcpy(tdm,
                                 &kt2_tdm_56450AA_ref[0],
                                 sizeof(kt2_tdm_56450AA_ref));
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 1:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 1:/* kt2_tdm_A_56450_1 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A_56450_1 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A_ref[0],
                                   sizeof(kt2_tdm_56450A_ref));
                        kt2_tdm_replace(tdm, 88, KT2_OLP_PORT, KT2_IDLE, 0);
                        kt2_tdm_replace(tdm, tdm_size, 33, 25, 0);
                        kt2_tdm_replace(tdm, tdm_size, 30, 26, 0);
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 2:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 2:/* kt2_tdm_A_56450_2 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A_56450_2 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A_ref[0],
                                   sizeof(kt2_tdm_56450A_ref));
                        kt2_tdm_replace(tdm, 88, 33, 25, 0);
                        kt2_tdm_replace(tdm, 88, 30, 26, 0);
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 3:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 3:/* kt2_tdm_A_56450_3 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A_56450_3 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A_ref[0],
                                   sizeof(kt2_tdm_56450A_ref));
                        kt2_tdm_replace(tdm, 88, 33, 25, 0);
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 4:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 4:/* kt2_tdm_A_56450_4 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A_56450_4 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A_ref[0],
                                   sizeof(kt2_tdm_56450A_ref));
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 5:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 5:/* kt2_tdm_A_56450_5 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A_56450_5 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A_ref[0],
                                   sizeof(kt2_tdm_56450A_ref));
                        kt2_tdm_display(unit, tdm, tdm_size, row, col);
                        kt2_tdm_swap(tdm, 88, 21, 33);
                        kt2_tdm_display(unit,tdm, tdm_size, row, col);
                        kt2_tdm_swap(tdm, 88, 30, 13);
                        kt2_tdm_display(unit, tdm, tdm_size, row, col);
                        kt2_tdm_replace(tdm, 88, 13, 25, 0);
                        kt2_tdm_display(unit, tdm, tdm_size, row, col);
                        kt2_tdm_replace(tdm, 88, 21, 36, 0);
                        kt2_tdm_display(unit, tdm, tdm_size, row, col);
                        kt2_tdm_replace(tdm, 88, 17, 13, 0);
                        kt2_tdm_display(unit, tdm, tdm_size, row, col);
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 6:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 6:/* kt2_tdm_A_56450_6 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A_56450_6 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A_ref[0],
                                   sizeof(kt2_tdm_56450A_ref));
                        kt2_tdm_swap(tdm, 88, 1, 17);
                        kt2_tdm_swap(tdm, 88, 13, 21);
                        kt2_tdm_replace(tdm, 88, 17, 39, 0);
                        kt2_tdm_replace(tdm, 88, 21, 26, 0);
                        kt2_tdm_replace(tdm, 88, 9, 25, 0);
                        kt2_tdm_replace(tdm, 88, 13, 36, 0);
                        kt2_tdm_replace(tdm, 88, 40, KT2_IDLE, 0);
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 7:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 7:/* kt2_tdm_A_56450_7 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A_56450_7 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A_ref[0],
                                   sizeof(kt2_tdm_56450A_ref));
                        kt2_tdm_swap(tdm, 88, 9, 17);
                        kt2_tdm_replace(tdm, 88, 17, 26, 0);
                        kt2_tdm_replace(tdm, 88, 21, 39, 0);
                        kt2_tdm_replace(tdm, 88, 13, 25, 0);

                        kt2_tdm_replace(tdm, 88, 13, KT2_IDLE, 0);
                        kt2_tdm_replace(tdm, 88, 1, KT2_IDLE, 0);
                        kt2_tdm_replace(tdm, 88, 5, KT2_IDLE, 0);
                        kt2_tdm_replace(tdm, 88, 9, KT2_IDLE, 0);
                        kt2_tdm_replace(tdm, 88, 40, KT2_IDLE, 0);
                        tdm_index = 0;
                        for (outer_index = 1; outer_index <= 4; outer_index++) {
                             for (inner_index= 0; inner_index < 6;
                                  inner_index++) {
                                      port = outer_index + inner_index*4;
                                      while(tdm[tdm_index] != KT2_IDLE) {
                                            tdm_index++;
                                      }
                                  tdm[tdm_index]=port;
                             }
                        }
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 8:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 8:/* kt2_tdm_A1_56450_8 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A1_56450_8 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A1_ref[0],
                                   sizeof(kt2_tdm_56450A1_ref));
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 9:
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 9:/* kt2_tdm_A1_56450_9 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A1A_56450_9 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56450A1A_ref[0],
                                   sizeof(kt2_tdm_56450A1A_ref));
                        break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 10:
                 /* kt2_tdm_A2_56450_10 */
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 10:
                          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                              "kt2_tdm_A2_56450_10 \n")));
                          sal_memcpy(tdm,
                                     &kt2_tdm_56450A2_ref[0],
                                     sizeof(kt2_tdm_56450A2_ref));
                          kt2_tdm_replace(tdm, tdm_size, KT2_OLP_PORT,
                                          KT2_IDLE, 0);
                          break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 11:
                 /* kt2_tdm_A2_56450_11 */
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 11:
                          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                              "kt2_tdm_A2_56450_11 \n")));
                          sal_memcpy(tdm,
                                    &kt2_tdm_56450A2_ref[0],
                                    sizeof(kt2_tdm_56450A2_ref));
                          break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 12:
                 /* kt2_tdm_A3_56450_12 */
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 12:
                          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                              "kt2_tdm_A3_56450_12 \n")));
                          sal_memcpy(tdm,
                                     &kt2_tdm_56450A3_ref[0],
                                     sizeof(kt2_tdm_56450A3_ref));
                          break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 13:
                 /* kt2_tdm_A2_56450_13 */
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 13:
                          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                              "kt2_tdm_A2_56450_13 \n")));
                          sal_memcpy(tdm,
                                     &kt2_tdm_56450A2_ref[0],
                                     sizeof(kt2_tdm_56450A2_ref));
                          kt2_tdm_replace(tdm, tdm_size, 26, 28, 0);
                          kt2_tdm_replace(tdm, tdm_size, 25, 27, 0);
                          break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 14:
                 /* kt2_tdm_A2_56450_14 */
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 14:
                          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                              "kt2_tdm_A1_56450_14 \n")));
                          sal_memcpy(tdm,
                                     &kt2_tdm_56450A1_ref[0],
                                     sizeof(kt2_tdm_56450A1_ref));
                          break;

                 case BCM56248_DEVICE_ID_OFFSET_CFG + 15:
                 /* kt2_tdm_A4_56450_15 */
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 15:
                          LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                              "kt2_tdm_A4_56450_15 \n")));
                          memcpy(tdm,
                                 &kt2_tdm_56450A4_ref[0],
                                 sizeof(kt2_tdm_56450A4_ref));
                          break;
                 /* kt2_tdm_F_56450_16 */
                 case BCM56450_DEVICE_ID_OFFSET_CFG + 16:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_F_56450_16 \n")));
                        sal_memcpy(tdm,
                                  &kt2_tdm_56450F_ref[0],
                                  sizeof(kt2_tdm_56450F_ref));
                        break;

                 case BCM56452_DEVICE_ID_OFFSET_CFG + 1:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_C_56452_1 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56455C_ref[0],
                                   sizeof(kt2_tdm_56455C_ref));
                        break;

                 case BCM56452_DEVICE_ID_OFFSET_CFG + 2:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_C1_56452_2 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56452C1_ref[0],
                                   sizeof(kt2_tdm_56452C1_ref));
                        break;

                 case BCM56452_DEVICE_ID_OFFSET_CFG + 3:
                 case BCM56452_DEVICE_ID_OFFSET_CFG + 4:
                        sal_memcpy(tdm,
                                   &kt2_tdm_56452C1_ref[0],
                                   sizeof(kt2_tdm_56452C1_ref));
                        for(port = 2; port <= 8; port++) {
                            kt2_tdm_replace(tdm, 64, port, 1, 0);
                        }
                        for(port = 9; port <=16 ; port++) {
                            kt2_tdm_replace(tdm, 64, port, 5, 0);
                        }
                        for(port = 17; port <= 24; port++) {
                            kt2_tdm_replace(tdm, 64, port, KT2_IDLE, 0);
                        }
                        if (cfg_num == BCM56452_DEVICE_ID_OFFSET_CFG + 3) {
                            LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                                "kt2_tdm_C1_56452_3 \n")));
                            kt2_tdm_replace(tdm, 64, KT2_OLP_PORT, KT2_IDLE, 0);
                        } else {
                            LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                                "kt2_tdm_C1_56452_4 \n")));
                        }
                        break;
                 case BCM56452_DEVICE_ID_OFFSET_CFG + 5:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_B_56452_5 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56452B_new_ref[0],
                                   sizeof(kt2_tdm_56452B_new_ref));
                        for(port=1;port<=8;port++) {
                            kt2_tdm_replace(tdm,90,port,KT2_IDLE,0);
                        }
                        tdm_index=0;
                        for (outer_index=1;outer_index<=4;outer_index++) {
                             for (inner_index=0;inner_index < 6;inner_index++) {
                                  port = outer_index + inner_index*4;/* 1,5,9,13,17,21
                                                                        2,6,10,14,18,22,
                                                                        3,7,11,15,19,23,
                                                                        4,8,12,16,20,24
                                                                      */
                                 while(tdm[tdm_index] != KT2_IDLE) {
                                       tdm_index++;
                                 }
                                 tdm[tdm_index]=port;
                             }
                        }
                        kt2_tdm_replace(tdm,90,26,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,38,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,39,KT2_IDLE,0);
                        break;

                 case BCM56452_DEVICE_ID_OFFSET_CFG + 6:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_B1_56452_6 \n")));
                        sal_memcpy(tdm,
                                  &kt2_tdm_56452B1_ref[0],
                                  sizeof(kt2_tdm_56452B1_ref));
                        kt2_tdm_replace(tdm,60,1,60,0);
                        kt2_tdm_replace(tdm,60,5,60,0);
                        kt2_tdm_replace(tdm,60,25,60,0);
                        for (inner_index=1;inner_index <= 4;inner_index++) {
                             for (outer_index=0;outer_index< 6;outer_index++) {
                                  port = inner_index + outer_index*4;
                                  kt2_tdm_replace(tdm,60,60,port,1);
                             }
                        }
                        kt2_tdm_replace(tdm,60,60,KT2_IDLE,0);
                        break;

                 case BCM56452_DEVICE_ID_OFFSET_CFG + 7:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_B_56452_7 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56452B_new_ref[0],
                                   sizeof(kt2_tdm_56452B_new_ref));
                        for(port=1;port<=8;port++) {
                            kt2_tdm_replace(tdm,90,port,KT2_IDLE,0);
                        }
                        tdm_index=0;
                        for (outer_index=1;outer_index<=4;outer_index++) {
                             for (inner_index=0;inner_index < 6;inner_index++) {
                                  port = outer_index + inner_index*4;/* 1,5,9,13,17,21
                                                                        2,6,10,14,18,22,
                                                                        3,7,11,15,19,23,
                                                                        4,8,12,16,20,24
                                                                      */
                                 while(tdm[tdm_index] != KT2_IDLE) {
                                       tdm_index++;
                                 }
                                 tdm[tdm_index]=port;
                             }
                        }

                        kt2_tdm_replace(tdm,90,25,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,35,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,36,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,37,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,26,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,38,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,39,KT2_IDLE,0);
                        kt2_tdm_replace(tdm,90,40,KT2_IDLE,0);
                        break;

                 case BCM56452_DEVICE_ID_OFFSET_CFG + 8:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_B_56452_8 \n")));
                        sal_memcpy(tdm,
                                  &kt2_tdm_56452B_new_ref[0],
                                  sizeof(kt2_tdm_56452B_new_ref));
                        mxqblock = 6;
                        outer_index= 0;
                        for (inner_index=0; inner_index < 90; inner_index++) {
                             if (tdm[inner_index] == 25) {
                                 tdm[inner_index] = (*kt2_mxqblock_ports[unit])
                                                      [mxqblock][outer_index];
                                 outer_index = (outer_index + 1) % 4;
                             }
                        }
                        break;
                 case BCM56452_DEVICE_ID_OFFSET_CFG + 9:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_B1_56452_9 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56452B1_ref[0],
                                   sizeof(kt2_tdm_56452B1_ref));
                        break;

                 case BCM56452_DEVICE_ID_OFFSET_CFG + 10:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_B2_56452_10 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56452B2_ref[0],
                                   sizeof(kt2_tdm_56452B2_ref));
                        break;

                 case BCM56454_DEVICE_ID_OFFSET_CFG + 1: /* kt2_tdm_D_56454_1 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_D1_56454_1 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56454D1_ref[0],
                                   sizeof(kt2_tdm_56454D1_ref));
                        break;

                 case BCM56454_DEVICE_ID_OFFSET_CFG + 2: /* kt2_tdm_D_56454_2 */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_D2_56454_2 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56454D1_ref[0],
                                   sizeof(kt2_tdm_56454D1_ref));
                        kt2_tdm_replace(tdm,40,27,25,0);
                        kt2_tdm_replace(tdm,40,28,26,0);
                        kt2_tdm_replace(tdm,40,KT2_OLP_PORT,KT2_IDLE,0);
                        break;
                 case BCM56455_DEVICE_ID_OFFSET_CFG + 1:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_C_56455_1 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56455C_ref[0],
                                   sizeof(kt2_tdm_56455C_ref));
                        break;
                 case BCM56455_DEVICE_ID_OFFSET_CFG + 2:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_C_56455_2 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56455C_ref[0],
                                   sizeof(kt2_tdm_56455C_ref));
                        kt2_tdm_swap(tdm, 84, 26, 28);
                        kt2_tdm_replace(tdm, 84, 27, KT2_IDLE, 0);
                        kt2_tdm_replace(tdm, 84, 28, KT2_IDLE, 0);
                        for (port = 1; port <= 8; port++) {
                             kt2_tdm_replace(tdm, 84, port, KT2_IDLE, 0);
                             kt2_tdm_replace(tdm, 84, port + 16, KT2_IDLE, 0);
                        }
                        break;
                 case BCM56248_DEVICE_ID_OFFSET_CFG + 16:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_A3_56450_16 \n")));
                        sal_memcpy(tdm,
                                  &kt2_tdm_56450A3_ref[0], sizeof(kt2_tdm_56450A3_ref));
                        break;
                 case BCM56248_DEVICE_ID_OFFSET_CFG + 17:
                        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
                                            "kt2_tdm_D2_56248_17 \n")));
                        sal_memcpy(tdm,
                                   &kt2_tdm_56248D2_ref[0],
                                   sizeof(kt2_tdm_56248D2_ref));
                        kt2_tdm_replace(tdm,40,9,KT2_IDLE,1);
                        kt2_tdm_replace(tdm,40,28,KT2_IDLE,1);
                        kt2_tdm_replace(tdm,40,29,KT2_IDLE,1);
                        kt2_tdm_replace(tdm,40,29,30,1);
                        break;

                 default:
                        LOG_CLI((BSL_META_U(unit,
                                "Not Supported Cfg Value%d \n"),cfg_num));
                        return SOC_E_FAIL;
                 }
             break;

        default:
            return SOC_E_FAIL;
    }
    return SOC_E_NONE;
}

int _soc_katana2_flexio_scache_allocate(int unit)
{
    int rv=SOC_E_NONE;
    uint8 *flexio_scache_ptr;
    soc_scache_handle_t scache_handle;
    uint32 alloc_get=0;
    uint32 alloc_size =  sizeof(scache_begin_magic_number) +
                         sizeof(kt2_scache_tdm_info[unit]) +
                         sizeof(kt2_scache_tdm[unit]) +
                         sizeof(kt2_scache_speed[unit]) +
                         sizeof(kt2_scache_port_details[unit]) +
                         sizeof(kt2_scache_portgroup[unit]) +
                         sizeof(scache_end_magic_number);

    SOC_SCACHE_HANDLE_SET(scache_handle, unit, SOC_SCACHE_FLEXIO_HANDLE, 0);
    rv = soc_scache_alloc(unit, scache_handle,
                          alloc_size + SOC_WB_SCACHE_CONTROL_SIZE);
    if (rv  == SOC_E_CONFIG) {
        /* Probably Level1 */
        return SOC_E_NONE;
    }
    /* NotRequired but just to confirm Get the pointer for the Level 2 cache */
    SOC_IF_ERROR_RETURN(soc_scache_ptr_get(unit, scache_handle,
                        &flexio_scache_ptr, &alloc_get));
    if (alloc_get != (alloc_size + SOC_WB_SCACHE_CONTROL_SIZE)) {
        /* Expected size doesn't match retrieved size */
        return SOC_E_INTERNAL;
    }
    if (NULL == flexio_scache_ptr) {
        return SOC_E_MEMORY;
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s()[LINE:%d] DONE \n"),FUNCTION_NAME(),  __LINE__));
    return SOC_E_NONE;
}

int _soc_katana2_flexio_scache_retrieve(int unit)
{
    int rv = SOC_E_NONE;
    uint8 *flexio_scache_ptr = NULL;
    soc_scache_handle_t scache_handle;
    uint32 alloc_get=0;
    uint32 alloc_size =  sizeof(scache_begin_magic_number) + 
                         sizeof(kt2_scache_tdm_info[unit]) +
                         sizeof(kt2_scache_tdm[unit]) +
                         sizeof(kt2_scache_speed[unit]) +
                         sizeof(kt2_scache_port_details[unit]) +
                         sizeof(kt2_scache_portgroup[unit]) +
                         sizeof(scache_end_magic_number);
    uint32 realloc_size = 0;
    uint32 offset=0;
    uint32 scache_offset=0;
    uint16 recovered_ver = 0;
    uint16 default_ver = BCM_WB_DEFAULT_VERSION;
    uint32 is_upgrade = 0;
    uint32 recover_default_tdm = 0;
    uint32 scache_tdm_size = 0;
    char config_str[80];
    char config_value[10];
    int cfg_num = 0;

    SOC_SCACHE_HANDLE_SET(scache_handle, unit, SOC_SCACHE_FLEXIO_HANDLE, 0);
    /* NotRequired but just to confirm Get the pointer for the Level 2 cache */
    rv = soc_scache_ptr_get(unit, scache_handle,
                            &flexio_scache_ptr, &alloc_get);

    if (SOC_FAILURE(rv)) {
        if (rv == SOC_E_NOT_FOUND) {
            /* Probably Level1 */
            LOG_ERROR(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                     "No scache data available(Level1 WarmBoot) - %s\n"),
                     soc_errmsg(rv)));
            return SOC_E_NONE;
        } else {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                     "Failed to recover scache data - %s\n"),soc_errmsg(rv)));
            return rv;
        }
    }

    if (NULL == flexio_scache_ptr) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                   "No scache data recovered!!\n")));
        return SOC_E_MEMORY;
    }


    /*
     * Check the magic number present at the start of the
     * scache data.
     */

    scache_offset = 0;
    if (sal_memcmp(&flexio_scache_ptr[scache_offset],
                   &scache_begin_magic_number[0],
                   sizeof(scache_begin_magic_number)) != 0) {

        LOG_ERROR(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                 "Corrupt scache for flexio operation - "
                 "Magic number missing at start\n")));
        return SOC_E_INTERNAL;
    }

    scache_offset += sizeof(scache_begin_magic_number);


    /*
     * If allocated scache size and recovered scache size
     * are not equal, more data was added to scache data.
     * Set upgrade to true.
     */
    if (alloc_get != (alloc_size + SOC_WB_SCACHE_CONTROL_SIZE)) {
        is_upgrade = 1;
        if (default_ver == BCM_WB_VERSION_1_2) {
            /* Expected size doesn't match retrieved size */
            LOG_INFO(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                    "Upgrade detected - "
                    "Scache for flexio size mismatch. "
                    "Expected size[%d], recovered size[%d]\n"),
                    (int) (alloc_size + SOC_WB_SCACHE_CONTROL_SIZE),
                     alloc_get));
            recovered_ver = BCM_WB_VERSION_1_1;
        }

        /*
         * reallocate scache space for upgrades and downgrades
         */
        realloc_size = ((alloc_size > (alloc_get - SOC_WB_SCACHE_CONTROL_SIZE))?
                           (alloc_size - alloc_get): (alloc_get - alloc_size)) +
                            SOC_WB_SCACHE_CONTROL_SIZE;
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                    "scache reallocate failed for size(%d) - %s\n"),
                    realloc_size, soc_errmsg(rv)));
    } else {
        recovered_ver = BCM_WB_DEFAULT_VERSION;
    }

    if (recovered_ver > default_ver) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                "Downgrade detected - "
                 "Current version %d.%d  found %d.%d\n"),
                 SOC_SCACHE_VERSION_MAJOR(default_ver),
                 SOC_SCACHE_VERSION_MINOR(default_ver),
                 SOC_SCACHE_VERSION_MAJOR(recovered_ver),
                 SOC_SCACHE_VERSION_MINOR(recovered_ver)));
    } else if (recovered_ver < default_ver) {
        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                 "Upgrade detected  - "
                 "Current version %d.%d  found %d.%d\n"),
                 SOC_SCACHE_VERSION_MAJOR(default_ver),
                 SOC_SCACHE_VERSION_MINOR(default_ver),
                 SOC_SCACHE_VERSION_MAJOR(recovered_ver),
                 SOC_SCACHE_VERSION_MINOR(recovered_ver)));
    }

    /*
     * If upgrade detected get the config num
     */
    if (is_upgrade) {
        SOC_IF_ERROR_RETURN(_soc_katana2_get_cfg_num(unit, &cfg_num));
        LOG_INFO(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                 "config: %d\n"), cfg_num));
    }

    /* recover the tdm info from the scache data */
    sal_memcpy(&kt2_scache_tdm_info[unit],
               &flexio_scache_ptr[scache_offset],
               sizeof(kt2_scache_tdm_info[unit]));

    /*
     * if upgrade check TDM size of the current config
     * and the recovered config. If not equal, new TDM
     * settings were added for the config. Overwrite
     * the scache_tdm_info with the default tdm_info
     * of the current config.
     */
    if (is_upgrade) {
        if ((bcm56450_tdm_info[cfg_num].tdm_size !=
            kt2_scache_tdm_info[unit].tdm_size) ||
            (bcm56450_tdm_info[cfg_num].row != kt2_scache_tdm_info[unit].row) ||
            (bcm56450_tdm_info[cfg_num].col != kt2_scache_tdm_info[unit].col)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                       (BSL_META_U(unit,
                       "Upgrade detected - Overwrite TDM info\n")));

            sal_memcpy(&kt2_scache_tdm_info[unit],
                       &bcm56450_tdm_info[cfg_num],
                       sizeof(bcm56450_tdm_info_t));
            recover_default_tdm = 1;
        } else if ((cfg_num == BCM56450_DEVICE_ID_OFFSET_CFG + 10) || 
                   (cfg_num == BCM56450_DEVICE_ID_OFFSET_CFG + 11) || 
                   (cfg_num == BCM56450_DEVICE_ID_OFFSET_CFG + 13)) {
            recover_default_tdm = 1;
        }
    }

    scache_offset += sizeof(kt2_scache_tdm_info[unit]);

    /*
     * Upgrade with new TDM settings detected, recover the default
     * tdm settings of the current config.
     */
    if (recover_default_tdm) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                   (BSL_META_U(unit,
                   "Recovering default TDM for config %d\n"), cfg_num));
        _soc_katana2_default_tdm_recover(unit, (uint32 *) kt2_scache_tdm[unit]);
        kt2_tdm_display(unit, (uint32 *) (&kt2_scache_tdm[unit][0]),
                        kt2_scache_tdm_info[unit].tdm_size,
                        kt2_scache_tdm_info[unit].row,
                        kt2_scache_tdm_info[unit].col);

        if (recovered_ver <= BCM_WB_VERSION_1_1) {
            LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,
                    "cfg: %d ver:%d %d\n"), cfg_num,
                     recovered_ver, (int)sizeof(bcm56450_tdm[cfg_num])));
        }
    } else {
        sal_memcpy(&kt2_scache_tdm[unit],
               &flexio_scache_ptr[scache_offset], sizeof(kt2_scache_tdm[unit]));
    }

    /* move the scache offset based on the recovered_ver */
    if (recovered_ver <= BCM_WB_VERSION_1_1) {
        scache_tdm_size = KT2_MAX_TDM_SLOTS_VER_1_1;
    } else if (recovered_ver == BCM_WB_DEFAULT_VERSION) {
        scache_tdm_size = KT2_MAX_TDM_SLOTS;
    }

    scache_offset += (sizeof(kt2_scache_tdm[unit][0]) * scache_tdm_size);

    sal_memcpy(&kt2_scache_speed[unit], &flexio_scache_ptr[scache_offset],
               sizeof(kt2_scache_speed[unit]));

    scache_offset += sizeof(kt2_scache_speed[unit]);
    sal_memcpy(&kt2_scache_port_details[unit],
               &flexio_scache_ptr[scache_offset], 
               sizeof(kt2_scache_port_details[unit]));

    scache_offset += sizeof(kt2_scache_port_details[unit]);
    for (offset=0; offset < sizeof(kt2_scache_portgroup[unit]);offset++) {
         kt2_scache_portgroup[unit][offset] = flexio_scache_ptr[scache_offset];
         sal_sprintf(config_value,"%d",kt2_scache_portgroup[unit][offset]);
         sal_sprintf(config_str,"portgroup_%d",offset + 27);
         if (kt2_scache_portgroup[unit][offset]) {
             _soc_kt2_mem_config_set(unit,config_str,config_value);
         }
         scache_offset += 1;
    }
    if (sal_memcmp(&flexio_scache_ptr[scache_offset],
                   &scache_end_magic_number[0], 
                   sizeof(scache_end_magic_number)) != 0) {
        LOG_CLI((BSL_META_U(unit,
                "Corrupt scache for flexio operation - "
                "Magic number check at the end of scache data failed\n")));
        return SOC_E_INTERNAL;
    }
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                 "%s()[LINE:%d] \n"),FUNCTION_NAME(),  __LINE__));

    if (realloc_size > 0) {
        rv = soc_scache_realloc(unit, scache_handle, realloc_size);
        if (SOC_FAILURE(rv)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                      "scache reallocate failed for size(%d) - %s\n"),
                       realloc_size, soc_errmsg(rv)));
            return rv;
        }
    }
    return SOC_E_NONE;
}

int _soc_katana2_flexio_scache_sync(int unit)
{
    int rv;
    uint8 *flexio_scache_ptr;
    uint8  mxqblock = 0;
    soc_scache_handle_t scache_handle;
    uint32 alloc_get=0;
    uint32 alloc_size =  sizeof(scache_begin_magic_number) +
                         sizeof(kt2_scache_tdm_info[unit]) +
                         sizeof(kt2_scache_tdm[unit]) +
                         sizeof(kt2_scache_speed[unit]) +
                         sizeof(kt2_scache_port_details[unit]) +
                         sizeof(kt2_scache_portgroup[unit]) +
                         sizeof(scache_end_magic_number); 
    uint32 scache_offset=0;
    uint32 offset=0;
    int    cfg_num=0;
    char config_str[80];
    uint32 port=0;

    /* uint32 num_cfg; */
    /* uint32 num_cfg; */
    SOC_SCACHE_HANDLE_SET(scache_handle, unit, SOC_SCACHE_FLEXIO_HANDLE, 0);
    /* NotRequired but just to confirm Get the pointer for the Level 2 cache */
    rv = soc_scache_ptr_get(unit, scache_handle,
                            &flexio_scache_ptr, &alloc_get);
    if (rv == SOC_E_NOT_FOUND) {
        /* Probably Level1 */
        return SOC_E_NONE;
    }
    if (alloc_get != (alloc_size + SOC_WB_SCACHE_CONTROL_SIZE)) {
        /* Expected size doesn't match retrieved size */
        return SOC_E_INTERNAL;
    }
    if (NULL == flexio_scache_ptr) {
        return SOC_E_MEMORY;
    }
    SOC_IF_ERROR_RETURN(_soc_katana2_get_cfg_num(unit, &cfg_num));
    if (cfg_num >= (sizeof(bcm56450_tdm)/sizeof(bcm56450_tdm[0]))) {
        return SOC_E_FAIL;
    }

    scache_offset = 0;
    sal_memcpy(&flexio_scache_ptr[scache_offset], 
               &scache_begin_magic_number[0],
               sizeof(scache_begin_magic_number));

    scache_offset += sizeof(scache_begin_magic_number);
    sal_memcpy(&flexio_scache_ptr[scache_offset], 
               &bcm56450_tdm_info[cfg_num],
               sizeof(kt2_scache_tdm_info[unit]));

    scache_offset += sizeof(kt2_scache_tdm_info[unit]);
    sal_memcpy(&flexio_scache_ptr[scache_offset],
               &kt2_current_tdm[0], 
               sizeof(uint32)* bcm56450_tdm_info[cfg_num].tdm_size);

    scache_offset += sizeof(kt2_scache_tdm[unit]);


    for (port=1 ; port <= KT2_MAX_PHYSICAL_PORTS ; port++) {
         mxqblock = (*kt2_port_to_mxqblock[unit])[port-1];
         kt2_scache_speed[unit][port-1] = 0;
         if (IS_GE_PORT(unit,port)) {
             if ((bcm56450_speed[unit][cfg_num][port-1] == 0) || /*Converted */
                 (bcm56450_speed[unit][cfg_num][port-1] >= 2500)) {
                  kt2_scache_speed[unit][port - 1] = 2500;
             } else {
                 kt2_scache_speed[unit][port - 1] = 1000;
             }
         } 
         if ((port == KT2_OLP_PORT) && (SOC_INFO(unit).olp_port[0])) {
             kt2_scache_speed[unit][port - 1] = 2500;
         } 
         if (IS_XE_PORT(unit,port)) {
             kt2_scache_speed[unit][port - 1] = 10000;
         } 
         if (IS_HG_PORT(unit,port)) {
             if (bcm56450_speed[unit][cfg_num][port-1] > 13000) {
                 kt2_scache_speed[unit][port - 1] = 21000;
             } else if (bcm56450_speed[unit][cfg_num][port-1] == 10000) {
                        /* Assuming the HG port has been created
                         *  via encapsulation 
                         */ 
                        kt2_scache_speed[unit][port - 1] = 10000;
            } else {
                 kt2_scache_speed[unit][port - 1] = 13000;
             }
         } 
         if (IS_HG2_ENABLED_PORT(unit,port) &&
                 ((mxqblock == 8) || (mxqblock == 9))) {
             /* 21G supported only in WC0/WC1 */
             if (bcm56450_speed[unit][cfg_num][port-1] > 13000) {
                     kt2_scache_speed[unit][port - 1] = 21000;
             } else if (bcm56450_speed[unit][cfg_num][port-1] == 10000) {
                 /* Assuming the HG port has been created
                  *  via encapsulation
                  */
                 kt2_scache_speed[unit][port - 1] = 10000;
             } else {
                 kt2_scache_speed[unit][port - 1] = 13000;
             }
         } 
         if (IS_HL_PORT(unit,port)) {
             kt2_scache_speed[unit][port - 1] = 2500;
         }
    }
    sal_memcpy(&flexio_scache_ptr[scache_offset], 
               &kt2_scache_speed[unit][0], sizeof(kt2_scache_speed[unit]));

    scache_offset += sizeof(kt2_scache_speed[unit]);
    for (port=1 ; port <= KT2_MAX_PHYSICAL_PORTS ; port++) {
         /* mxqblock = (*kt2_port_to_mxqblock[unit])[port-1]; */
         kt2_scache_port_details[unit][port-1].start_port_no = port;
         kt2_scache_port_details[unit][port-1].end_port_no = port;
         kt2_scache_port_details[unit][port-1].port_incr = 1;
         kt2_scache_port_details[unit][port-1].port_type = 0;
         kt2_scache_port_details[unit][port-1].port_speed = 0xFFFF;
         if (IS_GE_PORT(unit,port)) {
             if ((bcm56450_speed[unit][cfg_num][port-1] == 0) || /*Converted */
                 (bcm56450_speed[unit][cfg_num][port-1] >= 2500)) {
                  kt2_scache_port_details[unit][port-1].port_speed = 2500;
             } else {
                  kt2_scache_port_details[unit][port-1].port_speed = 1000;
             }
             kt2_scache_port_details[unit][port-1].port_type = GE_PORT;
         } 
         if ((port == KT2_OLP_PORT) && (SOC_INFO(unit).olp_port[0])) {
             kt2_scache_port_details[unit][port-1].port_speed = 2500;
             kt2_scache_port_details[unit][port-1].port_type |= OLP_PORT;
         } 
         if (IS_XE_PORT(unit,port)) {
             kt2_scache_port_details[unit][port-1].port_speed = 10000;
             kt2_scache_port_details[unit][port - 1].port_type |= XE_PORT;
         } 
         if (IS_HG_PORT(unit,port)) {
             if (bcm56450_speed[unit][cfg_num][port-1] > 13000) {
                 kt2_scache_port_details[unit][port-1].port_speed = 21000;
             } else {
                 kt2_scache_port_details[unit][port-1].port_speed = 13000;
             }
             kt2_scache_port_details[unit][port - 1].port_type |= HG_PORT;
             kt2_scache_port_details[unit][port - 1].port_type |= STK_PORT;
         } 
         if (IS_HG2_ENABLED_PORT(unit,port)) {
             kt2_scache_port_details[unit][port-1].port_speed = 21000;
             kt2_scache_port_details[unit][port - 1].port_type |= HG_PORT;
             kt2_scache_port_details[unit][port - 1].port_type |= STK_PORT;
         }
         if (IS_HL_PORT(unit,port)) {
             kt2_scache_port_details[unit][port-1].port_speed = 2500;
             kt2_scache_port_details[unit][port-1].port_type |= HGL_PORT;
             kt2_scache_port_details[unit][port-1].port_type |= STK_PORT;
         }
    }
    sal_memcpy(&flexio_scache_ptr[scache_offset],
               &kt2_scache_port_details[unit],
               sizeof(kt2_scache_port_details[unit]));

    scache_offset += sizeof(kt2_scache_port_details[unit]);
    for (offset=0; offset < sizeof(kt2_scache_portgroup[unit]);offset++) {
         sal_sprintf(config_str,"portgroup_%d",offset + 27);
         flexio_scache_ptr[scache_offset] = soc_property_get(unit, 
                                                             config_str,0);
         scache_offset += 1;
    }


    /* num_cfg = COUNTOF(bcm56450_tdm_info); */
    sal_memcpy(&flexio_scache_ptr[scache_offset], 
               &scache_end_magic_number[0],
               sizeof(scache_end_magic_number));
    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit,
                            "%s()[LINE:%d] \n"),FUNCTION_NAME(),  __LINE__));
    return SOC_E_NONE;
}
#endif

int
soc_kt2_lls_bmap_alloc(int unit)
{
    soc_control_t *soc;
    int rv = SOC_E_NONE;
    int port;
    int alloc_size_l0;
    int alloc_size_l1;
    int alloc_size_l2;
    soc_info_t *si;

    si = &SOC_INFO(unit);
    soc = SOC_CONTROL(unit);

    /* First cleanup if any allocation was done earlier.
     * This is needed to make sure that on subsequent rc
     * there is no memory leak due to MMU LLS usage bitmap
     * allocation.
     */
    for (port = 0; port < ((si->lb_port)+1); port++) {
        if (soc->port_lls_s0_bmap[port] != NULL) {
            sal_free(soc->port_lls_s0_bmap[port]);
        }
        if (soc->port_lls_s1_bmap[port] != NULL) {
            sal_free(soc->port_lls_s1_bmap[port]);
        }
        if (soc->port_lls_l0_bmap[port] != NULL) {
            sal_free(soc->port_lls_l0_bmap[port]);
        }
        if (soc->port_lls_l1_bmap[port] != NULL) {
            sal_free(soc->port_lls_l1_bmap[port]);
        }
        if (soc->port_lls_l2_bmap[port] != NULL) {
            sal_free(soc->port_lls_l2_bmap[port]);
        }
    }

    alloc_size_l0 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, LLS_L0_PARENTm));
    alloc_size_l1 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, LLS_L1_PARENTm));
    alloc_size_l2 =
        SHR_BITALLOCSIZE(soc_mem_index_count(unit, LLS_L2_PARENTm));

    for (port = 0; port < ((si->lb_port)+1); port++) {
        soc->port_lls_s0_bmap[port] = sal_alloc(alloc_size_l0, "LLS_S0_BMAP");
        if (soc->port_lls_s0_bmap[port] == NULL) {
            rv = SOC_E_MEMORY;
            goto clean_up;
        }
        soc->port_lls_s1_bmap[port] = sal_alloc(alloc_size_l0, "LLS_S1_BMAP");
        if (soc->port_lls_s1_bmap[port] == NULL) {
            rv = SOC_E_MEMORY;
            goto clean_up;
        }
        soc->port_lls_l0_bmap[port] = sal_alloc(alloc_size_l0, "LLS_L0_BMAP");
        if (soc->port_lls_l0_bmap[port] == NULL) {
            rv = SOC_E_MEMORY;
            goto clean_up;
        }
        soc->port_lls_l1_bmap[port] = sal_alloc(alloc_size_l1, "LLS_L1_BMAP");
        if (soc->port_lls_l1_bmap[port] == NULL) {
            rv = SOC_E_MEMORY;
            goto clean_up;
        }
        soc->port_lls_l2_bmap[port] = sal_alloc(alloc_size_l2, "LLS_L2_BMAP");
        if (soc->port_lls_l2_bmap[port] == NULL) {
            rv = SOC_E_MEMORY;
            goto clean_up;
        }
        sal_memset(soc->port_lls_s0_bmap[port], 0, alloc_size_l0);
        sal_memset(soc->port_lls_s1_bmap[port], 0, alloc_size_l0);
        sal_memset(soc->port_lls_l0_bmap[port], 0, alloc_size_l0);
        sal_memset(soc->port_lls_l1_bmap[port], 0, alloc_size_l1);
        sal_memset(soc->port_lls_l2_bmap[port], 0, alloc_size_l2);

    }

    clean_up:
    if (SOC_FAILURE(rv))  {
        for (port = 0; port < ((si->lb_port)+1) ; port++) {
            if (soc->port_lls_s0_bmap[port] != NULL) {
               sal_free(soc->port_lls_s0_bmap[port]);
            }
            if (soc->port_lls_s1_bmap[port] != NULL) {
               sal_free(soc->port_lls_s1_bmap[port]);
            }
            if (soc->port_lls_l0_bmap[port] != NULL) {
               sal_free(soc->port_lls_l0_bmap[port]);
            }
            if (soc->port_lls_l1_bmap[port] != NULL) {
                sal_free(soc->port_lls_l1_bmap[port]);
            }
            if (soc->port_lls_l2_bmap[port] != NULL) {
               sal_free(soc->port_lls_l2_bmap[port]);
            }
        }
    }
    return rv;
}

 int
_soc_kt2_cosq_min_bucket_get(int unit, int port, int index, int level,
                        uint32 *min_quantum, uint32 *mantissa,
                        uint32 *exp, uint32 *cycle) 
{
    int rv;
    soc_mem_t config_mem[2];
    lls_l0_shaper_config_c_entry_t  l0_entry;
    lls_l1_shaper_config_c_entry_t  l1_entry;
    lls_l2_shaper_config_lower_entry_t l2_entry;
    uint32 rate_exp[2], rate_mantissa[2];
    uint32 cycle_sel[2];
    int i, idx;
    soc_field_t rate_exp_f[] = {
        C_MAX_REF_RATE_EXPf, C_MIN_REF_RATE_EXPf
    };
    soc_field_t rate_mant_f[] = {
        C_MAX_REF_RATE_MANTf, C_MIN_REF_RATE_MANTf
    };
    soc_field_t rate_exp_fields[] = {
       C_MAX_REF_RATE_EXP_0f, C_MAX_REF_RATE_EXP_1f,
       C_MAX_REF_RATE_EXP_2f, C_MAX_REF_RATE_EXP_3f,
       C_MIN_REF_RATE_EXP_0f, C_MIN_REF_RATE_EXP_1f,
       C_MIN_REF_RATE_EXP_2f, C_MIN_REF_RATE_EXP_3f
    };
    soc_field_t rate_mant_fields[] = {
       C_MAX_REF_RATE_MANT_0f, C_MAX_REF_RATE_MANT_1f,
       C_MAX_REF_RATE_MANT_2f, C_MAX_REF_RATE_MANT_3f,
       C_MIN_REF_RATE_MANT_0f, C_MIN_REF_RATE_MANT_1f,
       C_MIN_REF_RATE_MANT_2f, C_MIN_REF_RATE_MANT_3f
    };
    static const soc_field_t cycle_sel_fields[] = {
        C_MAX_CYCLE_SEL_0f, C_MAX_CYCLE_SEL_1f,
        C_MAX_CYCLE_SEL_2f, C_MAX_CYCLE_SEL_3f,
        C_MIN_CYCLE_SEL_0f, C_MIN_CYCLE_SEL_1f,
        C_MIN_CYCLE_SEL_2f, C_MIN_CYCLE_SEL_3f
    };
    soc_field_t cycle_sel_f[] = {
        C_MAX_CYCLE_SELf, C_MIN_CYCLE_SELf
    };
    int shaper_bucket_index = 0 ;
    int max_l1_shaper_bucket = 0;
    int max_l2_shaper_bucket = 0 ;

    if (min_quantum == NULL )
    {
        return BCM_E_INTERNAL;
    }


    switch (level) {

        case _SOC_KT2_COSQ_NODE_LVL_L0:
            config_mem[0] = LLS_L0_SHAPER_CONFIG_Cm;
            config_mem[1] = LLS_L0_MIN_CONFIG_Cm;

            for (i = 1; i < 2; i++) {
                SOC_IF_ERROR_RETURN
                       (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                 index, &l0_entry));
                rate_exp[i] = soc_mem_field32_get(unit, config_mem[i], 
                                                  &l0_entry,
                                                  rate_exp_f[i]);
                rate_mantissa[i] = soc_mem_field32_get(unit, config_mem[i], 
                                                       &l0_entry,
                                                       rate_mant_f[i]);
                cycle_sel[i] = soc_mem_field32_get(unit, config_mem[i], &l0_entry,
                                cycle_sel_f[i]);
            }
            break;

        case _SOC_KT2_COSQ_NODE_LVL_L1:
            config_mem[0] = LLS_L1_SHAPER_CONFIG_Cm;
            config_mem[1] = LLS_L1_MIN_CONFIG_Cm;
            max_l1_shaper_bucket = soc_mem_index_count(unit,LLS_L1_PARENTm) /
                                               soc_mem_index_count(unit,
                                                LLS_L1_SHAPER_CONFIG_Cm);

                shaper_bucket_index = index % max_l1_shaper_bucket;
            for (i = 1; i < 2; i++) {
                 idx = (i * 4) + shaper_bucket_index;
                SOC_IF_ERROR_RETURN
                       (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                     index / max_l1_shaper_bucket, &l1_entry));
                rate_exp[i] = soc_mem_field32_get(unit, config_mem[i], 
                                                  &l1_entry,
                                                  rate_exp_fields[idx]);
                rate_mantissa[i] = soc_mem_field32_get(unit, config_mem[i], 
                                                       &l1_entry,
                                                       rate_mant_fields[idx]);
                cycle_sel[i] = soc_mem_field32_get(unit, config_mem[i], &l1_entry,
                                cycle_sel_f[i]);
             }
            break;

        case _SOC_KT2_COSQ_NODE_LVL_L2:

            if ((index % 8) < 4) {
                config_mem[0] = LLS_L2_SHAPER_CONFIG_LOWERm;
                config_mem[1] = LLS_L2_MIN_CONFIG_LOWER_Cm;
            } else {
                config_mem[0] = LLS_L2_SHAPER_CONFIG_UPPERm;
                config_mem[1] = LLS_L2_MIN_CONFIG_UPPER_Cm;
            }
             max_l2_shaper_bucket = soc_mem_index_count(unit,LLS_L2_PARENTm)/
              soc_mem_index_count(unit, LLS_L2_SHAPER_CONFIG_LOWERm);
            for (i = 1; i < 2; i++) {
                idx = (i * 4) + (index % 4);
                SOC_IF_ERROR_RETURN
                       (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                 index/max_l2_shaper_bucket, &l2_entry));
                rate_exp[i] = soc_mem_field32_get(unit, config_mem[i], 
                                                  &l2_entry,
                                                  rate_exp_fields[idx]);
                rate_mantissa[i] = soc_mem_field32_get(unit, config_mem[i], 
                                                       &l2_entry,
                                                       rate_mant_fields[idx]);
                cycle_sel[i] = soc_mem_field32_get(unit, config_mem[i], &l2_entry,
                                cycle_sel_fields[idx]);
            }
            break;

        case _SOC_KT2_COSQ_NODE_LVL_S0:
        case _SOC_KT2_COSQ_NODE_LVL_S1:
        case _SOC_KT2_COSQ_NODE_LVL_ROOT:
             return BCM_E_INTERNAL ;
        default:
            return BCM_E_INTERNAL;
    }


   rv =  soc_katana_compute_shaper_rate(unit, rate_mantissa[1], rate_exp[1],
                                        min_quantum);
   if(rv) 
   {
      return rv; 
   }
   *mantissa = rate_mantissa[1]; 
   *exp = rate_exp[1];
   *cycle = cycle_sel[1]; 

    return BCM_E_NONE;
}

int 
soc_kt2_cosq_min_clear(int unit, int port, int index, uint32 level)
{
    lls_l0_shaper_config_c_entry_t  l0_entry;
    lls_l1_shaper_config_c_entry_t  l1_entry;
    lls_l2_shaper_config_lower_entry_t l2_entry;
    soc_mem_t config_mem;
    int idx;

    static const soc_field_t rate_exp_fields[] = {
        C_MIN_REF_RATE_EXP_0f, C_MIN_REF_RATE_EXP_1f,
        C_MIN_REF_RATE_EXP_2f, C_MIN_REF_RATE_EXP_3f
    };
    static const soc_field_t rate_mant_fields[] = {
        C_MIN_REF_RATE_MANT_0f, C_MIN_REF_RATE_MANT_1f,
        C_MIN_REF_RATE_MANT_2f, C_MIN_REF_RATE_MANT_3f
    };
    switch(level){
        case _SOC_KT2_COSQ_NODE_LVL_L0:
            sal_memset(&l0_entry, 0,
                    sizeof(lls_l0_shaper_config_c_entry_t));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, LLS_L0_MIN_CONFIG_Cm, MEM_BLOCK_ALL,
                              index, &l0_entry));
            soc_mem_field32_set(unit, LLS_L0_MIN_CONFIG_Cm , &l0_entry,
                    C_MIN_REF_RATE_EXPf, 0);  
            soc_mem_field32_set(unit, LLS_L0_MIN_CONFIG_Cm, &l0_entry,
                    C_MIN_REF_RATE_MANTf, 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, LLS_L0_MIN_CONFIG_Cm,
                               MEM_BLOCK_ALL, index, &l0_entry));
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L1:
            sal_memset(&l1_entry, 0,
                    sizeof(lls_l1_shaper_config_c_entry_t));
            idx = index % 4;
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, LLS_L1_MIN_CONFIG_Cm, MEM_BLOCK_ALL,
                              index/4, &l1_entry));
            soc_mem_field32_set(unit, LLS_L1_MIN_CONFIG_Cm, &l1_entry,
                    rate_exp_fields[idx], 0);
            soc_mem_field32_set(unit, LLS_L1_MIN_CONFIG_Cm, &l1_entry,
                    rate_mant_fields[idx], 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, LLS_L1_MIN_CONFIG_Cm,
                               MEM_BLOCK_ALL, index/4, &l1_entry));
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L2:
            if ((index % 8) < 4) {
                config_mem = LLS_L2_MIN_CONFIG_LOWER_Cm;
            } else {
                config_mem = LLS_L2_MIN_CONFIG_UPPER_Cm;
            }

            idx = (index % 4);
            sal_memset(&l2_entry, 0,
                    sizeof(lls_l2_shaper_config_lower_entry_t));
            SOC_IF_ERROR_RETURN
                (soc_mem_read(unit, config_mem, MEM_BLOCK_ALL,
                              index/8, &l2_entry));
            soc_mem_field32_set(unit, config_mem, &l2_entry,
                    rate_exp_fields[idx], 0);
            soc_mem_field32_set(unit, config_mem, &l2_entry,
                    rate_mant_fields[idx], 0);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, config_mem,
                               MEM_BLOCK_ALL, index/8, &l2_entry));
            break;

        default:
            break;
    }
    return SOC_E_NONE;
}

int
soc_kt2_cosq_max_bucket_set(int unit, int port,
                        int index, uint32 level)
{
    uint32 idx = 0;
    uint32 i = 0;
    lls_port_shaper_config_c_entry_t port_entry;
    lls_l0_shaper_config_c_entry_t  l0_entry;
    lls_l1_shaper_config_c_entry_t  l1_entry;
    lls_l2_shaper_config_lower_entry_t l2_entry;
    soc_mem_t config_mem[2];
    lls_s0_shaper_config_c_entry_t s0_entry;

    static const soc_field_t rate_exp_fields[] = {
       C_MAX_REF_RATE_EXP_0f, C_MAX_REF_RATE_EXP_1f,
       C_MAX_REF_RATE_EXP_2f, C_MAX_REF_RATE_EXP_3f,
       C_MIN_REF_RATE_EXP_0f, C_MIN_REF_RATE_EXP_1f,
       C_MIN_REF_RATE_EXP_2f, C_MIN_REF_RATE_EXP_3f
    };
    static const soc_field_t rate_mant_fields[] = {
       C_MAX_REF_RATE_MANT_0f, C_MAX_REF_RATE_MANT_1f,
       C_MAX_REF_RATE_MANT_2f, C_MAX_REF_RATE_MANT_3f,
       C_MIN_REF_RATE_MANT_0f, C_MIN_REF_RATE_MANT_1f,
       C_MIN_REF_RATE_MANT_2f, C_MIN_REF_RATE_MANT_3f
    };
    static const soc_field_t burst_exp_fields[] = {
       C_MAX_THLD_EXP_0f, C_MAX_THLD_EXP_1f,
       C_MAX_THLD_EXP_2f, C_MAX_THLD_EXP_3f,
       C_MIN_THLD_EXP_0f, C_MIN_THLD_EXP_1f,
       C_MIN_THLD_EXP_2f, C_MIN_THLD_EXP_3f
    };
    static const soc_field_t burst_mant_fields[] = {
       C_MAX_THLD_MANT_0f, C_MAX_THLD_MANT_1f,
       C_MAX_THLD_MANT_2f, C_MAX_THLD_MANT_3f,
       C_MIN_THLD_MANT_0f, C_MIN_THLD_MANT_1f,
       C_MIN_THLD_MANT_2f, C_MIN_THLD_MANT_3f
    };
    static const soc_field_t cycle_sel_fields[] = {
        C_MAX_CYCLE_SEL_0f, C_MAX_CYCLE_SEL_1f,
        C_MAX_CYCLE_SEL_2f, C_MAX_CYCLE_SEL_3f,
        C_MIN_CYCLE_SEL_0f, C_MIN_CYCLE_SEL_1f,
        C_MIN_CYCLE_SEL_2f, C_MIN_CYCLE_SEL_3f
    };

    soc_field_t rate_exp_f[] = {
        C_MAX_REF_RATE_EXPf, C_MIN_REF_RATE_EXPf
    };
    soc_field_t rate_mant_f[] = {
        C_MAX_REF_RATE_MANTf, C_MIN_REF_RATE_MANTf
    };
    soc_field_t burst_exp_f[] = {
        C_MAX_THLD_EXPf, C_MIN_THLD_EXPf
    };
    soc_field_t burst_mant_f[] = {
        C_MAX_THLD_MANTf, C_MIN_THLD_MANTf
    };
    soc_field_t cycle_sel_f[] = {
        C_MAX_CYCLE_SELf, C_MIN_CYCLE_SELf
    };

    /* set Min/Max threshold shapers to 33Gbps */
    switch (level)  {
        case _SOC_KT2_COSQ_NODE_LVL_ROOT:
            config_mem[0] = LLS_PORT_SHAPER_CONFIG_Cm;

            sal_memset(&port_entry, 0,
                       sizeof(lls_port_shaper_config_c_entry_t));
            SOC_IF_ERROR_RETURN
               (soc_mem_read(unit, config_mem[0], MEM_BLOCK_ALL,
                             index, &port_entry));
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                rate_exp_f[0],
                                KT2_QUEUE_FLUSH_RATE_EXP);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                rate_mant_f[0],
                                KT2_QUEUE_FLUSH_RATE_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                burst_exp_f[0],
                                KT2_QUEUE_FLUSH_BURST_EXP);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                burst_mant_f[0],
                                KT2_QUEUE_FLUSH_BURST_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                cycle_sel_f[0],
                                KT2_QUEUE_FLUSH_CYCLE_SEL);
            SOC_IF_ERROR_RETURN
                   (soc_mem_write(unit, config_mem[0],
                                       MEM_BLOCK_ALL, index, &port_entry));
           break;
        case _SOC_KT2_COSQ_NODE_LVL_S0:
        case _SOC_KT2_COSQ_NODE_LVL_S1:
            config_mem[0] = (level ==_SOC_KT2_COSQ_NODE_LVL_S0) ?
                            LLS_S0_SHAPER_CONFIG_Cm :
                            LLS_S1_SHAPER_CONFIG_Cm;
            SOC_IF_ERROR_RETURN
               (soc_mem_read(unit, config_mem[0], MEM_BLOCK_ALL,
                             index, &s0_entry));
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                rate_exp_f[0], KT2_QUEUE_FLUSH_RATE_EXP);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                rate_mant_f[0], KT2_QUEUE_FLUSH_RATE_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                burst_exp_f[0], KT2_QUEUE_FLUSH_BURST_EXP);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                burst_mant_f[0], KT2_QUEUE_FLUSH_BURST_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                cycle_sel_f[0], KT2_QUEUE_FLUSH_CYCLE_SEL);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, config_mem[0],
                               MEM_BLOCK_ALL, index, &s0_entry));
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L0:
            config_mem[0] = LLS_L0_SHAPER_CONFIG_Cm;
            config_mem[1] = LLS_L0_MIN_CONFIG_Cm;

            for (i = 0; i < 2; i++) {
                sal_memset(&l0_entry, 0,
                             sizeof(lls_l0_shaper_config_c_entry_t));
                SOC_IF_ERROR_RETURN
                       (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                     index, &l0_entry));
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    rate_exp_f[i],
                                    KT2_QUEUE_FLUSH_RATE_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    rate_mant_f[i],
                                    KT2_QUEUE_FLUSH_RATE_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    burst_exp_f[i],
                                    KT2_QUEUE_FLUSH_BURST_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    burst_mant_f[i],
                                    KT2_QUEUE_FLUSH_BURST_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    cycle_sel_f[i],
                                    KT2_QUEUE_FLUSH_CYCLE_SEL);
                SOC_IF_ERROR_RETURN
                         (soc_mem_write(unit, config_mem[i],
                                    MEM_BLOCK_ALL, index, &l0_entry));
            }
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L1:
            config_mem[0] = LLS_L1_SHAPER_CONFIG_Cm;
            config_mem[1] = LLS_L1_MIN_CONFIG_Cm;

            for (i = 0; i < 2; i++) {
                sal_memset(&l1_entry, 0,
                            sizeof(lls_l1_shaper_config_c_entry_t));
                idx = (i * 4) + (index % 4);
                SOC_IF_ERROR_RETURN
                       (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                   index/4, &l1_entry));
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    rate_exp_fields[idx],
                                    KT2_QUEUE_FLUSH_RATE_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    rate_mant_fields[idx],
                                    KT2_QUEUE_FLUSH_RATE_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    burst_exp_fields[idx],
                                    KT2_QUEUE_FLUSH_BURST_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    burst_mant_fields[idx],
                                    KT2_QUEUE_FLUSH_BURST_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    cycle_sel_fields[idx],
                                    KT2_QUEUE_FLUSH_CYCLE_SEL);
                SOC_IF_ERROR_RETURN
                     (soc_mem_write(unit, config_mem[i],
                                    MEM_BLOCK_ALL, index/4, &l1_entry));
            }
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L2:
            if ((index % 8) < 4) {
                config_mem[0] = LLS_L2_SHAPER_CONFIG_LOWERm;
                config_mem[1] = LLS_L2_MIN_CONFIG_LOWER_Cm;
            } else {
                config_mem[0] = LLS_L2_SHAPER_CONFIG_UPPERm;
                config_mem[1] = LLS_L2_MIN_CONFIG_UPPER_Cm;
            }

            for ( i = 0; i < 2; i++) {
                idx = (i * 4) + (index % 4);

                sal_memset(&l2_entry, 0,
                           sizeof(lls_l2_shaper_config_lower_entry_t));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                  index/8, &l2_entry));
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    rate_exp_fields[idx],
                                    KT2_QUEUE_FLUSH_RATE_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    rate_mant_fields[idx],
                                    KT2_QUEUE_FLUSH_RATE_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    burst_exp_fields[idx],
                                    KT2_QUEUE_FLUSH_BURST_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    burst_mant_fields[idx],
                                    KT2_QUEUE_FLUSH_BURST_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    cycle_sel_fields[idx],
                                    KT2_QUEUE_FLUSH_CYCLE_SEL);
                SOC_IF_ERROR_RETURN
                    (soc_mem_write(unit, config_mem[i],
                                   MEM_BLOCK_ALL, index/8, &l2_entry));
            }
            break;
        default:
            return SOC_E_NONE;
    }

    return SOC_E_NONE;

}

int
soc_kt2_cosq_min_bucket_set(int unit, int port,
                        int index, uint32 level)
{
    uint32 idx = 0;
    uint32 i = 0;
    lls_port_shaper_config_c_entry_t port_entry;
    lls_l0_shaper_config_c_entry_t  l0_entry;
    lls_l1_shaper_config_c_entry_t  l1_entry;
    lls_l2_shaper_config_lower_entry_t l2_entry;
    soc_mem_t config_mem[2];
    lls_s0_shaper_config_c_entry_t s0_entry;

    static const soc_field_t rate_exp_fields[] = {
       C_MAX_REF_RATE_EXP_0f, C_MAX_REF_RATE_EXP_1f,
       C_MAX_REF_RATE_EXP_2f, C_MAX_REF_RATE_EXP_3f,
       C_MIN_REF_RATE_EXP_0f, C_MIN_REF_RATE_EXP_1f,
       C_MIN_REF_RATE_EXP_2f, C_MIN_REF_RATE_EXP_3f
    };
    static const soc_field_t rate_mant_fields[] = {
       C_MAX_REF_RATE_MANT_0f, C_MAX_REF_RATE_MANT_1f,
       C_MAX_REF_RATE_MANT_2f, C_MAX_REF_RATE_MANT_3f,
       C_MIN_REF_RATE_MANT_0f, C_MIN_REF_RATE_MANT_1f,
       C_MIN_REF_RATE_MANT_2f, C_MIN_REF_RATE_MANT_3f
    };
    static const soc_field_t burst_exp_fields[] = {
       C_MAX_THLD_EXP_0f, C_MAX_THLD_EXP_1f,
       C_MAX_THLD_EXP_2f, C_MAX_THLD_EXP_3f,
       C_MIN_THLD_EXP_0f, C_MIN_THLD_EXP_1f,
       C_MIN_THLD_EXP_2f, C_MIN_THLD_EXP_3f
    };
    static const soc_field_t burst_mant_fields[] = {
       C_MAX_THLD_MANT_0f, C_MAX_THLD_MANT_1f,
       C_MAX_THLD_MANT_2f, C_MAX_THLD_MANT_3f,
       C_MIN_THLD_MANT_0f, C_MIN_THLD_MANT_1f,
       C_MIN_THLD_MANT_2f, C_MIN_THLD_MANT_3f
    };
    static const soc_field_t cycle_sel_fields[] = {
        C_MAX_CYCLE_SEL_0f, C_MAX_CYCLE_SEL_1f,
        C_MAX_CYCLE_SEL_2f, C_MAX_CYCLE_SEL_3f,
        C_MIN_CYCLE_SEL_0f, C_MIN_CYCLE_SEL_1f,
        C_MIN_CYCLE_SEL_2f, C_MIN_CYCLE_SEL_3f
    };

    soc_field_t rate_exp_f[] = {
        C_MAX_REF_RATE_EXPf, C_MIN_REF_RATE_EXPf
    };
    soc_field_t rate_mant_f[] = {
        C_MAX_REF_RATE_MANTf, C_MIN_REF_RATE_MANTf
    };
    soc_field_t burst_exp_f[] = {
        C_MAX_THLD_EXPf, C_MIN_THLD_EXPf
    };
    soc_field_t burst_mant_f[] = {
        C_MAX_THLD_MANTf, C_MIN_THLD_MANTf
    };
    soc_field_t cycle_sel_f[] = {
        C_MAX_CYCLE_SELf, C_MIN_CYCLE_SELf
    };

    /* set Min/Max threshold shapers to 33Gbps */
    switch (level)  {
        case _SOC_KT2_COSQ_NODE_LVL_ROOT:
            config_mem[0] = LLS_PORT_SHAPER_CONFIG_Cm;

            sal_memset(&port_entry, 0,
                       sizeof(lls_port_shaper_config_c_entry_t));
            SOC_IF_ERROR_RETURN
               (soc_mem_read(unit, config_mem[0], MEM_BLOCK_ALL,
                             index, &port_entry));
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                rate_exp_f[0],
                                KT2_QUEUE_MIN_RATE_EXP);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                rate_mant_f[0],
                                KT2_QUEUE_MIN_RATE_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                burst_exp_f[0],
                                KT2_QUEUE_MIN_BURST_EXP);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                burst_mant_f[0],
                                KT2_QUEUE_MIN_BURST_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &port_entry,
                                cycle_sel_f[0],
                                KT2_QUEUE_MIN_CYCLE_SEL);
            SOC_IF_ERROR_RETURN
                   (soc_mem_write(unit, config_mem[0],
                                       MEM_BLOCK_ALL, index, &port_entry));
           break;
        case _SOC_KT2_COSQ_NODE_LVL_S0:
        case _SOC_KT2_COSQ_NODE_LVL_S1:
            config_mem[0] = (level ==_SOC_KT2_COSQ_NODE_LVL_S0) ?
                            LLS_S0_SHAPER_CONFIG_Cm :
                            LLS_S1_SHAPER_CONFIG_Cm;
            SOC_IF_ERROR_RETURN
               (soc_mem_read(unit, config_mem[0], MEM_BLOCK_ALL,
                             index, &s0_entry));
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                rate_exp_f[0], KT2_QUEUE_MIN_RATE_EXP);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                rate_mant_f[0], KT2_QUEUE_MIN_RATE_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                burst_exp_f[0], KT2_QUEUE_MIN_BURST_EXP);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                burst_mant_f[0], KT2_QUEUE_MIN_BURST_MANTISSA);
            soc_mem_field32_set(unit, config_mem[0], &s0_entry,
                                cycle_sel_f[0], KT2_QUEUE_MIN_CYCLE_SEL);
            SOC_IF_ERROR_RETURN
                (soc_mem_write(unit, config_mem[0],
                               MEM_BLOCK_ALL, index, &s0_entry));
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L0:
            config_mem[0] = LLS_L0_SHAPER_CONFIG_Cm;
            config_mem[1] = LLS_L0_MIN_CONFIG_Cm;

            for (i = 0; i < 2; i++) {
                sal_memset(&l0_entry, 0,
                             sizeof(lls_l0_shaper_config_c_entry_t));
                SOC_IF_ERROR_RETURN
                       (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                     index, &l0_entry));
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    rate_exp_f[i],
                                    KT2_QUEUE_MIN_RATE_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    rate_mant_f[i],
                                    KT2_QUEUE_MIN_RATE_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    burst_exp_f[i],
                                    KT2_QUEUE_MIN_BURST_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    burst_mant_f[i],
                                    KT2_QUEUE_MIN_BURST_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l0_entry,
                                    cycle_sel_f[i],
                                    KT2_QUEUE_MIN_CYCLE_SEL);
                SOC_IF_ERROR_RETURN
                         (soc_mem_write(unit, config_mem[i],
                                    MEM_BLOCK_ALL, index, &l0_entry));
            }
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L1:
            config_mem[0] = LLS_L1_SHAPER_CONFIG_Cm;
            config_mem[1] = LLS_L1_MIN_CONFIG_Cm;

            for (i = 0; i < 2; i++) {
                sal_memset(&l1_entry, 0,
                            sizeof(lls_l1_shaper_config_c_entry_t));
                idx = (i * 4) + (index % 4);
                SOC_IF_ERROR_RETURN
                       (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                   index/4, &l1_entry));
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    rate_exp_fields[idx],
                                    KT2_QUEUE_MIN_RATE_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    rate_mant_fields[idx],
                                    KT2_QUEUE_MIN_RATE_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    burst_exp_fields[idx],
                                    KT2_QUEUE_MIN_BURST_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    burst_mant_fields[idx],
                                    KT2_QUEUE_MIN_BURST_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l1_entry,
                                    cycle_sel_fields[idx],
                                    KT2_QUEUE_MIN_CYCLE_SEL);
                SOC_IF_ERROR_RETURN
                     (soc_mem_write(unit, config_mem[i],
                                    MEM_BLOCK_ALL, index/4, &l1_entry));
            }
            break;
        case _SOC_KT2_COSQ_NODE_LVL_L2:
            if ((index % 8) < 4) {
                config_mem[0] = LLS_L2_SHAPER_CONFIG_LOWERm;
                config_mem[1] = LLS_L2_MIN_CONFIG_LOWER_Cm;
            } else {
                config_mem[0] = LLS_L2_SHAPER_CONFIG_UPPERm;
                config_mem[1] = LLS_L2_MIN_CONFIG_UPPER_Cm;
            }

            for ( i = 0; i < 2; i++) {
                idx = (i * 4) + (index % 4);

                sal_memset(&l2_entry, 0,
                           sizeof(lls_l2_shaper_config_lower_entry_t));
                SOC_IF_ERROR_RETURN
                    (soc_mem_read(unit, config_mem[i], MEM_BLOCK_ALL,
                                  index/8, &l2_entry));
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    rate_exp_fields[idx],
                                    KT2_QUEUE_MIN_RATE_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    rate_mant_fields[idx],
                                    KT2_QUEUE_MIN_RATE_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    burst_exp_fields[idx],
                                    KT2_QUEUE_MIN_BURST_EXP);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    burst_mant_fields[idx],
                                    KT2_QUEUE_MIN_BURST_MANTISSA);
                soc_mem_field32_set(unit, config_mem[i], &l2_entry,
                                    cycle_sel_fields[idx],
                                    KT2_QUEUE_MIN_CYCLE_SEL);
                SOC_IF_ERROR_RETURN
                    (soc_mem_write(unit, config_mem[i],
                                   MEM_BLOCK_ALL, index/8, &l2_entry));
            }
            break;
        default:
            return SOC_E_NONE;
    }

    return SOC_E_NONE;

}

STATIC
int  _soc_kt2_is_bit64_set(uint64 dst, int n)
{
    uint64 temp64;
    COMPILER_64_SET(temp64, 0, 1);
    COMPILER_64_SHL(temp64, n);
    COMPILER_64_AND(temp64, dst);
    return (!COMPILER_64_IS_ZERO(temp64));
}
STATIC
int _soc_kt2_dfc_status_get(int unit, int port, int hw_index,
                            int *dfc_restore_needed,
                            int *sid)
{
    soc_pbmp_t  pbmp_linkphy;
    soc_reg_t reg_dfc;
    uint64 rval_dfc, data_dfc;
    int stream_id;
    egr_queue_to_pp_port_map_entry_t pp_port_map;
    
    /* Check if port is not linkphy then return */
    pbmp_linkphy = soc_property_get_pbmp(unit, spn_PBMP_LINKPHY, 0);

    if (!SOC_PBMP_MEMBER(pbmp_linkphy, port)) {
        return SOC_E_NONE;
    }
    SOC_IF_ERROR_RETURN(READ_EGR_QUEUE_TO_PP_PORT_MAPm(unit, MEM_BLOCK_ALL, 
                                                        hw_index,
                                                        &pp_port_map));
    stream_id = soc_mem_field32_get(unit, EGR_QUEUE_TO_PP_PORT_MAPm, 
                                    &pp_port_map, DEVICE_STREAM_IDf);
    stream_id = stream_id % 128;
    *sid = stream_id;
    if (stream_id < 64) {
        reg_dfc = RXLP_DFC_STATUS_LOr;
    } else {
        reg_dfc = RXLP_DFC_STATUS_HIr;
        stream_id = stream_id % 64;
    }

    SOC_IF_ERROR_RETURN(
        soc_reg_get(unit, reg_dfc, port, 0, &rval_dfc));
    data_dfc = soc_reg64_field_get(unit, reg_dfc, rval_dfc, DFC_STATUSf);
    if (!_soc_kt2_is_bit64_set(data_dfc, stream_id)) {
         return SOC_E_NONE;
    }
    *dfc_restore_needed = 1;
    return SOC_E_NONE;
}


int _soc_kt2_dfc_status_clear(int unit, int port, int stream_id)
{
    soc_reg_t reg_dfc, reg_cpu;
    uint64 rval_dfc, rval_cpu, rval_cpu_save, data_dfc, data_cpu;

    if (stream_id < 64) {
        reg_dfc = RXLP_DFC_STATUS_LOr;
        reg_cpu = RXLP_DFC_STATUS_CPU_UPDATE_ENABLE_LOr;
    } else {
        reg_dfc = RXLP_DFC_STATUS_HIr;
        reg_cpu = RXLP_DFC_STATUS_CPU_UPDATE_ENABLE_HIr;
        stream_id = stream_id % 64;
    }

    SOC_IF_ERROR_RETURN(
        soc_reg_get(unit, reg_dfc, port, 0, &rval_dfc));
    data_dfc = soc_reg64_field_get(unit, reg_dfc, rval_dfc, DFC_STATUSf);
    COMPILER_64_BITCLR(data_dfc, stream_id);
  
    SOC_IF_ERROR_RETURN(
        soc_reg_get(unit,reg_cpu, port, 0, &rval_cpu));
    rval_cpu_save = rval_cpu;
    data_cpu = soc_reg64_field_get(unit, reg_cpu, rval_cpu, DFC_STATUS_CPU_WRITE_ENf);
    COMPILER_64_BITSET(data_cpu, stream_id);
    soc_reg64_field_set(unit, reg_cpu, &rval_cpu, DFC_STATUS_CPU_WRITE_ENf, data_cpu);
    SOC_IF_ERROR_RETURN(
        soc_reg_set(unit, reg_cpu, port, 0, rval_cpu));
    WRITE_RXLP_DFC_CPU_UPDATE_REFRESHr(unit, port, 1);
    
    SOC_IF_ERROR_RETURN(
         soc_reg_set(unit,reg_cpu, port, 0, rval_cpu_save));
    WRITE_RXLP_DFC_CPU_UPDATE_REFRESHr(unit, port, 1);

    soc_reg64_field_set(unit, reg_dfc, &rval_dfc, DFC_STATUSf, data_dfc);
    SOC_IF_ERROR_RETURN(
            soc_reg_set(unit, reg_dfc, port, 0, rval_dfc));

    return SOC_E_NONE;
}

STATIC
int _soc_kt2_dfc_status_set(int unit, int port, int stream_id)
{
    soc_reg_t reg_dfc, reg_cpu;
    uint64 rval_dfc, rval_cpu, rval_cpu_save, data_dfc, data_cpu;

    if (stream_id < 64) {
        reg_dfc = RXLP_DFC_STATUS_LOr;
        reg_cpu = RXLP_DFC_STATUS_CPU_UPDATE_ENABLE_LOr;
    } else {
        reg_dfc = RXLP_DFC_STATUS_HIr;
        reg_cpu = RXLP_DFC_STATUS_CPU_UPDATE_ENABLE_HIr;
        stream_id = stream_id % 64;
    }

    SOC_IF_ERROR_RETURN(
        soc_reg_get(unit, reg_dfc, port, 0, &rval_dfc));
    data_dfc = soc_reg64_field_get(unit, reg_dfc, rval_dfc, DFC_STATUSf);
    COMPILER_64_BITSET(data_dfc, stream_id);

    SOC_IF_ERROR_RETURN(
        soc_reg_get(unit,reg_cpu, port, 0, &rval_cpu));
    rval_cpu_save = rval_cpu;
    data_cpu = soc_reg64_field_get(unit, reg_cpu, rval_cpu, DFC_STATUS_CPU_WRITE_ENf);
    COMPILER_64_BITSET(data_cpu, stream_id);
    soc_reg64_field_set(unit, reg_cpu, &rval_cpu, DFC_STATUS_CPU_WRITE_ENf, data_cpu);
    SOC_IF_ERROR_RETURN(
        soc_reg_set(unit, reg_cpu, port, 0, rval_cpu));
    WRITE_RXLP_DFC_CPU_UPDATE_REFRESHr(unit, port, 1);

    SOC_IF_ERROR_RETURN(
         soc_reg_set(unit,reg_cpu, port, 0, rval_cpu_save));
    WRITE_RXLP_DFC_CPU_UPDATE_REFRESHr(unit, port, 1);

    soc_reg64_field_set(unit, reg_dfc, &rval_dfc, DFC_STATUSf, data_dfc);
    SOC_IF_ERROR_RETURN(
            soc_reg_set(unit, reg_dfc, port, 0, rval_dfc));

    return SOC_E_NONE;
}

STATIC
int _soc_kt2_cosq_pp_port_and_s1_index_get(int unit,
                                           int queue_id,
                                           int *pp_port,
                                           int *s1_index)
{
    lls_l0_parent_entry_t l0_parent;
    lls_l1_parent_entry_t l1_parent;
    lls_l2_parent_entry_t l2_parent;
    egr_queue_to_pp_port_map_entry_t pp_port_map;
    int index;
    int ctype;


    SOC_IF_ERROR_RETURN
        (READ_LLS_L2_PARENTm(unit, MEM_BLOCK_ALL, queue_id, &l2_parent));
    index = soc_mem_field32_get(unit, LLS_L2_PARENTm, &l2_parent, C_PARENTf);

    SOC_IF_ERROR_RETURN
            (READ_LLS_L1_PARENTm(unit, MEM_BLOCK_ALL, index, &l1_parent));
    index = soc_mem_field32_get(unit, LLS_L1_PARENTm, &l1_parent, C_PARENTf);

    SOC_IF_ERROR_RETURN
            (READ_LLS_L0_PARENTm(unit, MEM_BLOCK_ALL, index, &l0_parent));

    /*
     * Ctype 1 indicates parent is a port, 0 indicates parent is an s1.
     */
    ctype  = soc_mem_field32_get(unit, LLS_L0_PARENTm, &l0_parent, C_TYPEf);;
    if (!ctype) {
        if (s1_index != NULL) {
            *s1_index = soc_mem_field32_get(unit, LLS_L0_PARENTm,
                                            &l0_parent, C_PARENTf);
        }
        if (pp_port != NULL) {
            SOC_IF_ERROR_RETURN
                (READ_EGR_QUEUE_TO_PP_PORT_MAPm(unit, MEM_BLOCK_ALL,
                                                queue_id, &pp_port_map));
            *pp_port = soc_mem_field32_get(unit, EGR_QUEUE_TO_PP_PORT_MAPm,
                                           &pp_port_map, PP_PORTf);
        }
    }
    return SOC_E_NONE;

}
STATIC
int _soc_kt2_coe_pause_status_get(int unit, int port, int hw_index,
                                  int *coe_pause_restore_needed)
{
    soc_pbmp_t  pbmp_linkphy, pbmp_coe;

    /* Check if port is not coe then return */
    pbmp_coe = soc_property_get_pbmp(unit, spn_PBMP_SUBPORT, 0);

    if (!SOC_PBMP_MEMBER(pbmp_coe, port)) {
        return SOC_E_NONE;
    }

    /* Check if port is linkphy then return */
    pbmp_linkphy = soc_property_get_pbmp(unit, spn_PBMP_LINKPHY, 0);

    if (SOC_PBMP_MEMBER(pbmp_linkphy, port)) {
        return SOC_E_NONE;
    }
#ifdef BCM_SABER2_SUPPORT
    if (SOC_IS_SABER2(unit)) {
        *coe_pause_restore_needed = 1;
    }
#endif
    return SOC_E_NONE;
}
#define    KT2_LLS_CLEAR_CREDIT_COE_BASE  64
#define    KT2_LLS_CLEAR_CREDIT_MAX_S1    64
STATIC
int _soc_kt2_coe_pause_status_clear(int unit, int hw_index)
{
    uint32 rval;
    mmu_enq_src_ppp_to_s1_lookup_entry_t ppp_to_s1;
    int pp_port = -1, s1_index = -1, max_count;

    SOC_IF_ERROR_RETURN(
        _soc_kt2_cosq_pp_port_and_s1_index_get(unit, hw_index, &pp_port, &s1_index));
    max_count = soc_mem_index_count(unit, MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm);
    if ((pp_port < 0) || (pp_port >= max_count)) {
        return SOC_E_NONE;
    }
    if ((s1_index < 0) || (s1_index >= KT2_LLS_CLEAR_CREDIT_MAX_S1)) {
        return SOC_E_NONE;
    }
    /*clear channel mapping */
    memset(&ppp_to_s1, 0, sizeof(ppp_to_s1));
    SOC_IF_ERROR_RETURN(
        READ_MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm(unit, MEM_BLOCK_ALL,
                                           pp_port, &ppp_to_s1));
    soc_mem_field32_set(unit, MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm,
                        &ppp_to_s1, S1_VLDf, 0);
    SOC_IF_ERROR_RETURN(
        WRITE_MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm(unit,
                                            MEM_BLOCK_ALL,
                                            pp_port, &ppp_to_s1));
    /* Clear coe pause */
    SOC_IF_ERROR_RETURN(
        READ_LLS_CLEAR_S1_CREDITSr(unit, &rval));
    soc_reg_field_set(unit, LLS_CLEAR_S1_CREDITSr, &rval, VALIDf, 1);
    soc_reg_field_set(unit, LLS_CLEAR_S1_CREDITSr, &rval, ADDRESSf,
                      KT2_LLS_CLEAR_CREDIT_COE_BASE + s1_index);
    SOC_IF_ERROR_RETURN(
        WRITE_LLS_CLEAR_S1_CREDITSr(unit, rval));
    return SOC_E_NONE;

}

STATIC
int _soc_kt2_coe_pause_status_set(int unit, int hw_index)
{
    mmu_enq_src_ppp_to_s1_lookup_entry_t ppp_to_s1;
    int pp_port, max_count;

    SOC_IF_ERROR_RETURN(
        _soc_kt2_cosq_pp_port_and_s1_index_get(unit, hw_index, &pp_port, NULL));
    max_count = soc_mem_index_count(unit, MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm);
    if ((pp_port < 0) || (pp_port >= max_count)) {
        return SOC_E_NONE;
    }
    /*set channel mapping */
    memset(&ppp_to_s1, 0, sizeof(ppp_to_s1));
    SOC_IF_ERROR_RETURN(
        READ_MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm(unit, MEM_BLOCK_ALL,
                                           pp_port, &ppp_to_s1));
    soc_mem_field32_set(unit, MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm,
                        &ppp_to_s1, S1_VLDf, 1);
    SOC_IF_ERROR_RETURN(
        WRITE_MMU_ENQ_SRC_PPP_TO_S1_LOOKUPm(unit,
                                            MEM_BLOCK_ALL,
                                            pp_port, &ppp_to_s1));
    return SOC_E_NONE;

}

int
_soc_kt2_cosq_begin_port_flush(int unit, int port, int hw_index)
{
    uint32 map_entry[SOC_MAX_MEM_WORDS];
    int index =0 , eindex = 0;
    static const soc_field_t indexf[] = {
        INDEX0f, INDEX1f
    };
    int map_offset = 0, dfc_restore_needed = 0, stream_id = 0;
    int packing_mode = 0, coe_pause_restore_needed = 0;
    uint32 rval = 0;
    uint32 ext_mem = 0;
    int flush_active = 0;
    uint32 timeout_val;
    soc_timeout_t timeout;

    if (IS_EXT_MEM_PORT(unit, port)) {
        ext_mem = 1;
    }


    if(soc_feature(unit, soc_feature_mmu_packing)) {
        packing_mode = soc_property_get(unit, spn_MMU_MULTI_PACKETS_PER_CELL, 0);
    }
    if (packing_mode == 1) {
        /* default time - packing mode
         */
        timeout_val = soc_property_get(unit, spn_MMU_QUEUE_FLUSH_TIMEOUT,
                                _SOC_COSQ_QUEUE_FLUSH_TIMEOUT_PACKING_DEFAULT);
    } else {

        /* default time - non packing mode
         */
        timeout_val = soc_property_get(unit, spn_MMU_QUEUE_FLUSH_TIMEOUT,
                                    _SOC_COSQ_QUEUE_FLUSH_TIMEOUT_DEFAULT);
    }

    SOC_IF_ERROR_RETURN(READ_TOQ_FLUSH0r(unit, &rval));

    soc_reg_field_set(unit, TOQ_FLUSH0r, &rval, FLUSH_NUMf,1);
    soc_reg_field_set(unit, TOQ_FLUSH0r, &rval, FLUSH_ID0f, hw_index);
    if (soc_reg_field_valid(unit, TOQ_FLUSH0r, FLUSH_EXTERNALf)){
        soc_reg_field_set(unit, TOQ_FLUSH0r, &rval, FLUSH_EXTERNALf,
                              ext_mem);
    }
    soc_reg_field_set(unit, TOQ_FLUSH0r, &rval, FLUSH_ACTIVEf, 1);
    soc_reg_field_set(unit, TOQ_FLUSH0r, &rval, FLUSH_TYPEf, 0);

    SOC_IF_ERROR_RETURN(WRITE_TOQ_FLUSH0r(unit, rval));
    if (hw_index > 0) {
        index = hw_index / 16 ;
        eindex = (hw_index % 16) / 8;
        SOC_IF_ERROR_RETURN
            (soc_mem_read(unit, MMU_INTFI_FC_MAP_TBL2m,
                          MEM_BLOCK_ALL, index, &map_entry));
        map_offset = soc_mem_field32_get(unit, MMU_INTFI_FC_MAP_TBL2m, &map_entry,
                indexf[eindex]);
        if (map_offset) {
            soc_mem_field32_set(unit, MMU_INTFI_FC_MAP_TBL2m, &map_entry,
                    indexf[eindex], 0);
            SOC_IF_ERROR_RETURN(soc_mem_write(unit, MMU_INTFI_FC_MAP_TBL2m,
                        MEM_BLOCK_ALL, index, &map_entry));

        }
    }
    /*
     * Check if queue belongs to linkphy port and corresponding
     * stream (S1 node) is paused because of received DFC frame.
     * Then clear DFC_STATUS and save the original value to
     * restore it again.In similar manner clear CoE pause too.
     */
    SOC_IF_ERROR_RETURN(_soc_kt2_dfc_status_get(unit, port, hw_index,
                                &dfc_restore_needed, &stream_id));
    if (dfc_restore_needed) {
        SOC_IF_ERROR_RETURN(_soc_kt2_dfc_status_clear(unit, port,
                                                    stream_id));
    }
    SOC_IF_ERROR_RETURN(_soc_kt2_coe_pause_status_get(unit, port, hw_index,
                        &coe_pause_restore_needed));
    if (coe_pause_restore_needed) {
        SOC_IF_ERROR_RETURN(_soc_kt2_coe_pause_status_clear(unit, hw_index));
    }


    /* Wait for flush completion */
    flush_active = 1;
    soc_timeout_init(&timeout, timeout_val, 0);

    while (flush_active) {
        if (SOC_REG_IS_VALID(unit, TOQ_FLUSH0r)) {
            SOC_IF_ERROR_RETURN(READ_TOQ_FLUSH0r(unit, &rval));
            flush_active = soc_reg_field_get(unit, TOQ_FLUSH0r, rval,
                                             FLUSH_ACTIVEf);
        }

        if (soc_timeout_check(&timeout)) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
               (BSL_META_U(unit,
               "ERROR: Port %d Queue flush operation failed for queue %d \n"),
                port, hw_index));
            if (map_offset) {
                soc_mem_field32_set(unit, MMU_INTFI_FC_MAP_TBL2m, &map_entry,
                        indexf[eindex], map_offset);
                SOC_IF_ERROR_RETURN(soc_mem_write(unit, MMU_INTFI_FC_MAP_TBL2m,
                            MEM_BLOCK_ALL, index, &map_entry));

            }
            return (SOC_E_TIMEOUT);

        }
    }

    if (map_offset) {
        soc_mem_field32_set(unit, MMU_INTFI_FC_MAP_TBL2m, &map_entry,
                indexf[eindex], map_offset);
        SOC_IF_ERROR_RETURN(soc_mem_write(unit, MMU_INTFI_FC_MAP_TBL2m,
                    MEM_BLOCK_ALL, index, &map_entry));

    }

    if (dfc_restore_needed) {
        SOC_IF_ERROR_RETURN(_soc_kt2_dfc_status_set(unit, port,
                                                    stream_id));
    }
    if (coe_pause_restore_needed) {
        SOC_IF_ERROR_RETURN(_soc_kt2_coe_pause_status_set(unit, hw_index));
    }

    return SOC_E_NONE;
}

int
_soc_kt2_cosq_end_port_flush(int unit, int hw_index)
{
    uint32 rval = 0, q_bmp;

    KT2_COSQ_LOCK(unit);

    soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG2r, &rval, QUEUE_NUMf,
                      (hw_index & 0xfe0));
    SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG2r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_CFG1r(unit, &rval));
    soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, QUEUE_RDf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG1r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_STATUSr(unit, &rval));
    q_bmp = soc_reg_field_get(unit, THDO_QUEUE_DISABLE_STATUSr, rval,
                                           QUEUE_BITMAPf);

    if (q_bmp & (1 << (hw_index % 32))) {
        SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_CFG2r(unit, &rval));
        soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG2r, &rval, QUEUE_NUMf,
                                       hw_index );
        SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG2r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_CFG1r(unit, &rval));
        soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, QUEUE_WRf, 1);
        SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG1r(unit, rval));
    }

    KT2_COSQ_UNLOCK(unit);

    return SOC_E_NONE;
}

int
soc_kt2_cosq_queue_enable(int unit, int hw_index, int enable)
{
    uint32 rval = 0, rval1 = 0, q_bmp, disable_bit, wr_type = 0;
    soc_timeout_t       to;
    sal_usecs_t         timeout;

    soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, STAT_CLRf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG1r(unit, rval));

    rval = 0;
    soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG2r, &rval, QUEUE_NUMf,
                      hw_index); 
    SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG2r(unit, rval));

    SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_CFG1r(unit, &rval));
    wr_type = soc_reg_field_get(unit, THDO_QUEUE_DISABLE_CFG1r, rval, QUEUE_WR_TYPEf);
    if (enable) {
        soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, QUEUE_WR_TYPEf, 0);
    } else {
        soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, QUEUE_WR_TYPEf, 1);
    }
    soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, QUEUE_WRf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG1r(unit, rval));

    timeout = 20000;
    soc_timeout_init(&to, timeout, 0);
    do {

        SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_CFG1r(unit, &rval1));
        soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval1, QUEUE_RDf, 1);
        SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG1r(unit, rval1));

        SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_STATUSr(unit, &rval1));
        q_bmp = soc_reg_field_get(unit, THDO_QUEUE_DISABLE_STATUSr, rval1,
                                           QUEUE_BITMAPf);

        disable_bit = (q_bmp & (1 << (hw_index % 32)));

        if ((enable && !disable_bit) ||
            (!enable && disable_bit)) {
            SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_CFG1r(unit, &rval));
            soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, QUEUE_WR_TYPEf, wr_type);
            SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG1r(unit, rval));
            return SOC_E_NONE;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : Queue %d enable timeout\n"), unit, hw_index));
            break;
        }
    } while (TRUE);
    SOC_IF_ERROR_RETURN(READ_THDO_QUEUE_DISABLE_CFG1r(unit, &rval));
    soc_reg_field_set(unit, THDO_QUEUE_DISABLE_CFG1r, &rval, QUEUE_WR_TYPEf, wr_type);
    SOC_IF_ERROR_RETURN(WRITE_THDO_QUEUE_DISABLE_CFG1r(unit, rval));
    return SOC_E_TIMEOUT;
}

soc_error_t 
soc_katana2_mmu_port_enable_set(int unit, soc_port_t port, int enable)
{
    uint32 rval;
    uint64 rval64, p_bmp;
    soc_timeout_t       to;
    sal_usecs_t         timeout;

    rval = 0;
    soc_reg_field_set(unit, THDO_PORT_DISABLE_CFG1r, &rval, STAT_CLRf, 1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_PORT_DISABLE_CFG1r(unit, rval));

    rval = 0;
    COMPILER_64_ZERO(rval64);
    soc_reg_field_set(unit, THDO_PORT_DISABLE_CFG1r, &rval, 
                        PORT_IDf, port);

    if (enable) {
        soc_reg_field_set(unit, THDO_PORT_DISABLE_CFG1r, &rval, 
                        PORT_WR_TYPEf,0);
    } else {
        soc_reg_field_set(unit, THDO_PORT_DISABLE_CFG1r, &rval, 
                        PORT_WR_TYPEf,1);
    }
    SOC_IF_ERROR_RETURN(WRITE_THDO_PORT_DISABLE_CFG1r(unit,rval));
    soc_reg_field_set(unit, THDO_PORT_DISABLE_CFG1r, &rval, 
                        PORT_WRf,1);
    SOC_IF_ERROR_RETURN(WRITE_THDO_PORT_DISABLE_CFG1r(unit,rval));

    timeout = 20000;
    soc_timeout_init(&to, timeout, 0);
    do {
        SOC_IF_ERROR_RETURN(READ_THDO_PORT_DISABLE_CFG1r(unit, &rval));
        soc_reg_field_set(unit, THDO_PORT_DISABLE_CFG1r, &rval, PORT_RDf, 1);
        SOC_IF_ERROR_RETURN(WRITE_THDO_PORT_DISABLE_CFG1r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_THDO_PORT_DISABLE_STATUSr(unit, &rval64));
        p_bmp = soc_reg64_field_get(unit, THDO_PORT_DISABLE_STATUSr, rval64,
                                           QUEUE_BITMAPf);

        if ((enable && !COMPILER_64_BITTEST(p_bmp, port)) ||
            (!enable && COMPILER_64_BITTEST(p_bmp, port))) {
            return SOC_E_NONE;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : Port %d enable timeout\n"), unit, port));
            break;
        }
    } while (TRUE);

    return SOC_E_TIMEOUT;
}
STATIC int
_soc_kt2_mmu_config_shared_update_check(int unit, int val1, int val2, int flags)
{
    int rv = 0;
    if (flags == 1) {
        if (val1 > val2) {
            rv = 1;
        }
    } else {
        if (val1 < val2) {
            rv = 1;
        }
    }
    return rv;
}

int
soc_kt2_mmu_config_shared_buf_recalc(int unit, int shared_size,
                                     bcm_kt2_cosq_recalc_type_t recalc_type)
{
    uint8         port_index = 0;
    uint32        op_node=0;
    uint32        port_max_opnodes = 0;
    uint8 port_list[]={KT2_CMIC_PORT, KT2_LPBK_PORT ,
                       1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                       11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                       21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
                       31, 32, 33, 34, 35, 36, 37, 38, 39, 40};
    soc_port_t    port_iter=0;
    soc_info_t    *si= &SOC_INFO(unit); 
    mmu_thdo_opnconfig_cell_entry_t     mmu_thdo_opnconfig_cell_entry={{0}};
    uint32        op_node_offset=0;
    uint32        temp_val;
    uint32        rval = 0;
    uint32        ext_mem_type;
    int           cur_limit, resume_limit, flags;

    ext_mem_type = ((recalc_type == BCM_KT2_RECALC_SHARED_EXT_DECREMENT) ||
                    (recalc_type == BCM_KT2_RECALC_SHARED_EXT_INCREMENT)) ? 1 : 0;

    flags = ((recalc_type == BCM_KT2_RECALC_SHARED_INT_DECREMENT) ||
             (recalc_type == BCM_KT2_RECALC_SHARED_EXT_DECREMENT)) ? 1 : 0;

    if ((recalc_type == BCM_KT2_RECALC_SHARED_EXT_DECREMENT) || 
        (recalc_type == BCM_KT2_RECALC_SHARED_EXT_INCREMENT)) {

        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r (
                            unit, &rval));
        cur_limit = soc_reg_field_get(unit, OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r, rval,
                                         OP_BUFFER_SHARED_LIMIT_CELLEf);
        if (_soc_kt2_mmu_config_shared_update_check(unit, cur_limit, shared_size, flags)) {
            if (recalc_type == BCM_KT2_RECALC_SHARED_EXT_DECREMENT) {
                temp_val = cur_limit - shared_size;
            } else {
                temp_val = shared_size - cur_limit;
            }

            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r, &rval,
                            OP_BUFFER_SHARED_LIMIT_CELLEf, shared_size);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r (
                                unit, rval));

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r(
                                unit, &rval));
            cur_limit = soc_reg_field_get(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r, 
                            rval,OP_BUFFER_SHARED_LIMIT_RESUME_CELLEf);
            if (recalc_type == BCM_KT2_RECALC_SHARED_EXT_DECREMENT) {
                resume_limit = cur_limit - temp_val;
            } else {
                resume_limit = cur_limit + temp_val;
            }
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r, 
                            &rval,OP_BUFFER_SHARED_LIMIT_RESUME_CELLEf, resume_limit);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_CELLE_POOL0r(
                                unit, rval));
        }
    } else {
        /* Ouput port thresholds */
        /* Internal buffer Egress pool */
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLIr (unit, &rval));
        cur_limit = soc_reg_field_get(unit, OP_BUFFER_SHARED_LIMIT_CELLIr, rval,
                                        OP_BUFFER_SHARED_LIMIT_CELLIf);
        if (_soc_kt2_mmu_config_shared_update_check(unit, cur_limit, shared_size, flags)) {
            if (recalc_type == BCM_KT2_RECALC_SHARED_INT_DECREMENT) {
                temp_val = cur_limit - shared_size;
            } else {
                temp_val = shared_size - cur_limit;
            }
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_CELLIr, &rval,
                    OP_BUFFER_SHARED_LIMIT_CELLIf, shared_size);

            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_CELLIr (unit, rval));

            SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr(unit, &rval));
            cur_limit = soc_reg_field_get(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr, rval,
                                        OP_BUFFER_SHARED_LIMIT_RESUME_CELLIf);
            if (recalc_type == BCM_KT2_RECALC_SHARED_INT_DECREMENT) {
                resume_limit = cur_limit - temp_val;
            } else {
                resume_limit = cur_limit + temp_val;
            }
            soc_reg_field_set(unit, OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr, &rval,
                    OP_BUFFER_SHARED_LIMIT_RESUME_CELLIf, resume_limit);
            SOC_IF_ERROR_RETURN(WRITE_OP_BUFFER_SHARED_LIMIT_RESUME_CELLIr(unit, rval));
        }
    }

    op_node = 0;
    port_max_opnodes = 0;
    for(port_index = 0, op_node = 0 ;
        port_index < COUNTOF(port_list);
        port_index++, op_node += port_max_opnodes ) {

        port_iter = port_list[port_index];
        port_max_opnodes = ceil_func(si->port_num_uc_cosq[port_iter],8);

        if (((!ext_mem_type && !SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port_iter)) ||
            (ext_mem_type && SOC_PBMP_MEMBER(PBMP_EXT_MEM (unit), port_iter))) &&
            (port_iter >= KT2_CMIC_PORT) && (port_iter <= KT2_LPBK_PORT)) {
            for (op_node_offset = 0;
                op_node_offset < port_max_opnodes ;
                op_node_offset++) {
                SOC_IF_ERROR_RETURN(READ_MMU_THDO_OPNCONFIG_CELLm(unit,
                                    MEM_BLOCK_ANY,op_node + op_node_offset,
                                    &mmu_thdo_opnconfig_cell_entry));

                cur_limit = soc_mem_field32_get(unit, MMU_THDO_OPNCONFIG_CELLm,
                                                   &mmu_thdo_opnconfig_cell_entry,
                                                   OPN_SHARED_LIMIT_CELLf);
                if (_soc_kt2_mmu_config_shared_update_check(
                                unit, cur_limit, shared_size, flags)) {
                    if ((recalc_type == BCM_KT2_RECALC_SHARED_INT_DECREMENT) ||
                        (recalc_type == BCM_KT2_RECALC_SHARED_EXT_DECREMENT)) {
                        temp_val = cur_limit - shared_size;
                    } else {
                        temp_val = shared_size - cur_limit;
                    }
                    soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                                        &mmu_thdo_opnconfig_cell_entry,
                                        OPN_SHARED_LIMIT_CELLf,
                                        shared_size);

                    cur_limit = soc_mem_field32_get(unit, MMU_THDO_OPNCONFIG_CELLm,
                                        &mmu_thdo_opnconfig_cell_entry,
                                        OPN_SHARED_RESET_VALUE_CELLf);
                    if ((recalc_type == BCM_KT2_RECALC_SHARED_INT_DECREMENT) ||
                        (recalc_type == BCM_KT2_RECALC_SHARED_EXT_DECREMENT)) {
                        resume_limit = cur_limit - temp_val;
                    } else {
                        resume_limit = cur_limit + temp_val;
                    }
                    soc_mem_field32_set(unit, MMU_THDO_OPNCONFIG_CELLm,
                                        &mmu_thdo_opnconfig_cell_entry,
                                        OPN_SHARED_RESET_VALUE_CELLf, resume_limit);
                    SOC_IF_ERROR_RETURN(WRITE_MMU_THDO_OPNCONFIG_CELLm(unit,
                                        MEM_BLOCK_ANY,op_node + op_node_offset,
                                        &mmu_thdo_opnconfig_cell_entry));
                }
            }
        }
    }
    return SOC_E_NONE;
}

int soc_kt2_mmu_get_shared_size(int unit, int *shared_size, 
                                int *shared_size_external)
{
    uint32        rval = 0;

    if (shared_size) {
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLIr (unit, &rval));
        *shared_size = soc_reg_field_get(unit, OP_BUFFER_SHARED_LIMIT_CELLIr, rval,
                                        OP_BUFFER_SHARED_LIMIT_CELLIf);
    }
    if (shared_size_external) {
        SOC_IF_ERROR_RETURN(READ_OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r (
                            unit, &rval));
        *shared_size_external = soc_reg_field_get(unit, 
                                            OP_BUFFER_SHARED_LIMIT_CELLE_POOL0r, rval,
                                            OP_BUFFER_SHARED_LIMIT_CELLEf);
    }
    return 1;
}

void
soc_kt2_xport_type_update(int unit, soc_port_t port, int mode)
{
    soc_info_t          *si;
    soc_port_t          it_port;

    si = &SOC_INFO(unit);

    /* We need to lock the SOC structures until we finish the update */
    SOC_CONTROL_LOCK(unit);

    if (mode != SOC_ENCAP_IEEE) {
        SOC_PBMP_PORT_ADD(si->st.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->ether.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->xe.bitmap, port);
        /* special process for HG-Lite support to avoid wrong PBMP assignment.
         *
         * Note :
         *  the 'to_hg_port' for this special design must carry proper encap mode
         *  instead of TRUE/FALSE only.
         */
        if ((mode == SOC_ENCAP_HIGIG2) || (mode == SOC_ENCAP_HIGIG2_LITE)) {
            if (mode == SOC_ENCAP_HIGIG2_LITE) {
                SOC_PBMP_PORT_ADD(si->hl.bitmap, port);
            }
            SOC_PBMP_PORT_ADD(si->hg.bitmap, port);
        }
    } else {
        /* To IEEE mode */
        SOC_PBMP_PORT_ADD(si->ether.bitmap, port);
        SOC_PBMP_PORT_ADD(si->xe.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->st.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->hg.bitmap, port);
        SOC_PBMP_PORT_REMOVE(si->hl.bitmap, port);
    }
#define RECONFIGURE_PORT_TYPE_INFO(ptype) \
    si->ptype.num = 0; \
    si->ptype.min = si->ptype.max = -1; \
    PBMP_ITER(si->ptype.bitmap, it_port) { \
        si->ptype.port[si->ptype.num++] = it_port; \
        if (si->ptype.min < 0) { \
            si->ptype.min = it_port; \
        } \
        if (it_port > si->ptype.max) { \
            si->ptype.max = it_port; \
        } \
    }

    /* Recalculate port type data */
    RECONFIGURE_PORT_TYPE_INFO(ether);
    RECONFIGURE_PORT_TYPE_INFO(st);
    RECONFIGURE_PORT_TYPE_INFO(hg);
    RECONFIGURE_PORT_TYPE_INFO(xe);
#undef  RECONFIGURE_PORT_TYPE_INFO

    soc_dport_map_update(unit);

    /* Release SOC structures lock */
    SOC_CONTROL_UNLOCK(unit);
}

int soc_kt2_get_max_buffer_size(int unit, int external, int value)
{
    int cval;
#ifdef BCM_SABER2_SUPPORT
    if (SOC_IS_SABER2(unit)) {
#ifdef BCM_METROLITE_SUPPORT
        if (SOC_IS_METROLITE(unit)) {
            return soc_ml_get_max_buffer_size(unit, value);
        } else
#endif
        {
            return soc_sb2_get_max_buffer_size(unit, external, value);
        }
    } else
#endif
    {
        cval= (external ?
        _soc_kt2_mmu_intermediate_results.general_info.max_ext_cell_buff_size:
        _soc_kt2_mmu_intermediate_results.general_info.max_int_cell_buff_size);
        if ((cval <= 0) || (cval >= value)) {
             return value;
        } else {
            return cval;
        }
    }
}
#endif /* BCM_KATANA2_SUPPORT */
