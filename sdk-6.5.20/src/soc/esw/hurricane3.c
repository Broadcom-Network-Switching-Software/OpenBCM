/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * File:        hurricane3.c
 * Purpose:
 * Requires:
 */


#include <sal/core/boot.h>

#include <soc/firebolt.h>
#include <soc/bradley.h>
#include <soc/greyhound.h>
#include <soc/hurricane3.h>
#include <soc/wolfhound2.h>
#include <soc/drv.h>
#include <soc/mem.h>
#include <soc/hash.h>
#include <soc/lpm.h>
#include <soc/error.h>
#include <soc/debug.h>
#include <soc/er_tcam.h>
#include <soc/memtune.h>
#include <soc/devids.h>
#include <soc/defs.h>
#include <soc/l2x.h>
#include <soc/mspi.h>

#include <shared/util.h>
#include <shared/l3.h>
#include <shared/bsl.h>

#include <soc/esw/portctrl.h>

#ifdef BCM_HURRICANE3_SUPPORT

#define SOC_MAX_PHY_PORTS            42

/* Port config related : p2l, max_speed and TDM */

/* 56160 : option 1
 * 24P 1G + 4P (1G/10G) + 2P (1G/10G) PHY
 */
static const int p2l_mapping_56160_op1[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, 31,
    -1, -1
};
static const int port_speed_max_56160_op1[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 110, 110,
    -1,  -1
};

/* 56160 : option 1A
 * 24P 1G + 4P (1G/10G) + 2P (1G/10G) PHY
 */

static const int p2l_mapping_56160_op1a[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, 29,
    30, 31
};
static const int port_speed_max_56160_op1a[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, -1, -1,  110,  110,
   110, 110
};

/* 56160 : option 2
 * 24P 1G + 2P (1G/10G) + 2P (1G/10G) + 2P 25G
 */
static const int p2l_mapping_56160_op2[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, -1,
    31, -1
};
static const int port_speed_max_56160_op2[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 250,  -1,
   250, -1
};

/* 56160 : option 2A
 * 24P 1G + 2P (1G/10G) + 2P (1G/10G) + 2P 25G
 */
static const int p2l_mapping_56160_op2a[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, 29,
    30, 31
};
static const int port_speed_max_56160_op2a[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
   110, 110
};

/* 56160 : option 3
 * 24P 1G +4P 1G/10G+1P XAUI
 */
static const int p2l_mapping_56160_op3[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, -1,
    -1, -1
};
static const int port_speed_max_56160_op3[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 100,  -1,
    -1,  -1
};

/* 56160 : option 4
 * 24P 1G +2P XAUI
 */
static const int p2l_mapping_56160_op4[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27, -1,
    -1, -1
};
static const int port_speed_max_56160_op4[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 100,  -1,  -1,  -1, 100,  -1,
    -1,  -1
};


/* 56160 : option 5
 * 24P 1G + 4P 1G/10G + 2P 20G
 */
static const int p2l_mapping_56160_op5[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, -1, 29, 30,
    31, -1
};
static const int port_speed_max_56160_op5[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 210,  -1, 110, 110,
   210, -1
};

/* 56160 : option 6
 * 24P 1G +2P 1G/10G + 2P 20G + 2P 25G
 */
static const int p2l_mapping_56160_op6[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, -1, 29, -1,
    30, -1
};
static const int port_speed_max_56160_op6[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 210,  -1, 250,  -1,
   250, -1
};

/* 56160 : option 6A
 * 24P 1G +2P 1G/10G + 2P 20G + 2P 25G
 */
static const int p2l_mapping_56160_op6a[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, 29,
    30, -1
};
static const int port_speed_max_56160_op6a[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
   210, -1
};


/* 56160 : option 7
 * 24P 1G +2P 40G
 */
static const int p2l_mapping_56160_op7[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27,  -1,
    -1, -1
};
static const int port_speed_max_56160_op7[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 420,  -1,  -1,  -1, 420,  -1,
    -1,  -1
};

/* 56160 : option 8
 * 24P 1G +1P 40G  + 2P 25G
 */
static const int p2l_mapping_56160_op8[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    -1, -1
};
static const int port_speed_max_56160_op8[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 420,  -1,
    -1,  -1
};


/* 56160 : option 8A
 * 24P 1G +1P 40G  + 2P 25G
 */
static const int p2l_mapping_56160_op8a[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27, -1,
    28, -1
};
static const int port_speed_max_56160_op8a[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 420,  -1,  -1,  -1, 250,  -1,
   250,  -1
};

/* 56160 : option 9
 * 24P 1G + 2P 20G  + 2P 25G
 */
static const int p2l_mapping_56160_op9[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56160_op9[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 210,  -1, 210,  -1, 250,  -1,
   250,  -1
};

/* 56160 : option 9A
 * 24P 1G + 2P 20G  + 2P 25G
 */
static const int p2l_mapping_56160_op9a[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56160_op9a[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 210,  -1,
   210,  -1
};

/* 56160 : option 1 gphy bypass
 * 24P 1G +4P 1G/10G +2P 1G/10G
 */
static const int p2l_mapping_56160_op1_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, 31,
    -1, -1
};
static const int port_speed_max_56160_op1_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 110, 110,
    -1,  -1
};

/* 56160 : option 1A gphy bypass
 * 24P 1G +4P 1G/10G +2P 1G/10G
 */
static const int p2l_mapping_56160_op1a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, 29,
    30, 31
};
static const int port_speed_max_56160_op1a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110,  -1,  -1, 110, 110,
   110, 110
};

/* 56160 : option 2 gphy bypass
 * 24P 1G + 2P 1G/10G + 2P 1G/10G + 2P 25G
 */
static const int p2l_mapping_56160_op2_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, -1,
    31, -1
};
static const int port_speed_max_56160_op2_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 250,  -1,
   250,  -1
};

/* 56160 : option 2A gphy bypass
 * 24P 1G + 2P 1G/10G + 2P 1G/10G + 2P 25G
 */
static const int p2l_mapping_56160_op2a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, 29,
    30, 31
};
static const int port_speed_max_56160_op2a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
   110, 110
};

/* 56160 : option 3 gphy bypass
 * 24P 1G +4P 1G/10G+1P XAUI
 */
static const int p2l_mapping_56160_op3_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, -1,
    -1, -1
};
static const int port_speed_max_56160_op3_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 100,  -1,
    -1,  -1
};

/* 56160 : option 4 gphy bypass
 * 24P 1G +2P XAUI
 */
static const int p2l_mapping_56160_op4_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27, -1,
    -1, -1
};
static const int port_speed_max_56160_op4_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 100,  -1,  -1,  -1, 100,  -1,
    -1,  -1
};


/* 56160 : option 5 gphy bypass
 *  24P 1G + 4P 1G/10G + 2P 20G
 */
static const int p2l_mapping_56160_op5_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, -1, 29, 30,
    31, -1
};
static const int port_speed_max_56160_op5_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 210,  -1, 110, 110,
   210,  -1
};

/* 56160 : option 6 gphy bypass
 *  24P 1G +2P 1G/10G + 1P 20G + 2P 25G
 */
static const int p2l_mapping_56160_op6_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, -1, 29, -1,
    30, -1
};
static const int port_speed_max_56160_op6_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 210,  -1, 250,  -1,
   250,  -1
};

/* 56160 : option 6A gphy bypass
 *  24P 1G +2P 1G/10G + 1P 20G + 2P 25G
 */
static const int p2l_mapping_56160_op6a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, 29,
    30, -1
};
static const int port_speed_max_56160_op6a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
   210,  -1
};

/* 56160 : option 7 gphy bypass
 *  24P 1G +2P 40G
 */
static const int p2l_mapping_56160_op7_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27, -1,
    -1, -1
};
static const int port_speed_max_56160_op7_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 420,  -1,  -1,  -1, 420,  -1,
    -1,  -1
};

/* 56160 : option 8 gphy bypass
 *  24P 1G +1P 40G + 2P 25G
 */
static const int p2l_mapping_56160_op8_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    -1, -1
};
static const int port_speed_max_56160_op8_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 420,  -1,
    -1,  -1
};

/* 56160 : option 8A gphy bypass
 *  24P 1G +1P 40G + 2P 25G
 */
static const int p2l_mapping_56160_op8a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27, -1,
    28, -1
};
static const int port_speed_max_56160_op8a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 420,  -1,  -1,  -1, 250,  -1,
   250,  -1
};

/* 56160 : option 9 gphy bypass
 *  24P 1G + 1P 20G + 2P 25G
 */
static const int p2l_mapping_56160_op9_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56160_op9_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 210,  -1, 210,  -1, 250,  -1,
   250,  -1
};

/* 56160 : option 9a gphy bypass
 *  24P 1G + 1P 20G + 2P 25G
 */
static const int p2l_mapping_56160_op9a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56160_op9a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 210,  -1,
   210,  -1
};

/* 56162 : option 1
 *  24P 1G +4P 1G
 */
static const int p2l_mapping_56162_op1[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, -1, -1,
    -1, -1
};
static const int port_speed_max_56162_op1[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1
};

/* 56162 : option 1A
 *  24P 1G +4P 1G
 */
static const int p2l_mapping_56162_op1a[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, -1, -1, -1, -1, 26, 27,
    28, 29
};
static const int port_speed_max_56162_op1a[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  10,  10,
    10,  10
};

/* 56162 : option 2
 *  24P 1G + 2P 1G + 2P 13G
 */
static const int p2l_mapping_56162_op2[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56162_op2[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  -1,  -1, 130,  -1,
   130,  -1
};

/* 56162 : option 1 gphy bypass
 *  24P 1G +4P 1G
 */
static const int p2l_mapping_56162_op1_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, -1, -1,
    -1, -1
};
static const int port_speed_max_56162_op1_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1
};

/* 56162 : option 1A gphy bypass
 *  24P 1G +4P 1G
 */
static const int p2l_mapping_56162_op1a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, -1, -1, -1, -1, 26, 27,
    28, 29
};
static const int port_speed_max_56162_op1a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  10,  10,
    10,  10
};

/* 56162 : option 2 gphy bypass
 *  24P 1G + 2P 1G + 2P 13G
 */
static const int p2l_mapping_56162_op2_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56162_op2_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  -1,  -1, 130,  -1,
   130,  -1
};

/* Hurricane 3 Lite */

/* 56163 : option 1
 *  8P 1G (PHY) + 2P 1G/2.5G/5G/10G
 */
static const int p2l_mapping_56163_op1[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9,  -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, -1, -1, -1, 11, -1,
    -1, -1
};
static const int port_speed_max_56163_op1[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1, 110,  -1,  -1,  -1, 110,  -1,
    -1,  -1
};

/* 56163 : option 2
 *  8P 1G (PHY) + 4P 1G/2.5G OR 1P XAUI + 4P 1G/2.5G OR 1P XAUI
 */
static const int p2l_mapping_56163_op2[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9,  -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17
};
static const int port_speed_max_56163_op2[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  25,  25,  25,  25,  25,  25,
    25,  25
};

/* 56163 : option 1 gphy bypass
 *  8P 1G (PHY) + 2P 1G/2.5G/5G/10G
 */
static const int p2l_mapping_56163_op1_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  6,  7,  8,  9, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, -1, -1, -1, 11, -1,
    -1, -1
};
static const int port_speed_max_56163_op1_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1, 110,  -1,  -1,  -1, 110,  -1,
    -1,  -1
};

/* 56163 : option 2 gphy bypass
 *  8P 1G (PHY) + 4P 1G/2.5G OR 1P XAUI + 4P 1G/2.5G OR 1P XAUI
 */
static const int p2l_mapping_56163_op2_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  6,  7,  8,  9, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17
};
static const int port_speed_max_56163_op2_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  25,  25,  25,  25,  25,  25,
    25,  25
};


/* 56164
 * 24P 1G  (PHY) + 4P 1G
 */
/* same as 56162 option 1 */


/* Buckhound */

/* 53440 : option 1
 * 16P 1G + 8P 1G/2.5G + 4P 10G + 2P 20G
 */
/* same as 56160 option 5 */


/* 53440 : option 2
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 20G (stack) + 2P 25G
 */
/* same as 56160 option 6A */

/* 53440 : option 2A
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 20G (stack) + 2P 25G
 */
/* same as 56160 option 6 gphy bypass */

/* 53440 : option 3
 * 16P 1G + 8P 1G/2.5G + 4P 10G (Uplink) + 2P 10G (stack)
 */
static const int p2l_mapping_53440_op3[] = {
     0, -1,  2,  3,  4,  5, -1, -1,
    -1, -1,  6,  7,  8,  9, 10, 11,
    12, 13, 14, 15, 16, 17, -1, -1,
    -1, -1, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, -1, 29, 30,
    31, -1
};
static const int port_speed_max_53440_op3[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110,  -1, 110, 110,
   110, -1
};

/* 53440 : option 4
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 10G (stack) + 2P 25G
 */
/* same as 56160 option 2A */
static const int port_speed_max_53440_op4[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
   110,  -1
};

/* 53440 : option 4A
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 10G (stack) + 2P 25G
 */
/* same as 56160 option 2 */
static const int port_speed_max_53440_op4a[] = {
    -1,  -1,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110,  -1, 250,  -1,
   250, -1
};

/* 53440 : option 5
 * 24P 1G + 4P 10G + 1P XAUI (Phy)
 */
/* same as 56160 option 3 */

/* 53440 : option 6
 * 24P 1G + 2P XAUI (Phy)
 */
/* same as 56160 option 4 */

/* 53440 : option 7
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G + 4P 1G/10G (PHY)
 */
/* same as 56160 option 1 */

/* 53440 : option 7A
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G + 4P 1G/10G (PHY)
 */
/* same as 56160 option 1A */

/* 53440 : option 8
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G + 2P 1G/10G + 2P 25G (PHY)
 */
/* same as 56160 option 2 */

/* 53440 : option 8A
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G  2P 1G/10G + 2P 25G (PHY)
 */
/* same as 56160 option 2A */

/* 53440 : option 1 gphy bypass
 * 16P 1G + 8P 1G/2.5G + 4P 10G + 2P 20G (Phy)
 */
/* same as 56160 option 5 gphy bypass */


/* 53440 : option 2 gphy bypass
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 20G (stack) + 2P 25G (Phy)
 */
/* same as 56160 option 6A gphy bypass */


/* 53440 : option 2A gphy bypass
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 20G (stack) + 2P 25G (Phy)
 */
/* same as 56160 option 6 gphy bypass */


/* 53440 : option 3 gphy bypass
 * 16P 1G + 8P 1G/2.5G + 4P 10G (Uplink) + 2P 10G (stack)
 */
static const int p2l_mapping_53440_op3_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, -1, 29, 30,
    31, -1
};
static const int port_speed_max_53440_op3_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110,  -1, 110, 110,
   110, -1
};


/* 53440 : option 4 gphy bypass
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 10G (stack) + 2P 25G (Phy)
 */
/* same as 56160 option 2A gphy bypass */
static const int port_speed_max_53440_op4_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
   110,  -1
};


/* 53440 : option 4A gphy bypass
 * 16P 1G + 8P 1G/2.5G + 2P 10G (Uplink) + 1P 20G (stack) + 2P 25G (Phy)
 */
/* same as 56160 option 2 gphy bypass */
static const int port_speed_max_53440_op4a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110,  -1, 250,  -1,
   250,  -1
};

/* 53440 : option 5 gphy bypass
 * 24P 1G + 4P 10G + 1P XAUI (Phy)
 */
/* same as 56160 option 3 gphy bypass */

/* 53440 : option 6 gphy bypass
 * 24P 1G + 2P XAUI (Phy)
 */
/* same as 56160 option 4 gphy bypass */

/* 53440 : option 7 gphy bypass
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G + 4P 1G/10G (PHY)
 */
/* same as 56160 option 1 gphy bypass */

/* 53440 : option 7A gphy bypass
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G + 4P 1G/10G (PHY)
 */
/* same as 56160 option 1A  gphy bypass*/

/* 53440 : option 8 gphy bypass
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G + 2P 1G/10G + 2P 25G (PHY)
 */
/* same as 56160 option 2  gphy bypass*/

/* 53440 : option 8A gphy bypass
 * 16P 1G +  8x1G/2.5G + 2P 1G/10G  2P 1G/10G + 2P 25G (PHY)
 */
/* same as 56160 option 2A  gphy bypass*/

/* 53442 : option 1
 * 24P 1G +4P 1G  (PHY)
 */
/* same as 56162 option 1 */


/* 53442 : option 1A
 * 24P 1G +4P 1G  (PHY)
 */
/* same as 56162 option 1A */


/* 53442 : option 2
 * 24P 1G + 2P 1G + 2P 13G (PHY)
 */
/* same as 56162 option 2 */


/* 53442 : option 1 gphy bypass
 * 24P 1G +4P 1G  (PHY)
 */
/* same as 56162 option 1 gphy bypass */


/* 53442 : option 1A gphy bypass
 * 24P 1G +4P 1G  (PHY)
 */
/* same as 56162 option 1A gphy bypass */


/* 53442 : option 2 gphy bypass
 * 24P 1G + 2P 1G + 2P 13G (PHY)
 */
/* same as 56162 option 2 gphy bypass */


/* 53443 : option 1
 * 8P 1G  (PHY) + 2P 1G/2.5G/5G/10G
 */
/* same as 56163 option 1 */


/* 53443 : option 2
 *  8P 1G  (PHY) + 4P 1G/2.5G OR 1P XAUI + 4P 1G/2.5G OR 1P XAUI
 */
/* same as 56163 option 2 */


/* 53443 : option 1 gphy bypass
 * 8P 1G  (PHY) + 2P 1G/2.5G/5G/10G
 */
/* same as 56163 option 1 gphy bypass */


/* 53443 : option 2 gphy bypass
 *  8P 1G  (PHY) + 4P 1G/2.5G OR 1P XAUI + 4P 1G/2.5G OR 1P XAUI
 */
/* same as 56163 option 2 gphy bypass */



/* Hurricane 3 Lite */

/* 56166 : option 1
 * 24P 1G +4P 1G/10G +2P 1G/10G
 */
static const int p2l_mapping_56166_op1[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, 31,
    -1, -1
};
static const int port_speed_max_56166_op1[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 110, 110,
    -1,  -1
};

/* 56166 : option 1A
 * 24P 1G +2P 1G/10G +4P 1G/10G
 */
static const int p2l_mapping_56166_op1a[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, 29,
    30, 31
};
static const int port_speed_max_56166_op1a[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110,  -1,  -1, 110, 110,
   110, 110
};

/* 56166 : option 2
 * 24P 1G + 2P 1G/10G + 2P 25G
 */
static const int p2l_mapping_56166_op2[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56166_op2[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110,  -1,  -1, 250,  -1,
   250,  -1
};

/* 56166 : option 2A
 * 24P 1G + 2P 25G + 2P 1G/10G
 */
static const int p2l_mapping_56166_op2a[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, 29,
    -1, -1
};
static const int port_speed_max_56166_op2a[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
    -1,  -1
};

/* 56166 : option 3
 * 24P 1G +4P 1G/10G+1P XAUI
 */
static const int p2l_mapping_56166_op3[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, -1,
    -1, -1
};
static const int port_speed_max_56166_op3[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 100,  -1,
    -1,  -1
};

/* 56166 : option 4
 * 24P 1G +2P XAUI
 */
static const int p2l_mapping_56166_op4[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27, -1,
    -1, -1
};
static const int port_speed_max_56166_op4[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 100,  -1,  -1,  -1, 100,  -1,
    -1,  -1
};

/* 56166 : option 5
 * 24P 1G + 2P 1G/10G + 2P 20G
 */
static const int p2l_mapping_56166_op5[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56166_op5[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110,  -1, 210,  -1, 110,  -1,
   210,  -1
};

/* 56166 : option 6
 * 24P 1G +1P 1G/10G + 1P 20G + 2P 25G
 */
static const int p2l_mapping_56166_op6[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1,  2,  3,  4,  5,  6,  7,
     8,  9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56166_op6[] = {
    -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110,  -1, 210,  -1, 250,  -1,
   250,  -1
};

/* 56166 : option 1 gphy bypass
 * 24P 1G +4P 1G/10G +2P 1G/10G
 */
static const int p2l_mapping_56166_op1_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, 31,
    -1, -1
};
static const int port_speed_max_56166_op1_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 110, 110,
    -1,  -1
};

/* 56166 : option 1A gphy bypass
 * 24P 1G +2P 1G/10G +4P 1G/10G
 */
static const int p2l_mapping_56166_op1a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, 29,
    30, 31
};
static const int port_speed_max_56166_op1a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110,  -1,  -1, 110, 110,
   110, 110
};

/* 56166 : option 2 gphy bypass
 * 24P 1G + 2P 1G/10G + 2P 25G
 */
static const int p2l_mapping_56166_op2_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, -1, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56166_op2_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110,  -1,  -1, 250,  -1,
   250,  -1
};

/* 56166 : option 2A gphy bypass
 * 24P 1G + 2P 25G + 2P 1G/10G
 */
static const int p2l_mapping_56166_op2a_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, 29,
    -1, -1
};
static const int port_speed_max_56166_op2a_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 250,  -1, 250,  -1, 110, 110,
    -1,  -1
};

/* 56166 : option 3 gphy bypass
 * 24P 1G +4P 1G/10G+1P XAUI
 */
static const int p2l_mapping_56166_op3_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27, 28, 29, 30, -1,
    -1, -1
};
static const int port_speed_max_56166_op3_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110, 110, 110, 110, 100,  -1,
    -1,  -1
};

/* 56166 : option 4 gphy bypass
 * 24P 1G +2P XAUI
 */
static const int p2l_mapping_56166_op4_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, -1, -1, 27, -1,
    -1, -1
};
static const int port_speed_max_56166_op4_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 100,  -1,  -1,  -1, 100,  -1,
    -1,  -1
};

/* 56166 : option 5 gphy bypass
 * 24P 1G + 2P 1G/10G + 2P 20G
 */
static const int p2l_mapping_56166_op5_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56166_op5_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110,  -1, 210,  -1, 110,  -1,
   210,  -1
};

/* 56166 : option 6 gphy bypass
 * 24P 1G +1P 1G/10G + 1P 20G + 2P 25G
 */
static const int p2l_mapping_56166_op6_gphy_bypass[] = {
     0, -1,  2,  3,  4,  5,  6,  7,
     8,  9, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, -1, 27, -1, 28, -1,
    29, -1
};
static const int port_speed_max_56166_op6_gphy_bypass[] = {
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  -1,  -1,  -1,  -1,  -1,  -1,
    -1,  -1,  10,  10,  10,  10,  10,  10,
    10,  10,  10,  10,  10,  10,  10,  10,
    10,  10, 110,  -1, 210,  -1, 250,  -1,
   250,  -1
};



/* Foxhound2 */

/* 53434 :
 * 24P 1G  (PHY)
 */
/* Phyiscal to logical mapping as 56162 option 1 */

static const int port_speed_max_53434[] = {
     0, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, -1, -1, -1, -1, -1, -1,
    -1, -1
};


/* Template TDM */
/* Should be provided by design team */
uint32 hr3_tdm_template_56160_op1[50] = {
        38, 36, 34, 12,
        39, 37, 35, 13,
         2, 18, 26, 14,
        38, 36, 34, 15,
        39, 37, 35, 16,
         3, 19, 27, 17,
        38, 36, 34, 28,
        39, 37, 35, 29,
         4, 20, 10, 30,
        38, 36, 34, 31,
        39, 37, 35, 32,
         5, 21, 11, 33,
         0, 63
    };

uint32 hr3_tdm_template_56160_op1a[50] = {
        38, 40, 34, 12,
        39, 41, 35, 13,
         2, 18, 26, 14,
        38, 40, 34, 15,
        39, 41, 35, 16,
         3, 19, 27, 17,
        38, 40, 34, 28,
        39, 41, 35, 29,
         4, 20, 10, 30,
        38, 40, 34, 31,
        39, 41, 35, 32,
         5, 21, 11, 33,
         0, 63
    };

uint32 hr3_tdm_template_56160_op2[64] = {
       38, 40, 34, 10,
       38, 40, 35, 11,
        2, 18, 36, 12,
       38, 40, 37, 13,
       38, 40, 34, 14,
        3, 19, 35, 15,
       38, 40, 36, 16,
       38, 40, 37, 17,
        4, 20, 34, 26,
       38, 40, 35, 27,
       38, 40, 36, 28,
        5, 21, 37, 29,
       38, 40, 34, 30,
        0, 63, 35, 31,
       38, 40, 36, 32,
       63, 63, 37, 33
   };

uint32 hr3_tdm_template_56160_op2a[64] = {
       34, 36, 38, 10,
       34, 36, 39, 11,
        2, 18, 40, 12,
       34, 36, 41, 13,
       34, 36, 38, 14,
        3, 19, 39, 15,
       34, 36, 40, 16,
       34, 36, 41, 17,
        4, 20, 38, 26,
       34, 36, 39, 27,
       34, 36, 40, 28,
        5, 21, 41, 29,
       34, 36, 38, 30,
        0, 63, 39, 31,
       34, 36, 40, 32,
       63, 63, 41, 33
   };


uint32 hr3_tdm_template_56160_op5[66] = {
         36, 34, 38,  2,
         40, 35, 39,  3,
         36, 10, 26,  4,
         40, 11, 27,  5,
         36, 34, 38, 18,
         40, 35, 39, 19,
         36, 12, 28, 20,
         40, 13, 29, 21,
         36, 34, 38,  2,
         40, 35, 39,  3,
         36, 14, 30,  4,
         40, 15, 31,  5,
         36, 34, 38, 18,
         40, 35, 39, 19,
         36, 16, 32, 20,
         40, 17, 33, 21,
          0, 63
    };

uint32 hr3_tdm_template_56160_op6[64] = {
       38, 40, 34, 10,
       38, 40, 35, 11,
        2, 18, 36, 12,
       38, 40, 36, 13,
       38, 40, 34, 14,
        3, 19, 35, 15,
       38, 40, 36, 16,
       38, 40, 36, 17,
        4, 20, 34, 26,
       38, 40, 35, 27,
       38, 40, 36, 28,
        5, 21, 36, 29,
       38, 40, 34, 30,
        0, 63, 35, 31,
       38, 40, 36, 32,
       63, 63, 36, 33
   };

uint32 hr3_tdm_template_56160_op6a[64] = {
      34, 36, 38, 10,
      34, 36, 39, 11,
       2, 18, 40, 12,
      34, 36, 40, 13,
      34, 36, 38, 14,
       3, 19, 39, 15,
      34, 36, 40, 16,
      34, 36, 40, 17,
       4, 20, 38, 26,
      34, 36, 39, 27,
      34, 36, 40, 28,
       5, 21, 40, 29,
      34, 36, 38, 30,
       0, 63, 39, 31,
      34, 36, 40, 32,
      63, 63, 40, 33
  };


uint32 hr3_tdm_template_56160_op7[68] = {
         34, 38,  2, 18,
         34, 38, 10, 26,
         34, 38,  3, 19,
         34, 38, 11, 27,
         34, 38,  4, 20,
         34, 38, 12, 28,
         34, 38,  5, 21,
         34, 38, 13, 29,
         34, 38,  2, 18,
         34, 38, 14, 30,
         34, 38,  3, 19,
         34, 38, 15, 31,
         34, 38,  4, 20,
         34, 38, 16, 32,
         34, 38,  5, 21,
         34, 38, 17, 33,
         34, 38,  0, 63
    };

uint32 hr3_tdm_template_56160_op8[80] = {
         38, 34, 36, 18,
         38, 34, 36, 26,
         38, 34, 36, 19,
         38, 34,  2, 27,
         38, 36, 10, 20,
         38, 34,  3, 28,
         38, 36, 11, 21,
         38, 34,  4, 29,
         38, 36, 12, 18,
         38, 34,  5, 30,
         38, 36, 13, 19,
         38, 34, 36,  2,
         38, 34, 36, 14,
         38, 34, 36, 31,
         38, 34,  3, 20,
         38, 36, 15, 32,
         38, 34,  4, 21,
         38, 36, 16, 33,
         38, 34,  5,  0,
         38, 36, 17, 63
    };

uint32 hr3_tdm_template_56160_op8a[80] = {
         34, 38, 40, 18,
         34, 38, 40, 26,
         34, 38, 40, 19,
         34, 38,  2, 27,
         34, 40, 10, 20,
         34, 38,  3, 28,
         34, 40, 11, 21,
         34, 38,  4, 29,
         34, 40, 12, 18,
         34, 38,  5, 30,
         34, 40, 13, 19,
         34, 38, 40,  2,
         34, 38, 40, 14,
         34, 38, 40, 31,
         34, 38,  3, 20,
         34, 40, 15, 32,
         34, 38,  4, 21,
         34, 40, 16, 33,
         34, 38,  5,  0,
         34, 40, 17, 63
    };

uint32 hr3_tdm_template_56160_op9[64] = {
         38, 40, 34, 10,
         38, 40, 34, 11,
          2, 18, 36, 12,
         38, 40, 36, 13,
         38, 40, 34, 14,
          3, 19, 34, 15,
         38, 40, 36, 16,
         38, 40, 36, 17,
          4, 20, 34, 26,
         38, 40, 34, 27,
         38, 40, 36, 28,
          5, 21, 36, 29,
         38, 40, 34, 30,
          0, 63, 34, 31,
         38, 40, 36, 32,
         63, 63, 36, 33,
    };

uint32 hr3_tdm_template_56160_op9a[64] = {
         34, 36, 38, 10,
         34, 36, 38, 11,
          2, 18, 40, 12,
         34, 36, 40, 13,
         34, 36, 38, 14,
          3, 19, 38, 15,
         34, 36, 40, 16,
         34, 36, 40, 17,
          4, 20, 38, 26,
         34, 36, 38, 27,
         34, 36, 40, 28,
          5, 21, 40, 29,
         34, 36, 38, 30,
          0, 63, 38, 31,
         34, 36, 40, 32,
         63, 63, 40, 33,
    };

/* 56160 GPHY BYPASS TDMs */

uint32 hr3_tdm_template_56160_op1_gphy_bypass[50] = {
        38, 36,  7, 22,
        39, 37, 34, 26,
         2, 18, 35, 27,
        38, 36,  8, 23,
        39, 37, 34, 28,
         3, 19, 35, 29,
        38, 36,  9, 24,
        39, 37, 34, 30,
         4, 20, 35, 31,
        38, 36,  6, 25,
        39, 37, 34, 32,
         5, 21, 35, 33,
         0, 63
    };

uint32 hr3_tdm_template_56160_op1a_gphy_bypass[50] = {
        38, 40,  7, 22,
        39, 41, 34, 26,
         2, 18, 35, 27,
        38, 40,  8, 23,
        39, 41, 34, 28,
         3, 19, 35, 29,
        38, 40,  9, 24,
        39, 41, 34, 30,
         4, 20, 35, 31,
        38, 40,  6, 25,
        39, 41, 34, 32,
         5, 21, 35, 33,
         0, 63
    };

uint32 hr3_tdm_template_56160_op2_gphy_bypass[64] = {
        38, 40, 34,  6,
        38, 40, 35,  7,
         0, 18, 36,  8,
        38, 40, 37,  9,
        38, 40, 34, 26,
         3, 19, 35, 27,
        38, 40, 36, 28,
        38, 40, 37, 29,
         4, 20, 34, 30,
        38, 40, 35, 31,
        38, 40, 36, 32,
         5, 21, 37, 33,
        38, 40, 34, 22,
         2, 63, 35, 23,
        38, 40, 36, 24,
        63, 63, 37, 25
   };

uint32 hr3_tdm_template_56160_op2a_gphy_bypass[64] = {
        34, 36, 38,  6,
        34, 36, 39,  7,
         0, 18, 40,  8,
        34, 36, 41,  9,
        34, 36, 38, 26,
         3, 19, 39, 27,
        34, 36, 40, 28,
        34, 36, 41, 29,
         4, 20, 38, 30,
        34, 36, 39, 31,
        34, 36, 40, 32,
         5, 21, 41, 33,
        34, 36, 38, 22,
         2, 63, 39, 23,
        34, 36, 40, 24,
        63, 63, 41, 25
    };


uint32 hr3_tdm_template_56160_op5_gphy_bypass[66] = {
        36, 34, 38,  2,
        40, 35, 39,  3,
        36, 22, 26,  4,
        40, 23, 27,  5,
        36, 34, 38, 18,
        40, 35, 39, 19,
        36,  8, 28, 20,
        40,  9, 29, 21,
        36, 34, 38,  2,
        40, 35, 39,  3,
        36, 24, 30,  4,
        40, 25, 31,  5,
        36, 34, 38, 18,
        40, 35, 39, 19,
        36,  6, 32, 20,
        40,  7, 33, 21,
         0, 63
    };

uint32 hr3_tdm_template_56160_op6_gphy_bypass[64] = {
        38, 40, 34,  6,
        38, 40, 35,  7,
         0, 18, 36,  8,
        38, 40, 36,  9,
        38, 40, 34, 26,
         3, 19, 35, 27,
        38, 40, 36, 28,
        38, 40, 36, 29,
         4, 20, 34, 30,
        38, 40, 35, 31,
        38, 40, 36, 32,
         5, 21, 36, 33,
        38, 40, 34, 22,
         2, 63, 35, 23,
        38, 40, 36, 24,
        63, 63, 36, 25
    };

uint32 hr3_tdm_template_56160_op6a_gphy_bypass[64] = {
        34, 36, 38,  6,
        34, 36, 39,  7,
         0, 18, 40,  8,
        34, 36, 40,  9,
        34, 36, 38, 26,
         3, 19, 39, 27,
        34, 36, 40, 28,
        34, 36, 40, 29,
         4, 20, 38, 30,
        34, 36, 39, 31,
        34, 36, 40, 32,
         5, 21, 40, 33,
        34, 36, 38, 22,
         2, 63, 39, 23,
        34, 36, 40, 24,
        63, 63, 40, 25
    };

uint32 hr3_tdm_template_56160_op7_gphy_bypass[68] = {
        34, 38,  2, 18,
        34, 38,  6, 26,
        34, 38,  3, 19,
        34, 38,  7, 27,
        34, 38,  4, 20,
        34, 38,  8, 28,
        34, 38,  5, 21,
        34, 38,  9, 29,
        34, 38,  2, 18,
        34, 38, 30, 22,
        34, 38,  3, 19,
        34, 38, 31, 23,
        34, 38,  4, 20,
        34, 38, 32, 24,
        34, 38,  5, 21,
        34, 38, 33, 25,
        34, 38,  0, 63
    };


uint32 hr3_tdm_template_56160_op8_gphy_bypass[80] = {
        38, 34, 36, 18,
        38, 34, 36, 26,
        38, 34, 36, 19,
        38, 34,  2, 27,
        38, 36,  6, 20,
        38, 34,  3, 28,
        38, 36,  7, 21,
        38, 34,  4, 29,
        38, 36,  8, 18,
        38, 34,  5, 30,
        38, 36,  9, 19,
        38, 34, 36,  2,
        38, 34, 36, 22,
        38, 34, 36, 31,
        38, 34,  3, 20,
        38, 36, 32, 23,
        38, 34,  4, 21,
        38, 36, 33, 24,
        38, 34,  5,  0,
        38, 36, 63, 25
    };

uint32 hr3_tdm_template_56160_op8a_gphy_bypass[80] = {
        34, 38, 40, 18,
        34, 38, 40, 26,
        34, 38, 40, 19,
        34, 38,  2, 27,
        34, 40,  6, 20,
        34, 38,  3, 28,
        34, 40,  7, 21,
        34, 38,  4, 29,
        34, 40,  8, 18,
        34, 38,  5, 30,
        34, 40,  9, 19,
        34, 38, 40,  2,
        34, 38, 40, 22,
        34, 38, 40, 31,
        34, 38,  3, 20,
        34, 40, 32, 23,
        34, 38,  4, 21,
        34, 40, 33, 24,
        34, 38,  5,  0,
        34, 40, 63, 25
    };

uint32 hr3_tdm_template_56160_op9_gphy_bypass[64] = {
         38, 40, 34,  6,
         38, 40, 34,  7,
          0, 18, 36,  8,
         38, 40, 36,  9,
         38, 40, 34, 26,
          3, 19, 34, 27,
         38, 40, 36, 28,
         38, 40, 36, 29,
          4, 20, 34, 30,
         38, 40, 34, 31,
         38, 40, 36, 32,
          5, 21, 36, 33,
         38, 40, 34, 22,
          2, 63, 34, 23,
         38, 40, 36, 24,
         63, 63, 36, 25,
    };

uint32 hr3_tdm_template_56160_op9a_gphy_bypass[64] = {
         34, 36, 38,  6,
         34, 36, 38,  7,
          0, 18, 40,  8,
         34, 36, 40,  9,
         34, 36, 38, 26,
          3, 19, 38, 27,
         34, 36, 40, 28,
         34, 36, 40, 29,
          4, 20, 38, 30,
         34, 36, 38, 31,
         34, 36, 40, 32,
          5, 21, 40, 33,
         34, 36, 38, 22,
          2, 63, 38, 23,
         34, 36, 40, 24,
         63, 63, 40, 25,
    };

/* 56162 TDMs */

uint32 hr3_tdm_template_56162_op1[34] = {
        10, 18, 26, 34,
        11, 19, 27, 35,
        12, 20, 28, 36,
        13, 21, 29, 37,
        14, 22, 30, 34,
        15, 23, 31, 35,
        16, 24, 32, 36,
        17, 25, 33, 37,
         0, 63
    };

uint32 hr3_tdm_template_56162_op1a[34] = {
        10, 18, 26, 38,
        11, 19, 27, 39,
        12, 20, 28, 40,
        13, 21, 29, 41,
        14, 22, 30, 38,
        15, 23, 31, 39,
        16, 24, 32, 40,
        17, 25, 33, 41,
         0, 63
    };

uint32 hr3_tdm_template_56162_op2[54] = {
         38, 40, 10, 34,
         38, 40, 11, 35,
         38, 40, 12, 31,
         38, 40, 13, 32,
         38, 40, 14, 33,
         38, 40, 15, 18,
         38, 40, 16, 19,
         38, 40, 17, 20,
         38, 40, 26, 21,
         38, 40, 27, 22,
         38, 40, 28, 23,
         38, 40, 29, 24,
         38, 40, 30, 25,
          0, 63
    };

/* 56162 GPHY BYPASS TDMs */

uint32 hr3_tdm_template_56162_op1_gphy_bypass[34] = {
         2, 18, 26, 34,
         3, 19, 27, 35,
         4, 20, 28, 36,
         5, 21, 29, 37,
         6, 22, 30, 34,
         7, 23, 31, 35,
         8, 24, 32, 36,
         9, 25, 33, 37,
         0, 63
    };

uint32 hr3_tdm_template_56162_op1a_gphy_bypass[34] = {
         2, 18, 26, 38,
         3, 19, 27, 39,
         4, 20, 28, 40,
         5, 21, 29, 41,
         6, 22, 30, 38,
         7, 23, 31, 39,
         8, 24, 32, 40,
         9, 25, 33, 41,
         0, 63
    };

uint32 hr3_tdm_template_56162_op2_gphy_bypass[54] = {
         38, 40,  2, 34,
         38, 40,  3, 35,
         38, 40,  4, 31,
         38, 40,  5, 32,
         38, 40,  6, 33,
         38, 40,  7, 18,
         38, 40,  8, 19,
         38, 40,  9, 20,
         38, 40, 26, 21,
         38, 40, 27, 22,
         38, 40, 28, 23,
         38, 40, 29, 24,
         38, 40, 30, 25,
          0, 63
    };

/* Hurricane3 Lite TDMs */

uint32 hr3_tdm_template_56163_op1[32] = {
        34, 38,  0, 10,
        34, 38, 63, 11,
        34, 38, 63, 12,
        34, 38, 63, 13,
        34, 38, 63, 14,
        34, 38, 63, 15,
        34, 38, 63, 16,
        34, 38, 63, 17
    };

uint32 hr3_tdm_template_56163_op2[32] = {
        34, 38,  0, 10,
        35, 39, 63, 11,
        36, 40, 63, 12,
        37, 41, 63, 13,
        34, 38, 63, 14,
        35, 39, 63, 15,
        36, 40, 63, 16,
        37, 41, 63, 17
    };

/* 56163 GPHY BYPASS TDMs */
uint32 hr3_tdm_template_56163_op1_gphy_bypass[32] = {
        34, 38,  0,  2,
        34, 38, 63,  3,
        34, 38, 63,  4,
        34, 38, 63,  5,
        34, 38, 63, 18,
        34, 38, 63, 19,
        34, 38, 63, 20,
        34, 38, 63, 21
    };

uint32 hr3_tdm_template_56163_op2_gphy_bypass[32] = {
        34, 38,  0,  2,
        35, 39, 63,  3,
        36, 40, 63,  4,
        37, 41, 63,  5,
        34, 38, 63, 18,
        35, 39, 63, 19,
        36, 40, 63, 20,
        37, 41, 63, 21
    };


/* Buckhound TDMs */

/* 53440 TDMs */
uint32 hr3_tdm_template_53440_op3[50] = {
        38, 36, 34, 12,
        39, 40, 35, 13,
         2, 18, 26, 14,
        38, 36, 34, 15,
        39, 40, 35, 16,
         3, 19, 27, 17,
        38, 36, 34, 28,
        39, 40, 35, 29,
         4, 20, 10, 30,
        38, 36, 34, 31,
        39, 40, 35, 32,
         5, 21, 11, 33,
         0, 63
    };

uint32 hr3_tdm_template_53440_op3_gphy_bypass[50] = {
        38, 40,  7, 22,
        39, 36, 34, 26,
         2, 18, 35, 27,
        38, 40,  8, 23,
        39, 36, 34, 28,
         3, 19, 35, 29,
        38, 40,  9, 24,
        39, 36, 34, 30,
         4, 20, 35, 31,
        38, 40,  6, 25,
        39, 36, 34, 32,
         5, 21, 35, 33,
         0, 63
    };

/* 56166 GPHY BYPASS TDMs */
uint32 hr3_tdm_template_56166_op1_gphy_bypass[86] = {
        38, 36, 34, 18,
        39, 37, 35, 19,
        38, 36, 34, 20,
        39, 37, 35, 21,
        38, 36, 34, 22,
        39, 37, 35, 23,
        38, 36, 34, 24,
        39, 37, 35, 26,
        38, 36, 34, 27,
        39, 37, 35, 28,
        38, 36, 34, 29,
        39, 37, 35, 30,
        38, 36, 34, 31,
        39, 37, 35,  2,
        38, 36, 34,  3,
        39, 37, 35,  4,
        38, 36, 34,  5,
        39, 37, 35,  6,
        38, 36, 34,  7,
        39, 37, 32,  8,
        35, 25, 33,  9,
        0, 63
    };


uint32 hr3_tdm_template_56166_op1a_gphy_bypass[86] = {
        38, 40, 34, 18,
        39, 41, 35, 19,
        38, 40, 34, 20,
        39, 41, 35, 21,
        38, 40, 34, 22,
        39, 41, 35, 23,
        38, 40, 34, 24,
        39, 41, 35, 26,
        38, 40, 34, 27,
        39, 41, 35, 28,
        38, 40, 34, 29,
        39, 41, 35, 30,
        38, 40, 34, 31,
        39, 41, 35,  2,
        38, 40, 34,  3,
        39, 41, 35,  4,
        38, 40, 34,  5,
        39, 41, 35,  6,
        38, 40, 34,  7,
        39, 41, 32,  8,
        35, 25, 33,  9,
        0, 63
    };

uint32 hr3_tdm_template_56166_op2_gphy_bypass[96] = {
        38, 40, 34,  2,
        38, 40, 35,  3,
        38, 40, 34,  4,
        38, 40, 35,  5,
        38, 40, 34,  6,
        38, 40, 35,  7,
        38, 40, 34,  8,
        38, 40, 35,  9,
        38, 40, 34, 18,
        38, 40, 35, 19,
        38, 40, 34, 20,
        38, 40, 35, 21,
        38, 40, 34, 22,
        38, 40, 35, 23,
        38, 40, 34, 24,
        38, 40, 35, 25,
        38, 40, 34, 26,
        38, 40, 35, 27,
        38, 40, 34, 28,
        38, 40, 35, 29,
        38, 40,  0, 30,
        38, 40, 34, 31,
        38, 40, 35, 32,
        38, 40, 63, 33
    };

uint32 hr3_tdm_template_56166_op2a_gphy_bypass[96] = {
        34, 36, 38,  2,
        34, 36, 39,  3,
        34, 36, 38,  4,
        34, 36, 39,  5,
        34, 36, 38,  6,
        34, 36, 39,  7,
        34, 36, 38,  8,
        34, 36, 39,  9,
        34, 36, 38, 18,
        34, 36, 39, 19,
        34, 36, 38, 20,
        34, 36, 39, 21,
        34, 36, 38, 22,
        34, 36, 39, 23,
        34, 36, 38, 24,
        34, 36, 39, 25,
        34, 36, 38, 26,
        34, 36, 39, 27,
        34, 36, 38, 28,
        34, 36, 39, 29,
        34, 36,  0, 30,
        34, 36, 38, 31,
        34, 36, 39, 32,
        34, 36, 63, 33
    };

uint32 hr3_tdm_template_56166_op5_gphy_bypass[86] = {
        36, 40, 34, 19,
        36, 40, 38, 20,
        36, 40, 34, 21,
        36, 40, 38, 22,
        36, 40, 34, 23,
        36, 40, 38, 24,
        36, 40, 34, 25,
        36, 40, 38, 26,
        36, 40, 34, 27,
        36, 40, 38, 28,
        18,  9,  0, 29,
        36, 40, 34, 30,
        36, 40, 38, 31,
        36, 40, 34, 32,
        36, 40, 38,  2,
        36, 40, 34,  3,
        36, 40, 38,  4,
        36, 40, 34,  5,
        36, 40, 38,  6,
        36, 40, 34,  7,
        36, 40, 38,  8,
        33, 63
    };

uint32 hr3_tdm_template_56166_op6_gphy_bypass[92] = {
        38, 40, 36,  5,
        38, 40, 36,  6,
        38, 40, 36, 34,
        38, 40, 36, 26,
         2, 40, 18, 34,
        38, 40, 36, 27,
        38, 40, 36,  7,
        38, 40, 19, 34,
        38, 40, 36, 28,
         3,  0, 20, 34,
        38, 40, 36,  8,
        38, 40, 36, 29,
        38, 40, 21, 34,
        38, 40, 36, 30,
         4, 63, 22, 34,
        38, 40, 36, 31,
        38, 40, 36, 32,
        38, 40, 23, 34,
        38, 40, 36,  9,
        38, 63, 24, 34,
        38, 40, 36, 33,
        38, 40, 36, 34,
        38, 40, 36, 25
    };

/* 56166 TDMs */
uint32 hr3_tdm_template_56166_op1[86] = {
        38, 36, 34, 18,
        39, 37, 35, 19,
        38, 36, 34, 20,
        39, 37, 35, 21,
        38, 36, 34, 22,
        39, 37, 35, 23,
        38, 36, 34, 24,
        39, 37, 35, 26,
        38, 36, 34, 27,
        39, 37, 35, 28,
        38, 36, 34, 29,
        39, 37, 35, 30,
        38, 36, 34, 31,
        39, 37, 35, 10,
        38, 36, 34, 11,
        39, 37, 35, 12,
        38, 36, 34, 13,
        39, 37, 35, 14,
        38, 36, 34, 15,
        39, 37, 32, 16,
        35, 25, 33, 17,
        0, 63
    };

uint32 hr3_tdm_template_56166_op1a[86] = {
        38, 40, 34, 18,
        39, 41, 35, 19,
        38, 40, 34, 20,
        39, 41, 35, 21,
        38, 40, 34, 22,
        39, 41, 35, 23,
        38, 40, 34, 24,
        39, 41, 35, 26,
        38, 40, 34, 27,
        39, 41, 35, 28,
        38, 40, 34, 29,
        39, 41, 35, 30,
        38, 40, 34, 31,
        39, 41, 35, 10,
        38, 40, 34, 11,
        39, 41, 35, 12,
        38, 40, 34, 13,
        39, 41, 35, 14,
        38, 40, 34, 15,
        39, 41, 32, 16,
        35, 25, 33, 17,
        0, 63
    };

uint32 hr3_tdm_template_56166_op2[96] = {
        38, 40, 34, 10,
        38, 40, 35, 11,
        38, 40, 34, 12,
        38, 40, 35, 13,
        38, 40, 34, 14,
        38, 40, 35, 15,
        38, 40, 34, 16,
        38, 40, 35, 17,
        38, 40, 34, 18,
        38, 40, 35, 19,
        38, 40, 34, 20,
        38, 40, 35, 21,
        38, 40, 34, 22,
        38, 40, 35, 23,
        38, 40, 34, 24,
        38, 40, 35, 25,
        38, 40, 34, 26,
        38, 40, 35, 27,
        38, 40, 34, 28,
        38, 40, 35, 29,
        38, 40,  0, 30,
        38, 40, 34, 31,
        38, 40, 35, 32,
        38, 40, 63, 33
    };

uint32 hr3_tdm_template_56166_op2a[96] = {
        34, 36, 38, 10,
        34, 36, 39, 11,
        34, 36, 38, 12,
        34, 36, 39, 13,
        34, 36, 38, 14,
        34, 36, 39, 15,
        34, 36, 38, 16,
        34, 36, 39, 17,
        34, 36, 38, 18,
        34, 36, 39, 19,
        34, 36, 38, 20,
        34, 36, 39, 21,
        34, 36, 38, 22,
        34, 36, 39, 23,
        34, 36, 38, 24,
        34, 36, 39, 25,
        34, 36, 38, 26,
        34, 36, 39, 27,
        34, 36, 38, 28,
        34, 36, 39, 29,
        34, 36,  0, 30,
        34, 36, 38, 31,
        34, 36, 39, 32,
        34, 36, 63, 33
    };

uint32 hr3_tdm_template_56166_op5[86] = {
        36, 40, 34, 19,
        36, 40, 38, 20,
        36, 40, 34, 21,
        36, 40, 38, 22,
        36, 40, 34, 23,
        36, 40, 38, 24,
        36, 40, 34, 25,
        36, 40, 38, 26,
        36, 40, 34, 27,
        36, 40, 38, 28,
        18, 17,  0, 29,
        36, 40, 34, 30,
        36, 40, 38, 31,
        36, 40, 34, 32,
        36, 40, 38, 10,
        36, 40, 34, 11,
        36, 40, 38, 12,
        36, 40, 34, 13,
        36, 40, 38, 14,
        36, 40, 34, 15,
        36, 40, 38, 16,
        33, 63
    };

uint32 hr3_tdm_template_56166_op6[92] = {
        38, 40, 36, 13,
        38, 40, 36, 14,
        38, 40, 36, 34,
        38, 40, 36, 26,
        10, 40, 18, 34,
        38, 40, 36, 27,
        38, 40, 36, 15,
        38, 40, 19, 34,
        38, 40, 36, 28,
        11,  0, 20, 34,
        38, 40, 36, 16,
        38, 40, 36, 29,
        38, 40, 21, 34,
        38, 40, 36, 30,
        12, 63, 22, 34,
        38, 40, 36, 31,
        38, 40, 36, 32,
        38, 40, 23, 34,
        38, 40, 36, 17,
        38, 63, 24, 34,
        38, 40, 36, 33,
        38, 40, 36, 34,
        38, 40, 36, 25
    };


/* System Clock Freq (MHz) */
#define _HR3_56160_SYSTEM_FREQ          (300)
#define _HR3_56162_SYSTEM_FREQ          (111)
#define _HR3_56163_SYSTEM_FREQ          (111)
#define _HR3_56164_SYSTEM_FREQ          (75)
#define _HR3_56166_SYSTEM_FREQ          (230)
#define _HR3_53440_SYSTEM_FREQ          (300)
#define _HR3_53442_SYSTEM_FREQ          (111)
#define _HR3_53443_SYSTEM_FREQ          (111)
#define _HR3_53434_SYSTEM_FREQ          (75)


#define _HR3_MAX_TSC_COUNT              (2)
#define _HR3_MAX_QTC_COUNT              (2)
#define _HR3_MAX_QGPHY_COUNT            (2)
#define _HR3_PORT_COUNT_PER_TSC         (4)
#define _HR3_PORT_COUNT_PER_QTC         (16)


#define _HR3_QTC_SERDES_OVERRDE_NONE    (0)
#define _HR3_QTC_SERDES_OVERRDE_QSGMII  (1)
#define _HR3_QTC_SERDES_OVERRDE_SGMII   (2)

#define _HR3_ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))

static const int tsc_phy_port[] = {34, 38};
static const int qtc_phy_port[] = {2, 18};


static int matched_devid_idx[SOC_MAX_NUM_DEVICES] = {-1};
static int _hr3_port_config_id = -1;

typedef struct _hr3_tsc_info_s {
    int     port_count;
    uint8   valid;
    int     phy_port_base;
}_hr3_tsc_info_t;

typedef struct _hr3_sku_info_s {
    uint16      dev_id;
    int         config_op; /* sku option */
    int         gphy_bypass; /* gphy_bypass_mode */
    int         tsc_configurable;
    int         freq;
    const int   *p2l_mapping;
    const int   *speed_max;
    uint32      *tdm_table;
    int         tdm_table_size;
    uint32      disabled_qtc_bmp; /* 2 bits: [qtc1~qtc0] */
    uint32      disabled_tsc_bmp; /* 2 bits: [tsc1~tsc0] */
    uint32      disabled_gphy_bmp; /* 2 bits: [gphy1~gphy0] */
    int         default_port_ratio[_HR3_MAX_TSC_COUNT];
    int         num_qsgmii_supported[_HR3_MAX_QTC_COUNT];
    int         num_sgmii_supported[_HR3_MAX_QTC_COUNT];
}_hr3_sku_info_t;

static _hr3_tsc_info_t _hr3_tsc[_HR3_MAX_TSC_COUNT];
static int _hr3_qtc_gport_port_count[_HR3_MAX_TSC_COUNT][2];
static int _hr3_qtc_serdes_override[_HR3_MAX_QTC_COUNT];


STATIC _hr3_sku_info_t _hr3_sku_port_config[] = {
/* 56160 */
/* Option 1 */
{BCM56160_DEVICE_ID,  1, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op1, port_speed_max_56160_op1,
    hr3_tdm_template_56160_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},
/* Option 1A */
{BCM56160_DEVICE_ID,  0x1a, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op1a, port_speed_max_56160_op1a,
    hr3_tdm_template_56160_op1a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},
/* Option 2 */
{BCM56160_DEVICE_ID,  0x2, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op2, port_speed_max_56160_op2,
    hr3_tdm_template_56160_op2, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},
/* Option 2A */
{BCM56160_DEVICE_ID,  0x2a, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op2a, port_speed_max_56160_op2a,
    hr3_tdm_template_56160_op2a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},
/* Option 3 */
{BCM56160_DEVICE_ID,  0x3, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op3, port_speed_max_56160_op3,
    hr3_tdm_template_56160_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {1, 1}, {4, 4}},
/* Option 4 */
{BCM56160_DEVICE_ID,  0x4, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op4, port_speed_max_56160_op4,
    hr3_tdm_template_56160_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {1, 1}, {4, 4}},
/* Option 5 */
{BCM56160_DEVICE_ID,  0x5, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op5, port_speed_max_56160_op5,
    hr3_tdm_template_56160_op5, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op5),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {1, 1}, {4, 4}},
/* Option 6 */
{BCM56160_DEVICE_ID,  0x6, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op6, port_speed_max_56160_op6,
    hr3_tdm_template_56160_op6, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},
/* Option 6A */
{BCM56160_DEVICE_ID,  0x6a, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op6a, port_speed_max_56160_op6a,
    hr3_tdm_template_56160_op6a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {1, 1}, {4, 4}},
/* Option 7 */
{BCM56160_DEVICE_ID,  0x7, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op7, port_speed_max_56160_op7,
    hr3_tdm_template_56160_op7, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op7),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_SINGLE, SOC_HR3_PORT_RATIO_SINGLE},
    {1, 1}, {4, 4}},
/* Option 8 */
{BCM56160_DEVICE_ID,  0x8, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op8, port_speed_max_56160_op8,
    hr3_tdm_template_56160_op8, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op8),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_SINGLE},
    {1, 1}, {4, 4}},
/* Option 8A */
{BCM56160_DEVICE_ID,  0x8a, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op8a, port_speed_max_56160_op8a,
    hr3_tdm_template_56160_op8a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op8a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_SINGLE, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},
/* Option 9 */
{BCM56160_DEVICE_ID,  0x9, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op9, port_speed_max_56160_op9,
    hr3_tdm_template_56160_op9, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op9),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},
/* Option 9A */
{BCM56160_DEVICE_ID,  0x9a, 0, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op9a, port_speed_max_56160_op9a,
    hr3_tdm_template_56160_op9a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op9a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},

/* 56160 GPHY BYPASS */
/* Option 1 */
{BCM56160_DEVICE_ID,  0x1, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op1_gphy_bypass, port_speed_max_56160_op1_gphy_bypass,
    hr3_tdm_template_56160_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},
/* Option 1A */
{BCM56160_DEVICE_ID,  0x1a, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op1a_gphy_bypass, port_speed_max_56160_op1a_gphy_bypass,
    hr3_tdm_template_56160_op1a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},
/* Option 2 */
{BCM56160_DEVICE_ID,  0x2, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op2_gphy_bypass, port_speed_max_56160_op2_gphy_bypass,
    hr3_tdm_template_56160_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},
/* Option 2A */
{BCM56160_DEVICE_ID,  0x2a, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op2a_gphy_bypass, port_speed_max_56160_op2a_gphy_bypass,
    hr3_tdm_template_56160_op2a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},
/* Option 3 */
{BCM56160_DEVICE_ID,  0x3, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op3_gphy_bypass, port_speed_max_56160_op3_gphy_bypass,
    hr3_tdm_template_56160_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {2, 4}, {4, 4}},
/* Option 4 */
{BCM56160_DEVICE_ID,  0x4, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op4_gphy_bypass, port_speed_max_56160_op4_gphy_bypass,
    hr3_tdm_template_56160_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {2, 4}, {4, 4}},
/* Option 5 */
{BCM56160_DEVICE_ID,  0x5, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op5_gphy_bypass, port_speed_max_56160_op5_gphy_bypass,
    hr3_tdm_template_56160_op5_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op5_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {2, 4}, {4, 4}},
/* Option 6 */
{BCM56160_DEVICE_ID,  0x6, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op6_gphy_bypass, port_speed_max_56160_op6_gphy_bypass,
    hr3_tdm_template_56160_op6_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},
/* Option 6A */
{BCM56160_DEVICE_ID,  0x6a, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op6a_gphy_bypass, port_speed_max_56160_op6a_gphy_bypass,
    hr3_tdm_template_56160_op6a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {2, 4}, {4, 4}},
/* Option 7 */
{BCM56160_DEVICE_ID,  0x7, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op7_gphy_bypass, port_speed_max_56160_op7_gphy_bypass,
    hr3_tdm_template_56160_op7_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op7_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_SINGLE, SOC_HR3_PORT_RATIO_SINGLE},
    {2, 4}, {4, 4}},
/* Option 8 */
{BCM56160_DEVICE_ID,  0x8, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op8_gphy_bypass, port_speed_max_56160_op8_gphy_bypass,
    hr3_tdm_template_56160_op8_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op8_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_SINGLE},
    {2, 4}, {4, 4}},
/* Option 8A */
{BCM56160_DEVICE_ID,  0x8a, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op8a_gphy_bypass, port_speed_max_56160_op8a_gphy_bypass,
    hr3_tdm_template_56160_op8a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op8a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_SINGLE, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},
/* Option 9 */
{BCM56160_DEVICE_ID,  0x9, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op9_gphy_bypass, port_speed_max_56160_op9_gphy_bypass,
    hr3_tdm_template_56160_op9_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op9_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},
/* Option 9A */
{BCM56160_DEVICE_ID,  0x9a, 1, 0, _HR3_56160_SYSTEM_FREQ,
    p2l_mapping_56160_op9a_gphy_bypass, port_speed_max_56160_op9a_gphy_bypass,
    hr3_tdm_template_56160_op9a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op9a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},

/* 56162 */
/* Option 1 */
{BCM56162_DEVICE_ID,  0x1, 0, 0, _HR3_56162_SYSTEM_FREQ,
    p2l_mapping_56162_op1, port_speed_max_56162_op1,
    hr3_tdm_template_56162_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1),
    0x0, 0x2, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, -1},
    {0, 2}, {0, 2}},
/* Option 1A */
{BCM56162_DEVICE_ID,  0x1a, 0, 0, _HR3_56162_SYSTEM_FREQ,
    p2l_mapping_56162_op1a, port_speed_max_56162_op1a,
    hr3_tdm_template_56162_op1a, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1a),
    0x0, 0x1, 0x0,
    {-1, SOC_HR3_PORT_RATIO_QUAD},
    {0, 2}, {0, 2}},
/* Option 2 */
{BCM56162_DEVICE_ID,  0x2, 0, 0, _HR3_56162_SYSTEM_FREQ,
    p2l_mapping_56162_op2, port_speed_max_56162_op2,
    hr3_tdm_template_56162_op2, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op2),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {0, 2}, {0, 2}},

/* 56162 GPHY BYPASS*/
/* Option 1 */
{BCM56162_DEVICE_ID,  0x1, 1, 0, _HR3_56162_SYSTEM_FREQ,
    p2l_mapping_56162_op1_gphy_bypass, port_speed_max_56162_op1_gphy_bypass,
    hr3_tdm_template_56162_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1_gphy_bypass),
    0x0, 0x2, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, -1},
    {2, 4}, {2, 4}},
/* Option 1A */
{BCM56162_DEVICE_ID,  0x1a, 1, 0, _HR3_56162_SYSTEM_FREQ,
    p2l_mapping_56162_op1a_gphy_bypass, port_speed_max_56162_op1a_gphy_bypass,
    hr3_tdm_template_56162_op1a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1a_gphy_bypass),
    0x0, 0x1, 0x3,
    {-1, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {2, 4}},
/* Option 2 */
{BCM56162_DEVICE_ID,  0x2, 1, 0, _HR3_56162_SYSTEM_FREQ,
    p2l_mapping_56162_op2_gphy_bypass, port_speed_max_56162_op2_gphy_bypass,
    hr3_tdm_template_56162_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op2_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {2, 4}},


/* Huricane3 Lite */
/* 56163 */
/* Option 1 */
{BCM56163_DEVICE_ID,  0x1, 0, 0, _HR3_56163_SYSTEM_FREQ,
    p2l_mapping_56163_op1, port_speed_max_56163_op1,
    hr3_tdm_template_56163_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1),
    0x2, 0x0, 0x2,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {0, 0}},
/* Option 2, TSCx 4X2.5g */
{BCM56163_DEVICE_ID,  0x2, 0, 1, _HR3_56163_SYSTEM_FREQ,
    p2l_mapping_56163_op2, port_speed_max_56163_op2,
    hr3_tdm_template_56163_op2, _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op2),
    0x2, 0x0, 0x2,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {0, 0}},
/* Option 2, TSCx XAUI */
{BCM56163_DEVICE_ID,  0x2, 0, 1, _HR3_56163_SYSTEM_FREQ,
    p2l_mapping_56163_op1, port_speed_max_56163_op1,
    hr3_tdm_template_56163_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1),
    0x2, 0x0, 0x2,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {0, 0}, {0, 0}},

/* 56163 GPHY BYPASS*/
/* Option 1 */
{BCM56163_DEVICE_ID,  0x1, 1, 0, _HR3_56163_SYSTEM_FREQ,
    p2l_mapping_56163_op1_gphy_bypass, port_speed_max_56163_op1_gphy_bypass,
    hr3_tdm_template_56163_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {4, 4}},
/* Option 2, TSCx 4X2.5g */
{BCM56163_DEVICE_ID,  0x2, 1, 1, _HR3_56163_SYSTEM_FREQ,
    p2l_mapping_56163_op2_gphy_bypass, port_speed_max_56163_op2_gphy_bypass,
    hr3_tdm_template_56163_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op2_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {4, 4}},
/* Option 2, TSCx XAUI */
{BCM56163_DEVICE_ID,  0x2, 1, 1, _HR3_56163_SYSTEM_FREQ,
    p2l_mapping_56163_op1_gphy_bypass, port_speed_max_56163_op1_gphy_bypass,
    hr3_tdm_template_56163_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {0, 0}, {4, 4}},

/* 56164 */
{BCM56164_DEVICE_ID,  -1, 0, 0, _HR3_56164_SYSTEM_FREQ,
    p2l_mapping_56162_op1, port_speed_max_56162_op1,
    hr3_tdm_template_56162_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1),
    0x0, 0x2, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, -1},
    {0, 2}, {0, 2}},

/* 56166 */
/* Option 1 */
{BCM56166_DEVICE_ID,  0x1, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op1, port_speed_max_56166_op1,
    hr3_tdm_template_56166_op1,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 2}, {0, 2}},
/* Option 1A */
{BCM56166_DEVICE_ID,  0x1a, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op1a, port_speed_max_56166_op1a,
    hr3_tdm_template_56166_op1a,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1a),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 2}, {0, 2}},
/* Option 2 */
{BCM56166_DEVICE_ID,  0x2, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op2, port_speed_max_56166_op2,
    hr3_tdm_template_56166_op2,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op2),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {0, 2}, {0, 2}},
/* Option 2A */
{BCM56166_DEVICE_ID,  0x2a, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op2a, port_speed_max_56166_op2a,
    hr3_tdm_template_56166_op2a,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op2a),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {0, 2}, {0, 2}},
/* Option 3 */
{BCM56166_DEVICE_ID,  0x3, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op3, port_speed_max_56166_op3,
    hr3_tdm_template_56166_op1,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {0, 2}, {0, 2}},
/* Option 4 */
{BCM56166_DEVICE_ID,  0x4, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op4, port_speed_max_56166_op4,
    hr3_tdm_template_56166_op1,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {0, 2}, {0, 2}},
/* Option 5 */
{BCM56166_DEVICE_ID,  0x5, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op5, port_speed_max_56166_op5,
    hr3_tdm_template_56166_op5,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op5),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {0, 2}, {0, 2}},
/* Option 6 */
{BCM56166_DEVICE_ID,  0x6, 0, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op6, port_speed_max_56166_op6,
    hr3_tdm_template_56166_op6,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op6),
    0, 0, 0x0,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {0, 2}, {0, 2}},

/* 56166 GPHY BYPASS */
/* Option 1 */
{BCM56166_DEVICE_ID,  0x1, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op1_gphy_bypass, port_speed_max_56166_op1_gphy_bypass,
    hr3_tdm_template_56166_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {2, 4}},
/* Option 1A */
{BCM56166_DEVICE_ID,  0x1a, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op1a_gphy_bypass, port_speed_max_56166_op1a_gphy_bypass,
    hr3_tdm_template_56166_op1a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1a_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {2, 4}},
/* Option 2 */
{BCM56166_DEVICE_ID,  0x2, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op2_gphy_bypass, port_speed_max_56166_op2_gphy_bypass,
    hr3_tdm_template_56166_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op2_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {2, 4}},
/* Option 2A */
{BCM56166_DEVICE_ID,  0x2a, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op2a_gphy_bypass, port_speed_max_56166_op2a_gphy_bypass,
    hr3_tdm_template_56166_op2a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op2a_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {2, 4}},
/* Option 3 */
{BCM56166_DEVICE_ID,  0x3, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op3_gphy_bypass, port_speed_max_56166_op3_gphy_bypass,
    hr3_tdm_template_56166_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {2, 4}, {2, 4}},
/* Option 4 */
{BCM56166_DEVICE_ID,  0x4, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op4_gphy_bypass, port_speed_max_56166_op4_gphy_bypass,
    hr3_tdm_template_56166_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op1_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {2, 4}, {2, 4}},
/* Option 5 */
{BCM56166_DEVICE_ID,  0x5, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op5_gphy_bypass, port_speed_max_56166_op5_gphy_bypass,
    hr3_tdm_template_56166_op5_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op5_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {2, 4}, {2, 4}},
/* Option 6 */
{BCM56166_DEVICE_ID,  0x6, 1, 0, _HR3_56166_SYSTEM_FREQ,
    p2l_mapping_56166_op6_gphy_bypass, port_speed_max_56166_op6_gphy_bypass,
    hr3_tdm_template_56166_op6_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56166_op6_gphy_bypass),
    0x0, 0, 0x3,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {2, 4}},


/* Buckhound */
/* 53440 */
/* Option 1 */
{BCM53440_DEVICE_ID,  0x1, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op5, port_speed_max_56160_op5,
    hr3_tdm_template_56160_op5, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op5),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {1, 1}, {4, 4}},
/* Option 2 */
{BCM53440_DEVICE_ID,  0x2, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op6a, port_speed_max_56160_op6a,
    hr3_tdm_template_56160_op6a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {1, 1}, {4, 4}},
/* Option 2A */
{BCM53440_DEVICE_ID,  0x2a, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op6, port_speed_max_56160_op6,
    hr3_tdm_template_56160_op6, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},
/* Option 3 */
{BCM53440_DEVICE_ID,  0x3, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_53440_op3, port_speed_max_53440_op3,
    hr3_tdm_template_53440_op3, _HR3_ARRAY_SIZE(hr3_tdm_template_53440_op3),
    0, 0, 0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},
/* Option 4 */
{BCM53440_DEVICE_ID,  0x4, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2a, port_speed_max_53440_op4,
    hr3_tdm_template_56160_op2a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2a),
    0, 0, 0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},
/* Option 4A */
{BCM53440_DEVICE_ID,  0x4a, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2, port_speed_max_53440_op4a,
    hr3_tdm_template_56160_op2, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2),
    0, 0, 0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},
/* Option 5 */
{BCM53440_DEVICE_ID,  0x5, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op3, port_speed_max_56160_op3,
    hr3_tdm_template_56160_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {1, 1}, {4, 4}},
/* Option 6 */
{BCM53440_DEVICE_ID,  0x6, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op4, port_speed_max_56160_op4,
    hr3_tdm_template_56160_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {1, 1}, {4, 4}},
/* Option 7 */
{BCM53440_DEVICE_ID, 0x7, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op1, port_speed_max_56160_op1,
    hr3_tdm_template_56160_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},
/* Option 7A */
{BCM53440_DEVICE_ID,  0x7a, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op1a, port_speed_max_56160_op1a,
    hr3_tdm_template_56160_op1a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},
/* Option 8 */
{BCM53440_DEVICE_ID,  0x8, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2, port_speed_max_56160_op2,
    hr3_tdm_template_56160_op2, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {1, 1}, {4, 4}},
/* Option 8A */
{BCM53440_DEVICE_ID,  0x8a, 0, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2a, port_speed_max_56160_op2a,
    hr3_tdm_template_56160_op2a, _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2a),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {1, 1}, {4, 4}},

/* 53440 GPHY BYPASS */
/* Option 1 */
{BCM53440_DEVICE_ID,  0x1, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op5_gphy_bypass, port_speed_max_56160_op5_gphy_bypass,
    hr3_tdm_template_56160_op5_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op5_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {2, 4}, {4, 4}},
/* Option 2 */
{BCM53440_DEVICE_ID,  0x2, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op6a_gphy_bypass, port_speed_max_56160_op6a_gphy_bypass,
    hr3_tdm_template_56160_op6a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_TRI_012_1_1_2},
    {2, 4}, {4, 4}},
/* Option 2A */
{BCM53440_DEVICE_ID,  0x2a, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op6_gphy_bypass, port_speed_max_56160_op6_gphy_bypass,
    hr3_tdm_template_56160_op6_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op6_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_TRI_012_1_1_2, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},
/* Option 3 */
{BCM53440_DEVICE_ID,  0x3, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_53440_op3_gphy_bypass, port_speed_max_53440_op3_gphy_bypass,
    hr3_tdm_template_53440_op3_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_53440_op3_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},
/* Option 4 */
{BCM53440_DEVICE_ID,  0x4, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2a_gphy_bypass, port_speed_max_53440_op4_gphy_bypass,
    hr3_tdm_template_56160_op2a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},
/* Option 4A */
{BCM53440_DEVICE_ID,  0x4a, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2_gphy_bypass, port_speed_max_53440_op4a_gphy_bypass,
    hr3_tdm_template_56160_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},
/* Option 5 */
{BCM53440_DEVICE_ID,  0x5, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op3_gphy_bypass, port_speed_max_56160_op3_gphy_bypass,
    hr3_tdm_template_56160_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {2, 4}, {4, 4}},
/* Option 6 */
{BCM53440_DEVICE_ID,  0x6, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op4_gphy_bypass, port_speed_max_56160_op4_gphy_bypass,
    hr3_tdm_template_56160_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {2, 4}, {4, 4}},
/* Option 7 */
{BCM53440_DEVICE_ID,  0x7, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op1_gphy_bypass, port_speed_max_56160_op1_gphy_bypass,
    hr3_tdm_template_56160_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},
/* Option 7A */
{BCM53440_DEVICE_ID,  0x7a, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op1a_gphy_bypass, port_speed_max_56160_op1a_gphy_bypass,
    hr3_tdm_template_56160_op1a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op1a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},
/* Option 8 */
{BCM53440_DEVICE_ID,  0x8, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2_gphy_bypass, port_speed_max_56160_op2_gphy_bypass,
    hr3_tdm_template_56160_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {4, 4}},
/* Option 8A */
{BCM53440_DEVICE_ID,  0x8a, 1, 0, _HR3_53440_SYSTEM_FREQ,
    p2l_mapping_56160_op2a_gphy_bypass, port_speed_max_56160_op2a_gphy_bypass,
    hr3_tdm_template_56160_op2a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56160_op2a_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_DUAL_2_2, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {4, 4}},

/* 53442 */
/* Option 1 */
{BCM53442_DEVICE_ID,  0x1, 0, 0, _HR3_53442_SYSTEM_FREQ,
    p2l_mapping_56162_op1, port_speed_max_56162_op1,
    hr3_tdm_template_56162_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1),
    0x0, 0x2, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, -1},
    {0, 2}, {0, 2}},
/* Option 1A */
{BCM53442_DEVICE_ID,  0x1a, 0, 0, _HR3_53442_SYSTEM_FREQ,
    p2l_mapping_56162_op1a, port_speed_max_56162_op1a,
    hr3_tdm_template_56162_op1a, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1a),
    0x0, 0x1, 0x0,
    {-1, SOC_HR3_PORT_RATIO_QUAD},
    {0, 2}, {0, 2}},
/* Option 2 */
{BCM53442_DEVICE_ID,  0x2, 0, 0, _HR3_53442_SYSTEM_FREQ,
    p2l_mapping_56162_op2, port_speed_max_56162_op2,
    hr3_tdm_template_56162_op2, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op2),
    0x0, 0x0, 0x0,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {0, 2}, {0, 2}},
/* 53442 GPHY BYPASS */
/* Option 1 */
{BCM53442_DEVICE_ID,  0x1, 1, 0, _HR3_53442_SYSTEM_FREQ,
    p2l_mapping_56162_op1_gphy_bypass, port_speed_max_56162_op1_gphy_bypass,
    hr3_tdm_template_56162_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1_gphy_bypass),
    0x0, 0x2, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, -1},
    {2, 4}, {2, 4}},
/* Option 1A */
{BCM53442_DEVICE_ID,  0x1a, 1, 0, _HR3_53442_SYSTEM_FREQ,
    p2l_mapping_56162_op1a_gphy_bypass, port_speed_max_56162_op1a_gphy_bypass,
    hr3_tdm_template_56162_op1a_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1a_gphy_bypass),
    0x0, 0x1, 0x3,
    {-1, SOC_HR3_PORT_RATIO_QUAD},
    {2, 4}, {2, 4}},
/* Option 2 */
{BCM53442_DEVICE_ID,  0x2, 1, 0, _HR3_53442_SYSTEM_FREQ,
    p2l_mapping_56162_op2_gphy_bypass, port_speed_max_56162_op2_gphy_bypass,
    hr3_tdm_template_56162_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op2_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_DUAL_2_2},
    {2, 4}, {2, 4}},

/* 53443 */
/* Option 1 */
{BCM53443_DEVICE_ID,  0x1, 0, 0, _HR3_53443_SYSTEM_FREQ,
    p2l_mapping_56163_op1, port_speed_max_56163_op1,
    hr3_tdm_template_56163_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1),
    0x2, 0x0, 0x2,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {0, 0}},
/* Option 2, TSCx 4X2.5G  */
{BCM53443_DEVICE_ID,  0x2, 0, 1, _HR3_53443_SYSTEM_FREQ,
    p2l_mapping_56163_op2, port_speed_max_56163_op2,
    hr3_tdm_template_56163_op2, _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op2),
    0x2, 0x0, 0x2,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {0, 0}},
/* Option 2, TSCx XAUI */
{BCM53443_DEVICE_ID,  0x2, 0, 1, _HR3_53443_SYSTEM_FREQ,
    p2l_mapping_56163_op1, port_speed_max_56163_op1,
    hr3_tdm_template_56163_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1),
    0x2, 0x0, 0x2,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {0, 0}, {0, 0}},

/* 53443 GPHY BYPASS*/
/* Option 1 */
{BCM53443_DEVICE_ID,  0x1, 1, 0, _HR3_53443_SYSTEM_FREQ,
    p2l_mapping_56163_op1_gphy_bypass, port_speed_max_56163_op1_gphy_bypass,
    hr3_tdm_template_56163_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {4, 4}},
/* Option 2, TSCx 4X2.5G  */
{BCM53443_DEVICE_ID,  0x2, 1, 1, _HR3_53443_SYSTEM_FREQ,
    p2l_mapping_56163_op2_gphy_bypass, port_speed_max_56163_op2_gphy_bypass,
    hr3_tdm_template_56163_op2_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op2_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_QUAD, SOC_HR3_PORT_RATIO_QUAD},
    {0, 0}, {4, 4}},
/* Option 2, TSCx XAUI */
{BCM53443_DEVICE_ID,  0x2, 1, 1, _HR3_53443_SYSTEM_FREQ,
    p2l_mapping_56163_op1_gphy_bypass, port_speed_max_56163_op1_gphy_bypass,
    hr3_tdm_template_56163_op1_gphy_bypass,
    _HR3_ARRAY_SIZE(hr3_tdm_template_56163_op1_gphy_bypass),
    0x0, 0x0, 0x3,
    {SOC_HR3_PORT_RATIO_SINGLE_XAUI, SOC_HR3_PORT_RATIO_SINGLE_XAUI},
    {0, 0}, {4, 4}},

/* 53434 */
{BCM53434_DEVICE_ID,  -1, 0, 0, _HR3_53434_SYSTEM_FREQ,
    p2l_mapping_56162_op1, port_speed_max_53434,
    hr3_tdm_template_56162_op1, _HR3_ARRAY_SIZE(hr3_tdm_template_56162_op1),
    0x0, 0x3, 0x0,
    {-1, -1},
    {0, 2}, {0, 2}},

{0,0,0,0,0,0,0,0,0,0,0,0,{-1,-1}, {0, 0}, {0, 0}},
};

/* MMU related */
/* Hurricane3 uses 2MB of internal Buffers */
#define HR3_MMU_BUFFER_SIZE_2MB    (2 * 1024 * 1024)
/* Foxhound2 uses 512KB of internal Buffers */
#define FH2_MMU_BUFFER_SIZE_512KB  (512 * 1024)

/* 24GE + 4HG +1CPU ports */
#define HR3_MMU_TOTAL_PORTS      29

#define HR3_MMU_NUM_COS          8
#define HR3_MMU_CELL_SIZE        128

#define HR3_MMU_IN_COS_MIN_CELLS     16

#define HR3_MMU_IN_COS_MIN_XQS       16
#define FH2_MMU_IN_COS_MIN_XQS       8

#define HR3_MMU_IN_XOFF_PKT     12

/* cos(8) * reserved cells */
#define HR3_MMU_IN_PORT_STATIC_CELLS (HR3_MMU_NUM_COS * HR3_MMU_IN_COS_MIN_CELLS)

/* Every port has 6K packet pointers(XQs) */
/* #define HR3_MMU_IN_PORT_TOTAL_XQS    6144 */
/* The value should be provided by desigh team, change it to 1536 temporarily. */
#define HR3_MMU_IN_PORT_TOTAL_XQS    1536
/* number of cos(8) * minimum xqs per cos */
#define HR3_MMU_IN_PORT_STATIC_XQS   (HR3_MMU_NUM_COS * HR3_MMU_IN_COS_MIN_XQS)
#define FH2_MMU_IN_PORT_STATIC_XQS   (HR3_MMU_NUM_COS * FH2_MMU_IN_COS_MIN_XQS)
/* total xqs (8192)- static xqs */
#define HR3_MMU_IN_PORT_DYNAMIC_XQS  (HR3_MMU_IN_PORT_TOTAL_XQS - HR3_MMU_IN_PORT_STATIC_XQS)
#define FH2_MMU_IN_PORT_DYNAMIC_XQS  (HR3_MMU_IN_PORT_TOTAL_XQS - FH2_MMU_IN_PORT_STATIC_XQS)

#define _SOC_HR3_MMU_IPMC_GROUP_MAX     32
static soc_mem_t ipmc_mems[_SOC_HR3_MMU_IPMC_GROUP_MAX] = {
        INVALIDm,  INVALIDm,
        MMU_IPMC_GROUP_TBL2m,  MMU_IPMC_GROUP_TBL3m,
        MMU_IPMC_GROUP_TBL4m,  MMU_IPMC_GROUP_TBL5m,
        MMU_IPMC_GROUP_TBL6m,  MMU_IPMC_GROUP_TBL7m,
        MMU_IPMC_GROUP_TBL8m,  MMU_IPMC_GROUP_TBL9m,
        MMU_IPMC_GROUP_TBL10m,  MMU_IPMC_GROUP_TBL11m,
        MMU_IPMC_GROUP_TBL12m,  MMU_IPMC_GROUP_TBL13m,
        MMU_IPMC_GROUP_TBL14m,  MMU_IPMC_GROUP_TBL15m,
        MMU_IPMC_GROUP_TBL16m,  MMU_IPMC_GROUP_TBL17m,
        MMU_IPMC_GROUP_TBL18m,  MMU_IPMC_GROUP_TBL19m,
        MMU_IPMC_GROUP_TBL20m,  MMU_IPMC_GROUP_TBL21m,
        MMU_IPMC_GROUP_TBL22m,  MMU_IPMC_GROUP_TBL23m,
        MMU_IPMC_GROUP_TBL24m,  MMU_IPMC_GROUP_TBL25m,
        MMU_IPMC_GROUP_TBL26m,  MMU_IPMC_GROUP_TBL27m,
        MMU_IPMC_GROUP_TBL28m,  MMU_IPMC_GROUP_TBL29m,
        MMU_IPMC_GROUP_TBL30m,  MMU_IPMC_GROUP_TBL31m
};

static int
soc_hurricane3_pipe_mem_clear(int unit)
{
    uint32              rval;
    int                 pipe_init_usec, index;
    soc_timeout_t       to;
    static const struct {
        soc_mem_t mem;
        uint32 skip_flags; /* always skip on QUICKTURN or XGSSIM */
    } cam_list[] = {
        { CPU_COS_MAPm,                     BOOT_F_PLISIM },
        { EFP_TCAMm,                        BOOT_F_PLISIM },
        { FP_GLOBAL_MASK_TCAMm,             BOOT_F_PLISIM },
        { FP_TCAMm,                         BOOT_F_PLISIM },
        { L2_USER_ENTRYm,                   BOOT_F_PLISIM },
        { L2_USER_ENTRY_ONLYm,              BOOT_F_PLISIM },
        { L3_DEFIPm,                        BOOT_F_PLISIM },
        { L3_DEFIP_ONLYm,                   BOOT_F_PLISIM },
        { VFP_TCAMm,                        BOOT_F_PLISIM },
        { VLAN_SUBNETm,                     0 },/* VLAN API needs all 0 mask */
        { VLAN_SUBNET_ONLYm,                0 }
    };

    /*
     * Reset the IPIPE and EPIPE block
     */
    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_1r(unit, rval));
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, VALIDf, 1);
    /* Set count to # entries in largest IPIPE table, L2_ENTRYm */
    soc_reg_field_set(unit, ING_HW_RESET_CONTROL_2r, &rval, COUNTf, 0x4000);
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_0r(unit, rval));
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, RESET_ALLf, 1);
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, VALIDf, 1);
    /* Set count to # entries in largest EPIPE table, EGR_GPP_ATTRIBUTESm */
    soc_reg_field_set(unit, EGR_HW_RESET_CONTROL_1r, &rval, COUNTf, 0x2000);
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    /* For simulation, set timeout to 10 sec.  Otherwise, timeout = 50 ms */
    if (SAL_BOOT_SIMULATION) {
        pipe_init_usec = 10000000;
    } else {
        pipe_init_usec = 50000;
    }
    soc_timeout_init(&to, pipe_init_usec, 0);

    /* Wait for IPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_ING_HW_RESET_CONTROL_2r(unit, &rval));
        if (soc_reg_field_get(unit, ING_HW_RESET_CONTROL_2r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                     (BSL_META_U(unit,
                                 "unit %d : ING_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);

    /* Wait for EPIPE memory initialization done. */
    do {
        SOC_IF_ERROR_RETURN(READ_EGR_HW_RESET_CONTROL_1r(unit, &rval));
        if (soc_reg_field_get(unit, EGR_HW_RESET_CONTROL_1r, rval, DONEf)) {
            break;
        }
        if (soc_timeout_check(&to)) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit, "unit %d : EGR_HW_RESET timeout\n"), unit));
            break;
        }
    } while (TRUE);

    rval = 0;
    SOC_IF_ERROR_RETURN(WRITE_ING_HW_RESET_CONTROL_2r(unit, rval));
    SOC_IF_ERROR_RETURN(WRITE_EGR_HW_RESET_CONTROL_1r(unit, rval));

    if (!SAL_BOOT_SIMULATION || SAL_BOOT_BCMSIM) {
        /* TCAM tables are not handled by hardware reset control */
        for (index = 0; index < sizeof(cam_list) / sizeof(cam_list[0]);
             index++) {
            if (sal_boot_flags_get() & cam_list[index].skip_flags) {
                continue;
            }
            if (((cam_list[index].mem == EFP_TCAMm) ||
                (cam_list[index].mem == VFP_TCAMm)) &&
                (!soc_feature(unit, soc_feature_field_multi_stage))) {
                continue;
            }
            SOC_IF_ERROR_RETURN
                (soc_mem_clear(unit, cam_list[index].mem, COPYNO_ALL, TRUE));
        }

        /* MMU_IPMC_VLAN_TBL */
        SOC_IF_ERROR_RETURN
            (soc_mem_clear(unit, MMU_IPMC_VLAN_TBLm, COPYNO_ALL, TRUE));

        /* MMU_IPMC_GROUP_TBLn : n is 2 ~ 31 in HR3 */
        for (index = 0; index < _SOC_HR3_MMU_IPMC_GROUP_MAX; index++) {
            if (ipmc_mems[index] != INVALIDm) {
                SOC_IF_ERROR_RETURN(soc_mem_clear(unit,
                        ipmc_mems[index], COPYNO_ALL, TRUE));
            }
        }

    }

    return SOC_E_NONE;
}

/*
* Function:
*      soc_hurricane3_chip_sku_get
* Purpose:
*      Get the chip sku
* Parameters :
*      sku - (OUT)Hurricane3 chip sku(SOC_HR3_SKU_XXX)
*/
int
soc_hurricane3_chip_sku_get(int unit, int *sku)
{
    uint16  dev_id;
    uint8    rev_id;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    if (((dev_id & 0x00FF) == 0x0060) || ((dev_id & 0x00FF) == 0x0062)) {
        /* Hurricane3 (56160, 56162) */
        *sku = SOC_HR3_SKU_HURRICANE3;
    } else if (((dev_id & 0x00FF) == 0x0063) || ((dev_id & 0x00FF) == 0x0064) ||
        ((dev_id & 0x00FF) == 0x0066)) {
        /* Hurricane3Lite (56163, 56164, 56166) */
        *sku = SOC_HR3_SKU_HURRICANE3LITE;
    } else if ((dev_id & 0x00F0) == 0x0040) {
        /* Buckhound (53440, 53442, 53443) */
        *sku = SOC_HR3_SKU_BUCKHOUND;
    } else if ((dev_id & 0x00F0) == 0x0030) {
        /* Foxhound2 (53434) */
        *sku = SOC_HR3_SKU_FOXHOUND2;
    } else {
        *sku = -1;
        return SOC_E_BADID;
    }

    return SOC_E_NONE;
}

int
_soc_hr3_process_l2_overflow(int unit)
{
    uint32 ip1_rval, l2_no_learn, ovf_no_learn;

    if (SOC_CONTROL(unit)->l2_overflow_enable) {
        SOC_IF_ERROR_RETURN(soc_reg32_get(
            unit, IP1_INTR_STATUSr, REG_PORT_ANY, 0, &ip1_rval));
        l2_no_learn = soc_reg_field_get(unit, IP1_INTR_STATUSr,
            ip1_rval, L2_ENTRY_NO_LEARN_INTRf);
        ovf_no_learn = soc_reg_field_get(unit, IP1_INTR_STATUSr,
            ip1_rval, L2_ENTRY_OVF_NO_LEARN_INTRf);
        if (SOC_CONTROL(unit)->l2_overflow_bucket_enable) {
            if (ovf_no_learn) {
                /* report overflow event */
                soc_hr3_l2_overflow_interrupt_handler(unit);
            }
        } else {
            if (l2_no_learn) {
                /* report overflow event */
                soc_hr3_l2_overflow_interrupt_handler(unit);
            }
        }
        /* Enable interrupt */
        SOC_IF_ERROR_RETURN(soc_hr3_l2_overflow_intr_enable(unit));
    }

    return SOC_E_NONE;
}

#define CMIC_PARITY_IP1_TO_CMIC_PERR_INTR_BIT       0x0008

STATIC soc_hr3_oam_ser_handler_t hr3_oam_ser_handler[SOC_MAX_NUM_DEVICES] = {NULL};

void
soc_hr3_oam_ser_handler_register(int unit, soc_hr3_oam_ser_handler_t handler)
{
    hr3_oam_ser_handler[unit] = handler;
}

int
soc_hr3_oam_ser_process(int unit, soc_mem_t mem, int index)
{
    void *null_entry = NULL;
    int rv = SOC_E_NONE;

    if (hr3_oam_ser_handler[unit]) {
        return hr3_oam_ser_handler[unit](unit, mem, index);
    } else {
        /* Clear the entry of MA_STATE and REMP memories */
        null_entry = soc_mem_entry_null(unit, mem);
        if ((rv = soc_mem_write(unit, mem, MEM_BLOCK_ALL, index, null_entry)) < 0) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "OAM SER ENTRY_CLEAR failed for %s[%d]: %s\n"),
                       SOC_MEM_NAME(unit, mem),
                       index, soc_errmsg(rv)));
            return rv;
        }
        soc_event_generate(unit, SOC_SWITCH_EVENT_PARITY_ERROR,
                               SOC_SWITCH_EVENT_DATA_ERROR_CORRECTED, mem, index);
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "OAM SER ENTRY_CLEAR: %s[%d] index %d\n"),
                   SOC_MEM_NAME(unit, mem), mem, index));
        return rv;
    }
}

STATIC soc_hr3_oam_handler_t hr3_oam_handler[SOC_MAX_NUM_DEVICES] = {NULL};

soc_field_t _soc_hr3_oam_interrupt_fields[] = {
    SOME_RDI_DEFECT_INTRf,
    SOME_RMEP_CCM_DEFECT_INTRf,
    ERROR_CCM_DEFECT_INTRf,
    ANY_RMEP_TLV_PORT_DOWN_INTRf,
    ANY_RMEP_TLV_PORT_UP_INTRf,
    ANY_RMEP_TLV_INTERFACE_DOWN_INTRf,
    ANY_RMEP_TLV_INTERFACE_UP_INTRf,
    XCON_CCM_DEFECT_INTRf,
    INVALIDf
};

static int
_soc_hr3_oam_interrupt_control(int unit, soc_field_t field, int enable)
{

    uint32      rval;
    int         fidx = 0;

    SOC_IF_ERROR_RETURN(READ_IP1_INTR_ENABLEr(unit, &rval));
    if (field == INVALIDf){
        while (_soc_hr3_oam_interrupt_fields[fidx] != INVALIDf) {
            soc_reg_field_set(unit, IP1_INTR_ENABLEr, &rval,
                              _soc_hr3_oam_interrupt_fields[fidx],
                              enable ? 1 : 0);
            fidx++;
        }
    } else {
        if (soc_reg_field_valid(unit, IP1_INTR_ENABLEr, field)) {
            soc_reg_field_set(unit, IP1_INTR_ENABLEr, &rval,
                              field, enable ? 1 : 0);
        } else {
            return SOC_E_PARAM;
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_IP1_INTR_ENABLEr(unit, rval));
    return SOC_E_NONE;
}

void
soc_hr3_oam_handler_register(int unit, soc_hr3_oam_handler_t handler)
{
    hr3_oam_handler[unit] = handler;

    /* Enable oam interrupt */
    _soc_hr3_oam_interrupt_control(unit, INVALIDf, 1);
    /* Write CMIC enable register */
    (void)soc_cmicm_intr3_enable(
            unit, CMIC_PARITY_IP1_TO_CMIC_PERR_INTR_BIT);

}

int
soc_hr3_process_oam_interrupt(int unit)
{
    uint32 rval;
    int fidx = 0;
    soc_hr3_oam_handler_t oam_handler_snapshot = hr3_oam_handler[unit];


    SOC_IF_ERROR_RETURN(READ_IP1_INTR_STATUSr(unit, &rval));

    while (_soc_hr3_oam_interrupt_fields[fidx] != INVALIDf) {
        if (soc_reg_field_get(unit, IP1_INTR_STATUSr, rval,
                          _soc_hr3_oam_interrupt_fields[fidx])) {
            if (oam_handler_snapshot != NULL)
            {
                (void)(oam_handler_snapshot(unit,
                           _soc_hr3_oam_interrupt_fields[fidx]));
            }
        }
        fidx++;
    }

    return SOC_E_NONE;
}


#define  HR3_NUM_COS  8
int soc_hr3_xq_mem(int unit, soc_port_t port, soc_mem_t *xq)
{
    soc_mem_t   xq_mems[] = {   MMU_XQ0m,
                                MMU_XQ1m,
                                MMU_XQ2m,
                                MMU_XQ3m,
                                MMU_XQ4m,
                                MMU_XQ5m,
                                MMU_XQ6m,
                                MMU_XQ7m,
                                MMU_XQ8m,
                                MMU_XQ9m,
                                MMU_XQ10m,
                                MMU_XQ11m,
                                MMU_XQ12m,
                                MMU_XQ13m,
                                MMU_XQ14m,
                                MMU_XQ15m,
                                MMU_XQ16m,
                                MMU_XQ17m,
                                MMU_XQ18m,
                                MMU_XQ19m,
                                MMU_XQ20m,
                                MMU_XQ21m,
                                MMU_XQ22m,
                                MMU_XQ23m,
                                MMU_XQ24m,
                                MMU_XQ25m,
                                MMU_XQ26m,
                                MMU_XQ27m,
                                MMU_XQ28m,
                                MMU_XQ29m
                            };
    int max_port;
    max_port = sizeof(xq_mems) / sizeof(xq_mems[0]);
    if (port >= max_port) {
        return(SOC_E_PORT);
    }
    *xq = xq_mems[port];
    return(SOC_E_NONE);
}


int
soc_hurricane3_init_port_mapping(int unit)
{
    soc_info_t *si;
    soc_mem_t mem;
    uint32 rval;
    ing_physical_to_logical_port_number_mapping_table_entry_t entry;
    int port, phy_port;
    int num_port, num_phy_port;

    si = &SOC_INFO(unit);

    /* Ingress physical to logical port mapping */
    mem = ING_PHYSICAL_TO_LOGICAL_PORT_NUMBER_MAPPING_TABLEm;
    num_phy_port = soc_mem_index_count(unit, mem);
    sal_memset(&entry, 0, sizeof(entry));
    for (phy_port = 0; phy_port < num_phy_port; phy_port++) {
        port = si->port_p2l_mapping[phy_port];
        soc_mem_field32_set(unit, mem, &entry, LOGICAL_PORT_NUMBERf,
                            port == -1 ? 0x30 : port);
        SOC_IF_ERROR_RETURN
            (soc_mem_write(unit, mem, MEM_BLOCK_ALL, phy_port, &entry));
    }
    num_port = soc_mem_index_count(unit, PORT_TABm);

    /* Egress logical to physical port mapping */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_l2p_mapping[port];
        rval = 0;
        soc_reg_field_set(unit, EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr,
                          &rval, PHYSICAL_PORT_NUMBERf,
                          phy_port == -1 ? 0x3f : phy_port);
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_LOGICAL_TO_PHYSICAL_PORT_NUMBER_MAPPINGr(unit, port,
                                                                rval));
    }
    /* MMU logical to physical port mapping */
    /*(Here, Same as Egress logical to physical port mapping) */
    for (port = 0; port < num_port; port++) {
        phy_port = si->port_m2p_mapping[port];
        if (phy_port != -1) {
            rval = 0;
            soc_reg_field_set(unit, LOG_TO_PHY_PORT_MAPPINGr, &rval,
                              PHY_PORTf, phy_port);
            SOC_IF_ERROR_RETURN
                (WRITE_LOG_TO_PHY_PORT_MAPPINGr(unit, port, rval));
        }
    }

    return SOC_E_NONE;
}

STATIC int
_soc_hr3_tsc_config_supported(int unit, int sku_config_idx)
{
    int i;
    char *propval;

    for (i = 0; i <_HR3_MAX_TSC_COUNT; i++) {
        propval = soc_property_suffix_num_str_get(unit, i,
            spn_BCM5616X_INIT_PORT_CONFIG, "tsc");
        if (propval) {
            if (sal_strcmp(propval, "XAUI") == 0) {
                if (_hr3_sku_port_config[sku_config_idx].default_port_ratio[i]
                    != SOC_HR3_PORT_RATIO_SINGLE_XAUI) {
                    return FALSE;
                }
            } else if (sal_strcmp(propval, "SINGLE") == 0) {
                if (_hr3_sku_port_config[sku_config_idx].default_port_ratio[i]
                    != SOC_HR3_PORT_RATIO_QUAD) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}

/*
 *  Function:
 *      _soc_hurricane3_port_gphy_mode_init
 *  Purpose:
 *      Init GPHY as normal or bypass mode based on the
 *      matched SKU configuration.
 *      (GPHY_BYPASS mode means trun off the embedded GPHYs.)
 *  Note:
 *      From rev B0, TOP_MISC_STATUSr.RSVD_0f is used to configure
 *      GPHY bypass mode
 */
STATIC int
_soc_hurricane3_port_gphy_mode_init(int unit)
{
    uint16 dev_id;
    uint8 rev_id;
    uint32 rval = 0;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    /* The support of gphy bypass mode is started from B0 */
    if (rev_id == BCM56160_A0_REV_ID) {
        return SOC_E_NONE;
    }

    SOC_IF_ERROR_RETURN(READ_TOP_MISC_STATUSr(unit, &rval));

    if (_hr3_sku_port_config[matched_devid_idx[unit]].gphy_bypass == 0) {
        soc_reg_field_set(unit, TOP_MISC_STATUSr, &rval, RSVD_0f, 0x0);
    } else {
        soc_reg_field_set(unit, TOP_MISC_STATUSr, &rval, RSVD_0f, 0x3);
    }

    SOC_IF_ERROR_RETURN(WRITE_TOP_MISC_STATUSr(unit, rval));

    return SOC_E_NONE;
}

/*
 *  HR3 port mapping
 * cpu port number is fixed: physical 0, logical 0, mmu 0
 */
int
soc_hurricane3_port_config_init(int unit, uint16 dev_id)
{

    soc_info_t *si;
    int rv = SOC_E_NONE;
    int phy_port;
    const int *p2l_mapping = 0,*speed_max = 0;
    char *propval,*option;
    int match = -1, i, j, match_option;
    int p2l_mapping_override[SOC_MAX_PHY_PORTS];
    int port_speed_max_override[SOC_MAX_PHY_PORTS];
    int port_num_lanes[SOC_MAX_PHY_PORTS];
    _hr3_sku_info_t *matched_port_config = NULL;
    uint32  gphy_bypass = 0;


    matched_devid_idx[unit] = -1;
    option = soc_property_get_str(unit, spn_BCM5616X_INIT_PORT_CONFIG);
    if(option == NULL) {
        if ((dev_id & 0x00F0) == 0x0060) { /* Hurricane3 */
            _hr3_port_config_id = 5;
        } else {
            /* default option to 1 for non-HR3 SKUs */
            _hr3_port_config_id = 1;
        }
    } else {
        _hr3_port_config_id = sal_ctoi(option, NULL);
    }
    match_option = -1;
    /* gphy_bypass value */
    gphy_bypass = soc_property_suffix_num_get_only_suffix(unit, 0,
               spn_BCM5616X_INIT_PORT_CONFIG, "gphy_bypass", 0);

    for (i=0; _hr3_sku_port_config[i].dev_id; i++){
        /* CHECK SKU ID */
        if(dev_id == _hr3_sku_port_config[i].dev_id) {
            match = i;
            if (_hr3_sku_port_config[i].config_op != -1 ){
                match_option = 0;

                /* check the option ID and GPHY bypass mode */
                if ((_hr3_sku_port_config[i].config_op == _hr3_port_config_id)
                    && (_hr3_sku_port_config[i].gphy_bypass ==
                    gphy_bypass)){
                    /* Check the TSC configuration is supported or not */
                    if ((_hr3_sku_port_config[i].tsc_configurable) &&
                      (!_soc_hr3_tsc_config_supported(unit, i))) {
                        continue;
                    }
                    /* match */
                    match = i;
                    match_option = _hr3_port_config_id;
                    break;
                }
            }
        }
    }
    for (i = 0; i < _HR3_MAX_TSC_COUNT; i++) {
        _hr3_tsc[i].port_count = 0;
        _hr3_tsc[i].valid = 0;
        _hr3_tsc[i].phy_port_base = tsc_phy_port[i];
        if (match == -1) {
            _hr3_tsc[i].port_count = _hr3_sku_port_config[0].default_port_ratio[i];
        } else {
            _hr3_tsc[i].port_count = _hr3_sku_port_config[match].default_port_ratio[i];
        }
    }

    /* Check QTC SGMII/QSGMII selection */
    for (i = 0; i < _HR3_MAX_QTC_COUNT; i++) {
        _hr3_qtc_serdes_override[i] = _HR3_QTC_SERDES_OVERRDE_NONE;
        propval = soc_property_suffix_num_str_get(unit, i, spn_BCM5616X_INIT_PORT_CONFIG, "qtc");
        if (propval) {
            if (sal_strcmp(propval, "SGMII") == 0) {
                _hr3_qtc_serdes_override[i] = _HR3_QTC_SERDES_OVERRDE_SGMII;
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,"%s: QTC%1d is SGMII\n"),
                    FUNCTION_NAME(), i));
            } else if (sal_strcmp(propval, "QSGMII") == 0) {
                _hr3_qtc_serdes_override[i] = _HR3_QTC_SERDES_OVERRDE_QSGMII;
                LOG_VERBOSE(BSL_LS_SOC_COMMON,
                    (BSL_META_U(unit,"%s: QTC%1d is QSGMII\n"),
                    FUNCTION_NAME(), i));
            } else {
                _hr3_qtc_serdes_override[i] = _HR3_QTC_SERDES_OVERRDE_NONE;
            }
        }
    }

    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        p2l_mapping_override[phy_port] = 0;
        port_speed_max_override[phy_port] = 0;
        port_num_lanes[phy_port] = 1;
    }
    if (match == -1) {
        /* take 56160 option 1a as default config */
        p2l_mapping = p2l_mapping_56160_op1a;
        speed_max = port_speed_max_56160_op1a;
        LOG_WARN(BSL_LS_SOC_COMMON,
            (BSL_META_U(unit,"%s: no device_id matched\n"),FUNCTION_NAME()));
    } else {
        matched_devid_idx[unit] = match;
        matched_port_config = &_hr3_sku_port_config[match];
        if (((option != NULL) && (matched_port_config->config_op == -1)) ||
            (match_option == 0)){
            LOG_WARN(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit, "Warning: bcm5616x_init_port_config=%d config "
                "is not supported in %s ! \n"),_hr3_port_config_id,
                soc_dev_name(unit)));
        }

        p2l_mapping = matched_port_config->p2l_mapping;
        speed_max = matched_port_config->speed_max;

        /* QSGMII or SGMII selection */
        for (i = 0; i <_HR3_MAX_QTC_COUNT; i++) {
            if(!((1 << i) &  matched_port_config->disabled_qtc_bmp)) {
                /* Override to the SGMII port mapping and max speed */
                if (_hr3_qtc_serdes_override[i] == _HR3_QTC_SERDES_OVERRDE_SGMII) {
                    LOG_VERBOSE(BSL_LS_SOC_COMMON,
                        (BSL_META_U(unit,"%s: QTC%1d SGMII overrided.\n"),
                        FUNCTION_NAME(), i));
                    if (matched_port_config->num_sgmii_supported[i] == 0) {
                        LOG_WARN(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                            "Warning: bcm5616x_init_port_config_qtc%d config "
                            "is not supported in %s ! \n"),i,
                            soc_dev_name(unit)));
                    }
                    /* Disable original qsgmii ports */
                    for (j = 0; j < matched_port_config->num_qsgmii_supported[i]; j++) {
                        p2l_mapping_override[qtc_phy_port[i]+j * 4] = -1;
                        p2l_mapping_override[qtc_phy_port[i]+j * 4 + 1] = -1;
                        p2l_mapping_override[qtc_phy_port[i]+j * 4 + 2] = -1;
                        p2l_mapping_override[qtc_phy_port[i]+j * 4 + 3] = -1;
                    }
                    for (j = 0; j < matched_port_config->num_sgmii_supported[i]; j++) {

                        /* Override sgmii port to max speed  = 2.5 Gb*/
                        p2l_mapping_override[qtc_phy_port[i]+j] = 1;
                        port_num_lanes[qtc_phy_port[i]+j] = 4;
                        if ((dev_id == BCM56160_DEVICE_ID) ||
                                (dev_id == BCM53440_DEVICE_ID)) {
                            port_speed_max_override[qtc_phy_port[i]+j] = 25;
                        } else {
                            port_speed_max_override[qtc_phy_port[i]+j] = 10;
                        }
                    }
                } else if (_hr3_qtc_serdes_override[i] ==
                        _HR3_QTC_SERDES_OVERRDE_QSGMII) {
                    if (matched_port_config->num_qsgmii_supported[i] == 0) {
                        LOG_WARN(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,
                            "Warning: bcm5616x_init_port_config_qtc%d config "
                            "is not supported in %s ! \n"),i,
                            soc_dev_name(unit)));
                        /* Defaul configuration is QSGMII except QSGMII is not supported */
                        /* No need to override the mapping and max port speed */
                    }
                }
            }
        }
        /*  TSC configuration selection of 56163 and 53443 */
        if (matched_port_config->tsc_configurable) {
            for (i = 0; i <_HR3_MAX_TSC_COUNT; i++) {
                propval = soc_property_suffix_num_str_get(unit, i,
                    spn_BCM5616X_INIT_PORT_CONFIG, "tsc");
                if (propval) {
                    if (sal_strcmp(propval, "XAUI") == 0) {
                        p2l_mapping_override[tsc_phy_port[i]] = 1;
                        port_speed_max_override[tsc_phy_port[i]] = 100;
                        p2l_mapping_override[tsc_phy_port[i]+ 1] = -1;
                        p2l_mapping_override[tsc_phy_port[i]+ 2] = -1;
                        p2l_mapping_override[tsc_phy_port[i]+ 3] = -1;
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,"%s: TSC%1d is XAUI mode\n"),
                            FUNCTION_NAME(), i));
                    } else if (sal_strcmp(propval, "SINGLE") == 0) {
                        /* default configuration */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,"%s: TSC%1d is SINGLE mode\n"),
                            FUNCTION_NAME(), i));
                    } else {
                        /* Using default configuration, SINGLE */
                        LOG_VERBOSE(BSL_LS_SOC_COMMON,
                            (BSL_META_U(unit,"%s: TSC%1d is SINGLE mode\n"),
                            FUNCTION_NAME(), i));
                    }
                }
            }
        }
    }

    si = &SOC_INFO(unit);

    for (phy_port = 0; phy_port < SOC_MAX_PHY_PORTS; phy_port++) {
        if (p2l_mapping_override[phy_port] == -1){
            si->port_p2l_mapping[phy_port] = p2l_mapping_override[phy_port];
            /* Same as Egr P2L */
            si->port_p2m_mapping[phy_port] = p2l_mapping_override[phy_port];
            /* For COSQ programming */
            si->max_port_p2m_mapping[phy_port] = p2l_mapping_override[phy_port];
        } else {
            /* speed_max reflects the valid port */
            /* For the same TDM, the phy_port should be existed in p2l_mapping table */
            if((speed_max[phy_port] == -1) && (phy_port != 0)){
                si->port_p2l_mapping[phy_port] = -1;
                si->port_p2m_mapping[phy_port] = -1;
                si->max_port_p2m_mapping[phy_port] = -1;
                si->port_num_lanes[p2l_mapping[phy_port]] = -1;
            } else {
                si->port_p2l_mapping[phy_port] = p2l_mapping[phy_port];
                si->port_p2m_mapping[phy_port] = p2l_mapping[phy_port];
                si->max_port_p2m_mapping[phy_port] = p2l_mapping[phy_port];
                si->port_num_lanes[p2l_mapping[phy_port]] = 1;
            }
        }
        if (port_speed_max_override[phy_port] != 0){
            if (port_speed_max_override[phy_port] != -1) {
                si->port_speed_max[si->port_p2l_mapping[phy_port]] =
                    port_speed_max_override[phy_port] * 100;
                si->port_num_lanes[p2l_mapping[phy_port]] =
                    port_num_lanes[phy_port];
            }
        } else {
            if (speed_max[phy_port] != -1) {
                si->port_speed_max[si->port_p2l_mapping[phy_port]] =
                    speed_max[phy_port] * 100;
            }
        }
    }

    /* QTC port count */
    for (i = 0; i <_HR3_MAX_QTC_COUNT; i++) {
        _hr3_qtc_gport_port_count[i][0] = SOC_HR3_PORT_RATIO_NONE;
        _hr3_qtc_gport_port_count[i][1] = SOC_HR3_PORT_RATIO_NONE;
        phy_port = qtc_phy_port[i];
        /* Check the port count of GPORT blocks */
        if(!((1 << i) &  matched_port_config->disabled_qtc_bmp)) {
            /* GP0 */
            if (si->port_p2l_mapping[phy_port + 7] != -1) {
                _hr3_qtc_gport_port_count[i][0] = SOC_HR3_PORT_RATIO_OCTAL;
            } else if (si->port_p2l_mapping[phy_port + 3] != -1) {
                _hr3_qtc_gport_port_count[i][0] = SOC_HR3_PORT_RATIO_QUAD;
            } else if (si->port_p2l_mapping[phy_port + 1] != -1) {
                _hr3_qtc_gport_port_count[i][0] = SOC_HR3_PORT_RATIO_DUAL_1_1;
            } else if (si->port_p2l_mapping[phy_port] != -1) {
                _hr3_qtc_gport_port_count[i][0] = SOC_HR3_PORT_RATIO_SINGLE;
            }

            /* GP1 */
            if (si->port_p2l_mapping[phy_port + 15] != -1) {
                _hr3_qtc_gport_port_count[i][1] = SOC_HR3_PORT_RATIO_OCTAL;
            } else if (si->port_p2l_mapping[phy_port + 11] != -1) {
                _hr3_qtc_gport_port_count[i][1] = SOC_HR3_PORT_RATIO_QUAD;
            } else if (si->port_p2l_mapping[phy_port + 9] != -1) {
                _hr3_qtc_gport_port_count[i][1] = SOC_HR3_PORT_RATIO_DUAL_1_1;
            } else if (si->port_p2l_mapping[phy_port + 8] != -1) {
                _hr3_qtc_gport_port_count[i][1] = SOC_HR3_PORT_RATIO_SINGLE;
            }
        }
    }

    /* system core clock */
    si->frequency = matched_port_config->freq;

    return rv;
}


int
_soc_hurricane3_tdm_init(int unit, uint16 dev_id)
{
    uint32              *arr = NULL;
    int                 tdm_size;
    uint32              rval;
    iarb_tdm_table_entry_t iarb_tdm;
    mmu_arb_tdm_table_entry_t mmu_arb_tdm;
    int i, port, phy_port;
    _hr3_sku_info_t *matched_sku_info;


    SOC_IF_ERROR_RETURN(READ_IARB_TDM_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 1);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf, 83);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    if (matched_devid_idx[unit] == -1) {
        LOG_WARN(BSL_LS_SOC_COMMON,
           (BSL_META_U(unit, "Warning: soc_hurricane3_port_config_init should "
                        "be invoked first! Choose bcm56160 port config.\n")));
        matched_devid_idx[unit] = 0;
    }
    matched_sku_info = &_hr3_sku_port_config[matched_devid_idx[unit]];

    arr = matched_sku_info->tdm_table;
    tdm_size = matched_sku_info->tdm_table_size;

    if (arr == NULL) {
        return SOC_E_CONFIG;
    }

    for (i = 0; i < tdm_size; i++) {
        phy_port = arr[i];
        port = (phy_port != 63) ? matched_sku_info->p2l_mapping[phy_port]:63;
        sal_memset(&iarb_tdm, 0, sizeof(iarb_tdm_table_entry_t));
        sal_memset(&mmu_arb_tdm, 0, sizeof(mmu_arb_tdm_table_entry_t));

        soc_IARB_TDM_TABLEm_field32_set(unit, &iarb_tdm, PORT_NUMf,
                                        phy_port);

        soc_MMU_ARB_TDM_TABLEm_field32_set(unit, &mmu_arb_tdm, PORT_NUMf,
                                       (port != -1) ? port : 63);
        if (i == tdm_size - 1) {
            soc_MMU_ARB_TDM_TABLEm_field32_set(unit, &mmu_arb_tdm, WRAP_ENf, 1);
        }
        SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                                                  &iarb_tdm));
        SOC_IF_ERROR_RETURN(WRITE_MMU_ARB_TDM_TABLEm(unit, SOC_BLOCK_ALL, i,
                                                 &mmu_arb_tdm));
    }
    rval = 0;
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, DISABLEf, 0);
    soc_reg_field_set(unit, IARB_TDM_CONTROLr, &rval, TDM_WRAP_PTRf,
                      tdm_size -1);
    SOC_IF_ERROR_RETURN(WRITE_IARB_TDM_CONTROLr(unit, rval));

    return SOC_E_NONE;
}

STATIC int
_soc_hr3_mmu_init_lossy(int unit)
{
    soc_port_t  port;
    uint32      val, oval, cfap_max_idx;
    uint16      dev_id;
    uint8       rev_id;
    uint32 rval;
    int index;
    int mmu_total_dyn_cells_set;
    int mmu_total_dyn_cells_reset;
    int egress_xq_min_reserve_lossy_ports;
    int egress_pkt_set_limit;
    int egress_pkt_reset_limit;
    int egress_cng_pkt_set_limit0;
    int egress_cng_pkt_set_limit1;
    int egress_cng_port_pkt_limit0;
    int egress_cng_port_pkt_limit1;
    int egress_dyn_xq_cnt_port;
    int egress_dyn_reset_lim_port;
    int egress_lwm_cell_set_limit;
    int egress_lwm_cell_reset_limit;
    int egress_hol_cell_max_limit;
    int egress_hol_cell_max_resume_limit;
    int egress_dyn_cell_set_limit;
    int egress_dyn_cell_reset_limit;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    cfap_max_idx = soc_mem_index_max(unit, MMU_CFAPm);
    SOC_IF_ERROR_RETURN(READ_CFAPCONFIGr(unit, &val));
    oval = val;
    soc_reg_field_set(unit, CFAPCONFIGr, &val, CFAPPOOLSIZEf, cfap_max_idx);
    if (oval != val) {
        SOC_IF_ERROR_RETURN(WRITE_CFAPCONFIGr(unit, val));
    }

    egress_xq_min_reserve_lossy_ports = 0xc; /* J61 */
    egress_pkt_set_limit = 0x59c; /* J62 */
    egress_pkt_reset_limit = 0x59b; /* J63 */
    egress_cng_pkt_set_limit0 = 0x5ff; /* J64 */
    egress_cng_pkt_set_limit1 = 0x5ff; /* J65 */
    egress_cng_port_pkt_limit0 = 0x5ff; /* J66 */
    egress_cng_port_pkt_limit1 = 0x5ff; /* J67 */
    egress_dyn_xq_cnt_port = 0x590; /* J68 */
    egress_dyn_reset_lim_port = 0x58e; /* J69 */
    egress_lwm_cell_set_limit = 0xc; /* J70 */
    egress_lwm_cell_reset_limit = 0xc; /* J71 */

    if (dev_id == BCM53443_DEVICE_ID) {
        /* downlink port 8, uplink port 4, cpu port 1 */
        mmu_total_dyn_cells_set = 0x3abc; /* J15 */
        mmu_total_dyn_cells_reset = 0x3a2c; /* J16 */
        egress_hol_cell_max_limit = 0x764; /* J72 */
        egress_hol_cell_max_resume_limit = 0x758; /* J73 */
        egress_dyn_cell_set_limit = 0x3abc; /* J74 */
        egress_dyn_cell_reset_limit = 0x3aa4; /* J75 */
    } else if (dev_id == BCM56163_DEVICE_ID) {
        /* downlink port 16, uplink port 4, cpu port 1 */
        mmu_total_dyn_cells_set = 0x37bc; /* J15 */
        mmu_total_dyn_cells_reset = 0x372c; /* J16 */
        egress_hol_cell_max_limit = 0x704; /* J72 */
        egress_hol_cell_max_resume_limit = 0x6f8; /* J73 */
        egress_dyn_cell_set_limit = 0x37bc; /* J74 */
        egress_dyn_cell_reset_limit = 0x37a4; /* J75 */
    } else if ((dev_id == BCM56162_DEVICE_ID) ||
               (dev_id == BCM53442_DEVICE_ID) ||
               (dev_id == BCM56164_DEVICE_ID)) {
        /* downlink port 24, uplink port 4, cpu port 1 */
        mmu_total_dyn_cells_set = 0x34bc; /* J15 */
        mmu_total_dyn_cells_reset = 0x342c; /* J16 */
        egress_hol_cell_max_limit = 0x6a4; /* J72 */
        egress_hol_cell_max_resume_limit = 0x698; /* J73 */
        egress_dyn_cell_set_limit = 0x34bc; /* J74 */
        egress_dyn_cell_reset_limit = 0x34a4; /* J75 */
    } else {
        /* 56160, 56161, 53449, 53446 */
        /* downlink port 24, uplink port 6, cpu port 1 */
        mmu_total_dyn_cells_set = 0x33fc; /* J15 */
        mmu_total_dyn_cells_reset = 0x336c; /* J16 */
        egress_hol_cell_max_limit = 0x68c; /* J72 */
        egress_hol_cell_max_resume_limit = 0x680; /* J73 */
        egress_dyn_cell_set_limit = 0x33fc; /* J74 */
        egress_dyn_cell_reset_limit = 0x33e4; /* J75 */
    }

    /* Device Wide Registers */
    SOC_IF_ERROR_RETURN(READ_CFAPFULLTHRESHOLDr(unit, &val));
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDr, &val,
                      CFAPFULLSETPOINTf, 0x3f9c);
    soc_reg_field_set(unit, CFAPFULLTHRESHOLDr, &val,
                      CFAPFULLRESETPOINTf, 0x3f54);
    SOC_IF_ERROR_RETURN(WRITE_CFAPFULLTHRESHOLDr(unit, val));

    /* Ingress Thresholds */
    SOC_IF_ERROR_RETURN(READ_GBLLIMITSETLIMITr(unit, &val));
    soc_reg_field_set(unit, GBLLIMITSETLIMITr, &val,
                      GBLCELLSETLIMITf, 0x3f9c);
    SOC_IF_ERROR_RETURN(WRITE_GBLLIMITSETLIMITr(unit, val));

    SOC_IF_ERROR_RETURN(READ_GBLLIMITRESETLIMITr(unit, &val));
    soc_reg_field_set(unit, GBLLIMITRESETLIMITr, &val,
                      GBLCELLRESETLIMITf, 0x3f9c);
    SOC_IF_ERROR_RETURN(WRITE_GBLLIMITRESETLIMITr(unit, val));

    /* Egress Thresholds */
    rval = 0;
    soc_reg_field_set(unit, TOTALDYNCELLSETLIMITr,
                      &rval, TOTALDYNCELLSETLIMITf,
                      mmu_total_dyn_cells_set);
    SOC_IF_ERROR_RETURN(WRITE_TOTALDYNCELLSETLIMITr(unit, rval));
    rval = 0;
    soc_reg_field_set(unit, TOTALDYNCELLRESETLIMITr,
                      &rval, TOTALDYNCELLRESETLIMITf,
                      mmu_total_dyn_cells_reset);
    SOC_IF_ERROR_RETURN(WRITE_TOTALDYNCELLRESETLIMITr(unit, rval));

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &val));
    soc_reg_field_set(unit, MISCCONFIGr, &val, MULTIPLE_ACCOUNTING_FIX_ENf, 1);
    soc_reg_field_set(unit, MISCCONFIGr, &val, CNG_DROP_ENf, 0);
    soc_reg_field_set(unit, MISCCONFIGr, &val, DYN_XQ_ENf, 1);
    soc_reg_field_set(unit, MISCCONFIGr, &val, HOL_CELL_SOP_DROP_ENf, 1);
    soc_reg_field_set(unit, MISCCONFIGr, &val, DYNAMIC_MEMORY_ENf, 1);
    soc_reg_field_set(unit, MISCCONFIGr, &val, SKIDMARKERf, 3);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, val));

    /* Enable IP to CMICM credit transfer */
    val = 0;
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &val, TRANSFER_ENABLEf, 1);
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &val, NUM_OF_CREDITSf, 32);
    SOC_IF_ERROR_RETURN(WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(unit, val));

    PBMP_ALL_ITER(unit, port) {
        /* PG_CTRL0r */
        soc_reg32_get(unit, PG_CTRL0r, port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PPFC_PG_ENf, 0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI0_GRPf, 0);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI1_GRPf, 1);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI2_GRPf, 2);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI3_GRPf, 3);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI4_GRPf, 4);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI5_GRPf, 5);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI6_GRPf, 6);
        soc_reg_field_set(unit, PG_CTRL0r, &rval, PRI7_GRPf, 7);
        soc_reg32_set(unit, PG_CTRL0r, port, 0, rval);

        /* PG_CTRL1r */
        soc_reg32_get(unit, PG_CTRL1r, port, 0, &rval);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI8_GRPf, 7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI9_GRPf, 7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI10_GRPf, 7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI11_GRPf, 7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI12_GRPf, 7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI13_GRPf, 7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI14_GRPf, 7);
        soc_reg_field_set(unit, PG_CTRL1r, &rval, PRI15_GRPf, 7);
        soc_reg32_set(unit, PG_CTRL1r, port, 0, rval);

        /* PG2TCr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PG2TCr, port, index, &rval);
            soc_reg_field_set(unit, PG2TCr, &rval, PG_BMPf, 0);
            soc_reg32_set(unit, PG2TCr, port, index, rval);
        }

        /* IBPPKTSETLIMITr */
        val = 0;
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &val,
                          PKTSETLIMITf, 0x3f9c);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &val, RESETLIMITSELf, 3);
        SOC_IF_ERROR_RETURN(WRITE_IBPPKTSETLIMITr(unit, port, val));

        /* MMU_FC_RX_ENr */
        soc_reg32_get(unit, MMU_FC_RX_ENr, port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_RX_ENr, &rval, MMU_FC_RX_ENABLEf, 0);
        soc_reg32_set(unit, MMU_FC_RX_ENr, port, 0, rval);

        /* MMU_FC_TX_ENr */
        soc_reg32_get(unit, MMU_FC_TX_ENr, port, 0, &rval);
        soc_reg_field_set(unit, MMU_FC_TX_ENr, &rval, MMU_FC_TX_ENABLEf, 0);
        soc_reg32_set(unit, MMU_FC_TX_ENr, port, 0, rval);

        /* PGCELLLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGCELLLIMITr, port, index, &rval);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLSETLIMITf,
                              0x3f9c);
            soc_reg_field_set(unit, PGCELLLIMITr, &rval,
                              CELLRESETLIMITf,
                              0x3f9c);
            soc_reg32_set(unit, PGCELLLIMITr,
                          port, index, rval);
        }

        /* PGDISCARDSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, PGDISCARDSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &rval,
                              DISCARDSETLIMITf,
                              0x3f9c);
            soc_reg32_set(unit, PGDISCARDSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSMINXQCNTr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSMINXQCNTr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &rval,
                              HOLCOSMINXQCNTf,
                              egress_xq_min_reserve_lossy_ports);
            soc_reg32_set(unit, HOLCOSMINXQCNTr,
                          port, index, rval);
        }

        /* HOLCOSPKTSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &rval,
                              PKTSETLIMITf,
                              egress_pkt_set_limit);
            soc_reg32_set(unit, HOLCOSPKTSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSPKTRESETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSPKTRESETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &rval,
                              PKTRESETLIMITf,
                              egress_pkt_reset_limit);
            soc_reg32_set(unit, HOLCOSPKTRESETLIMITr,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT0r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT0r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT0r, &rval,
                              CNGPKTSETLIMIT0f,
                              egress_cng_pkt_set_limit0);
            soc_reg32_set(unit, CNGCOSPKTLIMIT0r,
                          port, index, rval);
        }

        /* CNGCOSPKTLIMIT1r, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, CNGCOSPKTLIMIT1r,
                          port, index, &rval);
            soc_reg_field_set(unit, CNGCOSPKTLIMIT1r, &rval,
                              CNGPKTSETLIMIT1f,
                              egress_cng_pkt_set_limit1);
            soc_reg32_set(unit, CNGCOSPKTLIMIT1r,
                          port, index, rval);
        }

        /* CNGPORTPKTLIMIT0r */
        soc_reg32_get(unit, CNGPORTPKTLIMIT0r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT0r, &rval,
                          CNGPORTPKTLIMIT0f,
                          egress_cng_port_pkt_limit0);
        soc_reg32_set(unit, CNGPORTPKTLIMIT0r,
                      port, 0, rval);

        /* CNGPORTPKTLIMIT1r */
        soc_reg32_get(unit, CNGPORTPKTLIMIT1r,
                      port, 0, &rval);
        soc_reg_field_set(unit, CNGPORTPKTLIMIT1r, &rval,
                          CNGPORTPKTLIMIT1f,
                          egress_cng_port_pkt_limit1);
        soc_reg32_set(unit, CNGPORTPKTLIMIT1r,
                      port, 0, rval);

        /* DYNXQCNTPORTr */
        soc_reg32_get(unit, DYNXQCNTPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNXQCNTPORTr, &rval,
                          DYNXQCNTPORTf,
                          egress_dyn_xq_cnt_port);
        soc_reg32_set(unit, DYNXQCNTPORTr,
                      port, 0, rval);

        /* DYNRESETLIMPORTr */
        soc_reg32_get(unit, DYNRESETLIMPORTr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &rval,
                          DYNRESETLIMPORTf,
                          egress_dyn_reset_lim_port);
        soc_reg32_set(unit, DYNRESETLIMPORTr,
                      port, 0, rval);

        /* LWMCOSCELLSETLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, LWMCOSCELLSETLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLSETLIMITf,
                              egress_lwm_cell_set_limit);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &rval,
                              CELLRESETLIMITf,
                              egress_lwm_cell_reset_limit);
            soc_reg32_set(unit, LWMCOSCELLSETLIMITr,
                          port, index, rval);
        }

        /* HOLCOSCELLMAXLIMITr, index 0 ~ 7 */
        for (index = 0; index <= 7; index++) {
            soc_reg32_get(unit, HOLCOSCELLMAXLIMITr,
                          port, index, &rval);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXLIMITf,
                              egress_hol_cell_max_limit);
            soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &rval,
                              CELLMAXRESUMELIMITf,
                              egress_hol_cell_max_resume_limit);
            soc_reg32_set(unit, HOLCOSCELLMAXLIMITr,
                          port, index, rval);
        }

        /* DYNCELLLIMITr */
        soc_reg32_get(unit, DYNCELLLIMITr,
                      port, 0, &rval);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLSETLIMITf,
                          egress_dyn_cell_set_limit);
        soc_reg_field_set(unit, DYNCELLLIMITr, &rval,
                          DYNCELLRESETLIMITf,
                          egress_dyn_cell_reset_limit);
        soc_reg32_set(unit, DYNCELLLIMITr,
                      port, 0, rval);

        /* COLOR_DROP_ENr */
        soc_reg32_get(unit, COLOR_DROP_ENr,
                      port, 0, &rval);
        soc_reg_field_set(unit, COLOR_DROP_ENr, &rval,
                          COLOR_DROP_ENf,
                          0);
        soc_reg32_set(unit, COLOR_DROP_ENr,
                      port, 0, rval);

        /* SHARED_POOL_CTRLr */
        soc_reg32_get(unit, SHARED_POOL_CTRLr,
                      port, 0, &rval);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          DYNAMIC_COS_DROP_ENf,
                          0xff);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_DISCARD_ENf,
                          0);
        soc_reg_field_set(unit, SHARED_POOL_CTRLr, &rval,
                          SHARED_POOL_XOFF_ENf,
                          0);
        soc_reg32_set(unit, SHARED_POOL_CTRLr,
                      port, 0, rval);
    }

    return SOC_E_NONE;
}

STATIC int
_soc_hr3_mmu_init_lossless(int unit)
{
    int         cos;
    soc_port_t  port;
    uint32      val, oval, cfap_max_idx;
    int         skid_mark;
    uint32  dyn_xq_per_port;
    uint32  xq_limit, cell_limit;
    uint32      cos_min_xqs, cos_min_cells;
    uint16      dev_id;
    uint8       rev_id;
    int mmu_total_cells;
    int mmu_total_dyn_cells;
    int mmu_total_static_cells;
    int total_ports;
    uint32 max_cell_limit_pri0;
    uint32 max_cell_limit_pri1_7;
    uint32 dyn_cell_limit;
    uint32 xoff_cell_limit;
    uint32 reset_cell_limit;
    uint32 cell_resume_delta;
    uint32 dyn_cell_reset_delta;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    cfap_max_idx = soc_mem_index_max(unit, MMU_CFAPm);
    SOC_IF_ERROR_RETURN(READ_CFAPCONFIGr(unit, &val));
    oval = val;
    soc_reg_field_set(unit, CFAPCONFIGr, &val, CFAPPOOLSIZEf, cfap_max_idx);
    if (oval != val) {
        SOC_IF_ERROR_RETURN(WRITE_CFAPCONFIGr(unit, val));
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &val));
    /* set dyn_xq_en on */
    soc_reg_field_set(unit, MISCCONFIGr, &val, DYN_XQ_ENf, 1);
    /* set HOL_CELL_SOP_DROP_EN on */
    soc_reg_field_set(unit, MISCCONFIGr, &val, HOL_CELL_SOP_DROP_ENf, 1);
    /* set skidmarker to 3 */
    soc_reg_field_set(unit, MISCCONFIGr, &val, SKIDMARKERf, 3);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, val));

    /* Every inactive COSQ consumes skid mark + 4 XQs; remove them from pool */
    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &val));
    skid_mark = soc_reg_field_get(unit, MISCCONFIGr, val, SKIDMARKERf) + 4;

    /* Enable IP to CMICM credit transfer */
    val = 0;
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &val, TRANSFER_ENABLEf, 1);
    soc_reg_field_set(unit, IP_TO_CMICM_CREDIT_TRANSFERr, &val, NUM_OF_CREDITSf, 32);
    SOC_IF_ERROR_RETURN(WRITE_IP_TO_CMICM_CREDIT_TRANSFERr(unit, val));

    if (dev_id == BCM53434_DEVICE_ID) {
        /* Foxhound2 with 512 KB buffer */
        mmu_total_cells = FH2_MMU_BUFFER_SIZE_512KB / HR3_MMU_CELL_SIZE;
    } else {
        mmu_total_cells = HR3_MMU_BUFFER_SIZE_2MB / HR3_MMU_CELL_SIZE;
    }

    if (dev_id == BCM53443_DEVICE_ID) {
        total_ports = 13;
    } else if (dev_id == BCM56163_DEVICE_ID) {
        total_ports = 21;
    } else if ((dev_id == BCM56162_DEVICE_ID) ||
               (dev_id == BCM53442_DEVICE_ID) ||
               (dev_id == BCM56164_DEVICE_ID)) {
        total_ports = 29;
    } else if (dev_id == BCM53434_DEVICE_ID) {
        total_ports = 25;
    } else {
        /* 56160, 56166, 53440 */
        total_ports = 31;
    }

    mmu_total_static_cells = total_ports * HR3_MMU_IN_PORT_STATIC_CELLS;
    mmu_total_dyn_cells = mmu_total_cells - mmu_total_static_cells;

    /* total dynamic xqs - skid mark - 9(reserved xqs) */
    dyn_xq_per_port = HR3_MMU_IN_PORT_DYNAMIC_XQS -  skid_mark - 9;
    /* limit includes the static minimum cells as well */
    xq_limit = dyn_xq_per_port + HR3_MMU_IN_COS_MIN_XQS;
    cos_min_xqs = HR3_MMU_IN_COS_MIN_XQS;
    cos_min_cells = HR3_MMU_IN_COS_MIN_CELLS;

    cell_resume_delta = 12;
    dyn_cell_reset_delta = 24;
    xoff_cell_limit = 80;
    reset_cell_limit = 40;
    max_cell_limit_pri1_7 = 48;
    if (dev_id == BCM53443_DEVICE_ID) {
        max_cell_limit_pri0 = 3888;
    } else if (dev_id == BCM56163_DEVICE_ID) {
        max_cell_limit_pri0= 6480;
    } else if ((dev_id == BCM56162_DEVICE_ID) ||
               (dev_id == BCM53442_DEVICE_ID) ||
               (dev_id == BCM56164_DEVICE_ID)) {
        max_cell_limit_pri0 = 9072;
    } else if (dev_id == BCM53434_DEVICE_ID) {
        dyn_xq_per_port = FH2_MMU_IN_PORT_DYNAMIC_XQS -  skid_mark - 9;
        xq_limit = dyn_xq_per_port + FH2_MMU_IN_COS_MIN_XQS;
        cos_min_xqs = FH2_MMU_IN_COS_MIN_XQS;
        max_cell_limit_pri1_7 = 64;
        max_cell_limit_pri0= 2112;
        dyn_cell_reset_delta = 32;
        cell_resume_delta = 16;
        xoff_cell_limit = 40;
        reset_cell_limit = 30;
    } else {
        /* 56160, 56161, 53449, 53446 */
         max_cell_limit_pri0 = 9720;
    }

    dyn_cell_limit = max_cell_limit_pri0 + \
                     ((HR3_MMU_NUM_COS -1) * max_cell_limit_pri1_7);
    PBMP_ALL_ITER(unit, port) {

        for (cos = 0; cos < NUM_COS(unit); cos++) {
            /*
             * The HOLCOSPKTSETLIMITr register controls BOTH the XQ
             * size per cosq AND the HOL set limit for that cosq.
             */
            SOC_IF_ERROR_RETURN
                (READ_HOLCOSPKTSETLIMITr(unit, port, cos, &val));
            soc_reg_field_set(unit, HOLCOSPKTSETLIMITr, &val,
                              PKTSETLIMITf,
                              xq_limit);
            SOC_IF_ERROR_RETURN
                (WRITE_HOLCOSPKTSETLIMITr(unit, port, cos, val));

            /* reset limit is set limit - 4 */
            SOC_IF_ERROR_RETURN
                (READ_HOLCOSPKTRESETLIMITr(unit, port, cos, &val));
            soc_reg_field_set(unit, HOLCOSPKTRESETLIMITr, &val,
                              PKTRESETLIMITf,
                              xq_limit-4);
            SOC_IF_ERROR_RETURN
                (WRITE_HOLCOSPKTRESETLIMITr(unit, port, cos, val));

            val = 0;
            soc_reg_field_set(unit, HOLCOSMINXQCNTr, &val,
                              HOLCOSMINXQCNTf, cos_min_xqs);
            SOC_IF_ERROR_RETURN
                (WRITE_HOLCOSMINXQCNTr(unit, port, cos, val));

            val = 0;
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &val,
                              CELLSETLIMITf, cos_min_cells);
            soc_reg_field_set(unit, LWMCOSCELLSETLIMITr, &val,
                              CELLRESETLIMITf, cos_min_cells);
            SOC_IF_ERROR_RETURN
                (WRITE_LWMCOSCELLSETLIMITr(unit, port, cos, val));

            cell_limit = 0;
            if(!cos) {
                soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &cell_limit,
                                  CELLMAXLIMITf, max_cell_limit_pri0);
                soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &cell_limit,
                                  CELLMAXRESUMELIMITf, max_cell_limit_pri0 - cell_resume_delta);
            } else {
                if (IS_CPU_PORT(unit, port)) {
                    /* Ensure 9K bytes packets on queue 1-7 of CPU port */
                    soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &cell_limit,
                                      CELLMAXLIMITf, 72);
                    soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &cell_limit,
                                      CELLMAXRESUMELIMITf, 60);
                } else {
                    soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &cell_limit,
                                      CELLMAXLIMITf, max_cell_limit_pri1_7);
                    soc_reg_field_set(unit, HOLCOSCELLMAXLIMITr, &cell_limit,
                                      CELLMAXRESUMELIMITf, max_cell_limit_pri1_7 - cell_resume_delta);
                }
            }
            SOC_IF_ERROR_RETURN
                (WRITE_HOLCOSCELLMAXLIMITr(unit, port, cos, cell_limit));

            val = 0;
            soc_reg_field_set(unit, PGCELLLIMITr, &val,
                              CELLSETLIMITf, xoff_cell_limit);
            soc_reg_field_set(unit, PGCELLLIMITr, &val,
                              CELLRESETLIMITf, reset_cell_limit);
            SOC_IF_ERROR_RETURN
                (WRITE_PGCELLLIMITr(unit, port, cos, val));

            val = 0;
            soc_reg_field_set(unit, PGDISCARDSETLIMITr, &val,
                              DISCARDSETLIMITf, mmu_total_cells-1);
            SOC_IF_ERROR_RETURN
                (WRITE_PGDISCARDSETLIMITr(unit, port, cos, val));
        }

        val = 0;
        soc_reg_field_set(unit, DYNXQCNTPORTr, &val,
                          DYNXQCNTPORTf, dyn_xq_per_port);

        SOC_IF_ERROR_RETURN(WRITE_DYNXQCNTPORTr(unit, port, val));

        val = 0;
        soc_reg_field_set(unit, DYNRESETLIMPORTr, &val,
                          DYNRESETLIMPORTf, dyn_xq_per_port - 16);
        SOC_IF_ERROR_RETURN(WRITE_DYNRESETLIMPORTr(unit, port, val));

        val = 0;
        soc_reg_field_set(unit, DYNCELLLIMITr, &val,
                          DYNCELLSETLIMITf, dyn_cell_limit);
        soc_reg_field_set(unit, DYNCELLLIMITr, &val,
                          DYNCELLRESETLIMITf, dyn_cell_limit - dyn_cell_reset_delta);
        SOC_IF_ERROR_RETURN(WRITE_DYNCELLLIMITr(unit, port, val));

        cell_limit = 0;
        soc_reg_field_set(unit, TOTALDYNCELLSETLIMITr,
                          &cell_limit, TOTALDYNCELLSETLIMITf, mmu_total_dyn_cells);
        SOC_IF_ERROR_RETURN(WRITE_TOTALDYNCELLSETLIMITr(unit, cell_limit));
        cell_limit = 0;
        soc_reg_field_set(unit, TOTALDYNCELLRESETLIMITr,
                          &cell_limit, TOTALDYNCELLRESETLIMITf, mmu_total_dyn_cells - dyn_cell_reset_delta);
        SOC_IF_ERROR_RETURN(WRITE_TOTALDYNCELLRESETLIMITr(unit, cell_limit));

        val = 0;
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &val,
                        PKTSETLIMITf, HR3_MMU_IN_XOFF_PKT);
        soc_reg_field_set(unit, IBPPKTSETLIMITr, &val, RESETLIMITSELf, 0);
        SOC_IF_ERROR_RETURN(WRITE_IBPPKTSETLIMITr(unit, port, val));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_hurricane3_mmu_init(int unit)
{
    int         cos;
    soc_port_t  port;
    uint32      val;
    int         age[HR3_NUM_COS], max_age, min_age;
    int         age_enable, disabled_age;
    uint32      limit; /* E2EFC configuration */
    uint16      dev_id;
    uint8       rev_id;
    int i;

    soc_cm_get_id(unit, &dev_id, &rev_id);

    SOC_IF_ERROR_RETURN(_soc_hurricane3_tdm_init(unit, dev_id));

    if (soc_property_get(unit, spn_MMU_LOSSLESS, 0)) {
        SOC_IF_ERROR_RETURN(_soc_hr3_mmu_init_lossless(unit));
    } else {
        SOC_IF_ERROR_RETURN(_soc_hr3_mmu_init_lossy(unit));
    }

    if (!(dev_id == BCM53434_DEVICE_ID))  {
        PBMP_ALL_ITER(unit, port) {
            /* E2EFC configuration */
            if (IS_HG_PORT(unit, port)){
                SOC_IF_ERROR_RETURN(READ_IE2E_CONTROLr(unit, port, &val));
                soc_reg_field_set(unit, IE2E_CONTROLr, &val, IBP_ENABLEf, 1);
                SOC_IF_ERROR_RETURN(WRITE_IE2E_CONTROLr(unit, port, val));

                limit = 0;
                soc_reg_field_set(unit, E2EFC_CNT_SET_LIMITr, &limit,
                                    PKT_SET_LIMITf, 1456);
                soc_reg_field_set(unit, E2EFC_CNT_SET_LIMITr, &limit,
                                    CELL_SET_LIMITf, 9504);
                SOC_IF_ERROR_RETURN(WRITE_E2EFC_CNT_SET_LIMITr(unit, port, limit));

                limit = 0;
                soc_reg_field_set(unit, E2EFC_CNT_RESET_LIMITr, &limit,
                                    PKT_RESET_LIMITf, 1456);
                soc_reg_field_set(unit, E2EFC_CNT_RESET_LIMITr, &limit,
                                    CELL_RESET_LIMITf, 9504);
                SOC_IF_ERROR_RETURN(WRITE_E2EFC_CNT_RESET_LIMITr(unit, port, limit));

                limit = 0;
                soc_reg_field_set(unit, E2EFC_CNT_DISC_LIMITr, &limit,
                                    PKT_DISC_LIMITf, 1456);
                soc_reg_field_set(unit, E2EFC_CNT_DISC_LIMITr, &limit,
                                    CELL_DISC_LIMITf, 9504);
                SOC_IF_ERROR_RETURN(WRITE_E2EFC_CNT_DISC_LIMITr(unit, port, limit));
            } else {
                limit = 0;
                soc_reg_field_set(unit, E2EFC_CNT_SET_LIMITr, &limit,
                                    PKT_SET_LIMITf, 12);
                soc_reg_field_set(unit, E2EFC_CNT_SET_LIMITr, &limit,
                                    CELL_SET_LIMITf, 80);
                SOC_IF_ERROR_RETURN(WRITE_E2EFC_CNT_SET_LIMITr(unit, port, limit));

                limit = 0;
                soc_reg_field_set(unit, E2EFC_CNT_RESET_LIMITr, &limit,
                                    PKT_RESET_LIMITf, 9);
                soc_reg_field_set(unit, E2EFC_CNT_RESET_LIMITr, &limit,
                                    CELL_RESET_LIMITf, 60);
                SOC_IF_ERROR_RETURN(WRITE_E2EFC_CNT_RESET_LIMITr(unit, port, limit));

                limit = 0;
                soc_reg_field_set(unit, E2EFC_CNT_DISC_LIMITr, &limit,
                                    PKT_DISC_LIMITf, 1456);
                soc_reg_field_set(unit, E2EFC_CNT_DISC_LIMITr, &limit,
                                    CELL_DISC_LIMITf, 9504);
                SOC_IF_ERROR_RETURN(WRITE_E2EFC_CNT_DISC_LIMITr(unit, port, limit));
            }
        }

        /* E2EFC configuration */
        SOC_IF_ERROR_RETURN(READ_E2EFC_IBP_ENr(unit, &val));
        soc_reg_field_set(unit, E2EFC_IBP_ENr, &val, ENf, 1);
        SOC_IF_ERROR_RETURN(WRITE_E2EFC_IBP_ENr(unit, val));

        for (i = 0; i < SOC_REG_NUMELS(unit, E2EFC_HG_MIN_TX_TIMERr); i++) {
            SOC_IF_ERROR_RETURN(READ_E2EFC_HG_MIN_TX_TIMERr(unit, i, &val));
            soc_reg_field_set(unit, E2EFC_HG_MIN_TX_TIMERr, &val, LGf, 0);
            soc_reg_field_set(unit, E2EFC_HG_MIN_TX_TIMERr, &val, TIMERf, 64);
            SOC_IF_ERROR_RETURN(WRITE_E2EFC_HG_MIN_TX_TIMERr(unit, i, val));
        }

        for (i = 0; i < SOC_REG_NUMELS(unit, E2EFC_HG_MAX_TX_TIMERr); i++) {
            SOC_IF_ERROR_RETURN(READ_E2EFC_HG_MAX_TX_TIMERr(unit, i, &val));
            soc_reg_field_set(unit, E2EFC_HG_MAX_TX_TIMERr, &val, LGf, 1);
            soc_reg_field_set(unit, E2EFC_HG_MAX_TX_TIMERr, &val, TIMERf, 640);
            SOC_IF_ERROR_RETURN(WRITE_E2EFC_HG_MAX_TX_TIMERr(unit, i, val));
        }
    }

    /*
     * Configure per-XQ packet aging for the various COSQs.
     *
     * The shortest age allowed by H/W is 250 microseconds.
     * The longest age allowed is 7.162 seconds (7162 msec).
     * The maximum ratio between the longest age and the shortest
     * (nonzero) age is 7:2.
     */
    age_enable = disabled_age = max_age = 0;
    min_age = 7162;
    for (cos = 0; cos < NUM_COS(unit); cos++) {
        if ((age[cos] =
             soc_property_suffix_num_get(unit, cos, spn_MMU_XQ_AGING,
                                         "cos",  0)) > 0) {
            age_enable = 1;
            if (age[cos] > 7162) {
                age[cos] = 7162;
            }
            if (age[cos] < min_age) {
                min_age = age[cos];
            }
        } else {
            disabled_age = 1;
            age[cos] = 0;
        }
        if (age[cos] > max_age) {
            max_age = age[cos];
        }
    }
    if (!age_enable) {
        /* Disable packet aging on all COSQs */
        SOC_IF_ERROR_RETURN(WRITE_PKTAGINGTIMERr(unit, 0));
        SOC_IF_ERROR_RETURN(WRITE_PKTAGINGLIMITr(unit, 0)); /* Aesthetic */
    } else {
        uint32 regval = 0;
        uint32 timerval;

        /* Enforce the 7:2 ratio between min and max values */
        if ((((max_age * 2)+6) / 7) > min_age) {
            /* Keep requested max age; make min_age comply */
            min_age = ((max_age * 2) + 6) / 7;
        }

        /*
         * Give up granularity for range, if we need to
         * "disable" (max out) aging for any COSQ(s).
         */
        if (disabled_age) {
            /* Max range */
            max_age = min_age * 7 / 2;
        }

        /*
         * Compute shortest duration of one PKTAGINGTIMERr cycle.
         * This duration is 1/7th of the longest packet age.
         * This duration is in units of 125 usec (msec * 8).
         */
        timerval = ((8 * max_age) + 6) / 7;
        SOC_IF_ERROR_RETURN(WRITE_PKTAGINGTIMERr(unit, timerval));

        for (cos = 0; cos < NUM_COS(unit); cos++) {
            if (!age[cos]) {
                /*
                 * Requested to be disabled, but cannot disable individual
                 * COSQs once packet aging is enabled. Therefore, mark
                 * this COSQ's aging duration as maxed out.
                 */
                age[cos] = -1;
            } else if (age[cos] < min_age) {
                age[cos] = min_age;
            }

            /* Normalize each "age" into # of PKTAGINGTIMERr cycles. */
        if (age[cos] > 0) {
            /* coverity[divide_by_zero : FALSE] */
            age[cos] = ((8 * age[cos]) + timerval - 1) / timerval;
        }
        else {
            age[cos] = 7;
        }
            /* Format each "age" for its appropriate field */
            regval |= ((7 - age[cos]) << (cos * 3));
        }
        SOC_IF_ERROR_RETURN(WRITE_PKTAGINGLIMITr(unit, regval));
    }

    /*
     * Port enable
     */
    val = 0;
    soc_reg_field_set(unit, MMUPORTENABLEr, &val, MMUPORTENABLEf,
                      SOC_PBMP_WORD_GET(PBMP_ALL(unit), 0));
    SOC_IF_ERROR_RETURN(WRITE_MMUPORTENABLEr(unit, val));

    return SOC_E_NONE;
}

/* soc_hurricane3_tsc_core_reset()
 *  - to reset TSCE or QTC on Hurricane3
 */
int
soc_hurricane3_tsc_core_reset(int unit, int port, int reset_delay_us)
{
    int phy_id, block_idx, is_qtc;

    phy_id = SOC_INFO(unit).port_l2p_mapping[port];
    if (phy_id <= 17 && phy_id>=2) {
        block_idx = 13;
        is_qtc = 1;
    } else if (phy_id <=33 && phy_id >=18) {
        block_idx = 14;
        is_qtc = 1;
    } else if (phy_id <=37 && phy_id >=34) {
        is_qtc = 0;
    } else if (phy_id <=39 && phy_id >=38) {
        is_qtc = 0;
    } else {
        return SOC_E_PARAM;
    }

    if (is_qtc) {
        block_idx = block_idx | SOC_REG_ADDR_BLOCK_ID_MASK;
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, block_idx, 0));
    } else {
        /* TSCE */
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }
    return SOC_E_NONE;
}

/* soc_hurricane3_tsc_reset()
 *  - to reset TSCE and QTC on Hurricane3
 */
int
soc_hurricane3_tsc_reset(int unit)
{
    int blk, port;
    uint32 rval;

    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_NONE;
    }
    if (soc_feature(unit, soc_feature_wh2)) {
        return soc_wolfhound2_port_reset(unit);
    }
    /* Reset QTC */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_PMQ) {
        port = blk | SOC_REG_ADDR_BLOCK_ID_MASK;
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    /* Reset TSCE */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        SOC_IF_ERROR_RETURN(soc_tsc_xgxs_reset(unit, port, 0));
    }

    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1 || port == REG_PORT_ANY) {
            continue;
        }
        SOC_IF_ERROR_RETURN(READ_XLPORT_MAC_CONTROLr(unit, port, &rval));
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 1);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
        sal_udelay(10);
        soc_reg_field_set(unit, XLPORT_MAC_CONTROLr, &rval, XMAC0_RESETf, 0);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MAC_CONTROLr(unit, port, rval));
    }

    return SOC_E_NONE;
}

/* soc_hurricane3_sbus_tsc_block()
 *  - to report the valid blk of this port for wc_ucmem_data
 *      (i.e. GPORT/XLPORT_WC_UCMEM_DATAm)access process.
 *
 *  - Parameters :
 *      phy_port(IN) : physical port.
 *      blk(OUT) : the valid block
 */
int
soc_hurricane3_sbus_tsc_block(int unit, int phy_port, int *blk)
{
    soc_info_t *si = &SOC_INFO(unit);

    if (SOC_PORT_BLOCK_TYPE(unit, phy_port) == SOC_BLK_GPORT) {
        if ((phy_port >= qtc_phy_port[0]) &&
            (phy_port < qtc_phy_port[1])) {
            *blk = si->pmq_block[0];
        } else if ((phy_port >= qtc_phy_port[1]) &&
                   (phy_port < tsc_phy_port[0])) {
            *blk = si->pmq_block[1];
        } else {
            return SOC_E_PARAM;
        }
    } else {
        *blk = SOC_PORT_BLOCK(unit, phy_port);
    }

    return SOC_E_NONE;
}

extern int (*_phy_tsce_firmware_set_helper[SOC_MAX_NUM_DEVICES])(int, int, uint8 *, int);
extern int (*_phy_qtce_firmware_set_helper[SOC_MAX_NUM_DEVICES])(int, int, uint8 *, int);

STATIC int
_soc_hurricane3_tscx_firmware_set(int unit, int port, uint8 *array, int datalen)
{
    soc_mem_t mem = IS_XL_PORT(unit, port) ?
                    XLPORT_WC_UCMEM_DATAm : GPORT_WC_UCMEM_DATAm;
    soc_reg_t reg = IS_XL_PORT(unit, port) ?
                    XLPORT_WC_UCMEM_CTRLr : GPORT_WC_UCMEM_CTRLr;

    return soc_warpcore_firmware_set(unit, port, array, datalen, 0, mem, reg);
}

#define TSC_REG_ADDR_TSCID_SET(_phy_reg, _phyad)    \
                            ((_phy_reg) |= ((_phyad) & 0x1f) << 19)

STATIC int
_soc_hurricane3_mdio_addr_to_port(uint32 phy_addr)
{
    int bus, offset;
    int mdio_addr;

    /* Must be internal MDIO address */
    if ((phy_addr & 0x80) == 0) {
        return 0;
    }

    bus = PHY_ID_BUS_NUM(phy_addr);
    mdio_addr = phy_addr & 0x1f;

    if (bus == 0) {
        if (mdio_addr <= 0x8) {
            offset = 9;
        } else {
            offset = 17;
        }
    } else if (bus == 1) {
        if (mdio_addr <= 0x8) {
            offset = 33;
        } else if (mdio_addr <= 0xc) {
            offset = -7;
        } else {
            offset = 5;
        }
    } else {
        return 0;
    }

    return mdio_addr + offset;
}

STATIC int
_soc_hurricane3_tscx_reg_read(int unit, uint32 phy_addr,
                            uint32 phy_reg, uint32 *phy_data)
{
    int rv, blk, port;
    int phy_port = _soc_hurricane3_mdio_addr_to_port(phy_addr);

    port = SOC_INFO(unit).port_p2l_mapping[phy_port];

    SOC_IF_ERROR_RETURN
        (soc_hurricane3_sbus_tsc_block(unit, phy_port, &blk));

    LOG_INFO(BSL_LS_SOC_MII,
             (BSL_META_U(unit,
                         "soc_hurricane3_tscx_reg_read[%d]: 0x%X/0x%X/%d/%d/%d\n"),
              unit, phy_addr, phy_reg,phy_port, port, blk));

    TSC_REG_ADDR_TSCID_SET(phy_reg, phy_addr);
    rv = soc_sbus_tsc_reg_read(unit, port, blk, phy_addr,
                               phy_reg, phy_data);

    return rv;
}

STATIC int
_soc_hurricane3_tscx_reg_write(int unit, uint32 phy_addr,
                             uint32 phy_reg, uint32 phy_data)
{
    int rv, blk, port;
    int phy_port = _soc_hurricane3_mdio_addr_to_port(phy_addr);

    port = SOC_INFO(unit).port_p2l_mapping[phy_port];

    SOC_IF_ERROR_RETURN
        (soc_hurricane3_sbus_tsc_block(unit, phy_port, &blk));

    LOG_INFO(BSL_LS_SOC_MII,
             (BSL_META_U(unit,
                         "soc_hurricane3_tscx_reg_read[%d]: 0x%X/0x%X/%d/%d/%d\n"),
              unit, phy_addr, phy_reg, phy_port, port, blk));

    TSC_REG_ADDR_TSCID_SET(phy_reg, phy_addr);
    rv = soc_sbus_tsc_reg_write(unit, port, blk, phy_addr,
                                phy_reg, phy_data);

    return rv;
}

#define NUM_XLPORT 4

/*
 * Function:
 *      _soc_hurricane3_mib_reset()
 * Purpose:
 *      Reset MIB counter
 */
STATIC int
_soc_hurricane3_mib_reset(int unit)
{
    uint32 rval, fval;
    int blk, bindex;
    soc_info_t *si = &SOC_INFO(unit);
    int blk_port, phy_port;

    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_NONE;
    }

    /* Reset XLPORT MIB counter (registers implemented in memory). The clear
     * function is implemented with read-modify-write, parity needs to be
     * disabled */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        blk_port = SOC_BLOCK_PORT(unit, blk);
        if (blk_port < 0) {
            continue;
        }
        phy_port = si->port_l2p_mapping[blk_port];
        fval = 0;
        for (bindex = 0; bindex < 4; bindex++) {
            if (si->port_p2l_mapping[phy_port + bindex] != -1) {
                fval |= 1 << bindex;
            }
        }
        rval = 0;
        soc_reg_field_set(unit, XLPORT_MIB_RESETr, &rval, CLR_CNTf, fval);
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MIB_RESETr(unit, blk_port, rval));
        SOC_IF_ERROR_RETURN(WRITE_XLPORT_MIB_RESETr(unit, blk_port, 0));
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      _soc_hurricane3_gport_tdm_mode_init()
 * Purpose:
 *      Initialize the TDM mode of each PGW_GE blocks
 */
STATIC int
_soc_hurricane3_gport_tdm_mode_init(int unit)
{
    uint32 rval, fval;
    int blk, bindex;
    int blk_port;

    /* Confiure the GPORT GP0/GP1 bus TDM mode */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_PGW_GE) {
        bindex = SOC_BLOCK_NUMBER(unit, blk);
        blk_port = bindex | SOC_REG_ADDR_INSTANCE_MASK;
        /* port 0 ~port 7 */
        SOC_IF_ERROR_RETURN(READ_PGW_GE0_MODE_REGr(unit, blk_port, &rval));
        fval = 0;
        switch (_hr3_qtc_gport_port_count[bindex][0]) {
            case SOC_HR3_PORT_RATIO_OCTAL:
                fval = 8;
                break;
            case SOC_HR3_PORT_RATIO_QUAD:
                fval = 4;
                break;
            case SOC_HR3_PORT_RATIO_DUAL_1_1:
                fval = 2;
                break;
            case SOC_HR3_PORT_RATIO_SINGLE:
                fval = 1;
                break;
            default:
                break;
        }
        soc_reg_field_set(unit, PGW_GE0_MODE_REGr, &rval, GP0_TDM_MODEf, fval);
        SOC_IF_ERROR_RETURN(WRITE_PGW_GE0_MODE_REGr(unit, blk_port, rval));

        /* port 8 ~ port 15 */
        SOC_IF_ERROR_RETURN(READ_PGW_GE1_MODE_REGr(unit, blk_port, &rval));
        fval = 0;
        switch (_hr3_qtc_gport_port_count[bindex][1]) {
            case SOC_HR3_PORT_RATIO_OCTAL:
                fval = 8;
                break;
            case SOC_HR3_PORT_RATIO_QUAD:
                fval = 4;
                break;
            case SOC_HR3_PORT_RATIO_DUAL_1_1:
                fval = 2;
                break;
            case SOC_HR3_PORT_RATIO_SINGLE:
                fval = 1;
                break;
            default:
                break;
        }
        soc_reg_field_set(unit, PGW_GE0_MODE_REGr, &rval, GP0_TDM_MODEf, fval);
        SOC_IF_ERROR_RETURN(WRITE_PGW_GE1_MODE_REGr(unit, blk_port, rval));
    }

    return SOC_E_NONE;
}


/*
 * Function:
 *      _soc_hurricane3_gmac_init()
 * Purpose:
 *      To init GMAC (should be moved to mac)
 */
STATIC int
_soc_hurricane3_gmac_init(int unit)
{
    uint32 rval;
    uint32 prev_reg_addr;
    int port;

    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_NONE;
    }

    rval = 0;
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 1);
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, GPORT_ENf, 1);

    prev_reg_addr = 0xffffffff;
    PBMP_E_ITER(unit, port) {
        uint32  reg_addr;
        if (IS_XL_PORT(unit, port)) {
            continue;
        }

        reg_addr = soc_reg_addr(unit, GPORT_CONFIGr, port, 0);
        if (reg_addr != prev_reg_addr) {
            SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
            prev_reg_addr = reg_addr;
        }
    }

    prev_reg_addr = 0xffffffff;
    soc_reg_field_set(unit, GPORT_CONFIGr, &rval, CLR_CNTf, 0);
    PBMP_E_ITER(unit, port) {
        uint32  reg_addr;
        if (IS_XL_PORT(unit, port)) {
            continue;
        }

        reg_addr = soc_reg_addr(unit, GPORT_CONFIGr, port, 0);
        if (reg_addr != prev_reg_addr) {
            SOC_IF_ERROR_RETURN(WRITE_GPORT_CONFIGr(unit, port, rval));
            prev_reg_addr = reg_addr;
        }
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      _soc_hurricane3_higig_mode_init()
 * Purpose:
 *      To init the default Higig mode for HG port
 */
STATIC int
_soc_hurricane3_higig_mode_init(int unit)
{
    uint32 rval;
    int port;

    PBMP_PORT_ITER(unit, port) {
        if (!IS_HG_PORT(unit, port)) {
            continue;
        }

        if (!SOC_USE_PORTCTRL(unit)) {
            /* Section below is used to config XLPORT HiGig encap
             * setting for normal init process.
             */
            SOC_IF_ERROR_RETURN(READ_XLPORT_CONFIGr(unit, port, &rval));
            soc_reg_field_set(unit, XLPORT_CONFIGr, &rval, HIGIG_MODEf, 1);
            SOC_IF_ERROR_RETURN(WRITE_XLPORT_CONFIGr(unit, port, rval));
        }

        /* PGW encap setting */
        SOC_IF_ERROR_RETURN(soc_greyhound_pgw_encap_field_modify(unit,
                port, HIGIG_MODEf, 1));
    }

    return SOC_E_NONE;
}

/*
 * Function:
 *      _soc_hurricane3_xlport_init()
 * Purpose:
 *      To init the XLPORT block
 * Parameters :
 *      blk(IN): XLPORT block
 *      mode(IN): port mode. SOC_HR3_PORT_MODE_XXX.
 */
STATIC int
_soc_hurricane3_xlport_init(int unit, int blk, int mode)
{
    static const soc_field_t port_field[] = {
        PORT0f, PORT1f, PORT2f, PORT3f
    };
    uint32 rval;
    int port;
    int phy_port_base;
    int bindex;
    soc_info_t *si = &SOC_INFO(unit);


    if (SOC_USE_PORTCTRL(unit)) {
        return SOC_E_NONE;
    }

    port = SOC_BLOCK_PORT(unit, blk);
    if (port == -1 || port == REG_PORT_ANY) {
        return SOC_E_PARAM;
    }

    phy_port_base = si->port_l2p_mapping[port];

    /* Assert XLPORT soft reset */
    rval = 0;
    for (bindex = 0; bindex < NUM_XLPORT; bindex++) {
        if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
            soc_reg_field_set(unit, XLPORT_SOFT_RESETr, &rval,
                              port_field[bindex], 1);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, rval));

    /* Set XLPORT mode */
    rval = 0;
    soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                      XPORT0_CORE_PORT_MODEf, mode);
    soc_reg_field_set(unit, XLPORT_MODE_REGr, &rval,
                      XPORT0_PHY_PORT_MODEf, mode);
    SOC_IF_ERROR_RETURN(WRITE_XLPORT_MODE_REGr(unit, port, rval));

    /* De-assert XLPORT soft reset */
    SOC_IF_ERROR_RETURN(WRITE_XLPORT_SOFT_RESETr(unit, port, 0));

    /* Enable XLPORT */
    rval = 0;
    for (bindex = 0; bindex < NUM_XLPORT; bindex++) {
        if (si->port_p2l_mapping[phy_port_base + bindex] != -1) {
            soc_reg_field_set(unit, XLPORT_ENABLE_REGr, &rval,
                              port_field[bindex], 1);
        }
    }
    SOC_IF_ERROR_RETURN(WRITE_XLPORT_ENABLE_REGr(unit, port, rval));

    return SOC_E_NONE;
}

#define _hr3_get_pval(_map_, _idx_, _max_num_) \
    ((_idx_ < _max_num_) ? _map_[_idx_]: 0)

#define _HR3_PGW_COUNT_GE       (2)
#define _HR3_PORTS_PER_PGW_GE   (16)
#define _HR3_FIRST_PORT_PGW_GE0 (2)
#define _HR3_PGW_COUNT_XL       (2)
#define _HR3_PORTS_PER_PGW_XL   (4)
#define _HR3_FIRST_PORT_PGW_XL0 (34)

STATIC int
_soc_hurricane3_ledup_init(int unit)
{
    int i, j, pval0, pval1, pval2, pval3, port_idx;
    uint32 led_remap[64] = {0}, port_cnt = 0, rval = 0, disable_4x10 = 0;

    struct led_remap_t {
       uint32 reg_addr;
       uint32 port0;
       uint32 port1;
       uint32 port2;
       uint32 port3;
    } ledup0_remap_r[] = {
        {CMIC_LEDUP0_PORT_ORDER_REMAP_0_3r,
         REMAP_PORT_0f, REMAP_PORT_1f, REMAP_PORT_2f, REMAP_PORT_3f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_4_7r,
         REMAP_PORT_4f, REMAP_PORT_5f, REMAP_PORT_6f, REMAP_PORT_7f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_8_11r,
         REMAP_PORT_8f, REMAP_PORT_9f, REMAP_PORT_10f, REMAP_PORT_11f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_12_15r,
         REMAP_PORT_12f, REMAP_PORT_13f, REMAP_PORT_14f, REMAP_PORT_15f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_16_19r,
         REMAP_PORT_16f, REMAP_PORT_17f, REMAP_PORT_18f, REMAP_PORT_19f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_20_23r,
         REMAP_PORT_20f, REMAP_PORT_21f, REMAP_PORT_22f, REMAP_PORT_23f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_24_27r,
         REMAP_PORT_24f, REMAP_PORT_25f, REMAP_PORT_26f, REMAP_PORT_27f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_28_31r,
         REMAP_PORT_28f, REMAP_PORT_29f, REMAP_PORT_30f, REMAP_PORT_31f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_32_35r,
         REMAP_PORT_32f, REMAP_PORT_33f, REMAP_PORT_34f, REMAP_PORT_35f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_36_39r,
         REMAP_PORT_36f, REMAP_PORT_37f, REMAP_PORT_38f, REMAP_PORT_39f},
        {CMIC_LEDUP0_PORT_ORDER_REMAP_40_43r,
         REMAP_PORT_40f, REMAP_PORT_41f, REMAP_PORT_42f, REMAP_PORT_43f}
    };

    /* The LED scanning out order is
     *  PGW_XL1(41->38) -> PGW_XL0(37->34) -> PGW_GE1(18->33) -> PGW_GE0(2->17)
     *  If PM4x10 is ON, PGW_XL will output 4 bytes LED status to the LED chain.
     *  If PM4x10 is OFF, PGW_XL will output 1 byte to the LED chain.
     *  PGW_GE always outputs 16 bytes.
     */

    SOC_IF_ERROR_RETURN(READ_PGW_CTRL_0r(unit, &rval));
    disable_4x10 = soc_reg_field_get(unit, PGW_CTRL_0r,
                                     rval, SW_PM4X10_DISABLEf);

    /* PGW_XL1 -> PGW_XL0 */
    for (i = _HR3_PGW_COUNT_XL - 1; i >= 0; i--) {
        if (disable_4x10 & (1 << i)) {
            /* For PGW_XL, shift out 1 byte if PM4x10 is disabled */
            led_remap[port_cnt++] = 0;
        } else {
            /* For PGW_XL, port 3 is shifted out first and port 0 is the last */
            for (j = _HR3_PORTS_PER_PGW_XL - 1; j >= 0; j--) {
                led_remap[port_cnt++] =
                    _HR3_FIRST_PORT_PGW_XL0 + _HR3_PORTS_PER_PGW_XL * i + j;
            }
        }
    }

    /* PGW_GE1 -> PGW_GE0 */
    for (i = _HR3_PGW_COUNT_GE - 1; i >= 0; i--) {
        /* For PGW_GE, port 0 is shifted out first and port 15 is the last */
        for (j = 0; j < _HR3_PORTS_PER_PGW_GE; j++) {
            led_remap[port_cnt++] =
                _HR3_FIRST_PORT_PGW_GE0 + _HR3_PORTS_PER_PGW_GE * i + j;
        }
    }

    /* Setup CMIC_LEDUP0_PORT_ORDER_REMAP registers */
    for (i = 0; i < sizeof(ledup0_remap_r)/sizeof(ledup0_remap_r[0]); i++) {
        port_idx = i * 4;
        pval0 = _hr3_get_pval(led_remap, port_idx, port_cnt);
        pval1 = _hr3_get_pval(led_remap, port_idx + 1, port_cnt);
        pval2 = _hr3_get_pval(led_remap, port_idx + 2, port_cnt);
        pval3 = _hr3_get_pval(led_remap, port_idx + 3, port_cnt);

        rval = 0;
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                         ledup0_remap_r[i].port0, pval0);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                         ledup0_remap_r[i].port1, pval1);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                         ledup0_remap_r[i].port2, pval2);
        soc_reg_field_set(unit, ledup0_remap_r[i].reg_addr, &rval,
                         ledup0_remap_r[i].port3, pval3);

        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN
            (soc_pci_write(unit,
                soc_reg_addr(unit, ledup0_remap_r[i].reg_addr, REG_PORT_ANY, 0),
                rval));
    }

    /* Initialize the LEDuP0 data ram */
    rval = 0;
    for (i = 0; i < 256; i++) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_LEDUP0_DATA_RAMr(unit, i, rval));
    }

    return SOC_E_NONE;
}

STATIC int
_soc_hurricane3_misc_init(int unit)
{
    uint32              rval, fval, l2_ovf_enable, l2_tbl_size;
    uint64              reg64;
    int                 port;
    uint32 entry[SOC_MAX_MEM_WORDS];
    soc_field_t         fields[3];
    uint32              values[3];
    int blk, mode;
    int phy_port_base;
    soc_info_t *si = &SOC_INFO(unit);
    int delay;
    int freq, target_freq, divisor, dividend;
    int parity_enable;
    char *board_name;

    if (!SOC_IS_RELOADING(unit) && !SOC_WARM_BOOT(unit)) {
        /* Clear IPIPE/EIPIE Memories */
        SOC_IF_ERROR_RETURN(soc_hurricane3_pipe_mem_clear(unit));

        /* GPORT bus TDM mode */
        SOC_IF_ERROR_RETURN(_soc_hurricane3_gport_tdm_mode_init(unit));

        /* Clear MIB counter */
        SOC_IF_ERROR_RETURN(_soc_hurricane3_mib_reset(unit));
    }

    SOC_IF_ERROR_RETURN(soc_hurricane3_init_port_mapping(unit));

    parity_enable = soc_property_get(unit, spn_PARITY_ENABLE, TRUE);
    /* Do the ser register w/o checking parity_enable.
      OAM and l2 overflow interrupt will be dispatched from
      _soc_ser_parity_error_cmicm_intr_f  */
    soc_hr3_ser_register(unit);
    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_hr3_tcam_ser_init(unit));
        /* Enabling the packet drop when parity error occurred */
        SOC_IF_ERROR_RETURN(READ_IPIPE_PERR_CONTROLr(unit, &rval));
        fval = 1;
        soc_reg_field_set(unit, IPIPE_PERR_CONTROLr, &rval, DROPf, fval);
        SOC_IF_ERROR_RETURN(WRITE_IPIPE_PERR_CONTROLr(unit, rval));
        SOC_IF_ERROR_RETURN(soc_hr3_ser_enable_all(unit, TRUE));
#if defined(SER_TR_TEST_SUPPORT)
        soc_hr3_ser_test_register(unit);
#endif /* SER_TR_TEST_SUPPORT */
    } else {
        SOC_IF_ERROR_RETURN(soc_hr3_ser_enable_all(unit, FALSE));
    }

    /* Enable L2 overflow bucket */
    l2_tbl_size = soc_property_get(unit, spn_L2_TABLE_SIZE, FALSE);
    if (l2_tbl_size == (soc_mem_index_count(unit, L2Xm) +
                            soc_mem_index_count(unit, L2_ENTRY_OVERFLOWm))) {
        /*
         * if l2 table size equals to l2 table size + l2 overflow table size,
         * it indicates the l2 overflow table is enabled.
         */
        l2_ovf_enable = 1;
    } else {
        l2_ovf_enable = 0;
    }
    SOC_IF_ERROR_RETURN(READ_L2_LEARN_CONTROLr(unit, &rval));
    soc_reg_field_set(unit, L2_LEARN_CONTROLr, &rval,
            OVERFLOW_BUCKET_ENABLEf, l2_ovf_enable);
    SOC_IF_ERROR_RETURN(WRITE_L2_LEARN_CONTROLr(unit, rval));
    SOC_CONTROL_LOCK(unit);
    SOC_CONTROL(unit)->l2_overflow_bucket_enable = l2_ovf_enable;
    SOC_CONTROL_UNLOCK(unit);

    /* Enable L2 overflow interrupt */
    if(soc_property_get(unit, spn_L2_OVERFLOW_EVENT, FALSE)) {

        SOC_CONTROL_LOCK(unit);
        SOC_CONTROL(unit)->l2_overflow_enable = TRUE;
        SOC_CONTROL_UNLOCK(unit);
        SOC_IF_ERROR_RETURN(soc_hr3_l2_overflow_start(unit));
    } else {
        SOC_CONTROL_LOCK(unit);
        SOC_CONTROL(unit)->l2_overflow_enable = FALSE;
        SOC_CONTROL_UNLOCK(unit);
        SOC_IF_ERROR_RETURN(soc_hr3_l2_overflow_stop(unit));
    }

    /* If parity is not enabled, enable the l2 overflow interrupt */
    if (!soc_property_get(unit, spn_PARITY_ENABLE, TRUE)) {
        /* Write CMIC enable register */
        (void)soc_cmicm_intr3_enable(unit,
                    CMIC_PARITY_IP1_TO_CMIC_PERR_INTR_BIT);
    }

    /* GMAC init should be moved to mac */
    SOC_IF_ERROR_RETURN(_soc_hurricane3_gmac_init(unit));

    /* HG init */
    SOC_IF_ERROR_RETURN(_soc_hurricane3_higig_mode_init(unit));

    /* XLPORT blocks init */
    SOC_BLOCK_ITER(unit, blk, SOC_BLK_XLPORT) {
        int port_count = -1, i;

        port = SOC_BLOCK_PORT(unit, blk);
        if (port == -1 || port == REG_PORT_ANY) {
            continue;
        }
        phy_port_base = si->port_l2p_mapping[port];

        for(i=0; i <_HR3_MAX_TSC_COUNT ; i++){
            if(_hr3_tsc[i].phy_port_base == phy_port_base){
                port_count = _hr3_tsc[i].port_count;
                break;
            }
        }

        if (port_count == SOC_HR3_PORT_RATIO_QUAD){
            mode = SOC_HR3_PORT_MODE_QUAD;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
            si->port_num_lanes[port + 3] = 1;
        } else if ((port_count == SOC_HR3_PORT_RATIO_SINGLE) ||
            (port_count == SOC_HR3_PORT_RATIO_SINGLE_XAUI)) {
            mode = SOC_HR3_PORT_MODE_SINGLE;
            si->port_num_lanes[port] = 4;
            si->port_num_lanes[port + 1] = -1;
            si->port_num_lanes[port + 2] = -1;
            si->port_num_lanes[port + 3] = -1;
        } else if (port_count == SOC_HR3_PORT_RATIO_DUAL_2_2) {
            mode = SOC_HR3_PORT_MODE_DUAL;
            si->port_num_lanes[port] = 2;
            si->port_num_lanes[port + 1] = 2;
            si->port_num_lanes[port + 2] = -1;
            si->port_num_lanes[port + 3] = -1;
        } else if (port_count == SOC_HR3_PORT_RATIO_TRI_012_1_1_2){
            mode = SOC_HR3_PORT_MODE_TRI_012;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 2;
            si->port_num_lanes[port + 3] = -1;
            if (si->port_p2l_mapping[phy_port_base] != -1) {
                si->port_num_lanes[port] = 1;
            }
            if (si->port_p2l_mapping[phy_port_base + 1] != -1) {
                si->port_num_lanes[++port] = 1;
            }
            if (si->port_p2l_mapping[phy_port_base + 2] != -1) {
                si->port_num_lanes[++port] = 2;
            }
            si->port_num_lanes[++port] = -1;
        } else {
            mode = SOC_HR3_PORT_MODE_QUAD;
            si->port_num_lanes[port] = 1;
            si->port_num_lanes[port + 1] = 1;
            si->port_num_lanes[port + 2] = 1;
            si->port_num_lanes[port + 3] = 1;
        }

        SOC_IF_ERROR_RETURN(_soc_hurricane3_xlport_init(unit, blk, mode));
    }

    SOC_IF_ERROR_RETURN(READ_MISCCONFIGr(unit, &rval));
    soc_reg_field_set(unit, MISCCONFIGr, &rval, METERING_CLK_ENf, 1);
    SOC_IF_ERROR_RETURN(WRITE_MISCCONFIGr(unit, rval));

    /* Enable dual hash on L2 and L3 tables */
    fields[0] = ENABLEf;
    values[0] = 1;
    fields[1] = HASH_SELECTf;
    values[1] = FB_HASH_CRC32_LOWER;
    fields[2] = INSERT_LEAST_FULL_HALFf;
    values[2] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L2_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, L3_AUX_HASH_CONTROLr, REG_PORT_ANY, 3,
                                 fields, values));

    /*
     * Egress Enable
     */
    sal_memset(entry, 0, sizeof(egr_enable_entry_t));
    soc_mem_field32_set(unit, EGR_ENABLEm, entry, PRT_ENABLEf, 1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN
            (WRITE_EGR_ENABLEm(unit, MEM_BLOCK_ALL, SOC_INFO(unit).port_l2p_mapping[port], entry));
    }

    COMPILER_64_ZERO(reg64);
    soc_reg64_field32_set(unit, EPC_LINK_BMAP_64r, &reg64, PORT_BITMAP_LOf,
                          SOC_PBMP_WORD_GET(PBMP_CMIC(unit), 0));
    SOC_IF_ERROR_RETURN(WRITE_EPC_LINK_BMAP_64r(unit, reg64));

    SOC_IF_ERROR_RETURN(READ_ING_CONFIG_64r(unit, &reg64));
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L3SRC_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          L2DST_HIT_ENABLEf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L2f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          APPLY_EGR_MASK_ON_L3f, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_RARP_TO_FPf, 0x3); /* enable both ARP & RARP */
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          ARP_VALIDATION_ENf, 1);
    soc_reg64_field32_set(unit, ING_CONFIG_64r, &reg64,
                          IGNORE_HG_HDR_LAG_FAILOVERf, 1);
    SOC_IF_ERROR_RETURN(WRITE_ING_CONFIG_64r(unit, reg64));

    SOC_IF_ERROR_RETURN(READ_EGR_CONFIG_1r(unit, &rval));
    soc_reg_field_set(unit, EGR_CONFIG_1r, &rval, RING_MODEf, 1);
    SOC_IF_ERROR_RETURN(WRITE_EGR_CONFIG_1r(unit, rval));

    /* The HW defaults for EGR_VLAN_CONTROL_1.VT_MISS_UNTAG == 1, which
     * causes the outer tag to be removed from packets that don't have
     * a hit in the egress vlan tranlation table. Set to 0 to disable this.
     */
    rval = 0;
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, VT_MISS_UNTAGf, 0);

    /* Enable pri/cfi remarking on egress ports. */
    soc_reg_field_set(unit, EGR_VLAN_CONTROL_1r, &rval, REMARK_OUTER_DOT1Pf,
                      1);
    PBMP_ALL_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(WRITE_EGR_VLAN_CONTROL_1r(unit, port, rval));
    }

    /* Multicast range initialization */
    SOC_IF_ERROR_RETURN
        (soc_hbx_higig2_mcast_sizes_set(unit,
             soc_property_get(unit, spn_HIGIG2_MULTICAST_VLAN_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L2_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT),
             soc_property_get(unit, spn_HIGIG2_MULTICAST_L3_RANGE,
                              SOC_HBX_MULTICAST_RANGE_DEFAULT)));

    /* Setup SW2_FP_DST_ACTION_CONTROL */
    fields[0] = HGTRUNK_RES_ENf;
    fields[1] = LAG_RES_ENf;
    values[0] = values[1] = 1;
    SOC_IF_ERROR_RETURN
        (soc_reg_fields32_modify(unit, SW2_FP_DST_ACTION_CONTROLr,
                                 REG_PORT_ANY, 2, fields, values));

    freq = si->frequency;

    /*
     * Set external MDIO freq to around 10MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     */
    target_freq = 10;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_EXT_MDIO_DIVIDEND, 1);

    rval = 0;
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVISORf, divisor);
    soc_reg_field_set(unit, CMIC_RATE_ADJUSTr, &rval, DIVIDENDf, dividend);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUSTr(unit, rval));

    /*
     * Set internal MDIO freq to around 10MHz
     * Valid range is from 2.5MHz to 12.5MHz
     * target_freq = core_clock_freq * DIVIDEND / DIVISOR / 2
     * or
     * DIVISOR = core_clock_freq * DIVIDENT / (target_freq * 2)
     */
    target_freq = 10;
    divisor = (freq + (target_freq * 2 - 1)) / (target_freq * 2);
    divisor = soc_property_get(unit, spn_RATE_INT_MDIO_DIVISOR, divisor);
    dividend = soc_property_get(unit, spn_RATE_INT_MDIO_DIVIDEND, 1);
    rval = 0;
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVISORf,
                       divisor);
    soc_reg_field_set (unit, CMIC_RATE_ADJUST_INT_MDIOr, &rval, DIVIDENDf,
                       dividend);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_RATE_ADJUST_INT_MDIOr(unit, rval));

    delay = soc_property_get(unit, spn_MDIO_OUTPUT_DELAY, -1);
    if (delay >= 1  && delay <= 15) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(READ_CMIC_MIIM_CONFIGr(unit, &rval));
        soc_reg_field_set(unit, CMIC_MIIM_CONFIGr, &rval, MDIO_OUT_DELAYf,
                          delay);
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_MIIM_CONFIGr(unit, rval));
    }

    /* Directed Mirroring ON by default except for CPU port */
    /* The src_port info will be changed as egress port if EM_SRCMOD_CHANGEf = 1 */
    PBMP_PORT_ITER(unit, port) {
        SOC_IF_ERROR_RETURN(READ_EGR_PORT_64r(unit, port, &reg64));
        soc_reg64_field32_set(unit, EGR_PORT_64r, &reg64, EM_SRCMOD_CHANGEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_EGR_PORT_64r(unit, port, reg64));
        SOC_IF_ERROR_RETURN(READ_IEGR_PORT_64r(unit, port, &reg64));
        soc_reg64_field32_set(unit, IEGR_PORT_64r, &reg64, EM_SRCMOD_CHANGEf, 1);
        SOC_IF_ERROR_RETURN(WRITE_IEGR_PORT_64r(unit, port, reg64));
    }

    _phy_tsce_firmware_set_helper[unit] = _soc_hurricane3_tscx_firmware_set;
    _phy_qtce_firmware_set_helper[unit] = _soc_hurricane3_tscx_firmware_set;

    /* LEDuP init */
    SOC_IF_ERROR_RETURN(_soc_hurricane3_ledup_init(unit));

    /* MSPI init */
    if (soc_mspi_init(unit) != SOC_E_NONE) {
        LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit,
                             "unit %d : MSPI Init Failed\n"), unit));
    }

    /* Add board properity which can be used in rc.soc */
    board_name = soc_property_get_str(unit, spn_BOARD_NAME);
    if (board_name) {
        if (soc_mem_config_set == NULL) {
            LOG_WARN(BSL_LS_SOC_COMMON,
                 (BSL_META_U(unit, "unit %d : soc_mem_config_set() is NULL\n"),
                  unit));
        } else {
            if (sal_strcmp(board_name, "BCM956160R") == 0) {
                soc_mem_config_set("bcm956160r", "1");
            } else if (sal_strcmp(board_name, "BCM956166R") == 0) {
                soc_mem_config_set("bcm956166r", "1");
            } else if (sal_strcmp(board_name, "BCM956160K") == 0) {
                soc_mem_config_set("bcm956160k", "1");
            } else if (sal_strcmp(board_name, "BCM953434K") == 0) {
                soc_mem_config_set("bcm953434k", "1");
            } else if (sal_strcmp(board_name, "BCM956164K") == 0) {
                soc_mem_config_set("bcm956164k", "1");
            }
        }
    }

#ifdef INCLUDE_MEM_SCAN
    if (parity_enable) {
        SOC_IF_ERROR_RETURN(soc_generic_ser_mem_scan_start(unit));
    }
#endif /* INCLUDE_MEM_SCAN */

#ifdef INCLUDE_AVS
    soc_hr3_avs_init(unit);
#endif /* INCLUDE_AVS  */

    SOC_IF_ERROR_RETURN(_soc_hr3_l3iif_hw_mem_init(unit, TRUE));
    return SOC_E_NONE;
}


/*
 * Function:
 *  _soc_hurricane3_gpio_set
 * Purpose:
 *  Write value to the specified GPIO pin
 */
STATIC int
_soc_hurricane3_gpio_set(int unit, int pin, int output, int val)
{
    uint32 rval = 0;
    uint32 fval = 0;
    uint8 mask = 0xFF;

    mask &= ~(1 << pin);

    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(READ_CMIC_GP_OUT_ENr(unit, &rval));
    fval = soc_reg_field_get(unit, CMIC_GP_OUT_ENr, rval, OUT_ENABLEf);
    if (output) {
        fval |= 1 << pin;
    } else {
        fval &= ~(1 << pin);
    }
    soc_reg_field_set(unit, CMIC_GP_OUT_ENr, &rval, OUT_ENABLEf, fval);
    /* coverity[result_independent_of_operands] */
    SOC_IF_ERROR_RETURN(WRITE_CMIC_GP_OUT_ENr(unit, rval));

    if (output) {
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(READ_CMIC_GP_DATA_OUTr(unit, &rval));
        fval = soc_reg_field_get(unit, CMIC_GP_DATA_OUTr, rval, DATA_OUTf);
        if (val) {
            fval |= (val << pin);
        } else {
            fval &= ~(1 << pin);
        }

        soc_reg_field_set(unit, CMIC_GP_DATA_OUTr, &rval, DATA_OUTf, fval);
        /* coverity[result_independent_of_operands] */
        SOC_IF_ERROR_RETURN(WRITE_CMIC_GP_DATA_OUTr(unit, rval));
    }

    return SOC_E_NONE;
}


/* soc_hurricane3_mem_config:
 * Over-ride the default table sizes (from regsfile) for any SKUs here
 */
int
soc_hurricane3_mem_config(int unit, int dev_id)
{
    int rv = SOC_E_NONE;
    soc_persist_t *sop = SOC_PERSIST(unit);

    switch (dev_id) {
        case BCM56163_DEVICE_ID:
        case BCM56164_DEVICE_ID:
        case BCM56166_DEVICE_ID:
            /* Hurricane3 Lite */
            /* -- L2 related -- */
            sop->memState[L2MCm].index_max = 511;
            /* -- L3 related -- */
            sop->memState[L3_IPMCm].index_max = 63;
            sop->memState[L3_DEFIPm].index_max = 63;
            sop->memState[L3_DEFIP_ONLYm].index_max = 63;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 63;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max = 63;
            sop->memState[ING_L3_NEXT_HOPm].index_max = 767;
            sop->memState[INITIAL_ING_L3_NEXT_HOPm].index_max = 767;
            sop->memState[EGR_L3_NEXT_HOPm].index_max = 767;
            sop->memState[EGR_L3_INTFm].index_max = 255;
            sop->memState[L3_MTU_VALUESm].index_max = 575;
            sop->memState[L3_IIFm].index_max = -1;
            sop->memState[L3_ECMP_COUNTm].index_max = -1;
            sop->memState[L3_ECMPm].index_max = -1;
            sop->memState[INITIAL_L3_ECMP_GROUPm].index_max = -1;
            sop->memState[INITIAL_L3_ECMPm].index_max = -1;
            SOC_CONTROL(unit)->l3_defip_max_tcams = 1;
            SOC_CONTROL(unit)->l3_defip_tcam_size = 64;

            sop->memState[VLAN_SUBNETm].index_max = 63;
            sop->memState[VLAN_SUBNET_ONLYm].index_max = 63;
            sop->memState[VLAN_SUBNET_DATA_ONLYm].index_max = 63;
            sop->memState[EFP_COUNTER_TABLEm].index_max = -1;
            sop->memState[EFP_METER_TABLEm].index_max = -1;
            sop->memState[EFP_POLICY_TABLEm].index_max = -1;
            sop->memState[EFP_TCAMm].index_max = -1;
            sop->memState[VFP_POLICY_TABLEm].index_max = -1;
            sop->memState[VFP_TCAMm].index_max = -1;
            break;
        case BCM53440_DEVICE_ID:
        case BCM53442_DEVICE_ID:
        case BCM53443_DEVICE_ID:
            /* Buckhound */
            /* -- L3 related -- */
            /* used for miml and oam
            sop->memState[ING_L3_NEXT_HOPm].index_max = -1;
            sop->memState[EGR_L3_NEXT_HOPm].index_max = -1;
            sop->memState[EGR_L3_INTFm].index_max = -1;
            sop->memState[L3_ENTRY_IPV4_UNICASTm].index_max = -1;
            sop->memState[L3_ENTRY_ONLYm].index_max = -1;
            sop->memState[L3_MTU_VALUESm].index_max = -1;
            */
            sop->memState[L3_IPMCm].index_max = -1;
            sop->memState[L3_DEFIPm].index_max = -1;
            sop->memState[L3_DEFIP_ONLYm].index_max = -1;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max = -1;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max = -1;
            sop->memState[INITIAL_ING_L3_NEXT_HOPm].index_max = -1;
            sop->memState[L3_ENTRY_HIT_ONLYm].index_max = -1;
            sop->memState[L3_ENTRY_IPV4_MULTICASTm].index_max = -1;
            sop->memState[L3_ENTRY_IPV6_UNICASTm].index_max = -1;
            sop->memState[L3_ENTRY_IPV6_MULTICASTm].index_max = -1;
            sop->memState[L3_ENTRY_VALID_ONLYm].index_max = -1;
            sop->memState[L3_ECMP_COUNTm].index_max = -1;
            sop->memState[L3_ECMPm].index_max = -1;
            sop->memState[INITIAL_L3_ECMP_GROUPm].index_max = -1;
            sop->memState[INITIAL_L3_ECMPm].index_max = -1;
            sop->memState[L3_IIFm].index_max = -1;
            SOC_CONTROL(unit)->l3_defip_max_tcams = 0;
            SOC_CONTROL(unit)->l3_defip_tcam_size = 0;
            break;
        case BCM53434_DEVICE_ID:
            /* Foxhound2 */
            /* -- L2 related -- */
            sop->memState[L2Xm].index_max = 8191;
            sop->memState[L2_ENTRY_ONLYm].index_max = 8191;
            sop->memState[L2_HITDA_ONLYm].index_max = 1023;
            sop->memState[L2_HITSA_ONLYm].index_max = 1023;
            sop->memState[L2MCm].index_max = 255;
            /* -- L3 related -- */
            sop->memState[L3_IPMCm].index_max = -1;
            sop->memState[L3_DEFIPm].index_max = -1;
            sop->memState[L3_DEFIP_ONLYm].index_max = -1;
            sop->memState[L3_DEFIP_DATA_ONLYm].index_max = -1;
            sop->memState[L3_DEFIP_HIT_ONLYm].index_max = -1;
            sop->memState[ING_L3_NEXT_HOPm].index_max = -1;
            sop->memState[INITIAL_ING_L3_NEXT_HOPm].index_max = -1;
            sop->memState[EGR_L3_NEXT_HOPm].index_max = -1;
            sop->memState[EGR_L3_INTFm].index_max = -1;
            sop->memState[L3_ENTRY_HIT_ONLYm].index_max = -1;
            sop->memState[L3_ENTRY_IPV4_UNICASTm].index_max = -1;
            sop->memState[L3_ENTRY_IPV4_MULTICASTm].index_max = -1;
            sop->memState[L3_ENTRY_IPV6_UNICASTm].index_max = -1;
            sop->memState[L3_ENTRY_IPV6_MULTICASTm].index_max = -1;
            sop->memState[L3_ENTRY_ONLYm].index_max = -1;
            sop->memState[L3_ENTRY_VALID_ONLYm].index_max = -1;
            sop->memState[L3_MTU_VALUESm].index_max = -1;
            sop->memState[L3_ECMP_COUNTm].index_max = -1;
            sop->memState[L3_ECMPm].index_max = -1;
            sop->memState[INITIAL_L3_ECMP_GROUPm].index_max = -1;
            sop->memState[INITIAL_L3_ECMPm].index_max = -1;
            sop->memState[L3_IIFm].index_max = -1;

            sop->memState[VLAN_SUBNETm].index_max = -1;
            sop->memState[VLAN_SUBNET_ONLYm].index_max = -1;
            sop->memState[VLAN_SUBNET_DATA_ONLYm].index_max = -1;
            sop->memState[EFP_COUNTER_TABLEm].index_max = -1;
            sop->memState[EFP_METER_TABLEm].index_max = -1;
            sop->memState[EFP_POLICY_TABLEm].index_max = -1;
            sop->memState[EFP_TCAMm].index_max = -1;
            sop->memState[VFP_POLICY_TABLEm].index_max = -1;
            sop->memState[VFP_TCAMm].index_max = -1;
            sop->memState[FP_TCAMm].index_max = 1023;
            sop->memState[FP_GLOBAL_MASK_TCAMm].index_max = 1023;
            sop->memState[FP_COUNTER_TABLEm].index_max = 1023;
            sop->memState[FP_METER_TABLEm].index_max = 1023;
            sop->memState[FP_POLICY_TABLEm].index_max = 1023;
            sop->memState[MMU_CBPCELLHEADERm].index_max = 4095;
            sop->memState[MMU_CBPDATA0m].index_max = 4095;
            sop->memState[MMU_CBPDATA1m].index_max = 4095;
            sop->memState[MMU_CBPDATA2m].index_max = 4095;
            sop->memState[MMU_CBPDATA3m].index_max = 4095;
            sop->memState[MMU_CBPDATA4m].index_max = 4095;
            sop->memState[MMU_CBPDATA5m].index_max = 4095;
            sop->memState[MMU_CBPDATA6m].index_max = 4095;
            sop->memState[MMU_CBPDATA7m].index_max = 4095;
            sop->memState[MMU_CBPPKTHEADER0m].index_max = 4095;
            sop->memState[MMU_CBPPKTHEADER1m].index_max = 4095;
            sop->memState[MMU_CBPPKTHEADER2m].index_max = 4095;
            sop->memState[MMU_CBPPKTHEADER_EXTm].index_max = 4095;
            SOC_CONTROL(unit)->l3_defip_max_tcams = 0;
            SOC_CONTROL(unit)->l3_defip_tcam_size = 0;
            break;
        default:
            SOC_CONTROL(unit)->l3_defip_max_tcams = 8;
            SOC_CONTROL(unit)->l3_defip_tcam_size = 64;
            break;
    }
    if (SAL_BOOT_QUICKTURN) {
        /* QuickTurn with limited TCAM entries */
        sop->memState[L2_USER_ENTRYm].index_max = 11;
        sop->memState[L2_USER_ENTRY_ONLYm].index_max = 11;
        sop->memState[L2_USER_ENTRY_DATA_ONLYm].index_max = 11;
        sop->memState[CPU_COS_MAPm].index_max = 11;
        sop->memState[CPU_COS_MAP_ONLYm].index_max = 11;
        sop->memState[FP_GLOBAL_MASK_TCAMm].index_max = 29;
        sop->memState[VLAN_SUBNETm].index_max = 11;
        sop->memState[VLAN_SUBNET_ONLYm].index_max = 11;
        sop->memState[VLAN_SUBNET_DATA_ONLYm].index_max = 11;
        sop->memState[L3_DEFIPm].index_max = 31;
        sop->memState[L3_DEFIP_ONLYm].index_max = 31;
        sop->memState[L3_DEFIP_DATA_ONLYm].index_max = 31;
        sop->memState[VFP_TCAMm].index_max = 29;
        sop->memState[EFP_TCAMm].index_max = 29;
        sop->memState[FP_TCAMm].index_max = 29;
    }
    return rv;
}

/*
 * Function:
 *      _soc_hurricane3_core_disable
 * Purpose:
 *      Re-config the port info for the core disabled
 */
STATIC int
_soc_hurricane3_core_disable(int unit, int core_type,
                                 uint32 disable_core_bmp, uint32 disable_qgphy_bmp)
{
    int i, j, idx, core_count;
    int phy_port, port, blk, num_port, num_port2;
    soc_info_t *si;
    const int *core_phy_port;

    si = &SOC_INFO(unit);

    switch (core_type) {
        case SOC_HR3_PORT_CORE_TYPE_TSC:
            num_port = _HR3_PORT_COUNT_PER_TSC;
            core_phy_port = &tsc_phy_port[0];
            core_count = _HR3_MAX_TSC_COUNT;
            break;
        case SOC_HR3_PORT_CORE_TYPE_QTC:
            num_port = _HR3_PORT_COUNT_PER_QTC;
            core_phy_port = &qtc_phy_port[0];
            core_count = _HR3_MAX_QTC_COUNT;
            break;
        default:
            return (SOC_E_PARAM);
    }
    for (i = 0; i < core_count; i++) {
        if((1 << i) & disable_core_bmp){
            num_port2 = num_port;
            if (!((1 << i) & disable_qgphy_bmp) &&
                (core_type == SOC_HR3_PORT_CORE_TYPE_QTC)) {
                /* The QGPHY ports are occupied on the same ports
                 *  as QTC lane 3 lane 4.
                 * If these ports are used for GPHY, we should not disable them.
                 */
                 num_port2 = 8;

            }

            for (j = 0; j < num_port2; j++) {
                phy_port = core_phy_port[i]+j;
                port = si->port_p2l_mapping[phy_port];
                for (idx = 0; idx < SOC_DRIVER(unit)->port_num_blktype; idx++) {
                    blk = SOC_PORT_IDX_BLOCK(unit, phy_port, idx);
                    if (blk < 0) { /* end of block list of each port */
                        break;
                    }
                    if(si->block_port[blk] == port){
                        si->block_port[blk] = -1;
                    }
                    si->block_valid[blk]=0;
                    SOC_PBMP_PORT_REMOVE(si->block_bitmap[blk],port);
                }
                si->port_p2l_mapping[phy_port]= -1;
                si->port_p2m_mapping[phy_port] = -1;
                si->max_port_p2m_mapping[phy_port] = -1;
                si->port_l2p_mapping[port] = -1;
                si->port_m2p_mapping[port] = -1;

                SOC_PBMP_PORT_REMOVE(si->ether.bitmap,port);
                SOC_PBMP_PORT_REMOVE(si->ge.bitmap,port);
                SOC_PBMP_PORT_REMOVE(si->xe.bitmap,port);
                SOC_PBMP_PORT_REMOVE(si->hg.bitmap,port);
                SOC_PBMP_PORT_REMOVE(si->st.bitmap,port);
                SOC_PBMP_PORT_REMOVE(si->xl.bitmap,port);
                SOC_PBMP_PORT_REMOVE(si->all.bitmap,port);
                SOC_PBMP_PORT_REMOVE(si->port.bitmap,port);
                sal_snprintf(si->port_name[port], sizeof(si->port_name[port]),
                         "?%d", port);
                si->port_offset[port] = port;
            }
        }
    }

#define RECONFIG_PORT_INFO(ptype,str) \
    si->ptype.num = 0; \
    si->ptype.min = si->ptype.max = -1; \
    PBMP_ITER(si->ptype.bitmap, port) { \
        if(sal_strcmp(str,"")){\
            sal_snprintf(si->port_name[port], sizeof(si->port_name[port]),\
            "%s%d", str, si->ptype.num);\
        }\
        si->ptype.port[si->ptype.num++] = port; \
        if (si->ptype.min < 0) { \
            si->ptype.min = port; \
        } \
        if (port > si->ptype.max) { \
            si->ptype.max = port; \
        } \
    }

    /* coverity[pointless_string_compare] */
    RECONFIG_PORT_INFO(ether,"");
    /* coverity[pointless_string_compare] */
    RECONFIG_PORT_INFO(st,"");
    RECONFIG_PORT_INFO(hg,"hg");
    RECONFIG_PORT_INFO(xe,"xe");
    RECONFIG_PORT_INFO(ge,"ge");
#undef RECONFIG_PORT_INFO

    return SOC_E_NONE;
}

#define TOP_STRAP_STATUS_TSC_DISABLE(val)    \
    (((val) >> 25) & 0x3)
#define TOP_STRAP_STATUS_QTC_DISABLE(val)    \
    (((val) >> 27) & 0x3)
#define TOP_STRAP_STATUS_LCPLL1_REF(val)    \
    (((val) & (1<<9)) != 0)
#define TOP_STRAP_STATUS_1_REF(val)    \
    ((val) & 1)


/*
 * Function:
 *      soc_hurricane3_chip_reset
 * Purpose:
 *      Special reset sequencing for BCM56160
 */
int
soc_hurricane3_chip_reset(int unit)
{
    uint32 rval, to_usec, strap_sts, strap_sts_1;
    _hr3_sku_info_t *matched_sku_info;
    uint32 disabled_bmp,disable_tsc,disable_qtc, disable_gphy;
    int i;
    uint16              dev_id;
    uint8               rev_id;

    unsigned ts_ref_freq;
    unsigned ts_idx;
    static const soc_pll_param_t ts_pll[] = {  /* values for 500MHz TSPLL output */
      /*     Fref,  Ndiv_int, Ndiv_frac,  Pdiv, Mdiv, Ka, Ki, Kp, VCO_div2 */
        {25000000,       100,         0,     5,    1,  2,  2,  3,        1},
        {50000000,        50,         0,     5,    1,  2,  2,  3,        1},
        {       0,       160,         0,     1,    8,  2,  2,  3,        1}, /* 25Mhz internal clk */
        {       0,        50,         0,     1,    5,  2,  2,  3,        1}  /* 50Mhz internal clk */
        /* 0 => 25MHz or 50Mhz depending upon strap_xtal_freq_sel - from internal reference */
    };
    unsigned bs_ref_freq;
    unsigned bs_idx;
    uint32 bs_ndiv_high, bs_ndiv_low;
    static const soc_pll_param_t bs_pll[] = {  /* values for 20MHz BSPLL output */
      /*     Fref,  Ndiv_int,  Ndiv_frac,  Pdiv, Mdiv, Ka, Ki, Kp, VCO_div2 */
        {25000000,       120,          0,     1,  150,  4,  1,  8,        0},
        {50000000,        60,          0,     1,  150,  4,  1,  8,        0},
        {       0,       120,          0,     1,  150,  4,  1,  8,        0}, /* 25Mhz internal clk */
        {       0,        60,          0,     1,  150,  4,  1,  8,        0} /* 50MHZ internal clk */
        /* 0 => 25MHz or 50Mhz depending upon strap_xtal_freq_sel - from internal reference */
    };
    int hitless = 0;
#if defined(BCM_HITLESS_RESET_SUPPORT)
    const int broadsync_default_fbdiv = 0x3c00;
#endif /* BCM_HITLESS_RESET_SUPPORT */
    uint32 refclk;

    soc_cm_get_id(unit, &dev_id, &rev_id);
    to_usec = SAL_BOOT_QUICKTURN ? (250 * MILLISECOND_USEC) :
                                   (10 * MILLISECOND_USEC);

    WRITE_CMIC_SBUS_RING_MAP_0_7r(unit, 0x00110000); /* block 7  - 0 */
    WRITE_CMIC_SBUS_RING_MAP_8_15r(unit, 0x00430000); /* block 15 - 8 */
    WRITE_CMIC_SBUS_RING_MAP_16_23r(unit, 0x00005064); /* block 23 - 16 */
    WRITE_CMIC_SBUS_RING_MAP_24_31r(unit, 0x00000000); /* block 31 - 24 */
    WRITE_CMIC_SBUS_RING_MAP_32_39r(unit, 0x77772222); /* block 39 - 32 */
    WRITE_CMIC_SBUS_RING_MAP_40_47r(unit, 0x00000000); /* block 40 - 47 */

    WRITE_CMIC_SBUS_TIMEOUTr(unit, 0x7d0);

    sal_usleep(to_usec);


    strap_sts = 0;
    SOC_IF_ERROR_RETURN(READ_TOP_STRAP_STATUSr(unit, &strap_sts));
    strap_sts_1 = 0;
    SOC_IF_ERROR_RETURN(READ_TOP_STRAP_STATUS_1r(unit, &strap_sts_1));

    /* TSPLL configuration: 500MHz TS_CLK from 20/25/32/50MHz refclk */
    /* CMICd divides by 2 on input, so this is a 250MHz clock to TS logic */

    ts_ref_freq = soc_property_get(unit, spn_PTP_TS_PLL_FREF, 0);  /* 0->internal reference */
    /* Set TS_PLL_CLK_IN_SEL based on reference frequency.  If it is 0, use the internal reference */
    soc_reg_field32_modify(unit, TOP_PLL_BYP_AND_REFCLK_CONTROLr, REG_PORT_ANY,
        TS_PLL_REFCLK_SELf, (ts_ref_freq != 0));

    for (ts_idx = 0; ts_idx < sizeof(ts_pll)/sizeof(ts_pll[0]); ++ts_idx) {
        if (ts_pll[ts_idx].ref_freq == ts_ref_freq) {
            break;
        }
    }
    /* differentiang between internal 25Mhz or 50MHz clk */
    if (ts_ref_freq == 0) {
        if (rev_id < BCM56160_B0_REV_ID) {
            /* only 25Mhz internal clk */
            ts_idx = 2;
        } else {
            /* 25MHz or 50MHz internal clk depeding upon strap setting */
            ts_idx = (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ?  2 : 3;
        }
    }
    if (ts_idx == sizeof(ts_pll)/sizeof(ts_pll[0])) {
        LOG_ERROR(BSL_LS_SOC_COMMON,
                  (BSL_META_U(unit,
                              "Invalid value for PTP_TS_PLL_REF (%u).  No default PLL params.\n"), ts_ref_freq));
        /* Could check for existence of SOC properties for VCO_DIV2, KA, KI, KP, NDIV_INT, NDIV_FRAC, MDIV, PDIV, and if
           all exist, use them.  For now, just fail.
        */
    } else {

        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_RST_Lf, 0);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_POST_RST_Lf, 0);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

        /* Enable software overwrite of TimeSync PLL settings. */
        soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY,
            CMIC_TO_TS_PLL_LOADf, 1);

        soc_reg_field32_modify(unit, TOP_TS_PLL_CTRL_0r, REG_PORT_ANY,
            VCO_DIV2f, soc_property_get(unit, spn_PTP_TS_VCO_DIV2,
                                        ts_pll[ts_idx].vco_div2));

        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_4r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KAf,
                          soc_property_get(unit, spn_PTP_TS_KA, ts_pll[ts_idx].ka));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KIf,
                          soc_property_get(unit, spn_PTP_TS_KI, ts_pll[ts_idx].ki));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_4r, &rval, KPf,
                          soc_property_get(unit, spn_PTP_TS_KP, ts_pll[ts_idx].kp));
        SOC_IF_ERROR_RETURN(WRITE_TOP_TS_PLL_CTRL_4r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_3r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_INTf,
                        soc_property_get(unit, spn_PTP_TS_PLL_N, ts_pll[ts_idx].ndiv_int));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_3r, &rval, NDIV_FRACf,
                          ts_pll[ts_idx].ndiv_frac);
        SOC_IF_ERROR_RETURN(WRITE_TOP_TS_PLL_CTRL_3r(unit, rval));

        SOC_IF_ERROR_RETURN(READ_TOP_TS_PLL_CTRL_2r(unit,&rval));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, PDIVf,
                        soc_property_get(unit, spn_PTP_TS_PLL_PDIV, ts_pll[ts_idx].pdiv));
        soc_reg_field_set(unit, TOP_TS_PLL_CTRL_2r, &rval, CH0_MDIVf,
                        soc_property_get(unit, spn_PTP_TS_PLL_MNDIV, ts_pll[ts_idx].mdiv));
        SOC_IF_ERROR_RETURN(WRITE_TOP_TS_PLL_CTRL_2r(unit, rval));

        /* Strobe channel-0 load-enable to set divisors. */
        soc_reg_field32_modify(unit, TOP_TS_PLL_CTRL_2r, REG_PORT_ANY,
             LOAD_EN_CH0f, 0);
        soc_reg_field32_modify(unit, TOP_TS_PLL_CTRL_2r, REG_PORT_ANY,
             LOAD_EN_CH0f, 1);
    }

    /* 500Mhz TSPLL -> 250MHz ref at timestamper, implies 4ns resolution */
    SOC_TIMESYNC_PLL_CLOCK_NS(unit) = (1/250 * 1000); /* clock period in nanoseconds */

#if defined(BCM_HITLESS_RESET_SUPPORT)
    /* Some SKUs do not have BSPLLs: time_v3 is true if they exist */
    if (soc_feature(unit, soc_feature_time_v3) &&
        !soc_feature(unit, soc_feature_time_v3_no_bs)) {
        /* Check to see if the BSPLLs have been configured yet. */
        SOC_IF_ERROR_RETURN(
            READ_TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_1r(unit,&rval));

        hitless = (soc_reg_field_get(unit, TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_1r,
                                     rval, BROAD_SYNC1_LCPLL_FBDIV_1f)
                   != broadsync_default_fbdiv);

        LOG_VERBOSE(BSL_LS_SOC_COMMON, (BSL_META_U(unit,
            "BSPLL %s\n"), initialize_broadsync ? "Initializing" : "Hitless"));
    }
#endif  /* BCM_HITLESS_RESET_SUPPORT */

    /* Initialize BroadSync if we aren't booting hitless, if BroadSync exists */
    if (!hitless &&
        soc_feature(unit, soc_feature_time_v3) &&
        !soc_feature(unit, soc_feature_time_v3_no_bs)) {
        /* as a signal to upper-level code that the BroadSync is newly initialized
         * disable BroadSync0/1 bitclock output.  Checked in time.c / 1588 firmware    */
        soc_reg_field32_modify(unit, CMIC_BS0_CONFIGr, REG_PORT_ANY,
                               BS_CLK_OUTPUT_ENABLEf, 0);

        soc_reg_field32_modify(unit, CMIC_BS1_CONFIGr, REG_PORT_ANY,
                               BS_CLK_OUTPUT_ENABLEf, 0);

        /* BSPLL0 has not been configured, so reset/configure both BSPLL0 and BSPLL1 */
        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL0_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL1_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL0_POST_RST_Lf, 0);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL1_POST_RST_Lf, 0);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

        /* Set RATE_MANGER_MODE to 1 to enable on-the-fly setting of NDIV */
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_3r,
                               REG_PORT_ANY, RATE_MANAGER_MODEf, 1);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_3r,
                               REG_PORT_ANY, RATE_MANAGER_MODEf, 1);

        /* Both BSPLLs configured the same, for 20MHz output by default */

        bs_ref_freq = soc_property_get(unit, spn_PTP_BS_FREF, 0);  /* 0->internal reference */
        /* Set BS_PLL_CLK_IN_SEL based on reference frequency.  If it is 0, use the internal reference */
        SOC_IF_ERROR_RETURN(READ_TOP_PLL_BYP_AND_REFCLK_CONTROLr(unit,&rval));
        soc_reg_field_set(unit, TOP_PLL_BYP_AND_REFCLK_CONTROLr, &rval, BS_PLL0_REFCLK_SELf,
                          (bs_ref_freq != 0));
        soc_reg_field_set(unit, TOP_PLL_BYP_AND_REFCLK_CONTROLr, &rval, BS_PLL1_REFCLK_SELf,
                          (bs_ref_freq != 0));
        SOC_IF_ERROR_RETURN(WRITE_TOP_PLL_BYP_AND_REFCLK_CONTROLr(unit, rval));

        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_6r, REG_PORT_ANY,
                               LDO_CTRLf, (rev_id < BCM56160_B0_REV_ID) ? 0x2a : 0x22);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_7r, REG_PORT_ANY,
                               FREQ_DOUBLER_ONf, 0);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_6r, REG_PORT_ANY,
                               MSC_CTRLf,
                               (rev_id < BCM56160_B0_REV_ID) ?  0x0022 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0)
                               ? 0x0022: 0x1022);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_7r, REG_PORT_ANY,
                               VCO_CONT_ADJf, 1);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_3r, REG_PORT_ANY,
                               VCO_CURf, 0);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_5r, REG_PORT_ANY,
                               VCO_GAINf, (rev_id < BCM56160_B0_REV_ID) ? 3 : 15);
        soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY,
                               CMIC_TO_BS_PLL0_SW_OVWRf, 1);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_5r, REG_PORT_ANY,
                               CP1f,
                               (rev_id < BCM56160_B0_REV_ID) ?  1 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0)
                               ? 0 : 1);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_5r, REG_PORT_ANY,
                               CPf,
                               (rev_id < BCM56160_B0_REV_ID) ?  3 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0)
                               ? 0 : 3);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_5r, REG_PORT_ANY,
                               CZf, 3);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_5r, REG_PORT_ANY,
                               RPf, (rev_id < BCM56160_B0_REV_ID) ? 7 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ? 0 : 7);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_5r, REG_PORT_ANY,
                               RZf, (rev_id < BCM56160_B0_REV_ID) ? 7 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ? 6 : 2);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_5r, REG_PORT_ANY,
                               ICPf, (rev_id < BCM56160_B0_REV_ID) ? 16 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ? 20 : 10);
        soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_7r, REG_PORT_ANY,
                               CPPf, 0x80);

        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_6r, REG_PORT_ANY,
                               LDO_CTRLf, (rev_id < BCM56160_B0_REV_ID) ? 0x2a : 0x22);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_7r, REG_PORT_ANY,
                               FREQ_DOUBLER_ONf, 0);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_6r, REG_PORT_ANY,
                               MSC_CTRLf,
                               (rev_id < BCM56160_B0_REV_ID) ?  0x0022 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0)
                               ? 0x0022: 0x1022);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_7r, REG_PORT_ANY,
                               VCO_CONT_ADJf, 1);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_3r, REG_PORT_ANY,
                               VCO_CURf, 0);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_5r, REG_PORT_ANY,
                               VCO_GAINf, (rev_id < BCM56160_B0_REV_ID) ? 3 : 15);
        soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY,
                               CMIC_TO_BS_PLL1_SW_OVWRf, 1);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_5r, REG_PORT_ANY,
                               CP1f, 1);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_5r, REG_PORT_ANY,
                               CPf, 3);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_5r, REG_PORT_ANY,
                               CZf, 3);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_5r, REG_PORT_ANY,
                               RPf, (rev_id < BCM56160_B0_REV_ID) ? 7 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ? 0 : 7);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_5r, REG_PORT_ANY,
                               RZf, (rev_id < BCM56160_B0_REV_ID) ? 7 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ? 6 : 2);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_5r, REG_PORT_ANY,
                               ICPf, (rev_id < BCM56160_B0_REV_ID) ? 16 :
                               (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ? 20 : 10);
        soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_7r, REG_PORT_ANY,
                               CPPf, 0x80);

        for (bs_idx = 0; bs_idx < sizeof(bs_pll)/sizeof(bs_pll[0]); ++bs_idx) {
            if (bs_pll[bs_idx].ref_freq == bs_ref_freq) {
                break;
            }
        }
        /* differentiang between internal 25Mhz or 50MHz clk */
        if (bs_ref_freq == 0) {
            if (rev_id < BCM56160_B0_REV_ID) {
                /* only 25Mhz internal clk */
                bs_idx = 2;
            } else {
                /* 25MHz or 50MHz internal clk depeding upon strap setting */
                bs_idx = (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0) ?  2 : 3;
            }
        }

        if (bs_idx == sizeof(bs_pll)/sizeof(bs_pll[0])) {
            LOG_ERROR(BSL_LS_SOC_COMMON,
                      (BSL_META_U(unit,
                                  "Invalid value for PTP_BS_REF (%u).  No default PLL params.\n"), bs_ref_freq));
            /* Could check for existence of SOC properties for KA, KI, KP, NDIV_INT,
               NDIV_FRAC, MDIV, PDIV, and if all exist, use them.  For now, just fail.
            */
        } else {
            soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_1r, REG_PORT_ANY,
                KAf,
                soc_property_get(unit, spn_PTP_BS_KA, bs_pll[bs_idx].ka));

            soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_1r, REG_PORT_ANY,
                KIf,
                soc_property_get(unit, spn_PTP_BS_KI, bs_pll[bs_idx].ki));

            soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_1r, REG_PORT_ANY,
                KPf,
                soc_property_get(unit, spn_PTP_BS_KP, bs_pll[bs_idx].kp));

            soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_1r, REG_PORT_ANY,
                PDIVf,
                soc_property_get(unit, spn_PTP_BS_PDIV, bs_pll[bs_idx].pdiv));

            soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_1r, REG_PORT_ANY,
                KAf,
                soc_property_get(unit, spn_PTP_BS_KA, bs_pll[bs_idx].ka));

            soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_1r, REG_PORT_ANY,
                KIf,
                soc_property_get(unit, spn_PTP_BS_KI, bs_pll[bs_idx].ki));

            soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_1r, REG_PORT_ANY,
                KPf,
                soc_property_get(unit, spn_PTP_BS_KP, bs_pll[bs_idx].kp));

            soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_1r, REG_PORT_ANY,
                PDIVf,
                soc_property_get(unit, spn_PTP_BS_PDIV, bs_pll[bs_idx].pdiv));

            /* ndiv_int: 10 bits.  ndiv_frac: 24 bits, stored in upper 24
             * ndiv_int  =  BROAD_SYNC0_LCPLL_FBDIV_1[15:6];
             * ndiv_frac = {BROAD_SYNC0_LCPLL_FBDIV_1[5:0],
             *                      BROAD_SYNC0_LCPLL_FBDIV_0[31:14]};
             * So FBDIV_1 = (ndiv_int << 6) | (ndiv_frac >> (32-6))
             *    FBDIV_2 = (ndiv_frac >> 6)
             */
            bs_ndiv_high = ((soc_property_get(unit, spn_PTP_BS_NDIV_INT,
                                 bs_pll[bs_idx].ndiv_int) << 6) |
                            ((soc_property_get(unit, spn_PTP_BS_NDIV_FRAC,
                                 bs_pll[bs_idx].ndiv_frac) >> (32-6)) & 0x3f));
            bs_ndiv_low = (soc_property_get(unit, spn_PTP_BS_NDIV_FRAC,
                                  bs_pll[bs_idx].ndiv_frac) << 8);

            soc_reg_field32_modify(unit,
                TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY,
                BROAD_SYNC0_LCPLL_FBDIV_1f,
                bs_ndiv_high);

            soc_reg_field32_modify(unit,
                TOP_BROAD_SYNC0_LCPLL_FBDIV_CTRL_0r, REG_PORT_ANY,
                BROAD_SYNC0_LCPLL_FBDIV_0f,
                bs_ndiv_low);

            soc_reg_field32_modify(unit,
                TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY,
                BROAD_SYNC1_LCPLL_FBDIV_1f,
                bs_ndiv_high);

            soc_reg_field32_modify(unit,
                TOP_BROAD_SYNC1_LCPLL_FBDIV_CTRL_0r, REG_PORT_ANY,
                BROAD_SYNC1_LCPLL_FBDIV_0f,
                bs_ndiv_low);

            soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_0r, REG_PORT_ANY,
                CH0_MDIVf,
                soc_property_get(unit, spn_PTP_BS_MNDIV, bs_pll[bs_idx].mdiv));

            soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_0r, REG_PORT_ANY,
                CH0_MDIVf,
                soc_property_get(unit, spn_PTP_BS_MNDIV, bs_pll[bs_idx].mdiv));

            soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_1r, REG_PORT_ANY,
                LOAD_EN_CHf, 0);
            soc_reg_field32_modify(unit, TOP_BS_PLL0_CTRL_1r, REG_PORT_ANY,
                LOAD_EN_CHf, 1);

            soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_1r, REG_PORT_ANY,
                LOAD_EN_CHf, 0);
            soc_reg_field32_modify(unit, TOP_BS_PLL1_CTRL_1r, REG_PORT_ANY,
                LOAD_EN_CHf, 1);
        }

        soc_reg_field32_modify(unit, TOP_SOFT_RESET_REG_2r, REG_PORT_ANY,
            TOP_BS_PLL0_RST_Lf, 1);

        soc_reg_field32_modify(unit, TOP_SOFT_RESET_REG_2r, REG_PORT_ANY,
            TOP_BS_PLL1_RST_Lf, 1);

        sal_usleep(to_usec);
        SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL0_POST_RST_Lf, 1);
        soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_BS_PLL1_POST_RST_Lf, 1);
        SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    }

    if (!hitless) {
        /* Initialize XGPLLs */
        soc_reg_field32_modify(unit, TOP_SOFT_RESET_REGr, REG_PORT_ANY,
            TOP_LCPLL_SOFT_RESETf, 1);

        /* XGPLL0 */
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_1r, REG_PORT_ANY,
            PDIVf, 1);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_0r, REG_PORT_ANY,
            CH0_MDIVf, 0x14);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_6r, REG_PORT_ANY,
                               LDO_CTRLf, (rev_id < BCM56160_B0_REV_ID) ? 0x2a : 0x22);
        /* Use strap for setting of FREQ_DOUBLER */
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_7r, REG_PORT_ANY,
            FREQ_DOUBLER_ONf, (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0));
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_7r, REG_PORT_ANY,
            VCO_CONT_ADJf, 1);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_3r, REG_PORT_ANY,
            VCO_CURf, 0);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_5r, REG_PORT_ANY,
            VCO_GAINf, (rev_id < BCM56160_B0_REV_ID) ? 3 : 15);
        soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY,
            CMIC_TO_XG_PLL0_SW_OVWRf, 1);
        soc_reg_field32_modify(unit, TOP_XG0_LCPLL_FBDIV_CTRL_0r, REG_PORT_ANY,
            XG0_LCPLL_FBDIV_0f, 0);
        soc_reg_field32_modify(unit, TOP_XG0_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY,
            XG0_LCPLL_FBDIV_1f, 0x0fa0);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_5r, REG_PORT_ANY,
            CP1f, 1);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_5r, REG_PORT_ANY,
            CPf, 3);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_5r, REG_PORT_ANY,
            CZf, 3);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_5r, REG_PORT_ANY,
            RPf, 7);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_5r, REG_PORT_ANY,
            RZf, (rev_id < BCM56160_B0_REV_ID) ? 7 : 2);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_5r, REG_PORT_ANY,
            ICPf, (rev_id < BCM56160_B0_REV_ID) ? 16 : 10);
        soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_7r, REG_PORT_ANY,
            CPPf, 0x80);

        /* XGPLL1 */

        if (TOP_STRAP_STATUS_LCPLL1_REF(strap_sts)) {
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_1r, REG_PORT_ANY,
                PDIVf, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_0r, REG_PORT_ANY,
                CH0_MDIVf, 0x14);
            /* Use strap for setting of FREQ_DOUBLER */
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY,
                FREQ_DOUBLER_ONf, (TOP_STRAP_STATUS_1_REF(strap_sts_1) == 0));
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_6r, REG_PORT_ANY,
                MSC_CTRLf, 0x00a2);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_6r, REG_PORT_ANY,
                LDO_CTRLf, (rev_id < BCM56160_B0_REV_ID) ? 0x2a : 0x22);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY,
                VCO_CONT_ADJf, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_3r, REG_PORT_ANY,
                VCO_CURf, 0);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                VCO_GAINf, (rev_id < BCM56160_B0_REV_ID) ? 3 : 15);
            soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY,
                CMIC_TO_XG_PLL1_SW_OVWRf, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                CP1f, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                CPf, 3);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                CZf, 3);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                RPf, 7);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                RZf, (rev_id < BCM56160_B0_REV_ID) ? 7 : 2);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                ICPf, (rev_id < BCM56160_B0_REV_ID) ? 16 : 10);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY,
                CPPf, 0x80);
            soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_0r, REG_PORT_ANY,
                XG1_LCPLL_FBDIV_0f, 0);
            soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY,
                XG1_LCPLL_FBDIV_1f, 0x0fa0);
        } else {
            /* TOP_STRAP_STATUS_LCPLL1_REF == 0 */
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_1r, REG_PORT_ANY,
                PDIVf, 3);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_0r, REG_PORT_ANY,
                CH0_MDIVf, 0x14);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY,
                FREQ_DOUBLER_ONf, 0);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_6r, REG_PORT_ANY,
                MSC_CTRLf, 0xcaa4);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY,
                VCO_CONT_ADJf, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_3r, REG_PORT_ANY,
                VCO_CURf, 0);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                VCO_GAINf, (rev_id < BCM56160_B0_REV_ID) ? 3 : 15);
            soc_reg_field32_modify(unit, TOP_MISC_CONTROL_1r, REG_PORT_ANY,
                CMIC_TO_XG_PLL1_SW_OVWRf, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                CP1f, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                CPf, 1);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                CZf, 3);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                RPf, 0);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                RZf, (rev_id < BCM56160_B0_REV_ID) ? 8 : 2);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_5r, REG_PORT_ANY,
                ICPf, (rev_id < BCM56160_B0_REV_ID) ? 32 : 20);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_7r, REG_PORT_ANY,
                CPPf, 0x80);
            soc_reg_field32_modify(unit, TOP_XG_PLL1_CTRL_6r, REG_PORT_ANY,
                LDO_CTRLf, (rev_id < BCM56160_B0_REV_ID) ? 0x2a : 0x22);
            soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_0r, REG_PORT_ANY,
                XG1_LCPLL_FBDIV_0f, 0);
            soc_reg_field32_modify(unit, TOP_XG1_LCPLL_FBDIV_CTRL_1r, REG_PORT_ANY,
                XG1_LCPLL_FBDIV_1f, 0x0f00);
        }

        soc_reg_field32_modify(unit, TOP_SOFT_RESET_REGr, REG_PORT_ANY,
            TOP_LCPLL_SOFT_RESETf, 0);
    }

    /* Select LCPLL0 as external PHY reference clock and output 125MHz */
    /* Pull GPIO3 low to reset the ext. PHY */
    SOC_IF_ERROR_RETURN(_soc_hurricane3_gpio_set(unit, 3, TRUE, 0));

    SOC_IF_ERROR_RETURN
        (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_0r,
                                REG_PORT_ANY, CH5_MDIVf, 0x19));

    /* Select LCPLL0 clock source. */
    refclk = soc_property_get(unit, spn_LC_PLL_EXT_CLOCK, 0);
    if (refclk == 0) {
        /* Clock source of LCPLL0 is from internal XTAL. */
        SOC_IF_ERROR_RETURN
            (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_6r,
                                    REG_PORT_ANY, MSC_CTRLf, 0x71a2));
    } else {
        /* Clock source of LCPLL0 is from external XTAL. */
        if (refclk == 25) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_6r,
                                        REG_PORT_ANY, MSC_CTRLf, 0x71a4));
            /*
             * External source 25MHz, FREQ_DOUBLER_ONf = 1
             */
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_7r, REG_PORT_ANY,
                                        FREQ_DOUBLER_ONf, 1));
        } else if (refclk == 50) {
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_6r,
                                        REG_PORT_ANY, MSC_CTRLf, 0x71a4));
            /*
             * External source 50MHz, FREQ_DOUBLER_ONf = 0
             */
            SOC_IF_ERROR_RETURN
                (soc_reg_field32_modify(unit, TOP_XG_PLL0_CTRL_7r, REG_PORT_ANY,
                                        FREQ_DOUBLER_ONf, 0));
        } else {
            /* Other values. */
            LOG_WARN(BSL_LS_SOC_COMMON,
                (BSL_META_U(unit, "Warning: unsupported LC_PLL0 external "
                            "source clock %d MHz.\n"), refclk));
        }
    }

    /* Pull  GPIO high to leave the reset state */
    SOC_IF_ERROR_RETURN(_soc_hurricane3_gpio_set(unit, 3, TRUE, 1));

    /* TSCx or QTCx should be disabled in some sku. */
    if (matched_devid_idx[unit] == -1) {
        LOG_WARN(BSL_LS_SOC_COMMON,
           (BSL_META_U(unit, "Warning: soc_hurricane3_port_config_init should "
                        "be invoked first! Choose bcm534x1 port config.\n")));
        matched_devid_idx[unit] = 0;
    }

    matched_sku_info = &_hr3_sku_port_config[matched_devid_idx[unit]];
    disabled_bmp = matched_sku_info->disabled_tsc_bmp;
    disable_tsc = TOP_STRAP_STATUS_TSC_DISABLE(strap_sts);
    disable_qtc = TOP_STRAP_STATUS_QTC_DISABLE(strap_sts);
    disable_gphy = matched_sku_info->disabled_gphy_bmp;
    for (i = 0; i < _HR3_MAX_TSC_COUNT; i++) {
        if((1 << i) & disabled_bmp){
            disable_tsc |= (1 << i);
        }
    }

    disabled_bmp = matched_sku_info->disabled_qtc_bmp;
    for (i = 0; i < _HR3_MAX_QTC_COUNT; i++) {
        if((1 << i) & disabled_bmp){
            disable_qtc |= (1 << i);
        }
    }

    if (disable_tsc) {
        SOC_IF_ERROR_RETURN(
            _soc_hurricane3_core_disable(unit, SOC_HR3_PORT_CORE_TYPE_TSC,
                                        disable_tsc, 0));
    }
    if (disable_qtc) {
        SOC_IF_ERROR_RETURN(
            _soc_hurricane3_core_disable(unit, SOC_HR3_PORT_CORE_TYPE_QTC,
                                        disable_qtc, disable_gphy));
    }

    /* Configure GPHY bypass mode */
    SOC_IF_ERROR_RETURN(
        _soc_hurricane3_port_gphy_mode_init(unit));

    /* re-ordering the port sequence */
    soc_esw_dport_init(unit);

    SOC_IF_ERROR_RETURN(READ_PGW_CTRL_0r(unit, &rval));
    soc_reg_field_set(unit, PGW_CTRL_0r, &rval, SW_PM4X10_DISABLEf, disable_tsc);
    soc_reg_field_set(unit, PGW_CTRL_0r, &rval, SW_QTC_DISABLEf, disable_qtc);
    SOC_IF_ERROR_RETURN(WRITE_PGW_CTRL_0r(unit, rval));
    sal_usleep(to_usec);

    /*
     * Bring port blocks out of reset
     */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_QGPHY_RST_Lf, 0xf);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP0_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_XLP1_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_GXP0_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_GXP1_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));
    sal_usleep(to_usec);

    /* Bring network sync out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_TS_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));
    sal_usleep(to_usec);

    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval, TOP_TS_PLL_POST_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    /* Bring IP, EP, and MMU blocks out of reset */
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REGr(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_EP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_IP_RST_Lf, 1);
    soc_reg_field_set(unit, TOP_SOFT_RESET_REGr, &rval, TOP_MMU_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REGr(unit, rval));
    sal_usleep(to_usec);

    return SOC_E_NONE;
}


STATIC int
_soc_hurricane3_age_timer_get(int unit, int *age_seconds, int *enabled)
{
    uint32 value;

    SOC_IF_ERROR_RETURN(READ_L2_AGE_TIMERr(unit, &value));
    *enabled = soc_reg_field_get(unit, L2_AGE_TIMERr, value, AGE_ENAf);
    *age_seconds = soc_reg_field_get(unit, L2_AGE_TIMERr, value, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_hurricane3_age_timer_max_get(int unit, int *max_seconds)
{
    *max_seconds =
        soc_reg_field_get(unit, L2_AGE_TIMERr, 0xffffffff, AGE_VALf);

    return SOC_E_NONE;
}

STATIC int
_soc_hurricane3_age_timer_set(int unit, int age_seconds, int enable)
{
    uint32 value;

    value = 0;
    soc_reg_field_set(unit, L2_AGE_TIMERr, &value, AGE_ENAf, enable);
    soc_reg_field_set(unit, L2_AGE_TIMERr, &value, AGE_VALf, age_seconds);
    SOC_IF_ERROR_RETURN(WRITE_L2_AGE_TIMERr(unit, value));

    return SOC_E_NONE;
}

static const soc_reg_t pvtmon_result_reg[] = {
    TOP_PVTMON_RESULT_0r
};

int
soc_hr3_temperature_monitor_get(int unit,
          int temperature_max,
          soc_switch_temperature_monitor_t *temperature_array,
          int *temperature_count)
{
    soc_reg_t reg;
    int index;
    uint32 rval;
    int fval, cur, peak;
    int num_entries_out;

    *temperature_count = 0;
    if (COUNTOF(pvtmon_result_reg) > temperature_max) {
        num_entries_out = temperature_max;
    } else {
        num_entries_out = COUNTOF(pvtmon_result_reg);
    }

    for (index = 0; index < num_entries_out; index++) {
        reg = pvtmon_result_reg[index];
        SOC_IF_ERROR_RETURN(soc_reg32_get(unit, reg, REG_PORT_ANY, 0, &rval));

        fval = soc_reg_field_get(unit, reg, rval, PVT_DATAf);
        cur = (41004000 - (48705 * fval)) / 10000;
        fval = soc_reg_field_get(unit, reg, rval, PEAK_TEMP_DATAf);
        peak = (41004000 - (48705 * fval)) / 10000;
        (temperature_array + index)->curr = cur;
        (temperature_array + index)->peak = peak;
    }
    SOC_IF_ERROR_RETURN(READ_TOP_SOFT_RESET_REG_2r(unit, &rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 0);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));
    soc_reg_field_set(unit, TOP_SOFT_RESET_REG_2r, &rval,
                      TOP_TEMP_MON_PEAK_RST_Lf, 1);
    SOC_IF_ERROR_RETURN(WRITE_TOP_SOFT_RESET_REG_2r(unit, rval));

    *temperature_count=num_entries_out;
    return SOC_E_NONE;
}

typedef struct _hr3_pgw_reg_info_s {
    soc_reg_t   pgw_reg;
    uint32      valid_bm;
    uint32      invalid_bm;
    uint32      invalid_blk_num_bm;
}_hr3_pgw_reg_info_t;

STATIC _hr3_pgw_reg_info_t _hr3_pgw_reg_info[] = {
    {PGW_GX_CONFIGr, 0x3c, 0, 0x1f},
    {PGW_GX_TXFIFO_CTRLr, 0x3c, 0, 0x1f},
    {PGW_GX_SPARE0_REGr, 0x3c, 0, 0x1f},
    {PGW_GX_RXFIFO_SOFT_RESETr, 0, 0, 0x1f},
    {PGW_GX_ECC_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO0_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO0_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO1_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO1_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO0_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO0_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO1_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO1_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO2_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO2_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO3_ECC_SBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO3_ECC_DBE_STATUSr, 0, 0, 0x1f},
    {PGW_GX_TXFIFO_OVERFLOWr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO0_OVERFLOW_ERRORr, 0, 0, 0x1f},
    {PGW_GX_RXFIFO1_OVERFLOW_ERRORr, 0, 0, 0x1f},
    {PGW_GX_TM0_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM1_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM2_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM3_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM4_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM5_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM6_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM7_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_TM8_CONTROLr, 0, 0, 0x1f},
    {PGW_GX_BYPASS_LED_CHAIN_CONFIGr, 0, 0, 0x1f},
    {PGW_GX_INTR_STATUSr, 0, 0, 0x1f},
    {PGW_GX_INTR_ENABLEr, 0, 0, 0x1f},
    {PGW_XL_CONFIGr, 0, 0x3c, 0x20},
    {PGW_XL_TXFIFO_CTRLr, 0, 0x3c, 0x20},
    {PGW_XL_SPARE0_REGr, 0, 0x3c, 0x20},
    {PGW_XL_RXFIFO_SOFT_RESETr, 0, 0, 0x20},
    {PGW_XL_ECC_CONTROLr, 0, 0, 0x20},
    {PGW_XL_RXFIFO_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_RXFIFO_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO0_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO0_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO1_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO1_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO2_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO2_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO3_ECC_SBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO3_ECC_DBE_STATUSr, 0, 0, 0x20},
    {PGW_XL_TXFIFO_OVERFLOWr, 0, 0, 0x20},
    {PGW_XL_RXFIFO_OVERFLOW_ERRORr, 0, 0, 0x20},
    {PGW_XL_TM0_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM1_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM2_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM3_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM4_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM5_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM6_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM7_CONTROLr, 0, 0, 0x20},
    {PGW_XL_TM8_CONTROLr, 0, 0, 0x20},
    {PGW_XL_BYPASS_LED_CHAIN_CONFIGr, 0, 0, 0x20},
    {PGW_XL_INTR_STATUSr, 0, 0, 0x20},
    {PGW_XL_INTR_ENABLEr, 0, 0, 0x20},
    {INVALIDr, 0, 0},
};

/*
 * Function:
 *  soc_hurricane3_pgw_reg_blk_index_get
 * Purpose:
 *  Deal with the blk, blknum for PGW_GX and PGW_XL registers
 * Parameters:
 *  reg (IN): register.
 *  port (IN): logical port if PGW_GX's port register.
 *  bm (IN/OUT): bm should be added for the reg.
 *  block (IN/OUT): blk used to access the reg.
 *  index (OUT): port index of the reg.
 *  invalid_blk_check (IN): perform the blk check.
 *                          skip the block if the return value = 1.
 * Return:
 *   SOC_E_NOT_FOUND : w/o bm,blk,invalid_blk_check case, register not matched.
 *   1 : register matched and the block/index has been override.
 *   1 : register matched and the valid bm has been override.
 *   1 : skip the block when the invalid_blk_check=1
 *   SOC_E_PARAM : invalid paramter
 */
int
soc_hurricane3_pgw_reg_blk_index_get(int unit,
    soc_reg_t reg, soc_port_t port,
    pbmp_t *bm, int *block, int *index, int invalid_blk_check) {

    int i, p, phy_port, blk_num, pgw_blk;
    soc_reg_info_t *reginfo;
    _hr3_pgw_reg_info_t *pgw_reg = NULL;
    pbmp_t pgw_pbm, pgw_invalid_pbm;

    pgw_blk = -1;
    SOC_PBMP_CLEAR(pgw_pbm);

    for (i = 0; _hr3_pgw_reg_info[i].pgw_reg != INVALIDr; i ++) {
        if (reg == _hr3_pgw_reg_info[i].pgw_reg){
            pgw_reg = &_hr3_pgw_reg_info[i];
            break;
        }
    }

    if (!pgw_reg) {
        return SOC_E_NOT_FOUND;
    }

    reginfo = &SOC_REG_INFO(unit, reg);
    phy_port = 0;
    if (reginfo->regtype == soc_portreg) {
        SOC_PBMP_WORD_SET(pgw_pbm, 0, pgw_reg->valid_bm);
        SOC_PBMP_WORD_SET(pgw_invalid_pbm, 0, pgw_reg->invalid_bm);
        phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    }

    if (bm != NULL) {
        SOC_PBMP_ITER(pgw_pbm, p) {
            SOC_PBMP_PORT_ADD(*bm, p);
        }
        return 1;
    }
    if (block) {
        if (reginfo->regtype == soc_portreg) {
            if( SOC_PORT_BLOCK_TYPE(unit,phy_port) == SOC_BLK_GXPORT ){
                if(SOC_PBMP_MEMBER(pgw_pbm, port)) {
                    /* get the blk from phy_port=2 bindex=1 i.e. XLPORT5*/
                    pgw_blk = SOC_PORT_IDX_BLOCK(unit, 2, 1);
                    if (index) {
                        *index = phy_port - 2;
                    }
                    if (!invalid_blk_check) {
                        *block = pgw_blk;
                        return 1;
                    }
                }
                if(SOC_PBMP_MEMBER(pgw_invalid_pbm, port)) {
                    *block = 0;
                    return 1;
                }
            }
        }
    }
    if (invalid_blk_check){
        if(!block){
            return SOC_E_PARAM;
        }
        /* check if the *block is valid for the reg */

        if (pgw_blk == -1) {
            pgw_blk = *block;
        }
        blk_num = SOC_BLOCK_NUMBER(unit, pgw_blk) & 0xff;
        if (pgw_reg->invalid_blk_num_bm & (1 << blk_num)){
            return 1;
        }
    }
    return SOC_E_NONE;
}

int soc_hurricane3_pgw_rx_fifo_reset(int unit, int port, int reset)
{
    int phy_port = SOC_INFO(unit).port_l2p_mapping[port];
    uint32 rval;
    int block = -1;
    int pindex = -1;
    int port_num_blktype, i;

    if (SOC_PORT_BLOCK_TYPE(unit, phy_port) != SOC_BLK_GPORT) {
        return SOC_E_UNAVAIL;
    }

    if (!SOC_REG_IS_VALID(unit, PGW_GE_RXFIFO_SOFT_RESETr)) {
        return SOC_E_UNAVAIL;
    }

    port_num_blktype = SOC_DRIVER(unit)->port_num_blktype > 1 ?
        SOC_DRIVER(unit)->port_num_blktype : 1;

    for (i = 0; i < port_num_blktype; i++) {
        block = SOC_PORT_IDX_BLOCK(unit, phy_port, i);
        if (block < 0) {
            break;
        }

        if (SOC_BLOCK_TYPE(unit, block) == SOC_BLK_PGW_GE) {
            pindex = SOC_PORT_IDX_BINDEX(unit, phy_port, i);

            SOC_IF_ERROR_RETURN
                (READ_PGW_GE_RXFIFO_SOFT_RESETr(unit, port, &rval));

            if (reset) {
                rval |= 1 << pindex;
            } else {
                rval &= ~(1 << pindex);
            }

            SOC_IF_ERROR_RETURN
                (WRITE_PGW_GE_RXFIFO_SOFT_RESETr(unit, port, rval));

            break;
        }
    }

    return SOC_E_NONE;
}

int
_soc_hurricane3_features(int unit, soc_feature_t feature) {

    uint16              dev_id;
    uint8               rev_id;
    int sku ;

    soc_cm_get_id(unit, &dev_id, &rev_id);
    soc_hurricane3_chip_sku_get(unit, &sku);

    switch (feature) {
        case soc_feature_arl_hashed:
        case soc_feature_arl_insert_ovr:
        case soc_feature_cfap_pool:
        case soc_feature_cos_rx_dma:
        case soc_feature_dcb_type34:
        case soc_feature_ingress_metering:
        case soc_feature_egress_metering:
        case soc_feature_l3_lookup_cmd:
        case soc_feature_led_proc:
        case soc_feature_led_data_offset_a0:
        case soc_feature_schmsg_alias:
        case soc_feature_stack_my_modid:
        case soc_feature_stat_dma:
        case soc_feature_cpuport_stat_dma:
        case soc_feature_table_dma:
        case soc_feature_tslam_dma:
        case soc_feature_stg:
        case soc_feature_stg_xgs:
        case soc_feature_remap_ut_prio:
        case soc_feature_xgxs_v7:
        case soc_feature_phy_cl45:
        case soc_feature_aging_extended:
        case soc_feature_modmap:
        case soc_feature_l2_hashed:
        case soc_feature_l2_lookup_cmd:
        case soc_feature_l2_lookup_retry:
        case soc_feature_l2_user_table:
        case soc_feature_schan_hw_timeout:
        case soc_feature_mdio_enhanced:
        case soc_feature_rxdma_cleanup:
        case soc_feature_fe_maxframe:
        case soc_feature_l2x_parity:
        case soc_feature_l3x_parity:
        case soc_feature_l2_modfifo:
        case soc_feature_parity_err_tocpu:
        case soc_feature_nip_l3_err_tocpu:
        case soc_feature_l3mtu_fail_tocpu:
        case soc_feature_meter_adjust:
        case soc_feature_xgxs_power:
        case soc_feature_src_modid_blk:
        case soc_feature_src_modid_blk_ucast_override:
        case soc_feature_src_modid_blk_opcode_override:
        case soc_feature_egress_blk_ucast_override:
        case soc_feature_stat_jumbo_adj:
        case soc_feature_stat_xgs3:
        case soc_feature_port_trunk_index:
        case soc_feature_port_flow_hash:
        case soc_feature_cpuport_switched:
        case soc_feature_cpuport_mirror:
        case soc_feature_higig2:
        case soc_feature_color:
        case soc_feature_color_inner_cfi:
        case soc_feature_color_prio_map:
        case soc_feature_untagged_vt_miss:
        case soc_feature_module_loopback:
        case soc_feature_dscp_map_per_port:
        case soc_feature_egr_dscp_map_per_port:
        case soc_feature_dscp_map_mode_all:
        case soc_feature_egr_mirror_path:
        case soc_feature_trunk_extended:
        case soc_feature_hg_trunking:
        case soc_feature_hg_trunk_override:
        case soc_feature_egr_vlan_check:
        case soc_feature_cpu_proto_prio:
        case soc_feature_hg_trunk_failover:
        case soc_feature_trunk_egress:
        case soc_feature_force_forward:
        case soc_feature_port_egr_block_ctl:
        case soc_feature_bucket_support:
        case soc_feature_remote_learn_trust:
        case soc_feature_src_mac_group:
        case soc_feature_storm_control:
        case soc_feature_hw_stats_calc:
        case soc_feature_mac_learn_limit:
        case soc_feature_linear_drr_weight:
        case soc_feature_igmp_mld_support:
        case soc_feature_basic_dos_ctrl:
        case soc_feature_enhanced_dos_ctrl:
        case soc_feature_proto_pkt_ctrl:
        case soc_feature_vlan_ctrl:
        case soc_feature_big_icmpv6_ping_check:
        case soc_feature_trunk_group_overlay:
        case soc_feature_xport_convertible:
        case soc_feature_dual_hash:
        case soc_feature_dscp:
        case soc_feature_rcpu_1:
        case soc_feature_unimac:
        case soc_feature_ifg_wb_include_unimac:
        case soc_feature_xlmac:
        case soc_feature_generic_table_ops:
        case soc_feature_static_pfm:
        case soc_feature_sgmii_autoneg:
        case soc_feature_rcpu_priority:
        case soc_feature_rcpu_tc_mapping:
        case soc_feature_mem_push_pop:
        case soc_feature_dcb_reason_hi:
        case soc_feature_multi_sbus_cmds:
        case soc_feature_new_sbus_format:
        case soc_feature_new_sbus_old_resp:
        case soc_feature_sbus_format_v4:
        case soc_feature_fifo_dma:
        case soc_feature_fifo_dma_active:
        case soc_feature_l2_pending:
        case soc_feature_internal_loopback:
        case soc_feature_packet_rate_limit:
        case soc_feature_system_mac_learn_limit:
        case soc_feature_field:
        case soc_feature_field_mirror_ovr:
        case soc_feature_field_udf_higig:
        case soc_feature_field_udf_ethertype:
        case soc_feature_field_comb_read:
        case soc_feature_field_wide:
        case soc_feature_field_slice_enable:
        case soc_feature_field_cos:
        case soc_feature_field_color_indep:
        case soc_feature_field_qual_drop:
        case soc_feature_field_qual_IpType:
        case soc_feature_field_qual_Ip6High:
        case soc_feature_field_ingress_global_meter_pools:
        case soc_feature_field_ingress_ipbm:
        case soc_feature_field_egress_flexible_v6_key:
        case soc_feature_field_egress_global_counters:
        case soc_feature_field_ing_egr_separate_packet_byte_counters:
        case soc_feature_field_egress_metering:
        case soc_feature_field_intraslice_double_wide:
        case soc_feature_field_virtual_slice_group:
        case soc_feature_field_action_timestamp:
        case soc_feature_field_action_l2_change:
        case soc_feature_field_virtual_queue:
        case soc_feature_field_action_redirect_nexthop:
        case soc_feature_field_slice_dest_entity_select:
        case soc_feature_field_packet_based_metering:
        case soc_feature_lport_tab_profile:
        case soc_feature_ignore_cmic_xgxs_pll_status:
        case soc_feature_use_double_freq_for_ddr_pll:
        case soc_feature_counter_parity:
        case soc_feature_extended_pci_error:
        case soc_feature_qos_profile:
        case soc_feature_rx_timestamp:
        case soc_feature_rx_timestamp_upper:
        case soc_feature_logical_port_num:
        case soc_feature_timestamp_counter:
        case soc_feature_generic_counters:
        case soc_feature_modport_map_profile:
        case soc_feature_modport_map_dest_is_hg_port_bitmap:
        case soc_feature_eee:
        case soc_feature_xy_tcam:
        case soc_feature_xy_tcam_direct:
        case soc_feature_xy_tcam_28nm:
        case soc_feature_uc:
        case soc_feature_cmicm:
        case soc_feature_iproc:
        case soc_feature_iproc_7:
        case soc_feature_iproc_ddr:
        case soc_feature_unified_port:
        case soc_feature_sbusdma:
        case soc_feature_mirror_encap_profile:
        case soc_feature_higig_misc_speed_support:
        case soc_feature_vpd_profile:
        case soc_feature_color_prio_map_profile:
        case soc_feature_mem_parity_eccmask:
        case soc_feature_discard_ability:
        case soc_feature_wred_drop_counter_per_port:
        case soc_feature_l2_no_vfi:
        case soc_feature_gmii_clkout:
        case soc_feature_field_action_pfc_class:
        case soc_feature_fifo_dma_hu2:
        case soc_feature_system_reserved_vlan:
        case soc_feature_ser_parity:
        case soc_feature_mem_cache:
        case soc_feature_mem_wb_cache_reload:
        case soc_feature_ser_engine:
        case soc_feature_ser_system_scrub:
        case soc_feature_regs_as_mem:
        case soc_feature_cmicd_v2:
        case soc_feature_cmicm_extended_interrupts:
        case soc_feature_int_common_init:
        case soc_feature_inner_tpid_enable:
        case soc_feature_no_tunnel:
        case soc_feature_ecn_wred:
        case soc_feature_eee_bb_mode:
        case soc_feature_field_oam_actions:
        case soc_feature_hg_no_speed_change:
        case soc_feature_src_modid_base_index:
        case soc_feature_avs:
        case soc_feature_l2_overflow:
        case soc_feature_l2_overflow_bucket:
        case soc_feature_l2_learn_stats:
        case soc_feature_custom_header:
        case soc_feature_ing_capwap_parser:
        case soc_feature_tsce:
        case soc_feature_field_qual_vlanformat_reverse:
        case soc_feature_cpureg_dump:
        case soc_feature_hr2_dual_hash:
        case soc_feature_ignore_mem_write_nak:
        case soc_feature_unimac_reset_wo_clock:
        case soc_feature_internal_phy_link_check:
        case soc_feature_field_udf_offset_hg_114B:
        case soc_feature_field_udf_offset_hg2_110B:
        case soc_feature_vlan_action:
        case soc_feature_eee_stat_clear_directly:
        case soc_feature_pktpri_as_dot1p:
        case soc_feature_cosq_hol_drop_packet_count:
        case soc_feature_hg2_light_in_portmacro:
        case soc_feature_vlan_egress_membership_l3_only:
        case soc_feature_memory_2bit_ecc_ser:
        case soc_feature_switch_match:
        case soc_feature_sync_port_lport_tab:
        case soc_feature_serdes_firmware_pos_by_host_endian:
        case soc_feature_dport_update_hl:
        case soc_feature_no_mirror_truncate:
            return TRUE;
        case soc_feature_hr3_lite_lpm_shadow_hit:
        case soc_feature_field_action_l3_route_disabled:
            if (sku == SOC_HR3_SKU_HURRICANE3LITE) {
                /* HR3-Lite */
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_field_multi_stage:
            if ((sku == SOC_HR3_SKU_HURRICANE3) ||
                (sku == SOC_HR3_SKU_BUCKHOUND)) {
                /* Hurricane3, Buckhound */
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_time_v3_no_bs:
        case soc_feature_field_slice_size128:
            if ((sku == SOC_HR3_SKU_HURRICANE3) ||
                (sku == SOC_HR3_SKU_BUCKHOUND)) { /* Hurricane3/Buckhound */
                return FALSE;
            } else {
                return TRUE;
            }
        case soc_feature_l3_no_ecmp:
            if (sku == SOC_HR3_SKU_HURRICANE3) {
                /* Hurricane3 has ECMP support */
                return FALSE;
            } else {
                return TRUE;
            }
        case soc_feature_field_slices8:
        case soc_feature_field_meter_pools8:
        case soc_feature_e2ecc:
        case soc_feature_priority_flow_control:
        case soc_feature_gh_style_pfc_config:
        case soc_feature_time_support:
        case soc_feature_time_v3:
        case soc_feature_timesync_support:
        case soc_feature_timesync_v3:
        case soc_feature_timesync_timestampingmode:
        case soc_feature_flowcnt:
        case soc_feature_ip_subnet_based_vlan:
        case soc_feature_vlan_translation:
        case soc_feature_mac_based_vlan:
        case soc_feature_vlan_translation_range:
        case soc_feature_vlan_mc_flood_ctrl:
        case soc_feature_vlan_egr_it_inner_replace:
        case soc_feature_higig_lookup:
        case soc_feature_proxy_port_property:
        case soc_feature_oam:
        case soc_feature_miml:
            if (sku == SOC_HR3_SKU_FOXHOUND2) { /* Foxhound2 */
                return FALSE;
            } else {
                return TRUE;
            }
        case soc_feature_miml_no_l3:
            /*
             * Buckhound doesn't support L3 feature but MiML reuses some L3 functions
             * for resource management.
             */
            if (sku == SOC_HR3_SKU_BUCKHOUND) { /* Buckhound */
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_field_slices4:
        case soc_feature_field_meter_pools4:
            if (sku == SOC_HR3_SKU_FOXHOUND2) { /* Foxhound2 */
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_port_extension:
        case soc_feature_niv:
            if ((sku == SOC_HR3_SKU_HURRICANE3) ||
                (sku == SOC_HR3_SKU_BUCKHOUND)) { /* Hurricane3/Buckhound */
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_gphy:
            if (_hr3_sku_port_config[matched_devid_idx[unit]].gphy_bypass) {
                return FALSE;
            } else {
                return TRUE;
            }
        /* L3 feature for HR3 SKU basis supporting */
        case soc_feature_l3:
        case soc_feature_l3_ip6:
        case soc_feature_l3_entry_key_type:
        case soc_feature_lpm_tcam:
        case soc_feature_ip_mcast:
        case soc_feature_ip_mcast_repl:
        case soc_feature_ipmc_unicast:
        case soc_feature_ipmc_use_configured_dest_mac:
        case soc_feature_l3mc_use_egress_next_hop:
        case soc_feature_l3_sgv:
            if ((sku == SOC_HR3_SKU_BUCKHOUND) ||
                (sku == SOC_HR3_SKU_FOXHOUND2)) {
                /* Buckhound/Foxhound2 */
                return FALSE;
            } else {
                return TRUE;
            }
        case soc_feature_l3_dynamic_ecmp_group:
        case soc_feature_urpf:
        case soc_feature_l3_ingress_interface:
        case soc_feature_l3_iif_zero_invalid:
        case soc_feature_l3_iif_under_4k:
            if (sku == SOC_HR3_SKU_HURRICANE3) {
                /* Hurricane3 */
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_hr3_switch_encap_index_shift2_war:
            if (rev_id == BCM56160_A0_REV_ID) {
                /* WAR: Switch Encap index of EGR_HEADER_ENCAP_DATA is shifted << 2 bits */
                return TRUE;
            } else {
                return FALSE;
            }
        case soc_feature_hr3_egphy28_phyrev_override:
            if ((sku == SOC_HR3_SKU_HURRICANE3) ||
                (sku == SOC_HR3_SKU_HURRICANE3LITE) ||
                (sku == SOC_HR3_SKU_BUCKHOUND) ||
                (sku == SOC_HR3_SKU_FOXHOUND2)) {
                /* Use EGPHY_28 Hurricane3 family */
                return TRUE;
            } else {
                return FALSE;
            }
        default:
            return FALSE;
    }
}


/*
 * Hurricane3 chip driver functions.
 */
soc_functions_t soc_hurricane3_drv_funs = {
    _soc_hurricane3_misc_init,
    _soc_hurricane3_mmu_init,
    _soc_hurricane3_age_timer_get,
    _soc_hurricane3_age_timer_max_get,
    _soc_hurricane3_age_timer_set,
    _soc_hurricane3_tscx_firmware_set,
    _soc_hurricane3_tscx_reg_read,
    _soc_hurricane3_tscx_reg_write,
};

#endif /* BCM_HURRICANE3_SUPPORT */
