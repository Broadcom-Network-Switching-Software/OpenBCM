/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *         
 *     
 * DO NOT EDIT THIS FILE!
 */

#include <soc/types.h>
#include <soc/error.h>
#include <soc/portmod/portmod_internal.h>
#include <soc/portmod/portmod.h>
#include <soc/portmod/portmod_dispatch.h>


        
#ifdef _ERR_MSG_MODULE_NAME
#error "_ERR_MSG_MODULE_NAME redefined"
#endif
#define _ERR_MSG_MODULE_NAME BSL_LS_SOC_PORT

#ifdef PORTMOD_PM4X25_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x25_driver;
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10_driver;
#endif
#ifdef PORTMOD_PM4X10TD_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10td_driver;
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
extern __portmod__dispatch__t__ portmod_pm12x10_driver;
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10Q_driver;
#endif
#ifdef PORTMOD_PM_QTC_SUPPORT
extern __portmod__dispatch__t__ portmod_pm_qtc_driver;
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
extern __portmod__dispatch__t__ portmod_pmOsILKN_driver;
#endif
#ifdef PORTMOD_PM_OS_ILKN_50G_SUPPORT
extern __portmod__dispatch__t__ portmod_pmOsILKN_50G_driver;
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
extern __portmod__dispatch__t__ portmod_dnx_fabric_driver;
#endif
#ifdef PORTMOD_DNX_FABRIC_O_NIF_SUPPORT
extern __portmod__dispatch__t__ portmod_dnx_fabric_o_nif_driver;
#endif
#ifdef PORTMOD_PM8X50_FABRIC_SUPPORT
extern __portmod__dispatch__t__ portmod_pm8x50_fabric_driver;
#endif
#ifdef PORTMOD_PM4X25TD_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x25td_driver;
#endif
#ifdef PORTMOD_PM12X10_XGS_SUPPORT
extern __portmod__dispatch__t__ portmod_pm12x10_xgs_driver;
#endif
#ifdef PORTMOD_PM4X2P5_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x2p5_driver;
#endif
#ifdef PORTMOD_CPM4X25_SUPPORT
extern __portmod__dispatch__t__ portmod_cpm4x25_driver;
#endif
#ifdef PORTMOD_PM8X50_SUPPORT
extern __portmod__dispatch__t__ portmod_pm8x50_driver;
#endif
#ifdef PORTMOD_PM4X10_QTC_SUPPORT
extern __portmod__dispatch__t__ portmod_pm4x10_qtc_driver;
#endif
#ifdef PORTMOD_PMNULL_SUPPORT
extern __portmod__dispatch__t__ portmod_pmNull_driver;
#endif

__portmod__dispatch__t__* __portmod__dispatch__[portmodDispatchTypeCount] = {
#ifdef PORTMOD_PM4X25_SUPPORT
    &portmod_pm4x25_driver,
#endif
#ifdef PORTMOD_PM4X10_SUPPORT
    &portmod_pm4x10_driver,
#endif
#ifdef PORTMOD_PM4X10TD_SUPPORT
    &portmod_pm4x10td_driver,
#endif
#ifdef PORTMOD_PM12X10_SUPPORT
    &portmod_pm12x10_driver,
#endif
#ifdef PORTMOD_PM4x10Q_SUPPORT
    &portmod_pm4x10Q_driver,
#endif
#ifdef PORTMOD_PM_QTC_SUPPORT
    &portmod_pm_qtc_driver,
#endif
#ifdef PORTMOD_PM_OS_ILKN_SUPPORT
    &portmod_pmOsILKN_driver,
#endif
#ifdef PORTMOD_PM_OS_ILKN_50G_SUPPORT
    &portmod_pmOsILKN_50G_driver,
#endif
#ifdef PORTMOD_DNX_FABRIC_SUPPORT
    &portmod_dnx_fabric_driver,
#endif
#ifdef PORTMOD_DNX_FABRIC_O_NIF_SUPPORT
    &portmod_dnx_fabric_o_nif_driver,
#endif
#ifdef PORTMOD_PM8X50_FABRIC_SUPPORT
    &portmod_pm8x50_fabric_driver,
#endif
#ifdef PORTMOD_PM4X25TD_SUPPORT
    &portmod_pm4x25td_driver,
#endif
#ifdef PORTMOD_PM12X10_XGS_SUPPORT
    &portmod_pm12x10_xgs_driver,
#endif
#ifdef PORTMOD_PM4X2P5_SUPPORT
    &portmod_pm4x2p5_driver,
#endif
#ifdef PORTMOD_CPM4X25_SUPPORT
    &portmod_cpm4x25_driver,
#endif
#ifdef PORTMOD_PM8X50_SUPPORT
    &portmod_pm8x50_driver,
#endif
#ifdef PORTMOD_PM4X10_QTC_SUPPORT
    &portmod_pm4x10_qtc_driver,
#endif
#ifdef PORTMOD_PMNULL_SUPPORT
    &portmod_pmNull_driver,
#endif

};

int portmod_dispatch_type_t_validate(int unit, portmod_dispatch_type_t portmod_dispatch_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dispatch_type >= portmodDispatchTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_validate(int unit, const portmod_default_user_access_t* portmod_default_user_access)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_default_user_access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_default_user_access_t_init(int unit, portmod_default_user_access_t* portmod_default_user_access)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_default_user_access == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_default_user_access NULL parameter"));
    }
    sal_memset(portmod_default_user_access, 0, sizeof(portmod_default_user_access_t));
    portmod_default_user_access->unit = -1;
    portmod_default_user_access->blk_id = -1;
    portmod_default_user_access->mutex = NULL;
    portmod_default_user_access->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_user_data_t_validate(int unit, const portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10q_user_data == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_default_user_access_t_validate(unit, &portmod_pm4x10q_user_data->qsgmiie_user_data)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("qsgmiie_user_data validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_user_data_t_init(int unit, portmod_pm4x10q_user_data_t* portmod_pm4x10q_user_data)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10q_user_data == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10q_user_data NULL parameter"));
    }
    sal_memset(portmod_pm4x10q_user_data, 0, sizeof(portmod_pm4x10q_user_data_t));
    if(SOC_E_NONE != portmod_default_user_access_t_init(unit, &portmod_pm4x10q_user_data->qsgmiie_user_data)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("qsgmiie_user_data initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_fifo_status_t_validate(int unit, const portmod_fifo_status_t* portmod_fifo_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_fifo_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_fifo_status_t_init(int unit, portmod_fifo_status_t* portmod_fifo_status)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_fifo_status == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_fifo_status NULL parameter"));
    }
    sal_memset(portmod_fifo_status, 0, sizeof(portmod_fifo_status_t));
    portmod_fifo_status->timestamps_in_fifo = 0;
    portmod_fifo_status->timestamps_in_fifo_hi = 0;
    portmod_fifo_status->sequence_id = 0;
    portmod_fifo_status->timestamp_sub_nanosec = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_config_t_validate(int unit, const portmod_pfc_config_t* portmod_pfc_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pfc_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_config_t_init(int unit, portmod_pfc_config_t* portmod_pfc_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pfc_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pfc_config NULL parameter"));
    }
    sal_memset(portmod_pfc_config, 0, sizeof(portmod_pfc_config_t));
    portmod_pfc_config->type = 0;
    portmod_pfc_config->opcode = 0;
    portmod_pfc_config->classes = 0;
    portmod_pfc_config->da_oui = 0;
    portmod_pfc_config->da_nonoui = 0;
    portmod_pfc_config->rxpass = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_t_validate(int unit, const portmod_eee_t* portmod_eee)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_eee == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_t_init(int unit, portmod_eee_t* portmod_eee)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_eee == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_eee NULL parameter"));
    }
    sal_memset(portmod_eee, 0, sizeof(portmod_eee_t));
    portmod_eee->enable = 0;
    portmod_eee->tx_idle_time = 0;
    portmod_eee->tx_wake_time = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_clock_t_validate(int unit, const portmod_eee_clock_t* portmod_eee_clock)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_eee_clock == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_eee_clock_t_init(int unit, portmod_eee_clock_t* portmod_eee_clock)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_eee_clock == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_eee_clock NULL parameter"));
    }
    sal_memset(portmod_eee_clock, 0, sizeof(portmod_eee_clock_t));
    portmod_eee_clock->clock_gate = 0;
    portmod_eee_clock->clock_count = 0;
    portmod_eee_clock->timer_pulse = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vlan_tag_t_validate(int unit, const portmod_vlan_tag_t* portmod_vlan_tag)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_vlan_tag == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vlan_tag_t_init(int unit, portmod_vlan_tag_t* portmod_vlan_tag)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_vlan_tag == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_vlan_tag NULL parameter"));
    }
    sal_memset(portmod_vlan_tag, 0, sizeof(portmod_vlan_tag_t));
    portmod_vlan_tag->inner_vlan_tag = 0;
    portmod_vlan_tag->outer_vlan_tag = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_rx_control_t_validate(int unit, const portmod_rx_control_t* portmod_rx_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rx_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_rx_control_t_init(int unit, portmod_rx_control_t* portmod_rx_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rx_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rx_control NULL parameter"));
    }
    sal_memset(portmod_rx_control, 0, sizeof(portmod_rx_control_t));
    portmod_rx_control->flags = 0;
    portmod_rx_control->pass_control_frames = 0;
    portmod_rx_control->pass_pfc_frames = 0;
    portmod_rx_control->pass_pause_frames = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_multi_get_t_validate(int unit, const portmod_multi_get_t* portmod_multi_get)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_multi_get == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_multi_get_t_init(int unit, portmod_multi_get_t* portmod_multi_get)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_multi_get == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_multi_get NULL parameter"));
    }
    sal_memset(portmod_multi_get, 0, sizeof(portmod_multi_get_t));
    portmod_multi_get->flags = 0;
    portmod_multi_get->dev_addr = 0;
    portmod_multi_get->offset = 0;
    portmod_multi_get->max_size = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_loopback_mode_t_validate(int unit, portmod_loopback_mode_t portmod_loopback_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_loopback_mode >= portmodLoopbackCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_core_port_mode_t_validate(int unit, portmod_core_port_mode_t portmod_core_port_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_core_port_mode >= portmodPortModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_mode_aux_info_t_validate(int unit, portmod_port_mode_aux_info_t portmod_port_mode_aux_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_mode_aux_info >= portmodModeInfoCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_mac_soft_reset_mode_t_validate(int unit, portmod_mac_soft_reset_mode_t portmod_mac_soft_reset_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_mac_soft_reset_mode >= portmodMacSoftResetModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_prbs_mode_t_validate(int unit, portmod_prbs_mode_t portmod_prbs_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_prbs_mode >= portmodPrbsModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ext_to_int_phy_ctrlcode_t_validate(int unit, portmod_ext_to_int_phy_ctrlcode_t portmod_ext_to_int_phy_ctrlcode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ext_to_int_phy_ctrlcode >= portmodExtToInt_CtrlCode_Count) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_cpm_core_mode_t_validate(int unit, portmod_cpm_core_mode_t portmod_cpm_core_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpm_core_mode >= portmodCpmCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_core_port_enet_cpri_type_t_validate(int unit, portmod_core_port_enet_cpri_type_t portmod_core_port_enet_cpri_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_core_port_enet_cpri_type >= portmodCpmPrtCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_portphy_ability_t_validate(int unit, const portmod_portphy_ability_t* portmod_portphy_ability)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_portphy_ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_portphy_ability_t_init(int unit, portmod_portphy_ability_t* portmod_portphy_ability)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_portphy_ability == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_portphy_ability NULL parameter"));
    }
    sal_memset(portmod_portphy_ability, 0, sizeof(portmod_portphy_ability_t));
    portmod_portphy_ability->cur_mode = 0;
    portmod_portphy_ability->speed_half_duplex = 0;
    portmod_portphy_ability->speed_full_duplex = 0;
    portmod_portphy_ability->pause = 0;
    portmod_portphy_ability->interface = 0;
    portmod_portphy_ability->medium = 0;
    portmod_portphy_ability->loopback = 0;
    portmod_portphy_ability->flags = 0;
    portmod_portphy_ability->eee = 0;
    portmod_portphy_ability->fcmap = 0;
    portmod_portphy_ability->encap = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pdata_t_validate(int unit, const portmod_pdata_t* portmod_pdata)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pdata == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pdata_t_init(int unit, portmod_pdata_t* portmod_pdata)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pdata == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pdata NULL parameter"));
    }
    sal_memset(portmod_pdata, 0, sizeof(portmod_pdata_t));
    portmod_pdata->data = 0;
    portmod_pdata->enable = 0;
    portmod_pdata->pif = 0;
    portmod_pdata->ability = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_mode_info_t_validate(int unit, const portmod_port_mode_info_t* portmod_port_mode_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_mode_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_core_port_mode_t_validate(unit, portmod_port_mode_info->cur_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cur_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_mode_info_t_init(int unit, portmod_port_mode_info_t* portmod_port_mode_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_mode_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_mode_info NULL parameter"));
    }
    sal_memset(portmod_port_mode_info, 0, sizeof(portmod_port_mode_info_t));
    portmod_port_mode_info->cur_mode = 0;
    portmod_port_mode_info->lanes = 0;
    portmod_port_mode_info->port_index = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_validate(int unit, const portmod_port_diag_info_t* portmod_port_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_mode_info_t_validate(unit, &portmod_port_diag_info->core_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_diag_info_t_init(int unit, portmod_port_diag_info_t* portmod_port_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_diag_info NULL parameter"));
    }
    sal_memset(portmod_port_diag_info, 0, sizeof(portmod_port_diag_info_t));
    portmod_port_diag_info->interface = phymodInterfaceCount;
    PORTMOD_PBMP_CLEAR(portmod_port_diag_info->phys);
    portmod_port_diag_info->sub_phy = 0;
    portmod_port_diag_info->medium = 0;
    sal_memset(&(portmod_port_diag_info->core_mode), 0, sizeof(portmod_port_mode_info_t));
    sal_memset(&(portmod_port_diag_info->polarity), 0, sizeof(phymod_polarity_t));
    portmod_port_diag_info->fec = _SHR_PORT_PHY_FEC_COUNT;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_core_info_t_validate(int unit, const portmod_pm_core_info_t* portmod_pm_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_core_info_t_init(int unit, portmod_pm_core_info_t* portmod_pm_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_core_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_core_info NULL parameter"));
    }
    sal_memset(portmod_pm_core_info, 0, sizeof(portmod_pm_core_info_t));
    portmod_pm_core_info->ref_clk = -1;
    sal_memset(&(portmod_pm_core_info->lane_map), 0, sizeof(phymod_lane_map_t));
    portmod_pm_core_info->nof_phys = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_validate(int unit, const portmod_pm_diag_info_t* portmod_pm_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_diag_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_diag_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    if(SOC_E_NONE != portmod_pm_core_info_t_validate(unit, &portmod_pm_diag_info->core_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_diag_info_t_init(int unit, portmod_pm_diag_info_t* portmod_pm_diag_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_diag_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_diag_info NULL parameter"));
    }
    sal_memset(portmod_pm_diag_info, 0, sizeof(portmod_pm_diag_info_t));
    portmod_pm_diag_info->type = portmodDispatchTypeCount;
    sal_memset(&(portmod_pm_diag_info->core_info), 0, sizeof(portmod_pm_core_info_t));
    PORTMOD_PBMP_CLEAR(portmod_pm_diag_info->phys);
    SOC_PBMP_CLEAR(portmod_pm_diag_info->ports);
    portmod_pm_diag_info->serdes_id0 = -1;
    portmod_pm_diag_info->phy_id0 = -1;
    portmod_pm_diag_info->phy_id1 = -1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_ts_adjust_t_validate(int unit, const portmod_port_ts_adjust_t* portmod_port_ts_adjust)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_ts_adjust == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_ts_adjust_t_init(int unit, portmod_port_ts_adjust_t* portmod_port_ts_adjust)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_ts_adjust == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_ts_adjust NULL parameter"));
    }
    sal_memset(portmod_port_ts_adjust, 0, sizeof(portmod_port_ts_adjust_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_qtc_mode_t_validate(int unit, portmod_qtc_mode_t portmod_qtc_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_qtc_mode >= portmodQtcModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_init_config_t_validate(int unit, const portmod_port_init_config_t* portmod_port_init_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_init_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_mode_aux_info_t_validate(unit, portmod_port_init_config->port_mode_aux_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_mode_aux_info validation failed"));
    }

    if(SOC_E_NONE != portmod_cpm_core_mode_t_validate(unit, portmod_port_init_config->cpm_core_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cpm_core_mode validation failed"));
    }

    if(SOC_E_NONE != portmod_qtc_mode_t_validate(unit, portmod_port_init_config->qtc_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("qtc_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_init_config_t_init(int unit, portmod_port_init_config_t* portmod_port_init_config)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_init_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_init_config NULL parameter"));
    }
    sal_memset(portmod_port_init_config, 0, sizeof(portmod_port_init_config_t));
    portmod_port_init_config->cx4_10g = 0;
    portmod_port_init_config->pdetect1000x = 0;
    portmod_port_init_config->an_mode = phymod_AN_MODE_NONE;
    portmod_port_init_config->an_master_lane = 0;
    portmod_port_init_config->an_cl72 = 0;
    portmod_port_init_config->fs_cl72 = 0;
    portmod_port_init_config->an_fec = 0;
    portmod_port_init_config->sgmii_mstr = 0;
    portmod_port_init_config->serdes_driver_current = 0;
    portmod_port_init_config->serdes_1000x_at_6250_vco = 0;
    portmod_port_init_config->serdes_1000x_at_12500_vco = 0;
    portmod_port_init_config->serdes_1000x_at_25g_vco = 0;
    portmod_port_init_config->serdes_10g_at_25g_vco = 0;
    portmod_port_init_config->pll_divider_req = 0;
    portmod_port_init_config->rxaui_mode = 0;
    portmod_port_init_config->port_fallback_lane = 0;
    portmod_port_init_config->an_cl37 = 0;
    portmod_port_init_config->cl37_sgmii_war = 0;
    portmod_port_init_config->cl37_sgmii_cnt = 0;
    portmod_port_init_config->cl37_sgmii_RESTART_CNT = 2;
    portmod_port_init_config->an_cl73 = 0;
    portmod_port_init_config->is_hg = 0;
    portmod_port_init_config->polarity_overwrite = 0;
    portmod_port_init_config->lane_map_overwrite = 0;
    portmod_port_init_config->fw_load_method_overwrite = 0;
    portmod_port_init_config->ref_clk = 0;
    portmod_port_init_config->ref_clk_overwrite = 0;
    portmod_port_init_config->port_mode_aux_info = 0;
    for(_array_iter = 0 ; _array_iter < PORTMOD_TS_ADJUST_NUM ; _array_iter++){
        if(SOC_E_NONE != portmod_port_ts_adjust_t_init(unit, &portmod_port_init_config->port_ts_adjust[_array_iter])) {
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_ts_adjust initialization failed"));
        }
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_validate(int unit, const portmod_port_interface_config_t* portmod_port_interface_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_interface_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_interface_config_t_init(int unit, portmod_port_interface_config_t* portmod_port_interface_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_interface_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_interface_config NULL parameter"));
    }
    sal_memset(portmod_port_interface_config, 0, sizeof(portmod_port_interface_config_t));
    portmod_port_interface_config->interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->line_interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->serdes_interface = SOC_PORT_IF_NULL;
    portmod_port_interface_config->interface_modes = 0;
    portmod_port_interface_config->flags = 0;
    portmod_port_interface_config->port_refclk_int = -1;
    portmod_port_interface_config->port_num_lanes = 0;
    portmod_port_interface_config->speed = 0;
    portmod_port_interface_config->max_speed = 0;
    portmod_port_interface_config->encap_mode = 0;
    portmod_port_interface_config->pll_divider_req = 0;
    portmod_port_interface_config->port_op_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_speed_ability_t_validate(int unit, const portmod_port_speed_ability_t* portmod_port_speed_ability)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_speed_ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_speed_ability_t_init(int unit, portmod_port_speed_ability_t* portmod_port_speed_ability)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_speed_ability == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_speed_ability NULL parameter"));
    }
    sal_memset(portmod_port_speed_ability, 0, sizeof(portmod_port_speed_ability_t));
    portmod_port_speed_ability->speed = 0;
    portmod_port_speed_ability->num_lanes = 0;
    portmod_port_speed_ability->fec_type = _SHR_PORT_PHY_FEC_COUNT;
    portmod_port_speed_ability->medium = _SHR_PORT_MEDIUM_COUNT;
    portmod_port_speed_ability->pause = _SHR_PORT_PHY_PAUSE_COUNT;
    portmod_port_speed_ability->channel = _SHR_PORT_PHY_CHANNEL_COUNT;
    portmod_port_speed_ability->an_mode = _SHR_PORT_PHY_CONTROL_AUTONEG_MODE_COUNT;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_speed_ability_local_get(int unit, int port, int max_num_abilities, portmod_port_speed_ability_t* abilities, int* num_abilities)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(abilities == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("abilities NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_speed_ability_t_init(unit, abilities)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("abilities initialization failed"));
    }

    if(num_abilities == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("num_abilities NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_speed_ability_local_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_speed_ability_local_get(unit, port, pm_info, max_num_abilities, abilities, num_abilities);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_speed_ability_local_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_speed_config_t_validate(int unit, const portmod_speed_config_t* portmod_speed_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_speed_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_speed_config_t_init(int unit, portmod_speed_config_t* portmod_speed_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_speed_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_speed_config NULL parameter"));
    }
    sal_memset(portmod_speed_config, 0, sizeof(portmod_speed_config_t));
    portmod_speed_config->speed = 0;
    portmod_speed_config->num_lane = 0;
    portmod_speed_config->fec = 0;
    portmod_speed_config->link_training = 0;
    portmod_speed_config->lane_config = -1;
    portmod_speed_config->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vco_type_t_validate(int unit, portmod_vco_type_t portmod_vco_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_vco_type >= portmodVCOCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_validate(int unit, const portmod_pm_identifier_t* portmod_pm_identifier)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_identifier == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_identifier->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_identifier_t_init(int unit, portmod_pm_identifier_t* portmod_pm_identifier)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_identifier == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_identifier NULL parameter"));
    }
    sal_memset(portmod_pm_identifier, 0, sizeof(portmod_pm_identifier_t));
    portmod_pm_identifier->type = portmodDispatchTypeCount;
    portmod_pm_identifier->phy = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_validate(int unit, const portmod_port_add_info_t* portmod_port_add_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_add_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config validation failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_validate(unit, &portmod_port_add_info->init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config validation failed"));
    }

    if(SOC_E_NONE != portmod_speed_config_t_validate(unit, &portmod_port_add_info->speed_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config validation failed"));
    }

    if(SOC_E_NONE != portmod_vco_type_t_validate(unit, portmod_port_add_info->tvco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tvco validation failed"));
    }

    if(SOC_E_NONE != portmod_vco_type_t_validate(unit, portmod_port_add_info->ovco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ovco validation failed"));
    }

    switch(portmod_port_add_info->sub_phy) {
        case 0:
        case 1:
        case 2:
        case 3:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sub_phy not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_add_info_t_init(int unit, portmod_port_add_info_t* portmod_port_add_info)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_add_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_add_info NULL parameter"));
    }
    sal_memset(portmod_port_add_info, 0, sizeof(portmod_port_add_info_t));
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, &portmod_port_add_info->interface_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface_config initialization failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_init(unit, &portmod_port_add_info->init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config initialization failed"));
    }

    if(SOC_E_NONE != portmod_speed_config_t_init(unit, &portmod_port_add_info->speed_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config initialization failed"));
    }

    PORTMOD_PBMP_CLEAR(portmod_port_add_info->phys);
    PORTMOD_PBMP_CLEAR(portmod_port_add_info->phy_ports);
    portmod_port_add_info->sub_phy = 0;
    portmod_port_add_info->autoneg_en = 0;
    portmod_port_add_info->link_training_en = 0;
    portmod_port_add_info->flags = PORTMOD_PORT_ADD_F_FIRMWARE_LOAD_VERIFY;
    portmod_port_add_info->is_fabric_o_nif = 0;
    portmod_port_add_info->ilkn_core_id = 0;
    portmod_port_add_info->ilkn_port_is_over_fabric = 0;
    portmod_port_add_info->ilkn_burst_max = -1;
    portmod_port_add_info->ilkn_burst_min = -1;
    portmod_port_add_info->ilkn_burst_short = -1;
    portmod_port_add_info->ilkn_nof_segments = -1;
    portmod_port_add_info->ilkn_metaframe_period = -1;
    portmod_port_add_info->rx_retransmit = 0;
    portmod_port_add_info->tx_retransmit = 0;
    portmod_port_add_info->phy_op_mode = 0;
    portmod_port_add_info->phy_op_datapath = 0;
    portmod_port_add_info->ilkn_inb_cal_len_rx = -1;
    portmod_port_add_info->ilkn_inb_cal_len_tx = -1;
    portmod_port_add_info->ilkn_oob_cal_len_rx = -1;
    portmod_port_add_info->ilkn_oob_cal_len_tx = -1;
    portmod_port_add_info->reserved_channel_rx = 0;
    portmod_port_add_info->reserved_channel_tx = 0;
    PORTMOD_PBMP_CLEAR(portmod_port_add_info->ilkn_lanes);
    portmod_port_add_info->nof_aggregated_pms = 0;
    for(_array_iter = 0 ; _array_iter < PORTMOD_MAX_ILKN_AGGREGATED_PMS ; _array_iter++){
        if(SOC_E_NONE != portmod_pm_identifier_t_init(unit, &portmod_port_add_info->controlled_pms[_array_iter])) {
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("controlled_pms initialization failed"));
        }
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_validate(int unit, const portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dnx_fabric_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm_identifier_t_validate(unit, &portmod_dnx_fabric_create_info->fabric_o_nif_pm)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fabric_o_nif_pm validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dnx_fabric_create_info_t_init(int unit, portmod_dnx_fabric_create_info_t* portmod_dnx_fabric_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_dnx_fabric_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_dnx_fabric_create_info NULL parameter"));
    }
    sal_memset(portmod_dnx_fabric_create_info, 0, sizeof(portmod_dnx_fabric_create_info_t));
    portmod_dnx_fabric_create_info->ref_clk = phymodRefClkCount;
    portmod_dnx_fabric_create_info->com_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_dnx_fabric_create_info->access);
    phymod_lane_map_t_init(&portmod_dnx_fabric_create_info->lane_map);
    portmod_dnx_fabric_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_dnx_fabric_create_info->external_fw_loader = NULL;
    portmod_dnx_fabric_create_info->fmac_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_schan_id = -1;
    portmod_dnx_fabric_create_info->fsrd_internal_quad = -1;
    portmod_dnx_fabric_create_info->first_phy_offset = 0;
    portmod_dnx_fabric_create_info->core_index = -1;
    portmod_dnx_fabric_create_info->is_over_nif = 0;
    if(SOC_E_NONE != portmod_pm_identifier_t_init(unit, &portmod_dnx_fabric_create_info->fabric_o_nif_pm)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fabric_o_nif_pm initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm8x50_fabric_create_info_t_validate(int unit, const portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm8x50_fabric_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm8x50_fabric_create_info_t_init(int unit, portmod_pm8x50_fabric_create_info_t* portmod_pm8x50_fabric_create_info)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm8x50_fabric_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm8x50_fabric_create_info NULL parameter"));
    }
    sal_memset(portmod_pm8x50_fabric_create_info, 0, sizeof(portmod_pm8x50_fabric_create_info_t));
    portmod_pm8x50_fabric_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm8x50_fabric_create_info->access);
    portmod_pm8x50_fabric_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm8x50_fabric_create_info->external_fw_loader = NULL;
    for(_array_iter = 0 ; _array_iter < PORTMOD_NOF_FMACS_PER_PM8X50_FABRIC ; _array_iter++){        portmod_pm8x50_fabric_create_info->fmac_schan_id[_array_iter] = -1;
    }    portmod_pm8x50_fabric_create_info->fsrd_schan_id = -1;
    portmod_pm8x50_fabric_create_info->first_phy_offset = 0;
    portmod_pm8x50_fabric_create_info->core_index = -1;
    portmod_pm8x50_fabric_create_info->force_single_pll0 = 0;
    portmod_pm8x50_fabric_create_info->force_single_pll1 = 0;
    for(_array_iter = 0 ; _array_iter < PORTMOD_NOF_WORDS_PER_PM8X50_FABRIC_LANES_BITMAP ; _array_iter++){        portmod_pm8x50_fabric_create_info->bypass_lanes_bitmap[_array_iter] = 0;
    }    portmod_pm8x50_fabric_create_info->is_rx_ctrl_bypass_supported = 0;
    portmod_pm8x50_fabric_create_info->clock_buffer_disable_required = 0;
    portmod_pm8x50_fabric_create_info->clock_buffer_bw_update_required = 0;
    portmod_pm8x50_fabric_create_info->native_single_pll = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_call_back_action_type_t_validate(int unit, portmod_call_back_action_type_t portmod_call_back_action_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_call_back_action_type >= portmodCallBackActionTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_intr_type_t_validate(int unit, portmod_intr_type_t portmod_intr_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_intr_type >= portmodIntrTypeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_validate(int unit, const portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x25_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x25_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }

    if(SOC_E_NONE != portmod_port_mode_aux_info_t_validate(unit, portmod_pm4x25_create_info->port_mode_aux_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_mode_aux_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x25_create_info_t_init(int unit, portmod_pm4x25_create_info_t* portmod_pm4x25_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x25_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x25_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x25_create_info, 0, sizeof(portmod_pm4x25_create_info_t));
    portmod_pm4x25_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x25_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x25_create_info->lane_map);
    portmod_pm4x25_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x25_create_info->external_fw_loader = NULL;
    portmod_pm4x25_create_info->in_pm_12x10 = 0;
    portmod_pm4x25_create_info->core_num = 0;
    portmod_pm4x25_create_info->core_num_int = 0;
    portmod_pm4x25_create_info->portmod_mac_soft_reset = NULL;
    phymod_afe_pll_t_init(&portmod_pm4x25_create_info->afe_pll);
    portmod_pm4x25_create_info->rescal = -1;
    portmod_pm4x25_create_info->port_mode_aux_info = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_validate(int unit, const portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_pm4x10_create_info->in_pm_12x10) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm_12x10 not allowed value"));
            break;
    }

    if(SOC_E_NONE != portmod_port_mode_aux_info_t_validate(unit, portmod_pm4x10_create_info->port_mode_aux_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_mode_aux_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_create_info_t_init(int unit, portmod_pm4x10_create_info_t* portmod_pm4x10_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x10_create_info, 0, sizeof(portmod_pm4x10_create_info_t));
    PORTMOD_PBMP_CLEAR(portmod_pm4x10_create_info->phy_ports);
    portmod_pm4x10_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x10_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x10_create_info->lane_map);
    portmod_pm4x10_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x10_create_info->external_fw_loader = NULL;
    portmod_pm4x10_create_info->in_pm_12x10 = 0;
    portmod_pm4x10_create_info->portmod_phy_external_reset = NULL;
    portmod_pm4x10_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm4x10_create_info->core_num = 0;
    portmod_pm4x10_create_info->core_num_int = 0;
    portmod_pm4x10_create_info->port_mode_aux_info = 0;
    portmod_pm4x10_create_info->rescal = -1;
    portmod_pm4x10_create_info->is_pm4x10q = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_qtc_create_info_t_validate(int unit, const portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_qtc_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_qtc_create_info_t_init(int unit, portmod_pm_qtc_create_info_t* portmod_pm_qtc_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_qtc_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_qtc_create_info NULL parameter"));
    }
    sal_memset(portmod_pm_qtc_create_info, 0, sizeof(portmod_pm_qtc_create_info_t));
    portmod_pm_qtc_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm_qtc_create_info->access);
    phymod_lane_map_t_init(&portmod_pm_qtc_create_info->lane_map);
    portmod_pm_qtc_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm_qtc_create_info->external_fw_loader = NULL;
    portmod_pm_qtc_create_info->portmod_phy_external_reset = NULL;
    portmod_pm_qtc_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm_qtc_create_info->core_num = 0;
    portmod_pm_qtc_create_info->core_clock_khz = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_gphy_create_info_t_validate(int unit, const portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_gphy_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_gphy_create_info_t_init(int unit, portmod_pm_gphy_create_info_t* portmod_pm_gphy_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_gphy_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_gphy_create_info NULL parameter"));
    }
    sal_memset(portmod_pm_gphy_create_info, 0, sizeof(portmod_pm_gphy_create_info_t));
    portmod_pm_gphy_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm_gphy_create_info->access);
    phymod_lane_map_t_init(&portmod_pm_gphy_create_info->lane_map);
    portmod_pm_gphy_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm_gphy_create_info->external_fw_loader = NULL;
    portmod_pm_gphy_create_info->portmod_phy_external_reset = NULL;
    portmod_pm_gphy_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm_gphy_create_info->core_num = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_validate(int unit, const portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm12x10_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x25_create_info_t_validate(unit, &portmod_pm12x10_create_info->pm4x25_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x25_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm12x10_create_info_t_init(int unit, portmod_pm12x10_create_info_t* portmod_pm12x10_create_info)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm12x10_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm12x10_create_info NULL parameter"));
    }
    sal_memset(portmod_pm12x10_create_info, 0, sizeof(portmod_pm12x10_create_info_t));
    for(_array_iter = 0 ; _array_iter < 3 ; _array_iter++){
        if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm12x10_create_info->pm4x10_infos[_array_iter])) {
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_infos initialization failed"));
        }
    }

    if(SOC_E_NONE != portmod_pm4x25_create_info_t_init(unit, &portmod_pm12x10_create_info->pm4x25_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x25_info initialization failed"));
    }

    portmod_pm12x10_create_info->blk_id = -1;
    portmod_pm12x10_create_info->refclk_source = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_validate(int unit, const portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10q_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x10_create_info_t_validate(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10q_create_info_t_init(int unit, portmod_pm4x10q_create_info_t* portmod_pm4x10q_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10q_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10q_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x10q_create_info, 0, sizeof(portmod_pm4x10q_create_info_t));
    if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm4x10q_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info initialization failed"));
    }

    portmod_pm4x10q_create_info->qsgmii_user_acc = NULL;
    portmod_pm4x10q_create_info->core_clock_khz = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_validate(int unit, const portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ilkn_os_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm_identifier_t_validate(unit, portmod_ilkn_os_create_info->controlled_pms)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("controlled_pms validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ilkn_os_create_info_t_init(int unit, portmod_ilkn_os_create_info_t* portmod_ilkn_os_create_info)
{
    int _array_iter;
        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_ilkn_os_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_ilkn_os_create_info NULL parameter"));
    }
    sal_memset(portmod_ilkn_os_create_info, 0, sizeof(portmod_ilkn_os_create_info_t));
    portmod_ilkn_os_create_info->nof_aggregated_pms = phymodRefClkCount;
    for(_array_iter = 0 ; _array_iter < PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM ; _array_iter++){        portmod_ilkn_os_create_info->wm_high[_array_iter] = 0;
    }    for(_array_iter = 0 ; _array_iter < PORTMOD_MAX_ILKN_PORTS_PER_ILKN_PM ; _array_iter++){        portmod_ilkn_os_create_info->wm_low[_array_iter] = 0;
    }    portmod_ilkn_os_create_info->core_clock_khz = 0;
    portmod_ilkn_os_create_info->ilkn_port_lane_map_get = NULL;
    portmod_ilkn_os_create_info->ilkn_pm_lane_map_get = NULL;
    portmod_ilkn_os_create_info->ilkn_port_fec_units_set = NULL;
    portmod_ilkn_os_create_info->ilkn_block_index = 0;
    portmod_ilkn_os_create_info->fec_disable_by_bypass = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x2p5_create_info_t_validate(int unit, const portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x2p5_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x2p5_create_info_t_init(int unit, portmod_pm4x2p5_create_info_t* portmod_pm4x2p5_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x2p5_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x2p5_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x2p5_create_info, 0, sizeof(portmod_pm4x2p5_create_info_t));
    SOC_PBMP_CLEAR(portmod_pm4x2p5_create_info->phy_ports);
    portmod_pm4x2p5_create_info->ref_clk = phymodRefClkCount;
    phymod_access_t_init(&portmod_pm4x2p5_create_info->access);
    phymod_lane_map_t_init(&portmod_pm4x2p5_create_info->lane_map);
    portmod_pm4x2p5_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm4x2p5_create_info->external_fw_loader = NULL;
    portmod_pm4x2p5_create_info->portmod_phy_external_reset = NULL;
    portmod_pm4x2p5_create_info->portmod_mac_soft_reset = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm8x50_create_info_t_validate(int unit, const portmod_pm8x50_create_info_t* portmod_pm8x50_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm8x50_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_vco_type_t_validate(unit, portmod_pm8x50_create_info->tvco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tvco validation failed"));
    }

    if(SOC_E_NONE != portmod_vco_type_t_validate(unit, portmod_pm8x50_create_info->ovco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ovco validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm8x50_create_info_t_init(int unit, portmod_pm8x50_create_info_t* portmod_pm8x50_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm8x50_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm8x50_create_info NULL parameter"));
    }
    sal_memset(portmod_pm8x50_create_info, 0, sizeof(portmod_pm8x50_create_info_t));
    SOC_PBMP_CLEAR(portmod_pm8x50_create_info->phy_ports);
    portmod_pm8x50_create_info->ref_clk = phymodRefClkCount;
    portmod_pm8x50_create_info->tvco = 0;
    portmod_pm8x50_create_info->ovco = 0;
    phymod_phy_access_t_init(&portmod_pm8x50_create_info->access);
    phymod_lane_map_t_init(&portmod_pm8x50_create_info->lane_map);
    portmod_pm8x50_create_info->fw_load_method = phymodFirmwareLoadMethodCount;
    portmod_pm8x50_create_info->external_fw_loader = NULL;
    portmod_pm8x50_create_info->portmod_phy_external_reset = NULL;
    portmod_pm8x50_create_info->portmod_mac_soft_reset = NULL;
    portmod_pm8x50_create_info->core_num = 0;
    phymod_afe_pll_t_init(&portmod_pm8x50_create_info->afe_pll);
    portmod_pm8x50_create_info->rescal = -1;
    portmod_pm8x50_create_info->is_master_pm = -1;
    portmod_pm8x50_create_info->portmod_egress_buffer_reset = NULL;
    portmod_pm8x50_create_info->allow_20p625g_tvco = -1;
    portmod_pm8x50_create_info->single_vco_used_by_ports = 0;
    portmod_pm8x50_create_info->clock_buffer_disable_required = 0;
    portmod_pm8x50_create_info->clock_buffer_bw_update_required = 0;
    portmod_pm8x50_create_info->pm_offset = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_qtc_create_info_t_validate(int unit, const portmod_pm4x10_qtc_create_info_t* portmod_pm4x10_qtc_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm4x10_qtc_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_pm4x10_create_info_t_validate(unit, &portmod_pm4x10_qtc_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info validation failed"));
    }

    if(SOC_E_NONE != portmod_pm_qtc_create_info_t_validate(unit, &portmod_pm4x10_qtc_create_info->pm_qtc_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm_qtc_info validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm4x10_qtc_create_info_t_init(int unit, portmod_pm4x10_qtc_create_info_t* portmod_pm4x10_qtc_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm4x10_qtc_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm4x10_qtc_create_info NULL parameter"));
    }
    sal_memset(portmod_pm4x10_qtc_create_info, 0, sizeof(portmod_pm4x10_qtc_create_info_t));
    if(SOC_E_NONE != portmod_pm4x10_create_info_t_init(unit, &portmod_pm4x10_qtc_create_info->pm4x10_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm4x10_info initialization failed"));
    }

    if(SOC_E_NONE != portmod_pm_qtc_create_info_t_init(unit, &portmod_pm4x10_qtc_create_info->pm_qtc_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm_qtc_info initialization failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_validate(int unit, const portmod_remote_fault_control_t* portmod_remote_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_remote_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_remote_fault_control_t_init(int unit, portmod_remote_fault_control_t* portmod_remote_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_remote_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_remote_fault_control NULL parameter"));
    }
    sal_memset(portmod_remote_fault_control, 0, sizeof(portmod_remote_fault_control_t));
    portmod_remote_fault_control->enable = 0;
    portmod_remote_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_validate(int unit, const portmod_local_fault_control_t* portmod_local_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_local_fault_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_local_fault_control_t_init(int unit, portmod_local_fault_control_t* portmod_local_fault_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_local_fault_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_local_fault_control NULL parameter"));
    }
    sal_memset(portmod_local_fault_control, 0, sizeof(portmod_local_fault_control_t));
    portmod_local_fault_control->enable = 0;
    portmod_local_fault_control->drop_tx_on_fault = 1;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_validate(int unit, const portmod_llfc_control_t* portmod_llfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_llfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_llfc_control_t_init(int unit, portmod_llfc_control_t* portmod_llfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_llfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_llfc_control NULL parameter"));
    }
    sal_memset(portmod_llfc_control, 0, sizeof(portmod_llfc_control_t));
    portmod_llfc_control->rx_enable = 1;
    portmod_llfc_control->tx_enable = 1;
    portmod_llfc_control->crc_ignore = 0;
    portmod_llfc_control->in_ipg_only = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_validate(int unit, const portmod_pfc_control_t* portmod_pfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pfc_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pfc_control_t_init(int unit, portmod_pfc_control_t* portmod_pfc_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pfc_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pfc_control NULL parameter"));
    }
    sal_memset(portmod_pfc_control, 0, sizeof(portmod_pfc_control_t));
    portmod_pfc_control->rx_enable = 0;
    portmod_pfc_control->tx_enable = 0;
    portmod_pfc_control->stats_en = 1;
    portmod_pfc_control->force_xon = 0;
    portmod_pfc_control->refresh_timer = -1;
    portmod_pfc_control->xoff_timer = 0xFFFF;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_validate(int unit, const portmod_pause_control_t* portmod_pause_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pause_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pause_control_t_init(int unit, portmod_pause_control_t* portmod_pause_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pause_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pause_control NULL parameter"));
    }
    sal_memset(portmod_pause_control, 0, sizeof(portmod_pause_control_t));
    portmod_pause_control->rx_enable = 0;
    portmod_pause_control->tx_enable = 0;
    portmod_pause_control->refresh_timer = 0xc000;
    portmod_pause_control->xoff_timer = 0xFFFF;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_drain_cells_t_validate(int unit, const portmod_drain_cells_t* portmod_drain_cells)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_drain_cells == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_drain_cells_t_init(int unit, portmod_drain_cells_t* portmod_drain_cells)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_drain_cells == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_drain_cells NULL parameter"));
    }
    sal_memset(portmod_drain_cells, 0, sizeof(portmod_drain_cells_t));
    portmod_drain_cells->rx_pfc_en = 0;
    portmod_drain_cells->llfc_en = 0;
    portmod_drain_cells->rx_pause = 0;
    portmod_drain_cells->tx_pause = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_validate(int unit, const portmod_pm_create_info_t* portmod_pm_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_create_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_create_info->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_create_info_t_init(int unit, portmod_pm_create_info_t* portmod_pm_create_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_create_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_create_info NULL parameter"));
    }
    sal_memset(portmod_pm_create_info, 0, sizeof(portmod_pm_create_info_t));
    portmod_pm_create_info->type = portmodDispatchTypeCount;
    PORTMOD_PBMP_CLEAR(portmod_pm_create_info->phys);
    sal_memset(&(portmod_pm_create_info->pm_specific_info), 0, sizeof(portmod_pm_specific_create_info_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_validate(int unit, const portmod_access_get_params_t* portmod_access_get_params)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_access_get_params == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    switch(portmod_access_get_params->sys_side) {
        case PORTMOD_SIDE_LINE:
        case  PORTMOD_SIDE_SYSTEM:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sys_side not allowed value"));
            break;
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_access_get_params_t_init(int unit, portmod_access_get_params_t* portmod_access_get_params)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_access_get_params == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_access_get_params NULL parameter"));
    }
    sal_memset(portmod_access_get_params, 0, sizeof(portmod_access_get_params_t));
    portmod_access_get_params->phyn = -1;
    portmod_access_get_params->sys_side = PORTMOD_SIDE_LINE;
    portmod_access_get_params->lane = -1;
    portmod_access_get_params->apply_lane_mask = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_validate(int unit, const portmod_pm_instances_t* portmod_pm_instances)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_instances == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_instances->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_instances_t_init(int unit, portmod_pm_instances_t* portmod_pm_instances)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_instances == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_instances NULL parameter"));
    }
    sal_memset(portmod_pm_instances, 0, sizeof(portmod_pm_instances_t));
    portmod_pm_instances->type = portmodDispatchTypeCount;
    portmod_pm_instances->instances = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_interface_type_is_supported(int unit, pm_info_t pm_info, soc_port_if_t interface, int* is_supported)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(is_supported == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_supported NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_interface_type_is_supported(unit, interface, is_supported);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_interface_type_is_supported isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_init(int unit, const portmod_pm_create_info_internal_t* pm_add_info, int wb_buffer_index, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_add_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_init) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_init(unit, pm_add_info, wb_buffer_index, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_destroy(int unit, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_destroy) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_destroy(unit, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_destroy isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_attach(int unit, int port, const portmod_port_add_info_t* add_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_add_info_t_validate(unit, add_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("add_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_attach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_attach(unit, port, pm_info, add_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_attach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_default_bus_update(int unit, pm_info_t pm_info, const portmod_bus_update_t* update)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_default_bus_update) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_default_bus_update(unit, pm_info, update);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_default_bus_update isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_bypass_set(int unit, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, enable, &enable, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, enable, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_bypass_set(unit, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_bypass_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_core_info_get(int unit, pm_info_t pm_info, int phyn, portmod_pm_core_info_t* core_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pm_core_info_t_init(unit, core_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_info initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_core_info_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_core_info_get(unit, pm_info, phyn, core_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_core_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_aggregated_update(int unit, pm_info_t pm_info, int core_id, int nof_aggregated_pms, const pm_info_t* pms, const int* pm_ids)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_aggregated_update) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_aggregated_update(unit, pm_info, core_id, nof_aggregated_pms, pms, pm_ids);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_aggregated_update isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_phys_get(int unit, pm_info_t pm_info, portmod_pbmp_t* phys)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(phys == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("phys NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_phys_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_phys_get(unit, pm_info, phys);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_phys_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_detach(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_detach) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_detach(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_detach isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_callback_unregister(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_callback_unregister) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_callback_unregister(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_callback_unregister isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_replace(int unit, int port, int new_port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_replace) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_replace(unit, port, pm_info, new_port);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_replace isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_set(int unit, int port, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_set(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_enable_get(int unit, int port, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_enable_get(unit, port, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cdr_lock_get(int unit, int port, int* is_locked)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(is_locked == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_locked NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cdr_lock_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cdr_lock_get(unit, port, pm_info, is_locked);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cdr_lock_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_electrical_idle_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_electrical_idle_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_electrical_idle_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_electrical_idle_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_set(int unit, int port, const portmod_port_interface_config_t* config, int phy_init_flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_set(unit, port, pm_info, config, phy_init_flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_config_get(int unit, int port, portmod_port_interface_config_t* config, int phy_init_flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_interface_config_t_init(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_config_get(unit, port, pm_info, config, phy_init_flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_default_interface_get(int unit, int port, const portmod_port_interface_config_t* config, soc_port_if_t* interface)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    if(interface == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("interface NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_default_interface_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_default_interface_get(unit, port, pm_info, config, interface);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_default_interface_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interface_check(int unit, int port, const portmod_port_interface_config_t* config, int is_ext_phy, soc_port_if_t interface, int* is_valid)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    if(is_valid == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_valid NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interface_check) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interface_check(unit, port, pm_info, config, is_ext_phy, interface, is_valid);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interface_check isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_set(int unit, int port, uint32 properties, portmod_port_pcs_t encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_set(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encoding_get(int unit, int port, uint32* properties, portmod_port_pcs_t* encoding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(properties == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("properties NULL parameter"));
    }
    if(encoding == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("encoding NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encoding_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encoding_get(unit, port, pm_info, properties, encoding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encoding_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_set(int unit, int port, uint32 enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_get(int unit, int port, uint32* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cl72_status_get(int unit, int port, phymod_cl72_status_t* status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cl72_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cl72_status_get(unit, port, pm_info, status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cl72_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_set(int unit, int port, portmod_loopback_mode_t loopback_type, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_set(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_loopback_get(int unit, int port, portmod_loopback_mode_t loopback_type, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_loopback_mode_t_validate(unit, loopback_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_type validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_loopback_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_loopback_get(unit, port, pm_info, loopback_type, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_loopback_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pass_through_set(int unit, int port, int loopback_en, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pass_through_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pass_through_set(unit, port, pm_info, loopback_en, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pass_through_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pass_through_get(int unit, int port, int* loopback_en, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(loopback_en == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback_en NULL parameter"));
    }
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pass_through_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pass_through_get(unit, port, pm_info, loopback_en, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pass_through_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pass_through_calibrate(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pass_through_calibrate) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pass_through_calibrate(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pass_through_calibrate isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pass_through_fec_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pass_through_fec_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pass_through_fec_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pass_through_fec_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pass_through_fec_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pass_through_fec_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pass_through_fec_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pass_through_fec_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_local_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_local_get(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_local_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_set(int unit, int port, uint32 phy_flags, const phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_set(unit, port, pm_info, phy_flags, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_get(int unit, int port, uint32 phy_flags, phymod_autoneg_control_t* an)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(an == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("an NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_get(unit, port, pm_info, phy_flags, an);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_status_get(int unit, int port, phymod_autoneg_status_t* an_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(an_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("an_status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_status_get(unit, port, pm_info, an_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_link_get(int unit, int port, int flags, int* link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(link == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("link NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_link_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_link_get(unit, port, pm_info, flags, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_link_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_link_latch_down_get(int unit, int port, uint32 flags, int* link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(link == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("link NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_link_latch_down_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_link_latch_down_get(unit, port, pm_info, flags, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_link_latch_down_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_link_up_event(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_link_up_event) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_link_up_event(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_link_up_event isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_link_down_event(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_link_down_event) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_link_down_event(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_link_down_event isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_set(int unit, int port, portmod_prbs_mode_t mode, int flags, const phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_set(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_config_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_config_get(unit, port, pm_info, mode, flags, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_set(int unit, int port, portmod_prbs_mode_t mode, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_set(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_enable_get(int unit, int port, portmod_prbs_mode_t mode, int flags, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_enable_get(unit, port, pm_info, mode, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_prbs_status_get(int unit, int port, portmod_prbs_mode_t mode, int flags, phymod_prbs_status_t* status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_prbs_mode_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    if(status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_prbs_status_get(unit, port, pm_info, mode, flags, status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_prbs_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_nof_lanes_get(int unit, int port, int* nof_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(nof_lanes == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_lanes NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_nof_lanes_get(unit, port, pm_info, nof_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_nof_lanes_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ilkn_nof_segments_set(int unit, int port, uint32 nof_segments)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    switch(nof_segments) {
        case 2:
        case 4:
        case 8:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_segments not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_set(unit, port, pm_info, nof_segments);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ilkn_nof_segments_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ilkn_nof_segments_get(int unit, int port, uint32* nof_segments)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(nof_segments == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_segments NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ilkn_nof_segments_get(unit, port, pm_info, nof_segments);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ilkn_nof_segments_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_set(int unit, int port, const ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_set(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ilkn_retranstmit_config_get(int unit, int port, ilkn_retransmit_config_t* retransmit_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(retransmit_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("retransmit_config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ilkn_retranstmit_config_get(unit, port, pm_info, retransmit_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ilkn_retranstmit_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_assign(int unit, int port, const portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_assign(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_assign isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lanes_retrieve(int unit, int port, portmod_lanes_assign_info_t* assign_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(assign_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("assign_map NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lanes_retrieve(unit, port, pm_info, assign_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lanes_retrieve isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_set(int unit, int port, phymod_firmware_mode_t fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_set(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_firmware_mode_get(int unit, int port, phymod_firmware_mode_t* fw_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(fw_mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fw_mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_firmware_mode_get(unit, port, pm_info, fw_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_firmware_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_runt_threshold_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_runt_threshold_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_runt_threshold_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_max_packet_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_max_packet_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_max_packet_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pad_size_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pad_size_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pad_size_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_set(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_set(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_mac_sa_get(int unit, int port, sal_mac_addr_t mac_sa)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_mac_sa_get(unit, port, pm_info, mac_sa);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_mac_sa_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_average_ipg_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_average_ipg_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_average_ipg_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_preamble_length_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_preamble_length_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_preamble_length_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_set(int unit, int port, const portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_local_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_control_get(int unit, int port, portmod_local_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_local_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_set(int unit, int port, const portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_remote_fault_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_control_get(int unit, int port, portmod_remote_fault_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_remote_fault_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_remote_fault_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_remote_fault_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_remote_fault_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_local_fault_reasons_get(int unit, int port, uint32* local_fault_reasons)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(local_fault_reasons == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("local_fault_reasons NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_local_fault_reasons_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_local_fault_reasons_get(unit, port, pm_info, local_fault_reasons);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_local_fault_reasons_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_set(int unit, int port, const portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pause_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pause_control_get(int unit, int port, portmod_pause_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pause_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pause_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pause_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_set(int unit, int port, const portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_control_get(int unit, int port, portmod_pfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_set(int unit, int port, const portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_llfc_control_t_validate(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_set(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_llfc_control_get(int unit, int port, portmod_llfc_control_t* control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control NULL parameter"));
    }
    if(SOC_E_NONE != portmod_llfc_control_t_init(unit, control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("control initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_llfc_control_get(unit, port, pm_info, control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_llfc_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_update_control_t_validate(int unit, const portmod_port_update_control_t* portmod_port_update_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_update_control == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_update_control_t_init(int unit, portmod_port_update_control_t* portmod_port_update_control)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_update_control == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_update_control NULL parameter"));
    }
    sal_memset(portmod_port_update_control, 0, sizeof(portmod_port_update_control_t));
    portmod_port_update_control->link_status = -1;
    portmod_port_update_control->flags = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_update(int unit, int port, const portmod_port_update_control_t* update_control)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_update_control_t_validate(unit, update_control)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("update_control validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_update) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_update(unit, port, pm_info, update_control);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_update isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_core_access_get(int unit, int port, int phyn, int max_cores, phymod_core_access_t* core_access_arr, int* nof_cores, int* is_most_ext)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_access_arr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_access_arr NULL parameter"));
    }
    if(nof_cores == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_cores NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_core_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_core_access_get(unit, port, pm_info, phyn, max_cores, core_access_arr, nof_cores, is_most_ext);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_core_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_lane_access_get(int unit, int port, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys, int* is_most_ext)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_access_get_params_t_validate(unit, params)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("params validation failed"));
    }

    if(access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("access NULL parameter"));
    }
    if(nof_phys == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_phys NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_lane_access_get(unit, port, pm_info, params, max_phys, access, nof_phys, is_most_ext);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_lane_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_phy_lane_access_get(int unit, int pm_id, const portmod_access_get_params_t* params, int max_phys, phymod_phy_access_t* access, int* nof_phys, int* is_most_ext)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_access_get_params_t_validate(unit, params)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("params validation failed"));
    }

    if(access == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("access NULL parameter"));
    }
    if(nof_phys == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("nof_phys NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_phy_lane_access_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_phy_lane_access_get(unit, pm_id, pm_info, params, max_phys, access, nof_phys, is_most_ext);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_phy_lane_access_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_duplex_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_duplex_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_duplex_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_duplex_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_duplex_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_duplex_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_duplex_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_duplex_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_reg_read(int unit, int port, int lane, int flags, int reg_addr, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_read) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_read(unit, port, pm_info, lane, flags, reg_addr, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_reg_read isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_reg_write(int unit, int port, int lane, int flags, int reg_addr, uint32 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_write) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_reg_write(unit, port, pm_info, lane, flags, reg_addr, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_reg_write isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_reset_set(int unit, int port, int mode, int opcode, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_reset_set(unit, port, pm_info, mode, opcode, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_reset_get(int unit, int port, int mode, int opcode, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_reset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_reset_get(unit, port, pm_info, mode, opcode, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_reset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_adv_remote_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_adv_remote_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_adv_remote_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_adv_remote_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drv_name(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drv_name) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drv_name(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drv_name isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drv_name_get(int unit, int port, char* name, int len)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(name == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("name NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drv_name_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drv_name_get(unit, port, pm_info, name, len);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drv_name_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fec_enable_set(int unit, int port, uint32 phy_flags, uint32_t enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_set(unit, port, pm_info, phy_flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fec_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fec_enable_get(int unit, int port, uint32 phy_flags, uint32_t* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fec_enable_get(unit, port, pm_info, phy_flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fec_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_advert_set(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_set(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_advert_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_advert_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_advert_get(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_advert_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ability_remote_get(int unit, int port, uint32 phy_flags, portmod_port_ability_t* ability)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ability NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ability_remote_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ability_remote_get(unit, port, pm_info, phy_flags, ability);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ability_remote_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_frame_spacing_stretch_set(int unit, int port, int spacing)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_set(unit, port, pm_info, spacing);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_frame_spacing_stretch_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_frame_spacing_stretch_get(int unit, int port, const int* spacing)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_frame_spacing_stretch_get(unit, port, pm_info, spacing);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_frame_spacing_stretch_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_diag_fifo_status_get(int unit, int port, const portmod_fifo_status_t* diag_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_fifo_status_t_validate(unit, diag_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("diag_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_diag_fifo_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_diag_fifo_status_get(unit, port, pm_info, diag_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_diag_fifo_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_control_set(int unit, int port, const portmod_rx_control_t* rx_ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rx_control_t_validate(unit, rx_ctrl)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_ctrl validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_control_set(unit, port, pm_info, rx_ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rx_control_get(int unit, int port, portmod_rx_control_t* rx_ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(rx_ctrl == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_ctrl NULL parameter"));
    }
    if(SOC_E_NONE != portmod_rx_control_t_init(unit, rx_ctrl)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rx_ctrl initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rx_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rx_control_get(unit, port, pm_info, rx_ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rx_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_config_set(int unit, int port, const portmod_pfc_config_t* pfc_cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pfc_config_t_validate(unit, pfc_cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_set(unit, port, pm_info, pfc_cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pfc_config_get(int unit, int port, portmod_pfc_config_t* pfc_cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(pfc_cfg == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pfc_config_t_init(unit, pfc_cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pfc_cfg initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pfc_config_get(unit, port, pm_info, pfc_cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pfc_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_set(int unit, int port, const portmod_eee_t* eee)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_eee_t_validate(unit, eee)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_set(unit, port, pm_info, eee);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_get(int unit, int port, portmod_eee_t* eee)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(eee == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee NULL parameter"));
    }
    if(SOC_E_NONE != portmod_eee_t_init(unit, eee)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_get(unit, port, pm_info, eee);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_clock_set(int unit, int port, const portmod_eee_clock_t* eee_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_eee_clock_t_validate(unit, eee_clk)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee_clk validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_set(unit, port, pm_info, eee_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_clock_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_eee_clock_get(int unit, int port, portmod_eee_clock_t* eee_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(eee_clk == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee_clk NULL parameter"));
    }
    if(SOC_E_NONE != portmod_eee_clock_t_init(unit, eee_clk)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("eee_clk initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_eee_clock_get(unit, port, pm_info, eee_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_eee_clock_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_vlan_tag_set(int unit, int port, const portmod_vlan_tag_t* vlan_tag)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_vlan_tag_t_validate(unit, vlan_tag)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_set(unit, port, pm_info, vlan_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_vlan_tag_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_vlan_tag_get(int unit, int port, portmod_vlan_tag_t* vlan_tag)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(vlan_tag == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag NULL parameter"));
    }
    if(SOC_E_NONE != portmod_vlan_tag_t_init(unit, vlan_tag)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_tag initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_vlan_tag_get(unit, port, pm_info, vlan_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_vlan_tag_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_modid_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_modid_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_modid_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_modid_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_led_chain_config(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_led_chain_config) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_led_chain_config(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_led_chain_config isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_clear_rx_lss_status_set(int unit, int port, int lcl_fault, int rmt_fault)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_set(unit, port, pm_info, lcl_fault, rmt_fault);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_clear_rx_lss_status_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_clear_rx_lss_status_get(int unit, int port, int* lcl_fault, int* rmt_fault)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(lcl_fault == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lcl_fault NULL parameter"));
    }
    if(rmt_fault == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rmt_fault NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_clear_rx_lss_status_get(unit, port, pm_info, lcl_fault, rmt_fault);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_clear_rx_lss_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_lane_connection_t_validate(int unit, const portmod_lane_connection_t* portmod_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_lane_connection == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_lane_connection_t_init(int unit, portmod_lane_connection_t* portmod_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_lane_connection == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_lane_connection NULL parameter"));
    }
    sal_memset(portmod_lane_connection, 0, sizeof(portmod_lane_connection_t));
    portmod_lane_connection->core_index = PORTMOD_CORE_INDEX_INVALID;
    portmod_lane_connection->lane_index = PORTMOD_LANE_INDEX_INVALID;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_phy_core_info_t_validate(int unit, const portmod_phy_core_info_t* portmod_phy_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_phy_core_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_phy_core_info_t_init(int unit, portmod_phy_core_info_t* portmod_phy_core_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_phy_core_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_phy_core_info NULL parameter"));
    }
    sal_memset(portmod_phy_core_info, 0, sizeof(portmod_phy_core_info_t));
    phymod_core_access_t_init(&portmod_phy_core_info->core_access);

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_xphy_lane_connection_t_validate(int unit, const portmod_xphy_lane_connection_t* portmod_xphy_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_xphy_lane_connection == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_xphy_lane_connection_t_init(int unit, portmod_xphy_lane_connection_t* portmod_xphy_lane_connection)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_xphy_lane_connection == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_xphy_lane_connection NULL parameter"));
    }
    sal_memset(portmod_xphy_lane_connection, 0, sizeof(portmod_xphy_lane_connection_t));
    portmod_xphy_lane_connection->xphy_id = PORTMOD_XPHY_ID_INVALID;
    portmod_xphy_lane_connection->ss_lane_mask = PORTMOD_LANE_INDEX_INVALID;
    portmod_xphy_lane_connection->ls_lane_mask = PORTMOD_LANE_INDEX_INVALID;
    portmod_xphy_lane_connection->rsvd1 = PORTMOD_LANE_INDEX_INVALID;
    portmod_xphy_lane_connection->rsvd2 = PORTMOD_LANE_INDEX_INVALID;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_xphy_lane_attach_to_pm(int unit, pm_info_t pm_info, int iphy, int phyn, const portmod_xphy_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_xphy_lane_connection_t_validate(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection validation failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_xphy_lane_attach_to_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_xphy_lane_attach_to_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_xphy_lane_attach_to_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_xphy_lane_detach_from_pm(int unit, pm_info_t pm_info, int iphy, int phyn, portmod_xphy_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_xphy_lane_connection_t_init(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_xphy_lane_detach_from_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_xphy_lane_detach_from_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_xphy_lane_detach_from_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ext_phy_lane_attach_to_pm(int unit, pm_info_t pm_info, int iphy, int phyn, const portmod_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_lane_connection_t_validate(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection validation failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_attach_to_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_attach_to_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ext_phy_lane_attach_to_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_ext_phy_lane_detach_from_pm(int unit, pm_info_t pm_info, int iphy, int phyn, portmod_lane_connection_t* lane_connection)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_lane_connection_t_init(unit, lane_connection)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_connection initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_detach_from_pm) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_ext_phy_lane_detach_from_pm(unit, pm_info, iphy, phyn, lane_connection);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_ext_phy_lane_detach_from_pm isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_status_toggle(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_status_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_status_toggle(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_status_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_loopback_set(int unit, int port, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_set(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_loopback_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_loopback_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_loopback_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_loopback_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mode_set(int unit, int port, const portmod_port_mode_info_t* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_mode_info_t_validate(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mode_get(int unit, int port, portmod_port_mode_info_t* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_mode_info_t_init(unit, mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encap_set(int unit, int port, int flags, portmod_encap_t encap)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encap_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encap_set(unit, port, pm_info, flags, encap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encap_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_encap_get(int unit, int port, int* flags, portmod_encap_t* encap)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(flags == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flags NULL parameter"));
    }
    if(encap == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("encap NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_encap_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_encap_get(unit, port, pm_info, flags, encap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_encap_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_mode_set(int unit, int port, int mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_mode_get(int unit, int port, int* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig2_mode_set(int unit, int port, int mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_set(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig2_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig2_mode_get(int unit, int port, int* mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_higig2_mode_get(unit, port, pm_info, mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_higig2_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_config_port_type_set(int unit, int port, int type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_set(unit, port, pm_info, type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_config_port_type_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_config_port_type_get(int unit, int port, int* type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(type == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_config_port_type_get(unit, port, pm_info, type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_config_port_type_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_config_set(int unit, int port, int hw_count)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_set(unit, port, pm_info, hw_count);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_config_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_config_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_trunk_hwfailover_status_get(int unit, int port, int* loopback)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(loopback == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("loopback NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_trunk_hwfailover_status_get(unit, port, pm_info, loopback);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_trunk_hwfailover_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_diag_ctrl(int unit, int port, uint32 inst, int op_type, int op_cmd, const void* arg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_diag_ctrl) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_diag_ctrl(unit, port, pm_info, inst, op_type, op_cmd, arg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_diag_ctrl isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_ref_clk_get(int unit, int port, int* ref_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ref_clk == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ref_clk NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_ref_clk_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_ref_clk_get(unit, port, pm_info, ref_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_ref_clk_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_failover_disable(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_disable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_failover_disable(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_failover_disable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_remove_failover_lpbk_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_remove_failover_lpbk_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lag_remove_failover_lpbk_get(int unit, int port, int* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lag_remove_failover_lpbk_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lag_remove_failover_lpbk_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cntmaxsize_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cntmaxsize_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_cntmaxsize_get(int unit, int port, int* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_cntmaxsize_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_cntmaxsize_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_multi_get(int unit, int port, portmod_multi_get_t* multi_get)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(multi_get == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("multi_get NULL parameter"));
    }
    if(SOC_E_NONE != portmod_multi_get_t_validate(unit, multi_get)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("multi_get validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_multi_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_multi_get(unit, port, pm_info, multi_get);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_multi_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_get(int unit, int port, portmod_drain_cells_t* drain_cells)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(drain_cells == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells NULL parameter"));
    }
    if(SOC_E_NONE != portmod_drain_cells_t_init(unit, drain_cells)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_get(unit, port, pm_info, drain_cells);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_stop(int unit, int port, const portmod_drain_cells_t* drain_cells)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_drain_cells_t_validate(unit, drain_cells)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("drain_cells validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_stop) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_stop(unit, port, pm_info, drain_cells);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_stop isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cell_start(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_start) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cell_start(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cell_start isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_drain_cells_rx_enable(int unit, int port, int rx_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_drain_cells_rx_enable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_drain_cells_rx_enable(unit, port, pm_info, rx_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_drain_cells_rx_enable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_egress_queue_drain_rx_en(int unit, int port, int rx_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_rx_en) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_rx_en(unit, port, pm_info, rx_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_egress_queue_drain_rx_en isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_ctrl_set(int unit, int port, uint64 ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_ctrl_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_ctrl_set(unit, port, pm_info, ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_ctrl_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_txfifo_cell_cnt_get(int unit, int port, uint32* cnt)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(cnt == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cnt NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_txfifo_cell_cnt_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_txfifo_cell_cnt_get(unit, port, pm_info, cnt);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_txfifo_cell_cnt_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_egress_queue_drain_get(int unit, int port, uint64* ctrl, int* rxen)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ctrl == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ctrl NULL parameter"));
    }
    if(rxen == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rxen NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_egress_queue_drain_get(unit, port, pm_info, ctrl, rxen);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_egress_queue_drain_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_reset_set(int unit, int port, int val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_set(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_reset_get(int unit, int port, int* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_reset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_soft_reset_toggle(int unit, int port, int idx)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_toggle(unit, port, pm_info, idx);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_soft_reset_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_soft_reset(int unit, int port, portmod_mac_soft_reset_mode_t reset_mode, int* saved_rx_enable, uint64* saved_mac_ctrl)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_mac_soft_reset_mode_t_validate(unit, reset_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("reset_mode validation failed"));
    }

    if(saved_rx_enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("saved_rx_enable NULL parameter"));
    }
    if(saved_mac_ctrl == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("saved_mac_ctrl NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_soft_reset) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_soft_reset(unit, port, pm_info, reset_mode, saved_rx_enable, saved_mac_ctrl);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_soft_reset isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_reset_check(int unit, int port, int enable, int* reset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(reset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("reset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_check) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_reset_check(unit, port, pm_info, enable, reset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_reset_check isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_core_num_get(int unit, int port, int* core_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_core_num_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_core_num_get(unit, port, pm_info, core_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_core_num_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_higig_e2ecc_hdr_t_validate(int unit, const portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_higig_e2ecc_hdr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_higig_e2ecc_hdr_t_init(int unit, portmod_port_higig_e2ecc_hdr_t* portmod_port_higig_e2ecc_hdr)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_higig_e2ecc_hdr == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_higig_e2ecc_hdr NULL parameter"));
    }
    sal_memset(portmod_port_higig_e2ecc_hdr, 0, sizeof(portmod_port_higig_e2ecc_hdr_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_e2ecc_hdr_set(int unit, int port, const portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_higig_e2ecc_hdr_t_validate(unit, e2ecc_hdr)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_set(unit, port, pm_info, e2ecc_hdr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2ecc_hdr_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2ecc_hdr_get(int unit, int port, portmod_port_higig_e2ecc_hdr_t* e2ecc_hdr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(e2ecc_hdr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_higig_e2ecc_hdr_t_init(unit, e2ecc_hdr)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("e2ecc_hdr initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2ecc_hdr_get(unit, port, pm_info, e2ecc_hdr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2ecc_hdr_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2e_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2e_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_e2e_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_e2e_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_e2e_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fallback_lane_get(int unit, int port, int* fallback_lane)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(fallback_lane == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("fallback_lane NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fallback_lane_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fallback_lane_get(unit, port, pm_info, fallback_lane);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fallback_lane_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_speed_get(int unit, int port, int* speed)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(speed == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_speed_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_speed_get(unit, port, pm_info, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_speed_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_tsc_refclock_set(int unit, int pm_id, int ref_in, int ref_out)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_tsc_refclock_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_tsc_refclock_set(unit, pm_id, pm_info, ref_in, ref_out);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_tsc_refclock_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_tsc_refclock_get(int unit, int pm_id, int* ref_in, int* ref_out)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ref_in == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ref_in NULL parameter"));
    }
    if(ref_out == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ref_out NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_tsc_refclock_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_tsc_refclock_get(unit, pm_id, pm_info, ref_in, ref_out);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_tsc_refclock_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_discard_set(int unit, int port, int discard)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_discard_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_discard_set(unit, port, pm_info, discard);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_discard_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_soft_reset_set(int unit, int port, int idx, int val, int flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_soft_reset_set(unit, port, pm_info, idx, val, flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_soft_reset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_down(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_down) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_down(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_down isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_logical_lane_order_set(int unit, int port, const int* lane_order, int lane_order_size)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_set(unit, port, pm_info, lane_order, lane_order_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_logical_lane_order_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_logical_lane_order_get(int unit, int port, int lane_order_max_size, int* lane_order, int* lane_order_actual_size)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(lane_order == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_order NULL parameter"));
    }
    if(lane_order_actual_size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_order_actual_size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_logical_lane_order_get(unit, port, pm_info, lane_order_max_size, lane_order, lane_order_actual_size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_logical_lane_order_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pgw_reconfig(int unit, int port, const portmod_port_mode_info_t* pmode, int phy_port, int flags)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_mode_info_t_validate(unit, pmode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pmode validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pgw_reconfig) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pgw_reconfig(unit, port, pm_info, pmode, phy_port, flags);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pgw_reconfig isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_notify(int unit, int port, int link)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_notify) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_notify(unit, port, pm_info, link);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_notify isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_control_phy_timesync_set(int unit, int port, portmod_port_control_phy_timesync_t config, uint64 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_set(unit, port, pm_info, config, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_control_phy_timesync_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_control_phy_timesync_get(int unit, int port, portmod_port_control_phy_timesync_t config, uint64* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_control_phy_timesync_get(unit, port, pm_info, config, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_control_phy_timesync_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_config_set(int unit, int port, const portmod_phy_timesync_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_config_get(int unit, int port, portmod_phy_timesync_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_enable_set(int unit, int port, uint32 enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_enable_get(int unit, int port, uint32* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_nco_addend_set(int unit, int port, uint32 freq_step)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_set(unit, port, pm_info, freq_step);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_nco_addend_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_nco_addend_get(int unit, int port, uint32* freq_step)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(freq_step == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("freq_step NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_nco_addend_get(unit, port, pm_info, freq_step);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_nco_addend_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_framesync_mode_set(int unit, int port, const portmod_timesync_framesync_t* framesync)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_set(unit, port, pm_info, framesync);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_framesync_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_framesync_mode_get(int unit, int port, portmod_timesync_framesync_t* framesync)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(framesync == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("framesync NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_framesync_mode_get(unit, port, pm_info, framesync);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_framesync_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_local_time_set(int unit, int port, uint64 local_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_set(unit, port, pm_info, local_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_local_time_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_local_time_get(int unit, int port, uint64* local_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(local_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("local_time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_local_time_get(unit, port, pm_info, local_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_local_time_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_load_ctrl_set(int unit, int port, uint32 load_once, uint32 load_always)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_set(unit, port, pm_info, load_once, load_always);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_load_ctrl_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_load_ctrl_get(int unit, int port, uint32* load_once, uint32* load_always)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(load_once == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("load_once NULL parameter"));
    }
    if(load_always == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("load_always NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_load_ctrl_get(unit, port, pm_info, load_once, load_always);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_load_ctrl_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_tx_timestamp_offset_set(int unit, int port, uint32 ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_set(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_tx_timestamp_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_tx_timestamp_offset_get(int unit, int port, uint32* ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ts_offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ts_offset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_timestamp_offset_get(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_tx_timestamp_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_rx_timestamp_offset_set(int unit, int port, uint32 ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_set(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_rx_timestamp_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_rx_timestamp_offset_get(int unit, int port, uint32* ts_offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ts_offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ts_offset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_rx_timestamp_offset_get(unit, port, pm_info, ts_offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_rx_timestamp_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timestamp_adjust_set(int unit, int port, const soc_port_timestamp_adjust_t* ts_adjust)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timestamp_adjust_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timestamp_adjust_set(unit, port, pm_info, ts_adjust);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timestamp_adjust_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timestamp_adjust_get(int unit, int port, soc_port_timestamp_adjust_t* ts_adjust)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ts_adjust == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ts_adjust NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timestamp_adjust_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timestamp_adjust_get(unit, port, pm_info, ts_adjust);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timestamp_adjust_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_enable_set(int unit, int port, uint32 intr_enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_set(unit, port, pm_info, intr_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_enable_get(int unit, int port, uint32* intr_enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(intr_enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intr_enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_enable_get(unit, port, pm_info, intr_enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_status_get(int unit, int port, uint32* intr_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(intr_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intr_status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_get(unit, port, pm_info, intr_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_intr_status_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_intr_status_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_intr_status_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_timesync_do_sync(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_timesync_do_sync) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_timesync_do_sync(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_timesync_do_sync isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_capture_timestamp_get(int unit, int port, uint64* cap_ts)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(cap_ts == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cap_ts NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_capture_timestamp_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_capture_timestamp_get(unit, port, pm_info, cap_ts);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_capture_timestamp_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_heartbeat_timestamp_get(int unit, int port, uint64* hb_ts)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(hb_ts == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("hb_ts NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_heartbeat_timestamp_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_heartbeat_timestamp_get(unit, port, pm_info, hb_ts);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_heartbeat_timestamp_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_edc_config_set(int unit, int port, const portmod_edc_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_edc_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_edc_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_edc_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_edc_config_get(int unit, int port, portmod_edc_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_edc_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_edc_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_edc_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupt_enable_set(int unit, int port, int intr_type, uint32 val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_set(unit, port, pm_info, intr_type, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupt_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupt_enable_get(int unit, int port, int intr_type, uint32* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupt_enable_get(unit, port, pm_info, intr_type, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupt_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupt_get(int unit, int port, int intr_type, uint32* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupt_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupt_get(unit, port, pm_info, intr_type, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupt_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_interrupts_get(int unit, int port, int arr_max_size, uint32* intr_arr, uint32* size)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(intr_arr == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intr_arr NULL parameter"));
    }
    if(size == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("size NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_interrupts_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_interrupts_get(unit, port, pm_info, arr_max_size, intr_arr, size);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_interrupts_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_stat_val_t_validate(int unit, portmod_stat_val_t portmod_stat_val)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_stat_val >= portmodCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_check_legacy_phy(int unit, int port, int* legacy_phy)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(legacy_phy == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("legacy_phy NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_check_legacy_phy) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_check_legacy_phy(unit, port, pm_info, legacy_phy);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_check_legacy_phy isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_failover_mode_set(int unit, int port, phymod_failover_mode_t failover)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_set(unit, port, pm_info, failover);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_failover_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_failover_mode_get(int unit, int port, phymod_failover_mode_t* failover)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(failover == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("failover NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_failover_mode_get(unit, port, pm_info, failover);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_failover_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_rsv_mask_set(int unit, int port, uint32 rsv_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_rsv_mask_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_rsv_mask_set(unit, port, pm_info, rsv_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_rsv_mask_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mib_reset_toggle(int unit, int port, int port_index)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mib_reset_toggle) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mib_reset_toggle(unit, port, pm_info, port_index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mib_reset_toggle isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_warmboot_db_restore(int unit, int port, const portmod_port_interface_config_t* intf_config, const portmod_port_init_config_t* init_config, phymod_operation_mode_t phy_op_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_interface_config_t_validate(unit, intf_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("intf_config validation failed"));
    }

    if(SOC_E_NONE != portmod_port_init_config_t_validate(unit, init_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("init_config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_warmboot_db_restore) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_warmboot_db_restore(unit, port, pm_info, intf_config, init_config, phy_op_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_warmboot_db_restore isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_flow_control_set(int unit, int port, int merge_mode_en, int parallel_fc_en)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_flow_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_flow_control_set(unit, port, pm_info, merge_mode_en, parallel_fc_en);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_flow_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_update_dynamic_state(int unit, int port, uint32_t port_dynamic_state)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_update_dynamic_state) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_update_dynamic_state(unit, port, pm_info, port_dynamic_state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_update_dynamic_state isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_phy_op_mode_get(int unit, int port, phymod_operation_mode_t* val)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(val == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("val NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_phy_op_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_phy_op_mode_get(unit, port, pm_info, val);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_phy_op_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lane_map_set(int unit, int port, uint32 flags, const phymod_lane_map_t* lane_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lane_map_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lane_map_set(unit, port, pm_info, flags, lane_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lane_map_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lane_map_get(int unit, int port, uint32 flags, phymod_lane_map_t* lane_map)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(lane_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_map NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lane_map_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lane_map_get(unit, port, pm_info, flags, lane_map);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lane_map_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_polarity_set(int unit, int port, const phymod_polarity_t* polarity)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_polarity_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_polarity_set(unit, port, pm_info, polarity);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_polarity_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_polarity_get(int unit, int port, phymod_polarity_t* polarity)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(polarity == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("polarity NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_polarity_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_polarity_get(unit, port, pm_info, polarity);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_polarity_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_medium_config_set(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_medium_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_medium_config_set(unit, port, pm_info, medium, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_medium_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_medium_config_get(int unit, int port, soc_port_medium_t medium, soc_phy_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_medium_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_medium_config_get(unit, port, pm_info, medium, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_medium_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_medium_get(int unit, int port, soc_port_medium_t* medium)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(medium == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("medium NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_medium_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_medium_get(unit, port, pm_info, medium);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_medium_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_is_in_pm12x10(int unit, pm_info_t pm_info, int* in_pm12x10)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(in_pm12x10 == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("in_pm12x10 NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_is_in_pm12x10) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_is_in_pm12x10(unit, pm_info, in_pm12x10);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_is_in_pm12x10 isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_slow_read_rate_set(int unit, int port, int slow_read_rate)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_slow_read_rate_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_slow_read_rate_set(unit, port, pm_info, slow_read_rate);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_slow_read_rate_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_resources_t_validate(int unit, const portmod_port_resources_t* portmod_port_resources)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_resources == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_port_resources->pm_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_resources_t_init(int unit, portmod_port_resources_t* portmod_port_resources)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_resources == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_resources NULL parameter"));
    }
    sal_memset(portmod_port_resources, 0, sizeof(portmod_port_resources_t));
    portmod_port_resources->speed = 0;
    portmod_port_resources->num_lane = 0;
    portmod_port_resources->encap_mode = 0;
    portmod_port_resources->flag = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_pll_div_get(int unit, int port, const portmod_port_resources_t* port_resource, uint32_t* pll_div)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_resources_t_validate(unit, port_resource)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_resource validation failed"));
    }

    if(pll_div == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pll_div NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pll_div_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pll_div_get(unit, port, pm_info, port_resource, pll_div);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pll_div_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_master_set(int unit, int port, int master_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_master_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_master_set(unit, port, pm_info, master_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_master_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_master_get(int unit, int port, int* master_mode)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(master_mode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("master_mode NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_master_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_master_get(unit, port, pm_info, master_mode);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_master_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_control_t_validate(int unit, portmod_preemption_control_t portmod_preemption_control)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_preemption_control >= portmodPreemptionControlCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_preemption_control_set(int unit, int port, portmod_preemption_control_t type, uint32 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_preemption_control_t_validate(unit, type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_control_set(unit, port, pm_info, type, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_control_get(int unit, int port, portmod_preemption_control_t type, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_preemption_control_t_validate(unit, type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_control_get(unit, port, pm_info, type, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_tx_status_t_validate(int unit, portmod_preemption_tx_status_t portmod_preemption_tx_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_preemption_tx_status >= portmodPreemptionTxStatusCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_preemption_tx_status_get(int unit, int port, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_tx_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_tx_status_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_tx_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_verify_status_type_t_validate(int unit, portmod_preemption_verify_status_type_t portmod_preemption_verify_status_type)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_preemption_verify_status_type >= portmodPreemptionVerifyCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_preemption_verify_status_t_validate(int unit, portmod_preemption_verify_status_t portmod_preemption_verify_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_preemption_verify_status >= portmodPreemptionVerifyStatusCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_preemption_verify_status_get(int unit, int port, portmod_preemption_verify_status_type_t type, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_preemption_verify_status_type_t_validate(unit, type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_verify_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_verify_status_get(unit, port, pm_info, type, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_verify_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_force_rx_eop_mode_t_validate(int unit, portmod_preemption_force_rx_eop_mode_t portmod_preemption_force_rx_eop_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_preemption_force_rx_eop_mode >= portmodPreemptionForceCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_preemption_force_rx_eop_mode_set(int unit, int port, portmod_preemption_force_rx_eop_mode_t type, uint32 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_preemption_force_rx_eop_mode_t_validate(unit, type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_force_rx_eop_mode_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_force_rx_eop_mode_set(unit, port, pm_info, type, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_force_rx_eop_mode_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_force_rx_eop_mode_get(int unit, int port, portmod_preemption_force_rx_eop_mode_t type, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_preemption_force_rx_eop_mode_t_validate(unit, type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }

    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_force_rx_eop_mode_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_force_rx_eop_mode_get(unit, port, pm_info, type, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_force_rx_eop_mode_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_rx_timeout_set(int unit, int port, uint32 enable, uint32 timeout_cnt)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_rx_timeout_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_rx_timeout_set(unit, port, pm_info, enable, timeout_cnt);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_rx_timeout_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_preemption_rx_timeout_get(int unit, int port, uint32* enable, uint32* timeout_cnt)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(timeout_cnt == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("timeout_cnt NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_preemption_rx_timeout_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_preemption_rx_timeout_get(unit, port, pm_info, enable, timeout_cnt);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_preemption_rx_timeout_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lane_count_get(int unit, int port, int line_side, int* num_lanes)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(num_lanes == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("num_lanes NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lane_count_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lane_count_get(unit, port, pm_info, line_side, num_lanes);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lane_count_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_timesync_tx_info_get(int unit, int port, portmod_fifo_status_t* tx_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tx_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tx_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_fifo_status_t_init(unit, tx_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tx_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_info_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_timesync_tx_info_get(unit, port, pm_info, tx_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_timesync_tx_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_lane_mask_get(int unit, int port, const portmod_access_get_params_t* params, int* lane_mask, int* xphy_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_access_get_params_t_validate(unit, params)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("params validation failed"));
    }

    if(lane_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("lane_mask NULL parameter"));
    }
    if(xphy_id == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("xphy_id NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_lane_mask_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_lane_mask_get(unit, port, pm_info, params, lane_mask, xphy_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_lane_mask_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_link_recovery_t_validate(int unit, const portmod_link_recovery_t* portmod_link_recovery)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_link_recovery == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_link_recovery_t_init(int unit, portmod_link_recovery_t* portmod_link_recovery)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_link_recovery == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_link_recovery NULL parameter"));
    }
    sal_memset(portmod_link_recovery, 0, sizeof(portmod_link_recovery_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_core_add(int unit, int pm_id, int flags, const portmod_port_add_info_t* add_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_add_info_t_validate(unit, add_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("add_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_core_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_core_add(unit, pm_id, pm_info, flags, add_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_core_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_serdes_core_init(int unit, int pm_id, const portmod_port_add_info_t* add_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_add_info_t_validate(unit, add_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("add_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_serdes_core_init) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_serdes_core_init(unit, pm_id, pm_info, add_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_serdes_core_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_is_initialized(int unit, int pm_id, int* is_initialized)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(is_initialized == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("is_initialized NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_is_initialized) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_is_initialized(unit, pm_id, pm_info, is_initialized);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_is_initialized isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pmd_lane_config_t_validate(int unit, const portmod_pmd_lane_config_t* portmod_pmd_lane_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pmd_lane_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pmd_lane_config_t_init(int unit, portmod_pmd_lane_config_t* portmod_pmd_lane_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pmd_lane_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pmd_lane_config NULL parameter"));
    }
    sal_memset(portmod_pmd_lane_config, 0, sizeof(portmod_pmd_lane_config_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_speed_config_validate(int unit, int port, const portmod_speed_config_t* speed_config, portmod_pbmp_t* affected_pbmp)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_speed_config_t_validate(unit, speed_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config validation failed"));
    }

    if(affected_pbmp == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("affected_pbmp NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_speed_config_validate) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_speed_config_validate(unit, port, pm_info, speed_config, affected_pbmp);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_speed_config_validate isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_enable(int unit, int pm_id, int flags, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_enable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_enable(unit, pm_id, pm_info, flags, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_enable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_logical_pbmp_get(int unit, int pm_id, portmod_pbmp_t* logical_pbmp)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(logical_pbmp == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("logical_pbmp NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_logical_pbmp_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_logical_pbmp_get(unit, pm_id, pm_info, logical_pbmp);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_logical_pbmp_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_vco_reconfig(int unit, int pm_id, const portmod_vco_type_t* vco)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_vco_type_t_validate(unit, *vco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vco validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_vco_reconfig) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_vco_reconfig(unit, pm_id, pm_info, vco);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_vco_reconfig isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_speed_config_set(int unit, int port, const portmod_speed_config_t* speed_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_speed_config_t_validate(unit, speed_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_speed_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_speed_config_set(unit, port, pm_info, speed_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_speed_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_speed_config_get(int unit, int port, portmod_speed_config_t* speed_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(speed_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_speed_config_t_init(unit, speed_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_speed_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_speed_config_get(unit, port, pm_info, speed_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_speed_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_sbus_bcast_config_t_validate(int unit, const portmod_sbus_bcast_config_t* portmod_sbus_bcast_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_sbus_bcast_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_sbus_bcast_config_t_init(int unit, portmod_sbus_bcast_config_t* portmod_sbus_bcast_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_sbus_bcast_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_sbus_bcast_config NULL parameter"));
    }
    sal_memset(portmod_sbus_bcast_config, 0, sizeof(portmod_sbus_bcast_config_t));
    portmod_sbus_bcast_config->bcast_id = 0;
    portmod_sbus_bcast_config->chain_last = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_fw_bcast(int unit, pm_info_t pm_info, const portmod_sbus_bcast_config_t* sbus_bcast_cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_sbus_bcast_config_t_validate(unit, sbus_bcast_cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sbus_bcast_cfg validation failed"));
    }

    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_fw_bcast) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_fw_bcast(unit, pm_info, sbus_bcast_cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_fw_bcast isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_credits_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_credits_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_credits_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_credits_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_stage_t_validate(int unit, portmod_cpri_stage_t portmod_cpri_stage)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_stage >= portmodCpriStageCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_stage_activate(int unit, int port, portmod_cpri_stage_t stage)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_stage_t_validate(unit, stage)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("stage validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_stage_activate) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_stage_activate(unit, port, pm_info, stage);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_stage_activate isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_axc_frame_info_t_validate(int unit, const portmod_cpri_axc_frame_info_t* portmod_cpri_axc_frame_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_axc_frame_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_axc_frame_info_t_init(int unit, portmod_cpri_axc_frame_info_t* portmod_cpri_axc_frame_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_axc_frame_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_axc_frame_info NULL parameter"));
    }
    sal_memset(portmod_cpri_axc_frame_info, 0, sizeof(portmod_cpri_axc_frame_info_t));
    portmod_cpri_axc_frame_info->start_bit = 0;
    portmod_cpri_axc_frame_info->num_bits = 0;
    _SOC_IF_ERR_EXIT(cprimod_cpri_container_config_t_init(&portmod_cpri_axc_frame_info->container_info));
    _SOC_IF_ERR_EXIT(cprimod_payload_size_info_t_init(&portmod_cpri_axc_frame_info->roe_payload_info));
    _SOC_IF_ERR_EXIT(cprimod_encap_decap_data_config_t_init(&portmod_cpri_axc_frame_info->encap_data_info));

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_fsm_state_set(int unit, int port, cprimod_rsvd4_tx_fsm_state_t state)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_fsm_state_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_fsm_state_set(unit, port, pm_info, state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_tx_fsm_state_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_override_set(int unit, int port, cprimod_rsvd4_tx_overide_t parameter, int enable, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_override_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_override_set(unit, port, pm_info, parameter, enable, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_tx_override_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_override_set(int unit, int port, cprimod_rsvd4_rx_overide_t parameter, int enable, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_override_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_override_set(unit, port, pm_info, parameter, enable, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_rx_override_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_axc_frame_add(int unit, int port, uint32 axc_id, const portmod_cpri_axc_frame_info_t* frame_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_axc_frame_info_t_validate(unit, frame_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("frame_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_axc_frame_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_axc_frame_add(unit, port, pm_info, axc_id, frame_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_axc_frame_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_frame_optional_config_set(int unit, int port, cprimod_rx_config_field_t field, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_frame_optional_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_frame_optional_config_set(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_frame_optional_config_get(int unit, int port, cprimod_rx_config_field_t field, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_frame_optional_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_frame_optional_config_get(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_optional_config_set(int unit, int port, cprimod_tx_config_field_t field, uint32 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_optional_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_optional_config_set(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_optional_config_get(int unit, int port, cprimod_tx_config_field_t field, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_optional_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_optional_config_get(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_frame_optional_config_set(int unit, int port, cprimod_rsvd4_rx_config_field_t field, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_frame_optional_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_frame_optional_config_set(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_rx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_frame_optional_config_get(int unit, int port, cprimod_rsvd4_rx_config_field_t field, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_frame_optional_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_frame_optional_config_get(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_rx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_frame_optional_config_set(int unit, int port, cprimod_rsvd4_tx_config_field_t field, int value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_frame_optional_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_frame_optional_config_set(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_tx_frame_optional_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_frame_optional_config_get(int unit, int port, cprimod_rsvd4_tx_config_field_t field, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_frame_optional_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_frame_optional_config_get(unit, port, pm_info, field, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_tx_frame_optional_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_speed_set(int unit, int port, cprimod_port_rsvd4_speed_mult_t speed)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_speed_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_speed_set(unit, port, pm_info, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_rx_speed_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_rx_speed_get(int unit, int port, cprimod_port_rsvd4_speed_mult_t* speed)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(speed == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_speed_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_rx_speed_get(unit, port, pm_info, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_rx_speed_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_speed_set(int unit, int port, cprimod_port_rsvd4_speed_mult_t speed)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_speed_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_speed_set(unit, port, pm_info, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_tx_speed_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_port_rsvd4_tx_speed_get(int unit, int port, cprimod_port_rsvd4_speed_mult_t* speed)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(speed == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_speed_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rsvd4_tx_speed_get(unit, port, pm_info, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rsvd4_tx_speed_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_axc_frame_delete(int unit, int port, uint32 axc_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_axc_frame_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_axc_frame_delete(unit, port, pm_info, axc_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_axc_frame_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_axc_frame_get(int unit, int port, uint32 axc_id, uint32 from_get_all, portmod_cpri_axc_frame_info_t* frame_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(frame_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("frame_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_axc_frame_info_t_init(unit, frame_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("frame_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_axc_frame_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_axc_frame_get(unit, port, pm_info, axc_id, from_get_all, frame_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_axc_frame_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_fsm_state_set(int unit, int port, cprimod_rsvd4_rx_fsm_state_t state)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_fsm_state_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_fsm_state_set(unit, port, pm_info, state);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_rx_fsm_state_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_axc_frame_add(int unit, int port, uint32 axc_id, const portmod_cpri_axc_frame_info_t* frame_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_axc_frame_info_t_validate(unit, frame_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("frame_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_axc_frame_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_axc_frame_add(unit, port, pm_info, axc_id, frame_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_axc_frame_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_axc_frame_delete(int unit, int port, uint32 axc_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_axc_frame_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_axc_frame_delete(unit, port, pm_info, axc_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_axc_frame_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_axc_frame_get(int unit, int port, uint32 axc_id, uint32 from_get_all, portmod_cpri_axc_frame_info_t* frame_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(frame_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("frame_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_axc_frame_info_t_init(unit, frame_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("frame_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_axc_frame_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_axc_frame_get(unit, port, pm_info, axc_id, from_get_all, frame_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_axc_frame_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_set(int unit, int port, uint32 queue_num, const cprimod_encap_header_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_set(unit, port, pm_info, queue_num, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_get(int unit, int port, uint32 queue_num, cprimod_encap_header_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_get(unit, port, pm_info, queue_num, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_info_set(int unit, int port, uint32 index, const cprimod_encap_ordering_info_entry_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_info_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_info_set(unit, port, pm_info, index, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_roe_ordering_info_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_info_get(int unit, int port, uint32 index, cprimod_encap_ordering_info_entry_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_info_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_info_get(unit, port, pm_info, index, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_roe_ordering_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_sequence_offset_set(int unit, int port, uint32 queue_num, uint32 control, const cprimod_cpri_ordering_info_offset_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_sequence_offset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_sequence_offset_set(unit, port, pm_info, queue_num, control, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_roe_ordering_sequence_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_roe_ordering_sequence_offset_get(int unit, int port, uint32 queue_num, uint32 control, cprimod_cpri_ordering_info_offset_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_sequence_offset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_roe_ordering_sequence_offset_get(unit, port, pm_info, queue_num, control, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_roe_ordering_sequence_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macda_entry_set(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macda_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macda_entry_set(unit, port, pm_info, index, mac_addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_roe_encap_macda_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macda_entry_get(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macda_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macda_entry_get(unit, port, pm_info, index, mac_addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_roe_encap_macda_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macsa_entry_set(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macsa_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macsa_entry_set(unit, port, pm_info, index, mac_addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_roe_encap_macsa_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_macsa_entry_get(int unit, int port, uint32 index, cprimod_mac_addr_t mac_addr)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macsa_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_macsa_entry_get(unit, port, pm_info, index, mac_addr);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_roe_encap_macsa_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_vlan_entry_set(int unit, int port, uint32 index, cprimod_vlan_table_id_t table_id, uint32 vlan_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_vlan_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_vlan_entry_set(unit, port, pm_info, index, table_id, vlan_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_roe_encap_vlan_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_roe_encap_vlan_entry_get(int unit, int port, uint32 index, cprimod_vlan_table_id_t table_id, uint32* vlan_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(vlan_id == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vlan_id NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_vlan_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_roe_encap_vlan_entry_get(unit, port, pm_info, index, table_id, vlan_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_roe_encap_vlan_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_ethertype_config_set(int unit, int port, cprimod_ethertype_t pkt_type, uint16 ethtype)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_ethertype_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_ethertype_config_set(unit, port, pm_info, pkt_type, ethtype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_ethertype_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_ethertype_config_get(int unit, int port, cprimod_ethertype_t pkt_type, uint16* ethtype)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ethtype == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ethtype NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_ethertype_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_ethertype_config_get(unit, port, pm_info, pkt_type, ethtype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_ethertype_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_ethertype_config_set(int unit, int port, cprimod_ethertype_t pkt_type, uint16 ethtype)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_ethertype_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_ethertype_config_set(unit, port, pm_info, pkt_type, ethtype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_ethertype_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_ethertype_config_get(int unit, int port, cprimod_ethertype_t pkt_type, uint16* ethtype)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ethtype == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ethtype NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_ethertype_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_ethertype_config_get(unit, port, pm_info, pkt_type, ethtype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_ethertype_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_config_set(int unit, int port, uint8 roe_subtype, uint32 queue_num, cprimod_cls_option_t cls_option, cprimod_cls_flow_type_t flow_type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_config_set(unit, port, pm_info, roe_subtype, queue_num, cls_option, flow_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_flow_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_config_get(int unit, int port, uint8 roe_subtype, uint32* queue_num, cprimod_cls_option_t* cls_option, cprimod_cls_flow_type_t* flow_type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(queue_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("queue_num NULL parameter"));
    }
    if(cls_option == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cls_option NULL parameter"));
    }
    if(flow_type == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_type NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_config_get(unit, port, pm_info, roe_subtype, queue_num, cls_option, flow_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_flow_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_config_clear(int unit, int port, uint8 roe_subtype)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_config_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_config_clear(unit, port, pm_info, roe_subtype);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_flow_config_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_to_ordering_info_index_set(int unit, int port, uint32 queue_num, uint32 ordering_info_index)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_to_ordering_info_index_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_to_ordering_info_index_set(unit, port, pm_info, queue_num, ordering_info_index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_queue_to_ordering_info_index_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_to_ordering_info_index_get(int unit, int port, uint32 queue_num, uint32* ordering_info_index)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ordering_info_index == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ordering_info_index NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_to_ordering_info_index_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_to_ordering_info_index_get(unit, port, pm_info, queue_num, ordering_info_index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_queue_to_ordering_info_index_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_to_queue_mapping_set(int unit, int port, uint32 flow_id, uint32 queue_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_to_queue_mapping_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_to_queue_mapping_set(unit, port, pm_info, flow_id, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_flow_to_queue_mapping_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_to_queue_mapping_get(int unit, int port, uint32 flow_id, uint32* queue_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(queue_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("queue_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_to_queue_mapping_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_to_queue_mapping_get(unit, port, pm_info, flow_id, queue_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_flow_to_queue_mapping_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_flow_to_queue_mapping_clear(int unit, int port, uint32 flow_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_to_queue_mapping_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_flow_to_queue_mapping_clear(unit, port, pm_info, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_flow_to_queue_mapping_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_info_set(int unit, int port, uint32 index, const cprimod_decap_ordering_info_entry_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_info_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_info_set(unit, port, pm_info, index, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_roe_ordering_info_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_info_get(int unit, int port, uint32 index, cprimod_decap_ordering_info_entry_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_info_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_info_get(unit, port, pm_info, index, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_roe_ordering_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_sequence_offset_set(int unit, int port, uint32 queue_num, const cprimod_cpri_ordering_info_offset_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_sequence_offset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_sequence_offset_set(unit, port, pm_info, queue_num, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_roe_ordering_sequence_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_roe_ordering_sequence_offset_get(int unit, int port, uint32 queue_num, cprimod_cpri_ordering_info_offset_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_sequence_offset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_roe_ordering_sequence_offset_get(unit, port, pm_info, queue_num, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_roe_ordering_sequence_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_tx_frame_tgen_config_t_validate(int unit, const portmod_tx_frame_tgen_config_t* portmod_tx_frame_tgen_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_tx_frame_tgen_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_tx_frame_tgen_config_t_init(int unit, portmod_tx_frame_tgen_config_t* portmod_tx_frame_tgen_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_tx_frame_tgen_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_tx_frame_tgen_config NULL parameter"));
    }
    sal_memset(portmod_tx_frame_tgen_config, 0, sizeof(portmod_tx_frame_tgen_config_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_config_set(int unit, int port, const portmod_tx_frame_tgen_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_tx_frame_tgen_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_tgen_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_config_get(int unit, int port, portmod_tx_frame_tgen_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_tx_frame_tgen_config_t_init(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_tgen_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_enable(int unit, int port, uint32 enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_enable) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_enable(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_tgen_enable isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_ts_offset_set(int unit, int port, uint64 offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_ts_offset_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_ts_offset_set(unit, port, pm_info, offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_tgen_ts_offset_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_tgen_ts_offset_get(int unit, int port, uint64* offset)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(offset == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("offset NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_ts_offset_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_tgen_ts_offset_get(unit, port, pm_info, offset);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_tgen_ts_offset_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_next_hfn_get(int unit, int port, uint32* hfn)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(hfn == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("hfn NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_next_hfn_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_next_hfn_get(unit, port, pm_info, hfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_next_hfn_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_frame_next_bfn_get(int unit, int port, uint32* bfn)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bfn == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_next_bfn_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_frame_next_bfn_get(unit, port, pm_info, bfn);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_frame_next_bfn_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_flow_info_t_validate(int unit, const portmod_rsvd4_rx_flow_info_t* portmod_rsvd4_rx_flow_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rsvd4_rx_flow_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_flow_info_t_init(int unit, portmod_rsvd4_rx_flow_info_t* portmod_rsvd4_rx_flow_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rsvd4_rx_flow_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rsvd4_rx_flow_info NULL parameter"));
    }
    sal_memset(portmod_rsvd4_rx_flow_info, 0, sizeof(portmod_rsvd4_rx_flow_info_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_flow_info_t_validate(int unit, const portmod_rsvd4_tx_flow_info_t* portmod_rsvd4_tx_flow_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rsvd4_tx_flow_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_flow_info_t_init(int unit, portmod_rsvd4_tx_flow_info_t* portmod_rsvd4_tx_flow_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rsvd4_tx_flow_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rsvd4_tx_flow_info NULL parameter"));
    }
    sal_memset(portmod_rsvd4_tx_flow_info, 0, sizeof(portmod_rsvd4_tx_flow_info_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_flow_add(int unit, int port, uint32 flow_id, const portmod_rsvd4_rx_flow_info_t* info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rsvd4_rx_flow_info_t_validate(unit, info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_flow_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_flow_add(unit, port, pm_info, flow_id, info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_rx_flow_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_flow_delete(int unit, int port, uint32 flow_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_flow_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_flow_delete(unit, port, pm_info, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_rx_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_flow_add(int unit, int port, uint32 flow_id, const portmod_rsvd4_tx_flow_info_t* info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rsvd4_tx_flow_info_t_validate(unit, info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_flow_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_flow_add(unit, port, pm_info, flow_id, info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_tx_flow_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_tx_flow_delete(int unit, int port, uint32 flow_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_flow_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_tx_flow_delete(unit, port, pm_info, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_tx_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_entry_set(int unit, int port, uint32 profile_id, const cprimod_dbm_rule_entry_t* profile)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_entry_set(unit, port, pm_info, profile_id, profile);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_dbm_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_entry_get(int unit, int port, uint32 profile_id, cprimod_dbm_rule_entry_t* profile)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(profile == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("profile NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_entry_get(unit, port, pm_info, profile_id, profile);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_dbm_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_secondary_dbm_entry_set(int unit, int port, uint32 profile_id, const cprimod_secondary_dbm_rule_entry_t* profile)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_secondary_dbm_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_secondary_dbm_entry_set(unit, port, pm_info, profile_id, profile);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_secondary_dbm_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_secondary_dbm_entry_get(int unit, int port, uint32 profile_id, cprimod_secondary_dbm_rule_entry_t* profile)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(profile == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("profile NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_secondary_dbm_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_secondary_dbm_entry_get(unit, port, pm_info, profile_id, profile);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_secondary_dbm_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_modulo_rule_entry_set(int unit, int port, uint32 modulo_rule_num, cprimod_transmission_rule_type_t modulo_rule_type, const cprimod_modulo_rule_entry_t* modulo_rule)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_modulo_rule_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_modulo_rule_entry_set(unit, port, pm_info, modulo_rule_num, modulo_rule_type, modulo_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_modulo_rule_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_modulo_rule_entry_get(int unit, int port, uint32 modulo_rule_num, cprimod_transmission_rule_type_t modulo_rule_type, cprimod_modulo_rule_entry_t* modulo_rule)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(modulo_rule == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo_rule NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_modulo_rule_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_modulo_rule_entry_get(unit, port, pm_info, modulo_rule_num, modulo_rule_type, modulo_rule);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_modulo_rule_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_position_entry_set(int unit, int port, uint32 index, const cprimod_dbm_pos_table_entry_t* pos_entry)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_position_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_position_entry_set(unit, port, pm_info, index, pos_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_dbm_position_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_dbm_position_entry_get(int unit, int port, uint32 index, cprimod_dbm_pos_table_entry_t* pos_entry)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(pos_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pos_entry NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_position_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_dbm_position_entry_get(unit, port, pm_info, index, pos_entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_dbm_position_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_master_frame_sync_config_set(int unit, int port, uint32 master_frame_number, uint64 master_frame_start_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_master_frame_sync_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_master_frame_sync_config_set(unit, port, pm_info, master_frame_number, master_frame_start_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_rx_master_frame_sync_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rsvd4_rx_master_frame_sync_config_get(int unit, int port, uint32* master_frame_number, uint64* master_frame_start_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(master_frame_number == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("master_frame_number NULL parameter"));
    }
    if(master_frame_start_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("master_frame_start_time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_master_frame_sync_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rsvd4_rx_master_frame_sync_config_get(unit, port, pm_info, master_frame_number, master_frame_start_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rsvd4_rx_master_frame_sync_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_vcos_speed_config_t_validate(int unit, const portmod_vcos_speed_config_t* portmod_vcos_speed_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_vcos_speed_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_core_port_enet_cpri_type_t_validate(unit, portmod_vcos_speed_config->port_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("port_type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_vcos_speed_config_t_init(int unit, portmod_vcos_speed_config_t* portmod_vcos_speed_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_vcos_speed_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_vcos_speed_config NULL parameter"));
    }
    sal_memset(portmod_vcos_speed_config, 0, sizeof(portmod_vcos_speed_config_t));
    portmod_vcos_speed_config->num_lanes = 0;
    portmod_vcos_speed_config->ieee_mode = 0;
    portmod_vcos_speed_config->higig_mode = 0;
    portmod_vcos_speed_config->txpi_mode = 0;
    portmod_vcos_speed_config->eth_of_mixed_mode = 0;
    portmod_vcos_speed_config->port_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dual_vcos_t_validate(int unit, const portmod_dual_vcos_t* portmod_dual_vcos)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_dual_vcos == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_dual_vcos_t_init(int unit, portmod_dual_vcos_t* portmod_dual_vcos)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_dual_vcos == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_dual_vcos NULL parameter"));
    }
    sal_memset(portmod_dual_vcos, 0, sizeof(portmod_dual_vcos_t));
    portmod_dual_vcos->vco_0 = 0;
    portmod_dual_vcos->vco_1 = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_vcos_get(int unit, int port, const portmod_vcos_speed_config_t* speed_config_list, int size, portmod_dual_vcos_t* dual_vco)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_vcos_speed_config_t_validate(unit, speed_config_list)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config_list validation failed"));
    }

    if(dual_vco == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dual_vco NULL parameter"));
    }
    if(SOC_E_NONE != portmod_dual_vcos_t_init(unit, dual_vco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("dual_vco initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_vcos_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_vcos_get(unit, port, pm_info, speed_config_list, size, dual_vco);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_vcos_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_timestamp_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_timestamp_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_timestamp_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_timestamp_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_mac_timestamp_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_timestamp_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_timestamp_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_timestamp_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_sync_info_get(int unit, int port, uint32* hyper_frame_num, uint32* radio_frame_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(hyper_frame_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("hyper_frame_num NULL parameter"));
    }
    if(radio_frame_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("radio_frame_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_sync_info_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_sync_info_get(unit, port, pm_info, hyper_frame_num, radio_frame_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_cw_sync_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_l1_inband_info_get(int unit, int port, portmod_cpri_cw_l1_inband_info_t* l1_inband_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(l1_inband_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("l1_inband_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_l1_inband_info_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_l1_inband_info_get(unit, port, pm_info, l1_inband_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_cw_l1_inband_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_l1_signal_signal_protection_set(int unit, int port, uint32 signal_map, uint32 enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_l1_signal_signal_protection_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_l1_signal_signal_protection_set(unit, port, pm_info, signal_map, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_cw_l1_signal_signal_protection_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_cw_l1_signal_signal_protection_get(int unit, int port, uint32 signal_map, uint32* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_l1_signal_signal_protection_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_cw_l1_signal_signal_protection_get(unit, port, pm_info, signal_map, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_cw_l1_signal_signal_protection_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_slow_hdlc_config_info_t_validate(int unit, const portmod_cpri_slow_hdlc_config_info_t* portmod_cpri_slow_hdlc_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_slow_hdlc_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_slow_hdlc_config_info_t_init(int unit, portmod_cpri_slow_hdlc_config_info_t* portmod_cpri_slow_hdlc_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_slow_hdlc_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_slow_hdlc_config_info NULL parameter"));
    }
    sal_memset(portmod_cpri_slow_hdlc_config_info, 0, sizeof(portmod_cpri_slow_hdlc_config_info_t));
    portmod_cpri_slow_hdlc_config_info->tx_crc_mode = 0;
    portmod_cpri_slow_hdlc_config_info->tx_flag_size = 0;
    portmod_cpri_slow_hdlc_config_info->tx_filling_flag_pattern = PORTMOD_CPRI_HDLC_FILLING_FLAG_PATTERN_7E;
    portmod_cpri_slow_hdlc_config_info->crc_init_val = 0;
    portmod_cpri_slow_hdlc_config_info->fcs_size = PORTMOD_CPRI_HDLC_FCS_SIZE_8_BITS;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_slow_hdlc_config_set(int unit, int port, const portmod_cpri_slow_hdlc_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_slow_hdlc_config_info_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_slow_hdlc_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_slow_hdlc_config_set(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_cw_slow_hdlc_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_slow_hdlc_config_get(int unit, int port, portmod_cpri_slow_hdlc_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_slow_hdlc_config_info_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_slow_hdlc_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_slow_hdlc_config_get(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_cw_slow_hdlc_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_fast_eth_config_info_t_validate(int unit, const portmod_cpri_fast_eth_config_info_t* portmod_cpri_fast_eth_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_fast_eth_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_fast_eth_config_info_t_init(int unit, portmod_cpri_fast_eth_config_info_t* portmod_cpri_fast_eth_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_fast_eth_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_fast_eth_config_info NULL parameter"));
    }
    sal_memset(portmod_cpri_fast_eth_config_info, 0, sizeof(portmod_cpri_fast_eth_config_info_t));
    portmod_cpri_fast_eth_config_info->tx_crc_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_fast_eth_config_set(int unit, int port, const portmod_cpri_fast_eth_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_fast_eth_config_info_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_fast_eth_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_fast_eth_config_set(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_cw_fast_eth_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_cw_fast_eth_config_get(int unit, int port, portmod_cpri_fast_eth_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_fast_eth_config_info_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_fast_eth_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_cw_fast_eth_config_get(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_cw_fast_eth_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_vsd_config_info_t_validate(int unit, const portmod_cpri_rx_vsd_config_info_t* portmod_cpri_rx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_rx_vsd_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_vsd_config_info_t_init(int unit, portmod_cpri_rx_vsd_config_info_t* portmod_cpri_rx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_rx_vsd_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_rx_vsd_config_info NULL parameter"));
    }
    sal_memset(portmod_cpri_rx_vsd_config_info, 0, sizeof(portmod_cpri_rx_vsd_config_info_t));
    portmod_cpri_rx_vsd_config_info->subchan_size = 0;
    portmod_cpri_rx_vsd_config_info->subchan_bytes = 0;
    portmod_cpri_rx_vsd_config_info->flow_bytes = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_config_set(int unit, int port, const portmod_cpri_rx_vsd_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_rx_vsd_config_info_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_config_set(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_vsd_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_config_get(int unit, int port, portmod_cpri_rx_vsd_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_rx_vsd_config_info_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_config_get(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_vsd_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_vsd_config_info_t_validate(int unit, const portmod_cpri_tx_vsd_config_info_t* portmod_cpri_tx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_tx_vsd_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_vsd_config_info_t_init(int unit, portmod_cpri_tx_vsd_config_info_t* portmod_cpri_tx_vsd_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_tx_vsd_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_tx_vsd_config_info NULL parameter"));
    }
    sal_memset(portmod_cpri_tx_vsd_config_info, 0, sizeof(portmod_cpri_tx_vsd_config_info_t));
    portmod_cpri_tx_vsd_config_info->subchan_size = 0;
    portmod_cpri_tx_vsd_config_info->subchan_bytes = 0;
    portmod_cpri_tx_vsd_config_info->flow_bytes = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_config_set(int unit, int port, const portmod_cpri_tx_vsd_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_tx_vsd_config_info_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_config_set(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_config_get(int unit, int port, portmod_cpri_tx_vsd_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_tx_vsd_config_info_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_config_get(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_flow_add(int unit, int port, uint32 group_id, const portmod_cpri_rx_vsd_flow_info_t* flow_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_flow_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_flow_add(unit, port, pm_info, group_id, flow_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_vsd_flow_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_flow_get(int unit, int port, uint32 group_id, portmod_cpri_rx_vsd_flow_info_t* flow_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(flow_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_flow_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_flow_get(unit, port, pm_info, group_id, flow_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_vsd_flow_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_flow_delete(int unit, int port, uint32 group_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_flow_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_flow_delete(unit, port, pm_info, group_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_vsd_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_flow_add(int unit, int port, uint32 group_id, const portmod_cpri_tx_vsd_flow_info_t* flow_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_flow_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_flow_add(unit, port, pm_info, group_id, flow_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_flow_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_flow_delete(int unit, int port, uint32 group_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_flow_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_flow_delete(unit, port, pm_info, group_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_flow_get(int unit, int port, uint32 group_id, portmod_cpri_tx_vsd_flow_info_t* flow_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(flow_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_flow_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_flow_get(unit, port, pm_info, group_id, flow_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_flow_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_queue_control_tag_to_flow_map_set(int unit, int port, uint32 tag_id, uint32 flow_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_queue_control_tag_to_flow_map_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_queue_control_tag_to_flow_map_set(unit, port, pm_info, tag_id, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_queue_control_tag_to_flow_map_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_queue_control_tag_to_flow_map_get(int unit, int port, uint32 tag_id, uint32* flow_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(flow_id == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("flow_id NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_queue_control_tag_to_flow_map_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_queue_control_tag_to_flow_map_get(unit, port, pm_info, tag_id, flow_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_queue_control_tag_to_flow_map_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_vsd_raw_config_t_validate(int unit, const portmod_cpri_rx_vsd_raw_config_t* portmod_cpri_rx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_rx_vsd_raw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_vsd_raw_config_t_init(int unit, portmod_cpri_rx_vsd_raw_config_t* portmod_cpri_rx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_rx_vsd_raw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_rx_vsd_raw_config NULL parameter"));
    }
    sal_memset(portmod_cpri_rx_vsd_raw_config, 0, sizeof(portmod_cpri_rx_vsd_raw_config_t));
    portmod_cpri_rx_vsd_raw_config->filter_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_raw_config_set(int unit, int port, uint32 index, const portmod_cpri_rx_vsd_raw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_rx_vsd_raw_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_raw_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_raw_config_set(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_vsd_raw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_vsd_raw_config_get(int unit, int port, uint32 index, portmod_cpri_rx_vsd_raw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_rx_vsd_raw_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_raw_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_vsd_raw_config_get(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_vsd_raw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_vsd_raw_config_t_validate(int unit, const portmod_cpri_tx_vsd_raw_config_t* portmod_cpri_tx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_tx_vsd_raw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_vsd_raw_config_t_init(int unit, portmod_cpri_tx_vsd_raw_config_t* portmod_cpri_tx_vsd_raw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_tx_vsd_raw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_tx_vsd_raw_config NULL parameter"));
    }
    sal_memset(portmod_cpri_tx_vsd_raw_config, 0, sizeof(portmod_cpri_tx_vsd_raw_config_t));
    portmod_cpri_tx_vsd_raw_config->map_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_config_set(int unit, int port, uint32 index, const portmod_cpri_tx_vsd_raw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_tx_vsd_raw_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_config_set(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_raw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_config_get(int unit, int port, uint32 index, portmod_cpri_tx_vsd_raw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_tx_vsd_raw_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_config_get(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_raw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_filter_set(int unit, int port, uint32 bfn0_value, uint32 bfn0_mask, uint32 bfn1_value, uint32 bfn1_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_filter_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_filter_set(unit, port, pm_info, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_raw_filter_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_vsd_raw_filter_get(int unit, int port, uint32* bfn0_value, uint32* bfn0_mask, uint32* bfn1_value, uint32* bfn1_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bfn0_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_value NULL parameter"));
    }
    if(bfn0_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_mask NULL parameter"));
    }
    if(bfn1_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_value NULL parameter"));
    }
    if(bfn1_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_mask NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_filter_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_vsd_raw_filter_get(unit, port, pm_info, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_vsd_raw_filter_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_brcm_rsvd5_config_t_validate(int unit, const portmod_cpri_rx_brcm_rsvd5_config_t* portmod_cpri_rx_brcm_rsvd5_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_rx_brcm_rsvd5_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_brcm_rsvd5_config_t_init(int unit, portmod_cpri_rx_brcm_rsvd5_config_t* portmod_cpri_rx_brcm_rsvd5_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_rx_brcm_rsvd5_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_rx_brcm_rsvd5_config NULL parameter"));
    }
    sal_memset(portmod_cpri_rx_brcm_rsvd5_config, 0, sizeof(portmod_cpri_rx_brcm_rsvd5_config_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_brcm_rsvd5_config_set(int unit, int port, const portmod_cpri_rx_brcm_rsvd5_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_rx_brcm_rsvd5_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_brcm_rsvd5_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_brcm_rsvd5_config_set(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_brcm_rsvd5_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_brcm_rsvd5_config_get(int unit, int port, portmod_cpri_rx_brcm_rsvd5_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_rx_brcm_rsvd5_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_brcm_rsvd5_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_brcm_rsvd5_config_get(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_brcm_rsvd5_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_brcm_rsvd5_config_t_validate(int unit, const portmod_cpri_tx_brcm_rsvd5_config_t* portmod_cpri_tx_brcm_rsvd5_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_tx_brcm_rsvd5_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_brcm_rsvd5_config_t_init(int unit, portmod_cpri_tx_brcm_rsvd5_config_t* portmod_cpri_tx_brcm_rsvd5_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_tx_brcm_rsvd5_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_tx_brcm_rsvd5_config NULL parameter"));
    }
    sal_memset(portmod_cpri_tx_brcm_rsvd5_config, 0, sizeof(portmod_cpri_tx_brcm_rsvd5_config_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_brcm_rsvd5_config_set(int unit, int port, const portmod_cpri_tx_brcm_rsvd5_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_tx_brcm_rsvd5_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_brcm_rsvd5_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_brcm_rsvd5_config_set(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_brcm_rsvd5_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_brcm_rsvd5_config_get(int unit, int port, portmod_cpri_tx_brcm_rsvd5_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_tx_brcm_rsvd5_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_brcm_rsvd5_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_brcm_rsvd5_config_get(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_brcm_rsvd5_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_gcw_config_t_validate(int unit, const portmod_cpri_rx_gcw_config_t* portmod_cpri_rx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_rx_gcw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_gcw_config_t_init(int unit, portmod_cpri_rx_gcw_config_t* portmod_cpri_rx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_rx_gcw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_rx_gcw_config NULL parameter"));
    }
    sal_memset(portmod_cpri_rx_gcw_config, 0, sizeof(portmod_cpri_rx_gcw_config_t));
    portmod_cpri_rx_gcw_config->mask = 0;
    portmod_cpri_rx_gcw_config->filter_mode = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_gcw_config_t_validate(int unit, const portmod_cpri_tx_gcw_config_t* portmod_cpri_tx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_tx_gcw_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_gcw_config_t_init(int unit, portmod_cpri_tx_gcw_config_t* portmod_cpri_tx_gcw_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_tx_gcw_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_tx_gcw_config NULL parameter"));
    }
    sal_memset(portmod_cpri_tx_gcw_config, 0, sizeof(portmod_cpri_tx_gcw_config_t));
    portmod_cpri_tx_gcw_config->mask = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_gcw_config_set(int unit, int port, uint32 index, const portmod_cpri_rx_gcw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_rx_gcw_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_gcw_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_gcw_config_set(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_gcw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_gcw_config_get(int unit, int port, uint32 index, portmod_cpri_rx_gcw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_rx_gcw_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_gcw_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_gcw_config_get(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_gcw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_config_set(int unit, int port, uint32 index, const portmod_cpri_tx_gcw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_tx_gcw_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_config_set(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_gcw_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_config_get(int unit, int port, uint32 index, portmod_cpri_tx_gcw_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_tx_gcw_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_config_get(unit, port, pm_info, index, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_gcw_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_filter_set(int unit, int port, uint32 bfn0_value, uint32 bfn0_mask, uint32 bfn1_value, uint32 bfn1_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_filter_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_filter_set(unit, port, pm_info, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_gcw_filter_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_filter_get(int unit, int port, uint32* bfn0_value, uint32* bfn0_mask, uint32* bfn1_value, uint32* bfn1_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bfn0_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_value NULL parameter"));
    }
    if(bfn0_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn0_mask NULL parameter"));
    }
    if(bfn1_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_value NULL parameter"));
    }
    if(bfn1_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bfn1_mask NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_filter_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_filter_get(unit, port, pm_info, bfn0_value, bfn0_mask, bfn1_value, bfn1_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_gcw_filter_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_sync_info_set(int unit, int port, uint32 hyper_frame_num, uint32 radio_frame_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_sync_info_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_sync_info_set(unit, port, pm_info, hyper_frame_num, radio_frame_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_cw_sync_info_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_sync_info_get(int unit, int port, uint32* hyper_frame_num, uint32* radio_frame_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(hyper_frame_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("hyper_frame_num NULL parameter"));
    }
    if(radio_frame_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("radio_frame_num NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_sync_info_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_sync_info_get(unit, port, pm_info, hyper_frame_num, radio_frame_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_cw_sync_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_l1_inband_info_set(int unit, int port, const portmod_cpri_cw_l1_inband_info_t* l1_inband_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_l1_inband_info_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_l1_inband_info_set(unit, port, pm_info, l1_inband_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_cw_l1_inband_info_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_cw_l1_inband_info_get(int unit, int port, portmod_cpri_cw_l1_inband_info_t* l1_inband_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(l1_inband_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("l1_inband_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_l1_inband_info_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_cw_l1_inband_info_get(unit, port, pm_info, l1_inband_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_cw_l1_inband_info_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_control_flow_config_t_validate(int unit, const portmod_control_flow_config_t* portmod_control_flow_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_control_flow_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_control_flow_config_t_init(int unit, portmod_control_flow_config_t* portmod_control_flow_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_control_flow_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_control_flow_config NULL parameter"));
    }
    sal_memset(portmod_control_flow_config, 0, sizeof(portmod_control_flow_config_t));
    portmod_control_flow_config->proc_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_control_flow_add(int unit, int port, uint32 flow_id, const portmod_control_flow_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_control_flow_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_control_flow_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_control_flow_add(unit, port, pm_info, flow_id, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_rx_control_flow_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_control_flow_delete(int unit, int port, uint32 flow_id, const portmod_control_flow_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_control_flow_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_control_flow_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_control_flow_delete(unit, port, pm_info, flow_id, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_rx_control_flow_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_fast_eth_config_set(int unit, int port, const portmod_cpri_fast_eth_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_fast_eth_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_fast_eth_config_set(unit, port, pm_info, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_fast_eth_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_sync_profile_entry_t_validate(int unit, const portmod_sync_profile_entry_t* portmod_sync_profile_entry)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_sync_profile_entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_sync_profile_entry_t_init(int unit, portmod_sync_profile_entry_t* portmod_sync_profile_entry)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_sync_profile_entry == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_sync_profile_entry NULL parameter"));
    }
    sal_memset(portmod_sync_profile_entry, 0, sizeof(portmod_sync_profile_entry_t));
    portmod_sync_profile_entry->count_cycle = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_sync_profile_entry_set(int unit, int port, uint32 profile_id, const portmod_sync_profile_entry_t* entry)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_sync_profile_entry_t_validate(unit, entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("entry validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_sync_profile_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_sync_profile_entry_set(unit, port, pm_info, profile_id, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_rx_sync_profile_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_sync_profile_entry_get(int unit, int port, uint32 profile_id, portmod_sync_profile_entry_t* entry)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(entry == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("entry NULL parameter"));
    }
    if(SOC_E_NONE != portmod_sync_profile_entry_t_init(unit, entry)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("entry initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_sync_profile_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_rx_sync_profile_entry_get(unit, port, pm_info, profile_id, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_rx_sync_profile_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_rx_tag_config_set(int unit, int port, uint32 default_tag, uint32 no_match_tag)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rx_tag_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rx_tag_config_set(unit, port, pm_info, default_tag, no_match_tag);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rx_tag_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_rx_tag_gen_entry_add(int unit, int port, const portmod_tag_gen_entry_t* entry)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rx_tag_gen_entry_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rx_tag_gen_entry_add(unit, port, pm_info, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rx_tag_gen_entry_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_rx_tag_gen_entry_delete(int unit, int port, const portmod_tag_gen_entry_t* entry)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rx_tag_gen_entry_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rx_tag_gen_entry_delete(unit, port, pm_info, entry);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rx_tag_gen_entry_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_group_member_add(int unit, int port, uint32 group_id, uint32 priority, uint32 queue_num, portmod_control_msg_proc_type_t proc_type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_group_member_add) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_group_member_add(unit, port, pm_info, group_id, priority, queue_num, proc_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_flow_group_member_add isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_group_member_delete(int unit, int port, uint32 group_id, uint32 priority)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_group_member_delete) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_group_member_delete(unit, port, pm_info, group_id, priority);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_flow_group_member_delete isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_eth_message_config_set(int unit, int port, uint32 msg_node, uint32 msg_subnode, uint32 msg_type, uint32 msg_padding)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_eth_message_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_eth_message_config_set(unit, port, pm_info, msg_node, msg_subnode, msg_type, msg_padding);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_eth_message_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_single_raw_message_config_set(int unit, int port, uint32 msg_id, uint32 msg_type)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_single_raw_message_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_single_raw_message_config_set(unit, port, pm_info, msg_id, msg_type);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_single_raw_message_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_config_info_t_validate(int unit, const portmod_rsvd4_tx_config_info_t* portmod_rsvd4_tx_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rsvd4_tx_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_config_info_t_init(int unit, portmod_rsvd4_tx_config_info_t* portmod_rsvd4_tx_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rsvd4_tx_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rsvd4_tx_config_info NULL parameter"));
    }
    sal_memset(portmod_rsvd4_tx_config_info, 0, sizeof(portmod_rsvd4_tx_config_info_t));
    portmod_rsvd4_tx_config_info->proc_type = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_config_set(int unit, int port, uint32 flow_id, const portmod_rsvd4_tx_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rsvd4_tx_config_info_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_config_set(unit, port, pm_info, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_flow_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_config_get(int unit, int port, uint32 flow_id, portmod_rsvd4_tx_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_rsvd4_tx_config_info_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_config_get(unit, port, pm_info, flow_id, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_flow_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_header_index_set(int unit, int port, uint32 roe_flow_id, uint32 index)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_header_index_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_header_index_set(unit, port, pm_info, roe_flow_id, index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_flow_header_index_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_flow_header_index_get(int unit, int port, uint32 roe_flow_id, uint32* index)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(index == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("index NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_header_index_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_flow_header_index_get(unit, port, pm_info, roe_flow_id, index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_flow_header_index_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_header_entry_set(int unit, int port, uint32 index, uint32 header_node, uint32 header_subnode, uint32 payload_node)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_header_entry_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_header_entry_set(unit, port, pm_info, index, header_node, header_subnode, payload_node);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_header_entry_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_control_header_entry_get(int unit, int port, uint32 index, uint32* header_node, uint32* header_subnode, uint32* payload_node)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(header_node == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("header_node NULL parameter"));
    }
    if(header_subnode == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("header_subnode NULL parameter"));
    }
    if(payload_node == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("payload_node NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_header_entry_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_control_header_entry_get(unit, port, pm_info, index, header_node, header_subnode, payload_node);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_control_header_entry_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_single_tunnel_message_config_set(int unit, int port, portmod_cpri_crc_option_t crc_option)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_single_tunnel_message_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_tx_single_tunnel_message_config_set(unit, port, pm_info, crc_option);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_tx_single_tunnel_message_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_txpi_override_t_validate(int unit, const portmod_txpi_override_t* portmod_txpi_override)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_txpi_override == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_txpi_override_t_init(int unit, portmod_txpi_override_t* portmod_txpi_override)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_txpi_override == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_txpi_override NULL parameter"));
    }
    sal_memset(portmod_txpi_override, 0, sizeof(portmod_txpi_override_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_txpi_override_set(int unit, int port, const portmod_txpi_override_t* override)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_txpi_override_t_validate(unit, override)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("override validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_txpi_override_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_txpi_override_set(unit, port, pm_info, override);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_txpi_override_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_txpi_override_get(int unit, int port, portmod_txpi_override_t* override)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(override == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("override NULL parameter"));
    }
    if(SOC_E_NONE != portmod_txpi_override_t_init(unit, override)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("override initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_txpi_override_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_txpi_override_get(unit, port, pm_info, override);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_txpi_override_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_txpi_sdm_data_get(int unit, int port, int* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_txpi_sdm_data_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_txpi_sdm_data_get(unit, port, pm_info, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_txpi_sdm_data_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm8x50_capability_t_validate(int unit, const portmod_pm8x50_capability_t* portmod_pm8x50_capability)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm8x50_capability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm8x50_capability_t_init(int unit, portmod_pm8x50_capability_t* portmod_pm8x50_capability)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm8x50_capability == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm8x50_capability NULL parameter"));
    }
    sal_memset(portmod_pm8x50_capability, 0, sizeof(portmod_pm8x50_capability_t));
    portmod_pm8x50_capability->num_lanes = 8;
    portmod_pm8x50_capability->num_cores = 1;
    portmod_pm8x50_capability->num_plls = 2;
    portmod_pm8x50_capability->num_vcos = 3;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_capability_t_validate(int unit, const portmod_pm_capability_t* portmod_pm_capability)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_capability == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, portmod_pm_capability->type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("type validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_capability_t_init(int unit, portmod_pm_capability_t* portmod_pm_capability)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_capability == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_capability NULL parameter"));
    }
    sal_memset(portmod_pm_capability, 0, sizeof(portmod_pm_capability_t));
    portmod_pm_capability->type = portmodDispatchTypeCount;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_vco_setting_t_validate(int unit, const portmod_pm_vco_setting_t* portmod_pm_vco_setting)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_pm_vco_setting == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_speed_config_t_validate(unit, portmod_pm_vco_setting->speed_config_list)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("speed_config_list validation failed"));
    }

    if(SOC_E_NONE != portmod_vco_type_t_validate(unit, portmod_pm_vco_setting->tvco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tvco validation failed"));
    }

    if(SOC_E_NONE != portmod_vco_type_t_validate(unit, portmod_pm_vco_setting->ovco)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ovco validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_vco_setting_t_init(int unit, portmod_pm_vco_setting_t* portmod_pm_vco_setting)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_pm_vco_setting == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_pm_vco_setting NULL parameter"));
    }
    sal_memset(portmod_pm_vco_setting, 0, sizeof(portmod_pm_vco_setting_t));
    portmod_pm_vco_setting->tvco = portmodVCOInvalid;
    portmod_pm_vco_setting->ovco = portmodVCOInvalid;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_pm_speed_config_validate(int unit, int pm_id, const portmod_pbmp_t* ports, int flag, portmod_pm_vco_setting_t* vco_setting)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(vco_setting == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vco_setting NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pm_vco_setting_t_validate(unit, vco_setting)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vco_setting validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_speed_config_validate) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_speed_config_validate(unit, pm_id, pm_info, ports, flag, vco_setting);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_speed_config_validate isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_vcos_get(int unit, portmod_dispatch_type_t pm_type, uint32 flags, portmod_pm_vco_setting_t* vco_select)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_dispatch_type_t_validate(unit, pm_type)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm_type validation failed"));
    }

    if(vco_select == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vco_select NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pm_vco_setting_t_validate(unit, vco_select)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vco_select validation failed"));
    }

    /* Dispatch */
    __type__ = (pm_type);
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_vcos_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_vcos_get(unit, pm_type, flags, vco_select);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_vcos_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_specific_vcos_get(int unit, const portmod_pm_capability_t* pm_cap, portmod_pm_vco_setting_t* vco_select)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_pm_capability_t_validate(unit, pm_cap)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pm_cap validation failed"));
    }

    if(vco_select == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vco_select NULL parameter"));
    }
    if(SOC_E_NONE != portmod_pm_vco_setting_t_init(unit, vco_select)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("vco_select initialization failed"));
    }

    /* Dispatch */
    __type__ = (pm_cap)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_specific_vcos_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_specific_vcos_get(unit, pm_cap, vco_select);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_specific_vcos_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_ability_advert_set(int unit, int port, int num_abilities, const portmod_port_speed_ability_t* abilities)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_speed_ability_t_validate(unit, abilities)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("abilities validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_ability_advert_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_ability_advert_set(unit, port, pm_info, num_abilities, abilities);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_ability_advert_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_ability_advert_get(int unit, int port, int max_num_abilities, portmod_port_speed_ability_t* abilities, int* actual_num_abilities)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(abilities == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("abilities NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_speed_ability_t_init(unit, abilities)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("abilities initialization failed"));
    }

    if(actual_num_abilities == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("actual_num_abilities NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_ability_advert_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_ability_advert_get(unit, port, pm_info, max_num_abilities, abilities, actual_num_abilities);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_ability_advert_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_autoneg_ability_remote_get(int unit, int port, int max_num_abilities, portmod_port_speed_ability_t* abilities, int* actual_num_abilities)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(abilities == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("abilities NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_speed_ability_t_init(unit, abilities)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("abilities initialization failed"));
    }

    if(actual_num_abilities == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("actual_num_abilities NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_autoneg_ability_remote_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_autoneg_ability_remote_get(unit, port, pm_info, max_num_abilities, abilities, actual_num_abilities);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_autoneg_ability_remote_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_interrupt_link_status_get(int unit, int port, const int* is_link_intr_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_interrupt_link_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_interrupt_link_status_get(unit, port, pm_info, is_link_intr_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_interrupt_link_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_cpri_port_intr_info_t_validate(int unit, const portmod_cpri_port_intr_info_t* portmod_cpri_port_intr_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_port_intr_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_cpri_port_intr_info_t_init(int unit, portmod_cpri_port_intr_info_t* portmod_cpri_port_intr_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_port_intr_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_port_intr_info NULL parameter"));
    }
    sal_memset(portmod_cpri_port_intr_info, 0, sizeof(portmod_cpri_port_intr_info_t));
    portmod_cpri_port_intr_info->cpri_intr_type = _shrCpriIntrCount;

        
exit:
    SOC_FUNC_RETURN; 
    
}

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_interrupt_enable_set(int unit, int port, portmod_cpri_port_intr_type_t cpri_intr_type, int data, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_interrupt_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_interrupt_enable_set(unit, port, pm_info, cpri_intr_type, data, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_interrupt_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_interrupt_enable_get(int unit, int port, portmod_cpri_port_intr_type_t cpri_intr_type, int data, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_interrupt_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_interrupt_enable_get(unit, port, pm_info, cpri_intr_type, data, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_interrupt_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_pm_interrupt_process(int unit, int pm_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_pm_interrupt_process) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_pm_interrupt_process(unit, pm_id, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_pm_interrupt_process isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_fast_clk_bit_time_period_set(int unit, int port, uint32 bit_time_period)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_fast_clk_bit_time_period_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_fast_clk_bit_time_period_set(unit, port, pm_info, bit_time_period);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_fast_clk_bit_time_period_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_fast_clk_bit_time_period_get(int unit, int port, uint32* bit_time_period)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bit_time_period == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bit_time_period NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_fast_clk_bit_time_period_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_fast_clk_bit_time_period_get(unit, port, pm_info, bit_time_period);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_fast_clk_bit_time_period_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_bit_time_period_set(int unit, int port, portmod_direction_t direction, cprimod_port_speed_t speed)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_bit_time_period_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_bit_time_period_set(unit, port, pm_info, direction, speed);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_bit_time_period_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_bit_time_period_get(int unit, int port, portmod_direction_t direction, uint32* bit_time_period)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(bit_time_period == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bit_time_period NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_bit_time_period_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_bit_time_period_get(unit, port, pm_info, direction, bit_time_period);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_bit_time_period_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_capture_config_set(int unit, int port, portmod_direction_t direction, const cprimod_1588_capture_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_capture_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_capture_config_set(unit, port, pm_info, direction, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_capture_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_capture_config_get(int unit, int port, portmod_direction_t direction, cprimod_1588_capture_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_capture_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_capture_config_get(unit, port, pm_info, direction, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_capture_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_captured_timestamp_get(int unit, int port, portmod_direction_t direction, portmod_1588_ts_type_t ts_type, uint8 mx_cnt, uint8* count, uint64* captured_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(count == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("count NULL parameter"));
    }
    if(captured_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("captured_time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_captured_timestamp_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_captured_timestamp_get(unit, port, pm_info, direction, ts_type, mx_cnt, count, captured_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_captured_timestamp_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_adjust_set(int unit, int port, portmod_direction_t direction, const cprimod_1588_time_t* adjust_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_adjust_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_adjust_set(unit, port, pm_info, direction, adjust_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_adjust_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_adjust_get(int unit, int port, portmod_direction_t direction, cprimod_1588_time_t* adjust_time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(adjust_time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("adjust_time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_adjust_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_adjust_get(unit, port, pm_info, direction, adjust_time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_adjust_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_fifo_config_set(int unit, int port, portmod_direction_t direction, uint16 modulo)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_fifo_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_fifo_config_set(unit, port, pm_info, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_fifo_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_fifo_config_get(int unit, int port, portmod_direction_t direction, uint16* modulo)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(modulo == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_fifo_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_fifo_config_get(unit, port, pm_info, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_fifo_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_cmic_config_set(int unit, int port, portmod_direction_t direction, uint16 modulo)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_cmic_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_cmic_config_set(unit, port, pm_info, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_cmic_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_1588_timestamp_cmic_config_get(int unit, int port, portmod_direction_t direction, uint16* modulo)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(modulo == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("modulo NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_cmic_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_1588_timestamp_cmic_config_get(unit, port, pm_info, direction, modulo);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_1588_timestamp_cmic_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_port_tx_set(int unit, int port, const phymod_tx_t* tx)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_set(unit, port, pm_info, tx);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_get(int unit, int port, phymod_tx_t* tx)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(tx == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("tx NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_get(unit, port, pm_info, tx);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_synce_clk_ctrl_t_validate(int unit, const portmod_port_synce_clk_ctrl_t* portmod_port_synce_clk_ctrl)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_synce_clk_ctrl == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_synce_clk_ctrl_t_init(int unit, portmod_port_synce_clk_ctrl_t* portmod_port_synce_clk_ctrl)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_synce_clk_ctrl == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_synce_clk_ctrl NULL parameter"));
    }
    sal_memset(portmod_port_synce_clk_ctrl, 0, sizeof(portmod_port_synce_clk_ctrl_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_synce_clk_ctrl_set(int unit, int port, const portmod_port_synce_clk_ctrl_t* cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_synce_clk_ctrl_t_validate(unit, cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cfg validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_synce_clk_ctrl_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_synce_clk_ctrl_set(unit, port, pm_info, cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_synce_clk_ctrl_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_synce_clk_ctrl_get(int unit, int port, portmod_port_synce_clk_ctrl_t* cfg)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(cfg == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cfg NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_synce_clk_ctrl_t_init(unit, cfg)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("cfg initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_synce_clk_ctrl_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_synce_clk_ctrl_get(unit, port, pm_info, cfg);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_synce_clk_ctrl_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_agnostic_config_info_t_validate(int unit, const portmod_cpri_rx_agnostic_config_info_t* portmod_cpri_rx_agnostic_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_rx_agnostic_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_agnostic_config_info_t_init(int unit, portmod_cpri_rx_agnostic_config_info_t* portmod_cpri_rx_agnostic_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_rx_agnostic_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_rx_agnostic_config_info NULL parameter"));
    }
    sal_memset(portmod_cpri_rx_agnostic_config_info, 0, sizeof(portmod_cpri_rx_agnostic_config_info_t));
    portmod_cpri_rx_agnostic_config_info->sync_mode = PORTMOD_CPRI_FRAME_SYNC_MODE_BASIC;
    portmod_cpri_rx_agnostic_config_info->basic_frame_offset = 0;
    portmod_cpri_rx_agnostic_config_info->hyper_frame_offset = 0;
    portmod_cpri_rx_agnostic_config_info->radio_frame_offset = 0;
    portmod_cpri_rx_agnostic_config_info->payload_multiple = PORTMOD_CPRI_PAYLOAD_MULTIPLE_1X;
    portmod_cpri_rx_agnostic_config_info->pres_mod_count = 0;
    portmod_cpri_rx_agnostic_config_info->ordering_info_option = PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_TIMESTAMP;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_agnostic_config_set(int unit, int port, int enable, const portmod_cpri_rx_agnostic_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_rx_agnostic_config_info_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_agnostic_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_agnostic_config_set(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_agnostic_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_agnostic_config_get(int unit, int port, int* enable, portmod_cpri_rx_agnostic_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_rx_agnostic_config_info_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_agnostic_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_agnostic_config_get(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_agnostic_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_agnostic_config_info_t_validate(int unit, const portmod_cpri_tx_agnostic_config_info_t* portmod_cpri_tx_agnostic_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_tx_agnostic_config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_agnostic_config_info_t_init(int unit, portmod_cpri_tx_agnostic_config_info_t* portmod_cpri_tx_agnostic_config_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_tx_agnostic_config_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_tx_agnostic_config_info NULL parameter"));
    }
    sal_memset(portmod_cpri_tx_agnostic_config_info, 0, sizeof(portmod_cpri_tx_agnostic_config_info_t));
    portmod_cpri_tx_agnostic_config_info->sync_mode = PORTMOD_CPRI_FRAME_SYNC_MODE_BASIC;
    portmod_cpri_tx_agnostic_config_info->basic_frame_offset = 0;
    portmod_cpri_tx_agnostic_config_info->hyper_frame_offset = 0;
    portmod_cpri_tx_agnostic_config_info->radio_frame_offset = 0;
    portmod_cpri_tx_agnostic_config_info->payload_multiple = PORTMOD_CPRI_PAYLOAD_MULTIPLE_1X;
    portmod_cpri_tx_agnostic_config_info->queue_mod_count = 0;
    portmod_cpri_tx_agnostic_config_info->pres_mod_count = 0;
    portmod_cpri_tx_agnostic_config_info->pres_mod_offset = 0;
    portmod_cpri_tx_agnostic_config_info->ordering_info_option = PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_TIMESTAMP;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_agnostic_config_set(int unit, int port, int enable, const portmod_cpri_tx_agnostic_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_tx_agnostic_config_info_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_agnostic_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_agnostic_config_set(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_agnostic_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_agnostic_config_get(int unit, int port, int* enable, portmod_cpri_tx_agnostic_config_info_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_tx_agnostic_config_info_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_agnostic_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_agnostic_config_get(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_agnostic_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_presentation_time_config_set(int unit, int port, portmod_presentation_time_attribute_t attribute, const portmod_presentation_time_t* time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_presentation_time_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_presentation_time_config_set(unit, port, pm_info, attribute, time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_presentation_time_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_encap_presentation_time_config_get(int unit, int port, portmod_presentation_time_attribute_t attribute, portmod_presentation_time_t* time)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(time == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("time NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_presentation_time_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_encap_presentation_time_config_get(unit, port, pm_info, attribute, time);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_encap_presentation_time_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_presentation_time_config_set(int unit, int port, const portmod_decap_presentation_time_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_presentation_time_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_presentation_time_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_presentation_time_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_presentation_time_config_get(int unit, int port, portmod_decap_presentation_time_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_presentation_time_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_presentation_time_config_get(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_presentation_time_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_lookup_table_set(int unit, int port, int table_depth, const uint32* table)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_lookup_table_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_lookup_table_set(unit, port, pm_info, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_compression_lookup_table_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_lookup_table_get(int unit, int port, int max_depth, int* table_depth, uint32* table)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(table_depth == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table_depth NULL parameter"));
    }
    if(table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_lookup_table_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_lookup_table_get(unit, port, pm_info, max_depth, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_compression_lookup_table_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_lookup_table_set(int unit, int port, int table_depth, const uint32* table)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_lookup_table_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_lookup_table_set(unit, port, pm_info, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decompression_lookup_table_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_lookup_table_get(int unit, int port, int max_depth, int* table_depth, uint32* table)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(table_depth == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table_depth NULL parameter"));
    }
    if(table == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("table NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_lookup_table_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_lookup_table_get(unit, port, pm_info, max_depth, table_depth, table);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decompression_lookup_table_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_flow_control_set(int unit, int port, uint32 queue_num, int enable, uint32_t xon_threshold, uint32_t xoff_threshold)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_flow_control_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_flow_control_set(unit, port, pm_info, queue_num, enable, xon_threshold, xoff_threshold);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_queue_flow_control_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decap_queue_flow_control_get(int unit, int port, uint32 queue_num, int* enable, uint32_t* xon_threshold, uint32_t* xoff_threshold)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(xon_threshold == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("xon_threshold NULL parameter"));
    }
    if(xoff_threshold == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("xoff_threshold NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_flow_control_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decap_queue_flow_control_get(unit, port, pm_info, queue_num, enable, xon_threshold, xoff_threshold);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decap_queue_flow_control_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_fec_timestamp_config_t_validate(int unit, const portmod_fec_timestamp_config_t* portmod_fec_timestamp_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_fec_timestamp_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_fec_timestamp_config_t_init(int unit, portmod_fec_timestamp_config_t* portmod_fec_timestamp_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_fec_timestamp_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_fec_timestamp_config NULL parameter"));
    }
    sal_memset(portmod_fec_timestamp_config, 0, sizeof(portmod_fec_timestamp_config_t));
    portmod_fec_timestamp_config->enable = 0;
    portmod_fec_timestamp_config->fec_fifo_ts_source_select = 1;
    portmod_fec_timestamp_config->fec_cmic_ts_source_select = 0;
    portmod_fec_timestamp_config->control_bit_offset_0 = 0;
    portmod_fec_timestamp_config->control_bit_offset_1 = 0x45;
    portmod_fec_timestamp_config->control_bit_offset_2 = 0x85;
    portmod_fec_timestamp_config->control_bit_offset_3 = 0xc5;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_enable_set(int unit, int port, portmod_direction_t dir, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_enable_set(unit, port, pm_info, dir, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_fec_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_enable_get(int unit, int port, portmod_direction_t dir, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_enable_get(unit, port, pm_info, dir, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_fec_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_timestamp_config_set(int unit, int port, portmod_direction_t dir, const portmod_fec_timestamp_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_fec_timestamp_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_timestamp_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_timestamp_config_set(unit, port, pm_info, dir, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_fec_timestamp_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_timestamp_config_get(int unit, int port, portmod_direction_t dir, portmod_fec_timestamp_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_fec_timestamp_config_t_init(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_timestamp_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_timestamp_config_get(unit, port, pm_info, dir, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_fec_timestamp_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_aux_config_set(int unit, int port, portmod_fec_aux_config_para_t parameter_id, uint32 value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_aux_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_aux_config_set(unit, port, pm_info, parameter_id, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_fec_aux_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_aux_config_get(int unit, int port, portmod_fec_aux_config_para_t parameter_id, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_aux_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_aux_config_get(unit, port, pm_info, parameter_id, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_fec_aux_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_fec_stat_get(int unit, int port, portmod_cpri_fec_stat_type_t stat_type, uint32* value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_stat_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_fec_stat_get(unit, port, pm_info, stat_type, value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_fec_stat_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_ecc_intr_info_t_validate(int unit, const portmod_ecc_intr_info_t* portmod_ecc_intr_info)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_ecc_intr_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_ecc_intr_info_t_init(int unit, portmod_ecc_intr_info_t* portmod_ecc_intr_info)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_ecc_intr_info == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_ecc_intr_info NULL parameter"));
    }
    sal_memset(portmod_ecc_intr_info, 0, sizeof(portmod_ecc_intr_info_t));
    portmod_ecc_intr_info->port = 0;
    portmod_ecc_intr_info->err_mem_info = INVALIDm;
    portmod_ecc_intr_info->ecc_reg_info = 0;
    portmod_ecc_intr_info->ecc_num_bits_err = 0;
    portmod_ecc_intr_info->err_addr = 0;
    portmod_ecc_intr_info->mem_str = NULL;

        
exit:
    SOC_FUNC_RETURN; 
    
}

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_ecc_interrupt_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_ecc_interrupt_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_ecc_interrupt_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_ecc_interrupt_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_pm_ecc_interrupt_status_get(int unit, int pm_id, portmod_cpri_ecc_intr_info_t* ecc_err_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ecc_err_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ecc_err_info NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_pm_ecc_interrupt_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_pm_ecc_interrupt_status_get(unit, pm_id, pm_info, ecc_err_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_pm_ecc_interrupt_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_init(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_init) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_init(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_init isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_gcw_word_get(int unit, int port, int group_index, uint16* gcw_word)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(gcw_word == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("gcw_word NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_gcw_word_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_gcw_word_get(unit, port, pm_info, group_index, gcw_word);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_gcw_word_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_gcw_word_set(int unit, int port, int group_index, uint16 gcw_word)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_word_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_gcw_word_set(unit, port, pm_info, group_index, gcw_word);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_gcw_word_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_pm_interrupt_process(int unit, int pm_id, portmod_ecc_intr_info_t* ecc_err_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(ecc_err_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ecc_err_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_ecc_intr_info_t_init(unit, ecc_err_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("ecc_err_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_pm_id_pm_type_get(unit, pm_id, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_interrupt_process) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_from_pm_id_get(unit, pm_id, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_interrupt_process(unit, pm_id, pm_info, ecc_err_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_interrupt_process isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_core_num_get(int unit, pm_info_t pm_info, int* core_num)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(core_num == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("core_num NULL parameter"));
    }
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_core_num_get) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_core_num_get(unit, pm_info, core_num);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_core_num_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rlm_config_t_validate(int unit, const portmod_port_rlm_config_t* portmod_port_rlm_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_rlm_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_rlm_config_t_init(int unit, portmod_port_rlm_config_t* portmod_port_rlm_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_rlm_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_rlm_config NULL parameter"));
    }
    sal_memset(portmod_port_rlm_config, 0, sizeof(portmod_port_rlm_config_t));

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_rlm_config_set(int unit, int port, int enable, const portmod_port_rlm_config_t* rlm_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_port_rlm_config_t_validate(unit, rlm_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rlm_config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rlm_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rlm_config_set(unit, port, pm_info, enable, rlm_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rlm_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rlm_config_get(int unit, int port, int* enable, portmod_port_rlm_config_t* rlm_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(rlm_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rlm_status NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_rlm_config_t_init(unit, rlm_status)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rlm_status initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rlm_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rlm_config_get(unit, port, pm_info, enable, rlm_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rlm_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_rlm_status_t_validate(int unit, const portmod_port_rlm_status_t* portmod_port_rlm_status)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_port_rlm_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_rlm_status_t_init(int unit, portmod_port_rlm_status_t* portmod_port_rlm_status)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_port_rlm_status == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_port_rlm_status NULL parameter"));
    }
    sal_memset(portmod_port_rlm_status, 0, sizeof(portmod_port_rlm_status_t));
    portmod_port_rlm_status->rlm_disabled = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_port_rlm_status_get(int unit, int port, portmod_port_rlm_status_t* rlm_status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(rlm_status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rlm_status NULL parameter"));
    }
    if(SOC_E_NONE != portmod_port_rlm_status_t_init(unit, rlm_status)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rlm_status initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_rlm_status_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_rlm_status_get(unit, port, pm_info, rlm_status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_rlm_status_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_tunnel_mode_config_t_validate(int unit, const portmod_cpri_rx_tunnel_mode_config_t* portmod_cpri_rx_tunnel_mode_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_rx_tunnel_mode_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_rx_tunnel_mode_config_t_init(int unit, portmod_cpri_rx_tunnel_mode_config_t* portmod_cpri_rx_tunnel_mode_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_rx_tunnel_mode_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_rx_tunnel_mode_config NULL parameter"));
    }
    sal_memset(portmod_cpri_rx_tunnel_mode_config, 0, sizeof(portmod_cpri_rx_tunnel_mode_config_t));
    portmod_cpri_rx_tunnel_mode_config->payload_size = 0;
    portmod_cpri_rx_tunnel_mode_config->pres_mod_count = 0;
    portmod_cpri_rx_tunnel_mode_config->ordering_info_option = PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_TIMESTAMP;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_tunnel_mode_config_set(int unit, int port, int enable, const portmod_cpri_rx_tunnel_mode_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_rx_tunnel_mode_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_tunnel_mode_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_tunnel_mode_config_set(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_tunnel_mode_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_tunnel_mode_config_get(int unit, int port, int* enable, portmod_cpri_rx_tunnel_mode_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_rx_tunnel_mode_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_tunnel_mode_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_tunnel_mode_config_get(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_tunnel_mode_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_tunnel_mode_config_t_validate(int unit, const portmod_cpri_tx_tunnel_mode_config_t* portmod_cpri_tx_tunnel_mode_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_tx_tunnel_mode_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_tx_tunnel_mode_config_t_init(int unit, portmod_cpri_tx_tunnel_mode_config_t* portmod_cpri_tx_tunnel_mode_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_tx_tunnel_mode_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_tx_tunnel_mode_config NULL parameter"));
    }
    sal_memset(portmod_cpri_tx_tunnel_mode_config, 0, sizeof(portmod_cpri_tx_tunnel_mode_config_t));
    portmod_cpri_tx_tunnel_mode_config->payload_size = 0;
    portmod_cpri_tx_tunnel_mode_config->queue_mod_count = 0;
    portmod_cpri_tx_tunnel_mode_config->pres_mod_count = 0;
    portmod_cpri_tx_tunnel_mode_config->pres_mod_offset = 0;
    portmod_cpri_tx_tunnel_mode_config->ordering_info_option = PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_TIMESTAMP;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_tunnel_mode_config_set(int unit, int port, int enable, const portmod_cpri_tx_tunnel_mode_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_tx_tunnel_mode_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_tunnel_mode_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_tunnel_mode_config_set(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_tunnel_mode_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_tunnel_mode_config_get(int unit, int port, int* enable, portmod_cpri_tx_tunnel_mode_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_cpri_tx_tunnel_mode_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_tunnel_mode_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_tunnel_mode_config_get(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_tunnel_mode_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_agnostic_config_t_validate(int unit, const portmod_rsvd4_rx_agnostic_config_t* portmod_rsvd4_rx_agnostic_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rsvd4_rx_agnostic_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_rx_agnostic_config_t_init(int unit, portmod_rsvd4_rx_agnostic_config_t* portmod_rsvd4_rx_agnostic_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rsvd4_rx_agnostic_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rsvd4_rx_agnostic_config NULL parameter"));
    }
    sal_memset(portmod_rsvd4_rx_agnostic_config, 0, sizeof(portmod_rsvd4_rx_agnostic_config_t));
    portmod_rsvd4_rx_agnostic_config->payload_multiple = 0;
    portmod_rsvd4_rx_agnostic_config->pres_mod_count = 0;
    portmod_rsvd4_rx_agnostic_config->ordering_info_option = PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_TIMESTAMP;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_rx_agnostic_config_set(int unit, int port, int enable, const portmod_rsvd4_rx_agnostic_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rsvd4_rx_agnostic_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_rx_agnostic_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_rx_agnostic_config_set(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_port_rx_agnostic_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_rx_agnostic_config_get(int unit, int port, int* enable, portmod_rsvd4_rx_agnostic_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_rsvd4_rx_agnostic_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_rx_agnostic_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_rx_agnostic_config_get(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_port_rx_agnostic_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_agnostic_config_t_validate(int unit, const portmod_rsvd4_tx_agnostic_config_t* portmod_rsvd4_tx_agnostic_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_rsvd4_tx_agnostic_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_tx_agnostic_config_t_init(int unit, portmod_rsvd4_tx_agnostic_config_t* portmod_rsvd4_tx_agnostic_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_rsvd4_tx_agnostic_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_rsvd4_tx_agnostic_config NULL parameter"));
    }
    sal_memset(portmod_rsvd4_tx_agnostic_config, 0, sizeof(portmod_rsvd4_tx_agnostic_config_t));
    portmod_rsvd4_tx_agnostic_config->payload_multiple = 0;
    portmod_rsvd4_tx_agnostic_config->queue_mod_count = 0;
    portmod_rsvd4_tx_agnostic_config->pres_mod_count = 0;
    portmod_rsvd4_tx_agnostic_config->pres_mod_offset = 0;
    portmod_rsvd4_tx_agnostic_config->ordering_info_option = PORTMOD_CPRI_ROE_ORDERING_INFO_OPTION_TIMESTAMP;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_tx_agnostic_config_set(int unit, int port, int enable, const portmod_rsvd4_tx_agnostic_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_rsvd4_tx_agnostic_config_t_validate(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_tx_agnostic_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_tx_agnostic_config_set(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_port_tx_agnostic_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_rsvd4_port_tx_agnostic_config_get(int unit, int port, int* enable, portmod_rsvd4_tx_agnostic_config_t* config_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    if(config_info == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info NULL parameter"));
    }
    if(SOC_E_NONE != portmod_rsvd4_tx_agnostic_config_t_init(unit, config_info)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config_info initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_tx_agnostic_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_rsvd4_port_tx_agnostic_config_get(unit, port, pm_info, enable, config_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_rsvd4_port_tx_agnostic_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_frame_config_t_validate(int unit, const portmod_cpri_port_frame_config_t* portmod_cpri_port_frame_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_cpri_port_frame_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_frame_config_t_init(int unit, portmod_cpri_port_frame_config_t* portmod_cpri_port_frame_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_cpri_port_frame_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_cpri_port_frame_config NULL parameter"));
    }
    sal_memset(portmod_cpri_port_frame_config, 0, sizeof(portmod_cpri_port_frame_config_t));
    portmod_cpri_port_frame_config->frame_type = PORTMOD_CPRI_ROE_FRAME_FORMAT_IEEE1914;
    portmod_cpri_port_frame_config->decap_primary_key = PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_0;
    portmod_cpri_port_frame_config->decap_secondary_key = PORTMOD_CPRI_ECPRI_HEADER_FIELD_BYTE_1;

        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */

#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_frame_config_set(int unit, int port, const portmod_cpri_port_frame_config_t* config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_cpri_port_frame_config_t_validate(unit, config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_frame_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_frame_config_set(unit, port, pm_info, config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_frame_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_saturation_config_set(int unit, int port, uint32 threshold_value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_saturation_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_saturation_config_set(unit, port, pm_info, threshold_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_compression_saturation_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_compression_saturation_config_get(int unit, int port, uint32* threshold_value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(threshold_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("threshold_value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_saturation_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_compression_saturation_config_get(unit, port, pm_info, threshold_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_compression_saturation_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_saturation_config_set(int unit, int port, uint32 sat_value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_saturation_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_saturation_config_set(unit, port, pm_info, sat_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decompression_saturation_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_decompression_saturation_config_get(int unit, int port, uint32* sat_value)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(sat_value == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("sat_value NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_saturation_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_decompression_saturation_config_get(unit, port, pm_info, sat_value);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_decompression_saturation_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_port_mac_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    switch(enable) {
        case 0:
        case 1:
            break;
        default:
            _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable not allowed value"));
            break;
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_mac_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_mac_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_mac_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pcs_fsm_check(int unit, int port, int* status)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(status == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("status NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pcs_fsm_check) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pcs_fsm_check(unit, port, pm_info, status);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pcs_fsm_check isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_txpi_rxcdr_clk_get(int unit, int port, uint32* txpi_clk, uint32* rxcdr_clk)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(txpi_clk == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("txpi_clk NULL parameter"));
    }
    if(rxcdr_clk == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("rxcdr_clk NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_txpi_rxcdr_clk_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_txpi_rxcdr_clk_get(unit, port, pm_info, txpi_clk, rxcdr_clk);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_txpi_rxcdr_clk_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_timestamp_mode_t_validate(int unit, portmod_timestamp_mode_t portmod_timestamp_mode)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_timestamp_mode >= portmodTimestampModeCount) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Parameter is out of range"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_egr_1588_timestamp_config_t_validate(int unit, const portmod_egr_1588_timestamp_config_t* portmod_egr_1588_timestamp_config)
{        
    SOC_INIT_FUNC_DEFS;
    if(portmod_egr_1588_timestamp_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("NULL parameter"));
    }

    if(SOC_E_NONE != portmod_timestamp_mode_t_validate(unit, portmod_egr_1588_timestamp_config->timestamp_mode)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("timestamp_mode validation failed"));
    }


        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_egr_1588_timestamp_config_t_init(int unit, portmod_egr_1588_timestamp_config_t* portmod_egr_1588_timestamp_config)
{        
    SOC_INIT_FUNC_DEFS;
    
    if(portmod_egr_1588_timestamp_config == NULL){
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("portmod_egr_1588_timestamp_config NULL parameter"));
    }
    sal_memset(portmod_egr_1588_timestamp_config, 0, sizeof(portmod_egr_1588_timestamp_config_t));
    portmod_egr_1588_timestamp_config->timestamp_mode = 0;
    portmod_egr_1588_timestamp_config->cmic_48_overr_en = 0;

        
exit:
    SOC_FUNC_RETURN; 
    
}

int portmod_egr_1588_timestamp_config_set(int unit, int port, portmod_egr_1588_timestamp_config_t timestamp_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(SOC_E_NONE != portmod_egr_1588_timestamp_config_t_validate(unit, &timestamp_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("timestamp_config validation failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_egr_1588_timestamp_config_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_egr_1588_timestamp_config_set(unit, port, pm_info, timestamp_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_egr_1588_timestamp_config_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_egr_1588_timestamp_config_get(int unit, int port, portmod_egr_1588_timestamp_config_t* timestamp_config)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(timestamp_config == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("timestamp_config NULL parameter"));
    }
    if(SOC_E_NONE != portmod_egr_1588_timestamp_config_t_init(unit, timestamp_config)) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("timestamp_config initialization failed"));
    }

    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_egr_1588_timestamp_config_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_egr_1588_timestamp_config_get(unit, port, pm_info, timestamp_config);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_egr_1588_timestamp_config_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_rx_pipeline_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_pipeline_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_rx_pipeline_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_rx_pipeline_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_pipeline_clear(int unit, int port)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_pipeline_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_pipeline_clear(unit, port, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_pipeline_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_enable_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_enable_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_enable_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_enable_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_tx_enable_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_enable_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_tx_enable_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_tx_enable_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_port_pcs_lane_map_reconfig(int unit, int port, uint32 tx_lane_swap, uint32 rx_lane_swap)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pcs_lane_map_reconfig) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pcs_lane_map_reconfig(unit, port, pm_info, tx_lane_swap, rx_lane_swap);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pcs_lane_map_reconfig isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_pmd_lock_counter_get(int unit, int port, uint32* pmd_lock_counter_sum)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(pmd_lock_counter_sum == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("pmd_lock_counter_sum NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_pmd_lock_counter_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_pmd_lock_counter_get(unit, port, pm_info, pmd_lock_counter_sum);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_pmd_lock_counter_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_speed_set(int unit, int port, cprimod_supported_port_speed_t speed_id)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_speed_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_speed_set(unit, port, pm_info, speed_id);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_speed_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


int portmod_port_tx_stall_set(int unit, int port, int enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_stall_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_stall_set(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_stall_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_tx_stall_get(int unit, int port, int* enable)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(enable == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("enable NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_tx_stall_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_tx_stall_get(unit, port, pm_info, enable);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_tx_stall_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_pm_wb_debug_log(int unit, pm_info_t pm_info)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    __type__ = (pm_info)->type;
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_pm_wb_debug_log) {
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_pm_wb_debug_log(unit, pm_info);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_pm_wb_debug_log isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fec_error_inject_set(int unit, int port, uint16 error_control_map, portmod_fec_error_mask_t bit_error_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fec_error_inject_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fec_error_inject_set(unit, port, pm_info, error_control_map, bit_error_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fec_error_inject_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


int portmod_port_fec_error_inject_get(int unit, int port, uint16* error_control_map, portmod_fec_error_mask_t* bit_error_mask)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(error_control_map == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("error_control_map NULL parameter"));
    }
    if(bit_error_mask == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("bit_error_mask NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_port_fec_error_inject_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_port_fec_error_inject_get(unit, port, pm_info, error_control_map, bit_error_mask);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_port_fec_error_inject_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_debug_set(int unit, int port, portmod_cpri_debug_attr_t type, int index, int buffer_size, const uint32* data)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_debug_set) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_debug_set(unit, port, pm_info, type, index, buffer_size, data);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_debug_set isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_debug_get(int unit, int port, portmod_cpri_debug_attr_t type, int index, int buffer_size, uint32* data)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    if(data == NULL) {
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("data NULL parameter"));
    }
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_debug_get) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_debug_get(unit, port, pm_info, type, index, buffer_size, data);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_debug_get isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */


#ifdef CPRIMOD_SUPPORT
int portmod_cpri_port_debug_clear(int unit, int port, portmod_cpri_debug_attr_t type, int index)
{

    portmod_dispatch_type_t __type__;
    int __rv__;        
    SOC_INIT_FUNC_DEFS;
    
    /* Dispatch */
    _SOC_IF_ERR_EXIT(portmod_port_pm_type_get(unit, port, &port, &__type__));
    if(__type__ >= portmodDispatchTypeCount) { 
        _SOC_EXIT_WITH_ERR(SOC_E_PARAM, ("Driver is out of range"));
    }

    if(NULL != __portmod__dispatch__[__type__]->f_portmod_cpri_port_debug_clear) {
        pm_info_t pm_info;
        _SOC_IF_ERR_EXIT(portmod_pm_info_get(unit, port, &pm_info));
        __rv__ = __portmod__dispatch__[__type__]->f_portmod_cpri_port_debug_clear(unit, port, pm_info, type, index);
        _SOC_IF_ERR_EXIT(__rv__);
    } else { 
        _SOC_EXIT_WITH_ERR(SOC_E_UNAVAIL, ("portmod_cpri_port_debug_clear isn't implemented for driver type"));
    }
        
exit:
    SOC_FUNC_RETURN; 
    
}
#endif /* CPRIMOD_SUPPORT */



#undef _ERR_MSG_MODULE_NAME
