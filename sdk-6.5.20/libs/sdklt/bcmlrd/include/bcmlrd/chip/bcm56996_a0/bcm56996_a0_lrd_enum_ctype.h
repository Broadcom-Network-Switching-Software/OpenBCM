/*******************************************************************************
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated by fltg from Logical Table definition files.
 *
 * Tool: $SDK/INTERNAL/fltg/bin/fltg
 *
 * Edits to this file will be lost when it is regenerated.
 *
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 */
#ifndef BCM56996_A0_LRD_ENUM_CTYPE_H
#define BCM56996_A0_LRD_ENUM_CTYPE_H
#ifndef DOXYGEN_IGNORE_AUTOGEN

/*! enum type for ALPM_COMP_KEY_TYPE_T
 * ALPM compression key type.
 */
typedef enum bcm56996_a0_lrd_alpm_comp_key_type_t_e {
    /*! Compression key is L4_PORT + IP, L4_PORT_MASK could be all 1 or 0.  */
    BCM56996_A0_LRD_ALPM_COMP_KEY_TYPE_T_T_ALPM_COMP_KEY_L4_PORT = 0,
    /*! Compression key is VRF + IP, VRF_MASK could be all 1 or 0.  */
    BCM56996_A0_LRD_ALPM_COMP_KEY_TYPE_T_T_ALPM_COMP_KEY_VRF = 1,
    /*! Compression key includes all fields, non-IP mask must be all 1.  */
    BCM56996_A0_LRD_ALPM_COMP_KEY_TYPE_T_T_ALPM_COMP_KEY_FULL = 2,
} bcm56996_a0_lrd_alpm_comp_key_type_t_t;

/*! enum type for ALPM_CONTROL_STATE_T
 * ALPM control table state.
 */
typedef enum bcm56996_a0_lrd_alpm_control_state_t_e {
    /*! Valid.  */
    BCM56996_A0_LRD_ALPM_CONTROL_STATE_T_T_VALID = 0,
    /*! Conflicting ALPM banks.  */
    BCM56996_A0_LRD_ALPM_CONTROL_STATE_T_T_CONFLICTING_ALPM_BANKS = 1,
} bcm56996_a0_lrd_alpm_control_state_t_t;

/*! enum type for ALPM_DB_T
 * ALPM database.
 */
typedef enum bcm56996_a0_lrd_alpm_db_t_e {
    /*! ALPM database 0  */
    BCM56996_A0_LRD_ALPM_DB_T_T_ALPM_DB_0 = 0,
    /*! ALPM database 1  */
    BCM56996_A0_LRD_ALPM_DB_T_T_ALPM_DB_1 = 1,
    /*! ALPM database 2  */
    BCM56996_A0_LRD_ALPM_DB_T_T_ALPM_DB_2 = 2,
    /*! ALPM database 3  */
    BCM56996_A0_LRD_ALPM_DB_T_T_ALPM_DB_3 = 3,
} bcm56996_a0_lrd_alpm_db_t_t;

/*! enum type for ALPM_HIT_MODE_T
 * ALPM hit support mode.
 */
typedef enum bcm56996_a0_lrd_alpm_hit_mode_t_e {
    /*! Disable ALPM hit support.  */
    BCM56996_A0_LRD_ALPM_HIT_MODE_T_T_ALPM_HIT_MODE_DISABLE = 0,
    /*! Enable ALPM hit support, and force clear to hit bits of moving entries.  */
    BCM56996_A0_LRD_ALPM_HIT_MODE_T_T_ALPM_HIT_MODE_FORCE_CLEAR = 1,
    /*! Enable ALPM hit support, and force set to hit bits of moving entries.  */
    BCM56996_A0_LRD_ALPM_HIT_MODE_T_T_ALPM_HIT_MODE_FORCE_SET = 2,
} bcm56996_a0_lrd_alpm_hit_mode_t_t;

/*! enum type for ALPM_KEY_INPUT_T
 * ALPM key input type.
 */
typedef enum bcm56996_a0_lrd_alpm_key_input_t_e {
    /*! Key input LPM destination quad wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_DST_QUAD = 0,
    /*! Key input LPM destination double wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_DST_DOUBLE = 1,
    /*! Key input LPM destination single wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_DST_SINGLE = 2,
    /*! Key input LPM source quad wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_SRC_QUAD = 3,
    /*! Key input LPM source double wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_SRC_DOUBLE = 4,
    /*! Key input LPM source single wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_SRC_SINGLE = 5,
    /*! Key input FP compression destination  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_FP_COMP_DST = 6,
    /*! Key input FP compression source  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_FP_COMP_SRC = 7,
    /*! Key input LPM L3MC quad wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_L3MC_QUAD = 8,
    /*! Key input LPM L3MC double wide  */
    BCM56996_A0_LRD_ALPM_KEY_INPUT_T_T_ALPM_KEY_INPUT_LPM_L3MC_DOUBLE = 9,
} bcm56996_a0_lrd_alpm_key_input_t_t;

/*! enum type for ALPM_KEY_TYPE_T
 * ALPM key type.
 */
typedef enum bcm56996_a0_lrd_alpm_key_type_t_e {
    /*! LPM global IPv4.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV4_UC = 0,
    /*! LPM VRF IPv4.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV4_UC_VRF = 1,
    /*! LPM global high priority IPv4.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV4_UC_OVERRIDE = 2,
    /*! LPM global IPv6 single wide.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_SINGLE = 3,
    /*! LPM VRF IPv6 single wide.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_SINGLE_VRF = 4,
    /*! LPM global high priority IPv6 single wide.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_SINGLE_OVERRIDE = 5,
    /*! LPM global IPv6 double wide.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_DOUBLE = 6,
    /*! LPM VRF IPv6 double wide.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_DOUBLE_VRF = 7,
    /*! LPM global high priority IPv6 double wide.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_DOUBLE_OVERRIDE = 8,
    /*! LPM global IPv6 quad wide.  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_QUAD = 9,
    /*! LPM VRF IPv6 quad wide  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_QUAD_VRF = 10,
    /*! LPM global high priority IPv6 quad wide  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_UC_QUAD_OVERRIDE = 11,
    /*! IPv4 compression  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV4_COMP = 12,
    /*! IPv6 compression  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_COMP = 13,
    /*! LPM IPv4 L3MC  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV4_MC = 14,
    /*! LPM IPv6 L3MC  */
    BCM56996_A0_LRD_ALPM_KEY_TYPE_T_T_KEY_L3_IPV6_MC = 15,
} bcm56996_a0_lrd_alpm_key_type_t_t;

/*! enum type for CTR_EFLEX_OBJ_SRC_T
 * Enhanced flex counter object selection options.
 */
typedef enum bcm56996_a0_lrd_ctr_eflex_obj_src_t_e {
    /*! Use the value 0.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_0 = 0,
    /*! Use the value 1.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_1 = 1,
    /*! Use object 1.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_OBJ_1 = 2,
    /*! Use object 2.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_OBJ_2 = 3,
    /*! Use object 3.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_OBJ_3 = 4,
    /*! Use object 4.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_OBJ_4 = 5,
    /*! Use trigger interval.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_TRIG_INTERVAL = 6,
    /*! Use range check result 1.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_RANGE_CHK_1 = 7,
    /*! Use range check result 2.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_RANGE_CHK_2 = 8,
    /*! Use range check result 3.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_RANGE_CHK_3 = 9,
    /*! Use range check result 4.  */
    BCM56996_A0_LRD_CTR_EFLEX_OBJ_SRC_T_T_USE_RANGE_CHK_4 = 10,
} bcm56996_a0_lrd_ctr_eflex_obj_src_t_t;

/*! enum type for CTR_EFLEX_SCALE_T
 * Enhanced flex counter time scale for a single trigger period.
 */
typedef enum bcm56996_a0_lrd_ctr_eflex_scale_t_e {
    /*! Unlimited collection.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_INFINITE = 0,
    /*! 128 nanoseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_128_NSEC = 1,
    /*! 512 nanoseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_512_NSEC = 2,
    /*! 1024 nanoseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_1024_NSEC = 3,
    /*! Approximately 8.192 microseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_8_USEC = 4,
    /*! Approximately 131 microseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_131_USEC = 5,
    /*! Approximately 1.048 milliseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_1_MSEC = 6,
    /*! Approximately 8.192 milliseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_8_MSEC = 7,
    /*! Approximately 131 milliseconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_131_MSEC = 8,
    /*! Approximately 1.07 seconds.  */
    BCM56996_A0_LRD_CTR_EFLEX_SCALE_T_T_SCALE_1_SEC = 9,
} bcm56996_a0_lrd_ctr_eflex_scale_t_t;

/*! enum type for CTR_EFLEX_STOP_TRIGGER_T
 * Enhanced flex counter stop trigger types.
 */
typedef enum bcm56996_a0_lrd_ctr_eflex_stop_trigger_t_e {
    /*! Use period as type.  */
    BCM56996_A0_LRD_CTR_EFLEX_STOP_TRIGGER_T_T_PERIOD = 0,
    /*! Use condition as type.  */
    BCM56996_A0_LRD_CTR_EFLEX_STOP_TRIGGER_T_T_CONDITION = 1,
} bcm56996_a0_lrd_ctr_eflex_stop_trigger_t_t;

/*! enum type for CTR_EFLEX_UPDATE_MODE_T
 * For specified flex counter width,
 *  CTR_ING/EGR_EFLEX_ACTION_PROFILE.MODE == NORMAL
 *  all update modes are supported.
 *
 *  CTR_ING/EGR_EFLEX_ACTION_PROFILE.MODE == WIDE
 *  only SET, INC and SETBIT update modes are supported.
 *
 *  CTR_ING/EGR_EFLEX_ACTION_PROFILE.MODE == SLIM
 *  only SET and INC update modes are supported.
 */
typedef enum bcm56996_a0_lrd_ctr_eflex_update_mode_t_e {
    /*! No change to current value.  */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_NOOP = 0,
    /*! Set to current value.  */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_SET = 1,
    /*! Increment counter value.  */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_INC = 2,
    /*!
     * Decrement counter value.
     *
     *  Applicable only if
     *  CTR_EFLEX_CONFIG.CTR_ING/EGR_EFLEX_OPERMODE_PIPEUNIQUE == 1.
     */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_DEC = 3,
    /*! Max of current and new counter values.  */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_MAX = 4,
    /*! Min of current and new counter values.  */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_MIN = 5,
    /*!
     * Exponentially weighted average value.
     *
     *  Applicable only if
     *  CTR_EFLEX_CONFIG.CTR_ING/EGR_EFLEX_OPERMODE_PIPEUNIQUE == 1.
     */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_AVG = 6,
    /*! Set the specified bit number in the new counter value.  */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_SETBIT = 7,
    /*!
     * Reverse decrement counter value.
     *
     *  Applicable only if
     *  CTR_EFLEX_CONFIG.CTR_ING/EGR_EFLEX_OPERMODE_PIPEUNIQUE == 1.
     */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_REV_DEC = 8,
    /*! Xor of current and new counter values.  */
    BCM56996_A0_LRD_CTR_EFLEX_UPDATE_MODE_T_T_XOR = 9,
} bcm56996_a0_lrd_ctr_eflex_update_mode_t_t;

/*! enum type for CTR_EGR_EFLEX_OBJ_BUS_T
 * Defines enhanced flex counter egress object bus enums.
 *  The egress source tables generate the value of these objects.
 */
typedef enum bcm56996_a0_lrd_ctr_egr_eflex_obj_bus_t_e {
    /*! Egress adapt table.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EGR_ADAPT = 0,
    /*! EFP policy table slice 0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EFP_POLICY_OBJ0 = 1,
    /*! EFP policy table slice 1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EFP_POLICY_OBJ1 = 2,
    /*! EFP policy table slice 2.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EFP_POLICY_OBJ2 = 3,
    /*! EFP policy table slice 3.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EFP_POLICY_OBJ3 = 4,
    /*! Ingress port.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_ING_PORT = 5,
    /*! Egress port.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EGR_PORT = 6,
    /*! VRF.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_VRF = 7,
    /*! Underlay L3 outgoing interface.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_L3_OIF = 8,
    /*! L3 tunnel index.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_L3_TNL_INDEX = 9,
    /*! Underlay next hop.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_NHOP = 10,
    /*! Metadata from egress NHOP table.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_NHOP_METADATA = 11,
    /*! I2E class ID.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_I2E_CLASSID = 12,
    /*! I2E class ID type.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_I2E_CLASSID_TYPE = 13,
    /*! Queue number.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_QUEUE_NUM = 14,
    /*! Residency timestamp lower.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_RESIDENCY_TIMESTAMP_LOWER = 15,
    /*! Residency timestamp upper.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_RESIDENCY_TIMESTAMP_UPPER = 16,
    /*! Egress timestamp 0-15 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EGR_TIMESTAMP_OBJ0 = 17,
    /*! Egress timestamp 16-31 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EGR_TIMESTAMP_OBJ1 = 18,
    /*! Egress timestamp 32-47 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EGR_TIMESTAMP_OBJ2 = 19,
    /*! Ingress timestamp 0-15 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_ING_TIMESTAMP_OBJ0 = 20,
    /*! Ingress timestamp 16-31 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_ING_TIMESTAMP_OBJ1 = 21,
    /*! Ingress timestamp 32-47 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_ING_TIMESTAMP_OBJ2 = 22,
    /*! Entropy label 0-15 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_ENTROPY_OBJ0 = 23,
    /*! Entropy label 16-25 bits.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_ENTROPY_OBJ1 = 24,
    /*! Egress mirror on drop event.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_EGR_MOD_EVENT = 25,
    /*! Internal congestion notification.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_INT_CN = 26,
    /*! Internal priority.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_INT_PRI = 27,
    /*! Congestion color.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_CNG = 28,
    /*! Packet attribute offset instance 0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_PKT_ATTR_OBJ0 = 29,
    /*! Packet attribute offset instance 1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_PKT_ATTR_OBJ1 = 30,
    /*! Packet attribute offset instance 2.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_PKT_ATTR_OBJ2 = 31,
    /*! Combine egress port and queue number.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_PORT_AND_QUEUE_NUM = 32,
    /*! Destination virtual port.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_DVP = 33,
    /*! Source virtual port.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_SVP = 34,
    /*! Virtual forwarding instance.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_VFI = 35,
    /*! Network group for SVP.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_SVP_NETWORK_GRP = 36,
    /*! Network group for DVP.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_DVP_NETWORK_GRP = 37,
    /*! Overlay next hop.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_OVERLAY_NHOP = 38,
    /*! Overlay L3 outgoing interface.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_OBJ_BUS_T_T_OVERLAY_L3_OIF = 39,
} bcm56996_a0_lrd_ctr_egr_eflex_obj_bus_t_t;

/*! enum type for CTR_EGR_EFLEX_PKT_ATTR_BUS_T
 * Defines enhanced flex counter egress packet attribute bus enums.
 */
typedef enum bcm56996_a0_lrd_ctr_egr_eflex_pkt_attr_bus_t_e {
    /*! CNG bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_CNG_BIT0 = 0,
    /*! CNG bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_CNG_BIT1 = 1,
    /*! Packets marked due to MMU congestion.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_CONGESTION_MARKED = 2,
    /*! Drop packets.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_DROP = 5,
    /*! Internal congestion packets bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_INT_CN_BIT0 = 7,
    /*! Internal congestion packets bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_INT_CN_BIT1 = 8,
    /*! Internal priority bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT0 = 9,
    /*! Internal priority bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT1 = 10,
    /*! Internal priority bit2.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT2 = 11,
    /*! Internal priority bit3.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT3 = 12,
    /*! IP packets.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_IP = 13,
    /*! Multicast packets.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_PKT_TYPE_MULTICAST = 14,
    /*! Packets based on bit0 of MMU_QUEUE_NUM/MMU_COS.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_MMU_QUEUE_NUM_BIT0 = 15,
    /*! Packets based on bit1 of MMU_QUEUE_NUM/MMU_COS.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_MMU_QUEUE_NUM_BIT1 = 16,
    /*! Packets based on bit2 of MMU_QUEUE_NUM/MMU_COS.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_MMU_QUEUE_NUM_BIT2 = 17,
    /*! Packets based on bit3 of MMU_QUEUE_NUM/MMU_COS.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_MMU_QUEUE_NUM_BIT3 = 18,
    /*! MPLS experimental field bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_MPLS_EXP_BIT0 = 19,
    /*! MPLS experimental field bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_MPLS_EXP_BIT1 = 20,
    /*! MPLS experimental field bit2.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_MPLS_EXP_BIT2 = 21,
    /*! Outer 802.1p priority bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_OUTER_DOT1P_BIT0 = 22,
    /*! Outer 802.1p priority bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_OUTER_DOT1P_BIT1 = 23,
    /*! Outer 802.1p priority bit2.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_OUTER_DOT1P_BIT2 = 24,
    /*! Outer VLAN tagged packets.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_VLAN_SOT = 25,
    /*! Port ID bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT0 = 26,
    /*! Port ID bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT1 = 27,
    /*! Port ID bit2.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT2 = 28,
    /*! Port ID bit3.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT3 = 29,
    /*! Port ID bit4.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT4 = 30,
    /*! Port ID bit5.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT5 = 31,
    /*! Explicit Congrestion Notification TOS bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_ECN_BIT0 = 32,
    /*! Explicit Congrestion Notification TOS bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_ECN_BIT1 = 33,
    /*! Differentiated Services TOS bit0.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT0 = 34,
    /*! Differentiated Services TOS bit1.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT1 = 35,
    /*! Differentiated Services TOS bit2.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT2 = 36,
    /*! Differentiated Services TOS bit3.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT3 = 37,
    /*! Differentiated Services TOS bit4.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT4 = 38,
    /*! Differentiated Services TOS bit5.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT5 = 39,
    /*! Packets unicast queueing.  */
    BCM56996_A0_LRD_CTR_EGR_EFLEX_PKT_ATTR_BUS_T_T_UNICAST_QUEUEING = 40,
} bcm56996_a0_lrd_ctr_egr_eflex_pkt_attr_bus_t_t;

/*! enum type for CTR_ING_EFLEX_OBJ_BUS_T
 * Defines enhanced flex counter ingress object bus enums.
 *  The ingress source tables generate the value of these objects.
 */
typedef enum bcm56996_a0_lrd_ctr_ing_eflex_obj_bus_t_e {
    /*! VFP policy table slice.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_VFP_POLICY_OBJ = 0,
    /*! IFP policy table slice 0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ0 = 1,
    /*! IFP policy table slice 1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ1 = 2,
    /*! IFP policy table slice 2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ2 = 3,
    /*! IFP policy table slice 3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ3 = 4,
    /*! IFP policy table slice 4.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ4 = 5,
    /*! IFP policy table slice 5.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ5 = 6,
    /*! IFP policy table slice 6.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ6 = 7,
    /*! IFP policy table slice 7.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ7 = 8,
    /*! IFP policy table slice 8.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IFP_POLICY_OBJ8 = 9,
    /*! Exact match policy table.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_EM_POLICY_OBJ = 10,
    /*! MPLS entry single table.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_MPLS_OBJ1 = 11,
    /*! MPLS entry double table.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_MPLS_OBJ2 = 12,
    /*! L3 tunnel.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_L3_TNL = 13,
    /*! Prefix length for flow count.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_FLOW_COUNT_PREFIX_LEN = 14,
    /*! Port context for flow count.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_FLOW_COUNT_PORT_CONTEXT = 15,
    /*! Flow size lower byte for flow count.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_FLOW_COUNT_FLOW_SIZE_LOWER = 16,
    /*! Flow size upper byte for flow count.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_FLOW_COUNT_FLOW_SIZE_UPPER = 17,
    /*! ALPM source lookup.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ALPM_SRC_LOOKUP = 18,
    /*! ALPM destination lookup.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ALPM_DST_LOOKUP = 19,
    /*! Lookup hit status.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_LOOKUP_HIT_STATUS = 20,
    /*! Ingress port.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ING_PORT = 21,
    /*! Egress port.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_EGR_PORT = 22,
    /*! Virtual forwarding instance.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_VFI = 23,
    /*! L3 IIF.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_L3_IIF = 24,
    /*! Virtual route forwarding.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_VRF = 25,
    /*! Class ID from port table.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_PORT_CLASS_ID = 26,
    /*! ECMP group.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ECMP_GROUP = 27,
    /*! ECMP member.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ECMP_MEMBER = 28,
    /*! Next hop or MC index.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_NHOP_MC_INDEX = 29,
    /*! RTAG7 subselection hash 0 and instance 0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_RTAG7_HASH_OBJ0 = 30,
    /*! RTAG7 subselection hash 0 and instance 1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_RTAG7_HASH_OBJ1 = 31,
    /*! RTAG7 subselection hash 1 and instance 0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_RTAG7_HASH_OBJ2 = 32,
    /*! RTAG7 subselection hash 1 and instance 1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_RTAG7_HASH_OBJ3 = 33,
    /*! Ingress timestamp 0-15 bits.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ING_TIMESTAMP_OBJ0 = 34,
    /*! Ingress timestamp 16-31 bits.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ING_TIMESTAMP_OBJ1 = 35,
    /*! Ingress timestamp 32-47 bits.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ING_TIMESTAMP_OBJ2 = 36,
    /*! Packet length in IP header.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IP_TOTAL_LEN = 37,
    /*! L4 flags.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_L4_FLAGS = 38,
    /*! UDF1 chunk 0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ0 = 39,
    /*! UDF1 chunk 1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ1 = 40,
    /*! UDF1 chunk 2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ2 = 41,
    /*! UDF1 chunk 3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ3 = 42,
    /*! UDF1 chunk 4.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ4 = 43,
    /*! UDF1 chunk 5.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ5 = 44,
    /*! UDF1 chunk 6.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ6 = 45,
    /*! UDF1 chunk 7.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF1_OBJ7 = 46,
    /*! UDF2 chunk 0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ0 = 47,
    /*! UDF2 chunk 1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ1 = 48,
    /*! UDF2 chunk 2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ2 = 49,
    /*! UDF2 chunk 3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ3 = 50,
    /*! UDF2 chunk 4.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ4 = 51,
    /*! UDF2 chunk 5.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ5 = 52,
    /*! UDF2 chunk 6.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ6 = 53,
    /*! UDF2 chunk 7.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_UDF2_OBJ7 = 54,
    /*! Packet attribute offset 0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_PKT_ATTR_OBJ0 = 55,
    /*! Packet attribute offset 1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_PKT_ATTR_OBJ1 = 56,
    /*! Packet attribute offset 2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_PKT_ATTR_OBJ2 = 57,
    /*! Internal priority.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_INT_PRI = 58,
    /*! Internal congestion notification.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_INT_CN = 59,
    /*! Ingress mirror on drop event.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_ING_MOD_EVENT = 60,
    /*! Trunk group.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_TRUNK_GROUP = 61,
    /*! Trunk member.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_TRUNK_MEMBER = 62,
    /*! Protocol field from IP header.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_IP_PROTOCOL = 63,
    /*! Destination virtual port.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_DVP = 64,
    /*! Source virtual port.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_SVP = 65,
    /*! Overlay ECMP group.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_OVERLAY_ECMP_GROUP = 66,
    /*! Overlay ECMP member.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_OVERLAY_ECMP_MEMBER = 67,
    /*! Overlay next hop.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_OBJ_BUS_T_T_OVERLAY_NHOP = 68,
} bcm56996_a0_lrd_ctr_ing_eflex_obj_bus_t_t;

/*! enum type for CTR_ING_EFLEX_PKT_ATTR_BUS_T
 * Defines enhanced flex counter ingress packet attribute bus enums.
 */
typedef enum bcm56996_a0_lrd_ctr_ing_eflex_pkt_attr_bus_t_e {
    /*! CNG bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_CNG_BIT0 = 0,
    /*! CNG bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_CNG_BIT1 = 1,
    /*! DCN packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_DCN = 2,
    /*! Drop packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_DROP = 3,
    /*! ELEPHANT packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_ELEPHANT = 4,
    /*! IFP congestion packets bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_IFP_CNG_BIT0 = 6,
    /*! IFP congestion packets bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_IFP_CNG_BIT1 = 7,
    /*! IFP internal priority packets bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_IFP_INT_PRI_BIT0 = 8,
    /*! IFP internal priority packets bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_IFP_INT_PRI_BIT1 = 9,
    /*! IFP internal priority packets bit2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_IFP_INT_PRI_BIT2 = 10,
    /*! IFP internal priority packets bit3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_IFP_INT_PRI_BIT3 = 11,
    /*! Internal congestion packets bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_INT_CN_BIT0 = 12,
    /*! Internal congestion packets bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_INT_CN_BIT1 = 13,
    /*! Internal priority bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT0 = 14,
    /*! Internal priority bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT1 = 15,
    /*! Internal priority bit2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT2 = 16,
    /*! Internal priority bit3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_INT_PRI_BIT3 = 17,
    /*! IP packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_IP = 18,
    /*! MPLS experimental field bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_MPLS_EXP_BIT0 = 19,
    /*! MPLS experimental field bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_MPLS_EXP_BIT1 = 20,
    /*! MPLS experimental field bit2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_MPLS_EXP_BIT2 = 21,
    /*! Outer 802.1p priority bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_OUTER_DOT1P_BIT0 = 22,
    /*! Outer 802.1p priority bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_OUTER_DOT1P_BIT1 = 23,
    /*! Outer 802.1p priority bit2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_OUTER_DOT1P_BIT2 = 24,
    /*! Outer VLAN tagged packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_VLAN_SOT = 25,
    /*! Packet resolution bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PKT_RESOLUTION_BIT0 = 26,
    /*! Packet resolution bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PKT_RESOLUTION_BIT1 = 27,
    /*! Packet resolution bit2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PKT_RESOLUTION_BIT2 = 28,
    /*! Packet resolution bit3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PKT_RESOLUTION_BIT3 = 29,
    /*! Packet resolution bit4.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PKT_RESOLUTION_BIT4 = 30,
    /*! Packet resolution bit5.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PKT_RESOLUTION_BIT5 = 31,
    /*! Port ID bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT0 = 32,
    /*! Port ID bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT1 = 33,
    /*! Port ID bit2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT2 = 34,
    /*! Port ID bit3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT3 = 35,
    /*! Port ID bit4.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT4 = 36,
    /*! Port ID bit5.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_PORT_ID_BIT5 = 37,
    /*! TCP FIN flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_FIN = 38,
    /*! TCP SYN flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_SYN = 39,
    /*! TCP RST flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_RST = 40,
    /*! TCP PSH flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_PSH = 41,
    /*! TCP ACK flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_ACK = 42,
    /*! TCP URG flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_URG = 43,
    /*! TCP ECE flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_ECE = 44,
    /*! TCP CWR flag.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TCP_FLAG_TYPE_CWR = 45,
    /*! Explicit Congrestion Notification TOS bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_ECN_BIT0 = 46,
    /*! Explicit Congrestion Notification TOS bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_ECN_BIT1 = 47,
    /*! Differentiated Services TOS bit0.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT0 = 48,
    /*! Differentiated Services TOS bit1.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT1 = 49,
    /*! Differentiated Services TOS bit2.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT2 = 50,
    /*! Differentiated Services TOS bit3.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT3 = 51,
    /*! Differentiated Services TOS bit4.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT4 = 52,
    /*! Differentiated Services TOS bit5.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_ATTR_BUS_T_T_TOS_DSCP_BIT5 = 53,
} bcm56996_a0_lrd_ctr_ing_eflex_pkt_attr_bus_t_t;

/*! enum type for CTR_ING_EFLEX_PKT_RESOLUTION_T
 * Defines enhanced flex counter ingress packet resolution enums.
 */
typedef enum bcm56996_a0_lrd_ctr_ing_eflex_pkt_resolution_t_e {
    /*! Unknown packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_UNKNOWN = 0,
    /*! Ethernet Control (8808) packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_CONTROL = 1,
    /*! BFD (Bidirectional Forwarding Detection) packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_BFD = 3,
    /*! BPDU (Bridge Protocol Data Unit) packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_BPDU = 4,
    /*! 1588 packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_1588 = 6,
    /*! Known L2 unicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_KNOWN_L2UC = 8,
    /*! Unknown L2 unicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_UNKNOWN_L2UC = 9,
    /*! Known L2 multicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_KNOWN_L2MC = 10,
    /*! Unknown L2 multicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_UNKNOWN_L2MC = 11,
    /*! L2BC (L2 Broadcast) packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_L2BC = 12,
    /*! Known L3 unicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_KNOWN_L3UC = 16,
    /*! Unknown L3 unicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_UNKNOWN_L3UC = 17,
    /*! Known IP multicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_KNOWN_IPMC = 18,
    /*! Unknown IP multicast packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_UNKNOWN_IPMC = 19,
    /*! Unknown MPLS packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_UNKNOWN_MPLS = 25,
    /*! known L3 MPLS packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_KNOWN_MPLS_L3 = 26,
    /*! Known MPLS packets.  */
    BCM56996_A0_LRD_CTR_ING_EFLEX_PKT_RESOLUTION_T_T_PKT_TYPE_KNOWN_MPLS = 28,
} bcm56996_a0_lrd_ctr_ing_eflex_pkt_resolution_t_t;

/*! enum type for DEVICE_BS_PLL_REF_CLK_T */
typedef enum bcm56996_a0_lrd_device_bs_pll_ref_clk_t_e {
    /*! Auto select clk source.  */
    BCM56996_A0_LRD_DEVICE_BS_PLL_REF_CLK_T_T_CLK_AUTO = 0,
    /*! Ext clk source 12.8Mhz.  */
    BCM56996_A0_LRD_DEVICE_BS_PLL_REF_CLK_T_T_CLK_EXT_12_8MHZ = 1,
    /*! Ext clk source 20Mhz.  */
    BCM56996_A0_LRD_DEVICE_BS_PLL_REF_CLK_T_T_CLK_EXT_20MHZ = 2,
    /*! Ext clk source 25Mhz.  */
    BCM56996_A0_LRD_DEVICE_BS_PLL_REF_CLK_T_T_CLK_EXT_25MHZ = 3,
    /*! Ext clk source 32Mhz.  */
    BCM56996_A0_LRD_DEVICE_BS_PLL_REF_CLK_T_T_CLK_EXT_32MHZ = 4,
    /*! Ext clk source 50Mhz.  */
    BCM56996_A0_LRD_DEVICE_BS_PLL_REF_CLK_T_T_CLK_EXT_50MHZ = 5,
    /*! Int clk source 50Mhz.  */
    BCM56996_A0_LRD_DEVICE_BS_PLL_REF_CLK_T_T_CLK_INT_50MHZ = 6,
} bcm56996_a0_lrd_device_bs_pll_ref_clk_t_t;

/*! enum type for DEVICE_CLK_FREQ_T */
typedef enum bcm56996_a0_lrd_device_clk_freq_t_e {
    /*! Clock frequency 1325Mhz.  */
    BCM56996_A0_LRD_DEVICE_CLK_FREQ_T_T_CLK_1325MHZ = 0,
    /*! Clock frequency 1250Mhz.  */
    BCM56996_A0_LRD_DEVICE_CLK_FREQ_T_T_CLK_1250MHZ = 1,
    /*! Clock frequency 1175Mhz.  */
    BCM56996_A0_LRD_DEVICE_CLK_FREQ_T_T_CLK_1175MHZ = 2,
    /*! Clock frequency 1100Mhz.  */
    BCM56996_A0_LRD_DEVICE_CLK_FREQ_T_T_CLK_1100MHZ = 3,
    /*! Clock frequency 1025Mhz.  */
    BCM56996_A0_LRD_DEVICE_CLK_FREQ_T_T_CLK_1025MHZ = 4,
    /*! Clock frequency 950Mhz.  */
    BCM56996_A0_LRD_DEVICE_CLK_FREQ_T_T_CLK_950MHZ = 5,
} bcm56996_a0_lrd_device_clk_freq_t_t;

/*! enum type for DEVICE_EM_BANK_ID_KEY_T
 * Device enhanced memory bank ID key type.
 */
typedef enum bcm56996_a0_lrd_device_em_bank_id_key_t_e {
    /*! L2 dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_L2_BANK0 = 1,
    /*! L2 dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_L2_BANK1 = 2,
    /*! MPLS dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_MPLS_BANK0 = 3,
    /*! MPLS dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_MPLS_BANK1 = 4,
    /*! MPLS dedicated bank 2.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_MPLS_BANK2 = 5,
    /*! MPLS dedicated bank 3.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_MPLS_BANK3 = 6,
    /*! L3_TUNNEL dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_L3_TUNNEL_BANK0 = 7,
    /*! L3_TUNNEL dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_L3_TUNNEL_BANK1 = 8,
    /*! L3_TUNNEL dedicated bank 2.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_L3_TUNNEL_BANK2 = 9,
    /*! L3_TUNNEL dedicated bank 3.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_L3_TUNNEL_BANK3 = 10,
    /*! EGR_ADAPT bank 0  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_EGR_ADAPT_BANK0 = 11,
    /*! EGR_ADAPT bank 1  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_EGR_ADAPT_BANK1 = 12,
    /*! UFT shared bank 0  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK0 = 13,
    /*! UFT shared bank 1  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK1 = 14,
    /*! UFT shared bank 2  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK2 = 15,
    /*! UFT shared bank 3  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK3 = 16,
    /*! UFT shared bank 4  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK4 = 17,
    /*! UFT shared bank 5  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK5 = 18,
    /*! UFT shared bank 6  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK6 = 19,
    /*! UFT shared bank 7  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_BANK7 = 20,
    /*! UFT mini bank 0  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_MINI_BANK0 = 21,
    /*! UFT mini bank 1  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_MINI_BANK1 = 22,
    /*! UFT mini bank 2  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_MINI_BANK2 = 23,
    /*! UFT mini bank 3  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_MINI_BANK3 = 24,
    /*! UFT mini bank 4  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_MINI_BANK4 = 25,
    /*! UFT mini bank 5  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_KEY_T_T_UFT_MINI_BANK5 = 26,
} bcm56996_a0_lrd_device_em_bank_id_key_t_t;

/*! enum type for DEVICE_EM_BANK_ID_VALUE_T
 * Device enhanced memory bank ID value type.
 */
typedef enum bcm56996_a0_lrd_device_em_bank_id_value_t_e {
    /*! Invalid bank id.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_INVALID = 0,
    /*! L2 dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_L2_BANK0 = 1,
    /*! L2 dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_L2_BANK1 = 2,
    /*! MPLS dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_MPLS_BANK0 = 3,
    /*! MPLS dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_MPLS_BANK1 = 4,
    /*! MPLS dedicated bank 2.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_MPLS_BANK2 = 5,
    /*! MPLS dedicated bank 3.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_MPLS_BANK3 = 6,
    /*! L3_TUNNEL dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_L3_TUNNEL_BANK0 = 7,
    /*! L3_TUNNEL dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_L3_TUNNEL_BANK1 = 8,
    /*! L3_TUNNEL dedicated bank 2.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_L3_TUNNEL_BANK2 = 9,
    /*! L3_TUNNEL dedicated bank 3.  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_L3_TUNNEL_BANK3 = 10,
    /*! EGR_ADAPT bank 0  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_EGR_ADAPT_BANK0 = 11,
    /*! EGR_ADAPT bank 1  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_EGR_ADAPT_BANK1 = 12,
    /*! UFT shared bank 0  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK0 = 13,
    /*! UFT shared bank 1  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK1 = 14,
    /*! UFT shared bank 2  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK2 = 15,
    /*! UFT shared bank 3  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK3 = 16,
    /*! UFT shared bank 4  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK4 = 17,
    /*! UFT shared bank 5  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK5 = 18,
    /*! UFT shared bank 6  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK6 = 19,
    /*! UFT shared bank 7  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_BANK7 = 20,
    /*! UFT mini bank 0  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_MINI_BANK0 = 21,
    /*! UFT mini bank 1  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_MINI_BANK1 = 22,
    /*! UFT mini bank 2  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_MINI_BANK2 = 23,
    /*! UFT mini bank 3  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_MINI_BANK3 = 24,
    /*! UFT mini bank 4  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_MINI_BANK4 = 25,
    /*! UFT mini bank 5  */
    BCM56996_A0_LRD_DEVICE_EM_BANK_ID_VALUE_T_T_UFT_MINI_BANK5 = 26,
} bcm56996_a0_lrd_device_em_bank_id_value_t_t;

/*! enum type for DEVICE_EM_GROUP_ID_KEY_T
 * Device enhanced memory group ID key type.
 */
typedef enum bcm56996_a0_lrd_device_em_group_id_key_t_e {
    /*! L2 feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_L2_HASH_GROUP = 1,
    /*! MPLS feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_MPLS_HASH_GROUP = 2,
    /*! FP_EM feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_FP_EM_HASH_GROUP = 3,
    /*! L3_TUNNEL feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_L3_TUNNEL_HASH_GROUP = 4,
    /*! ALPM level 2 feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_ALPM_LEVEL2_GROUP = 5,
    /*! ALPM level 3 feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_ALPM_LEVEL3_GROUP = 6,
    /*! EGR_ADAPT feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_EGR_ADAPT_GROUP = 7,
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_KEY_T_T_L2_UFT_GROUP = 8,
} bcm56996_a0_lrd_device_em_group_id_key_t_t;

/*! enum type for DEVICE_EM_GROUP_ID_VALUE_T
 * Device enhanced memory group ID value type.
 */
typedef enum bcm56996_a0_lrd_device_em_group_id_value_t_e {
    /*! Invalid group id.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_INVALID = 0,
    /*! L2 feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_L2_HASH_GROUP = 1,
    /*! MPLS feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_MPLS_HASH_GROUP = 2,
    /*! FP_EM feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_FP_EM_HASH_GROUP = 3,
    /*! L3_TUNNEL feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_L3_TUNNEL_HASH_GROUP = 4,
    /*! ALPM level 2 feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_ALPM_LEVEL2_GROUP = 5,
    /*! ALPM level 3 feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_ALPM_LEVEL3_GROUP = 6,
    /*! EGR_ADAPT feature.  */
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_EGR_ADAPT_GROUP = 7,
    BCM56996_A0_LRD_DEVICE_EM_GROUP_ID_VALUE_T_T_L2_UFT_GROUP = 8,
} bcm56996_a0_lrd_device_em_group_id_value_t_t;

/*! enum type for DEVICE_HASH_BANK_ID_KEY_T */
typedef enum bcm56996_a0_lrd_device_hash_bank_id_key_t_e {
    /*! L2 dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_L2_BANK0 = 1,
    /*! L2 dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_L2_BANK1 = 2,
    /*! MPLS dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_MPLS_BANK0 = 3,
    /*! MPLS dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_MPLS_BANK1 = 4,
    /*! MPLS dedicated bank 2.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_MPLS_BANK2 = 5,
    /*! MPLS dedicated bank 3.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_MPLS_BANK3 = 6,
    /*! L3_TUNNEL dedicated bank 0.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_L3_TUNNEL_BANK0 = 7,
    /*! L3_TUNNEL dedicated bank 1.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_L3_TUNNEL_BANK1 = 8,
    /*! L3_TUNNEL dedicated bank 2.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_L3_TUNNEL_BANK2 = 9,
    /*! L3_TUNNEL dedicated bank 3.  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_L3_TUNNEL_BANK3 = 10,
    /*! EGR_ADAPT bank 0  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_EGR_ADAPT_BANK0 = 11,
    /*! EGR_ADAPT bank 1  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_EGR_ADAPT_BANK1 = 12,
    /*! UFT shared bank 0  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_UFT_BANK0 = 13,
    /*! UFT shared bank 1  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_UFT_BANK1 = 14,
    /*! UFT shared bank 2  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_UFT_BANK2 = 15,
    /*! UFT shared bank 3  */
    BCM56996_A0_LRD_DEVICE_HASH_BANK_ID_KEY_T_T_UFT_BANK3 = 16,
} bcm56996_a0_lrd_device_hash_bank_id_key_t_t;

/*! enum type for DEVICE_HASH_VECTOR_T
 * Device hash vector type.
 */
typedef enum bcm56996_a0_lrd_device_hash_vector_t_e {
    /*! Use {crc32[31:0], crc32[31:0]} type hash vector.  */
    BCM56996_A0_LRD_DEVICE_HASH_VECTOR_T_T_CRC32A_CRC32B = 6,
} bcm56996_a0_lrd_device_hash_vector_t_t;

/*! enum type for DEVICE_SEQ_RESET_T
 * Device sequential reset type.
 */
typedef enum bcm56996_a0_lrd_device_seq_reset_t_e {
    /*! Seqential reset not enabled.  */
    BCM56996_A0_LRD_DEVICE_SEQ_RESET_T_T_SEQ_RESET_NONE = 0,
    /*! Hardware mode sequential reset.  */
    BCM56996_A0_LRD_DEVICE_SEQ_RESET_T_T_SEQ_RESET_HW = 1,
    /*! Software mode sequential reset.  */
    BCM56996_A0_LRD_DEVICE_SEQ_RESET_T_T_SEQ_RESET_SW = 2,
} bcm56996_a0_lrd_device_seq_reset_t_t;

/*! enum type for DEVICE_TS_PLL_REF_CLK_T */
typedef enum bcm56996_a0_lrd_device_ts_pll_ref_clk_t_e {
    /*! Auto select clk source.  */
    BCM56996_A0_LRD_DEVICE_TS_PLL_REF_CLK_T_T_CLK_AUTO = 0,
    /*! Ext clk source 50Mhz.  */
    BCM56996_A0_LRD_DEVICE_TS_PLL_REF_CLK_T_T_CLK_EXT_50MHZ = 1,
    /*! Int clk source 50Mhz.  */
    BCM56996_A0_LRD_DEVICE_TS_PLL_REF_CLK_T_T_CLK_INT_50MHZ = 2,
} bcm56996_a0_lrd_device_ts_pll_ref_clk_t_t;

/*! enum type for DLB_ASSIGNMENT_MODE_T
 * DLB Mode enumeration type.
 */
typedef enum bcm56996_a0_lrd_dlb_assignment_mode_t_e {
    /*!
     * If the inactivity duration has elapsed, pick the optimal member.
     *  Else, pick the current assigned member.
     */
    BCM56996_A0_LRD_DLB_ASSIGNMENT_MODE_T_T_TIME_ELIGIBILITY = 0,
    /*! Always pick the current assigned member.  */
    BCM56996_A0_LRD_DLB_ASSIGNMENT_MODE_T_T_FIXED = 1,
    /*! Always pick the optimal member.  */
    BCM56996_A0_LRD_DLB_ASSIGNMENT_MODE_T_T_PACKET_SPRAY = 2,
} bcm56996_a0_lrd_dlb_assignment_mode_t_t;

/*! enum type for DLB_FLOW_SET_SIZE_T
 * DLB Group Flow Set Size enumeration type.
 */
typedef enum bcm56996_a0_lrd_dlb_flow_set_size_t_e {
    /*! Indicate the number of flow sets allocated to a given DLB group is 0.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_0 = 0,
    /*! Indicate the number of flow sets allocated to a given DLB group is 256.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_256 = 1,
    /*! Indicate the number of flow sets allocated to a given DLB group is 512.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_512 = 2,
    /*! Indicate the number of flow sets allocated to a given DLB group is 1K.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_1024 = 3,
    /*! Indicate the number of flow sets allocated to a given DLB group is 2K.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_2048 = 4,
    /*! Indicate the number of flow sets allocated to a given DLB group is 4K.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_4096 = 5,
    /*! Indicate the number of flow sets allocated to a given DLB group is 8K.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_8192 = 6,
    /*! Indicate the number of flow sets allocated to a given DLB group is 16K.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_16384 = 7,
    /*! Indicate the number of flow sets allocated to a given DLB group is 32K.  */
    BCM56996_A0_LRD_DLB_FLOW_SET_SIZE_T_T_FLOW_SET_SIZE_32768 = 8,
} bcm56996_a0_lrd_dlb_flow_set_size_t_t;

/*! enum type for DLB_PORT_SCALING_FACTOR_T
 * DLB Scaling factor enumeration type.
 *  Per port multiplier used to scale the associated thresholds to account
 *  for different aggregation groups operating at different speeds.
 */
typedef enum bcm56996_a0_lrd_dlb_port_scaling_factor_t_e {
    /*! Scaling factor of 1 for 10G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_10G = 0,
    /*! Scaling factor of 2.5 for 25G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_25G = 1,
    /*! Scaling factor of 4 for 40G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_40G = 2,
    /*! Scaling factor of 5 for 50G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_50G = 3,
    /*! Scaling factor of 7.5 for 75G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_75G = 4,
    /*! Scaling factor of 10 for 100G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_100G = 5,
    /*! Scaling factor of 20 for 200G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_200G = 6,
    /*! Scaling factor of 40 for 400G ports.  */
    BCM56996_A0_LRD_DLB_PORT_SCALING_FACTOR_T_T_SCALING_FACTOR_400G = 7,
} bcm56996_a0_lrd_dlb_port_scaling_factor_t_t;

/*! enum type for ECMP_HASH_ALG_T
 * ECMP hash computation algorithm enumeration type.
 */
typedef enum bcm56996_a0_lrd_ecmp_hash_alg_t_e {
    /*! Always return 0 as hash value.  */
    BCM56996_A0_LRD_ECMP_HASH_ALG_T_T_ZERO = 0,
    /*! Use CRC-32 algorithm and select upper 16-bits as hash value.  */
    BCM56996_A0_LRD_ECMP_HASH_ALG_T_T_CRC32U = 1,
    /*! Use CRC-32 algorithm and select lower 16-bits as hash value.  */
    BCM56996_A0_LRD_ECMP_HASH_ALG_T_T_CRC32L = 2,
    /*! Lower 16-bits of the source IP address as hash value.  */
    BCM56996_A0_LRD_ECMP_HASH_ALG_T_T_LSB = 3,
} bcm56996_a0_lrd_ecmp_hash_alg_t_t;

/*! enum type for ECMP_HASH_MASK_T
 * ECMP hash mask enumeration type.
 */
typedef enum bcm56996_a0_lrd_ecmp_hash_mask_t_e {
    /*!
     * Use lowest 10-bits of the 16-bit hash value and
     *  perform 10_modulo_10 computation.
     */
    BCM56996_A0_LRD_ECMP_HASH_MASK_T_T_LSB_10BITS = 0,
    /*!
     * Use lowest 11-bits of the 16-bit hash value and
     *  perform 11_modulo_10 computation.
     */
    BCM56996_A0_LRD_ECMP_HASH_MASK_T_T_LSB_11BITS = 1,
    /*!
     * Use lowest 12-bits of the 16-bit hash value and
     *  perform 12_modulo_10 computation.
     */
    BCM56996_A0_LRD_ECMP_HASH_MASK_T_T_LSB_12BITS = 2,
    /*!
     * Use lowest 13-bits of the 16-bit hash value and
     *  perform 13_modulo_10 computation.
     */
    BCM56996_A0_LRD_ECMP_HASH_MASK_T_T_LSB_13BITS = 3,
    /*!
     * Use lowest 14-bits of the 16-bit hash value and
     *  perform 14_modulo_10 computation.
     */
    BCM56996_A0_LRD_ECMP_HASH_MASK_T_T_LSB_14BITS = 4,
    /*!
     * Use lowest 15-bits of the 16-bit hash value and
     *  perform 15_modulo_10 computation.
     */
    BCM56996_A0_LRD_ECMP_HASH_MASK_T_T_LSB_15BITS = 5,
    /*!
     * Use lowest 16-bits of the 16-bit hash value and
     *  perform 16_modulo_10 computation.
     */
    BCM56996_A0_LRD_ECMP_HASH_MASK_T_T_LSB_16BITS = 6,
} bcm56996_a0_lrd_ecmp_hash_mask_t_t;

/*! enum type for ECMP_MEMBER_OVERLAY_LIMIT_T
 * ECMP member overlay limit type.
 */
typedef enum bcm56996_a0_lrd_ecmp_member_overlay_limit_t_e {
    /*! Allocate no entries for overlay.  */
    BCM56996_A0_LRD_ECMP_MEMBER_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_0 = 0,
    /*! Allocate 4K entries for overlay.  */
    BCM56996_A0_LRD_ECMP_MEMBER_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_4K = 1,
    /*! Allocate 8K entries for overlay.  */
    BCM56996_A0_LRD_ECMP_MEMBER_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_8K = 2,
    /*! Allocate 12K entries for overlay.  */
    BCM56996_A0_LRD_ECMP_MEMBER_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_12K = 3,
} bcm56996_a0_lrd_ecmp_member_overlay_limit_t_t;

/*! enum type for ECMP_OVERLAY_LB_MODE_T
 * ECMP_OVERLAY logical table load balancing mode enum definition.
 */
typedef enum bcm56996_a0_lrd_ecmp_overlay_lb_mode_t_e {
    /*! Regular (static hash) load balancing mode.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_LB_MODE_T_T_REGULAR = 0,
    /*! Resilient hashing load balancing mode.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_LB_MODE_T_T_RESILIENT = 1,
    /*! Random load balancing mode.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_LB_MODE_T_T_RANDOM = 2,
} bcm56996_a0_lrd_ecmp_overlay_lb_mode_t_t;

/*! enum type for ECMP_OVERLAY_RH_SIZE_T
 * ECMP_OVERLAY logical table resilient hashing load balancing mode group size
 *  enum definition.
 */
typedef enum bcm56996_a0_lrd_ecmp_overlay_rh_size_t_e {
    /*! 64 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_64 = 6,
    /*! 128 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_128 = 7,
    /*! 256 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_256 = 8,
    /*! 512 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_512 = 9,
    /*! 1024 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_1K = 10,
    /*! 2048 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_2K = 11,
    /*! 4096 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_4K = 12,
    /*! 8192 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_8K = 13,
    /*! 16384 entries occupied in the ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_OVERLAY_RH_SIZE_T_T_RH_SIZE_16K = 14,
} bcm56996_a0_lrd_ecmp_overlay_rh_size_t_t;

/*! enum type for ECMP_RH_SIZE_T
 * Resilient hashing load balancing mode group size enum definition.
 */
typedef enum bcm56996_a0_lrd_ecmp_rh_size_t_e {
    /*! 64 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_64 = 6,
    /*! 128 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_128 = 7,
    /*! 256 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_256 = 8,
    /*! 512 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_512 = 9,
    /*! 1024 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_1K = 10,
    /*! 2048 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_2K = 11,
    /*! 4096 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_4K = 12,
    /*! 8192 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_8K = 13,
    /*! 16384 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_16K = 14,
    /*! 32768 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_RH_SIZE_T_T_RH_SIZE_32K = 15,
} bcm56996_a0_lrd_ecmp_rh_size_t_t;

/*! enum type for ECMP_UNDERLAY_LB_MODE_T
 * ECMP_UNDERLAY logical table load balancing mode enum definition.
 */
typedef enum bcm56996_a0_lrd_ecmp_underlay_lb_mode_t_e {
    /*! Regular load balancing mode.  */
    BCM56996_A0_LRD_ECMP_UNDERLAY_LB_MODE_T_T_REGULAR = 0,
    /*! Resilient hashing load balancing mode.  */
    BCM56996_A0_LRD_ECMP_UNDERLAY_LB_MODE_T_T_RESILIENT = 1,
    /*! Random load balancing mode.  */
    BCM56996_A0_LRD_ECMP_UNDERLAY_LB_MODE_T_T_RANDOM = 2,
} bcm56996_a0_lrd_ecmp_underlay_lb_mode_t_t;

/*! enum type for ECMP_WEIGHTED_MODE_T
 * Weighted ECMP group load balancing mode definition.
 */
typedef enum bcm56996_a0_lrd_ecmp_weighted_mode_t_e {
    /*! Weighting is achieved with member repetition.  */
    BCM56996_A0_LRD_ECMP_WEIGHTED_MODE_T_T_MEMBER_REPLICATION = 1,
    /*! Weighting is achieved with weight distribution algorithm.  */
    BCM56996_A0_LRD_ECMP_WEIGHTED_MODE_T_T_MEMBER_WEIGHT = 2,
} bcm56996_a0_lrd_ecmp_weighted_mode_t_t;

/*! enum type for ECMP_WEIGHTED_SIZE_T
 * Weighted ECMP group size enum definition.
 */
typedef enum bcm56996_a0_lrd_ecmp_weighted_size_t_e {
    /*!
     * Less than or equal to 512 entries occupied in ECMP member table
     *  by this group. It is only applied for MEMBER_WEIGHT mode.
     */
    BCM56996_A0_LRD_ECMP_WEIGHTED_SIZE_T_T_WEIGHTED_SIZE_0_511 = 2,
    /*! 1024 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_WEIGHTED_SIZE_T_T_WEIGHTED_SIZE_1K = 5,
    /*! 2048 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_WEIGHTED_SIZE_T_T_WEIGHTED_SIZE_2K = 6,
    /*! 4096 entries occupied in ECMP member table by this group.  */
    BCM56996_A0_LRD_ECMP_WEIGHTED_SIZE_T_T_WEIGHTED_SIZE_4K = 7,
} bcm56996_a0_lrd_ecmp_weighted_size_t_t;

/*! enum type for EGR_ADAPT_LOOKUP_KEY_MODE_T
 * Egress adaptation lookup key mode type.
 */
typedef enum bcm56996_a0_lrd_egr_adapt_lookup_key_mode_t_e {
    /*! No adapt lookup.  */
    BCM56996_A0_LRD_EGR_ADAPT_LOOKUP_KEY_MODE_T_T_NONE = 0,
    /*! VFI as key.  */
    BCM56996_A0_LRD_EGR_ADAPT_LOOKUP_KEY_MODE_T_T_VFI = 3,
    /*! VFI and DVP group ID as keys.  */
    BCM56996_A0_LRD_EGR_ADAPT_LOOKUP_KEY_MODE_T_T_VFI_AND_DVP_GRP_ID = 4,
    /*! VFI and port group ID as keys.  */
    BCM56996_A0_LRD_EGR_ADAPT_LOOKUP_KEY_MODE_T_T_VFI_AND_PORT_GRP_ID = 5,
    /*! SVP as key.  */
    BCM56996_A0_LRD_EGR_ADAPT_LOOKUP_KEY_MODE_T_T_SVP = 6,
} bcm56996_a0_lrd_egr_adapt_lookup_key_mode_t_t;

/*! enum type for ETRAP_CRITICAL_T
 * Time period at the end of ETRAP_INTERVAL.
 */
typedef enum bcm56996_a0_lrd_etrap_critical_t_e {
    /*! 50 microseconds.  */
    BCM56996_A0_LRD_ETRAP_CRITICAL_T_T_TIME_50US = 0,
    /*! 100 microseconds.  */
    BCM56996_A0_LRD_ETRAP_CRITICAL_T_T_TIME_100US = 1,
    /*! 150 microseconds.  */
    BCM56996_A0_LRD_ETRAP_CRITICAL_T_T_TIME_150US = 2,
    /*! 200 microseconds.  */
    BCM56996_A0_LRD_ETRAP_CRITICAL_T_T_TIME_200US = 3,
    /*! 250 microseconds.  */
    BCM56996_A0_LRD_ETRAP_CRITICAL_T_T_TIME_250US = 4,
    /*! 500 microseconds.  */
    BCM56996_A0_LRD_ETRAP_CRITICAL_T_T_TIME_500US = 5,
} bcm56996_a0_lrd_etrap_critical_t_t;

/*! enum type for ETRAP_HASH_SEL_T
 * LB hash function.
 */
typedef enum bcm56996_a0_lrd_etrap_hash_sel_t_e {
    /*! LB hash 0 instance 0.  */
    BCM56996_A0_LRD_ETRAP_HASH_SEL_T_T_HASH0_INSTANCE0 = 0,
    /*! LB hash 0 instance 1.  */
    BCM56996_A0_LRD_ETRAP_HASH_SEL_T_T_HASH0_INSTANCE1 = 1,
    /*! LB hash 1 instance 0.  */
    BCM56996_A0_LRD_ETRAP_HASH_SEL_T_T_HASH1_INSTANCE0 = 2,
    /*! LB hash 1 instance 1.  */
    BCM56996_A0_LRD_ETRAP_HASH_SEL_T_T_HASH1_INSTANCE1 = 3,
} bcm56996_a0_lrd_etrap_hash_sel_t_t;

/*! enum type for ETRAP_INTERVAL_T
 * Flow rate time interval.
 */
typedef enum bcm56996_a0_lrd_etrap_interval_t_e {
    /*! 1 millisecond.  */
    BCM56996_A0_LRD_ETRAP_INTERVAL_T_T_TIME_1MS = 0,
    /*! 2 milliseconds.  */
    BCM56996_A0_LRD_ETRAP_INTERVAL_T_T_TIME_2MS = 1,
    /*! 5 milliseconds.  */
    BCM56996_A0_LRD_ETRAP_INTERVAL_T_T_TIME_5MS = 2,
    /*! 10 milliseconds.  */
    BCM56996_A0_LRD_ETRAP_INTERVAL_T_T_TIME_10MS = 3,
} bcm56996_a0_lrd_etrap_interval_t_t;

/*! enum type for EVICTION_MODE_T
 * Eviction Mode
 */
typedef enum bcm56996_a0_lrd_eviction_mode_t_e {
    BCM56996_A0_LRD_EVICTION_MODE_T_T_DISABLE = 0,
    BCM56996_A0_LRD_EVICTION_MODE_T_T_RANDOM = 1,
    BCM56996_A0_LRD_EVICTION_MODE_T_T_THRESHOLD = 2,
    BCM56996_A0_LRD_EVICTION_MODE_T_T_CONDITIONAL = 3,
} bcm56996_a0_lrd_eviction_mode_t_t;

/*! enum type for FORWARDING_BEHAVIOR_T
 * L2 forwarding key type.
 */
typedef enum bcm56996_a0_lrd_forwarding_behavior_t_e {
    /*! L2 bridging based on VFI and MAC.  */
    BCM56996_A0_LRD_FORWARDING_BEHAVIOR_T_T_BRIDGE = 0,
    /*! Forward the packet based on a single VFI.  */
    BCM56996_A0_LRD_FORWARDING_BEHAVIOR_T_T_SINGLE_XCONNECT = 1,
} bcm56996_a0_lrd_forwarding_behavior_t_t;

/*! enum type for FP_CLASS_ID_SEL_T
 * Class ID selection to be passed to EFP.
 */
typedef enum bcm56996_a0_lrd_fp_class_id_sel_t_e {
    /*! Invalid Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_INVALID = 0,
    /*! PORT_SYSTEM Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_PORT = 1,
    /*! ALPM Compression src Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_ALPM_COMPRESSION_SRC = 2,
    /*! L3_IIF Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_L3_IIF = 3,
    /*! VFP high Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_VFP_HI = 4,
    /*! VFP lower Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_VFP_LO = 5,
    /*! L2_FDB_VLAN src Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_L2_SRC = 6,
    /*! L2_FDB_VLAN dst Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_L2_DST = 7,
    /*! L3_IPV4_UC_ROUTE src Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_L3_SRC = 8,
    /*! L3_IPV4_UC_ROUTE dst Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_L3_DST = 9,
    /*! VLAN Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_VLAN = 10,
    /*! VRF Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_VRF = 11,
    /*! ALPM Compression dst Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_ALPM_COMPRESSION_DST = 12,
    /*! Exact match Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_EM = 13,
    /*! IFP Class ID.  */
    BCM56996_A0_LRD_FP_CLASS_ID_SEL_T_T_IFP = 15,
} bcm56996_a0_lrd_fp_class_id_sel_t_t;

/*! enum type for FP_EGR_ENTRY_STATE_T
 * Enum defines operation state of egress FP entry
 */
typedef enum bcm56996_a0_lrd_fp_egr_entry_state_t_e {
    /*! Success.  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_SUCCESS = 0,
    /*! Group is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_GRP_TEMPLATE_NOT_EXISTS = 1,
    /*! Rule is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_RULE_TEMPLATE_NOT_EXISTS = 2,
    /*! Policy is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_POLICY_TEMPLATE_NOT_EXISTS = 3,
    /*!
     * One or more qualifiers specified in the rule are not present
     *  in the group.
     */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_RULE_QSET_NOT_IN_GRP = 4,
    /*!
     * One or more qualifiers data or mask is more than
     *  the bitmap specified in group.
     */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_RULE_QSET_WIDTH_EXCEEDS = 5,
    /*! Meter is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_METER_TEMPLATE_NOT_EXISTS = 6,
    /*! Counter is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_COUNTER_TEMPLATE_NOT_EXISTS = 7,
    /*! Meter pipe id is not matching with group pipe ID  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_BCMFP_ENTRY_METER_PIPE_ID_MISMATCH = 11,
    /*!
     * Group is not operational. That means QSET and QSET provided in
     *  group are not fit in given mode.
     */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_GROUP_TEMPLATE_NOT_OPERATIONAL = 19,
    /*! Conflicting actions present in policy.  */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_CONFLICTING_ACTIONS_PRESENT_IN_POLICY = 20,
    /*! Qset doesnt fit the group configuration provided.\n */
    BCM56996_A0_LRD_FP_EGR_ENTRY_STATE_T_T_GROUP_QSET_DOESNT_FIT = 28,
} bcm56996_a0_lrd_fp_egr_entry_state_t_t;

/*! enum type for FP_EGR_GRP_MODE_T
 * Enum defines group mode for egress FP.
 */
typedef enum bcm56996_a0_lrd_fp_egr_grp_mode_t_e {
    /*!
     * L2_SINGLE_WIDE creates groups in single wide mode. This mode supports
     *  only single key type based on the port_pkt_type
     *  PORT_ANY_PACKET_ANY (applicable for all packets).
     *  Supported qualifiers are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     */
    BCM56996_A0_LRD_FP_EGR_GRP_MODE_T_T_L2_SINGLE_WIDE = 0,
    /*!
     * L3_SINGLE_WIDE will create group in single wide mode. This mode supports
     *  three different keys based on port_pkt_type. Supported port_pkt_types in
     *  this mode are
     *  1. PORT_ANY_PACKET_IPV4 (applicable for IPv4 packets)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_IP_FRAG
     *  QUAL_TCP_FLAGS
     *  QUAL_L4DST_PORT
     *  QUAL_L4SRC_PORT
     *  QUAL_ICMP_TYPE_CODE
     *  QUAL_TTL
     *  QUAL_IP_PROTOCOL
     *  QUAL_DST_IP4
     *  QUAL_SRC_IP4
     *  QUAL_TOS
     *  QUAL_INPORT
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_OUTPORT
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *
     *  2. PORT_ANY_PACKET_IPV6 (applicable for IPv6 packets)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_IP_PROTO
     *  QUAL_SRC_IP6/QUAL_DST_IP6/(QUAL_SRC_IP6_HIGH and QUAL_DST_IP6_HIGH)
     *  QUAL_SRV6_SRH_PKT
     *  QUAL_TOS
     *  QUAL_INPORT
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *
     *  3. PORT_ANY_PACKET_NONIP (applicable for any other packets).
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     */
    BCM56996_A0_LRD_FP_EGR_GRP_MODE_T_T_L3_SINGLE_WIDE = 1,
    /*!
     * L3_DOUBLE_WIDE create group in double wide mode. This mode supports
     *  three different pair of keys based on port_pkt_type. Supported
     *  port_pkt_types in this mode are
     *  1. PORT_ANY_PACKET_IPV4 (applicable for IPv4 packets)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *  QUAL_IP_FRAG
     *  QUAL_TCP_FLAGS
     *  QUAL_L4DST_PORT
     *  QUAL_L4SRC_PORT
     *  QUAL_ICMP_TYPE_CODE
     *  QUAL_TTL
     *  QUAL_IP_PROTOCOL
     *  QUAL_DST_IP4
     *  QUAL_SRC_IP4
     *  QUAL_TOS
     *  QUAL_DROP_PKT
     *
     *  2. PORT_ANY_PACKET_IPV6 (applicable for IPv6 packets)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_IP_PROTO
     *  QUAL_SRC_IP6/QUAL_DST_IP6/(QUAL_SRC_IP6_HIGH and QUAL_DST_IP6_HIGH)
     *  QUAL_SRV6_SRH_PKT
     *  QUAL_TOS
     *  QUAL_INPORT
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_IP_FRAG
     *  QUAL_TCP_FLAGS
     *  QUAL_L4DST_PORT
     *  QUAL_L4SRC_PORT
     *  QUAL_ICMP_TYPE_CODE
     *  QUAL_TTL
     *  QUAL_IP_FIRST_EH_SUBCODE
     *  QUAL_IP_FIRST_EH_PROTO
     *  QUAL_DROP_PKT
     *
     *  3. PORT_ANY_PACKET_NONIP (applicable for any other packets).
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *  QUAL_BYTES_0_7_AFTER_L2HEADER
     *  QUAL_BYTES_8_15_AFTER_L2HEADER
     *  QUAL_BYTES_16_17_AFTER_L2HEADER
     */
    BCM56996_A0_LRD_FP_EGR_GRP_MODE_T_T_L3_DOUBLE_WIDE = 2,
    /*!
     * L3_ANY_SINGLE_WIDE create group in single wide mode. This mode supports
     *  two different keys based on the port_pkt_type. Supported port_pkt_types
     *  are
     *  1. PORT_ANY_PACKET_IP (applicable for all IP(IPv4 and IPv6) packets)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_IP_FRAG
     *  QUAL_TCP_FLAGS
     *  QUAL_L4DST_PORT
     *  QUAL_L4SRC_PORT
     *  QUAL_ICMP_TYPE_CODE
     *  QUAL_TTL
     *  QUAL_IP_PROTOCOL
     *  QUAL_DST_IP4
     *  QUAL_SRC_IP4
     *  QUAL_TOS
     *  QUAL_INPORT
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_OUTPORT
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *
     *  2. PORT_ANY_PACKET_NONIP (applicable for any other packets).
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     */
    BCM56996_A0_LRD_FP_EGR_GRP_MODE_T_T_L3_ANY_SINGLE_WIDE = 3,
    /*!
     * L3_ANY_DOUBLE_WIDE create group in double wide mode. This mode supports
     *  three different pair of keys based on the port_pkt_type. Supported
     *  port_pkt_types are
     *  1. HIGIG (applicable for packets on Higig ports)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_OUTPORT
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *  QUAL_L4_PKT
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *
     *  3. FRONT PANEL (applicable for packets on front panel ports).
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *  QUAL_IP_FRAG
     *  QUAL_TCP_FLAGS
     *  QUAL_L4DST_PORT
     *  QUAL_L4SRC_PORT
     *  QUAL_ICMP_TYPE_CODE
     *  QUAL_TTL
     *  QUAL_IP_PROTOCOL
     *  QUAL_DST_IP4
     *  QUAL_SRC_IP4
     *  QUAL_TOS
     *  QUAL_DROP_PKT
     */
    BCM56996_A0_LRD_FP_EGR_GRP_MODE_T_T_L3_ANY_DOUBLE_WIDE = 4,
    /*!
     * L3_ALT_DOUBLE_WIDE create group in double wide mode. This mode supports
     *  three different pair of keys based on the port_pkt_type. Supported
     *  port_pkt_types are
     *  1. PORT_ANY_PACKET_IPV4 (applicable for IPv4 packets)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *  QUAL_IP_FRAG
     *  QUAL_TCP_FLAGS
     *  QUAL_L4DST_PORT
     *  QUAL_L4SRC_PORT
     *  QUAL_ICMP_TYPE_CODE
     *  QUAL_TTL
     *  QUAL_IP_PROTOCOL
     *  QUAL_DST_IP4
     *  QUAL_SRC_IP4
     *  QUAL_TOS
     *  QUAL_DROP_PKT
     *
     *  2. PORT_ANY_PACKET_IPV6 (applicable for IPv6 packets)
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_SRV6_SRH_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_IP_PROTOCOL
     *  QUAL_SRC_IP6/QUAL_DST_IP6/(QUAL_SRC_IP6_HIGH and QUAL_DST_IP6_HIGH)
     *  QUAL_SRV6_SRH_PKT
     *  QUAL_TOS
     *
     *  3. PORT_ANY_PACKET_NONIP (applicable for any other packets).
     *  Supported qualifiers in this mode/port_pkt_type are
     *  QUAL_L4_PKT
     *  QUAL_EGR_NHOP_CLASS_ID
     *  QUAL_EGR_L3_IIF_CLASS_ID
     *  QUAL_EGR_UNDERLAY_NHOP_CLASS_ID
     *  QUAL_EGR_UNDERLAY_L3_IIF_CLASS_ID
     *  QUAL_INT_PRI
     *  QUAL_COLOR
     *  QUAL_L2_FORMAT
     *  QUAL_ETHERTYPE
     *  QUAL_SRC_MAC
     *  QUAL_DST_MAC
     *  QUAL_INPORT
     *  QUAL_EGR_DVP
     *  QUAL_EGR_DVP_GROUP_ID
     *  QUAL_L3_ROUTABLE_PKT
     *  QUAL_MIRR_COPY
     *  QUAL_OUTER_VLAN_ID
     *  QUAL_OUTER_VLAN_CFI
     *  QUAL_OUTER_VLAN_PRI
     *  QUAL_VLAN_OUTER_PRESENT
     *  QUAL_OPAQUE_TAG_PRESENT
     *  QUAL_PORT_GRP_OR_PORT_SYSTEM_CLASS
     *  QUAL_ING_CLASS_ID_TYPE
     *  QUAL_ING_CLASS_ID
     *  QUAL_OUTPORT
     *  QUAL_CPU_COS
     *  QUAL_IP_TYPE
     *  QUAL_FWD_VLAN_ID
     *  QUAL_VRF
     *  QUAL_VPN
     *  QUAL_FWD_TYPE
     *  QUAL_INT_CN
     *  QUAL_DROP_PKT
     *  QUAL_BYTES_0_7_AFTER_L2HEADER
     *  QUAL_BYTES_8_15_AFTER_L2HEADER
     *  QUAL_BYTES_16_17_AFTER_L2HEADER
     */
    BCM56996_A0_LRD_FP_EGR_GRP_MODE_T_T_L3_ALT_DOUBLE_WIDE = 5,
} bcm56996_a0_lrd_fp_egr_grp_mode_t_t;

/*! enum type for FP_EGR_PORT_PKT_TYPE_T
 * Enum defines Group Port Packet type for Egress FP.
 */
typedef enum bcm56996_a0_lrd_fp_egr_port_pkt_type_t_e {
    /*! Any port with any packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_ANY_PACKET_ANY = 0,
    /*! Any port with IPv4 packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_ANY_PACKET_IPV4 = 1,
    /*! Any port with IPv6 packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_ANY_PACKET_IPV6 = 2,
    /*! Any port with IP(IPv4/IPv6) packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_ANY_PACKET_IP = 3,
    /*! Any port with Non-IP packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_ANY_PACKET_NONIP = 4,
    /*! Higig port with any packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_HIGIG_PACKET_ANY = 5,
    /*! Front port with any packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_FRONT_PACKET_ANY = 6,
    /*! Loopback port with any packet type.  */
    BCM56996_A0_LRD_FP_EGR_PORT_PKT_TYPE_T_T_PORT_LOOPBACK_PACKET_ANY = 7,
} bcm56996_a0_lrd_fp_egr_port_pkt_type_t_t;

/*! enum type for FP_EGR_QUAL_COLOR_T
 * Enum for egress FP rule qualifier of color type.
 */
typedef enum bcm56996_a0_lrd_fp_egr_qual_color_t_e {
    BCM56996_A0_LRD_FP_EGR_QUAL_COLOR_T_T_ANY = 0,
    /*! Incoming packet color green.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_COLOR_T_T_GREEN = 1,
    /*! Incoming packet color yellow.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_COLOR_T_T_YELLOW = 2,
    /*! Incoming packet color red.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_COLOR_T_T_RED = 3,
} bcm56996_a0_lrd_fp_egr_qual_color_t_t;

/*! enum type for FP_EGR_QUAL_FWD_TYPE_T
 * Enum for egress FP qualifier of forwarding type.
 */
typedef enum bcm56996_a0_lrd_fp_egr_qual_fwd_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_FWD_TYPE_T_T_ANY = 0,
    /*! Invalid .  */
    BCM56996_A0_LRD_FP_EGR_QUAL_FWD_TYPE_T_T_INVALID = 23,
    /*! Vlan forwarding.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_FWD_TYPE_T_T_VLAN = 24,
    /*! vrf forwarding.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_FWD_TYPE_T_T_VRF = 25,
} bcm56996_a0_lrd_fp_egr_qual_fwd_type_t_t;

/*! enum type for FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T
 * Enum for egress FP qualifier of ingress to egress class ID type.
 */
typedef enum bcm56996_a0_lrd_fp_egr_qual_ifp_class_id_type_t_e {
    /*! Any class ID type.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_ANY = 0,
    /*! Class ID based on source port.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_PORT_SYSTEM = 1,
    /*! Class ID based on source virtual port(SVP).  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_SVP = 2,
    /*! Class ID assigned by L3_IIF.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_L3_IIF = 3,
    /*! Upper class ID assigned by VLAN FP.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_FP_VLAN_CLASS_1 = 4,
    /*! Lower class ID assigned by VLAN FP.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_FP_VLAN_CLASS_0 = 5,
    /*! Class ID based on L2 source address.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_L2_SRC = 6,
    /*! Class ID based on L2 destination address.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_L2_DST = 7,
    /*! Class ID based on L3 source address.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_L3_SRC = 8,
    /*! Class ID based on L3 destination address.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_L3_DST = 9,
    /*! Class ID based on VLAN.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_VLAN = 10,
    /*! Class ID based on VRF.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_VRF = 11,
    /*! Class ID assinged by ingress FP.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_FP_ING = 15,
    /*! Invalid.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IFP_CLASS_ID_TYPE_T_T_INVALID = 16,
} bcm56996_a0_lrd_fp_egr_qual_ifp_class_id_type_t_t;

/*! enum type for FP_EGR_QUAL_IP_FRAG_T
 * Enum for egress FP rule qualifier for IP fragments.
 */
typedef enum bcm56996_a0_lrd_fp_egr_qual_ip_frag_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_FRAG_T_T_NON_OR_ANY = 0,
    /*! Non-fragmented packet.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_FRAG_T_T_NON = 1,
    /*! First fragment  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_FRAG_T_T_FIRST = 2,
    /*! Non-fragmented or first fragment.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_FRAG_T_T_NON_OR_FIRST = 3,
    /*! Not the first fragment.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_FRAG_T_T_NOT_FIRST = 4,
    /*! Any fragment of fragmented packet.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_FRAG_T_T_ANY = 5,
} bcm56996_a0_lrd_fp_egr_qual_ip_frag_t_t;

/*! enum type for FP_EGR_QUAL_IP_TYPE_T
 * Enum for egress FP qualifier of IP type.
 */
typedef enum bcm56996_a0_lrd_fp_egr_qual_ip_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_ANY = 0,
    /*! Non-ip packet.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_NON_IP = 1,
    /*! IPv4 without options.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_IP4_NO_OPTIONS = 2,
    /*! IPv4 with options.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_IP4_OPTIONS = 3,
    /*! Any IPv4 packet.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_ANY_IP4 = 4,
    /*! IPv6 packet without any extension header.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_IP6_NO_EXT_HDR = 5,
    /*! IPv6 packet with one extension header.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_IP6_ONE_EXT_HDR = 6,
    /*! IPv6 packet with two or more extension headers.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_IP6_TWO_EXT_HDR = 7,
    /*! IPv6 packet.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_ANY_IP6 = 8,
    /*! IPv4 and IPv6 packets.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_IP = 9,
    /*! ARP/RARP.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_ARP = 10,
    /*! ARP request.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_ARP_REQUEST = 11,
    /*! ARP reply.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_ARP_REPL = 12,
    /*! MPLS unicast frame (Ethertype = 0x8847).  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_UC_MPLS = 13,
    /*! MPLS multicast frame (Ethertype = 0x8848).  */
    BCM56996_A0_LRD_FP_EGR_QUAL_IP_TYPE_T_T_MC_MPLS = 14,
} bcm56996_a0_lrd_fp_egr_qual_ip_type_t_t;

/*! enum type for FP_EGR_QUAL_L2_FORMAT_T
 * Enum for egress FP qualifier of L2 format.
 */
typedef enum bcm56996_a0_lrd_fp_egr_qual_l2_format_t_e {
    /*! Do not qualify on L2 format.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_L2_FORMAT_T_T_ANY = 0,
    /*! Ethernet 2 (802.2).  */
    BCM56996_A0_LRD_FP_EGR_QUAL_L2_FORMAT_T_T_ETHER_2 = 1,
    /*! Sub-network access protocol.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_L2_FORMAT_T_T_SNAP = 2,
    /*! Logical link control.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_L2_FORMAT_T_T_LLC = 3,
    /*! 802.3 frame format.  */
    BCM56996_A0_LRD_FP_EGR_QUAL_L2_FORMAT_T_T_IEEE802DOT3 = 4,
} bcm56996_a0_lrd_fp_egr_qual_l2_format_t_t;

/*! enum type for FP_EM_ACTION_COLOR_T
 * Enum for exact match FP action for color type.
 */
typedef enum bcm56996_a0_lrd_fp_em_action_color_t_e {
    /*! No operation.  */
    BCM56996_A0_LRD_FP_EM_ACTION_COLOR_T_T_NO_OP = 0,
    /*! Color green.  */
    BCM56996_A0_LRD_FP_EM_ACTION_COLOR_T_T_GREEN = 1,
    /*! Color yellow.  */
    BCM56996_A0_LRD_FP_EM_ACTION_COLOR_T_T_YELLOW = 2,
    /*! Color red.  */
    BCM56996_A0_LRD_FP_EM_ACTION_COLOR_T_T_RED = 3,
} bcm56996_a0_lrd_fp_em_action_color_t_t;

/*! enum type for FP_EM_ACTION_HIGIG_CLASS_ID_SELECT_T
 * Enum for exact match FP action for HiGig class ID selection.
 */
typedef enum bcm56996_a0_lrd_fp_em_action_higig_class_id_select_t_e {
    /*! Not assigned.  */
    BCM56996_A0_LRD_FP_EM_ACTION_HIGIG_CLASS_ID_SELECT_T_T_NO_ASSIGNED = 0,
    /*! Ingress class ID.  */
    BCM56996_A0_LRD_FP_EM_ACTION_HIGIG_CLASS_ID_SELECT_T_T_ING_CLASS_ID = 1,
    /*! Use port.  */
    BCM56996_A0_LRD_FP_EM_ACTION_HIGIG_CLASS_ID_SELECT_T_T_USE_PORT = 4,
} bcm56996_a0_lrd_fp_em_action_higig_class_id_select_t_t;

/*! enum type for FP_EM_ENTRY_STATE_T
 * Enum defines operation state of exact match FP entry
 */
typedef enum bcm56996_a0_lrd_fp_em_entry_state_t_e {
    /*! Success.  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_SUCCESS = 0,
    /*! Group is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_GRP_TEMPLATE_NOT_EXISTS = 1,
    /*! Rule is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_RULE_TEMPLATE_NOT_EXISTS = 2,
    /*! Policy is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_POLICY_TEMPLATE_NOT_EXISTS = 3,
    /*!
     * One or more qualifiers specified in the rule are not present
     *  in the group.
     */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_RULE_QSET_NOT_IN_GRP = 4,
    /*!
     * One or more qualifiers data or mask is more than
     *  the bitmap specified in group.
     */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_RULE_QSET_WIDTH_EXCEEDS = 5,
    /*! Meter is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_METER_TEMPLATE_NOT_EXISTS = 6,
    /*! PDD is not yet created but associated to the group or entry  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_PDD_TEMPLATE_NOT_EXISTS = 8,
    /*! Entry group masked by another group  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_GRP_MASKED_BY_ANOTHER = 9,
    /*! Presel entries are not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_PRESEL_ENTRY_NOT_EXISTS = 10,
    /*! Meter pipe id is not matching with group pipe ID  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_BCMFP_ENTRY_METER_PIPE_ID_MISMATCH = 11,
    /*! Default PDD is not yet created but associated to the group  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_DEFAULT_PDD_TEMPLATE_NOT_EXISTS = 14,
    /*! Default policy is not yet created but associated to the group  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_DEFAULT_POLICY_TEMPLATE_NOT_EXISTS = 15,
    /*!
     * Policy associated to entry is created but PDD associated to the
     *  entry or group is not yet created.
     */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_POLICY_EXISTS_PDD_NOT_EXISTS = 16,
    /*!
     * Default policy associated to the group is created but default
     *  PDD associated to the entry or group is not yet created.
     */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_DEFAULT_POLICY_EXISTS_DEFAULT_PDD_NOT_EXISTS = 17,
    /*!
     * Group is not operational. That means QSET and QSET provided in
     *  group are not fit in given mode.
     */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_GROUP_TEMPLATE_NOT_OPERATIONAL = 19,
    /*! Conflicting actions present in policy.  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_CONFLICTING_ACTIONS_PRESENT_IN_POLICY = 20,
    /*! Conflicting actions present in policy.  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_CONFLICTING_ACTIONS_PRESENT_IN_DEFAULT_POLICY = 21,
    /*! One or more actions specified in policy are not present PDD.  */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_POLICY_ASET_NOT_IN_PDD = 22,
    /*!
     * One or more actions specified in default policy are not
     *  present in default PDD.
     */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_DEFAULT_POLICY_ASET_NOT_IN_DEFAULT_PDD = 23,
    /*! Aset doesnt fit the group configuration provided.\n */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_GROUP_ASET_DOESNT_FIT = 27,
    /*! Qset doesnt fit the group configuration provided.\n */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_GROUP_QSET_DOESNT_FIT = 28,
    /*! Default aset doesnt fit the group configuration provided.\n */
    BCM56996_A0_LRD_FP_EM_ENTRY_STATE_T_T_GROUP_DEFAULT_ASET_DOESNT_FIT = 29,
} bcm56996_a0_lrd_fp_em_entry_state_t_t;

/*! enum type for FP_EM_GRP_MODE_T
 * Enum defines Group Mode for Exact Match FP.
 */
typedef enum bcm56996_a0_lrd_fp_em_grp_mode_t_e {
    /*! Group Mode None.  */
    BCM56996_A0_LRD_FP_EM_GRP_MODE_T_T_NONE = 0,
    /*! Single Wide mode.  */
    BCM56996_A0_LRD_FP_EM_GRP_MODE_T_T_SINGLE = 1,
    /*! Double Wide Inter-slice mode.  */
    BCM56996_A0_LRD_FP_EM_GRP_MODE_T_T_DBLINTER = 3,
} bcm56996_a0_lrd_fp_em_grp_mode_t_t;

/*! enum type for FP_EM_PRESEL_QUAL_FWD_TYPE_T
 * Enum for exact match FP pre-selection qualifier of forwarding type.
 */
typedef enum bcm56996_a0_lrd_fp_em_presel_qual_fwd_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_ANY = 0,
    /*! L2 switching forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_L2 = 1,
    /*! L3 routing forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_L3 = 2,
    /*! Shared vlan L2 forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_L2_SHARED = 3,
    /*! Vlan based L2 forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_L2_INDEPENDENT = 4,
    /*! VFI based L2 forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_L2_VPN = 5,
    /*! L2 point to point vpn forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_L2_VPN_DIRECT = 6,
    /*! L3 predefined next hop forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_L3_DIRECT = 7,
    /*! MPLS Switching forwarding.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_MPLS = 12,
    /*! Any other forwarding type.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_FWD_TYPE_T_T_UNKNOWN = 22,
} bcm56996_a0_lrd_fp_em_presel_qual_fwd_type_t_t;

/*! enum type for FP_EM_PRESEL_QUAL_ING_STP_STATE_T
 * Enum for exact match FP pre-selection qualifier of ingress STP state.
 */
typedef enum bcm56996_a0_lrd_fp_em_presel_qual_ing_stp_state_t_e {
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_ANY = 0,
    /*! STP state disable.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_DISABLE = 1,
    /*! STP state block.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_BLOCK = 2,
    /*! STP state learn.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_LEARN = 4,
    /*! STP state forward.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_FORWARD = 5,
    /*! STP state learn or forward.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_LEARN_FORWARD = 6,
    /*! STP state learn or disable.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_LEARN_DISABLE = 7,
    /*! STP state forward or block  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_FORWARD_BLOCK = 8,
    /*! STP state disable or block  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_ING_STP_STATE_T_T_DISABLE_BLOCK = 9,
} bcm56996_a0_lrd_fp_em_presel_qual_ing_stp_state_t_t;

/*! enum type for FP_EM_PRESEL_QUAL_IP_TYPE_T
 * Enum for exact match FP pre-selection qualifier of IP type.
 */
typedef enum bcm56996_a0_lrd_fp_em_presel_qual_ip_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_ANY = 0,
    /*! Non-IP packet.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_NON_IP = 1,
    /*! IPv4 without options.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_IP4_NO_OPTIONS = 2,
    /*! IPv4 with options.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_IP4_OPTIONS = 3,
    /*! Any IPv4 packet.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_ANY_IP4 = 4,
    /*! IPv6 packet without any extension header.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_IP6_NO_EXT_HDR = 5,
    /*! IPv6 packet with one extension header.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_IP6_ONE_EXT_HDR = 6,
    /*! IPv6 packet with two or more extension headers.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_IP6_TWO_EXT_HDR = 7,
    /*! IPv6 packet.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_ANY_IP6 = 8,
    /*! IPv4 and IPv6 packets.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_IP = 9,
    /*! ARP/RARP.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_ARP = 10,
    /*! ARP request.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_ARP_REQUEST = 11,
    /*! ARP reply.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_ARP_REPLY = 12,
    /*! MPLS unicast frame (Ethertype = 0x8847).  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_UC_MPLS = 13,
    /*! MPLS multicast frame (Ethertype = 0x8848).  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_IP_TYPE_T_T_MC_MPLS = 14,
} bcm56996_a0_lrd_fp_em_presel_qual_ip_type_t_t;

/*! enum type for FP_EM_PRESEL_QUAL_LOOPBACK_TYPE_T
 * Enum for exact match FP pre-selection qualifier of loopbaack type.
 */
typedef enum bcm56996_a0_lrd_fp_em_presel_qual_loopback_type_t_e {
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_LOOPBACK_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_LOOPBACK_TYPE_T_T_GENERIC = 1,
} bcm56996_a0_lrd_fp_em_presel_qual_loopback_type_t_t;

/*! enum type for FP_EM_PRESEL_QUAL_TNL_TYPE_T
 * Enum for exact match FP pre-selection qualifier of tunnel type.
 */
typedef enum bcm56996_a0_lrd_fp_em_presel_qual_tnl_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_TNL_TYPE_T_T_ANY = 0,
    /*! IP-in-IP.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_TNL_TYPE_T_T_IP = 1,
    /*! MPLS.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_TNL_TYPE_T_T_MPLS = 2,
    /*! VXLAN tunnel packet.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_TNL_TYPE_T_T_VXLAN = 7,
    /*! SRv6 tunnel type.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_TNL_TYPE_T_T_SRV6 = 8,
    /*! L2 termination.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_TNL_TYPE_T_T_NONE = 9,
} bcm56996_a0_lrd_fp_em_presel_qual_tnl_type_t_t;

/*! enum type for FP_EM_PRESEL_QUAL_VXLT_LOOKUP_T
 * Enum for exact match FP pre-selection qualifier of VLAN translate lookup hit.
 */
typedef enum bcm56996_a0_lrd_fp_em_presel_qual_vxlt_lookup_t_e {
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_VXLT_LOOKUP_T_T_ANY = 0,
    /*! VLAN translate lookup not hit.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_VXLT_LOOKUP_T_T_NO_HIT = 1,
    /*! First VLAN translate lookup hit.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_VXLT_LOOKUP_T_T_FIRST_LOOKUP_HIT = 2,
    /*! Second VLAN translate lookup hit.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_VXLT_LOOKUP_T_T_SECOND_LOOKUP_HIT = 3,
    /*! First or second VLAN translate lookup hit.  */
    BCM56996_A0_LRD_FP_EM_PRESEL_QUAL_VXLT_LOOKUP_T_T_ANY_LOOKUP_HIT = 4,
} bcm56996_a0_lrd_fp_em_presel_qual_vxlt_lookup_t_t;

/*! enum type for FP_EM_QUAL_FWD_TYPE_T
 * Enum for exact match FP qualifier of forwarding Type.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_fwd_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_ANY = 0,
    /*! L2 switching forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_L2 = 1,
    /*! L3 routing forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_L3 = 2,
    /*! Shared VLAN L2 forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_L2_SHARED = 3,
    /*! VLAN based L2 forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_L2_INDEPENDENT = 4,
    /*! VFI based L2 forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_L2_VPN = 5,
    /*! L2 point to point VPN forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_L2_VPN_DIRECT = 6,
    /*! L3 predefined next hop forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_L3_DIRECT = 7,
    /*! MPLS switching forwarding.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_MPLS = 12,
    /*! Any other unknown forwarding type.  */
    BCM56996_A0_LRD_FP_EM_QUAL_FWD_TYPE_T_T_UNKNOWN = 22,
} bcm56996_a0_lrd_fp_em_qual_fwd_type_t_t;

/*! enum type for FP_EM_QUAL_ING_STP_STATE_T
 * Enum for exact match FP qualifier of exact match STP state.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_ing_stp_state_t_e {
    BCM56996_A0_LRD_FP_EM_QUAL_ING_STP_STATE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_EM_QUAL_ING_STP_STATE_T_T_DISABLE = 1,
    BCM56996_A0_LRD_FP_EM_QUAL_ING_STP_STATE_T_T_BLOCK = 2,
    BCM56996_A0_LRD_FP_EM_QUAL_ING_STP_STATE_T_T_LEARN = 4,
    BCM56996_A0_LRD_FP_EM_QUAL_ING_STP_STATE_T_T_FORWARD = 5,
} bcm56996_a0_lrd_fp_em_qual_ing_stp_state_t_t;

/*! enum type for FP_EM_QUAL_INNER_TPID_T
 * Enum for exact match FP qualifier of inner TPID.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_inner_tpid_t_e {
    BCM56996_A0_LRD_FP_EM_QUAL_INNER_TPID_T_T_ANY = 0,
    /*! TPID is 0x8100.  */
    BCM56996_A0_LRD_FP_EM_QUAL_INNER_TPID_T_T_TPID_8100 = 1,
    /*! TPID is 0x9100.  */
    BCM56996_A0_LRD_FP_EM_QUAL_INNER_TPID_T_T_TPID_9100 = 2,
    /*! TPID is 0x88a8.  */
    BCM56996_A0_LRD_FP_EM_QUAL_INNER_TPID_T_T_TPID_88A8 = 3,
    /*! TPID is different than above options.  */
    BCM56996_A0_LRD_FP_EM_QUAL_INNER_TPID_T_T_TPID_OTHER = 4,
} bcm56996_a0_lrd_fp_em_qual_inner_tpid_t_t;

/*! enum type for FP_EM_QUAL_IP_FRAG_T
 * Enum for exact match FP rule qualifier for IP fragments.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_ip_frag_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_FRAG_T_T_NON_OR_ANY = 0,
    /*! Non-fragmented packet.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_FRAG_T_T_NON = 1,
    /*! First fragment  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_FRAG_T_T_FIRST = 2,
    /*! Non-fragmented or first fragment.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_FRAG_T_T_NON_OR_FIRST = 3,
    /*! Not the first fragment.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_FRAG_T_T_NOT_FIRST = 4,
    /*! Any fragment of fragmented packet.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_FRAG_T_T_ANY = 5,
} bcm56996_a0_lrd_fp_em_qual_ip_frag_t_t;

/*! enum type for FP_EM_QUAL_IP_TYPE_T
 * Enum for exact match FP qualifier of IP type.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_ip_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_ANY = 0,
    /*! Non-IP packet.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_NON_IP = 1,
    /*! IPv4 without options.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_IP4_NO_OPTIONS = 2,
    /*! IPv4 with options.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_IP4_OPTIONS = 3,
    /*! Any IPv4 packet.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_ANY_IP4 = 4,
    /*! IPv6 packet without any extension header.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_IP6_NO_EXT_HDR = 5,
    /*! IPv6 packet with one extension header.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_IP6_ONE_EXT_HDR = 6,
    /*! IPv6 packet with two or more extension headers.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_IP6_TWO_EXT_HDR = 7,
    /*! IPv6 packet.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_ANY_IP6 = 8,
    /*! IPv4 and IPv6 packets.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_IP = 9,
    /*! ARP/RARP.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_ARP = 10,
    /*! ARP request.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_ARP_REQUEST = 11,
    /*! ARP reply.  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_ARP_REPLY = 12,
    /*! MPLS unicast frame (Ethertype = 0x8847).  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_UC_MPLS = 13,
    /*! MPLS multicast frame (Ethertype = 0x8848).  */
    BCM56996_A0_LRD_FP_EM_QUAL_IP_TYPE_T_T_MC_MPLS = 14,
} bcm56996_a0_lrd_fp_em_qual_ip_type_t_t;

/*! enum type for FP_EM_QUAL_L2_FORMAT_T
 * Enum for exact match FP qualifier of L2 format.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_l2_format_t_e {
    /*! Do not qualify on L2 format.  */
    BCM56996_A0_LRD_FP_EM_QUAL_L2_FORMAT_T_T_ANY = 0,
    /*! Ethernet 2 (802.2).  */
    BCM56996_A0_LRD_FP_EM_QUAL_L2_FORMAT_T_T_ETHER_2 = 1,
    /*! Sub-network access protocol.  */
    BCM56996_A0_LRD_FP_EM_QUAL_L2_FORMAT_T_T_SNAP = 2,
    /*! Logical link control.  */
    BCM56996_A0_LRD_FP_EM_QUAL_L2_FORMAT_T_T_LLC = 3,
    /*! 802.3 frame format.  */
    BCM56996_A0_LRD_FP_EM_QUAL_L2_FORMAT_T_T_IEEE802DOT3 = 4,
} bcm56996_a0_lrd_fp_em_qual_l2_format_t_t;

/*! enum type for FP_EM_QUAL_LOOPBACK_TYPE_T
 * Enum for exact match FP rule qualifier of loopback type.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_loopback_type_t_e {
    BCM56996_A0_LRD_FP_EM_QUAL_LOOPBACK_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_EM_QUAL_LOOPBACK_TYPE_T_T_GENERIC = 1,
} bcm56996_a0_lrd_fp_em_qual_loopback_type_t_t;

/*! enum type for FP_EM_QUAL_MPLS_FWD_LABEL_ACTION_T
 * Enum for exact match FP rule qualifier of MPLS forward label action.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_mpls_fwd_label_action_t_e {
    /*! MPLS forward label action is invalid.  */
    BCM56996_A0_LRD_FP_EM_QUAL_MPLS_FWD_LABEL_ACTION_T_T_INVALID = 0,
    /*! MPLS forward label action is PHP.  */
    BCM56996_A0_LRD_FP_EM_QUAL_MPLS_FWD_LABEL_ACTION_T_T_PHP = 1,
    /*! MPLS forward label action is SWAP.  */
    BCM56996_A0_LRD_FP_EM_QUAL_MPLS_FWD_LABEL_ACTION_T_T_SWAP = 2,
    /*!
     * POP the MPLS label. This action is valid for MPLS scenarios
     *  which supports more than 3 label lookups through loopback.
     */
    BCM56996_A0_LRD_FP_EM_QUAL_MPLS_FWD_LABEL_ACTION_T_T_POP = 3,
    /*! POP the MPLS label and use L3 VPN.  */
    BCM56996_A0_LRD_FP_EM_QUAL_MPLS_FWD_LABEL_ACTION_T_T_POP_USE_L3_VPN = 5,
} bcm56996_a0_lrd_fp_em_qual_mpls_fwd_label_action_t_t;

/*! enum type for FP_EM_QUAL_OUTER_TPID_T
 * Enum for exact match FP qualifier of outer TPID.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_outer_tpid_t_e {
    BCM56996_A0_LRD_FP_EM_QUAL_OUTER_TPID_T_T_ANY = 0,
    /*! TPID is 0x8100.  */
    BCM56996_A0_LRD_FP_EM_QUAL_OUTER_TPID_T_T_TPID_8100 = 1,
    /*! TPID is 0x9100.  */
    BCM56996_A0_LRD_FP_EM_QUAL_OUTER_TPID_T_T_TPID_9100 = 2,
    /*! TPID is 0x88a8.  */
    BCM56996_A0_LRD_FP_EM_QUAL_OUTER_TPID_T_T_TPID_88A8 = 3,
    /*! TPID is different than above options.  */
    BCM56996_A0_LRD_FP_EM_QUAL_OUTER_TPID_T_T_TPID_OTHER = 4,
} bcm56996_a0_lrd_fp_em_qual_outer_tpid_t_t;

/*! enum type for FP_EM_QUAL_TNL_TYPE_T
 * Enum for exact match FP rule qualifier of tunnel type.
 */
typedef enum bcm56996_a0_lrd_fp_em_qual_tnl_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_EM_QUAL_TNL_TYPE_T_T_ANY = 0,
    /*! IP-in-IP.  */
    BCM56996_A0_LRD_FP_EM_QUAL_TNL_TYPE_T_T_IP = 1,
    /*! MPLS.  */
    BCM56996_A0_LRD_FP_EM_QUAL_TNL_TYPE_T_T_MPLS = 2,
    /*! VXLAN tunnel packet.  */
    BCM56996_A0_LRD_FP_EM_QUAL_TNL_TYPE_T_T_VXLAN = 7,
    BCM56996_A0_LRD_FP_EM_QUAL_TNL_TYPE_T_T_SRV6 = 8,
    /*! L2 termination.  */
    BCM56996_A0_LRD_FP_EM_QUAL_TNL_TYPE_T_T_NONE = 9,
} bcm56996_a0_lrd_fp_em_qual_tnl_type_t_t;

/*! enum type for FP_ING_ACTION_CLASS_ID_TYPE_T
 * Enum for egress FP qualifier of ingress to egress class ID type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_action_class_id_type_t_e {
    /*! Invalid.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_INVALID = 0,
    /*! Class ID based on source port.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_PORT_SYSTEM = 1,
    /*! Class ID based on compression ID A.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_COMPRESSION_ID_A = 2,
    /*! Class ID assigned by L3_IIF.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_L3_IIF = 3,
    /*! Upper class ID assigned by VLAN FP.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_FP_VLAN_CLASS_1 = 4,
    /*! Lower class ID assigned by VLAN FP.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_FP_VLAN_CLASS_0 = 5,
    /*! Class ID based on L2 source address.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_L2_SRC = 6,
    /*! Class ID based on L2 destination address.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_L2_DST = 7,
    /*! Class ID based on L3 source address.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_L3_SRC = 8,
    /*! Class ID based on L3 destination address.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_L3_DST = 9,
    /*! Class ID based on VLAN.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_VLAN = 10,
    /*! Class ID based on VRF.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_VRF = 11,
    /*! Class ID based on compression ID B.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_COMPRESSION_ID_B = 12,
    /*! Exact mach Class ID.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_EM_CLASS_ID = 13,
    /*! Class ID based on source virtual port(SVP).  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_SVP = 14,
    /*! Class ID assinged by ingress FP.  */
    BCM56996_A0_LRD_FP_ING_ACTION_CLASS_ID_TYPE_T_T_FP_ING = 15,
} bcm56996_a0_lrd_fp_ing_action_class_id_type_t_t;

/*! enum type for FP_ING_ACTION_COLOR_T
 * Enum for ingress FP action for color type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_action_color_t_e {
    /*! No operation.  */
    BCM56996_A0_LRD_FP_ING_ACTION_COLOR_T_T_NO_OP = 0,
    /*! Color green.  */
    BCM56996_A0_LRD_FP_ING_ACTION_COLOR_T_T_GREEN = 1,
    /*! Color yellow.  */
    BCM56996_A0_LRD_FP_ING_ACTION_COLOR_T_T_YELLOW = 2,
    /*! Color red.  */
    BCM56996_A0_LRD_FP_ING_ACTION_COLOR_T_T_RED = 3,
} bcm56996_a0_lrd_fp_ing_action_color_t_t;

/*! enum type for FP_ING_ACTION_HIGIG_CLASS_ID_SELECT_T
 * Enum for ingress FP action for Higig class ID selection.
 */
typedef enum bcm56996_a0_lrd_fp_ing_action_higig_class_id_select_t_e {
    /*! Not assigned.  */
    BCM56996_A0_LRD_FP_ING_ACTION_HIGIG_CLASS_ID_SELECT_T_T_NO_ASSIGNED = 0,
    /*! Ingress class ID.  */
    BCM56996_A0_LRD_FP_ING_ACTION_HIGIG_CLASS_ID_SELECT_T_T_ING_CLASS_ID = 1,
    /*! Use port.  */
    BCM56996_A0_LRD_FP_ING_ACTION_HIGIG_CLASS_ID_SELECT_T_T_USE_PORT = 4,
} bcm56996_a0_lrd_fp_ing_action_higig_class_id_select_t_t;

/*! enum type for FP_ING_ENTRY_STATE_T
 * Enum defines operation state of ingress FP entry
 */
typedef enum bcm56996_a0_lrd_fp_ing_entry_state_t_e {
    /*! Success.  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_SUCCESS = 0,
    /*! Group is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_GRP_TEMPLATE_NOT_EXISTS = 1,
    /*! Rule is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_RULE_TEMPLATE_NOT_EXISTS = 2,
    /*! Policy is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_POLICY_TEMPLATE_NOT_EXISTS = 3,
    /*!
     * One or more qualifiers specified in the rule are not present
     *  in the group.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_RULE_QSET_NOT_IN_GRP = 4,
    /*!
     * One or more qualifiers data or mask is more than
     *  the bitmap specified in group.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_RULE_QSET_WIDTH_EXCEEDS = 5,
    /*! Meter is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_METER_TEMPLATE_NOT_EXISTS = 6,
    /*! Counter is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_COUNTER_TEMPLATE_NOT_EXISTS = 7,
    /*! PDD is not yet created but associated to the group or entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_PDD_TEMPLATE_NOT_EXISTS = 8,
    /*! Entry group masked by another group  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_GRP_MASKED_BY_ANOTHER = 9,
    /*! Presel entries are not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_PRESEL_ENTRY_NOT_EXISTS = 10,
    /*! Meter pipe id is not matching with group pipe ID  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_BCMFP_ENTRY_METER_PIPE_ID_MISMATCH = 11,
    /*! SBR is not yet created but associated to the group or entry  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_SBR_TEMPLATE_NOT_EXISTS = 12,
    /*! Presel group is not yet created but associated to the group  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_PRESEL_GROUP_NOT_EXISTS = 13,
    /*! Default PDD is not yet created but associated to the group  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_DEFAULT_PDD_TEMPLATE_NOT_EXISTS = 14,
    /*! Default policy is not yet created but associated to the group  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_DEFAULT_POLICY_TEMPLATE_NOT_EXISTS = 15,
    /*!
     * Policy associated to entry is created but PDD associated to the
     *  entry or group is not yet created.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_POLICY_EXISTS_PDD_NOT_EXISTS = 16,
    /*!
     * Default policy associated to the group is created but default
     *  PDD associated to the entry or group is not yet created.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_DEFAULT_POLICY_EXISTS_DEFAULT_PDD_NOT_EXISTS = 17,
    /*!
     * Group is not operational. That means QSET and QSET provided in
     *  group are not fit in given mode.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_GROUP_TEMPLATE_NOT_OPERATIONAL = 19,
    /*! Conflicting actions present in policy.  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_CONFLICTING_ACTIONS_PRESENT_IN_POLICY = 20,
    /*! Conflicting actions present in policy.  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_CONFLICTING_ACTIONS_PRESENT_IN_DEFAULT_POLICY = 21,
    /*!
     * One or more qualifiers specified in presel entry are not present
     *  in the presel group.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_PRESEL_ENTRY_QSET_NOT_IN_PRESEL_GROUP = 22,
    /*! One or more actions specified in policy are not present PDD.  */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_POLICY_ASET_NOT_IN_PDD = 23,
    /*!
     * One or more actions specified in default policy are not
     *  present in default PDD.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_DEFAULT_POLICY_ASET_NOT_IN_DEFAULT_PDD = 24,
    /*!
     * One or more qualifiers data or mask is more than the
     *  qualifier bitmap specified in presel group.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_PRESEL_ENTRY_QSET_WIDTH_EXCEEDS = 25,
    /*!
     * Presel entries specified in group are created but presel group
     *  is not created.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_PRESEL_ENTRIES_EXISTS_PRESEL_GROUP_NOT_EXISTS = 26,
    /*! Qset doesnt fit the group configuration provided.\n */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_GROUP_QSET_DOESNT_FIT = 28,
    /*!
     * Already a group with same priority exists, which is of
     *  diferent group mode, and sharing resources is not feasible with
     *  the current configuration.
     */
    BCM56996_A0_LRD_FP_ING_ENTRY_STATE_T_T_GROUP_MULTIMODE_CHECK_FAILED = 42,
} bcm56996_a0_lrd_fp_ing_entry_state_t_t;

/*! enum type for FP_ING_GRP_MODE_T
 * Enum defines group mode for ingress FP.
 */
typedef enum bcm56996_a0_lrd_fp_ing_grp_mode_t_e {
    /*! Single wide mode.  */
    BCM56996_A0_LRD_FP_ING_GRP_MODE_T_T_SINGLE = 1,
    /*! Double wide intra-slice mode.  */
    BCM56996_A0_LRD_FP_ING_GRP_MODE_T_T_DBLINTRA = 2,
    /*! Double wide inter-slice mode.  */
    BCM56996_A0_LRD_FP_ING_GRP_MODE_T_T_DBLINTER = 3,
    /*! Triple wide mode  */
    BCM56996_A0_LRD_FP_ING_GRP_MODE_T_T_TRIPLE = 4,
} bcm56996_a0_lrd_fp_ing_grp_mode_t_t;

/*! enum type for FP_ING_PRESEL_QUAL_FWD_TYPE_T
 * Enum for Ingress FP Pre-Selection Qualifier of Forwarding Type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_presel_qual_fwd_type_t_e {
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_L2 = 1,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_L3 = 2,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_L2_SHARED = 3,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_L2_INDEPENDENT = 4,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_L2_VPN = 5,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_L2_VPN_DIRECT = 6,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_L3_DIRECT = 7,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_MPLS = 12,
    /*! Any other unknown forwarding type.  */
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_FWD_TYPE_T_T_UNKNOWN = 22,
} bcm56996_a0_lrd_fp_ing_presel_qual_fwd_type_t_t;

/*! enum type for FP_ING_PRESEL_QUAL_ING_STP_STATE_T
 * Enum for ingress FP pre-selection qualifier of ingress STP state.
 */
typedef enum bcm56996_a0_lrd_fp_ing_presel_qual_ing_stp_state_t_e {
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_DISABLE = 1,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_BLOCK = 2,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_LEARN = 4,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_FORWARD = 5,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_LEARN_FORWARD = 6,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_LEARN_DISABLE = 7,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_FORWARD_BLOCK = 8,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_ING_STP_STATE_T_T_DISABLE_BLOCK = 9,
} bcm56996_a0_lrd_fp_ing_presel_qual_ing_stp_state_t_t;

/*! enum type for FP_ING_PRESEL_QUAL_IP_TYPE_T
 * Enum for Ingress FP Pre-Selection Qualifier of IP Type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_presel_qual_ip_type_t_e {
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_NON_IP = 1,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_IP4_NO_OPTIONS = 2,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_IP4_OPTIONS = 3,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_ANY_IP4 = 4,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_IP6_NO_EXT_HDR = 5,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_IP6_ONE_EXT_HDR = 6,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_IP6_TWO_EXT_HDR = 7,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_ANY_IP6 = 8,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_IP = 9,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_ARP = 10,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_ARP_REQUEST = 11,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_ARP_REPLY = 12,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_UC_MPLS = 13,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_IP_TYPE_T_T_MC_MPLS = 14,
} bcm56996_a0_lrd_fp_ing_presel_qual_ip_type_t_t;

/*! enum type for FP_ING_PRESEL_QUAL_LOOPBACK_TYPE_T
 * Enum for ingress FP pre-selection qualifier of loopbaack type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_presel_qual_loopback_type_t_e {
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_LOOPBACK_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_LOOPBACK_TYPE_T_T_GENERIC = 1,
} bcm56996_a0_lrd_fp_ing_presel_qual_loopback_type_t_t;

/*! enum type for FP_ING_PRESEL_QUAL_TNL_TYPE_T
 * Enum for ingress FP pre-selection qualifier of tunnel type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_presel_qual_tnl_type_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_TNL_TYPE_T_T_ANY = 0,
    /*! IP-in-IP.  */
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_TNL_TYPE_T_T_IP = 1,
    /*! MPLS.  */
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_TNL_TYPE_T_T_MPLS = 2,
    /*! VXLAN tunnel packet.  */
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_TNL_TYPE_T_T_VXLAN = 7,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_TNL_TYPE_T_T_SRV6 = 8,
    /*! L2 termination.  */
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_TNL_TYPE_T_T_NONE = 9,
} bcm56996_a0_lrd_fp_ing_presel_qual_tnl_type_t_t;

/*! enum type for FP_ING_PRESEL_QUAL_VXLT_LOOKUP_T
 * Enum for ingress FP pre-selection qualifier of VLAN translate lookup hit.
 */
typedef enum bcm56996_a0_lrd_fp_ing_presel_qual_vxlt_lookup_t_e {
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_VXLT_LOOKUP_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_VXLT_LOOKUP_T_T_NO_HIT = 1,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_VXLT_LOOKUP_T_T_FIRST_LOOKUP_HIT = 2,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_VXLT_LOOKUP_T_T_SECOND_LOOKUP_HIT = 3,
    BCM56996_A0_LRD_FP_ING_PRESEL_QUAL_VXLT_LOOKUP_T_T_ANY_LOOKUP_HIT = 4,
} bcm56996_a0_lrd_fp_ing_presel_qual_vxlt_lookup_t_t;

/*! enum type for FP_ING_QUAL_COLOR_T
 * Enum for ingress FP rule qualifier of color type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_color_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_COLOR_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_QUAL_COLOR_T_T_GREEN = 1,
    BCM56996_A0_LRD_FP_ING_QUAL_COLOR_T_T_YELLOW = 2,
    BCM56996_A0_LRD_FP_ING_QUAL_COLOR_T_T_RED = 3,
} bcm56996_a0_lrd_fp_ing_qual_color_t_t;

/*! enum type for FP_ING_QUAL_FWD_TYPE_T
 * Enum for ingress FP qualifier of forwarding type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_fwd_type_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_L2 = 1,
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_L3 = 2,
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_L2_SHARED = 3,
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_L2_INDEPENDENT = 4,
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_L2_VPN = 5,
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_L3_DIRECT = 7,
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_MPLS = 12,
    /*! Any other forwarding type.  */
    BCM56996_A0_LRD_FP_ING_QUAL_FWD_TYPE_T_T_UNKNOWN = 22,
} bcm56996_a0_lrd_fp_ing_qual_fwd_type_t_t;

/*! enum type for FP_ING_QUAL_ING_STP_STATE_T
 * Enum for Ingress FP Qualifier of Ingress STP State.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_ing_stp_state_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_DISABLE = 1,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_BLOCK = 2,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_LEARN = 4,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_FORWARD = 5,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_LEARN_FORWARD = 6,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_LEARN_DISABLE = 7,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_FORWARD_BLOCK = 8,
    BCM56996_A0_LRD_FP_ING_QUAL_ING_STP_STATE_T_T_DISABLE_BLOCK = 9,
} bcm56996_a0_lrd_fp_ing_qual_ing_stp_state_t_t;

/*! enum type for FP_ING_QUAL_IP_FRAG_T
 * Enum for Ingress FP Rule Qualifier for IP fragments.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_ip_frag_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_ING_QUAL_IP_FRAG_T_T_NON_OR_ANY = 0,
    /*! Non-fragmented packet.  */
    BCM56996_A0_LRD_FP_ING_QUAL_IP_FRAG_T_T_NON = 1,
    /*! First fragment  */
    BCM56996_A0_LRD_FP_ING_QUAL_IP_FRAG_T_T_FIRST = 2,
    /*! Non-fragmented or first fragment.  */
    BCM56996_A0_LRD_FP_ING_QUAL_IP_FRAG_T_T_NON_OR_FIRST = 3,
    /*! Not the first fragment.  */
    BCM56996_A0_LRD_FP_ING_QUAL_IP_FRAG_T_T_NOT_FIRST = 4,
    /*! Any fragment of fragmented packet.  */
    BCM56996_A0_LRD_FP_ING_QUAL_IP_FRAG_T_T_ANY = 5,
} bcm56996_a0_lrd_fp_ing_qual_ip_frag_t_t;

/*! enum type for FP_ING_QUAL_IP_TYPE_T
 * Enum for ingress FP qualifier of IP type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_ip_type_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_NON_IP = 1,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_IP4_NO_OPTIONS = 2,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_IP4_OPTIONS = 3,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_ANY_IP4 = 4,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_IP6_NO_EXT_HDR = 5,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_IP6_ONE_EXT_HDR = 6,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_IP6_TWO_EXT_HDR = 7,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_ANY_IP6 = 8,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_IP = 9,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_ARP = 10,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_ARP_REQUEST = 11,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_ARP_REPLY = 12,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_UC_MPLS = 13,
    BCM56996_A0_LRD_FP_ING_QUAL_IP_TYPE_T_T_MC_MPLS = 14,
} bcm56996_a0_lrd_fp_ing_qual_ip_type_t_t;

/*! enum type for FP_ING_QUAL_L2_FORMAT_T
 * Enum for ingress FP qualifier of L2 format.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_l2_format_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_L2_FORMAT_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_QUAL_L2_FORMAT_T_T_ETHER_2 = 1,
    BCM56996_A0_LRD_FP_ING_QUAL_L2_FORMAT_T_T_SNAP = 2,
    BCM56996_A0_LRD_FP_ING_QUAL_L2_FORMAT_T_T_LLC = 3,
    BCM56996_A0_LRD_FP_ING_QUAL_L2_FORMAT_T_T_IEEE802DOT3 = 4,
    BCM56996_A0_LRD_FP_ING_QUAL_L2_FORMAT_T_T_OTHER = 8,
} bcm56996_a0_lrd_fp_ing_qual_l2_format_t_t;

/*! enum type for FP_ING_QUAL_LOOPBACK_TYPE_T
 * Enum for ingress FP rule qualifier of loopback type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_loopback_type_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_LOOPBACK_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_QUAL_LOOPBACK_TYPE_T_T_GENERIC = 1,
} bcm56996_a0_lrd_fp_ing_qual_loopback_type_t_t;

/*! enum type for FP_ING_QUAL_MPLS_FWD_LABEL_ACTION_T
 * Enum for Ingress FP Rule Qualifier of MPLS Forward Label Action.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_mpls_fwd_label_action_t_e {
    /*! MPLS forward label action is invalid.  */
    BCM56996_A0_LRD_FP_ING_QUAL_MPLS_FWD_LABEL_ACTION_T_T_INVALID = 0,
    /*! MPLS forward label action is PHP.  */
    BCM56996_A0_LRD_FP_ING_QUAL_MPLS_FWD_LABEL_ACTION_T_T_PHP = 1,
    /*! MPLS forward label action is swap.  */
    BCM56996_A0_LRD_FP_ING_QUAL_MPLS_FWD_LABEL_ACTION_T_T_SWAP = 2,
    /*!
     * POP the MPLS label. This action is valid for MPLS scenarios
     *  which supports more than 3 label lookups through loopback.
     */
    BCM56996_A0_LRD_FP_ING_QUAL_MPLS_FWD_LABEL_ACTION_T_T_POP = 3,
    /*! POP the MPLS label and use L3 VPN.  */
    BCM56996_A0_LRD_FP_ING_QUAL_MPLS_FWD_LABEL_ACTION_T_T_POP_USE_L2_VPN = 4,
    /*! POP the MPLS label and use L3 VPN.  */
    BCM56996_A0_LRD_FP_ING_QUAL_MPLS_FWD_LABEL_ACTION_T_T_POP_USE_L3_VPN = 5,
} bcm56996_a0_lrd_fp_ing_qual_mpls_fwd_label_action_t_t;

/*! enum type for FP_ING_QUAL_OUTER_TPID_T
 * Enum for Ingress FP Qualifier of Outer TPID.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_outer_tpid_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_OUTER_TPID_T_T_ANY = 0,
    /*! TPID is 0x8100.  */
    BCM56996_A0_LRD_FP_ING_QUAL_OUTER_TPID_T_T_TPID_8100 = 1,
    /*! TPID is 0x9100.  */
    BCM56996_A0_LRD_FP_ING_QUAL_OUTER_TPID_T_T_TPID_9100 = 2,
    /*! TPID is 0x88a8.  */
    BCM56996_A0_LRD_FP_ING_QUAL_OUTER_TPID_T_T_TPID_88A8 = 3,
    /*! TPID is different than above options.  */
    BCM56996_A0_LRD_FP_ING_QUAL_OUTER_TPID_T_T_TPID_OTHER = 4,
} bcm56996_a0_lrd_fp_ing_qual_outer_tpid_t_t;

/*! enum type for FP_ING_QUAL_TNL_TYPE_T
 * Enum for Ingress FP Rule Qualifier of Tunnel Type.
 */
typedef enum bcm56996_a0_lrd_fp_ing_qual_tnl_type_t_e {
    BCM56996_A0_LRD_FP_ING_QUAL_TNL_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_ING_QUAL_TNL_TYPE_T_T_IP = 1,
    BCM56996_A0_LRD_FP_ING_QUAL_TNL_TYPE_T_T_MPLS = 2,
    BCM56996_A0_LRD_FP_ING_QUAL_TNL_TYPE_T_T_VXLAN = 7,
    BCM56996_A0_LRD_FP_ING_QUAL_TNL_TYPE_T_T_SRV6 = 8,
    BCM56996_A0_LRD_FP_ING_QUAL_TNL_TYPE_T_T_NONE = 9,
} bcm56996_a0_lrd_fp_ing_qual_tnl_type_t_t;

/*! enum type for FP_LOOPBACK_TYPE_T
 * Enum for FP rule qualifier of loopback type.
 */
typedef enum bcm56996_a0_lrd_fp_loopback_type_t_e {
    BCM56996_A0_LRD_FP_LOOPBACK_TYPE_T_T_ANY = 0,
    /*! Tunnel.  */
    BCM56996_A0_LRD_FP_LOOPBACK_TYPE_T_T_TUNNEL = 1,
    /*! TRILL network.  */
    BCM56996_A0_LRD_FP_LOOPBACK_TYPE_T_T_TRILL_NETWORK = 2,
    /*! TRILL access type.  */
    BCM56996_A0_LRD_FP_LOOPBACK_TYPE_T_T_TRILL_ACCESS = 3,
    /*! TRILL masquerade type.  */
    BCM56996_A0_LRD_FP_LOOPBACK_TYPE_T_T_TRILL_MASQUERADE = 4,
} bcm56996_a0_lrd_fp_loopback_type_t_t;

/*! enum type for FP_SRC_CLASS_MODE_T
 * Enum for FP source class mode.
 */
typedef enum bcm56996_a0_lrd_fp_src_class_mode_t_e {
    /*!
     * SRC_CLASS for legacy XGS style devices.
     *  Following bits are used for below class IDs.
     *  Class ID         | From  |   To
     *  PORT_CLASS_ID    |    0  |    7
     *  UDF_CLASS_ID     |    8  |   15
     *  VFP_CLASS_ID     |   16  |   27
     *  VLAN_CLASS_ID    |   28  |   31
     */
    BCM56996_A0_LRD_FP_SRC_CLASS_MODE_T_T_LEGACY = 0,
    /*!
     * SRC_CLASS for SDN deployments.
     *  Following bits are used for below class IDs.
     *  Class ID         | From  |   To
     *  L3_IIF_CLASS_ID  |    0  |    3
     *  PORT_CLASS_ID    |    4  |    7
     *  UDF_CLASS_ID     |    8  |   11
     *  VFP_CLASS_ID     |   12  |   23
     *  VLAN_CLASS_ID    |   24  |   27
     */
    BCM56996_A0_LRD_FP_SRC_CLASS_MODE_T_T_SDN = 1,
    /*!
     * SRC_CLASS for balanced.
     *  Following bits are used for below class IDs.
     *  Class ID         | From  |   To
     *  L3_IIF_CLASS_ID  |    0  |    3
     *  PORT_CLASS_ID    |    4  |   11
     *  UDF_CLASS_ID     |   12  |   15
     *  VFP_CLASS_ID     |   16  |   23
     *  VLAN_CLASS_ID    |   24  |   27
     */
    BCM56996_A0_LRD_FP_SRC_CLASS_MODE_T_T_BALANCED = 2,
    /*!
     * SRC_CLASS is for overlay networks.
     *  Following bits are used for below class IDs.
     *  Class ID         | From  |   To
     *  L3_IIF_CLASS_ID  |    0  |    7
     *  PORT_CLASS_ID    |    8  |   11
     *  SVP_CLASS_ID     |   12  |   19
     *  VFP_CLASS_ID     |   20  |   23
     *  VLAN_CLASS_ID    |   16  |   23
     */
    BCM56996_A0_LRD_FP_SRC_CLASS_MODE_T_T_OVERLAY = 3,
} bcm56996_a0_lrd_fp_src_class_mode_t_t;

/*! enum type for FP_VLAN_ACTION_COLOR_T
 * Enum for VLAN FP Action for Color type.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_action_color_t_e {
    /*! No operation.  */
    BCM56996_A0_LRD_FP_VLAN_ACTION_COLOR_T_T_NO_OP = 0,
    /*! Color green.  */
    BCM56996_A0_LRD_FP_VLAN_ACTION_COLOR_T_T_GREEN = 1,
    /*! Color yellow.  */
    BCM56996_A0_LRD_FP_VLAN_ACTION_COLOR_T_T_YELLOW = 2,
    /*! Color red.  */
    BCM56996_A0_LRD_FP_VLAN_ACTION_COLOR_T_T_RED = 3,
} bcm56996_a0_lrd_fp_vlan_action_color_t_t;

/*! enum type for FP_VLAN_ACTION_TNL_TYPE_T
 * Enum for L3 tunnel type.
 *  0x0 = IP6TOIP4
 *  0x1 = ISATAP
 *  0x2 = IP6TOIP4Secure
 */
typedef enum bcm56996_a0_lrd_fp_vlan_action_tnl_type_t_e {
    /*! IP6TOIP4 tunnel.  */
    BCM56996_A0_LRD_FP_VLAN_ACTION_TNL_TYPE_T_T_IP6TOIP4 = 0,
    /*! ISATAP tunnel.  */
    BCM56996_A0_LRD_FP_VLAN_ACTION_TNL_TYPE_T_T_ISATAP = 1,
    /*! IP6TOIP4SECURE tunnel.  */
    BCM56996_A0_LRD_FP_VLAN_ACTION_TNL_TYPE_T_T_IP6TOIP4SECURE = 2,
} bcm56996_a0_lrd_fp_vlan_action_tnl_type_t_t;

/*! enum type for FP_VLAN_ENTRY_STATE_T
 * Enum defines operation state of vlan FP entry
 */
typedef enum bcm56996_a0_lrd_fp_vlan_entry_state_t_e {
    /*! Success.  */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_SUCCESS = 0,
    /*! Group is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_GRP_TEMPLATE_NOT_EXISTS = 1,
    /*! Rule is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_RULE_TEMPLATE_NOT_EXISTS = 2,
    /*! Policy is not yet created but associated to the entry  */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_POLICY_TEMPLATE_NOT_EXISTS = 3,
    /*!
     * One or more qualifiers specified in the rule are not present
     *  in the group.
     */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_RULE_QSET_NOT_IN_GRP = 4,
    /*!
     * One or more qualifiers data or mask is more than
     *  the bitmap specified in group.
     */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_RULE_QSET_WIDTH_EXCEEDS = 5,
    /*!
     * Group is not operational. That means QSET and QSET provided in
     *  group are not fit in given mode.
     */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_GROUP_TEMPLATE_NOT_OPERATIONAL = 19,
    /*! Conflicting actions present in policy.  */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_CONFLICTING_ACTIONS_PRESENT_IN_POLICY = 20,
    /*! Qset doesnt fit the group configuration provided.\n */
    BCM56996_A0_LRD_FP_VLAN_ENTRY_STATE_T_T_GROUP_QSET_DOESNT_FIT = 28,
} bcm56996_a0_lrd_fp_vlan_entry_state_t_t;

/*! enum type for FP_VLAN_GRP_MODE_T
 * Enum defines group mode for Vlan FP.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_grp_mode_t_e {
    /*! Single wide mode.  */
    BCM56996_A0_LRD_FP_VLAN_GRP_MODE_T_T_SINGLE = 1,
    /*! Double wide intra-slice mode.  */
    BCM56996_A0_LRD_FP_VLAN_GRP_MODE_T_T_DBLINTRA = 2,
    /*! Double wide inter-slice mode.  */
    BCM56996_A0_LRD_FP_VLAN_GRP_MODE_T_T_DBLINTER = 3,
    /*! Quad wide mode  */
    BCM56996_A0_LRD_FP_VLAN_GRP_MODE_T_T_QUAD = 5,
} bcm56996_a0_lrd_fp_vlan_grp_mode_t_t;

/*! enum type for FP_VLAN_PRIORITY_T
 * Enum for VLAN FP Action for ACTION_PRI_MODIFIER.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_priority_t_e {
    /*! Prioritize VLAN FP over all other sources.\n */
    BCM56996_A0_LRD_FP_VLAN_PRIORITY_T_T_PRIORITY_STRENGTH_HIGHEST = 0,
    /*!
     * Prioritizes L3_TNL/MPLS over VLAN FP, PORT and VLAN_MPLS.
     *  Thus the order of assignment priority is
     *  L3_TUNNEL/MPLS > VLAN FP > PORT> VLAN_MPLS.
     */
    BCM56996_A0_LRD_FP_VLAN_PRIORITY_T_T_PRIORITY_STRENGTH_HIGH = 1,
    /*!
     * Prioritizes L3_TNL/MPLS and PORT over VLAN FP and VFI.
     *  Thus the order of assignment priority is
     *  L3_TUNNEL/MPLS > PORT>  VLAN FP > VFI.
     */
    BCM56996_A0_LRD_FP_VLAN_PRIORITY_T_T_PRIORITY_STRENGTH_LOW = 2,
} bcm56996_a0_lrd_fp_vlan_priority_t_t;

/*! enum type for FP_VLAN_QUAL_IP_FRAG_T
 * Enum for vlan FP rule qualifier for IP fragments.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_qual_ip_frag_t_e {
    /*! Don't care.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_FRAG_T_T_NON_OR_ANY = 0,
    /*! Non-fragmented packet.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_FRAG_T_T_NON = 1,
    /*! First fragment  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_FRAG_T_T_FIRST = 2,
    /*! Non-fragmented or first fragment.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_FRAG_T_T_NON_OR_FIRST = 3,
    /*! Not the first fragment.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_FRAG_T_T_NOT_FIRST = 4,
    /*! Any fragment of fragmented packet.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_FRAG_T_T_ANY = 5,
} bcm56996_a0_lrd_fp_vlan_qual_ip_frag_t_t;

/*! enum type for FP_VLAN_QUAL_IP_PROTO_COMMON_T
 * Enums for some commonly used IP protocols.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_qual_ip_proto_common_t_e {
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_TCP = 1,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_UDP = 2,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_IGMP = 3,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_ICMP = 4,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_IP6_ICMP = 5,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_IP6_HOP_BY_HOP = 6,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_IP_IN_IP = 7,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_TCP_UDP = 8,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_PROTO_COMMON_T_T_UNKNOWN = 9,
} bcm56996_a0_lrd_fp_vlan_qual_ip_proto_common_t_t;

/*! enum type for FP_VLAN_QUAL_IP_TYPE_T
 * Enum for vlan FP qualifier of IP type.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_qual_ip_type_t_e {
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_NON_IP = 1,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_IP4_NO_OPTIONS = 2,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_IP4_OPTIONS = 3,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_ANY_IP4 = 4,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_IP6_NO_EXT_HDR = 5,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_IP6_ONE_EXT_HDR = 6,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_IP6_TWO_EXT_HDR = 7,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_ANY_IP6 = 8,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_IP = 9,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_ARP = 10,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_ARP_REQUEST = 11,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_ARP_REPLY = 12,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_UC_MPLS = 13,
    BCM56996_A0_LRD_FP_VLAN_QUAL_IP_TYPE_T_T_MC_MPLS = 14,
} bcm56996_a0_lrd_fp_vlan_qual_ip_type_t_t;

/*! enum type for FP_VLAN_QUAL_L2_FORMAT_T
 * Enum for vlan FP qualifier of L2 format.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_qual_l2_format_t_e {
    BCM56996_A0_LRD_FP_VLAN_QUAL_L2_FORMAT_T_T_ANY = 0,
    BCM56996_A0_LRD_FP_VLAN_QUAL_L2_FORMAT_T_T_ETHER_2 = 1,
    BCM56996_A0_LRD_FP_VLAN_QUAL_L2_FORMAT_T_T_SNAP = 2,
    BCM56996_A0_LRD_FP_VLAN_QUAL_L2_FORMAT_T_T_LLC = 3,
    BCM56996_A0_LRD_FP_VLAN_QUAL_L2_FORMAT_T_T_IEEE802DOT3 = 4,
} bcm56996_a0_lrd_fp_vlan_qual_l2_format_t_t;

/*! enum type for FP_VLAN_QUAL_OUTER_TPID_T
 * Enum for ingress FP qualifier of outer TPID.
 */
typedef enum bcm56996_a0_lrd_fp_vlan_qual_outer_tpid_t_e {
    BCM56996_A0_LRD_FP_VLAN_QUAL_OUTER_TPID_T_T_ANY = 0,
    /*! TPID is 0x8100.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_OUTER_TPID_T_T_TPID_8100 = 1,
    /*! TPID is 0x9100.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_OUTER_TPID_T_T_TPID_9100 = 2,
    /*! TPID is 0x88a8.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_OUTER_TPID_T_T_TPID_88A8 = 3,
    /*! TPID is different than above options.  */
    BCM56996_A0_LRD_FP_VLAN_QUAL_OUTER_TPID_T_T_TPID_OTHER = 4,
} bcm56996_a0_lrd_fp_vlan_qual_outer_tpid_t_t;

/*! enum type for IGMP_MLD_FWD_ACTION_T
 * Internet group management protocol & multicast listener discovery packet forwarding action.
 */
typedef enum bcm56996_a0_lrd_igmp_mld_fwd_action_t_e {
    /*! Forward the IGMP & MLD packet.  */
    BCM56996_A0_LRD_IGMP_MLD_FWD_ACTION_T_T_FORWARD = 0,
    /*! Drop the IGMP & MLD packet.  */
    BCM56996_A0_LRD_IGMP_MLD_FWD_ACTION_T_T_DROP = 1,
    /*! Flood the IGMP & MLD packet.  */
    BCM56996_A0_LRD_IGMP_MLD_FWD_ACTION_T_T_FLOOD = 2,
} bcm56996_a0_lrd_igmp_mld_fwd_action_t_t;

/*! enum type for INBAND_TELEMETRY_METADATA_FIELD_T
 * Defines inband telemetry metadata field enums.
 */
typedef enum bcm56996_a0_lrd_inband_telemetry_metadata_field_t_e {
    /*! Pad ones.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_PAD_ONES = 0,
    /*! Pad zeros.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_PAD_ZEROS = 1,
    /*! Opaque data 2.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_OPAQUE_DATA_2 = 2,
    /*! Opaque data 1.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_OPAQUE_DATA_1 = 3,
    /*! Opaque data 0.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_OPAQUE_DATA_0 = 4,
    /*! Switch identifier.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_SWITCH_ID = 5,
    /*! Sub-seconds portion of transit delay.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_TRANSIT_DELAY_SUBSECONDS = 6,
    /*! Stat 1 generated by traffic manager (TM).  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_TM_STAT_1 = 7,
    /*! Stat 0 generated by traffic manager (TM).  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_TM_STAT_0 = 8,
    /*! Sub-seconds portion of ingress timestamp.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_ING_TIMESTAMP_SUB_SECONDS = 9,
    /*! Sub-seconds portion of egress timestamp.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_EGR_TIMESTAMP_SUB_SECONDS = 10,
    /*! Lower seconds portion of ingress timestamp.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_ING_TIMESTAMP_SECONDS_LO = 11,
    /*! Lower seconds portion of egress timestamp.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_EGR_TIMESTAMP_SECONDS_LO = 12,
    /*! Higher seconds portion of ingress timestamp.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_ING_TIMESTAMP_SECONDS_HI = 13,
    /*! Higher seconds portion of egress timestamp.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_EGR_TIMESTAMP_SECONDS_HI = 14,
    /*! Seconds portion of transit delay.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_TRANSIT_DELAY_SECONDS = 15,
    /*! Overlay layer 3 egress interface identifier.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_L3_EIF_OVERLAY = 16,
    /*! Layer 3 egress interface identifier.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_L3_EIF = 17,
    /*! Layer 3 ingress interface identifier.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_L3_IIF = 18,
    /*! Ingress logical port ID.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_ING_PORT = 19,
    /*! Egress logical port ID.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_EGR_PORT = 20,
    /*! Virtual route forwarding.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_VRF = 21,
    /*! Virtual forwarding instance.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_VFI = 22,
    /*! Destination virtual port.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_DVP = 23,
    /*! Source virtual port.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_SVP = 24,
    /*! Tunnel encapsulation index.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_TNL_ENCAP_INDEX = 25,
    /*! Congestion marked status.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_CONGESTION = 26,
    /*! Internal Color/Drop precedence.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_CNG = 27,
    /*! Destination queue identifier.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_QUEUE_ID = 28,
    /*! Metadata profile identifier.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_METADATA_PROFILE_ID = 29,
    /*! Cut through status.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_FIELD_T_T_CUT_THROUGH = 30,
} bcm56996_a0_lrd_inband_telemetry_metadata_field_t_t;

/*! enum type for INBAND_TELEMETRY_METADATA_INSERT_MODE_T
 * Metadata insert mode type.
 */
typedef enum bcm56996_a0_lrd_inband_telemetry_metadata_insert_mode_t_e {
    /*! Do not insert metadata. Applies for INT-DP termination.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_INSERT_MODE_T_T_INSERT_NONE = 0,
    /*! Only insert metadata.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_METADATA_INSERT_MODE_T_T_INSERT_METADATA_ONLY = 3,
} bcm56996_a0_lrd_inband_telemetry_metadata_insert_mode_t_t;

/*! enum type for INBAND_TELEMETRY_O_BIT_UPDATE_MODE_T
 * IOAM overflow bit update mode type.
 */
typedef enum bcm56996_a0_lrd_inband_telemetry_o_bit_update_mode_t_e {
    /*! Do not update O-bit.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_O_BIT_UPDATE_MODE_T_T_SKIP_UPDATE = 0,
    /*!
     * Update O-bit per max length check. The O-bit will be set if there
     *  is no enough room for the metadata to be inserted.
     */
    BCM56996_A0_LRD_INBAND_TELEMETRY_O_BIT_UPDATE_MODE_T_T_SET_IF_OVERFLOW = 2,
} bcm56996_a0_lrd_inband_telemetry_o_bit_update_mode_t_t;

/*! enum type for INBAND_TELEMETRY_RESIDENCE_TIME_FORMAT_T
 * Residence time format type.
 */
typedef enum bcm56996_a0_lrd_inband_telemetry_residence_time_format_t_e {
    /*! Nanoseconds up to 48 bits.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_RESIDENCE_TIME_FORMAT_T_T_FMT_48_BITS = 0,
    /*!
     * IOAM compliant, nanoseconds up to 31 bits.
     *  0x80000000 indicates overflow.
     */
    BCM56996_A0_LRD_INBAND_TELEMETRY_RESIDENCE_TIME_FORMAT_T_T_FMT_32_BITS = 1,
} bcm56996_a0_lrd_inband_telemetry_residence_time_format_t_t;

/*! enum type for INBAND_TELEMETRY_TIMESTAMP_MODE_T
 * Timestamp mode type.
 */
typedef enum bcm56996_a0_lrd_inband_telemetry_timestamp_mode_t_e {
    /*! Precision Time Protocol.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_TIMESTAMP_MODE_T_T_PTP = 0,
    /*! Network Time Protocol.  */
    BCM56996_A0_LRD_INBAND_TELEMETRY_TIMESTAMP_MODE_T_T_NTP = 1,
} bcm56996_a0_lrd_inband_telemetry_timestamp_mode_t_t;

/*! enum type for INBAND_TELEMETRY_USAGE_CELL_MODE_T
 * Current and maximum usage in cells mode type.
 */
typedef enum bcm56996_a0_lrd_inband_telemetry_usage_cell_mode_t_e {
    BCM56996_A0_LRD_INBAND_TELEMETRY_USAGE_CELL_MODE_T_T_QUEUE_BASED = 0,
    BCM56996_A0_LRD_INBAND_TELEMETRY_USAGE_CELL_MODE_T_T_PORT_BASED = 1,
} bcm56996_a0_lrd_inband_telemetry_usage_cell_mode_t_t;

/*! enum type for INBAND_TELEMETRY_VECTOR_MATCH_MISS_ACTION_T */
typedef enum bcm56996_a0_lrd_inband_telemetry_vector_match_miss_action_t_e {
    BCM56996_A0_LRD_INBAND_TELEMETRY_VECTOR_MATCH_MISS_ACTION_T_T_DROP = 0,
    BCM56996_A0_LRD_INBAND_TELEMETRY_VECTOR_MATCH_MISS_ACTION_T_T_FORWARD = 1,
} bcm56996_a0_lrd_inband_telemetry_vector_match_miss_action_t_t;

/*! enum type for INT_MMU_REQ_T
 * Enum for inband network telemetry MMU request type.
 */
typedef enum bcm56996_a0_lrd_int_mmu_req_t_e {
    /*! No request.  */
    BCM56996_A0_LRD_INT_MMU_REQ_T_T_NONE = 0,
    /*! Bus usage request.  */
    BCM56996_A0_LRD_INT_MMU_REQ_T_T_BUS_USAGE = 1,
    /*! Water mark request.  */
    BCM56996_A0_LRD_INT_MMU_REQ_T_T_WATER_MARK = 2,
    /*! Buffer available in pool request.  */
    BCM56996_A0_LRD_INT_MMU_REQ_T_T_BUFFER_AVAILABLE = 3,
    /*! Minimum buffer available in pool request.  */
    BCM56996_A0_LRD_INT_MMU_REQ_T_T_MIN_BUFFER_AVAILABLE = 4,
} bcm56996_a0_lrd_int_mmu_req_t_t;

/*! enum type for IOAM_TYPE_T
 * In-situ Operations, Administration, and Maintenance (IOAM) type
 *  enumeration.
 */
typedef enum bcm56996_a0_lrd_ioam_type_t_e {
    /*! IOAM incremental trace option type.  */
    BCM56996_A0_LRD_IOAM_TYPE_T_T_INCREMENTAL_TRACE = 1,
} bcm56996_a0_lrd_ioam_type_t_t;

/*! enum type for IPV4_IN_IPV4_DF_MODE_T
 * Specifies DF field if tunnel initiation is done for a IPv4 packet.
 */
typedef enum bcm56996_a0_lrd_ipv4_in_ipv4_df_mode_t_e {
    /*! Clear DF flag.  */
    BCM56996_A0_LRD_IPV4_IN_IPV4_DF_MODE_T_T_CLEAR = 0,
    /*! Set DF flag to 1.  */
    BCM56996_A0_LRD_IPV4_IN_IPV4_DF_MODE_T_T_SET = 1,
    /*! Use inner IP Header's DF flag in tunnel header.  */
    BCM56996_A0_LRD_IPV4_IN_IPV4_DF_MODE_T_T_USE_INNER_DF = 2,
} bcm56996_a0_lrd_ipv4_in_ipv4_df_mode_t_t;

/*! enum type for IPV4_MC_FLOOD_MODE_T
 * IPv4 multicast packet flood mode.
 */
typedef enum bcm56996_a0_lrd_ipv4_mc_flood_mode_t_e {
    /*! Flood all multicast packets.  */
    BCM56996_A0_LRD_IPV4_MC_FLOOD_MODE_T_T_FLOOD_ALL = 0,
    /*! Flood unknown multicast packets.  */
    BCM56996_A0_LRD_IPV4_MC_FLOOD_MODE_T_T_FLOOD_UMC = 1,
    /*! Don't flood multicast packets.  */
    BCM56996_A0_LRD_IPV4_MC_FLOOD_MODE_T_T_FLOOD_NONE = 2,
} bcm56996_a0_lrd_ipv4_mc_flood_mode_t_t;

/*! enum type for IPV6_FLOW_LABEL_SELECT_T
 * Select options for the flow label in the IPv6 tunnel header during
 *  encapsulation.
 */
typedef enum bcm56996_a0_lrd_ipv6_flow_label_select_t_e {
    /*! Select FLOW_LABEL from TNL_IPV6_ENCAP.  */
    BCM56996_A0_LRD_IPV6_FLOW_LABEL_SELECT_T_T_FLOW_LABEL = 0,
    /*! Select hash entropy value from the payload.  */
    BCM56996_A0_LRD_IPV6_FLOW_LABEL_SELECT_T_T_HASH_ENTROPY = 1,
} bcm56996_a0_lrd_ipv6_flow_label_select_t_t;

/*! enum type for IPV6_IN_IPV4_DF_MODE_T
 * Specifies DF field if tunnel initiation is done for a IPv6 packet.
 */
typedef enum bcm56996_a0_lrd_ipv6_in_ipv4_df_mode_t_e {
    /*! Clear DF flag.  */
    BCM56996_A0_LRD_IPV6_IN_IPV4_DF_MODE_T_T_CLEAR = 0,
    /*! Set DF flag to 1.  */
    BCM56996_A0_LRD_IPV6_IN_IPV4_DF_MODE_T_T_SET = 1,
} bcm56996_a0_lrd_ipv6_in_ipv4_df_mode_t_t;

/*! enum type for IPV6_MC_FLOOD_MODE_T
 * IPv6 multicast packet flood mode.
 */
typedef enum bcm56996_a0_lrd_ipv6_mc_flood_mode_t_e {
    /*! Flood all multicast packets.  */
    BCM56996_A0_LRD_IPV6_MC_FLOOD_MODE_T_T_FLOOD_ALL = 0,
    /*! Flood unknown multicast packets.  */
    BCM56996_A0_LRD_IPV6_MC_FLOOD_MODE_T_T_FLOOD_UMC = 1,
    /*! Don't flood multicast packets.  */
    BCM56996_A0_LRD_IPV6_MC_FLOOD_MODE_T_T_FLOOD_NONE = 2,
} bcm56996_a0_lrd_ipv6_mc_flood_mode_t_t;

/*! enum type for L2_DEST_T
 * L2 destination.
 */
typedef enum bcm56996_a0_lrd_l2_dest_t_e {
    /*! Normal Port.  */
    BCM56996_A0_LRD_L2_DEST_T_T_PORT = 0,
    /*! Trunk group port.  */
    BCM56996_A0_LRD_L2_DEST_T_T_TRUNK = 1,
    /*! L2 multicast group ID.  */
    BCM56996_A0_LRD_L2_DEST_T_T_L2_MC_GRP = 2,
    /*! L3 multicast group ID.  */
    BCM56996_A0_LRD_L2_DEST_T_T_L3_MC_GRP = 3,
    /*! Next hop ID.  */
    BCM56996_A0_LRD_L2_DEST_T_T_NHOP = 4,
    /*! ECMP group ID.  */
    BCM56996_A0_LRD_L2_DEST_T_T_ECMP_GRP = 5,
} bcm56996_a0_lrd_l2_dest_t_t;

/*! enum type for L2_MC_FLOOD_MODE_T
 * L2 multicast packet flood mode.
 */
typedef enum bcm56996_a0_lrd_l2_mc_flood_mode_t_e {
    /*! Flood all multicast packets.  */
    BCM56996_A0_LRD_L2_MC_FLOOD_MODE_T_T_FLOOD_ALL = 0,
    /*! Flood unknown multicast packets.  */
    BCM56996_A0_LRD_L2_MC_FLOOD_MODE_T_T_FLOOD_UMC = 1,
    /*! Don't flood multicast packets.  */
    BCM56996_A0_LRD_L2_MC_FLOOD_MODE_T_T_FLOOD_NONE = 2,
} bcm56996_a0_lrd_l2_mc_flood_mode_t_t;

/*! enum type for L2_OPAQUE_TAG_NOT_PRESENT_ACTION_T
 * L2 opaque tag actions if it is not present.
 */
typedef enum bcm56996_a0_lrd_l2_opaque_tag_not_present_action_t_e {
    /*! No action.  */
    BCM56996_A0_LRD_L2_OPAQUE_TAG_NOT_PRESENT_ACTION_T_T_NO_ACTION = 0,
    /*! Add a tag.  */
    BCM56996_A0_LRD_L2_OPAQUE_TAG_NOT_PRESENT_ACTION_T_T_ADD = 1,
} bcm56996_a0_lrd_l2_opaque_tag_not_present_action_t_t;

/*! enum type for L2_OPAQUE_TAG_PRESENT_ACTION_T
 * L2 opaque tag actions if it is present.
 */
typedef enum bcm56996_a0_lrd_l2_opaque_tag_present_action_t_e {
    /*! No action.  */
    BCM56996_A0_LRD_L2_OPAQUE_TAG_PRESENT_ACTION_T_T_NO_ACTION = 0,
    /*! Delete the tag.  */
    BCM56996_A0_LRD_L2_OPAQUE_TAG_PRESENT_ACTION_T_T_DELETE = 1,
    /*! Replace the tag.  */
    BCM56996_A0_LRD_L2_OPAQUE_TAG_PRESENT_ACTION_T_T_REPLACE = 2,
} bcm56996_a0_lrd_l2_opaque_tag_present_action_t_t;

/*! enum type for L3_EIF_OVERLAY_LIMIT_T
 * L3 EIF overlay limit type.
 */
typedef enum bcm56996_a0_lrd_l3_eif_overlay_limit_t_e {
    /*! Allocate no entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_0 = 0,
    /*! Allocate 1K entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_1K = 1,
    /*! Allocate 2K entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_2K = 2,
    /*! Allocate 3K entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_3K = 3,
    /*! Allocate 4K entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_4K = 4,
    /*! Allocate 5K entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_5K = 5,
    /*! Allocate 6K entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_6K = 6,
    /*! Allocate 7K entries for overlay.  */
    BCM56996_A0_LRD_L3_EIF_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_7K = 7,
} bcm56996_a0_lrd_l3_eif_overlay_limit_t_t;

/*! enum type for L3_NHOP_OVERLAY_LIMIT_T
 * L3 next hop overlay limit type.
 */
typedef enum bcm56996_a0_lrd_l3_nhop_overlay_limit_t_e {
    /*! Allocate no entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_0 = 0,
    /*! Allocate 4K entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_4K = 1,
    /*! Allocate 8K entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_8K = 2,
    /*! Allocate 12K entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_12K = 3,
    /*! Allocate 16K entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_16K = 4,
    /*! Allocate 20K entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_20K = 5,
    /*! Allocate 24K entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_24K = 6,
    /*! Allocate 28K entries for overlay.  */
    BCM56996_A0_LRD_L3_NHOP_OVERLAY_LIMIT_T_T_OVERLAY_LIMIT_28K = 7,
} bcm56996_a0_lrd_l3_nhop_overlay_limit_t_t;

/*! enum type for L3_TNL_TYPE_T
 * Tunnel type for L3 tunnels.
 */
typedef enum bcm56996_a0_lrd_l3_tnl_type_t_e {
    /*! No tunnel.  */
    BCM56996_A0_LRD_L3_TNL_TYPE_T_T_NONE = 0,
    /*! IPV4 tunnel.  */
    BCM56996_A0_LRD_L3_TNL_TYPE_T_T_IPV4 = 1,
    /*! IPV6 tunnel.  */
    BCM56996_A0_LRD_L3_TNL_TYPE_T_T_IPV6 = 2,
    /*! MPLS tunnel.  */
    BCM56996_A0_LRD_L3_TNL_TYPE_T_T_MPLS = 3,
} bcm56996_a0_lrd_l3_tnl_type_t_t;

/*! enum type for LB_HASH_ALGORITHM_T
 * Load balance hash computation algorithm enumeration type.
 */
typedef enum bcm56996_a0_lrd_lb_hash_algorithm_t_e {
    /*! 0000: Default value.\n */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_RESERVED = 0,
    /*! 0001: Bits[15:0] of computed versatile hash.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_VERSATILE_HASH_0 = 1,
    /*! 0010: Bits[31:16] of computed versatile hash.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_VERSATILE_HASH_1 = 2,
    /*! 0011: CRC16_BISYNC.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC16_BISYNC = 3,
    /*! 0100: CRC16_BISYNC_AND_XOR1.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC16_BISYNC_AND_XOR1 = 4,
    /*! 0101: CRC16_BISYNC_AND_XOR2.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC16_BISYNC_AND_XOR2 = 5,
    /*! 0110: CRC16_BISYNC_AND_XOR4.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC16_BISYNC_AND_XOR4 = 6,
    /*! 0111: CRC16_BISYNC_AND_XOR8.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC16_BISYNC_AND_XOR8 = 7,
    /*! 1000: XOR16.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_XOR16 = 8,
    /*! 1001: CRC16_CCITT.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC16_CCITT = 9,
    /*! 1010: CRC32_LO/CRC32_A_LO.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC32_LO = 10,
    /*! 1011: CRC32_HI/CRC32_A_HI.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC32_HI = 11,
    /*! 1100: CRC32_B_LO.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC32_ETH_LO = 12,
    /*! 1101: CRC32_B_HI.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC32_ETH_HI = 13,
    /*! 1110: CRC32_C_LO.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC32_KOOPMAN_LO = 14,
    /*! 1111: CRC32_C_HI.  */
    BCM56996_A0_LRD_LB_HASH_ALGORITHM_T_T_CRC32_KOOPMAN_HI = 15,
} bcm56996_a0_lrd_lb_hash_algorithm_t_t;

/*! enum type for LB_HASH_FLEX_FIELDS_SELECT_T
 * This Enum represent the type of data to be extracted from the packet
 *  before feeding to RTAG7 Hash.
 */
typedef enum bcm56996_a0_lrd_lb_hash_flex_fields_select_t_e {
    /*!
     * Select 16 bits from the payload of the packet upto 32 bytes
     *  after the end of L3 header.
     */
    BCM56996_A0_LRD_LB_HASH_FLEX_FIELDS_SELECT_T_T_L4_DATA = 0,
    /*! Select UDF chunk.  */
    BCM56996_A0_LRD_LB_HASH_FLEX_FIELDS_SELECT_T_T_UDF = 1,
} bcm56996_a0_lrd_lb_hash_flex_fields_select_t_t;

/*! enum type for LB_HASH_IPSEC_SELECT_T
 * Hash IPsec select enumeration type.
 */
typedef enum bcm56996_a0_lrd_lb_hash_ipsec_select_t_e {
    /*!
     * 1: Reserved.
     *  3: Reserved.
     */
    BCM56996_A0_LRD_LB_HASH_IPSEC_SELECT_T_T_USE_L4_PORT = 0,
    /*! SPI = 2.  */
    BCM56996_A0_LRD_LB_HASH_IPSEC_SELECT_T_T_USE_SPI = 2,
} bcm56996_a0_lrd_lb_hash_ipsec_select_t_t;

/*! enum type for LB_HASH_IPV6_COLLAPSE_T
 * IPv6 addresses collapsing selection method enumeration type.
 */
typedef enum bcm56996_a0_lrd_lb_hash_ipv6_collapse_t_e {
    /*!
     * 32-bit value is folded and XORed from 128-bit IPv6 address.
     *  IPv6 collapsed source address = SIP[127:96]^SIP[95:64]^SIP[63:32]
     *                                  ^SIP[31:0].
     *  IPv6 collapsed destination address = DIP[127:96]^DIP[95:64]
     *                                       ^DIP[63:32]^DIP[31:0].
     */
    BCM56996_A0_LRD_LB_HASH_IPV6_COLLAPSE_T_T_FOLD_AND_XOR = 0,
    /*!
     * 32-bit value is 32 LSBs of 128-bit IPv6 address.
     *  IPv6 collapsed source address = SIP[31:0].
     *  IPv6 collapsed destination address = DIP[31:0].
     */
    BCM56996_A0_LRD_LB_HASH_IPV6_COLLAPSE_T_T_USE_LSB = 1,
} bcm56996_a0_lrd_lb_hash_ipv6_collapse_t_t;

/*! enum type for LB_HASH_SUBSET_SELECT_T
 * Hash subset select enumeration type.
 */
typedef enum bcm56996_a0_lrd_lb_hash_subset_select_t_e {
    /*! If CONCAT == 0, use 0_0, else use {1_1,1_0,0_1,0_0}.  */
    BCM56996_A0_LRD_LB_HASH_SUBSET_SELECT_T_T_USE_0_0 = 0,
    /*! If CONCAT == 0, use 1_0, else reserved.  */
    BCM56996_A0_LRD_LB_HASH_SUBSET_SELECT_T_T_USE_1_0 = 1,
    /*! Use port LBN.  */
    BCM56996_A0_LRD_LB_HASH_SUBSET_SELECT_T_T_USE_PORT_LBN = 2,
    /*!
     * If CONCAT == 0, if HG, use MH.DEST_PORT; If not HG, use 0_0.
     *
     *  If CONCAT == 1, if HG, use MH.DEST_PORT; If not HG, use {1_1,1_0,0_1,0_0}.
     */
    BCM56996_A0_LRD_LB_HASH_SUBSET_SELECT_T_T_USE_DEST_PORT = 3,
    /*! 4 (USE_LBID) and 5 (USE_LOCAL_LBID) are reserved.  */
    BCM56996_A0_LRD_LB_HASH_SUBSET_SELECT_T_T_USE_0_1 = 6,
    /*! If CONCAT == 0, use 1_1, else reserved.  */
    BCM56996_A0_LRD_LB_HASH_SUBSET_SELECT_T_T_USE_1_1 = 7,
} bcm56996_a0_lrd_lb_hash_subset_select_t_t;

/*! enum type for LB_HASH_TUNNEL_PAYLOAD_T
 * Tunnel-based hash field selection payload enumeration type.
 */
typedef enum bcm56996_a0_lrd_lb_hash_tunnel_payload_t_e {
    /*! Inner L2 = 0.  */
    BCM56996_A0_LRD_LB_HASH_TUNNEL_PAYLOAD_T_T_INNER_L2 = 0,
    /*! Inner L3 = 1.  */
    BCM56996_A0_LRD_LB_HASH_TUNNEL_PAYLOAD_T_T_INNER_L3 = 1,
} bcm56996_a0_lrd_lb_hash_tunnel_payload_t_t;

/*! enum type for LDH_COUNT_MODE_T
 * Latency monitor count mode enumeration type.
 */
typedef enum bcm56996_a0_lrd_ldh_count_mode_t_e {
    /*! Count all packets regardless of cut-through.  */
    BCM56996_A0_LRD_LDH_COUNT_MODE_T_T_COUNT_ALL = 0,
    /*! Count packets only if they are cut-through.  */
    BCM56996_A0_LRD_LDH_COUNT_MODE_T_T_CUT_THROUGH = 1,
    /*! Count packets only if they are store-and-forward.  */
    BCM56996_A0_LRD_LDH_COUNT_MODE_T_T_STORE_AND_FORWARD = 2,
    /*! Reserved.  */
    BCM56996_A0_LRD_LDH_COUNT_MODE_T_T_INVALID = 3,
} bcm56996_a0_lrd_ldh_count_mode_t_t;

/*! enum type for MIRROR_IP_ENTRY_NUM_T
 * Enum definition for the number of specified IPv4 or IPv6 address entries
 *  used for mirroring to multiple destinations. The number of entries
 *  must be a power of 2.
 */
typedef enum bcm56996_a0_lrd_mirror_ip_entry_num_t_e {
    /*! 1 entry.  */
    BCM56996_A0_LRD_MIRROR_IP_ENTRY_NUM_T_T_ENTRY_NUM_1 = 0,
    /*! 2 entries.  */
    BCM56996_A0_LRD_MIRROR_IP_ENTRY_NUM_T_T_ENTRY_NUM_2 = 1,
    /*! 4 3ntries.  */
    BCM56996_A0_LRD_MIRROR_IP_ENTRY_NUM_T_T_ENTRY_NUM_4 = 2,
    /*! 8 entries.  */
    BCM56996_A0_LRD_MIRROR_IP_ENTRY_NUM_T_T_ENTRY_NUM_8 = 3,
    /*! 16 entries.  */
    BCM56996_A0_LRD_MIRROR_IP_ENTRY_NUM_T_T_ENTRY_NUM_16 = 4,
    /*! 32 entries.  */
    BCM56996_A0_LRD_MIRROR_IP_ENTRY_NUM_T_T_ENTRY_NUM_32 = 5,
    /*! 64 entries.  */
    BCM56996_A0_LRD_MIRROR_IP_ENTRY_NUM_T_T_ENTRY_NUM_64 = 6,
} bcm56996_a0_lrd_mirror_ip_entry_num_t_t;

/*! enum type for MIRROR_METADATA_T
 * Mirror metadata used in sampled flow (sFlow) encapsulation header with
 *  sequence numbering and in packet sampling (PSAMP) encapsulation header
 *  with metadata.
 */
typedef enum bcm56996_a0_lrd_mirror_metadata_t_e {
    /*! Metadata field is written with zeroes.  */
    BCM56996_A0_LRD_MIRROR_METADATA_T_T_ZEROES = 0,
    /*! Metadata field is written with class ID assigned by ingress stage.  */
    BCM56996_A0_LRD_MIRROR_METADATA_T_T_ING_TO_EGR_CLASS_ID = 1,
    /*! Metadata field is written with next hop class ID.  */
    BCM56996_A0_LRD_MIRROR_METADATA_T_T_NHOP_CLASS_ID = 2,
    /*! Metadata field is written with value from METADATA.  */
    BCM56996_A0_LRD_MIRROR_METADATA_T_T_TABLE_METADATA = 3,
} bcm56996_a0_lrd_mirror_metadata_t_t;

/*! enum type for MIRROR_TRUNCATE_ACTION_T
 * Mirror truncation actions.
 */
typedef enum bcm56996_a0_lrd_mirror_truncate_action_t_e {
    /*! Do not truncate the mirror copy.  */
    BCM56996_A0_LRD_MIRROR_TRUNCATE_ACTION_T_T_DO_NOT_TRUNCATE = 0,
    /*! Truncate the mirror copy to 1 cell.  */
    BCM56996_A0_LRD_MIRROR_TRUNCATE_ACTION_T_T_TRUNCATE = 1,
    /*! Truncate the mirror copy to 1 cell and zero payload.  */
    BCM56996_A0_LRD_MIRROR_TRUNCATE_ACTION_T_T_TRUNCATE_AND_ZERO = 2,
} bcm56996_a0_lrd_mirror_truncate_action_t_t;

/*! enum type for MMRP_FWD_ACTION_T
 * Multiple MAC registration protocol packet forwarding action.
 */
typedef enum bcm56996_a0_lrd_mmrp_fwd_action_t_e {
    /*! Forward the MMRP packet.  */
    BCM56996_A0_LRD_MMRP_FWD_ACTION_T_T_FORWARD = 0,
    /*! Drop the MMRP packet.  */
    BCM56996_A0_LRD_MMRP_FWD_ACTION_T_T_DROP = 1,
    /*! Flood the MMRP packet.  */
    BCM56996_A0_LRD_MMRP_FWD_ACTION_T_T_FLOOD = 2,
} bcm56996_a0_lrd_mmrp_fwd_action_t_t;

/*! enum type for MPLS_EXP_MAP_ACTION_T
 * Indicates how to generate the internal priority and CNG values.
 */
typedef enum bcm56996_a0_lrd_mpls_exp_map_action_t_e {
    /*! Do not change INT_PRI and CNG.  */
    BCM56996_A0_LRD_MPLS_EXP_MAP_ACTION_T_T_NONE = 0,
    /*! Use PHB_ING_MPLS_EXP_TO_INT_PRI table to derive INT_PRI and CNG.  */
    BCM56996_A0_LRD_MPLS_EXP_MAP_ACTION_T_T_MAP_PRI_CNG = 1,
    /*! Use INT_PRI and CNG from TNL_MPLS_DECAP logical table.  */
    BCM56996_A0_LRD_MPLS_EXP_MAP_ACTION_T_T_FIXED_PRI_MAP_CNG = 2,
} bcm56996_a0_lrd_mpls_exp_map_action_t_t;

/*! enum type for MPLS_EXP_MODE_T
 * EXP mode for MPLS label.
 */
typedef enum bcm56996_a0_lrd_mpls_exp_mode_t_e {
    /*! Use EXP value from TNL_MPLS_ENCAP logical table.  */
    BCM56996_A0_LRD_MPLS_EXP_MODE_T_T_FIXED = 0,
    /*! Use PHB_EGR_MPLS_ID to derive EXP value.  */
    BCM56996_A0_LRD_MPLS_EXP_MODE_T_T_MAP = 1,
    /*! Use inner label's EXP value.  */
    BCM56996_A0_LRD_MPLS_EXP_MODE_T_T_USE_INNER_LABEL = 2,
} bcm56996_a0_lrd_mpls_exp_mode_t_t;

/*! enum type for MPLS_TNL_BOS_ACTIONS_T
 * Specifies MPLS bottom of stack label actions.
 */
typedef enum bcm56996_a0_lrd_mpls_tnl_bos_actions_t_e {
    /*! Invalid action.  */
    BCM56996_A0_LRD_MPLS_TNL_BOS_ACTIONS_T_T_INVALID = 0,
    /*! Pop and forward based on L3_IIF_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_BOS_ACTIONS_T_T_L3_IIF = 2,
    /*! Swap and forward to NHOP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_BOS_ACTIONS_T_T_SWAP_NHI = 3,
    /*! Pop and forward to NHOP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_BOS_ACTIONS_T_T_L3_NHI = 4,
    /*! Pop and forward to ECMP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_BOS_ACTIONS_T_T_L3_ECMP = 5,
    /*! Swap and forward to ECMP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_BOS_ACTIONS_T_T_SWAP_ECMP = 6,
} bcm56996_a0_lrd_mpls_tnl_bos_actions_t_t;

/*! enum type for MPLS_TNL_NON_BOS_ACTIONS_T
 * Specifies MPLS non bottom of stack label actions.
 */
typedef enum bcm56996_a0_lrd_mpls_tnl_non_bos_actions_t_e {
    /*! Invalid action.  */
    BCM56996_A0_LRD_MPLS_TNL_NON_BOS_ACTIONS_T_T_INVALID = 0,
    /*! Pop the label.  */
    BCM56996_A0_LRD_MPLS_TNL_NON_BOS_ACTIONS_T_T_POP = 1,
    /*! Pop and forward based on NHOP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_NON_BOS_ACTIONS_T_T_PHP_NHI = 2,
    /*! Swap and forward based on NHOP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_NON_BOS_ACTIONS_T_T_SWAP_NHI = 3,
    /*! Swap and forward based on ECMP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_NON_BOS_ACTIONS_T_T_SWAP_ECMP = 4,
    /*! Pop and forward based on ECMP_ID.  */
    BCM56996_A0_LRD_MPLS_TNL_NON_BOS_ACTIONS_T_T_PHP_ECMP = 5,
} bcm56996_a0_lrd_mpls_tnl_non_bos_actions_t_t;

/*! enum type for OPAQUE_TAG_SIZE_T
 * Size of opaque tag.
 */
typedef enum bcm56996_a0_lrd_opaque_tag_size_t_e {
    /*! Four bytes of the opaque tag.  */
    BCM56996_A0_LRD_OPAQUE_TAG_SIZE_T_T_FOUR_BYTES_OPAQUE_TAG = 1,
    /*! Eight bytes of the opaque tag.  */
    BCM56996_A0_LRD_OPAQUE_TAG_SIZE_T_T_EIGHT_BYTES_OPAQUE_TAG = 2,
} bcm56996_a0_lrd_opaque_tag_size_t_t;

/*! enum type for PC_ABILITY_TYPE_T
 * \brief port abilities types.
 */
typedef enum bcm56996_a0_lrd_pc_ability_type_t_e {
    /*!
     * Local ability reflects the port capabilities
     *  on the local device, such as speed, number of lanes,
     *  FEC type, Pause.
     */
    BCM56996_A0_LRD_PC_ABILITY_TYPE_T_T_PC_ABILITY_LOCAL = 0,
    /*!
     * Advert ability is used for the port to advertise its
     *  operational abilities.
     */
    BCM56996_A0_LRD_PC_ABILITY_TYPE_T_T_PC_ABILITY_ADVERT = 1,
} bcm56996_a0_lrd_pc_ability_type_t_t;

/*! enum type for PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T
 * \brief Globally available symbol error window sizes.
 */
typedef enum bcm56996_a0_lrd_pc_fdr_symbol_error_window_size_t_e {
    /*! Symbol error window size of 128 control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_128 = 0,
    /*! Symbol error window size of 1K control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_1K = 1,
    /*! Symbol error window size of 8K control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_8K = 2,
    /*! Symbol error window size of 64K control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_64K = 3,
    /*! Symbol error window size of 512K control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_512K = 4,
    /*! Symbol error window size of 4M control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_4M = 5,
    /*! Symbol error window size of 32M control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_32M = 6,
    /*! Symbol error window size of 256M control words.  */
    BCM56996_A0_LRD_PC_FDR_SYMBOL_ERROR_WINDOW_SIZE_T_T_SYMBOL_ERROR_WINDOW_CW_256M = 7,
} bcm56996_a0_lrd_pc_fdr_symbol_error_window_size_t_t;

/*! enum type for PC_PM_MODE_T
 * \brief PM mode supported.
 */
typedef enum bcm56996_a0_lrd_pc_pm_mode_t_e {
    /*! Default mode.  */
    BCM56996_A0_LRD_PC_PM_MODE_T_T_PC_PM_MODE_DEFAULT = 0,
} bcm56996_a0_lrd_pc_pm_mode_t_t;

/*! enum type for PC_PM_PLL_VCO_RATE_T
 * \brief Available port macro PLL VCO rates.
 */
typedef enum bcm56996_a0_lrd_pc_pm_pll_vco_rate_t_e {
    /*! No PLL configured.  */
    BCM56996_A0_LRD_PC_PM_PLL_VCO_RATE_T_T_PC_PM_PLL_VCO_RATE_NONE = 0,
    /*! PLL VCO rate is 10.3125G.  */
    BCM56996_A0_LRD_PC_PM_PLL_VCO_RATE_T_T_PC_PM_PLL_VCO_RATE_10P3125G = 1,
    /*! PLL VCO rate is 12.5G.  */
    BCM56996_A0_LRD_PC_PM_PLL_VCO_RATE_T_T_PC_PM_PLL_VCO_RATE_12P5G = 2,
    /*! PLL VCO rate is 41P25G.  */
    BCM56996_A0_LRD_PC_PM_PLL_VCO_RATE_T_T_PC_PM_PLL_VCO_RATE_41P25G = 6,
    /*! PLL VCO rate is 51P562G.  */
    BCM56996_A0_LRD_PC_PM_PLL_VCO_RATE_T_T_PC_PM_PLL_VCO_RATE_51P562G = 7,
    /*! PLL VCO rate is 53P125G.  */
    BCM56996_A0_LRD_PC_PM_PLL_VCO_RATE_T_T_PC_PM_PLL_VCO_RATE_53P125G = 8,
} bcm56996_a0_lrd_pc_pm_pll_vco_rate_t_t;

/*! enum type for PFC_DEADLOCK_RECOVERY_ACTION_T
 * Enum definition for PFC deadlock recovery action specified
 *  by the field TM_PFC_DEADLOCK_RECOVERY_CONTROL.ACTION
 */
typedef enum bcm56996_a0_lrd_pfc_deadlock_recovery_action_t_e {
    /*! Transmit all packets on deadlock recovery.  */
    BCM56996_A0_LRD_PFC_DEADLOCK_RECOVERY_ACTION_T_T_TRANSMIT = 0,
    /*! Discard all packets on deadlock recovery.  */
    BCM56996_A0_LRD_PFC_DEADLOCK_RECOVERY_ACTION_T_T_DISCARD = 1,
} bcm56996_a0_lrd_pfc_deadlock_recovery_action_t_t;

/*! enum type for PHB_EGR_DSCP_ACTION_T
 * Egress DSCP action.
 */
typedef enum bcm56996_a0_lrd_phb_egr_dscp_action_t_e {
    /*! Do not modify DSCP.  */
    BCM56996_A0_LRD_PHB_EGR_DSCP_ACTION_T_T_NONE = 0,
    /*! Use DSCP value from L3_EIF table.  */
    BCM56996_A0_LRD_PHB_EGR_DSCP_ACTION_T_T_FIXED = 1,
    /*!
     * Use PHB_EGR_IP_INT_PRI_TO_DSCP_ID to get DSCP
     *  value from PHB_EGR_IP_INT_PRI_TO_DSCP table.
     */
    BCM56996_A0_LRD_PHB_EGR_DSCP_ACTION_T_T_MAP = 2,
} bcm56996_a0_lrd_phb_egr_dscp_action_t_t;

/*! enum type for PHB_EGR_L2_TAG_ACTION_T
 * Egress L2 tag action.
 */
typedef enum bcm56996_a0_lrd_phb_egr_l2_tag_action_t_e {
    /*! Do not modify PRI and CFI.  */
    BCM56996_A0_LRD_PHB_EGR_L2_TAG_ACTION_T_T_NONE = 0,
    /*! Use PRI, CFI values from L3_EIF table.  */
    BCM56996_A0_LRD_PHB_EGR_L2_TAG_ACTION_T_T_FIXED = 1,
    /*!
     * Use PHB_EGR_L2_INT_PRI_TO_OTAG_ID to get PRI, CFI
     *  values from PHB_EGR_L2_INT_PRI_TO_OTAG table.
     */
    BCM56996_A0_LRD_PHB_EGR_L2_TAG_ACTION_T_T_MAP = 2,
} bcm56996_a0_lrd_phb_egr_l2_tag_action_t_t;

/*! enum type for PHB_EGR_TNL_DSCP_ACTION_T
 * Egress tunnel DSCP action.
 */
typedef enum bcm56996_a0_lrd_phb_egr_tnl_dscp_action_t_e {
    /*! Use DSCP value from the tunnel table.  */
    BCM56996_A0_LRD_PHB_EGR_TNL_DSCP_ACTION_T_T_FIXED = 0,
    /*! Use DSCP value from the packet.  */
    BCM56996_A0_LRD_PHB_EGR_TNL_DSCP_ACTION_T_T_PACKET = 1,
    /*! Use DSCP value from PHB_EGR_IP_INT_PRI_TO_DSCP logical table.  */
    BCM56996_A0_LRD_PHB_EGR_TNL_DSCP_ACTION_T_T_MAP = 2,
} bcm56996_a0_lrd_phb_egr_tnl_dscp_action_t_t;

/*! enum type for PKT_PRI_TYPE_T
 * Priority selection based on packet types.
 */
typedef enum bcm56996_a0_lrd_pkt_pri_type_t_e {
    /*! Packet priority from VLAN header.  */
    BCM56996_A0_LRD_PKT_PRI_TYPE_T_T_PKT_PRI_TYPE_VLAN = 0,
    /*! Packet priority from DSCP.  */
    BCM56996_A0_LRD_PKT_PRI_TYPE_T_T_PKT_PRI_TYPE_DSCP = 1,
    /*! Packet priority from MPLS header.  */
    BCM56996_A0_LRD_PKT_PRI_TYPE_T_T_PKT_PRI_TYPE_MPLS = 2,
    /*! Packet priority from PE ETAG header.  */
    BCM56996_A0_LRD_PKT_PRI_TYPE_T_T_PKT_PRI_TYPE_ETAG = 3,
} bcm56996_a0_lrd_pkt_pri_type_t_t;

/*! enum type for PORT_GRP_MODE_T
 * Port group mode type.
 */
typedef enum bcm56996_a0_lrd_port_grp_mode_t_e {
    /*! Use all ones as port group ID.  */
    BCM56996_A0_LRD_PORT_GRP_MODE_T_T_ALL_ONES = 0,
    /*! Use port group ID.  */
    BCM56996_A0_LRD_PORT_GRP_MODE_T_T_PORT_GRP_ID = 1,
} bcm56996_a0_lrd_port_grp_mode_t_t;

/*! enum type for PORT_OPERATING_MODE_T
 * Port operation mode to determine the strength of port-based L3_IIF and VRF.
 */
typedef enum bcm56996_a0_lrd_port_operating_mode_t_e {
    /*! No port-based L3_IIF and VRF.  */
    BCM56996_A0_LRD_PORT_OPERATING_MODE_T_T_NORMAL = 0,
    /*! Use PORT_SYSTEM.L3_IIF instead of VLAN.L3_IIF.  */
    BCM56996_A0_LRD_PORT_OPERATING_MODE_T_T_L3_IIF = 2,
    /*! Use PORT_SYSTEM.VRF_ID instead of L3_IIF.VRF_ID.  */
    BCM56996_A0_LRD_PORT_OPERATING_MODE_T_T_VRF = 3,
    /*! Use PORT_SYSTEM.L3_IIF instead of PORT_SYSTEM_PROFILE.ING_OVID.  */
    BCM56996_A0_LRD_PORT_OPERATING_MODE_T_T_VLAN = 4,
} bcm56996_a0_lrd_port_operating_mode_t_t;

/*! enum type for PORT_TYPE_T
 * Port encapsulation type.
 */
typedef enum bcm56996_a0_lrd_port_type_t_e {
    /*! Ethernet port.  */
    BCM56996_A0_LRD_PORT_TYPE_T_T_ETHERNET = 0,
    /*! Internal loopback port.  */
    BCM56996_A0_LRD_PORT_TYPE_T_T_LOOPBACK = 2,
} bcm56996_a0_lrd_port_type_t_t;

/*! enum type for RANGECHECK_FIELD_T
 * Enum for range checker fields.
 */
typedef enum bcm56996_a0_lrd_rangecheck_field_t_e {
    /*! L4 source port.  */
    BCM56996_A0_LRD_RANGECHECK_FIELD_T_T_L4SRCPORT = 0,
    /*! L4 destination port.  */
    BCM56996_A0_LRD_RANGECHECK_FIELD_T_T_L4DSTPORT = 1,
    /*! VLAN ID.  */
    BCM56996_A0_LRD_RANGECHECK_FIELD_T_T_OUTER_VLANID = 2,
    /*! Packet payload length.  */
    BCM56996_A0_LRD_RANGECHECK_FIELD_T_T_PKT_PAYLOAD_LEN = 3,
    /*! UDF.  */
    BCM56996_A0_LRD_RANGECHECK_FIELD_T_T_UDF = 4,
    /*! VFI.  */
    BCM56996_A0_LRD_RANGECHECK_FIELD_T_T_VFI = 5,
} bcm56996_a0_lrd_rangecheck_field_t_t;

/*! enum type for SER_BLK_KEY_TYPE_T
 * SER block key type. An application uses these
 *  enum values as lookup key for SER_STATS. If an application
 *  is not concerned with specific block types,
 *  SER_BLK_ALL can be used as the lookup key for SER_STATS.
 */
typedef enum bcm56996_a0_lrd_ser_blk_key_type_t_e {
    /*! All block types.  */
    BCM56996_A0_LRD_SER_BLK_KEY_TYPE_T_T_SER_BLK_ALL = 0,
    /*! Memory Management Unit.  */
    BCM56996_A0_LRD_SER_BLK_KEY_TYPE_T_T_SER_BLK_MMU = 1,
    /*! Ingress pipeline.  */
    BCM56996_A0_LRD_SER_BLK_KEY_TYPE_T_T_SER_BLK_IPIPE = 2,
    /*! Egress pipeline.  */
    BCM56996_A0_LRD_SER_BLK_KEY_TYPE_T_T_SER_BLK_EPIPE = 3,
    /*! Packet gateWay.  */
    BCM56996_A0_LRD_SER_BLK_KEY_TYPE_T_T_SER_BLK_PGW = 4,
    /*! PORT.  */
    BCM56996_A0_LRD_SER_BLK_KEY_TYPE_T_T_SER_BLK_PORT = 5,
} bcm56996_a0_lrd_ser_blk_key_type_t_t;

/*! enum type for SER_BLK_TYPE_T
 * SER block type.
 */
typedef enum bcm56996_a0_lrd_ser_blk_type_t_e {
    /*! Memory Management Unit.  */
    BCM56996_A0_LRD_SER_BLK_TYPE_T_T_SER_BLK_MMU = 1,
    /*! Ingress pipeline.  */
    BCM56996_A0_LRD_SER_BLK_TYPE_T_T_SER_BLK_IPIPE = 2,
    /*! Egress pipeline.  */
    BCM56996_A0_LRD_SER_BLK_TYPE_T_T_SER_BLK_EPIPE = 3,
    /*! Packet gateWay.  */
    BCM56996_A0_LRD_SER_BLK_TYPE_T_T_SER_BLK_PGW = 4,
    /*! PORT.  */
    BCM56996_A0_LRD_SER_BLK_TYPE_T_T_SER_BLK_PORT = 5,
} bcm56996_a0_lrd_ser_blk_type_t_t;

/*! enum type for SER_CHECK_TYPE_T
 * SER check type.
 */
typedef enum bcm56996_a0_lrd_ser_check_type_t_e {
    /*! No SER check  */
    BCM56996_A0_LRD_SER_CHECK_TYPE_T_T_SER_NO_CHECK = 0,
    /*! Parity check  */
    BCM56996_A0_LRD_SER_CHECK_TYPE_T_T_SER_PARITY_CHECK = 1,
    /*! ECC check  */
    BCM56996_A0_LRD_SER_CHECK_TYPE_T_T_SER_ECC_CHECK = 2,
} bcm56996_a0_lrd_ser_check_type_t_t;

/*! enum type for SER_ERROR_BIT_NUM_T
 * Used to determine whether to insert single bit error or
 *  insert double bit error.
 */
typedef enum bcm56996_a0_lrd_ser_error_bit_num_t_e {
    BCM56996_A0_LRD_SER_ERROR_BIT_NUM_T_T_SER_SINGLE_BIT_ERR = 0,
    BCM56996_A0_LRD_SER_ERROR_BIT_NUM_T_T_SER_DOUBLE_BIT_ERR = 1,
} bcm56996_a0_lrd_ser_error_bit_num_t_t;

/*! enum type for SER_ERROR_TYPE_T
 * SER error type.
 */
typedef enum bcm56996_a0_lrd_ser_error_type_t_e {
    /*! Parity error.  */
    BCM56996_A0_LRD_SER_ERROR_TYPE_T_T_SER_ERR_PARITY = 0,
    /*! ECC 1bit error.  */
    BCM56996_A0_LRD_SER_ERROR_TYPE_T_T_SER_ERR_ECC_1BIT = 1,
    /*! ECC 2bit error.  */
    BCM56996_A0_LRD_SER_ERROR_TYPE_T_T_SER_ERR_ECC_2BIT = 2,
} bcm56996_a0_lrd_ser_error_type_t_t;

/*! enum type for SER_INSTRUCTION_TYPE_T
 * SER instruction type.
 */
typedef enum bcm56996_a0_lrd_ser_instruction_type_t_e {
    /*! EP/IP: SER error in Start-Of-Packet(SOP) cell.  */
    BCM56996_A0_LRD_SER_INSTRUCTION_TYPE_T_T_SER_INSTRUCTION_SOP = 0,
    /*! EP/IP: SER error in Middle-Of-Packet(MOP) cell.  */
    BCM56996_A0_LRD_SER_INSTRUCTION_TYPE_T_T_SER_INSTRUCTION_MOP = 1,
    /*! EP/IP: SER error in End-Of-Packet(EOP) cell.  */
    BCM56996_A0_LRD_SER_INSTRUCTION_TYPE_T_T_SER_INSTRUCTION_EOP = 2,
    /*! EP/IP: SER error in sbus transaction.  */
    BCM56996_A0_LRD_SER_INSTRUCTION_TYPE_T_T_SER_INSTRUCTION_SBUS = 3,
    /*! EP/IP: SER error in other transaction - refresh, aging etc.  */
    BCM56996_A0_LRD_SER_INSTRUCTION_TYPE_T_T_SER_INSTRUCTION_OTHER = 4,
    /*! MMU: SER error in MMU transaction.  */
    BCM56996_A0_LRD_SER_INSTRUCTION_TYPE_T_T_SER_INSTRUCTION_MMU = 5,
    /*! PORT: SER error in PORT transaction.  */
    BCM56996_A0_LRD_SER_INSTRUCTION_TYPE_T_T_SER_INSTRUCTION_PORT = 6,
} bcm56996_a0_lrd_ser_instruction_type_t_t;

/*! enum type for SER_MEM_SCAN_MODE_T
 * SER memory scan mode.
 */
typedef enum bcm56996_a0_lrd_ser_mem_scan_mode_t_e {
    /*! Disable.  */
    BCM56996_A0_LRD_SER_MEM_SCAN_MODE_T_T_DISABLE = 0,
    /*! Enable default scan mode.  */
    BCM56996_A0_LRD_SER_MEM_SCAN_MODE_T_T_ENABLE_DEFAULT_SCAN = 1,
    /*! Enable software scan mode.  */
    BCM56996_A0_LRD_SER_MEM_SCAN_MODE_T_T_ENABLE_SW_SCAN = 2,
    /*! Enable hardware scan mode.  */
    BCM56996_A0_LRD_SER_MEM_SCAN_MODE_T_T_ENABLE_HW_SCAN = 3,
} bcm56996_a0_lrd_ser_mem_scan_mode_t_t;

/*! enum type for SER_MEM_SCAN_STATUS_T
 * SER memory scan status.
 */
typedef enum bcm56996_a0_lrd_ser_mem_scan_status_t_e {
    /*! Disable.  */
    BCM56996_A0_LRD_SER_MEM_SCAN_STATUS_T_T_DISABLE = 0,
    /*! Using software scan mode.  */
    BCM56996_A0_LRD_SER_MEM_SCAN_STATUS_T_T_USING_SW_SCAN = 1,
    /*! Using hardware scan mode.  */
    BCM56996_A0_LRD_SER_MEM_SCAN_STATUS_T_T_USING_HW_SCAN = 2,
} bcm56996_a0_lrd_ser_mem_scan_status_t_t;

/*! enum type for SER_RECOVERY_KEY_TYPE_T
 * SER recovery key type. An application uses these
 *  enum values as the lookup key for SER_STATS. If an application
 *  is not concerned with specific recovery types,
 *  SER_RECOVERY_ALL can be used as the lookup key for SER_STATS.
 */
typedef enum bcm56996_a0_lrd_ser_recovery_key_type_t_e {
    /*! All recovery types.  */
    BCM56996_A0_LRD_SER_RECOVERY_KEY_TYPE_T_T_SER_RECOVERY_ALL = 0,
    /*! Correct SER error entry with cache data  */
    BCM56996_A0_LRD_SER_RECOVERY_KEY_TYPE_T_T_SER_RECOVERY_CACHE_RESTORE = 1,
    /*! Clear SER error entry.  */
    BCM56996_A0_LRD_SER_RECOVERY_KEY_TYPE_T_T_SER_RECOVERY_ENTRY_CLEAR = 2,
    /*! Do not handle SER error.  */
    BCM56996_A0_LRD_SER_RECOVERY_KEY_TYPE_T_T_SER_RECOVERY_NO_OPERATION = 3,
} bcm56996_a0_lrd_ser_recovery_key_type_t_t;

/*! enum type for SER_RECOVERY_TYPE_T
 * SER recovery type.
 */
typedef enum bcm56996_a0_lrd_ser_recovery_type_t_e {
    /*! Correct SER error entry with cache data  */
    BCM56996_A0_LRD_SER_RECOVERY_TYPE_T_T_SER_RECOVERY_CACHE_RESTORE = 1,
    /*! Clear SER error entry.  */
    BCM56996_A0_LRD_SER_RECOVERY_TYPE_T_T_SER_RECOVERY_ENTRY_CLEAR = 2,
    /*! Do not handle SER error.  */
    BCM56996_A0_LRD_SER_RECOVERY_TYPE_T_T_SER_RECOVERY_NO_OPERATION = 3,
} bcm56996_a0_lrd_ser_recovery_type_t_t;

/*! enum type for SER_VALIDATE_TYPE_T
 * Used to determine whether an validation is necessary.
 */
typedef enum bcm56996_a0_lrd_ser_validate_type_t_e {
    BCM56996_A0_LRD_SER_VALIDATE_TYPE_T_T_SER_VALIDATION = 0,
    BCM56996_A0_LRD_SER_VALIDATE_TYPE_T_T_SER_NO_VALIDATION = 1,
} bcm56996_a0_lrd_ser_validate_type_t_t;

/*! enum type for SRP_FWD_ACTION_T
 * Stream reservation protocol packet forwarding action.
 */
typedef enum bcm56996_a0_lrd_srp_fwd_action_t_e {
    /*! Forward the SRP packet.  */
    BCM56996_A0_LRD_SRP_FWD_ACTION_T_T_FORWARD = 0,
    /*! Drop the SRP packet.  */
    BCM56996_A0_LRD_SRP_FWD_ACTION_T_T_DROP = 1,
    /*! Flood the SRP packet.  */
    BCM56996_A0_LRD_SRP_FWD_ACTION_T_T_FLOOD = 2,
} bcm56996_a0_lrd_srp_fwd_action_t_t;

/*! enum type for STG_STATE_T
 * Spanning tree group state type.
 */
typedef enum bcm56996_a0_lrd_stg_state_t_e {
    /*! Disabled state.  */
    BCM56996_A0_LRD_STG_STATE_T_T_DISABLE = 0,
    /*! Blocking state.  */
    BCM56996_A0_LRD_STG_STATE_T_T_BLOCK = 1,
    /*! Listening state.  */
    BCM56996_A0_LRD_STG_STATE_T_T_LEARN = 2,
    /*! Forwarding state.  */
    BCM56996_A0_LRD_STG_STATE_T_T_FORWARD = 3,
} bcm56996_a0_lrd_stg_state_t_t;

/*! enum type for SWITCHED_PKT_TYPE_T
 * Indicates switched packet type.
 */
typedef enum bcm56996_a0_lrd_switched_pkt_type_t_e {
    /*! Packet not switched to CPU.  */
    BCM56996_A0_LRD_SWITCHED_PKT_TYPE_T_T_NOT_SWITCHED = 0,
    /*! Unicast packet switched to CPU.  */
    BCM56996_A0_LRD_SWITCHED_PKT_TYPE_T_T_UNICAST_SWITCHED = 2,
    /*! Non-unicast packet switched to CPU.  */
    BCM56996_A0_LRD_SWITCHED_PKT_TYPE_T_T_NON_UNICAST_SWITCHED = 3,
} bcm56996_a0_lrd_switched_pkt_type_t_t;

/*! enum type for SYNCE_CLK_DIVISOR_T */
typedef enum bcm56996_a0_lrd_synce_clk_divisor_t_e {
    BCM56996_A0_LRD_SYNCE_CLK_DIVISOR_T_T_DIVIDE_BY_1 = 0,
    BCM56996_A0_LRD_SYNCE_CLK_DIVISOR_T_T_DIVIDE_BY_5 = 1,
    BCM56996_A0_LRD_SYNCE_CLK_DIVISOR_T_T_DIVIDE_BY_10 = 2,
    BCM56996_A0_LRD_SYNCE_CLK_DIVISOR_T_T_DIVIDE_BY_2 = 3,
} bcm56996_a0_lrd_synce_clk_divisor_t_t;

/*! enum type for SYNCE_CLK_TYPE_T */
typedef enum bcm56996_a0_lrd_synce_clk_type_t_e {
    BCM56996_A0_LRD_SYNCE_CLK_TYPE_T_T_CLK_PRIMARY = 0,
    BCM56996_A0_LRD_SYNCE_CLK_TYPE_T_T_CLK_BACKUP = 1,
} bcm56996_a0_lrd_synce_clk_type_t_t;

/*! enum type for SYSTEM_PORT_TYPE_T
 * System port type.
 */
typedef enum bcm56996_a0_lrd_system_port_type_t_e {
    /*! Port is not a member of any TRUNK group.  */
    BCM56996_A0_LRD_SYSTEM_PORT_TYPE_T_T_NORMAL_PORT = 0,
    /*! Port is a member of a TRUNK group.  */
    BCM56996_A0_LRD_SYSTEM_PORT_TYPE_T_T_TRUNK_PORT = 1,
} bcm56996_a0_lrd_system_port_type_t_t;

/*! enum type for TM_CPU_SCHED_NODE_T
 * TM CPU Scheduler Nodes.
 */
typedef enum bcm56996_a0_lrd_tm_cpu_sched_node_t_e {
    /*! COS Level scheduling node.  */
    BCM56996_A0_LRD_TM_CPU_SCHED_NODE_T_T_L0_SCHED_NODE = 0,
    /*! Scheduler level multicast queue.  */
    BCM56996_A0_LRD_TM_CPU_SCHED_NODE_T_T_L1_SCHED_NODE_MC = 2,
} bcm56996_a0_lrd_tm_cpu_sched_node_t_t;

/*! enum type for TM_CUT_THROUGH_CLASS_T
 * Cut-through traffic class types.
 */
typedef enum bcm56996_a0_lrd_tm_cut_through_class_t_e {
    /*! Store and forward mode.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_SAF_MODE = 0,
    /*! Cut-through class 10G.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_CUT_THROUGH_CLASS_10G = 1,
    /*! Cut-through class 25G.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_CUT_THROUGH_CLASS_25G = 2,
    /*! Cut-through class 40G.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_CUT_THROUGH_CLASS_40G = 3,
    /*! Cut-through class 50G.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_CUT_THROUGH_CLASS_50G = 4,
    /*! Cut-through class 100G.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_CUT_THROUGH_CLASS_100G = 5,
    /*! Cut-through class 200G.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_CUT_THROUGH_CLASS_200G = 6,
    /*! Cut-through class 400G.  */
    BCM56996_A0_LRD_TM_CUT_THROUGH_CLASS_T_T_CUT_THROUGH_CLASS_400G = 7,
} bcm56996_a0_lrd_tm_cut_through_class_t_t;

/*! enum type for TM_ING_THD_MIN_T
 * Traffic manager ingress buffer threshold minimum guarantee mode enum
 *  definition.
 */
typedef enum bcm56996_a0_lrd_tm_ing_thd_min_t_e {
    /*! Use priority group minimum threshold.  */
    BCM56996_A0_LRD_TM_ING_THD_MIN_T_T_USE_PRI_GRP_MIN = 0,
    /*! Use port service pool minimum threshold.  */
    BCM56996_A0_LRD_TM_ING_THD_MIN_T_T_USE_PORT_SERVICE_POOL_MIN = 1,
} bcm56996_a0_lrd_tm_ing_thd_min_t_t;

/*! enum type for TM_PERCENTAGE_VALUE_T
 * XGS TM percentage value.
 */
typedef enum bcm56996_a0_lrd_tm_percentage_value_t_e {
    /*! 100%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_1000 = 0,
    /*! 12.5%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_125 = 1,
    /*! 25%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_250 = 2,
    /*! 37.5%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_375 = 3,
    /*! 50%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_500 = 4,
    /*! 67.5%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_675 = 5,
    /*! 75%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_750 = 6,
    /*! 87.5%.  */
    BCM56996_A0_LRD_TM_PERCENTAGE_VALUE_T_T_PERCENTAGE_875 = 7,
} bcm56996_a0_lrd_tm_percentage_value_t_t;

/*! enum type for TM_PFC_DEADLOCK_DETECTION_TIMER_UNIT_T
 * Enum definition for the supported time unit (tick) values for the deadlock
 *  detection countdown timer, specified by
 *  TM_PFC_DEADLOCK_RECOVERY.DETECTION_TIMER_GRANULARITY
 */
typedef enum bcm56996_a0_lrd_tm_pfc_deadlock_detection_timer_unit_t_e {
    /*! 1 millisecond timer tick unit.  */
    BCM56996_A0_LRD_TM_PFC_DEADLOCK_DETECTION_TIMER_UNIT_T_T_TIME_1_MS = 0,
    /*! 10 milliseconds timer tick unit.  */
    BCM56996_A0_LRD_TM_PFC_DEADLOCK_DETECTION_TIMER_UNIT_T_T_TIME_10_MS = 1,
    /*! 100 milliseconds timer tick unit.  */
    BCM56996_A0_LRD_TM_PFC_DEADLOCK_DETECTION_TIMER_UNIT_T_T_TIME_100_MS = 2,
} bcm56996_a0_lrd_tm_pfc_deadlock_detection_timer_unit_t_t;

/*! enum type for TM_SCHED_MODE_T
 * Traffic manager Node scheduling mode
 */
typedef enum bcm56996_a0_lrd_tm_sched_mode_t_e {
    /*! Strict Priority scheduling mode.  */
    BCM56996_A0_LRD_TM_SCHED_MODE_T_T_SP = 0,
    /*! Round Robin Scheduling mode.  */
    BCM56996_A0_LRD_TM_SCHED_MODE_T_T_RR = 1,
} bcm56996_a0_lrd_tm_sched_mode_t_t;

/*! enum type for TM_SCHED_NODE_T
 * TM Scheduler Nodes.
 */
typedef enum bcm56996_a0_lrd_tm_sched_node_t_e {
    /*! COS Level scheduling node.  */
    BCM56996_A0_LRD_TM_SCHED_NODE_T_T_L0_SCHED_NODE = 0,
    /*! Scheduler level unicast queue.  */
    BCM56996_A0_LRD_TM_SCHED_NODE_T_T_L1_SCHED_NODE_UC = 1,
    /*! Scheduler level multicast queue.  */
    BCM56996_A0_LRD_TM_SCHED_NODE_T_T_L1_SCHED_NODE_MC = 2,
} bcm56996_a0_lrd_tm_sched_node_t_t;

/*! enum type for TM_STAT_TYPE_T
 * Stat type for Traffic Manager.
 */
typedef enum bcm56996_a0_lrd_tm_stat_type_t_e {
    /*! No stat.  */
    BCM56996_A0_LRD_TM_STAT_TYPE_T_T_NONE = 0,
    /*! Current used buffer in cells.  */
    BCM56996_A0_LRD_TM_STAT_TYPE_T_T_CURRENT_USAGE_CELLS = 1,
    /*! Maximum used buffer in cells.  */
    BCM56996_A0_LRD_TM_STAT_TYPE_T_T_MAX_USAGE_CELLS = 2,
    /*! Current available buffer in cells.  */
    BCM56996_A0_LRD_TM_STAT_TYPE_T_T_CURRENT_AVAILABLE_CELLS = 3,
    /*! Minimum available buffer in cells.  */
    BCM56996_A0_LRD_TM_STAT_TYPE_T_T_MIN_AVAILABLE_CELLS = 4,
} bcm56996_a0_lrd_tm_stat_type_t_t;

/*! enum type for TM_THD_ALPHA_VALUE_T
 * XGS TM Alpha value.
 */
typedef enum bcm56996_a0_lrd_tm_thd_alpha_value_t_e {
    /*! 1/128.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1_128 = 0,
    /*! 1/64.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1_64 = 1,
    /*! 1/32.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1_32 = 2,
    /*! 1/16.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1_16 = 3,
    /*! 1/8.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1_8 = 4,
    /*! 1/4.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1_4 = 5,
    /*! 1/2.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1_2 = 6,
    /*! 1.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_1 = 7,
    /*! 2.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_2 = 8,
    /*! 4.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_4 = 9,
    /*! 8.  */
    BCM56996_A0_LRD_TM_THD_ALPHA_VALUE_T_T_ALPHA_8 = 10,
} bcm56996_a0_lrd_tm_thd_alpha_value_t_t;

/*! enum type for TM_THD_DYNAMIC_GROUP_T
 * Enum defines dynamic group for egress queue.
 */
typedef enum bcm56996_a0_lrd_tm_thd_dynamic_group_t_e {
    /*! Middle priority group.  */
    BCM56996_A0_LRD_TM_THD_DYNAMIC_GROUP_T_T_MID_PRI_GROUP = 0,
    /*! Low priority group.  */
    BCM56996_A0_LRD_TM_THD_DYNAMIC_GROUP_T_T_LOW_PRI_GROUP = 1,
    /*! High priority group.  */
    BCM56996_A0_LRD_TM_THD_DYNAMIC_GROUP_T_T_HIGH_PRI_GROUP = 2,
} bcm56996_a0_lrd_tm_thd_dynamic_group_t_t;

/*! enum type for TM_THD_MODE_T
 * XGS TM threshold MMU mode
 */
typedef enum bcm56996_a0_lrd_tm_thd_mode_t_e {
    /*! Entire TM buffers operate in lossy mode.  */
    BCM56996_A0_LRD_TM_THD_MODE_T_T_LOSSY = 0,
    /*! Entire TM buffers operate in lossless mode.  */
    BCM56996_A0_LRD_TM_THD_MODE_T_T_LOSSLESS = 1,
    /*!
     * TM buffers operate in either lossy mode or lossless mode.
     *  The mode selection is based on the priority group assigned and
     *  whether the priority group is lossless or lossy.
     */
    BCM56996_A0_LRD_TM_THD_MODE_T_T_LOSSY_AND_LOSSLESS = 2,
} bcm56996_a0_lrd_tm_thd_mode_t_t;

/*! enum type for TM_WRED_DROP_PERCENTAGE_T
 * WRED drop percentage.
 */
typedef enum bcm56996_a0_lrd_tm_wred_drop_percentage_t_e {
    /*! Zero drop rate.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_0 = 0,
    /*! Drop rate 1%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_1 = 1,
    /*! Drop rate 2%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_2 = 2,
    /*! Drop rate 3%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_3 = 3,
    /*! Drop rate 4%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_4 = 4,
    /*! Drop rate 5%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_5 = 5,
    /*! Drop rate 6%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_6 = 6,
    /*! Drop rate 7%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_7 = 7,
    /*! Drop rate 8%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_8 = 8,
    /*! Drop rate 9%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_9 = 9,
    /*! Drop rate 10%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_10 = 10,
    /*! Drop rate 25%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_25 = 11,
    /*! Drop rate 50%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_50 = 12,
    /*! Drop rate 75%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_75 = 13,
    /*! Drop rate 100%.  */
    BCM56996_A0_LRD_TM_WRED_DROP_PERCENTAGE_T_T_TM_WRED_DROP_PERCENTAGE_100 = 14,
} bcm56996_a0_lrd_tm_wred_drop_percentage_t_t;

/*! enum type for TM_WRED_JITTER_T
 * WRED jitter time range in nanoseconds with step size = 50ns
 */
typedef enum bcm56996_a0_lrd_tm_wred_jitter_t_e {
    /*! Jitter from 50ns to 0.  */
    BCM56996_A0_LRD_TM_WRED_JITTER_T_T_TM_WRED_JITTER_RANGE_50NS_0 = 1,
    /*! Jitter from 150ns to 0.  */
    BCM56996_A0_LRD_TM_WRED_JITTER_T_T_TM_WRED_JITTER_RANGE_150NS_0 = 2,
    /*! Jitter from 350ns to 0.  */
    BCM56996_A0_LRD_TM_WRED_JITTER_T_T_TM_WRED_JITTER_RANGE_350NS_0 = 3,
    /*! Jitter from 750ns to 0.  */
    BCM56996_A0_LRD_TM_WRED_JITTER_T_T_TM_WRED_JITTER_RANGE_750NS_0 = 4,
    /*! Jitter from 1550ns to 0.  */
    BCM56996_A0_LRD_TM_WRED_JITTER_T_T_TM_WRED_JITTER_RANGE_1550NS_0 = 5,
    /*! Jitter from 3150ns to 0.  */
    BCM56996_A0_LRD_TM_WRED_JITTER_T_T_TM_WRED_JITTER_RANGE_3150NS_0 = 6,
    /*! Jitter from 6350ns to 0.  */
    BCM56996_A0_LRD_TM_WRED_JITTER_T_T_TM_WRED_JITTER_RANGE_6350NS_0 = 7,
} bcm56996_a0_lrd_tm_wred_jitter_t_t;

/*! enum type for TM_WRED_TIME_DOMAIN_T
 * Timer domain profiles.
 */
typedef enum bcm56996_a0_lrd_tm_wred_time_domain_t_e {
    /*! Time domain 0.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_0_5_US = 0,
    /*! Time domain 1 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_1_US = 1,
    /*! Time domain 1.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_1_5_US = 2,
    /*! Time domain 2 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_2_US = 3,
    /*! Time domain 2.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_2_5_US = 4,
    /*! Time domain 3 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_3_US = 5,
    /*! Time domain 3.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_3_5_US = 6,
    /*! Time domain 4 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_4_US = 7,
    /*! Time domain 4.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_4_5_US = 8,
    /*! Time domain 5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_5_US = 9,
    /*! Time domain 5.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_5_5_US = 10,
    /*! Time domain 6 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_6_US = 11,
    /*! Time domain 6.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_6_5_US = 12,
    /*! Time domain 7 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_7_US = 13,
    /*! Time domain 7.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_7_5_US = 14,
    /*! Time domain 8 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_8_US = 15,
    /*! Time domain 8.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_8_5_US = 16,
    /*! Time domain 9 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_9_US = 17,
    /*! Time domain 9.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_9_5_US = 18,
    /*! Time domain 10 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_10_US = 19,
    /*! Time domain 10.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_10_5_US = 20,
    /*! Time domain 11 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_11_US = 21,
    /*! Time domain 11.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_11_5_US = 22,
    /*! Time domain 12 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_12_US = 23,
    /*! Time domain 12.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_12_5_US = 24,
    /*! Time domain 13 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_13_US = 25,
    /*! Time domain 13.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_13_5_US = 26,
    /*! Time domain 14 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_14_US = 27,
    /*! Time domain 14.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_14_5_US = 28,
    /*! Time domain 15 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_15_US = 29,
    /*! Time domain 15.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_15_5_US = 30,
    /*! Time domain 16 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_16_US = 31,
    /*! Time domain 16.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_16_5_US = 32,
    /*! Time domain 17 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_17_US = 33,
    /*! Time domain 17.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_17_5_US = 34,
    /*! Time domain 18 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_18_US = 35,
    /*! Time domain 18.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_18_5_US = 36,
    /*! Time domain 19 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_19_US = 37,
    /*! Time domain 19.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_19_5_US = 38,
    /*! Time domain 20 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_20_US = 39,
    /*! Time domain 20.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_20_5_US = 40,
    /*! Time domain 21 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_21_US = 41,
    /*! Time domain 21.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_21_5_US = 42,
    /*! Time domain 22 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_22_US = 43,
    /*! Time domain 22.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_22_5_US = 44,
    /*! Time domain 23 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_23_US = 45,
    /*! Time domain 23.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_23_5_US = 46,
    /*! Time domain 24 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_24_US = 47,
    /*! Time domain 24.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_24_5_US = 48,
    /*! Time domain 25 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_25_US = 49,
    /*! Time domain 25.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_25_5_US = 50,
    /*! Time domain 26 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_26_US = 51,
    /*! Time domain 26.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_26_5_US = 52,
    /*! Time domain 27 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_27_US = 53,
    /*! Time domain 27.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_27_5_US = 54,
    /*! Time domain 28 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_28_US = 55,
    /*! Time domain 28.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_28_5_US = 56,
    /*! Time domain 29 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_29_US = 57,
    /*! Time domain 29.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_29_5_US = 58,
    /*! Time domain 30 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_30_US = 59,
    /*! Time domain 30.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_30_5_US = 60,
    /*! Time domain 31 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_31_US = 61,
    /*! Time domain 31.5 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_31_5_US = 62,
    /*! Time domain 32 us  */
    BCM56996_A0_LRD_TM_WRED_TIME_DOMAIN_T_T_TIME_DOMAIN_32_US = 63,
} bcm56996_a0_lrd_tm_wred_time_domain_t_t;

/*! enum type for TNL_IPV4_CONFIG_MODE_T
 * Indicates whether the tunnel is an auto or configured tunnel.
 */
typedef enum bcm56996_a0_lrd_tnl_ipv4_config_mode_t_e {
    /*! Configured tunnel.  */
    BCM56996_A0_LRD_TNL_IPV4_CONFIG_MODE_T_T_CONFIG = 0,
    /*! Automatic tunnel.  */
    BCM56996_A0_LRD_TNL_IPV4_CONFIG_MODE_T_T_AUTO = 1,
} bcm56996_a0_lrd_tnl_ipv4_config_mode_t_t;

/*! enum type for TNL_IPV4_DECAP_TYPE_T
 * Indicates L3 tunnel type.
 */
typedef enum bcm56996_a0_lrd_tnl_ipv4_decap_type_t_e {
    /*! IP6TOIP4 tunnel.  */
    BCM56996_A0_LRD_TNL_IPV4_DECAP_TYPE_T_T_IP6TOIP4 = 0,
    /*! ISATAP tunnel.  */
    BCM56996_A0_LRD_TNL_IPV4_DECAP_TYPE_T_T_ISATAP = 1,
    /*! IP6TOIP4SECURE tunnel.  */
    BCM56996_A0_LRD_TNL_IPV4_DECAP_TYPE_T_T_IP6TOIP4SECURE = 2,
    /*! Reserved value.  */
    BCM56996_A0_LRD_TNL_IPV4_DECAP_TYPE_T_T_RESERVED = 3,
} bcm56996_a0_lrd_tnl_ipv4_decap_type_t_t;

/*! enum type for TNL_IPV6_CONFIG_MODE_T
 * Indicates whether the tunnel is an auto or configured tunnel.
 */
typedef enum bcm56996_a0_lrd_tnl_ipv6_config_mode_t_e {
    /*! Configured tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_CONFIG_MODE_T_T_CONFIG = 0,
    /*! Automatic tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_CONFIG_MODE_T_T_AUTO = 1,
} bcm56996_a0_lrd_tnl_ipv6_config_mode_t_t;

/*! enum type for TNL_IPV6_DECAP_TYPE_T
 * Indicates L3 tunnel type.
 */
typedef enum bcm56996_a0_lrd_tnl_ipv6_decap_type_t_e {
    /*! IP6TOIP4 tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_DECAP_TYPE_T_T_IP6TOIP4 = 0,
    /*! ISATAP tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_DECAP_TYPE_T_T_ISATAP = 1,
    /*! IP6TOIP4SECURE tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_DECAP_TYPE_T_T_IP6TOIP4SECURE = 2,
    /*! Reserved value.  */
    BCM56996_A0_LRD_TNL_IPV6_DECAP_TYPE_T_T_RESERVED = 3,
} bcm56996_a0_lrd_tnl_ipv6_decap_type_t_t;

/*! enum type for TNL_IPV6_TYPE_T
 * Tunnel type for IPv6 tunnel.
 */
typedef enum bcm56996_a0_lrd_tnl_ipv6_type_t_e {
    /*! IP tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_TYPE_T_T_IP = 0,
    /*! GRE tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_TYPE_T_T_GRE = 4,
    /*! PIMSM_DR1 tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_TYPE_T_T_PIMSM_DR1 = 5,
    /*! PIMSM_DR2 tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_TYPE_T_T_PIMSM_DR2 = 6,
    /*! Virtual eXtensible Local Area Network (VXLAN) tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_TYPE_T_T_VXLAN = 7,
    /*! AMT tunnel.  */
    BCM56996_A0_LRD_TNL_IPV6_TYPE_T_T_AMT = 10,
} bcm56996_a0_lrd_tnl_ipv6_type_t_t;

/*! enum type for TNL_MPLS_EXP_MODE_T
 * EXP mode for MPLS VC/VPN label.
 */
typedef enum bcm56996_a0_lrd_tnl_mpls_exp_mode_t_e {
    /*! Use EXP value from the tunnel table.  */
    BCM56996_A0_LRD_TNL_MPLS_EXP_MODE_T_T_FIXED = 0,
    /*! Use PHB_EGR_MPLS_ID to derive EXP value.  */
    BCM56996_A0_LRD_TNL_MPLS_EXP_MODE_T_T_MAP = 1,
    /*! Use inner label's EXP value.  */
    BCM56996_A0_LRD_TNL_MPLS_EXP_MODE_T_T_USE_INNER_LABEL = 2,
    /*! Use EXP value of the swapped label.  */
    BCM56996_A0_LRD_TNL_MPLS_EXP_MODE_T_T_USE_SWAP_LABEL = 3,
} bcm56996_a0_lrd_tnl_mpls_exp_mode_t_t;

/*! enum type for TNL_MPLS_LABEL_ACTION_T
 * Label action for Transit tunnels.
 */
typedef enum bcm56996_a0_lrd_tnl_mpls_label_action_t_e {
    /*! No action.  */
    BCM56996_A0_LRD_TNL_MPLS_LABEL_ACTION_T_T_NONE = 0,
    /*! Swap the label.  */
    BCM56996_A0_LRD_TNL_MPLS_LABEL_ACTION_T_T_SWAP = 2,
    /*! Preserve the label.  */
    BCM56996_A0_LRD_TNL_MPLS_LABEL_ACTION_T_T_PRESERVE = 3,
} bcm56996_a0_lrd_tnl_mpls_label_action_t_t;

/*! enum type for TNL_TYPE_T
 * Tunnel type for IPv4 tunnel.
 */
typedef enum bcm56996_a0_lrd_tnl_type_t_e {
    /*! IP tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_IP = 0,
    /*! IP6TOIP4 tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_IP6TOIP4 = 1,
    /*! ISATAP tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_ISATAP = 2,
    /*! IP6TOIP4Secure tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_IP6TOIP4SECURE = 3,
    /*! GRE tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_GRE = 4,
    /*! PIMSM_DR1 tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_PIMSM_DR1 = 5,
    /*! PIMSM_DR2 tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_PIMSM_DR2 = 6,
    /*! Virtual eXtensible Local Area Network (VXLAN) tunnel.  */
    BCM56996_A0_LRD_TNL_TYPE_T_T_VXLAN = 7,
} bcm56996_a0_lrd_tnl_type_t_t;

/*! enum type for TRUNK_FAILOVER_RTAG_T
 * Rule tag enumeration type for trunk failover.
 */
typedef enum bcm56996_a0_lrd_trunk_failover_rtag_t_e {
    /*! Hash entry always zero.   */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_ZERO = 0,
    /*! Based on SA, VLAN, Ethertype, source module ID/port.  */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_SMAC = 1,
    /*! Based on DA, VLAN, Ethertype, source module ID/port.  */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_DMAC = 2,
    /*! Based on SA/DA,VLAN,Ethertype,src moduleID/port.  */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_SRCDSTMAC = 3,
    /*! Based on SIP and source TCP/UDP port.  */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_SIP = 4,
    /*! Based on DIP and destination TCP/UDP port.  */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_DIP = 5,
    /*! Based on SIP/DIP and src/dst TCP/UDP port.  */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_SRCDSTIP = 6,
    /*! Based on enhanced LB_HASH hashing algorithm.  */
    BCM56996_A0_LRD_TRUNK_FAILOVER_RTAG_T_T_LB_HASH = 7,
} bcm56996_a0_lrd_trunk_failover_rtag_t_t;

/*! enum type for TRUNK_FAST_LB_MODE_T
 * TRUNK_FAST Load Balancing Mode enumeration type.
 */
typedef enum bcm56996_a0_lrd_trunk_fast_lb_mode_t_e {
    /*! Regular hash mode.  */
    BCM56996_A0_LRD_TRUNK_FAST_LB_MODE_T_T_REG_HASH = 0,
    /*! Random mode.  */
    BCM56996_A0_LRD_TRUNK_FAST_LB_MODE_T_T_RANDOM = 1,
} bcm56996_a0_lrd_trunk_fast_lb_mode_t_t;

/*! enum type for TS_CF_UPDATE_MODE_T
 * Defines the correction field update mode
 */
typedef enum bcm56996_a0_lrd_ts_cf_update_mode_t_e {
    /*! Never update the correction field.  */
    BCM56996_A0_LRD_TS_CF_UPDATE_MODE_T_T_DISABLE = 0,
    /*!
     * Enable correction field based on local IEEE 1588 event
     *  packet parsing.
     */
    BCM56996_A0_LRD_TS_CF_UPDATE_MODE_T_T_PORT_BASED_ENABLE = 1,
    /*!
     * Enable IEEE 1588 correction field updates for all 1588 event packets
     *  for which ingress correction field updates have been done.
     */
    BCM56996_A0_LRD_TS_CF_UPDATE_MODE_T_T_ING_UPDATE_BASED_ENABLE = 2,
} bcm56996_a0_lrd_ts_cf_update_mode_t_t;

/*! enum type for TS_IEEE1588_VERSION_T
 * IEEE1588 version.
 */
typedef enum bcm56996_a0_lrd_ts_ieee1588_version_t_e {
    /*! IEEE1588 version field must be equal 2.  */
    BCM56996_A0_LRD_TS_IEEE1588_VERSION_T_T_VER_EQ_2 = 0,
    /*! IEEE1588 version field must be greater than or equal to 2.  */
    BCM56996_A0_LRD_TS_IEEE1588_VERSION_T_T_VER_GT_OR_EQ_2 = 1,
} bcm56996_a0_lrd_ts_ieee1588_version_t_t;

/*! enum type for TS_TIMESTAMPING_MODE_T
 * Timestamping Mode.
 */
typedef enum bcm56996_a0_lrd_ts_timestamping_mode_t_e {
    /*! 32-bit mode.  */
    BCM56996_A0_LRD_TS_TIMESTAMPING_MODE_T_T_TIMESTAMP_32_MODE = 0,
    /*! 48-bit mode.  */
    BCM56996_A0_LRD_TS_TIMESTAMPING_MODE_T_T_TIMESTAMP_48_MODE = 1,
} bcm56996_a0_lrd_ts_timestamping_mode_t_t;

/*! enum type for UDF_BASE_LAYER_ENCODE_T
 * Enum defines the base layer encoding for UDF chunk selection.
 */
typedef enum bcm56996_a0_lrd_udf_base_layer_encode_t_e {
    /*!
     * Start of the module header container.
     *  This 20 byte container consists of the following bytes for
     *  various packet types:
     *  (1) Ethernet packet: All zeros
     *  (2) HiGig+ packet: {hgplus_mhdr[95:0],64'h0}
     *  (3) HiGig2 packet: {hg2_mhdr[127:0],32'h0}
     *  (4) HiGig2 packet with Sirius extension header:
     *           {hg2_mhdr[127:0],sirius_ext_hdr[31:0]}
     */
    BCM56996_A0_LRD_UDF_BASE_LAYER_ENCODE_T_T_MODULE_HDR = 0,
    /*! Start of the L2 header stack in the packet.  */
    BCM56996_A0_LRD_UDF_BASE_LAYER_ENCODE_T_T_L2_HDR = 1,
    /*!
     * Start of the outer L3 header stack in the packet.
     *  (1) For non-IP packets, this is the end of the L2 header (start
     *      with bytes after Ethertype).
     *      a. For FCoE packets, this is the start of the FCoE header
     *      b. For TRILL packets, this is the start of the TRILL header
     *  (2) For non-tunneled IP packets, this is the start of the IP
     *      header.
     *  (3) For tunneled IP packets, this is the start of the outer IP
     *      header.
     */
    BCM56996_A0_LRD_UDF_BASE_LAYER_ENCODE_T_T_OUTER_L3_HDR = 2,
    /*!
     * Start of the inner L3 header stack in the packet.
     *  (1) For non-IP packets, this is the end of the L2 header (start
     *      with bytes after Ethertype).
     *  (2) For non-tunneled IP packets, this is the start of the L4
     *      header.
     *  (3) For tunneled IP packets, this is the start of the inner IP
     *      header.
     */
    BCM56996_A0_LRD_UDF_BASE_LAYER_ENCODE_T_T_INNER_L3_HDR = 3,
    /*!
     * Start of the L4 header stack in the packet.
     *  (1) For all IP packets (tunneled or not, with 0/1/2 extension
     *      headers), this is the start of the L4 header.
     *  (2) For TRILL packets, this is the start of the TRILL Payload.
     *  (3) For non-TRILL, non-IP packets, this is the end of the
     *      L2 header (start with bytes after Ethertype).
     */
    BCM56996_A0_LRD_UDF_BASE_LAYER_ENCODE_T_T_L4_HDR = 4,
} bcm56996_a0_lrd_udf_base_layer_encode_t_t;

/*! enum type for UDF_PKT_FORMAT_L2_TYPE_T
 * Enum defines L2 protocol type of the packet.
 */
typedef enum bcm56996_a0_lrd_udf_pkt_format_l2_type_t_e {
    /*! L2 packet format is Ethernet_2.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L2_TYPE_T_T_ETHER_2 = 0,
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L2_TYPE_T_T_SNAP = 1,
    /*! L2 packet format is LLC.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L2_TYPE_T_T_LLC = 2,
    /*! L2 packet format is other than specified values in this enum.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L2_TYPE_T_T_OTHER = 3,
} bcm56996_a0_lrd_udf_pkt_format_l2_type_t_t;

/*! enum type for UDF_PKT_FORMAT_L3_HDR_TYPE_T
 * Enum defines L3 header configurations in the packet.
 */
typedef enum bcm56996_a0_lrd_udf_pkt_format_l3_hdr_type_t_e {
    /*! IPv4 header without options.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L3_HDR_TYPE_T_T_IPV4_NO_OPTIONS = 0,
    /*! IPv4 header with options.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L3_HDR_TYPE_T_T_IPV4_WITH_OPTIONS = 1,
    /*! Non-IP header.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L3_HDR_TYPE_T_T_NON_IP = 2,
    /*! IPv6 header without extension headers.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L3_HDR_TYPE_T_T_IPV6_NO_EXTN = 4,
    /*! IPv6 header with extension headers.  */
    BCM56996_A0_LRD_UDF_PKT_FORMAT_L3_HDR_TYPE_T_T_IPV6_WITH_EXTN = 5,
} bcm56996_a0_lrd_udf_pkt_format_l3_hdr_type_t_t;

/*! enum type for VFI_BLOCK_MASK_MODE_T
 * VFI port block mask mode type.
 */
typedef enum bcm56996_a0_lrd_vfi_block_mask_mode_t_e {
    /*! Do not apply block mask A or B.  */
    BCM56996_A0_LRD_VFI_BLOCK_MASK_MODE_T_T_USE_NONE = 0,
    /*! Apply block mask A only.  */
    BCM56996_A0_LRD_VFI_BLOCK_MASK_MODE_T_T_USE_BLOCK_MASK_A = 1,
    /*! Apply block mask B only.  */
    BCM56996_A0_LRD_VFI_BLOCK_MASK_MODE_T_T_USE_BLOCK_MASK_B = 2,
    /*! Apply both block mask A and B.  */
    BCM56996_A0_LRD_VFI_BLOCK_MASK_MODE_T_T_USE_BLOCK_MASK_A_B = 3,
} bcm56996_a0_lrd_vfi_block_mask_mode_t_t;

/*! enum type for VLAN_EGR_SOT_OCFI_T
 * Action for the internal single outer-tagged packet's outgoing outer CFI
 *  in the egress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_egr_sot_ocfi_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_OCFI_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the CFI with the internal outer CFI.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_OCFI_T_T_REPLACE = 2,
} bcm56996_a0_lrd_vlan_egr_sot_ocfi_t_t;

/*! enum type for VLAN_EGR_SOT_OPRI_T
 * Action for the internal single outer-tagged packet's outgoing outer priority
 *  in the egress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_egr_sot_opri_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_OPRI_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the priority with the internal outer priority.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_OPRI_T_T_REPLACE = 2,
} bcm56996_a0_lrd_vlan_egr_sot_opri_t_t;

/*! enum type for VLAN_EGR_SOT_OTAG_T
 * Action for the internal single outer-tagged packet's outgoing outer VLAN
 *  in the egress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_egr_sot_otag_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_OTAG_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the VLAN with  the internal outer VLAN.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_OTAG_T_T_REPLACE = 2,
    /*! Delete the VLAN.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_OTAG_T_T_DELETE = 3,
} bcm56996_a0_lrd_vlan_egr_sot_otag_t_t;

/*! enum type for VLAN_EGR_SOT_POTAG_T
 * Action for the internal single outer priority-tagged packet's outgoing outer
 *  VLAN in the egress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_egr_sot_potag_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_POTAG_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the VLAN with the internal outer VLAN.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_POTAG_T_T_REPLACE = 2,
    /*! Delete the VLAN.  */
    BCM56996_A0_LRD_VLAN_EGR_SOT_POTAG_T_T_DELETE = 3,
} bcm56996_a0_lrd_vlan_egr_sot_potag_t_t;

/*! enum type for VLAN_EGR_UT_OCFI_T
 * Action for the internal untagged packet's outgoing outer CFI
 *  in the egress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_egr_ut_ocfi_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_EGR_UT_OCFI_T_T_DO_NOT_MODIFY = 0,
    /*! Add the CFI with the internal outer CFI.  */
    BCM56996_A0_LRD_VLAN_EGR_UT_OCFI_T_T_ADD = 1,
} bcm56996_a0_lrd_vlan_egr_ut_ocfi_t_t;

/*! enum type for VLAN_EGR_UT_OPRI_T
 * Action for the internal untagged packet's outgoing outer priority
 *  in the egress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_egr_ut_opri_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_EGR_UT_OPRI_T_T_DO_NOT_MODIFY = 0,
    /*! Add the priority with the internal outer priority.  */
    BCM56996_A0_LRD_VLAN_EGR_UT_OPRI_T_T_ADD = 1,
} bcm56996_a0_lrd_vlan_egr_ut_opri_t_t;

/*! enum type for VLAN_EGR_UT_OTAG_T
 * Action for the internal untagged packet's outgoing outer VLAN
 *  in the egress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_egr_ut_otag_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_EGR_UT_OTAG_T_T_DO_NOT_MODIFY = 0,
    /*! Add the VLAN with the internal outer VLAN.  */
    BCM56996_A0_LRD_VLAN_EGR_UT_OTAG_T_T_ADD = 1,
} bcm56996_a0_lrd_vlan_egr_ut_otag_t_t;

/*! enum type for VLAN_ING_SOT_OCFI_T
 * Action for the single outer-tagged packet's outer CFI in the ingress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_ing_sot_ocfi_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_OCFI_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the CFI with the internal outer CFI.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_OCFI_T_T_REPLACE = 2,
} bcm56996_a0_lrd_vlan_ing_sot_ocfi_t_t;

/*! enum type for VLAN_ING_SOT_OPRI_T
 * Action for the single outer-tagged packet's outer priority in the ingress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_ing_sot_opri_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_OPRI_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the priority with the internal outer priority.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_OPRI_T_T_REPLACE = 2,
} bcm56996_a0_lrd_vlan_ing_sot_opri_t_t;

/*! enum type for VLAN_ING_SOT_OTAG_T
 * Action for the single outer-tagged packet's outer VLAN in the ingress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_ing_sot_otag_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_OTAG_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the VLAN with the internal outer VLAN.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_OTAG_T_T_REPLACE = 2,
    /*! Delete the VLAN.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_OTAG_T_T_DELETE = 3,
} bcm56996_a0_lrd_vlan_ing_sot_otag_t_t;

/*! enum type for VLAN_ING_SOT_POTAG_T
 * Action for the single outer priority-tagged packet's outer VLAN
 *  in the ingress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_ing_sot_potag_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_POTAG_T_T_DO_NOT_MODIFY = 0,
    /*! Replace the VLAN with the internal outer VLAN.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_POTAG_T_T_REPLACE = 2,
    /*! Delete the VLAN.  */
    BCM56996_A0_LRD_VLAN_ING_SOT_POTAG_T_T_DELETE = 3,
} bcm56996_a0_lrd_vlan_ing_sot_potag_t_t;

/*! enum type for VLAN_ING_UT_OCFI_T
 * Action for the untagged packet's outer CFI in the ingress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_ing_ut_ocfi_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_ING_UT_OCFI_T_T_DO_NOT_MODIFY = 0,
    /*! Add the CFI with the internal outer CFI.  */
    BCM56996_A0_LRD_VLAN_ING_UT_OCFI_T_T_ADD = 1,
} bcm56996_a0_lrd_vlan_ing_ut_ocfi_t_t;

/*! enum type for VLAN_ING_UT_OPRI_T
 * Action for the untagged packet's outer priority in the ingress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_ing_ut_opri_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_ING_UT_OPRI_T_T_DO_NOT_MODIFY = 0,
    /*! Add the priority with the internal outer priority.  */
    BCM56996_A0_LRD_VLAN_ING_UT_OPRI_T_T_ADD = 1,
} bcm56996_a0_lrd_vlan_ing_ut_opri_t_t;

/*! enum type for VLAN_ING_UT_OTAG_T
 * Action for the untagged packet's outer VLAN in the ingress pipeline.
 */
typedef enum bcm56996_a0_lrd_vlan_ing_ut_otag_t_e {
    /*! Do not modify.  */
    BCM56996_A0_LRD_VLAN_ING_UT_OTAG_T_T_DO_NOT_MODIFY = 0,
    /*! Add the VLAN with the internal outer VLAN ID.  */
    BCM56996_A0_LRD_VLAN_ING_UT_OTAG_T_T_ADD = 1,
} bcm56996_a0_lrd_vlan_ing_ut_otag_t_t;

/*! enum type for VLAN_TAG_NOT_PRESENT_ACTION_T
 * VLAN tag actions if it is not present.
 */
typedef enum bcm56996_a0_lrd_vlan_tag_not_present_action_t_e {
    /*! No action.  */
    BCM56996_A0_LRD_VLAN_TAG_NOT_PRESENT_ACTION_T_T_NO_ACTION = 0,
    /*! Add VLAN and TPID.  */
    BCM56996_A0_LRD_VLAN_TAG_NOT_PRESENT_ACTION_T_T_ADD_VLAN_TPID = 1,
} bcm56996_a0_lrd_vlan_tag_not_present_action_t_t;

/*! enum type for VLAN_TAG_PRESENT_ACTION_T
 * VLAN tag actions if it is present.
 */
typedef enum bcm56996_a0_lrd_vlan_tag_present_action_t_e {
    /*! No action.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_NO_ACTION = 0,
    /*! Replace VLAN and TPID.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_REPLACE_VLAN_TPID = 1,
    /*! Replace VLAN only.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_REPLACE_VLAN = 2,
    /*! Delete the tag.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_DELETE = 3,
    /*! Replace VLAN, priority and TPID.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_REPLACE_VLAN_PRI_TPID = 4,
    /*! Replace VLAN, priority.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_REPLACE_VLAN_PRI = 5,
    /*! Replace priority only.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_REPLACE_PRI = 6,
    /*! Replace TPID only.  */
    BCM56996_A0_LRD_VLAN_TAG_PRESENT_ACTION_T_T_REPLACE_TPID = 7,
} bcm56996_a0_lrd_vlan_tag_present_action_t_t;

/*! enum type for VLAN_TAG_TYPE_T
 * Enum defines VLAN tag type present in the packet.
 */
typedef enum bcm56996_a0_lrd_vlan_tag_type_t_e {
    /*! No VLAN tag.  */
    BCM56996_A0_LRD_VLAN_TAG_TYPE_T_T_UNTAGGED = 0,
    /*! Single VLAN tag.  */
    BCM56996_A0_LRD_VLAN_TAG_TYPE_T_T_SINGLE_TAGGED = 1,
} bcm56996_a0_lrd_vlan_tag_type_t_t;

/*! enum type for VXLAN_DECAP_KEY_MODE_T
 * Indicates the key mode for decapsulation determination during
 *  VXLAN tunnel decapsulation.
 */
typedef enum bcm56996_a0_lrd_vxlan_decap_key_mode_t_e {
    /*! Use outer VLAN ID and destination IP address.  */
    BCM56996_A0_LRD_VXLAN_DECAP_KEY_MODE_T_T_OVID_DST_IP = 0,
    /*!
     * Use outer VLAN ID and source IP address and destination IP
     *  address.
     */
    BCM56996_A0_LRD_VXLAN_DECAP_KEY_MODE_T_T_OVID_IP = 1,
} bcm56996_a0_lrd_vxlan_decap_key_mode_t_t;

/*! enum type for VXLAN_SRC_L4_PORT_SELECT_T
 * Select options for layer 4 source port for UDP header during VXLAN
 *  encapsulation.
 */
typedef enum bcm56996_a0_lrd_vxlan_src_l4_port_select_t_e {
    /*!
     * Select SRC_L4_PORT from TNL_IPV4_ENCAP, TNL_IPV6_ENCAP as
     *  layer 4 source port.
     */
    BCM56996_A0_LRD_VXLAN_SRC_L4_PORT_SELECT_T_T_SRC_L4_PORT = 0,
    /*! Select hash entropy value in the range 0-65535.  */
    BCM56996_A0_LRD_VXLAN_SRC_L4_PORT_SELECT_T_T_HASH_ENTROPY = 1,
    /*! Select hash entropy value in the private range 49152-65535.  */
    BCM56996_A0_LRD_VXLAN_SRC_L4_PORT_SELECT_T_T_HASH_ENTROPY_PRIVATE = 2,
} bcm56996_a0_lrd_vxlan_src_l4_port_select_t_t;

/*! enum type for VXLAN_TNL_HDR_FOR_PHB_T
 * Indicates how to generate PHB based on tunnel header.
 */
typedef enum bcm56996_a0_lrd_vxlan_tnl_hdr_for_phb_t_e {
    /*! Don't use tunnel L2 or L3 header for PHB.  */
    BCM56996_A0_LRD_VXLAN_TNL_HDR_FOR_PHB_T_T_NONE = 0,
    /*! Use Differentiated Services field (DSCP) from L3 header for PHB.  */
    BCM56996_A0_LRD_VXLAN_TNL_HDR_FOR_PHB_T_T_USE_TNL_L3_DSCP_FOR_PHB = 1,
    /*! Use DOT1P PCP and CFI from L2 header for PHB.  */
    BCM56996_A0_LRD_VXLAN_TNL_HDR_FOR_PHB_T_T_USE_TNL_L2_DOT1P_CFI_FOR_PHB = 2,
} bcm56996_a0_lrd_vxlan_tnl_hdr_for_phb_t_t;

/*! enum type for VXLAN_VFI_ASSIGN_KEY_MODE_T
 * Indicates the key mode for virtual forwarding instance (VFI) assignment
 *  during VXLAN tunnel decapsulation.
 */
typedef enum bcm56996_a0_lrd_vxlan_vfi_assign_key_mode_t_e {
    /*! Use outer VLAN ID and VNID.  */
    BCM56996_A0_LRD_VXLAN_VFI_ASSIGN_KEY_MODE_T_T_OVID_VNID = 0,
    /*! Use outer VLAN ID and VNID and source IP address.  */
    BCM56996_A0_LRD_VXLAN_VFI_ASSIGN_KEY_MODE_T_T_OVID_VNID_SRC_IP = 1,
} bcm56996_a0_lrd_vxlan_vfi_assign_key_mode_t_t;

#endif /* DOXYGEN_IGNORE_AUTOGEN */
#endif /* BCM56996_A0_LRD_ENUM_CTYPE_H */
