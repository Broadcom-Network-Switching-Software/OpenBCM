#ifndef __BCMI_FALCON_XGXS_DEFS_H__
#define __BCMI_FALCON_XGXS_DEFS_H__
/*******************************************************************************
 *
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2020 Broadcom Inc. All rights reserved.
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated from the registers file.
 * Edits to this file will be lost when it is regenerated.
 *
 * Definition file for the BCMI_FALCON_XGXS.
 * This file provides all basic definitions required to program the BCMI_FALCON_XGXS.
 *
 * This file is autogenerated. Please do not edit.
 */

#ifndef _DV_TB_
#include <phymod/acc/phymod_tsc_iblk.h>
#endif /* _DV_TB_ */

/*******************************************************************************
 *
 *                    CHIP DEFINITIONS BEGIN HERE
 */



/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  ACC_CTL
 * BLOCKS:   MDIO_CL22_IEEE_COM
 * REGADDR:  0x000d
 * DEVAD:    1
 * DESC:     MMD_access_control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DEVAD       Device address
 *     MDIO_FUNCTION    00 = address01 = data, no post increment10 = data, post increment on reads and write11 = data, post increment on writes only
 */
#define BCMI_FALCON_XGXS_ACC_CTLr (0x0001000d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_ACC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program ACC_CTL.
 */
typedef union BCMI_FALCON_XGXS_ACC_CTLr_s {
	uint32_t v[1];
	uint32_t acc_ctl[1];
	uint32_t _acc_ctl;
} BCMI_FALCON_XGXS_ACC_CTLr_t;

#define BCMI_FALCON_XGXS_ACC_CTLr_CLR(r) (r).acc_ctl[0] = 0
#define BCMI_FALCON_XGXS_ACC_CTLr_SET(r,d) (r).acc_ctl[0] = d
#define BCMI_FALCON_XGXS_ACC_CTLr_GET(r) (r).acc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_ACC_CTLr_MDIO_FUNCTIONf_GET(r) ((((r).acc_ctl[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_ACC_CTLr_MDIO_FUNCTIONf_SET(r,f) (r).acc_ctl[0]=(((r).acc_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_ACC_CTLr_MDIO_DEVADf_GET(r) (((r).acc_ctl[0]) & 0x1f)
#define BCMI_FALCON_XGXS_ACC_CTLr_MDIO_DEVADf_SET(r,f) (r).acc_ctl[0]=(((r).acc_ctl[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access ACC_CTL.
 */
#define BCMI_FALCON_XGXS_READ_ACC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_ACC_CTLr,(_r._acc_ctl))
#define BCMI_FALCON_XGXS_WRITE_ACC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_CTLr,(_r._acc_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_ACC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_CTLr,(_r._acc_ctl))
#define BCMI_FALCON_XGXS_READLN_ACC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_ctl))
#define BCMI_FALCON_XGXS_WRITELN_ACC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_ACC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._acc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ACC_CTLr BCMI_FALCON_XGXS_ACC_CTLr
#define ACC_CTLr_SIZE BCMI_FALCON_XGXS_ACC_CTLr_SIZE
typedef BCMI_FALCON_XGXS_ACC_CTLr_t ACC_CTLr_t;
#define ACC_CTLr_CLR BCMI_FALCON_XGXS_ACC_CTLr_CLR
#define ACC_CTLr_SET BCMI_FALCON_XGXS_ACC_CTLr_SET
#define ACC_CTLr_GET BCMI_FALCON_XGXS_ACC_CTLr_GET
#define ACC_CTLr_MDIO_FUNCTIONf_GET BCMI_FALCON_XGXS_ACC_CTLr_MDIO_FUNCTIONf_GET
#define ACC_CTLr_MDIO_FUNCTIONf_SET BCMI_FALCON_XGXS_ACC_CTLr_MDIO_FUNCTIONf_SET
#define ACC_CTLr_MDIO_DEVADf_GET BCMI_FALCON_XGXS_ACC_CTLr_MDIO_DEVADf_GET
#define ACC_CTLr_MDIO_DEVADf_SET BCMI_FALCON_XGXS_ACC_CTLr_MDIO_DEVADf_SET
#define READ_ACC_CTLr BCMI_FALCON_XGXS_READ_ACC_CTLr
#define WRITE_ACC_CTLr BCMI_FALCON_XGXS_WRITE_ACC_CTLr
#define MODIFY_ACC_CTLr BCMI_FALCON_XGXS_MODIFY_ACC_CTLr
#define READLN_ACC_CTLr BCMI_FALCON_XGXS_READLN_ACC_CTLr
#define WRITELN_ACC_CTLr BCMI_FALCON_XGXS_WRITELN_ACC_CTLr
#define WRITEALL_ACC_CTLr BCMI_FALCON_XGXS_WRITEALL_ACC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_ACC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  ACC_ADDR_DATA
 * BLOCKS:   MDIO_CL22_IEEE_COM
 * REGADDR:  0x000e
 * DEVAD:    1
 * DESC:     MMD_access_addr_data
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_ADDR_DATA   If function field in PMD access control register is set to 00then this is the address register. Otherwise it is the data register
 */
#define BCMI_FALCON_XGXS_ACC_ADDR_DATAr (0x0001000e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_ACC_ADDR_DATAr_SIZE 4

/*
 * This structure should be used to declare and program ACC_ADDR_DATA.
 */
typedef union BCMI_FALCON_XGXS_ACC_ADDR_DATAr_s {
	uint32_t v[1];
	uint32_t acc_addr_data[1];
	uint32_t _acc_addr_data;
} BCMI_FALCON_XGXS_ACC_ADDR_DATAr_t;

#define BCMI_FALCON_XGXS_ACC_ADDR_DATAr_CLR(r) (r).acc_addr_data[0] = 0
#define BCMI_FALCON_XGXS_ACC_ADDR_DATAr_SET(r,d) (r).acc_addr_data[0] = d
#define BCMI_FALCON_XGXS_ACC_ADDR_DATAr_GET(r) (r).acc_addr_data[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET(r) (((r).acc_addr_data[0]) & 0xffff)
#define BCMI_FALCON_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET(r,f) (r).acc_addr_data[0]=(((r).acc_addr_data[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access ACC_ADDR_DATA.
 */
#define BCMI_FALCON_XGXS_READ_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data))
#define BCMI_FALCON_XGXS_WRITE_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_ADDR_DATAr,(_r._acc_addr_data))
#define BCMI_FALCON_XGXS_READLN_ACC_ADDR_DATAr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_addr_data))
#define BCMI_FALCON_XGXS_WRITELN_ACC_ADDR_DATAr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._acc_addr_data))
#define BCMI_FALCON_XGXS_WRITEALL_ACC_ADDR_DATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_ACC_ADDR_DATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._acc_addr_data))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define ACC_ADDR_DATAr BCMI_FALCON_XGXS_ACC_ADDR_DATAr
#define ACC_ADDR_DATAr_SIZE BCMI_FALCON_XGXS_ACC_ADDR_DATAr_SIZE
typedef BCMI_FALCON_XGXS_ACC_ADDR_DATAr_t ACC_ADDR_DATAr_t;
#define ACC_ADDR_DATAr_CLR BCMI_FALCON_XGXS_ACC_ADDR_DATAr_CLR
#define ACC_ADDR_DATAr_SET BCMI_FALCON_XGXS_ACC_ADDR_DATAr_SET
#define ACC_ADDR_DATAr_GET BCMI_FALCON_XGXS_ACC_ADDR_DATAr_GET
#define ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET BCMI_FALCON_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_GET
#define ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET BCMI_FALCON_XGXS_ACC_ADDR_DATAr_MDIO_ADDR_DATAf_SET
#define READ_ACC_ADDR_DATAr BCMI_FALCON_XGXS_READ_ACC_ADDR_DATAr
#define WRITE_ACC_ADDR_DATAr BCMI_FALCON_XGXS_WRITE_ACC_ADDR_DATAr
#define MODIFY_ACC_ADDR_DATAr BCMI_FALCON_XGXS_MODIFY_ACC_ADDR_DATAr
#define READLN_ACC_ADDR_DATAr BCMI_FALCON_XGXS_READLN_ACC_ADDR_DATAr
#define WRITELN_ACC_ADDR_DATAr BCMI_FALCON_XGXS_WRITELN_ACC_ADDR_DATAr
#define WRITEALL_ACC_ADDR_DATAr BCMI_FALCON_XGXS_WRITEALL_ACC_ADDR_DATAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_ACC_ADDR_DATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_IT_BASE_R_PMD_CTL
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x0096
 * DEVAD:    1
 * DESC:     BASE-R PMD control register 150
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_IEEE_RESTART_TRAINING 1 = Restart 10GBASE-KR cl93n72 training0 = Normal operation(self clearing)
 *     CL93N72_IEEE_TRAINING_ENABLE 1 = Enable the 10GBASE-KR start-up protocol0 = Disable the 10GBASE-KR start-up protocol
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr (0x00010096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_PMD_CTL.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_pmd_ctl[1];
	uint32_t _cl93n72_it_base_r_pmd_ctl;
} BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_t;

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CLR(r) (r).cl93n72_it_base_r_pmd_ctl[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_SET(r,d) (r).cl93n72_it_base_r_pmd_ctl[0] = d
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_GET(r) (r).cl93n72_it_base_r_pmd_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_GET(r) ((((r).cl93n72_it_base_r_pmd_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_SET(r,f) (r).cl93n72_it_base_r_pmd_ctl[0]=(((r).cl93n72_it_base_r_pmd_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_GET(r) (((r).cl93n72_it_base_r_pmd_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_SET(r,f) (r).cl93n72_it_base_r_pmd_ctl[0]=(((r).cl93n72_it_base_r_pmd_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_PMD_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr,(_r._cl93n72_it_base_r_pmd_ctl))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr,(_r._cl93n72_it_base_r_pmd_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr,(_r._cl93n72_it_base_r_pmd_ctl))
#define BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_pmd_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_pmd_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_PMD_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_it_base_r_pmd_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_PMD_CTLr BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr
#define CL93N72_IT_BASE_R_PMD_CTLr_SIZE BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_t CL93N72_IT_BASE_R_PMD_CTLr_t;
#define CL93N72_IT_BASE_R_PMD_CTLr_CLR BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CLR
#define CL93N72_IT_BASE_R_PMD_CTLr_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_SET
#define CL93N72_IT_BASE_R_PMD_CTLr_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_GET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_GET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_TRAINING_ENABLEf_SET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_GET
#define CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr_CL93N72_IEEE_RESTART_TRAININGf_SET
#define READ_CL93N72_IT_BASE_R_PMD_CTLr BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_PMD_CTLr
#define WRITE_CL93N72_IT_BASE_R_PMD_CTLr BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_PMD_CTLr
#define MODIFY_CL93N72_IT_BASE_R_PMD_CTLr BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_PMD_CTLr
#define READLN_CL93N72_IT_BASE_R_PMD_CTLr BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_PMD_CTLr
#define WRITELN_CL93N72_IT_BASE_R_PMD_CTLr BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_PMD_CTLr
#define WRITEALL_CL93N72_IT_BASE_R_PMD_CTLr BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_PMD_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_IT_BASE_R_PMD_STS
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x0097
 * DEVAD:    1
 * DESC:     BASE-R PMD status register 151
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_RECEIVER_STATUS 1 = Receiver trained and ready to receive data0 = Receiver training
 *     CL93N72_IEEE_FRAME_LOCK 1 = Training frame delineation detected0 = Training frame delineation not detected
 *     CL93N72_IEEE_TRAINING_STATUS 1 = Start-up protocol in progress0 = Start-up protocol complete
 *     CL93N72_IEEE_TRAINING_FAILURE 1 = Training failure has been detected0 = Training failure has not been detected
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr (0x00010097 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_PMD_STS.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_pmd_sts[1];
	uint32_t _cl93n72_it_base_r_pmd_sts;
} BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_t;

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CLR(r) (r).cl93n72_it_base_r_pmd_sts[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_SET(r,d) (r).cl93n72_it_base_r_pmd_sts[0] = d
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_GET(r) (r).cl93n72_it_base_r_pmd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_GET(r) ((((r).cl93n72_it_base_r_pmd_sts[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_GET(r) ((((r).cl93n72_it_base_r_pmd_sts[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_GET(r) ((((r).cl93n72_it_base_r_pmd_sts[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_GET(r) (((r).cl93n72_it_base_r_pmd_sts[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_SET(r,f) (r).cl93n72_it_base_r_pmd_sts[0]=(((r).cl93n72_it_base_r_pmd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_PMD_STS.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr,(_r._cl93n72_it_base_r_pmd_sts))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr,(_r._cl93n72_it_base_r_pmd_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr,(_r._cl93n72_it_base_r_pmd_sts))
#define BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_pmd_sts))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_PMD_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_pmd_sts))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_PMD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_it_base_r_pmd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_PMD_STSr BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr
#define CL93N72_IT_BASE_R_PMD_STSr_SIZE BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_t CL93N72_IT_BASE_R_PMD_STSr_t;
#define CL93N72_IT_BASE_R_PMD_STSr_CLR BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CLR
#define CL93N72_IT_BASE_R_PMD_STSr_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_SET
#define CL93N72_IT_BASE_R_PMD_STSr_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_FAILUREf_SET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_TRAINING_STATUSf_SET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_FRAME_LOCKf_SET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_GET
#define CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr_CL93N72_IEEE_RECEIVER_STATUSf_SET
#define READ_CL93N72_IT_BASE_R_PMD_STSr BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_PMD_STSr
#define WRITE_CL93N72_IT_BASE_R_PMD_STSr BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_PMD_STSr
#define MODIFY_CL93N72_IT_BASE_R_PMD_STSr BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_PMD_STSr
#define READLN_CL93N72_IT_BASE_R_PMD_STSr BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_PMD_STSr
#define WRITELN_CL93N72_IT_BASE_R_PMD_STSr BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_PMD_STSr
#define WRITEALL_CL93N72_IT_BASE_R_PMD_STSr BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_PMD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_PMD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_IR_BASE_R_LP_COEFF_UPD
 * BLOCKS:   CL93N72_IEEE_RX
 * REGADDR:  0x0098
 * DEVAD:    1
 * DESC:     BASE-R LP coeff update register 152
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LP_COEFF_UPDATE This register reflects the first 16-bit Word of the training framemost recently recieived from the Link PartnerThis register is not writeable when cl93n72 training is disabled asindicated in the IEEE spec.15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr (0x00010098 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IR_BASE_R_LP_COEFF_UPD.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl93n72_ir_base_r_lp_coeff_upd[1];
	uint32_t _cl93n72_ir_base_r_lp_coeff_upd;
} BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_t;

#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CLR(r) (r).cl93n72_ir_base_r_lp_coeff_upd[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SET(r,d) (r).cl93n72_ir_base_r_lp_coeff_upd[0] = d
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_GET(r) (r).cl93n72_ir_base_r_lp_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_GET(r) (((r).cl93n72_ir_base_r_lp_coeff_upd[0]) & 0xffff)
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_SET(r,f) (r).cl93n72_ir_base_r_lp_coeff_upd[0]=(((r).cl93n72_ir_base_r_lp_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IR_BASE_R_LP_COEFF_UPD.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr,(_r._cl93n72_ir_base_r_lp_coeff_upd))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr,(_r._cl93n72_ir_base_r_lp_coeff_upd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr,(_r._cl93n72_ir_base_r_lp_coeff_upd))
#define BCMI_FALCON_XGXS_READLN_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ir_base_r_lp_coeff_upd))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ir_base_r_lp_coeff_upd))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_IR_BASE_R_LP_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ir_base_r_lp_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_SIZE BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_t CL93N72_IR_BASE_R_LP_COEFF_UPDr_t;
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_CLR BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CLR
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_SET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_SET
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_GET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_GET
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_GET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_GET
#define CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_SET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr_CL93N72_IEEE_LP_COEFF_UPDATEf_SET
#define READ_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_FALCON_XGXS_READ_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define WRITE_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_FALCON_XGXS_WRITE_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define MODIFY_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_FALCON_XGXS_MODIFY_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define READLN_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_FALCON_XGXS_READLN_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define WRITELN_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_FALCON_XGXS_WRITELN_CL93N72_IR_BASE_R_LP_COEFF_UPDr
#define WRITEALL_CL93N72_IR_BASE_R_LP_COEFF_UPDr BCMI_FALCON_XGXS_WRITEALL_CL93N72_IR_BASE_R_LP_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_IR_BASE_R_LP_STS_REP
 * BLOCKS:   CL93N72_IEEE_RX
 * REGADDR:  0x0099
 * DEVAD:    1
 * DESC:     BASE-R LP status report register 153
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LP_STATUS_REPORT This register reflects the second 16-bit Word of the training framemost recently recieived from the Link Partner15   Receiver Ready1 =  The LP receiver has determined that training iscomplete and is prepared to receive data0 =  The LP receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 */
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr (0x00010099 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IR_BASE_R_LP_STS_REP.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl93n72_ir_base_r_lp_sts_rep[1];
	uint32_t _cl93n72_ir_base_r_lp_sts_rep;
} BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_t;

#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_CLR(r) (r).cl93n72_ir_base_r_lp_sts_rep[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_SET(r,d) (r).cl93n72_ir_base_r_lp_sts_rep[0] = d
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_GET(r) (r).cl93n72_ir_base_r_lp_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_GET(r) (((r).cl93n72_ir_base_r_lp_sts_rep[0]) & 0xffff)
#define BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_SET(r,f) (r).cl93n72_ir_base_r_lp_sts_rep[0]=(((r).cl93n72_ir_base_r_lp_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IR_BASE_R_LP_STS_REP.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr,(_r._cl93n72_ir_base_r_lp_sts_rep))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr,(_r._cl93n72_ir_base_r_lp_sts_rep)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr,(_r._cl93n72_ir_base_r_lp_sts_rep))
#define BCMI_FALCON_XGXS_READLN_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ir_base_r_lp_sts_rep))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ir_base_r_lp_sts_rep))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_IR_BASE_R_LP_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ir_base_r_lp_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IR_BASE_R_LP_STS_REPr BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr
#define CL93N72_IR_BASE_R_LP_STS_REPr_SIZE BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_t CL93N72_IR_BASE_R_LP_STS_REPr_t;
#define CL93N72_IR_BASE_R_LP_STS_REPr_CLR BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_CLR
#define CL93N72_IR_BASE_R_LP_STS_REPr_SET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_SET
#define CL93N72_IR_BASE_R_LP_STS_REPr_GET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_GET
#define CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_GET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_GET
#define CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_SET BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr_CL93N72_IEEE_LP_STATUS_REPORTf_SET
#define READ_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_FALCON_XGXS_READ_CL93N72_IR_BASE_R_LP_STS_REPr
#define WRITE_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_FALCON_XGXS_WRITE_CL93N72_IR_BASE_R_LP_STS_REPr
#define MODIFY_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_FALCON_XGXS_MODIFY_CL93N72_IR_BASE_R_LP_STS_REPr
#define READLN_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_FALCON_XGXS_READLN_CL93N72_IR_BASE_R_LP_STS_REPr
#define WRITELN_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_FALCON_XGXS_WRITELN_CL93N72_IR_BASE_R_LP_STS_REPr
#define WRITEALL_CL93N72_IR_BASE_R_LP_STS_REPr BCMI_FALCON_XGXS_WRITEALL_CL93N72_IR_BASE_R_LP_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_IR_BASE_R_LP_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_IT_BASE_R_LD_COEFF_UPD
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x009a
 * DEVAD:    1
 * DESC:     BASE-R LD coeff update register 154
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LD_COEFF_UPDATE This register reflects the first 16-bit Word of the outgoing training framesent by the Local Device15:14 Reserved13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (-1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr (0x0001009a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_LD_COEFF_UPD.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_ld_coeff_upd[1];
	uint32_t _cl93n72_it_base_r_ld_coeff_upd;
} BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_t;

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CLR(r) (r).cl93n72_it_base_r_ld_coeff_upd[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SET(r,d) (r).cl93n72_it_base_r_ld_coeff_upd[0] = d
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_GET(r) (r).cl93n72_it_base_r_ld_coeff_upd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_GET(r) (((r).cl93n72_it_base_r_ld_coeff_upd[0]) & 0xffff)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_SET(r,f) (r).cl93n72_it_base_r_ld_coeff_upd[0]=(((r).cl93n72_it_base_r_ld_coeff_upd[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_LD_COEFF_UPD.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr,(_r._cl93n72_it_base_r_ld_coeff_upd))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr,(_r._cl93n72_it_base_r_ld_coeff_upd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr,(_r._cl93n72_it_base_r_ld_coeff_upd))
#define BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_ld_coeff_upd))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_ld_coeff_upd))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_LD_COEFF_UPDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_it_base_r_ld_coeff_upd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_SIZE BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_t CL93N72_IT_BASE_R_LD_COEFF_UPDr_t;
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_CLR BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CLR
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_SET
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_GET
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_GET
#define CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr_CL93N72_IEEE_LD_COEFF_UPDATEf_SET
#define READ_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define WRITE_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define MODIFY_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define READLN_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define WRITELN_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_LD_COEFF_UPDr
#define WRITEALL_CL93N72_IT_BASE_R_LD_COEFF_UPDr BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_LD_COEFF_UPDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_COEFF_UPDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_IT_BASE_R_LD_STS_REP
 * BLOCKS:   CL93N72_IEEE_TX
 * REGADDR:  0x009b
 * DEVAD:    1
 * DESC:     BASE-R LD status report register 155
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_IEEE_LD_STATUS_REPORT This register reflects the second 16-bit Word of the outgoing training framesent by the Local Device15   Receiver Ready1 =  The LD receiver has determined that training iscomplete and is prepared to receive data0 =  The LD receiver is requesting that training continue14:6 Reserved5:4  Coefficient (+1) status5 41 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated3:2  Coefficient (0) status3 21 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated1:0  Coefficient (-1) status1 01 1 = maximum1 0 = minimum0 1 = updated0 0 = not_updated
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr (0x0001009b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_IT_BASE_R_LD_STS_REP.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_s {
	uint32_t v[1];
	uint32_t cl93n72_it_base_r_ld_sts_rep[1];
	uint32_t _cl93n72_it_base_r_ld_sts_rep;
} BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_t;

#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_CLR(r) (r).cl93n72_it_base_r_ld_sts_rep[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_SET(r,d) (r).cl93n72_it_base_r_ld_sts_rep[0] = d
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_GET(r) (r).cl93n72_it_base_r_ld_sts_rep[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_GET(r) (((r).cl93n72_it_base_r_ld_sts_rep[0]) & 0xffff)
#define BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_SET(r,f) (r).cl93n72_it_base_r_ld_sts_rep[0]=(((r).cl93n72_it_base_r_ld_sts_rep[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_IT_BASE_R_LD_STS_REP.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr,(_r._cl93n72_it_base_r_ld_sts_rep))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr,(_r._cl93n72_it_base_r_ld_sts_rep)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr,(_r._cl93n72_it_base_r_ld_sts_rep))
#define BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_ld_sts_rep))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_it_base_r_ld_sts_rep))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_LD_STS_REPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_it_base_r_ld_sts_rep))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_IT_BASE_R_LD_STS_REPr BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr
#define CL93N72_IT_BASE_R_LD_STS_REPr_SIZE BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_t CL93N72_IT_BASE_R_LD_STS_REPr_t;
#define CL93N72_IT_BASE_R_LD_STS_REPr_CLR BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_CLR
#define CL93N72_IT_BASE_R_LD_STS_REPr_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_SET
#define CL93N72_IT_BASE_R_LD_STS_REPr_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_GET
#define CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_GET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_GET
#define CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_SET BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr_CL93N72_IEEE_LD_STATUS_REPORTf_SET
#define READ_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_FALCON_XGXS_READ_CL93N72_IT_BASE_R_LD_STS_REPr
#define WRITE_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_FALCON_XGXS_WRITE_CL93N72_IT_BASE_R_LD_STS_REPr
#define MODIFY_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_FALCON_XGXS_MODIFY_CL93N72_IT_BASE_R_LD_STS_REPr
#define READLN_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_FALCON_XGXS_READLN_CL93N72_IT_BASE_R_LD_STS_REPr
#define WRITELN_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_FALCON_XGXS_WRITELN_CL93N72_IT_BASE_R_LD_STS_REPr
#define WRITEALL_CL93N72_IT_BASE_R_LD_STS_REPr BCMI_FALCON_XGXS_WRITEALL_CL93N72_IT_BASE_R_LD_STS_REPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_IT_BASE_R_LD_STS_REPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PF_CTL_DC_OFFS
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd000
 * DEVAD:    1
 * DESC:     rx_pf_ctrl_dc_offset register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PF2_CTRL      CD cut (Low PF),
 *     RX_PF_CTRL       Main Peaking Filter
 */
#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr (0x0001d000 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PF_CTL_DC_OFFS.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pf_ctl_dc_offs[1];
	uint32_t _dsc_rx_pf_ctl_dc_offs;
} BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_CLR(r) (r).dsc_rx_pf_ctl_dc_offs[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_SET(r,d) (r).dsc_rx_pf_ctl_dc_offs[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_GET(r) (r).dsc_rx_pf_ctl_dc_offs[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs[0]) >> 11) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs[0]=(((r).dsc_rx_pf_ctl_dc_offs[0] & ~((uint32_t)0xf << 11)) | ((((uint32_t)f) & 0xf) << 11)) | (15 << (16 + 11))
#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_GET(r) ((((r).dsc_rx_pf_ctl_dc_offs[0]) >> 8) & 0x7)
#define BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_SET(r,f) (r).dsc_rx_pf_ctl_dc_offs[0]=(((r).dsc_rx_pf_ctl_dc_offs[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))

/*
 * These macros can be used to access DSC_RX_PF_CTL_DC_OFFS.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PF_CTL_DC_OFFSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr,(_r._dsc_rx_pf_ctl_dc_offs))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PF_CTL_DC_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr,(_r._dsc_rx_pf_ctl_dc_offs)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PF_CTL_DC_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr,(_r._dsc_rx_pf_ctl_dc_offs))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PF_CTL_DC_OFFSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pf_ctl_dc_offs))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PF_CTL_DC_OFFSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pf_ctl_dc_offs))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PF_CTL_DC_OFFSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pf_ctl_dc_offs))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PF_CTL_DC_OFFSr BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr
#define DSC_RX_PF_CTL_DC_OFFSr_SIZE BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_t DSC_RX_PF_CTL_DC_OFFSr_t;
#define DSC_RX_PF_CTL_DC_OFFSr_CLR BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_CLR
#define DSC_RX_PF_CTL_DC_OFFSr_SET BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_SET
#define DSC_RX_PF_CTL_DC_OFFSr_GET BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_GET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_GET BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_GET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_SET BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF_CTRLf_SET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_GET BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_GET
#define DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_SET BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr_RX_PF2_CTRLf_SET
#define READ_DSC_RX_PF_CTL_DC_OFFSr BCMI_FALCON_XGXS_READ_DSC_RX_PF_CTL_DC_OFFSr
#define WRITE_DSC_RX_PF_CTL_DC_OFFSr BCMI_FALCON_XGXS_WRITE_DSC_RX_PF_CTL_DC_OFFSr
#define MODIFY_DSC_RX_PF_CTL_DC_OFFSr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PF_CTL_DC_OFFSr
#define READLN_DSC_RX_PF_CTL_DC_OFFSr BCMI_FALCON_XGXS_READLN_DSC_RX_PF_CTL_DC_OFFSr
#define WRITELN_DSC_RX_PF_CTL_DC_OFFSr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PF_CTL_DC_OFFSr
#define WRITEALL_DSC_RX_PF_CTL_DC_OFFSr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PF_CTL_DC_OFFSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PF_CTL_DC_OFFSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd001
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_DP rxa slicer offset adjust for data_pos[5:0] Sign,4-bit gray, 1 bit binary
 *     RXA_SLICER_OFFSET_ADJ_DN rxa slicer offset adjust for data_neg[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr (0x0001d001 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxa_slcr_offs_adj_dn_dp;
} BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxa_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxa_slcr_offs_adj_dn_dp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxa_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxa_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxa_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxa_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxa_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxa_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxa_slcr_offs_adj_dn_dp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxa_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_slcr_offs_adj_dn_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_GET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_SET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_GET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_SET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr_RXA_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define READLN_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define WRITELN_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr
#define WRITEALL_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXA_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd002
 * DEVAD:    1
 * DESC:     rxa_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXA_SLICER_OFFSET_ADJ_ZP rxa slicer offset adjust for phs_neg[5:0] Sign,4-bit gray, 1 bit binary
 *     RXA_SLICER_OFFSET_ADJ_ZN rxa slicer offset adjust for phs_pos[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d002 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXA_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxa_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxa_slcr_offs_adj_zn_zp;
} BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxa_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxa_slcr_offs_adj_zn_zp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxa_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxa_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxa_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxa_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxa_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxa_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXA_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxa_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxa_slcr_offs_adj_zn_zp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxa_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxa_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxa_slcr_offs_adj_zn_zp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_GET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_SET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_GET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_SET BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr_RXA_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READ_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITE_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_MODIFY_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define READLN_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READLN_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITELN_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITELN_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITEALL_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXA_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXAB_SLCR_OFFS_ADJ_LMS
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd003
 * DEVAD:    1
 * DESC:     rxab_slicer_offset_adj_lms register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_LMS rxb slicer offset adjust for lms[5:0] Sign,4-bit gray, 1 bit binary
 *     RXA_SLICER_OFFSET_ADJ_LMS rxa slicer offset adjust for lms[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr (0x0001d003 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXAB_SLCR_OFFS_ADJ_LMS.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_s {
	uint32_t v[1];
	uint32_t dsc_rxab_slcr_offs_adj_lms[1];
	uint32_t _dsc_rxab_slcr_offs_adj_lms;
} BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_t;

#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_CLR(r) (r).dsc_rxab_slcr_offs_adj_lms[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SET(r,d) (r).dsc_rxab_slcr_offs_adj_lms[0] = d
#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_GET(r) (r).dsc_rxab_slcr_offs_adj_lms[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_GET(r) ((((r).dsc_rxab_slcr_offs_adj_lms[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxab_slcr_offs_adj_lms[0]=(((r).dsc_rxab_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_GET(r) (((r).dsc_rxab_slcr_offs_adj_lms[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxab_slcr_offs_adj_lms[0]=(((r).dsc_rxab_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXAB_SLCR_OFFS_ADJ_LMS.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr,(_r._dsc_rxab_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr,(_r._dsc_rxab_slcr_offs_adj_lms)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr,(_r._dsc_rxab_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_READLN_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxab_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxab_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXAB_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxab_slcr_offs_adj_lms))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SIZE BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_t DSC_RXAB_SLCR_OFFS_ADJ_LMSr_t;
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_CLR BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_CLR
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SET BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_SET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_GET BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_GET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_GET BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_SET BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXA_SLICER_OFFSET_ADJ_LMSf_SET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_GET BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_SET BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr_RXB_SLICER_OFFSET_ADJ_LMSf_SET
#define READ_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_READ_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define WRITE_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_WRITE_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define MODIFY_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_MODIFY_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define READLN_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_READLN_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define WRITELN_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_WRITELN_DSC_RXAB_SLCR_OFFS_ADJ_LMSr
#define WRITEALL_DSC_RXAB_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_WRITEALL_DSC_RXAB_SLCR_OFFS_ADJ_LMSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXAB_SLCR_OFFS_ADJ_LMSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd004
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_DP rxb slicer offset adjust for data_pos[5:0] Sign,4-bit gray, 1 bit binary
 *     RXB_SLICER_OFFSET_ADJ_DN rxb slicer offset adjust for data_neg[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr (0x0001d004 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxb_slcr_offs_adj_dn_dp;
} BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxb_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxb_slcr_offs_adj_dn_dp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxb_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxb_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxb_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxb_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxb_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxb_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxb_slcr_offs_adj_dn_dp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxb_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_slcr_offs_adj_dn_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_GET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_SET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_GET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_SET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr_RXB_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define READLN_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define WRITELN_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr
#define WRITEALL_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXB_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd005
 * DEVAD:    1
 * DESC:     rxb_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_SLICER_OFFSET_ADJ_ZP rxb slicer offset adjust for phs_pos[5:0] Sign,4-bit gray, 1 bit binary
 *     RXB_SLICER_OFFSET_ADJ_ZN rxb slicer offset adjust for phs_neg[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d005 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXB_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxb_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxb_slcr_offs_adj_zn_zp;
} BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxb_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxb_slcr_offs_adj_zn_zp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxb_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxb_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxb_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxb_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxb_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxb_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXB_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxb_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxb_slcr_offs_adj_zn_zp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxb_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxb_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxb_slcr_offs_adj_zn_zp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_GET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_SET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_GET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_SET BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr_RXB_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READ_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITE_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_MODIFY_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define READLN_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READLN_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITELN_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITELN_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITEALL_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXB_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd006
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_DP rxc slicer offset adjust for data_pos[5:0] Sign,4-bit gray, 1 bit binary
 *     RXC_SLICER_OFFSET_ADJ_DN rxc slicer offset adjust for data_neg[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr (0x0001d006 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxc_slcr_offs_adj_dn_dp;
} BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxc_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxc_slcr_offs_adj_dn_dp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxc_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxc_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxc_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxc_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxc_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxc_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxc_slcr_offs_adj_dn_dp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxc_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_slcr_offs_adj_dn_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_GET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_SET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_GET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_SET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr_RXC_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define READLN_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define WRITELN_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr
#define WRITEALL_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXC_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd007
 * DEVAD:    1
 * DESC:     rxc_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXC_SLICER_OFFSET_ADJ_ZP rxc slicer offset adjust for phs_pos[5:0] Sign,4-bit gray, 1 bit binary
 *     RXC_SLICER_OFFSET_ADJ_ZN rxc slicer offset adjust for phs_neg[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d007 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXC_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxc_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxc_slcr_offs_adj_zn_zp;
} BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxc_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxc_slcr_offs_adj_zn_zp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxc_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxc_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxc_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxc_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxc_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxc_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXC_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxc_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxc_slcr_offs_adj_zn_zp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxc_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxc_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxc_slcr_offs_adj_zn_zp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_GET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_SET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_GET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_SET BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr_RXC_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READ_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITE_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_MODIFY_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define READLN_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READLN_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITELN_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITELN_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITEALL_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXC_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXCD_SLCR_OFFS_ADJ_LMS
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd008
 * DEVAD:    1
 * DESC:     rxcd_slicer_offset_adj_lms register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_LMS rxd slicer offset adjust for lms[5:0] Sign,4-bit gray, 1 bit binary
 *     RXC_SLICER_OFFSET_ADJ_LMS rxc slicer offset adjust for lms[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr (0x0001d008 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXCD_SLCR_OFFS_ADJ_LMS.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_s {
	uint32_t v[1];
	uint32_t dsc_rxcd_slcr_offs_adj_lms[1];
	uint32_t _dsc_rxcd_slcr_offs_adj_lms;
} BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_t;

#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_CLR(r) (r).dsc_rxcd_slcr_offs_adj_lms[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SET(r,d) (r).dsc_rxcd_slcr_offs_adj_lms[0] = d
#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_GET(r) (r).dsc_rxcd_slcr_offs_adj_lms[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_GET(r) ((((r).dsc_rxcd_slcr_offs_adj_lms[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxcd_slcr_offs_adj_lms[0]=(((r).dsc_rxcd_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_GET(r) (((r).dsc_rxcd_slcr_offs_adj_lms[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_SET(r,f) (r).dsc_rxcd_slcr_offs_adj_lms[0]=(((r).dsc_rxcd_slcr_offs_adj_lms[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXCD_SLCR_OFFS_ADJ_LMS.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr,(_r._dsc_rxcd_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr,(_r._dsc_rxcd_slcr_offs_adj_lms)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr,(_r._dsc_rxcd_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_READLN_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxcd_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxcd_slcr_offs_adj_lms))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXCD_SLCR_OFFS_ADJ_LMSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxcd_slcr_offs_adj_lms))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SIZE BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_t DSC_RXCD_SLCR_OFFS_ADJ_LMSr_t;
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_CLR BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_CLR
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SET BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_SET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_GET BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_GET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_GET BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_SET BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXC_SLICER_OFFSET_ADJ_LMSf_SET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_GET BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_GET
#define DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_SET BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr_RXD_SLICER_OFFSET_ADJ_LMSf_SET
#define READ_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_READ_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define WRITE_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_WRITE_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define MODIFY_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_MODIFY_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define READLN_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_READLN_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define WRITELN_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_WRITELN_DSC_RXCD_SLCR_OFFS_ADJ_LMSr
#define WRITEALL_DSC_RXCD_SLCR_OFFS_ADJ_LMSr BCMI_FALCON_XGXS_WRITEALL_DSC_RXCD_SLCR_OFFS_ADJ_LMSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXCD_SLCR_OFFS_ADJ_LMSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ_DN_DP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd009
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_adj_dn_dp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_DP rxd slicer offset adjust for data_pos[5:0] Sign,4-bit gray, 1 bit binary
 *     RXD_SLICER_OFFSET_ADJ_DN rxd slicer offset adjust for data_neg[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr (0x0001d009 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ_DN_DP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj_dn_dp[1];
	uint32_t _dsc_rxd_slcr_offs_adj_dn_dp;
} BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_t;

#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_CLR(r) (r).dsc_rxd_slcr_offs_adj_dn_dp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SET(r,d) (r).dsc_rxd_slcr_offs_adj_dn_dp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_GET(r) (r).dsc_rxd_slcr_offs_adj_dn_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_GET(r) ((((r).dsc_rxd_slcr_offs_adj_dn_dp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxd_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_GET(r) (((r).dsc_rxd_slcr_offs_adj_dn_dp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_dn_dp[0]=(((r).dsc_rxd_slcr_offs_adj_dn_dp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ_DN_DP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxd_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxd_slcr_offs_adj_dn_dp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr,(_r._dsc_rxd_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj_dn_dp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_slcr_offs_adj_dn_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SIZE BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_t DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_t;
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_CLR BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_CLR
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_SET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_GET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_GET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_GET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_SET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DNf_SET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_GET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_SET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr_RXD_SLICER_OFFSET_ADJ_DPf_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define READLN_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define WRITELN_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr
#define WRITEALL_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_DN_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RXD_SLCR_OFFS_ADJ_ZN_ZP
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00a
 * DEVAD:    1
 * DESC:     rxd_slicer_offset_adj_zn_zp register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_SLICER_OFFSET_ADJ_ZP rxd slicer offset adjust for phs_pos[5:0] Sign,4-bit gray, 1 bit binary
 *     RXD_SLICER_OFFSET_ADJ_ZN rxd slicer offset adjust for phs_neg[5:0] Sign,4-bit gray, 1 bit binary
 */
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr (0x0001d00a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RXD_SLCR_OFFS_ADJ_ZN_ZP.
 */
typedef union BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_s {
	uint32_t v[1];
	uint32_t dsc_rxd_slcr_offs_adj_zn_zp[1];
	uint32_t _dsc_rxd_slcr_offs_adj_zn_zp;
} BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_t;

#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_CLR(r) (r).dsc_rxd_slcr_offs_adj_zn_zp[0] = 0
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SET(r,d) (r).dsc_rxd_slcr_offs_adj_zn_zp[0] = d
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_GET(r) (r).dsc_rxd_slcr_offs_adj_zn_zp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_GET(r) ((((r).dsc_rxd_slcr_offs_adj_zn_zp[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxd_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_GET(r) (((r).dsc_rxd_slcr_offs_adj_zn_zp[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_SET(r,f) (r).dsc_rxd_slcr_offs_adj_zn_zp[0]=(((r).dsc_rxd_slcr_offs_adj_zn_zp[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RXD_SLCR_OFFS_ADJ_ZN_ZP.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxd_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxd_slcr_offs_adj_zn_zp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr,(_r._dsc_rxd_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rxd_slcr_offs_adj_zn_zp))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rxd_slcr_offs_adj_zn_zp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SIZE BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_t DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_t;
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_CLR BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_CLR
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_SET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_GET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_GET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_GET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_SET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZNf_SET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_GET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_GET
#define DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_SET BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr_RXD_SLICER_OFFSET_ADJ_ZPf_SET
#define READ_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READ_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITE_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITE_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define MODIFY_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_MODIFY_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define READLN_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_READLN_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITELN_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITELN_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr
#define WRITEALL_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr BCMI_FALCON_XGXS_WRITEALL_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RXD_SLCR_OFFS_ADJ_ZN_ZPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PHASE_LMS_THR_SEL
 * BLOCKS:   DSC_AFE1
 * REGADDR:  0xd00b
 * DEVAD:    1
 * DESC:     rx_phase_lms_thresh_sel register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_LMS_THRESH_SEL S,Gray +/-127. 127=300mV
 *     RX_PHASE_THRESH_SEL S,Gray -63 to +63. 63=150mV
 */
#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr (0x0001d00b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PHASE_LMS_THR_SEL.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_s {
	uint32_t v[1];
	uint32_t dsc_rx_phase_lms_thr_sel[1];
	uint32_t _dsc_rx_phase_lms_thr_sel;
} BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_CLR(r) (r).dsc_rx_phase_lms_thr_sel[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_SET(r,d) (r).dsc_rx_phase_lms_thr_sel[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_GET(r) (r).dsc_rx_phase_lms_thr_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_GET(r) ((((r).dsc_rx_phase_lms_thr_sel[0]) >> 8) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_SET(r,f) (r).dsc_rx_phase_lms_thr_sel[0]=(((r).dsc_rx_phase_lms_thr_sel[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_GET(r) (((r).dsc_rx_phase_lms_thr_sel[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_SET(r,f) (r).dsc_rx_phase_lms_thr_sel[0]=(((r).dsc_rx_phase_lms_thr_sel[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PHASE_LMS_THR_SEL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PHASE_LMS_THR_SELr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr,(_r._dsc_rx_phase_lms_thr_sel))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PHASE_LMS_THR_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr,(_r._dsc_rx_phase_lms_thr_sel)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PHASE_LMS_THR_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr,(_r._dsc_rx_phase_lms_thr_sel))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PHASE_LMS_THR_SELr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_phase_lms_thr_sel))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PHASE_LMS_THR_SELr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_phase_lms_thr_sel))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PHASE_LMS_THR_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_phase_lms_thr_sel))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PHASE_LMS_THR_SELr BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr
#define DSC_RX_PHASE_LMS_THR_SELr_SIZE BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_t DSC_RX_PHASE_LMS_THR_SELr_t;
#define DSC_RX_PHASE_LMS_THR_SELr_CLR BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_CLR
#define DSC_RX_PHASE_LMS_THR_SELr_SET BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_SET
#define DSC_RX_PHASE_LMS_THR_SELr_GET BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_GET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_GET BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_GET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_SET BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_PHASE_THRESH_SELf_SET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_GET BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_GET
#define DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_SET BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr_RX_LMS_THRESH_SELf_SET
#define READ_DSC_RX_PHASE_LMS_THR_SELr BCMI_FALCON_XGXS_READ_DSC_RX_PHASE_LMS_THR_SELr
#define WRITE_DSC_RX_PHASE_LMS_THR_SELr BCMI_FALCON_XGXS_WRITE_DSC_RX_PHASE_LMS_THR_SELr
#define MODIFY_DSC_RX_PHASE_LMS_THR_SELr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PHASE_LMS_THR_SELr
#define READLN_DSC_RX_PHASE_LMS_THR_SELr BCMI_FALCON_XGXS_READLN_DSC_RX_PHASE_LMS_THR_SELr
#define WRITELN_DSC_RX_PHASE_LMS_THR_SELr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PHASE_LMS_THR_SELr
#define WRITEALL_DSC_RX_PHASE_LMS_THR_SELr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PHASE_LMS_THR_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PHASE_LMS_THR_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_AB
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd010
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_ab register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP2     S,Gray, B +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP2     S,Gray, B +/-15, 1LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr (0x0001d010 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_AB.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_ab[1];
	uint32_t _dsc_rx_dfe_tap2_ab;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_CLR(r) (r).dsc_rx_dfe_tap2_ab[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_SET(r,d) (r).dsc_rx_dfe_tap2_ab[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_GET(r) (r).dsc_rx_dfe_tap2_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_GET(r) ((((r).dsc_rx_dfe_tap2_ab[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_ab[0]=(((r).dsc_rx_dfe_tap2_ab[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_GET(r) (((r).dsc_rx_dfe_tap2_ab[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_ab[0]=(((r).dsc_rx_dfe_tap2_ab[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_AB.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP2_ABr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr,(_r._dsc_rx_dfe_tap2_ab))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP2_ABr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr,(_r._dsc_rx_dfe_tap2_ab)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP2_ABr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr,(_r._dsc_rx_dfe_tap2_ab))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP2_ABr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_ab))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP2_ABr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_ab))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP2_ABr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_ab))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_ABr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr
#define DSC_RX_DFE_TAP2_ABr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_t DSC_RX_DFE_TAP2_ABr_t;
#define DSC_RX_DFE_TAP2_ABr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_CLR
#define DSC_RX_DFE_TAP2_ABr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_SET
#define DSC_RX_DFE_TAP2_ABr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_GET
#define DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXA_DFE_TAP2f_SET
#define DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr_RXB_DFE_TAP2f_SET
#define READ_DSC_RX_DFE_TAP2_ABr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP2_ABr
#define WRITE_DSC_RX_DFE_TAP2_ABr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP2_ABr
#define MODIFY_DSC_RX_DFE_TAP2_ABr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP2_ABr
#define READLN_DSC_RX_DFE_TAP2_ABr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP2_ABr
#define WRITELN_DSC_RX_DFE_TAP2_ABr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP2_ABr
#define WRITEALL_DSC_RX_DFE_TAP2_ABr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP2_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP2_CD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd011
 * DEVAD:    1
 * DESC:     rx_dfe_tap2_cd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP2     S,Gray, B +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP2     S,Gray, B +/-15, 1LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr (0x0001d011 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP2_CD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap2_cd[1];
	uint32_t _dsc_rx_dfe_tap2_cd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_CLR(r) (r).dsc_rx_dfe_tap2_cd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_SET(r,d) (r).dsc_rx_dfe_tap2_cd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_GET(r) (r).dsc_rx_dfe_tap2_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_GET(r) ((((r).dsc_rx_dfe_tap2_cd[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_cd[0]=(((r).dsc_rx_dfe_tap2_cd[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_GET(r) (((r).dsc_rx_dfe_tap2_cd[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_SET(r,f) (r).dsc_rx_dfe_tap2_cd[0]=(((r).dsc_rx_dfe_tap2_cd[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP2_CD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP2_CDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr,(_r._dsc_rx_dfe_tap2_cd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP2_CDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr,(_r._dsc_rx_dfe_tap2_cd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP2_CDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr,(_r._dsc_rx_dfe_tap2_cd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP2_CDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_cd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP2_CDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap2_cd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP2_CDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap2_cd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP2_CDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr
#define DSC_RX_DFE_TAP2_CDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_t DSC_RX_DFE_TAP2_CDr_t;
#define DSC_RX_DFE_TAP2_CDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_CLR
#define DSC_RX_DFE_TAP2_CDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_SET
#define DSC_RX_DFE_TAP2_CDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_GET
#define DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXC_DFE_TAP2f_SET
#define DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_GET
#define DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr_RXD_DFE_TAP2f_SET
#define READ_DSC_RX_DFE_TAP2_CDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP2_CDr
#define WRITE_DSC_RX_DFE_TAP2_CDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP2_CDr
#define MODIFY_DSC_RX_DFE_TAP2_CDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP2_CDr
#define READLN_DSC_RX_DFE_TAP2_CDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP2_CDr
#define WRITELN_DSC_RX_DFE_TAP2_CDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP2_CDr
#define WRITEALL_DSC_RX_DFE_TAP2_CDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP2_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP2_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP3_AB
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd012
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_ab register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXB_DFE_TAP3     +/-15, 1LSB=150mV/64
 *     RXA_DFE_TAP3     +/-15, 1LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr (0x0001d012 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_AB.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_ab[1];
	uint32_t _dsc_rx_dfe_tap3_ab;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_CLR(r) (r).dsc_rx_dfe_tap3_ab[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_SET(r,d) (r).dsc_rx_dfe_tap3_ab[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_GET(r) (r).dsc_rx_dfe_tap3_ab[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_GET(r) ((((r).dsc_rx_dfe_tap3_ab[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_ab[0]=(((r).dsc_rx_dfe_tap3_ab[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_GET(r) (((r).dsc_rx_dfe_tap3_ab[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_ab[0]=(((r).dsc_rx_dfe_tap3_ab[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_AB.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP3_ABr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr,(_r._dsc_rx_dfe_tap3_ab))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP3_ABr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr,(_r._dsc_rx_dfe_tap3_ab)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP3_ABr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr,(_r._dsc_rx_dfe_tap3_ab))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP3_ABr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_ab))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP3_ABr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_ab))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP3_ABr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap3_ab))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_ABr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr
#define DSC_RX_DFE_TAP3_ABr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_t DSC_RX_DFE_TAP3_ABr_t;
#define DSC_RX_DFE_TAP3_ABr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_CLR
#define DSC_RX_DFE_TAP3_ABr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_SET
#define DSC_RX_DFE_TAP3_ABr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_GET
#define DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXA_DFE_TAP3f_SET
#define DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr_RXB_DFE_TAP3f_SET
#define READ_DSC_RX_DFE_TAP3_ABr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP3_ABr
#define WRITE_DSC_RX_DFE_TAP3_ABr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP3_ABr
#define MODIFY_DSC_RX_DFE_TAP3_ABr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP3_ABr
#define READLN_DSC_RX_DFE_TAP3_ABr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP3_ABr
#define WRITELN_DSC_RX_DFE_TAP3_ABr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP3_ABr
#define WRITEALL_DSC_RX_DFE_TAP3_ABr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP3_ABr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_ABr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP3_CD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd013
 * DEVAD:    1
 * DESC:     rx_dfe_tap3_cd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP3     +/-15, 1LSB=150mV/64
 *     RXC_DFE_TAP3     +/-15, 1LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr (0x0001d013 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP3_CD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap3_cd[1];
	uint32_t _dsc_rx_dfe_tap3_cd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_CLR(r) (r).dsc_rx_dfe_tap3_cd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_SET(r,d) (r).dsc_rx_dfe_tap3_cd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_GET(r) (r).dsc_rx_dfe_tap3_cd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_GET(r) ((((r).dsc_rx_dfe_tap3_cd[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_cd[0]=(((r).dsc_rx_dfe_tap3_cd[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_GET(r) (((r).dsc_rx_dfe_tap3_cd[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_SET(r,f) (r).dsc_rx_dfe_tap3_cd[0]=(((r).dsc_rx_dfe_tap3_cd[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP3_CD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP3_CDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr,(_r._dsc_rx_dfe_tap3_cd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP3_CDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr,(_r._dsc_rx_dfe_tap3_cd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP3_CDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr,(_r._dsc_rx_dfe_tap3_cd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP3_CDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_cd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP3_CDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap3_cd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP3_CDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap3_cd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP3_CDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr
#define DSC_RX_DFE_TAP3_CDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_t DSC_RX_DFE_TAP3_CDr_t;
#define DSC_RX_DFE_TAP3_CDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_CLR
#define DSC_RX_DFE_TAP3_CDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_SET
#define DSC_RX_DFE_TAP3_CDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_GET
#define DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXC_DFE_TAP3f_SET
#define DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_GET
#define DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr_RXD_DFE_TAP3f_SET
#define READ_DSC_RX_DFE_TAP3_CDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP3_CDr
#define WRITE_DSC_RX_DFE_TAP3_CDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP3_CDr
#define MODIFY_DSC_RX_DFE_TAP3_CDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP3_CDr
#define READLN_DSC_RX_DFE_TAP3_CDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP3_CDr
#define WRITELN_DSC_RX_DFE_TAP3_CDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP3_CDr
#define WRITEALL_DSC_RX_DFE_TAP3_CDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP3_CDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP3_CDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP4_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd014
 * DEVAD:    1
 * DESC:     rx_dfe_tap4_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP4     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP4     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP4     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP4     S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr (0x0001d014 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP4_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap4_abcd[1];
	uint32_t _dsc_rx_dfe_tap4_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_CLR(r) (r).dsc_rx_dfe_tap4_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap4_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_GET(r) (r).dsc_rx_dfe_tap4_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_GET(r) ((((r).dsc_rx_dfe_tap4_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_GET(r) (((r).dsc_rx_dfe_tap4_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_SET(r,f) (r).dsc_rx_dfe_tap4_abcd[0]=(((r).dsc_rx_dfe_tap4_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP4_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP4_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr,(_r._dsc_rx_dfe_tap4_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP4_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr,(_r._dsc_rx_dfe_tap4_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP4_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr,(_r._dsc_rx_dfe_tap4_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP4_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP4_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap4_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP4_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap4_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP4_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr
#define DSC_RX_DFE_TAP4_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_t DSC_RX_DFE_TAP4_ABCDr_t;
#define DSC_RX_DFE_TAP4_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_CLR
#define DSC_RX_DFE_TAP4_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_SET
#define DSC_RX_DFE_TAP4_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXA_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXB_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXC_DFE_TAP4f_SET
#define DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_GET
#define DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr_RXD_DFE_TAP4f_SET
#define READ_DSC_RX_DFE_TAP4_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP4_ABCDr
#define WRITE_DSC_RX_DFE_TAP4_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP4_ABCDr
#define MODIFY_DSC_RX_DFE_TAP4_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP4_ABCDr
#define READLN_DSC_RX_DFE_TAP4_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP4_ABCDr
#define WRITELN_DSC_RX_DFE_TAP4_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP4_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP4_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP4_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP4_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP5_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd015
 * DEVAD:    1
 * DESC:     rx_dfe_tap5_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP5     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP5     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP5     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP5     S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr (0x0001d015 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP5_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap5_abcd[1];
	uint32_t _dsc_rx_dfe_tap5_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_CLR(r) (r).dsc_rx_dfe_tap5_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap5_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_GET(r) (r).dsc_rx_dfe_tap5_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET(r) ((((r).dsc_rx_dfe_tap5_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET(r) (((r).dsc_rx_dfe_tap5_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET(r,f) (r).dsc_rx_dfe_tap5_abcd[0]=(((r).dsc_rx_dfe_tap5_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP5_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr,(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP5_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP5_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap5_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP5_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap5_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP5_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr
#define DSC_RX_DFE_TAP5_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_t DSC_RX_DFE_TAP5_ABCDr_t;
#define DSC_RX_DFE_TAP5_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_CLR
#define DSC_RX_DFE_TAP5_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_SET
#define DSC_RX_DFE_TAP5_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXA_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXB_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXC_DFE_TAP5f_SET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_GET
#define DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr_RXD_DFE_TAP5f_SET
#define READ_DSC_RX_DFE_TAP5_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP5_ABCDr
#define WRITE_DSC_RX_DFE_TAP5_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP5_ABCDr
#define MODIFY_DSC_RX_DFE_TAP5_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP5_ABCDr
#define READLN_DSC_RX_DFE_TAP5_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP5_ABCDr
#define WRITELN_DSC_RX_DFE_TAP5_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP5_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP5_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP5_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP5_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP6_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd016
 * DEVAD:    1
 * DESC:     rx_dfe_tap6_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP6     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP6     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP6     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP6     S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr (0x0001d016 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP6_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap6_abcd[1];
	uint32_t _dsc_rx_dfe_tap6_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_CLR(r) (r).dsc_rx_dfe_tap6_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap6_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_GET(r) (r).dsc_rx_dfe_tap6_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET(r) ((((r).dsc_rx_dfe_tap6_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET(r) (((r).dsc_rx_dfe_tap6_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET(r,f) (r).dsc_rx_dfe_tap6_abcd[0]=(((r).dsc_rx_dfe_tap6_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP6_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr,(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP6_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP6_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap6_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP6_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap6_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP6_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr
#define DSC_RX_DFE_TAP6_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_t DSC_RX_DFE_TAP6_ABCDr_t;
#define DSC_RX_DFE_TAP6_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_CLR
#define DSC_RX_DFE_TAP6_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_SET
#define DSC_RX_DFE_TAP6_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXA_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXB_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXC_DFE_TAP6f_SET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_GET
#define DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr_RXD_DFE_TAP6f_SET
#define READ_DSC_RX_DFE_TAP6_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP6_ABCDr
#define WRITE_DSC_RX_DFE_TAP6_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP6_ABCDr
#define MODIFY_DSC_RX_DFE_TAP6_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP6_ABCDr
#define READLN_DSC_RX_DFE_TAP6_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP6_ABCDr
#define WRITELN_DSC_RX_DFE_TAP6_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP6_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP6_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP6_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP6_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP7_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd017
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP7     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP7     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP7     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP7     S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr (0x0001d017 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET(r) ((((r).dsc_rx_dfe_tap7_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET(r) (((r).dsc_rx_dfe_tap7_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET(r,f) (r).dsc_rx_dfe_tap7_abcd[0]=(((r).dsc_rx_dfe_tap7_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr,(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP7_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP7_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP7_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap7_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr
#define DSC_RX_DFE_TAP7_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_t DSC_RX_DFE_TAP7_ABCDr_t;
#define DSC_RX_DFE_TAP7_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_CLR
#define DSC_RX_DFE_TAP7_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_SET
#define DSC_RX_DFE_TAP7_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXA_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXB_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXC_DFE_TAP7f_SET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_GET
#define DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr_RXD_DFE_TAP7f_SET
#define READ_DSC_RX_DFE_TAP7_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP7_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP7_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP7_ABCDr
#define READLN_DSC_RX_DFE_TAP7_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP7_ABCDr
#define WRITELN_DSC_RX_DFE_TAP7_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP7_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP7_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP7_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP8_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd018
 * DEVAD:    1
 * DESC:     rx_dfe_tap8_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP8     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP8     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP8     S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr (0x0001d018 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP8_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap8_abcd[1];
	uint32_t _dsc_rx_dfe_tap8_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_CLR(r) (r).dsc_rx_dfe_tap8_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap8_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_GET(r) (r).dsc_rx_dfe_tap8_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET(r) ((((r).dsc_rx_dfe_tap8_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET(r) (((r).dsc_rx_dfe_tap8_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET(r,f) (r).dsc_rx_dfe_tap8_abcd[0]=(((r).dsc_rx_dfe_tap8_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP8_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr,(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP8_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP8_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap8_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP8_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap8_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP8_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr
#define DSC_RX_DFE_TAP8_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_t DSC_RX_DFE_TAP8_ABCDr_t;
#define DSC_RX_DFE_TAP8_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_CLR
#define DSC_RX_DFE_TAP8_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_SET
#define DSC_RX_DFE_TAP8_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXA_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXB_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXC_DFE_TAP8f_SET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_GET
#define DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr_RXD_DFE_TAP8f_SET
#define READ_DSC_RX_DFE_TAP8_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP8_ABCDr
#define WRITE_DSC_RX_DFE_TAP8_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP8_ABCDr
#define MODIFY_DSC_RX_DFE_TAP8_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP8_ABCDr
#define READLN_DSC_RX_DFE_TAP8_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP8_ABCDr
#define WRITELN_DSC_RX_DFE_TAP8_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP8_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP8_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP8_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP8_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP9_ABCD
 * BLOCKS:   DSC_AFE2
 * REGADDR:  0xd019
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP9     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP9     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP9     S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP9     S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr (0x0001d019 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET(r) ((((r).dsc_rx_dfe_tap9_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET(r) (((r).dsc_rx_dfe_tap9_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET(r,f) (r).dsc_rx_dfe_tap9_abcd[0]=(((r).dsc_rx_dfe_tap9_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr,(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP9_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP9_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP9_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap9_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr
#define DSC_RX_DFE_TAP9_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_t DSC_RX_DFE_TAP9_ABCDr_t;
#define DSC_RX_DFE_TAP9_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_CLR
#define DSC_RX_DFE_TAP9_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_SET
#define DSC_RX_DFE_TAP9_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXA_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXB_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXC_DFE_TAP9f_SET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_GET
#define DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr_RXD_DFE_TAP9f_SET
#define READ_DSC_RX_DFE_TAP9_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP9_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP9_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP9_ABCDr
#define READLN_DSC_RX_DFE_TAP9_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP9_ABCDr
#define WRITELN_DSC_RX_DFE_TAP9_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP9_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP9_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP9_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP10_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd020
 * DEVAD:    1
 * DESC:     rx_dfe_tap10_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP10    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP10    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP10    S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr (0x0001d020 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP10_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap10_abcd[1];
	uint32_t _dsc_rx_dfe_tap10_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_CLR(r) (r).dsc_rx_dfe_tap10_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap10_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_GET(r) (r).dsc_rx_dfe_tap10_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET(r) ((((r).dsc_rx_dfe_tap10_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET(r) (((r).dsc_rx_dfe_tap10_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET(r,f) (r).dsc_rx_dfe_tap10_abcd[0]=(((r).dsc_rx_dfe_tap10_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP10_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr,(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP10_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP10_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap10_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP10_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap10_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP10_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr
#define DSC_RX_DFE_TAP10_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_t DSC_RX_DFE_TAP10_ABCDr_t;
#define DSC_RX_DFE_TAP10_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_CLR
#define DSC_RX_DFE_TAP10_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_SET
#define DSC_RX_DFE_TAP10_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXA_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXB_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXC_DFE_TAP10f_SET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_GET
#define DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr_RXD_DFE_TAP10f_SET
#define READ_DSC_RX_DFE_TAP10_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP10_ABCDr
#define WRITE_DSC_RX_DFE_TAP10_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP10_ABCDr
#define MODIFY_DSC_RX_DFE_TAP10_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP10_ABCDr
#define READLN_DSC_RX_DFE_TAP10_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP10_ABCDr
#define WRITELN_DSC_RX_DFE_TAP10_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP10_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP10_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP10_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP10_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP11_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd021
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP11    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP11    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP11    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP11    S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr (0x0001d021 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET(r) ((((r).dsc_rx_dfe_tap11_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET(r) (((r).dsc_rx_dfe_tap11_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET(r,f) (r).dsc_rx_dfe_tap11_abcd[0]=(((r).dsc_rx_dfe_tap11_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr,(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP11_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP11_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP11_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap11_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr
#define DSC_RX_DFE_TAP11_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_t DSC_RX_DFE_TAP11_ABCDr_t;
#define DSC_RX_DFE_TAP11_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_CLR
#define DSC_RX_DFE_TAP11_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_SET
#define DSC_RX_DFE_TAP11_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXA_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXB_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXC_DFE_TAP11f_SET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_GET
#define DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr_RXD_DFE_TAP11f_SET
#define READ_DSC_RX_DFE_TAP11_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP11_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP11_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP11_ABCDr
#define READLN_DSC_RX_DFE_TAP11_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP11_ABCDr
#define WRITELN_DSC_RX_DFE_TAP11_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP11_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP11_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP11_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP12_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd022
 * DEVAD:    1
 * DESC:     rx_dfe_tap12_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP12    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP12    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP12    S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr (0x0001d022 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP12_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap12_abcd[1];
	uint32_t _dsc_rx_dfe_tap12_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_CLR(r) (r).dsc_rx_dfe_tap12_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap12_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_GET(r) (r).dsc_rx_dfe_tap12_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET(r) ((((r).dsc_rx_dfe_tap12_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET(r) (((r).dsc_rx_dfe_tap12_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET(r,f) (r).dsc_rx_dfe_tap12_abcd[0]=(((r).dsc_rx_dfe_tap12_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP12_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr,(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP12_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP12_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap12_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP12_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap12_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP12_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr
#define DSC_RX_DFE_TAP12_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_t DSC_RX_DFE_TAP12_ABCDr_t;
#define DSC_RX_DFE_TAP12_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_CLR
#define DSC_RX_DFE_TAP12_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_SET
#define DSC_RX_DFE_TAP12_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXA_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXB_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXC_DFE_TAP12f_SET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_GET
#define DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr_RXD_DFE_TAP12f_SET
#define READ_DSC_RX_DFE_TAP12_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP12_ABCDr
#define WRITE_DSC_RX_DFE_TAP12_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP12_ABCDr
#define MODIFY_DSC_RX_DFE_TAP12_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP12_ABCDr
#define READLN_DSC_RX_DFE_TAP12_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP12_ABCDr
#define WRITELN_DSC_RX_DFE_TAP12_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP12_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP12_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP12_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP12_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP13_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd023
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP13    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP13    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP13    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP13    S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr (0x0001d023 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET(r) ((((r).dsc_rx_dfe_tap13_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET(r) (((r).dsc_rx_dfe_tap13_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET(r,f) (r).dsc_rx_dfe_tap13_abcd[0]=(((r).dsc_rx_dfe_tap13_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr,(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP13_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP13_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP13_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap13_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr
#define DSC_RX_DFE_TAP13_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_t DSC_RX_DFE_TAP13_ABCDr_t;
#define DSC_RX_DFE_TAP13_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_CLR
#define DSC_RX_DFE_TAP13_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_SET
#define DSC_RX_DFE_TAP13_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXA_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXB_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXC_DFE_TAP13f_SET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_GET
#define DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr_RXD_DFE_TAP13f_SET
#define READ_DSC_RX_DFE_TAP13_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP13_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP13_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP13_ABCDr
#define READLN_DSC_RX_DFE_TAP13_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP13_ABCDr
#define WRITELN_DSC_RX_DFE_TAP13_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP13_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP13_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP13_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP14_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd024
 * DEVAD:    1
 * DESC:     rx_dfe_tap14_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXC_DFE_TAP14    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXB_DFE_TAP14    S,Gray,B  +/-7, 1 LSB=150mV/64
 *     RXA_DFE_TAP14    S,Gray,B  +/-7, 1 LSB=150mV/64
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr (0x0001d024 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP14_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap14_abcd[1];
	uint32_t _dsc_rx_dfe_tap14_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_CLR(r) (r).dsc_rx_dfe_tap14_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap14_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_GET(r) (r).dsc_rx_dfe_tap14_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET(r) ((((r).dsc_rx_dfe_tap14_abcd[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET(r) (((r).dsc_rx_dfe_tap14_abcd[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET(r,f) (r).dsc_rx_dfe_tap14_abcd[0]=(((r).dsc_rx_dfe_tap14_abcd[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP14_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr,(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP14_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP14_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap14_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP14_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap14_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP14_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr
#define DSC_RX_DFE_TAP14_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_t DSC_RX_DFE_TAP14_ABCDr_t;
#define DSC_RX_DFE_TAP14_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_CLR
#define DSC_RX_DFE_TAP14_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_SET
#define DSC_RX_DFE_TAP14_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXA_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXB_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXC_DFE_TAP14f_SET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_GET
#define DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr_RXD_DFE_TAP14f_SET
#define READ_DSC_RX_DFE_TAP14_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP14_ABCDr
#define WRITE_DSC_RX_DFE_TAP14_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP14_ABCDr
#define MODIFY_DSC_RX_DFE_TAP14_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP14_ABCDr
#define READLN_DSC_RX_DFE_TAP14_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP14_ABCDr
#define WRITELN_DSC_RX_DFE_TAP14_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP14_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP14_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP14_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP14_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP7_8_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd025
 * DEVAD:    1
 * DESC:     rx_dfe_tap7_8_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP8_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP7_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr (0x0001d025 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap7_8_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap7_8_mux_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap7_8_mux_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET(r) ((((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET(r) (((r).dsc_rx_dfe_tap7_8_mux_abcd[0]) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET(r,f) (r).dsc_rx_dfe_tap7_8_mux_abcd[0]=(((r).dsc_rx_dfe_tap7_8_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP7_8_MUX_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr,(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap7_8_mux_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap7_8_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_t DSC_RX_DFE_TAP7_8_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXA_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXB_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXC_DFE_TAP8_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP7_MUXf_SET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_GET
#define DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr_RXD_DFE_TAP8_MUXf_SET
#define READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP7_8_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP7_8_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP7_8_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP9_10_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd026
 * DEVAD:    1
 * DESC:     rx_dfe_tap9_10_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP10_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP9_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr (0x0001d026 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap9_10_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap9_10_mux_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap9_10_mux_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET(r) ((((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET(r) (((r).dsc_rx_dfe_tap9_10_mux_abcd[0]) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET(r,f) (r).dsc_rx_dfe_tap9_10_mux_abcd[0]=(((r).dsc_rx_dfe_tap9_10_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP9_10_MUX_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr,(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap9_10_mux_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap9_10_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_t DSC_RX_DFE_TAP9_10_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXA_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXB_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXC_DFE_TAP10_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP9_MUXf_SET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_GET
#define DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr_RXD_DFE_TAP10_MUXf_SET
#define READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP9_10_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP9_10_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP9_10_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP11_12_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd027
 * DEVAD:    1
 * DESC:     rx_dfe_tap11_12_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP12_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP11_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr (0x0001d027 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap11_12_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap11_12_mux_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap11_12_mux_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET(r) ((((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET(r) (((r).dsc_rx_dfe_tap11_12_mux_abcd[0]) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET(r,f) (r).dsc_rx_dfe_tap11_12_mux_abcd[0]=(((r).dsc_rx_dfe_tap11_12_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP11_12_MUX_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr,(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap11_12_mux_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap11_12_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_t DSC_RX_DFE_TAP11_12_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXA_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXB_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXC_DFE_TAP12_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP11_MUXf_SET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_GET
#define DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr_RXD_DFE_TAP12_MUXf_SET
#define READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP11_12_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP11_12_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP11_12_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DFE_TAP13_14_MUX_ABCD
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd028
 * DEVAD:    1
 * DESC:     rx_dfe_tap13_14_mux_abcd register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RXD_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXD_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXC_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXB_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP14_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 *     RXA_DFE_TAP13_MUX tapN cancels ISI from location (N+value) where value is 0,1,2,3 Mux selects, 0 is early, 3 is later
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr (0x0001d028 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_dfe_tap13_14_mux_abcd[1];
	uint32_t _dsc_rx_dfe_tap13_14_mux_abcd;
} BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET(r,d) (r).dsc_rx_dfe_tap13_14_mux_abcd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET(r) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 12) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 10) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET(r) ((((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) >> 2) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3 << 2)) | ((((uint32_t)f) & 0x3) << 2)) | (3 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET(r) (((r).dsc_rx_dfe_tap13_14_mux_abcd[0]) & 0x3)
#define BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET(r,f) (r).dsc_rx_dfe_tap13_14_mux_abcd[0]=(((r).dsc_rx_dfe_tap13_14_mux_abcd[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_RX_DFE_TAP13_14_MUX_ABCD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr,(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_dfe_tap13_14_mux_abcd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_dfe_tap13_14_mux_abcd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_t DSC_RX_DFE_TAP13_14_MUX_ABCDr_t;
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_CLR
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXA_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXB_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXC_DFE_TAP14_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP13_MUXf_SET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_GET
#define DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr_RXD_DFE_TAP14_MUXf_SET
#define READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_FALCON_XGXS_READ_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_FALCON_XGXS_WRITE_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_FALCON_XGXS_READLN_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_DFE_TAP13_14_MUX_ABCDr
#define WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DFE_TAP13_14_MUX_ABCDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DFE_TAP13_14_MUX_ABCDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_LOAD_PRESETS
 * BLOCKS:   DSC_AFE3
 * REGADDR:  0xd029
 * DEVAD:    1
 * DESC:     load_presets.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRESET_DSC_AFE_BANK Load presets for analog interface Registers
 */
#define BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr (0x0001d029 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_LOAD_PRESETS.
 */
typedef union BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_s {
	uint32_t v[1];
	uint32_t dsc_load_presets[1];
	uint32_t _dsc_load_presets;
} BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_t;

#define BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_CLR(r) (r).dsc_load_presets[0] = 0
#define BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_SET(r,d) (r).dsc_load_presets[0] = d
#define BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_GET(r) (r).dsc_load_presets[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_PRESET_DSC_AFE_BANKf_GET(r) (((r).dsc_load_presets[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_PRESET_DSC_AFE_BANKf_SET(r,f) (r).dsc_load_presets[0]=(((r).dsc_load_presets[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_LOAD_PRESETS.
 */
#define BCMI_FALCON_XGXS_READ_DSC_LOAD_PRESETSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr,(_r._dsc_load_presets))
#define BCMI_FALCON_XGXS_WRITE_DSC_LOAD_PRESETSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr,(_r._dsc_load_presets)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_LOAD_PRESETSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr,(_r._dsc_load_presets))
#define BCMI_FALCON_XGXS_READLN_DSC_LOAD_PRESETSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_load_presets))
#define BCMI_FALCON_XGXS_WRITELN_DSC_LOAD_PRESETSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_load_presets))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_LOAD_PRESETSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_load_presets))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_LOAD_PRESETSr BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr
#define DSC_LOAD_PRESETSr_SIZE BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_SIZE
typedef BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_t DSC_LOAD_PRESETSr_t;
#define DSC_LOAD_PRESETSr_CLR BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_CLR
#define DSC_LOAD_PRESETSr_SET BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_SET
#define DSC_LOAD_PRESETSr_GET BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_GET
#define DSC_LOAD_PRESETSr_PRESET_DSC_AFE_BANKf_GET BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_PRESET_DSC_AFE_BANKf_GET
#define DSC_LOAD_PRESETSr_PRESET_DSC_AFE_BANKf_SET BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr_PRESET_DSC_AFE_BANKf_SET
#define READ_DSC_LOAD_PRESETSr BCMI_FALCON_XGXS_READ_DSC_LOAD_PRESETSr
#define WRITE_DSC_LOAD_PRESETSr BCMI_FALCON_XGXS_WRITE_DSC_LOAD_PRESETSr
#define MODIFY_DSC_LOAD_PRESETSr BCMI_FALCON_XGXS_MODIFY_DSC_LOAD_PRESETSr
#define READLN_DSC_LOAD_PRESETSr BCMI_FALCON_XGXS_READLN_DSC_LOAD_PRESETSr
#define WRITELN_DSC_LOAD_PRESETSr BCMI_FALCON_XGXS_WRITELN_DSC_LOAD_PRESETSr
#define WRITEALL_DSC_LOAD_PRESETSr BCMI_FALCON_XGXS_WRITEALL_DSC_LOAD_PRESETSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_LOAD_PRESETSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_UC_CTL
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03d
 * DEVAD:    1
 * DESC:     DSC uC Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_GP_UC_REQ gp_uc request
 *     UC_DSC_ERROR_FOUND Error Found.
 *     UC_DSC_READY_FOR_CMD Ready for command.
 *     UC_DSC_SUPP_INFO Supplemental information.
 */
#define BCMI_FALCON_XGXS_DSC_UC_CTLr (0x0001d03d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_UC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_UC_CTL.
 */
typedef union BCMI_FALCON_XGXS_DSC_UC_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_uc_ctl[1];
	uint32_t _dsc_uc_ctl;
} BCMI_FALCON_XGXS_DSC_UC_CTLr_t;

#define BCMI_FALCON_XGXS_DSC_UC_CTLr_CLR(r) (r).dsc_uc_ctl[0] = 0
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_SET(r,d) (r).dsc_uc_ctl[0] = d
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_GET(r) (r).dsc_uc_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET(r) ((((r).dsc_uc_ctl[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET(r) ((((r).dsc_uc_ctl[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET(r) (((r).dsc_uc_ctl[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET(r,f) (r).dsc_uc_ctl[0]=(((r).dsc_uc_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_UC_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_FALCON_XGXS_WRITE_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_UC_CTLr,(_r._dsc_uc_ctl))
#define BCMI_FALCON_XGXS_READLN_DSC_UC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DSC_UC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_uc_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_UC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_UC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_uc_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_UC_CTLr BCMI_FALCON_XGXS_DSC_UC_CTLr
#define DSC_UC_CTLr_SIZE BCMI_FALCON_XGXS_DSC_UC_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DSC_UC_CTLr_t DSC_UC_CTLr_t;
#define DSC_UC_CTLr_CLR BCMI_FALCON_XGXS_DSC_UC_CTLr_CLR
#define DSC_UC_CTLr_SET BCMI_FALCON_XGXS_DSC_UC_CTLr_SET
#define DSC_UC_CTLr_GET BCMI_FALCON_XGXS_DSC_UC_CTLr_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_GET
#define DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_SUPP_INFOf_SET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_GET
#define DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_READY_FOR_CMDf_SET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_GET
#define DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_ERROR_FOUNDf_SET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_GET
#define DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET BCMI_FALCON_XGXS_DSC_UC_CTLr_UC_DSC_GP_UC_REQf_SET
#define READ_DSC_UC_CTLr BCMI_FALCON_XGXS_READ_DSC_UC_CTLr
#define WRITE_DSC_UC_CTLr BCMI_FALCON_XGXS_WRITE_DSC_UC_CTLr
#define MODIFY_DSC_UC_CTLr BCMI_FALCON_XGXS_MODIFY_DSC_UC_CTLr
#define READLN_DSC_UC_CTLr BCMI_FALCON_XGXS_READLN_DSC_UC_CTLr
#define WRITELN_DSC_UC_CTLr BCMI_FALCON_XGXS_WRITELN_DSC_UC_CTLr
#define WRITEALL_DSC_UC_CTLr BCMI_FALCON_XGXS_WRITEALL_DSC_UC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_UC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SCRATCH
 * BLOCKS:   DSC_A
 * REGADDR:  0xd03e
 * DEVAD:    1
 * DESC:     DSC uC Scratch
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_DSC_SCRATCH   DSC scratch register.
 */
#define BCMI_FALCON_XGXS_DSC_SCRATCHr (0x0001d03e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SCRATCHr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SCRATCH.
 */
typedef union BCMI_FALCON_XGXS_DSC_SCRATCHr_s {
	uint32_t v[1];
	uint32_t dsc_scratch[1];
	uint32_t _dsc_scratch;
} BCMI_FALCON_XGXS_DSC_SCRATCHr_t;

#define BCMI_FALCON_XGXS_DSC_SCRATCHr_CLR(r) (r).dsc_scratch[0] = 0
#define BCMI_FALCON_XGXS_DSC_SCRATCHr_SET(r,d) (r).dsc_scratch[0] = d
#define BCMI_FALCON_XGXS_DSC_SCRATCHr_GET(r) (r).dsc_scratch[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET(r) (((r).dsc_scratch[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET(r,f) (r).dsc_scratch[0]=(((r).dsc_scratch[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_SCRATCH.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_FALCON_XGXS_WRITE_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SCRATCHr,(_r._dsc_scratch)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SCRATCHr,(_r._dsc_scratch))
#define BCMI_FALCON_XGXS_READLN_DSC_SCRATCHr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SCRATCHr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_scratch))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SCRATCHr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SCRATCHr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_scratch))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SCRATCHr BCMI_FALCON_XGXS_DSC_SCRATCHr
#define DSC_SCRATCHr_SIZE BCMI_FALCON_XGXS_DSC_SCRATCHr_SIZE
typedef BCMI_FALCON_XGXS_DSC_SCRATCHr_t DSC_SCRATCHr_t;
#define DSC_SCRATCHr_CLR BCMI_FALCON_XGXS_DSC_SCRATCHr_CLR
#define DSC_SCRATCHr_SET BCMI_FALCON_XGXS_DSC_SCRATCHr_SET
#define DSC_SCRATCHr_GET BCMI_FALCON_XGXS_DSC_SCRATCHr_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_GET BCMI_FALCON_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_GET
#define DSC_SCRATCHr_UC_DSC_SCRATCHf_SET BCMI_FALCON_XGXS_DSC_SCRATCHr_UC_DSC_SCRATCHf_SET
#define READ_DSC_SCRATCHr BCMI_FALCON_XGXS_READ_DSC_SCRATCHr
#define WRITE_DSC_SCRATCHr BCMI_FALCON_XGXS_WRITE_DSC_SCRATCHr
#define MODIFY_DSC_SCRATCHr BCMI_FALCON_XGXS_MODIFY_DSC_SCRATCHr
#define READLN_DSC_SCRATCHr BCMI_FALCON_XGXS_READLN_DSC_SCRATCHr
#define WRITELN_DSC_SCRATCHr BCMI_FALCON_XGXS_WRITELN_DSC_SCRATCHr
#define WRITEALL_DSC_SCRATCHr BCMI_FALCON_XGXS_WRITEALL_DSC_SCRATCHr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SCRATCHr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_A_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd040
 * DEVAD:    1
 * DESC:     trnsum a low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_A_LOW     Trnsum interleave 'a' LSB result (7:0)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr (0x0001d040 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_A_LO.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_a_lo[1];
	uint32_t _dsc_trnsum_a_lo;
} BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_CLR(r) (r).dsc_trnsum_a_lo[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_SET(r,d) (r).dsc_trnsum_a_lo[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_GET(r) (r).dsc_trnsum_a_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET(r) ((((r).dsc_trnsum_a_lo[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET(r,f) (r).dsc_trnsum_a_lo[0]=(((r).dsc_trnsum_a_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_A_LO.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr,(_r._dsc_trnsum_a_lo))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr,(_r._dsc_trnsum_a_lo)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr,(_r._dsc_trnsum_a_lo))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_A_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a_lo))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_A_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a_lo))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_A_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_a_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_A_LOr BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr
#define DSC_TRNSUM_A_LOr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_t DSC_TRNSUM_A_LOr_t;
#define DSC_TRNSUM_A_LOr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_CLR
#define DSC_TRNSUM_A_LOr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_SET
#define DSC_TRNSUM_A_LOr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_GET
#define DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_GET
#define DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr_TRNSUM_A_LOWf_SET
#define READ_DSC_TRNSUM_A_LOr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_A_LOr
#define WRITE_DSC_TRNSUM_A_LOr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_A_LOr
#define MODIFY_DSC_TRNSUM_A_LOr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_A_LOr
#define READLN_DSC_TRNSUM_A_LOr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_A_LOr
#define WRITELN_DSC_TRNSUM_A_LOr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_A_LOr
#define WRITEALL_DSC_TRNSUM_A_LOr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_A_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_A_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_A
 * BLOCKS:   DSC_B
 * REGADDR:  0xd041
 * DEVAD:    1
 * DESC:     trnsum a register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_A         Trnsum interleave 'a' result (23:8)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Ar (0x0001d041 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_A.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_a[1];
	uint32_t _dsc_trnsum_a;
} BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_CLR(r) (r).dsc_trnsum_a[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_SET(r,d) (r).dsc_trnsum_a[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_GET(r) (r).dsc_trnsum_a[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_GET(r) (((r).dsc_trnsum_a[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_SET(r,f) (r).dsc_trnsum_a[0]=(((r).dsc_trnsum_a[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_A.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Ar(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Ar,(_r._dsc_trnsum_a))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Ar(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Ar,(_r._dsc_trnsum_a)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Ar(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Ar,(_r._dsc_trnsum_a))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Ar(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Ar(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Ar|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_a))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Ar(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Ar|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_a))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Ar BCMI_FALCON_XGXS_DSC_TRNSUM_Ar
#define DSC_TRNSUM_Ar_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_t DSC_TRNSUM_Ar_t;
#define DSC_TRNSUM_Ar_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_CLR
#define DSC_TRNSUM_Ar_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_SET
#define DSC_TRNSUM_Ar_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_GET
#define DSC_TRNSUM_Ar_TRNSUM_Af_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_GET
#define DSC_TRNSUM_Ar_TRNSUM_Af_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Ar_TRNSUM_Af_SET
#define READ_DSC_TRNSUM_Ar BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Ar
#define WRITE_DSC_TRNSUM_Ar BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Ar
#define MODIFY_DSC_TRNSUM_Ar BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Ar
#define READLN_DSC_TRNSUM_Ar BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Ar
#define WRITELN_DSC_TRNSUM_Ar BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Ar
#define WRITEALL_DSC_TRNSUM_Ar BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Ar

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_Ar'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_B_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd042
 * DEVAD:    1
 * DESC:     trnsum b low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_B_LOW     Trnsum interleave 'b' LSB result (7:0)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr (0x0001d042 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_B_LO.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_b_lo[1];
	uint32_t _dsc_trnsum_b_lo;
} BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_CLR(r) (r).dsc_trnsum_b_lo[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_SET(r,d) (r).dsc_trnsum_b_lo[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_GET(r) (r).dsc_trnsum_b_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET(r) ((((r).dsc_trnsum_b_lo[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET(r,f) (r).dsc_trnsum_b_lo[0]=(((r).dsc_trnsum_b_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_B_LO.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr,(_r._dsc_trnsum_b_lo))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr,(_r._dsc_trnsum_b_lo)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr,(_r._dsc_trnsum_b_lo))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_B_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b_lo))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_B_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b_lo))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_B_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_b_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_B_LOr BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr
#define DSC_TRNSUM_B_LOr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_t DSC_TRNSUM_B_LOr_t;
#define DSC_TRNSUM_B_LOr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_CLR
#define DSC_TRNSUM_B_LOr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_SET
#define DSC_TRNSUM_B_LOr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_GET
#define DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_GET
#define DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr_TRNSUM_B_LOWf_SET
#define READ_DSC_TRNSUM_B_LOr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_B_LOr
#define WRITE_DSC_TRNSUM_B_LOr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_B_LOr
#define MODIFY_DSC_TRNSUM_B_LOr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_B_LOr
#define READLN_DSC_TRNSUM_B_LOr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_B_LOr
#define WRITELN_DSC_TRNSUM_B_LOr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_B_LOr
#define WRITEALL_DSC_TRNSUM_B_LOr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_B_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_B_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_B
 * BLOCKS:   DSC_B
 * REGADDR:  0xd043
 * DEVAD:    1
 * DESC:     trnsum b register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_B         Trnsum interleave 'b' result (23:8)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Br (0x0001d043 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Br_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_B.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_Br_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_b[1];
	uint32_t _dsc_trnsum_b;
} BCMI_FALCON_XGXS_DSC_TRNSUM_Br_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Br_CLR(r) (r).dsc_trnsum_b[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Br_SET(r,d) (r).dsc_trnsum_b[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Br_GET(r) (r).dsc_trnsum_b[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_GET(r) (((r).dsc_trnsum_b[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_SET(r,f) (r).dsc_trnsum_b[0]=(((r).dsc_trnsum_b[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_B.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Br(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Br,(_r._dsc_trnsum_b))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Br(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Br,(_r._dsc_trnsum_b)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Br(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Br,(_r._dsc_trnsum_b))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Br(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Br(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Br|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_b))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Br(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Br|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_b))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Br BCMI_FALCON_XGXS_DSC_TRNSUM_Br
#define DSC_TRNSUM_Br_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_Br_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_Br_t DSC_TRNSUM_Br_t;
#define DSC_TRNSUM_Br_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_Br_CLR
#define DSC_TRNSUM_Br_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Br_SET
#define DSC_TRNSUM_Br_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Br_GET
#define DSC_TRNSUM_Br_TRNSUM_Bf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_GET
#define DSC_TRNSUM_Br_TRNSUM_Bf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Br_TRNSUM_Bf_SET
#define READ_DSC_TRNSUM_Br BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Br
#define WRITE_DSC_TRNSUM_Br BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Br
#define MODIFY_DSC_TRNSUM_Br BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Br
#define READLN_DSC_TRNSUM_Br BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Br
#define WRITELN_DSC_TRNSUM_Br BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Br
#define WRITEALL_DSC_TRNSUM_Br BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Br

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_Br'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_C_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd044
 * DEVAD:    1
 * DESC:     trnsum c low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_C_LOW     Trnsum interleave 'c' LSB result (7:0)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr (0x0001d044 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_C_LO.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_c_lo[1];
	uint32_t _dsc_trnsum_c_lo;
} BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_CLR(r) (r).dsc_trnsum_c_lo[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_SET(r,d) (r).dsc_trnsum_c_lo[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_GET(r) (r).dsc_trnsum_c_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET(r) ((((r).dsc_trnsum_c_lo[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET(r,f) (r).dsc_trnsum_c_lo[0]=(((r).dsc_trnsum_c_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_C_LO.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr,(_r._dsc_trnsum_c_lo))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr,(_r._dsc_trnsum_c_lo)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr,(_r._dsc_trnsum_c_lo))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_C_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c_lo))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_C_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c_lo))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_C_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_c_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_C_LOr BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr
#define DSC_TRNSUM_C_LOr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_t DSC_TRNSUM_C_LOr_t;
#define DSC_TRNSUM_C_LOr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_CLR
#define DSC_TRNSUM_C_LOr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_SET
#define DSC_TRNSUM_C_LOr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_GET
#define DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_GET
#define DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr_TRNSUM_C_LOWf_SET
#define READ_DSC_TRNSUM_C_LOr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_C_LOr
#define WRITE_DSC_TRNSUM_C_LOr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_C_LOr
#define MODIFY_DSC_TRNSUM_C_LOr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_C_LOr
#define READLN_DSC_TRNSUM_C_LOr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_C_LOr
#define WRITELN_DSC_TRNSUM_C_LOr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_C_LOr
#define WRITEALL_DSC_TRNSUM_C_LOr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_C_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_C_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_C
 * BLOCKS:   DSC_B
 * REGADDR:  0xd045
 * DEVAD:    1
 * DESC:     trnsum c register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_C         Trnsum interleave 'c' result (23:8)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Cr (0x0001d045 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_C.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_c[1];
	uint32_t _dsc_trnsum_c;
} BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_CLR(r) (r).dsc_trnsum_c[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_SET(r,d) (r).dsc_trnsum_c[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_GET(r) (r).dsc_trnsum_c[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_GET(r) (((r).dsc_trnsum_c[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_SET(r,f) (r).dsc_trnsum_c[0]=(((r).dsc_trnsum_c[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_C.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Cr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Cr,(_r._dsc_trnsum_c))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Cr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Cr,(_r._dsc_trnsum_c)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Cr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Cr,(_r._dsc_trnsum_c))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Cr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Cr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Cr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Cr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_c))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Cr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Cr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_c))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Cr BCMI_FALCON_XGXS_DSC_TRNSUM_Cr
#define DSC_TRNSUM_Cr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_t DSC_TRNSUM_Cr_t;
#define DSC_TRNSUM_Cr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_CLR
#define DSC_TRNSUM_Cr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_SET
#define DSC_TRNSUM_Cr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_GET
#define DSC_TRNSUM_Cr_TRNSUM_Cf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_GET
#define DSC_TRNSUM_Cr_TRNSUM_Cf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Cr_TRNSUM_Cf_SET
#define READ_DSC_TRNSUM_Cr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Cr
#define WRITE_DSC_TRNSUM_Cr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Cr
#define MODIFY_DSC_TRNSUM_Cr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Cr
#define READLN_DSC_TRNSUM_Cr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Cr
#define WRITELN_DSC_TRNSUM_Cr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Cr
#define WRITEALL_DSC_TRNSUM_Cr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Cr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_Cr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_D_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd046
 * DEVAD:    1
 * DESC:     trnsum d low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_D_LOW     Trnsum interleave 'd' LSB result (7:0)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr (0x0001d046 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_D_LO.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_d_lo[1];
	uint32_t _dsc_trnsum_d_lo;
} BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_CLR(r) (r).dsc_trnsum_d_lo[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_SET(r,d) (r).dsc_trnsum_d_lo[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_GET(r) (r).dsc_trnsum_d_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET(r) ((((r).dsc_trnsum_d_lo[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET(r,f) (r).dsc_trnsum_d_lo[0]=(((r).dsc_trnsum_d_lo[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))

/*
 * These macros can be used to access DSC_TRNSUM_D_LO.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr,(_r._dsc_trnsum_d_lo))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr,(_r._dsc_trnsum_d_lo)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr,(_r._dsc_trnsum_d_lo))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_D_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d_lo))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_D_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d_lo))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_D_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_d_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_D_LOr BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr
#define DSC_TRNSUM_D_LOr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_t DSC_TRNSUM_D_LOr_t;
#define DSC_TRNSUM_D_LOr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_CLR
#define DSC_TRNSUM_D_LOr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_SET
#define DSC_TRNSUM_D_LOr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_GET
#define DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_GET
#define DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr_TRNSUM_D_LOWf_SET
#define READ_DSC_TRNSUM_D_LOr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_D_LOr
#define WRITE_DSC_TRNSUM_D_LOr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_D_LOr
#define MODIFY_DSC_TRNSUM_D_LOr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_D_LOr
#define READLN_DSC_TRNSUM_D_LOr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_D_LOr
#define WRITELN_DSC_TRNSUM_D_LOr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_D_LOr
#define WRITEALL_DSC_TRNSUM_D_LOr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_D_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_D_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_D
 * BLOCKS:   DSC_B
 * REGADDR:  0xd047
 * DEVAD:    1
 * DESC:     trnsum d register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_D         Trnsum interleave 'd' result (15:8)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Dr (0x0001d047 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_D.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_d[1];
	uint32_t _dsc_trnsum_d;
} BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_CLR(r) (r).dsc_trnsum_d[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_SET(r,d) (r).dsc_trnsum_d[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_GET(r) (r).dsc_trnsum_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_GET(r) (((r).dsc_trnsum_d[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_SET(r,f) (r).dsc_trnsum_d[0]=(((r).dsc_trnsum_d[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_D.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Dr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Dr,(_r._dsc_trnsum_d))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Dr,(_r._dsc_trnsum_d)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Dr,(_r._dsc_trnsum_d))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Dr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Dr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_d))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_Dr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_d))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_Dr BCMI_FALCON_XGXS_DSC_TRNSUM_Dr
#define DSC_TRNSUM_Dr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_t DSC_TRNSUM_Dr_t;
#define DSC_TRNSUM_Dr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_CLR
#define DSC_TRNSUM_Dr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_SET
#define DSC_TRNSUM_Dr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_GET
#define DSC_TRNSUM_Dr_TRNSUM_Df_GET BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_GET
#define DSC_TRNSUM_Dr_TRNSUM_Df_SET BCMI_FALCON_XGXS_DSC_TRNSUM_Dr_TRNSUM_Df_SET
#define READ_DSC_TRNSUM_Dr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_Dr
#define WRITE_DSC_TRNSUM_Dr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_Dr
#define MODIFY_DSC_TRNSUM_Dr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_Dr
#define READLN_DSC_TRNSUM_Dr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_Dr
#define WRITELN_DSC_TRNSUM_Dr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_Dr
#define WRITEALL_DSC_TRNSUM_Dr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_LO
 * BLOCKS:   DSC_B
 * REGADDR:  0xd048
 * DEVAD:    1
 * DESC:     trnsum low register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM_LOW       Trnsum  LSB result (9:0)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_LOr (0x0001d048 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_LO.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_lo[1];
	uint32_t _dsc_trnsum_lo;
} BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_CLR(r) (r).dsc_trnsum_lo[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_SET(r,d) (r).dsc_trnsum_lo[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_GET(r) (r).dsc_trnsum_lo[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_GET(r) ((((r).dsc_trnsum_lo[0]) >> 6) & 0x3ff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_SET(r,f) (r).dsc_trnsum_lo[0]=(((r).dsc_trnsum_lo[0] & ~((uint32_t)0x3ff << 6)) | ((((uint32_t)f) & 0x3ff) << 6)) | (1023 << (16 + 6))

/*
 * These macros can be used to access DSC_TRNSUM_LO.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_LOr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_LOr,(_r._dsc_trnsum_lo))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_LOr,(_r._dsc_trnsum_lo)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_LOr,(_r._dsc_trnsum_lo))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_LOr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_lo))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_LOr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_LOr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_lo))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_LOr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_LOr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_lo))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_LOr BCMI_FALCON_XGXS_DSC_TRNSUM_LOr
#define DSC_TRNSUM_LOr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_t DSC_TRNSUM_LOr_t;
#define DSC_TRNSUM_LOr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_CLR
#define DSC_TRNSUM_LOr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_SET
#define DSC_TRNSUM_LOr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_GET
#define DSC_TRNSUM_LOr_TRNSUM_LOWf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_GET
#define DSC_TRNSUM_LOr_TRNSUM_LOWf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_LOr_TRNSUM_LOWf_SET
#define READ_DSC_TRNSUM_LOr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_LOr
#define WRITE_DSC_TRNSUM_LOr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_LOr
#define MODIFY_DSC_TRNSUM_LOr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_LOr
#define READLN_DSC_TRNSUM_LOr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_LOr
#define WRITELN_DSC_TRNSUM_LOr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_LOr
#define WRITEALL_DSC_TRNSUM_LOr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_LOr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_LOr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM
 * BLOCKS:   DSC_B
 * REGADDR:  0xd049
 * DEVAD:    1
 * DESC:     trnsum register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TRNSUM           Trnsum result (25:10)
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUMr (0x0001d049 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUMr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUMr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum[1];
	uint32_t _dsc_trnsum;
} BCMI_FALCON_XGXS_DSC_TRNSUMr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUMr_CLR(r) (r).dsc_trnsum[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUMr_SET(r,d) (r).dsc_trnsum[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUMr_GET(r) (r).dsc_trnsum[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUMr_TRNSUMf_GET(r) (((r).dsc_trnsum[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_TRNSUMr_TRNSUMf_SET(r,f) (r).dsc_trnsum[0]=(((r).dsc_trnsum[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_TRNSUM.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUMr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUMr,(_r._dsc_trnsum))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUMr,(_r._dsc_trnsum)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUMr,(_r._dsc_trnsum))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUMr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUMr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUMr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUMr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUMr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUMr BCMI_FALCON_XGXS_DSC_TRNSUMr
#define DSC_TRNSUMr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUMr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUMr_t DSC_TRNSUMr_t;
#define DSC_TRNSUMr_CLR BCMI_FALCON_XGXS_DSC_TRNSUMr_CLR
#define DSC_TRNSUMr_SET BCMI_FALCON_XGXS_DSC_TRNSUMr_SET
#define DSC_TRNSUMr_GET BCMI_FALCON_XGXS_DSC_TRNSUMr_GET
#define DSC_TRNSUMr_TRNSUMf_GET BCMI_FALCON_XGXS_DSC_TRNSUMr_TRNSUMf_GET
#define DSC_TRNSUMr_TRNSUMf_SET BCMI_FALCON_XGXS_DSC_TRNSUMr_TRNSUMf_SET
#define READ_DSC_TRNSUMr BCMI_FALCON_XGXS_READ_DSC_TRNSUMr
#define WRITE_DSC_TRNSUMr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUMr
#define MODIFY_DSC_TRNSUMr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUMr
#define READLN_DSC_TRNSUMr BCMI_FALCON_XGXS_READLN_DSC_TRNSUMr
#define WRITELN_DSC_TRNSUMr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUMr
#define WRITEALL_DSC_TRNSUMr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUMr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUMr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_DC_OFFS_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04c
 * DEVAD:    1
 * DESC:     dc offset status register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DC_OFFSET_BIN    rx dc offset bin
 */
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr (0x0001d04c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS_STS.
 */
typedef union BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs_sts[1];
	uint32_t _dsc_dc_offs_sts;
} BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_t;

#define BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_CLR(r) (r).dsc_dc_offs_sts[0] = 0
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_SET(r,d) (r).dsc_dc_offs_sts[0] = d
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_GET(r) (r).dsc_dc_offs_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET(r) (((r).dsc_dc_offs_sts[0]) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET(r,f) (r).dsc_dc_offs_sts[0]=(((r).dsc_dc_offs_sts[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_DC_OFFS_STS.
 */
#define BCMI_FALCON_XGXS_READ_DSC_DC_OFFS_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts))
#define BCMI_FALCON_XGXS_WRITE_DSC_DC_OFFS_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_DC_OFFS_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr,(_r._dsc_dc_offs_sts))
#define BCMI_FALCON_XGXS_READLN_DSC_DC_OFFS_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_sts))
#define BCMI_FALCON_XGXS_WRITELN_DSC_DC_OFFS_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_sts))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_DC_OFFS_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dc_offs_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFS_STSr BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr
#define DSC_DC_OFFS_STSr_SIZE BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_SIZE
typedef BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_t DSC_DC_OFFS_STSr_t;
#define DSC_DC_OFFS_STSr_CLR BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_CLR
#define DSC_DC_OFFS_STSr_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_SET
#define DSC_DC_OFFS_STSr_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_GET
#define DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr_DC_OFFSET_BINf_SET
#define READ_DSC_DC_OFFS_STSr BCMI_FALCON_XGXS_READ_DSC_DC_OFFS_STSr
#define WRITE_DSC_DC_OFFS_STSr BCMI_FALCON_XGXS_WRITE_DSC_DC_OFFS_STSr
#define MODIFY_DSC_DC_OFFS_STSr BCMI_FALCON_XGXS_MODIFY_DSC_DC_OFFS_STSr
#define READLN_DSC_DC_OFFS_STSr BCMI_FALCON_XGXS_READLN_DSC_DC_OFFS_STSr
#define WRITELN_DSC_DC_OFFS_STSr BCMI_FALCON_XGXS_WRITELN_DSC_DC_OFFS_STSr
#define WRITEALL_DSC_DC_OFFS_STSr BCMI_FALCON_XGXS_WRITEALL_DSC_DC_OFFS_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_DC_OFFS_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_VGA_D_THR_STS
 * BLOCKS:   DSC_B
 * REGADDR:  0xd04d
 * DEVAD:    1
 * DESC:     vga gain and data threshold status register.
 * RESETVAL: 0x2700 (9984)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_THRESH_SEL Binary read out of the Data Slicer threshold
 *     RX_VGA_CTRL      Binary read out of the VGA control.
 */
#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr (0x0001d04d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_D_THR_STS.
 */
typedef union BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_s {
	uint32_t v[1];
	uint32_t dsc_vga_d_thr_sts[1];
	uint32_t _dsc_vga_d_thr_sts;
} BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_t;

#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_CLR(r) (r).dsc_vga_d_thr_sts[0] = 0
#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_SET(r,d) (r).dsc_vga_d_thr_sts[0] = d
#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_GET(r) (r).dsc_vga_d_thr_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_GET(r) ((((r).dsc_vga_d_thr_sts[0]) >> 8) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_GET(r) (((r).dsc_vga_d_thr_sts[0]) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_SET(r,f) (r).dsc_vga_d_thr_sts[0]=(((r).dsc_vga_d_thr_sts[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_VGA_D_THR_STS.
 */
#define BCMI_FALCON_XGXS_READ_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts))
#define BCMI_FALCON_XGXS_WRITE_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr,(_r._dsc_vga_d_thr_sts))
#define BCMI_FALCON_XGXS_READLN_DSC_VGA_D_THR_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_d_thr_sts))
#define BCMI_FALCON_XGXS_WRITELN_DSC_VGA_D_THR_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_d_thr_sts))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_VGA_D_THR_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_d_thr_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_D_THR_STSr BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr
#define DSC_VGA_D_THR_STSr_SIZE BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_SIZE
typedef BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_t DSC_VGA_D_THR_STSr_t;
#define DSC_VGA_D_THR_STSr_CLR BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_CLR
#define DSC_VGA_D_THR_STSr_SET BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_SET
#define DSC_VGA_D_THR_STSr_GET BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_GET BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_GET
#define DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_SET BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_VGA_CTRLf_SET
#define DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_GET BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_GET
#define DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_SET BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr_RX_DATA_THRESH_SELf_SET
#define READ_DSC_VGA_D_THR_STSr BCMI_FALCON_XGXS_READ_DSC_VGA_D_THR_STSr
#define WRITE_DSC_VGA_D_THR_STSr BCMI_FALCON_XGXS_WRITE_DSC_VGA_D_THR_STSr
#define MODIFY_DSC_VGA_D_THR_STSr BCMI_FALCON_XGXS_MODIFY_DSC_VGA_D_THR_STSr
#define READLN_DSC_VGA_D_THR_STSr BCMI_FALCON_XGXS_READLN_DSC_VGA_D_THR_STSr
#define WRITELN_DSC_VGA_D_THR_STSr BCMI_FALCON_XGXS_WRITELN_DSC_VGA_D_THR_STSr
#define WRITEALL_DSC_VGA_D_THR_STSr BCMI_FALCON_XGXS_WRITEALL_DSC_VGA_D_THR_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_VGA_D_THR_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_CDR_CTL0
 * BLOCKS:   DSC_C
 * REGADDR:  0xd050
 * DEVAD:    1
 * DESC:     cdr control register 0.
 * RESETVAL: 0x9 (9)
 * ACCESS:   R/W
 * FIELDS:
 *     OS_ALL_EDGES     0: 001/110 (and os_pattern_enhanced ==0 and br_pd_en ==0) , 1: x01/x10 patterns
 *     BR_PD_EN         0: (refer to os_all_edges) 1: use 011/100 patterns
 *     OS_PATTERN_ENHANCED when 1, selects 001/110 and also 010/101 from 4 locations {n,n+1, n+9, n+10}
 *     CDR_FREQ_EN      1: 2nd order loop output to contribute
 *     CDR_INTEG_REG_CLR clear integ Register
 *     CDR_PHASE_ERR_FRZ 1: override phase error to be 0
 *     CDR_INTEG_SAT_SEL 0:(-24576, 24575), 1:(-16384, 16383)
 *     CDR_FREQ_OVERRIDE_EN 1:override integ Register with cdr_freq_override_val
 *     CDR_ZERO_POLARITY inverts the phase slicer information before the phase detector
 */
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r (0x0001d050 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL0.
 */
typedef union BCMI_FALCON_XGXS_DSC_CDR_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl0[1];
	uint32_t _dsc_cdr_ctl0;
} BCMI_FALCON_XGXS_DSC_CDR_CTL0r_t;

#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CLR(r) (r).dsc_cdr_ctl0[0] = 0
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_SET(r,d) (r).dsc_cdr_ctl0[0] = d
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_GET(r) (r).dsc_cdr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET(r) ((((r).dsc_cdr_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_GET(r) (((r).dsc_cdr_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_SET(r,f) (r).dsc_cdr_ctl0[0]=(((r).dsc_cdr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_CDR_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_FALCON_XGXS_WRITE_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL0r,(_r._dsc_cdr_ctl0))
#define BCMI_FALCON_XGXS_READLN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_DSC_CDR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL0r BCMI_FALCON_XGXS_DSC_CDR_CTL0r
#define DSC_CDR_CTL0r_SIZE BCMI_FALCON_XGXS_DSC_CDR_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_DSC_CDR_CTL0r_t DSC_CDR_CTL0r_t;
#define DSC_CDR_CTL0r_CLR BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CLR
#define DSC_CDR_CTL0r_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_SET
#define DSC_CDR_CTL0r_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_GET
#define DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_GET
#define DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_ZERO_POLARITYf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_OVERRIDE_ENf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_SAT_SELf_SET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_GET
#define DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_PHASE_ERR_FRZf_SET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_GET
#define DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_INTEG_REG_CLRf_SET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_GET
#define DSC_CDR_CTL0r_CDR_FREQ_ENf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_CDR_FREQ_ENf_SET
#define DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_GET
#define DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_PATTERN_ENHANCEDf_SET
#define DSC_CDR_CTL0r_BR_PD_ENf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_GET
#define DSC_CDR_CTL0r_BR_PD_ENf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_BR_PD_ENf_SET
#define DSC_CDR_CTL0r_OS_ALL_EDGESf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_GET
#define DSC_CDR_CTL0r_OS_ALL_EDGESf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL0r_OS_ALL_EDGESf_SET
#define READ_DSC_CDR_CTL0r BCMI_FALCON_XGXS_READ_DSC_CDR_CTL0r
#define WRITE_DSC_CDR_CTL0r BCMI_FALCON_XGXS_WRITE_DSC_CDR_CTL0r
#define MODIFY_DSC_CDR_CTL0r BCMI_FALCON_XGXS_MODIFY_DSC_CDR_CTL0r
#define READLN_DSC_CDR_CTL0r BCMI_FALCON_XGXS_READLN_DSC_CDR_CTL0r
#define WRITELN_DSC_CDR_CTL0r BCMI_FALCON_XGXS_WRITELN_DSC_CDR_CTL0r
#define WRITEALL_DSC_CDR_CTL0r BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_CDR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_CDR_CTL1
 * BLOCKS:   DSC_C
 * REGADDR:  0xd051
 * DEVAD:    1
 * DESC:     cdr control register 1.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_FREQ_OVERRIDE_VAL Gets loaded into the integ reg @ reset. Also, see alternate use in description of cdr_freq_override_en
 */
#define BCMI_FALCON_XGXS_DSC_CDR_CTL1r (0x0001d051 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_CDR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL1.
 */
typedef union BCMI_FALCON_XGXS_DSC_CDR_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl1[1];
	uint32_t _dsc_cdr_ctl1;
} BCMI_FALCON_XGXS_DSC_CDR_CTL1r_t;

#define BCMI_FALCON_XGXS_DSC_CDR_CTL1r_CLR(r) (r).dsc_cdr_ctl1[0] = 0
#define BCMI_FALCON_XGXS_DSC_CDR_CTL1r_SET(r,d) (r).dsc_cdr_ctl1[0] = d
#define BCMI_FALCON_XGXS_DSC_CDR_CTL1r_GET(r) (r).dsc_cdr_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET(r) ((((r).dsc_cdr_ctl1[0]) >> 5) & 0x7ff)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET(r,f) (r).dsc_cdr_ctl1[0]=(((r).dsc_cdr_ctl1[0] & ~((uint32_t)0x7ff << 5)) | ((((uint32_t)f) & 0x7ff) << 5)) | (2047 << (16 + 5))

/*
 * These macros can be used to access DSC_CDR_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_FALCON_XGXS_WRITE_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL1r,(_r._dsc_cdr_ctl1))
#define BCMI_FALCON_XGXS_READLN_DSC_CDR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_DSC_CDR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL1r BCMI_FALCON_XGXS_DSC_CDR_CTL1r
#define DSC_CDR_CTL1r_SIZE BCMI_FALCON_XGXS_DSC_CDR_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_DSC_CDR_CTL1r_t DSC_CDR_CTL1r_t;
#define DSC_CDR_CTL1r_CLR BCMI_FALCON_XGXS_DSC_CDR_CTL1r_CLR
#define DSC_CDR_CTL1r_SET BCMI_FALCON_XGXS_DSC_CDR_CTL1r_SET
#define DSC_CDR_CTL1r_GET BCMI_FALCON_XGXS_DSC_CDR_CTL1r_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_GET
#define DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL1r_CDR_FREQ_OVERRIDE_VALf_SET
#define READ_DSC_CDR_CTL1r BCMI_FALCON_XGXS_READ_DSC_CDR_CTL1r
#define WRITE_DSC_CDR_CTL1r BCMI_FALCON_XGXS_WRITE_DSC_CDR_CTL1r
#define MODIFY_DSC_CDR_CTL1r BCMI_FALCON_XGXS_MODIFY_DSC_CDR_CTL1r
#define READLN_DSC_CDR_CTL1r BCMI_FALCON_XGXS_READLN_DSC_CDR_CTL1r
#define WRITELN_DSC_CDR_CTL1r BCMI_FALCON_XGXS_WRITELN_DSC_CDR_CTL1r
#define WRITEALL_DSC_CDR_CTL1r BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_CDR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_CDR_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd052
 * DEVAD:    1
 * DESC:     cdr control register 2
 * RESETVAL: 0x80 (128)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_LM_THR_SEL   cdr lock monitor looks for integ reg to be within sat level - (cdr_lm_thr_sel +1)*512 in magnitude
 *     CDR_1G_SWAP_PZ   When 1, this will swap the peaks and zeros going out as the DME data. It will still use the original peaks and zeros for data recovery.
 *     CDR_1G_FORCE_EN  Forces the enable on the 1g logic. Else it should be enabled with osr mode setting to correct value.
 *     TX_PI_LOOP_TIMING_SRC_SEL Needs to be 1 in order to gate the phase sum on.This bit is ignored in repeater
 *     PHS_SUM_IGNORE_DSC_LOCK Normally the phase summer waits for dsc lock. This bit overrides that wait.
 *     CDR_1G_MANUAL_MODE Puts the 1G CDR in manual mode.
 *     CDR_1G_MANUAL_STROBE Manual Strobe for the 1G CDR.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r (0x0001d052 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_CTL2.
 */
typedef union BCMI_FALCON_XGXS_DSC_CDR_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_cdr_ctl2[1];
	uint32_t _dsc_cdr_ctl2;
} BCMI_FALCON_XGXS_DSC_CDR_CTL2r_t;

#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CLR(r) (r).dsc_cdr_ctl2[0] = 0
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_SET(r,d) (r).dsc_cdr_ctl2[0] = d
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_GET(r) (r).dsc_cdr_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET(r) ((((r).dsc_cdr_ctl2[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET(r) (((r).dsc_cdr_ctl2[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET(r,f) (r).dsc_cdr_ctl2[0]=(((r).dsc_cdr_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_CDR_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_FALCON_XGXS_WRITE_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL2r,(_r._dsc_cdr_ctl2))
#define BCMI_FALCON_XGXS_READLN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_DSC_CDR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_CTL2r BCMI_FALCON_XGXS_DSC_CDR_CTL2r
#define DSC_CDR_CTL2r_SIZE BCMI_FALCON_XGXS_DSC_CDR_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_DSC_CDR_CTL2r_t DSC_CDR_CTL2r_t;
#define DSC_CDR_CTL2r_CLR BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CLR
#define DSC_CDR_CTL2r_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_SET
#define DSC_CDR_CTL2r_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_GET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_GET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_STROBEf_SET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_GET
#define DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_MANUAL_MODEf_SET
#define DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_GET
#define DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_PHS_SUM_IGNORE_DSC_LOCKf_SET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_GET
#define DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_TX_PI_LOOP_TIMING_SRC_SELf_SET
#define DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_GET
#define DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_FORCE_ENf_SET
#define DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_GET
#define DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_1G_SWAP_PZf_SET
#define DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_GET
#define DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET BCMI_FALCON_XGXS_DSC_CDR_CTL2r_CDR_LM_THR_SELf_SET
#define READ_DSC_CDR_CTL2r BCMI_FALCON_XGXS_READ_DSC_CDR_CTL2r
#define WRITE_DSC_CDR_CTL2r BCMI_FALCON_XGXS_WRITE_DSC_CDR_CTL2r
#define MODIFY_DSC_CDR_CTL2r BCMI_FALCON_XGXS_MODIFY_DSC_CDR_CTL2r
#define READLN_DSC_CDR_CTL2r BCMI_FALCON_XGXS_READLN_DSC_CDR_CTL2r
#define WRITELN_DSC_CDR_CTL2r BCMI_FALCON_XGXS_WRITELN_DSC_CDR_CTL2r
#define WRITEALL_DSC_CDR_CTL2r BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_CDR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PI_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd053
 * DEVAD:    1
 * DESC:     rx pi control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PI_SLICERS_EN bit-vector representing which PI's to adjust: [0] d, [1] dq, [2] p, [3] pq, [4] l, [6] lq
 *     RX_PI_PHASE_STEP_CNT # of steps to adjust: 0..7: [1, 46,52,58,64,70,76,84]
 *     RX_PI_PHASE_STEP_DIR 0: left shift, 1: right shift
 *     RX_PI_MANUAL_MODE 0: normal, 1:disconnect all PI's from CDR when enabled
 *     RX_PI_MANUAL_STROBE perform a manual override over specified number of clocks
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr (0x0001d053 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CTL.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_ctl[1];
	uint32_t _dsc_rx_pi_ctl;
} BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_CLR(r) (r).dsc_rx_pi_ctl[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_SET(r,d) (r).dsc_rx_pi_ctl[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_GET(r) (r).dsc_rx_pi_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET(r) ((((r).dsc_rx_pi_ctl[0]) >> 6) & 0x7)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET(r) (((r).dsc_rx_pi_ctl[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET(r,f) (r).dsc_rx_pi_ctl[0]=(((r).dsc_rx_pi_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_RX_PI_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CTLr,(_r._dsc_rx_pi_ctl))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CTLr BCMI_FALCON_XGXS_DSC_RX_PI_CTLr
#define DSC_RX_PI_CTLr_SIZE BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_t DSC_RX_PI_CTLr_t;
#define DSC_RX_PI_CTLr_CLR BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_CLR
#define DSC_RX_PI_CTLr_SET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_SET
#define DSC_RX_PI_CTLr_GET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_STROBEf_SET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_GET
#define DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_MANUAL_MODEf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_DIRf_SET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_GET
#define DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_PHASE_STEP_CNTf_SET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_GET
#define DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CTLr_RX_PI_SLICERS_ENf_SET
#define READ_DSC_RX_PI_CTLr BCMI_FALCON_XGXS_READ_DSC_RX_PI_CTLr
#define WRITE_DSC_RX_PI_CTLr BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CTLr
#define MODIFY_DSC_RX_PI_CTLr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CTLr
#define READLN_DSC_RX_PI_CTLr BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CTLr
#define WRITELN_DSC_RX_PI_CTLr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CTLr
#define WRITEALL_DSC_RX_PI_CTLr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PI_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd055
 * DEVAD:    1
 * DESC:     trnsum control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_GAIN      bit-vector representing the gain to be applied: [0] 1, [1] 2, [2] 4, [3] 8
 *     TRNSUM_SEL_EMUX  0 selects phase slicer and 1 selects lms slicer
 *     TRNSUM_TAP_RANGE_SEL Taps -32 to 4 are broken into groups of 8 and                        this selects the range
 *     TRNSUM_COR_SEL   00: normal; 01: all 1s instead of emux; 10:                        count number of emux!= data; 11: all 1s instead of d[n-delay]
 *     TRNSUM_QPHASE_MULT_EN Enables cdr phase error to weigh the                        correlator output
 *     TRNSUM_RANDOM_TAPSEL_DISABLE Disables randomizing logic for tap                        selection. Enables sequential selection.
 *     TRNSUM_EYE_CLOSURE_EN When enabled this ands another term to the                        condition. d[n] != emux[n]
 *     TRNSUM_EN        Training sum enable
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr (0x0001d055 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_CTL.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_ctl[1];
	uint32_t _dsc_trnsum_ctl;
} BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_CLR(r) (r).dsc_trnsum_ctl[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_SET(r,d) (r).dsc_trnsum_ctl[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_GET(r) (r).dsc_trnsum_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 4) & 0x7)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_GET(r) ((((r).dsc_trnsum_ctl[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET(r) (((r).dsc_trnsum_ctl[0]) & 0x3)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET(r,f) (r).dsc_trnsum_ctl[0]=(((r).dsc_trnsum_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr,(_r._dsc_trnsum_ctl))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr,(_r._dsc_trnsum_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr,(_r._dsc_trnsum_ctl))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_CTLr BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr
#define DSC_TRNSUM_CTLr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_t DSC_TRNSUM_CTLr_t;
#define DSC_TRNSUM_CTLr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_CLR
#define DSC_TRNSUM_CTLr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_SET
#define DSC_TRNSUM_CTLr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_GET
#define DSC_TRNSUM_CTLr_TRNSUM_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_EYE_CLOSURE_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_RANDOM_TAPSEL_DISABLEf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_QPHASE_MULT_ENf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_COR_SELf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_TAP_RANGE_SELf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_SEL_EMUXf_SET
#define DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_GET
#define DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr_TRNSUM_GAINf_SET
#define READ_DSC_TRNSUM_CTLr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_CTLr
#define WRITE_DSC_TRNSUM_CTLr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_CTLr
#define MODIFY_DSC_TRNSUM_CTLr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_CTLr
#define READLN_DSC_TRNSUM_CTLr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_CTLr
#define WRITELN_DSC_TRNSUM_CTLr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_CTLr
#define WRITEALL_DSC_TRNSUM_CTLr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL1
 * BLOCKS:   DSC_C
 * REGADDR:  0xd056
 * DEVAD:    1
 * DESC:     trnsum pattern control 1 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN   pattern to be compared
 *     TRNSUM_PATTERN_FULL_CHECK_OFF enables pattern matching
 *     TRNSUM_EDGE_PATTERN_EN enables pattern matching on edges {-6,-5,-4,-3,-2,-1,data,0,1,2} where a number (eg: -4) represents an edge between d[-4] and d[-3]
 *     TRNSUM_INV_PATTERN_EN enables inverted pattern matching
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r (0x0001d056 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL1.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl1[1];
	uint32_t _dsc_trnsum_pat_ctl1;
} BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_CLR(r) (r).dsc_trnsum_pat_ctl1[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_SET(r,d) (r).dsc_trnsum_pat_ctl1[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_GET(r) (r).dsc_trnsum_pat_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_pat_ctl1[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET(r) ((((r).dsc_trnsum_pat_ctl1[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET(r) ((((r).dsc_trnsum_pat_ctl1[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_GET(r) (((r).dsc_trnsum_pat_ctl1[0]) & 0x3ff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_SET(r,f) (r).dsc_trnsum_pat_ctl1[0]=(((r).dsc_trnsum_pat_ctl1[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_PAT_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r,(_r._dsc_trnsum_pat_ctl1))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_PAT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r,(_r._dsc_trnsum_pat_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r,(_r._dsc_trnsum_pat_ctl1))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_PAT_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL1r BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r
#define DSC_TRNSUM_PAT_CTL1r_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_t DSC_TRNSUM_PAT_CTL1r_t;
#define DSC_TRNSUM_PAT_CTL1r_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_CLR
#define DSC_TRNSUM_PAT_CTL1r_SET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_SET
#define DSC_TRNSUM_PAT_CTL1r_GET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_INV_PATTERN_ENf_SET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_EDGE_PATTERN_ENf_SET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERN_FULL_CHECK_OFFf_SET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_GET
#define DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r_TRNSUM_PATTERNf_SET
#define READ_DSC_TRNSUM_PAT_CTL1r BCMI_FALCON_XGXS_READ_DSC_TRNSUM_PAT_CTL1r
#define WRITE_DSC_TRNSUM_PAT_CTL1r BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_PAT_CTL1r
#define MODIFY_DSC_TRNSUM_PAT_CTL1r BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL1r
#define READLN_DSC_TRNSUM_PAT_CTL1r BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_PAT_CTL1r
#define WRITELN_DSC_TRNSUM_PAT_CTL1r BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL1r
#define WRITEALL_DSC_TRNSUM_PAT_CTL1r BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_PAT_CTL2
 * BLOCKS:   DSC_C
 * REGADDR:  0xd057
 * DEVAD:    1
 * DESC:     trnsum pattern control 2 register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_PATTERN_BIT_EN pattern mask
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r (0x0001d057 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_PAT_CTL2.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_pat_ctl2[1];
	uint32_t _dsc_trnsum_pat_ctl2;
} BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_CLR(r) (r).dsc_trnsum_pat_ctl2[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_SET(r,d) (r).dsc_trnsum_pat_ctl2[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_GET(r) (r).dsc_trnsum_pat_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET(r) (((r).dsc_trnsum_pat_ctl2[0]) & 0x3ff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET(r,f) (r).dsc_trnsum_pat_ctl2[0]=(((r).dsc_trnsum_pat_ctl2[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_PAT_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_PAT_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r,(_r._dsc_trnsum_pat_ctl2))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_PAT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r,(_r._dsc_trnsum_pat_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r,(_r._dsc_trnsum_pat_ctl2))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_PAT_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_pat_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_pat_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_PAT_CTL2r BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r
#define DSC_TRNSUM_PAT_CTL2r_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_t DSC_TRNSUM_PAT_CTL2r_t;
#define DSC_TRNSUM_PAT_CTL2r_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_CLR
#define DSC_TRNSUM_PAT_CTL2r_SET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_SET
#define DSC_TRNSUM_PAT_CTL2r_GET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_GET
#define DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_GET
#define DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r_TRNSUM_PATTERN_BIT_ENf_SET
#define READ_DSC_TRNSUM_PAT_CTL2r BCMI_FALCON_XGXS_READ_DSC_TRNSUM_PAT_CTL2r
#define WRITE_DSC_TRNSUM_PAT_CTL2r BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_PAT_CTL2r
#define MODIFY_DSC_TRNSUM_PAT_CTL2r BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_PAT_CTL2r
#define READLN_DSC_TRNSUM_PAT_CTL2r BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_PAT_CTL2r
#define WRITELN_DSC_TRNSUM_PAT_CTL2r BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_PAT_CTL2r
#define WRITEALL_DSC_TRNSUM_PAT_CTL2r BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_PAT_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_PAT_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_TAP_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd058
 * DEVAD:    1
 * DESC:     trnsum tap control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TRNSUM_TAP_EN    Training taps enabled (either randomize over                        them or not)
 *     TRNSUM_TAP_SIGN  Sign of the 8 taps in the group
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr (0x0001d058 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_TAP_CTL.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_tap_ctl[1];
	uint32_t _dsc_trnsum_tap_ctl;
} BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_CLR(r) (r).dsc_trnsum_tap_ctl[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_SET(r,d) (r).dsc_trnsum_tap_ctl[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_GET(r) (r).dsc_trnsum_tap_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET(r) ((((r).dsc_trnsum_tap_ctl[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET(r,f) (r).dsc_trnsum_tap_ctl[0]=(((r).dsc_trnsum_tap_ctl[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET(r) (((r).dsc_trnsum_tap_ctl[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET(r,f) (r).dsc_trnsum_tap_ctl[0]=(((r).dsc_trnsum_tap_ctl[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_TRNSUM_TAP_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr,(_r._dsc_trnsum_tap_ctl))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr,(_r._dsc_trnsum_tap_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr,(_r._dsc_trnsum_tap_ctl))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_TAP_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tap_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_TAP_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tap_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_TAP_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_tap_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_TAP_CTLr BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr
#define DSC_TRNSUM_TAP_CTLr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_t DSC_TRNSUM_TAP_CTLr_t;
#define DSC_TRNSUM_TAP_CTLr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_CLR
#define DSC_TRNSUM_TAP_CTLr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_SET
#define DSC_TRNSUM_TAP_CTLr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_SIGNf_SET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_GET
#define DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr_TRNSUM_TAP_ENf_SET
#define READ_DSC_TRNSUM_TAP_CTLr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_TAP_CTLr
#define WRITE_DSC_TRNSUM_TAP_CTLr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_TAP_CTLr
#define MODIFY_DSC_TRNSUM_TAP_CTLr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_TAP_CTLr
#define READLN_DSC_TRNSUM_TAP_CTLr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_TAP_CTLr
#define WRITELN_DSC_TRNSUM_TAP_CTLr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_TAP_CTLr
#define WRITEALL_DSC_TRNSUM_TAP_CTLr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_TAP_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_TAP_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_TDT_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd059
 * DEVAD:    1
 * DESC:     trnsum tdt control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TDT_BIT_SEL      tdt bit select: range is 0 to 39
 *     TDT_PRBS_MODE    enables selection of every 511th bit or 255th bitIf tdt_cycle_sel[0] = 0, then it wraps @ 255, else @ 511
 *     TDT_TRNSUM_EN    enables the tdt featureAt no point should this be disabled in the middle of collecting data over multiple locations.The counters which figure out which cycle to select while this bit is 1.
 *     TDT_CYCLE_SEL    the cycle counter wraps at this number
 *     TDT_CYCLE_BIN    valid range: from 0 to tdt_cycle_sel; this cycle the tdt is enabled on bit indicated by tdt_bit_sel
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr (0x0001d059 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_TDT_CTL.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_tdt_ctl[1];
	uint32_t _dsc_trnsum_tdt_ctl;
} BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_CLR(r) (r).dsc_trnsum_tdt_ctl[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_SET(r,d) (r).dsc_trnsum_tdt_ctl[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_GET(r) (r).dsc_trnsum_tdt_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_GET(r) ((((r).dsc_trnsum_tdt_ctl[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_GET(r) (((r).dsc_trnsum_tdt_ctl[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_SET(r,f) (r).dsc_trnsum_tdt_ctl[0]=(((r).dsc_trnsum_tdt_ctl[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_TRNSUM_TDT_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr,(_r._dsc_trnsum_tdt_ctl))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr,(_r._dsc_trnsum_tdt_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr,(_r._dsc_trnsum_tdt_ctl))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_TDT_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tdt_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_TDT_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_tdt_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_TDT_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_tdt_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_TDT_CTLr BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr
#define DSC_TRNSUM_TDT_CTLr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_t DSC_TRNSUM_TDT_CTLr_t;
#define DSC_TRNSUM_TDT_CTLr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_CLR
#define DSC_TRNSUM_TDT_CTLr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_SET
#define DSC_TRNSUM_TDT_CTLr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_BINf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_CYCLE_SELf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_TRNSUM_ENf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_PRBS_MODEf_SET
#define DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_GET
#define DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr_TDT_BIT_SELf_SET
#define READ_DSC_TRNSUM_TDT_CTLr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_TDT_CTLr
#define WRITE_DSC_TRNSUM_TDT_CTLr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_TDT_CTLr
#define MODIFY_DSC_TRNSUM_TDT_CTLr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_TDT_CTLr
#define READLN_DSC_TRNSUM_TDT_CTLr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_TDT_CTLr
#define WRITELN_DSC_TRNSUM_TDT_CTLr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_TDT_CTLr
#define WRITEALL_DSC_TRNSUM_TDT_CTLr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_TDT_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_TDT_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_TRNSUM_MISC
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05a
 * DEVAD:    1
 * DESC:     trnsum misc register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TDT_PRBS_SLIP    tdt bit select: range is 0 to 39self clearing
 *     CDR_1G_TRNSUM_EN Enables accumulation of 1G CDR phase step.This logic is only supported in the repeater application - controlled by a strap bit @ kernel
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr (0x0001d05a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_SIZE 4

/*
 * This structure should be used to declare and program DSC_TRNSUM_MISC.
 */
typedef union BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_s {
	uint32_t v[1];
	uint32_t dsc_trnsum_misc[1];
	uint32_t _dsc_trnsum_misc;
} BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_t;

#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_CLR(r) (r).dsc_trnsum_misc[0] = 0
#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_SET(r,d) (r).dsc_trnsum_misc[0] = d
#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_GET(r) (r).dsc_trnsum_misc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_GET(r) ((((r).dsc_trnsum_misc[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET(r) (((r).dsc_trnsum_misc[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET(r,f) (r).dsc_trnsum_misc[0]=(((r).dsc_trnsum_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_TRNSUM_MISC.
 */
#define BCMI_FALCON_XGXS_READ_DSC_TRNSUM_MISCr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr,(_r._dsc_trnsum_misc))
#define BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr,(_r._dsc_trnsum_misc)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr,(_r._dsc_trnsum_misc))
#define BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_MISCr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_misc))
#define BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_MISCr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_trnsum_misc))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_trnsum_misc))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_TRNSUM_MISCr BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr
#define DSC_TRNSUM_MISCr_SIZE BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_SIZE
typedef BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_t DSC_TRNSUM_MISCr_t;
#define DSC_TRNSUM_MISCr_CLR BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_CLR
#define DSC_TRNSUM_MISCr_SET BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_SET
#define DSC_TRNSUM_MISCr_GET BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_GET
#define DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_GET
#define DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_CDR_1G_TRNSUM_ENf_SET
#define DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_GET
#define DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr_TDT_PRBS_SLIPf_SET
#define READ_DSC_TRNSUM_MISCr BCMI_FALCON_XGXS_READ_DSC_TRNSUM_MISCr
#define WRITE_DSC_TRNSUM_MISCr BCMI_FALCON_XGXS_WRITE_DSC_TRNSUM_MISCr
#define MODIFY_DSC_TRNSUM_MISCr BCMI_FALCON_XGXS_MODIFY_DSC_TRNSUM_MISCr
#define READLN_DSC_TRNSUM_MISCr BCMI_FALCON_XGXS_READLN_DSC_TRNSUM_MISCr
#define WRITELN_DSC_TRNSUM_MISCr BCMI_FALCON_XGXS_WRITELN_DSC_TRNSUM_MISCr
#define WRITEALL_DSC_TRNSUM_MISCr BCMI_FALCON_XGXS_WRITEALL_DSC_TRNSUM_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_TRNSUM_MISCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_VGA_CTL1
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05c
 * DEVAD:    1
 * DESC:     vga block control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     VGA_TIMER_T2     VGA timed write. Wait for  (1,2, ...8) cycles
 *     UC_TRNSUM_EN     1'b1 will move the state from UC_TUNE to MEASURE. This is a self-clear register bit.
 *     DC_OFFS_WRITE_EN self clearing dc offset write strobe
 *     VGA_DEC          self clearing vga dec
 *     VGA_INC          self clearing vga inc
 *     RX_VGA_CTRL_VAL  override val of vga
 *     VGA_WRITE        strobe to write VGA values
 */
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r (0x0001d05c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_VGA_CTL1.
 */
typedef union BCMI_FALCON_XGXS_DSC_VGA_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_vga_ctl1[1];
	uint32_t _dsc_vga_ctl1;
} BCMI_FALCON_XGXS_DSC_VGA_CTL1r_t;

#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_CLR(r) (r).dsc_vga_ctl1[0] = 0
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_SET(r,d) (r).dsc_vga_ctl1[0] = d
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_GET(r) (r).dsc_vga_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_WRITEf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_WRITEf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 8) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_INCf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_INCf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_DECf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_DECf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_UC_TRNSUM_ENf_GET(r) ((((r).dsc_vga_ctl1[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_UC_TRNSUM_ENf_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_TIMER_T2f_GET(r) (((r).dsc_vga_ctl1[0]) & 0x7)
#define BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_TIMER_T2f_SET(r,f) (r).dsc_vga_ctl1[0]=(((r).dsc_vga_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DSC_VGA_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_DSC_VGA_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_VGA_CTL1r,(_r._dsc_vga_ctl1))
#define BCMI_FALCON_XGXS_WRITE_DSC_VGA_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_CTL1r,(_r._dsc_vga_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_VGA_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_CTL1r,(_r._dsc_vga_ctl1))
#define BCMI_FALCON_XGXS_READLN_DSC_VGA_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_VGA_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_DSC_VGA_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_vga_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_VGA_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_VGA_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_vga_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_VGA_CTL1r BCMI_FALCON_XGXS_DSC_VGA_CTL1r
#define DSC_VGA_CTL1r_SIZE BCMI_FALCON_XGXS_DSC_VGA_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_DSC_VGA_CTL1r_t DSC_VGA_CTL1r_t;
#define DSC_VGA_CTL1r_CLR BCMI_FALCON_XGXS_DSC_VGA_CTL1r_CLR
#define DSC_VGA_CTL1r_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_SET
#define DSC_VGA_CTL1r_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_GET
#define DSC_VGA_CTL1r_VGA_WRITEf_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_WRITEf_GET
#define DSC_VGA_CTL1r_VGA_WRITEf_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_WRITEf_SET
#define DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_GET
#define DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_RX_VGA_CTRL_VALf_SET
#define DSC_VGA_CTL1r_VGA_INCf_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_INCf_GET
#define DSC_VGA_CTL1r_VGA_INCf_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_INCf_SET
#define DSC_VGA_CTL1r_VGA_DECf_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_DECf_GET
#define DSC_VGA_CTL1r_VGA_DECf_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_DECf_SET
#define DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_GET
#define DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_DC_OFFS_WRITE_ENf_SET
#define DSC_VGA_CTL1r_UC_TRNSUM_ENf_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_UC_TRNSUM_ENf_GET
#define DSC_VGA_CTL1r_UC_TRNSUM_ENf_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_UC_TRNSUM_ENf_SET
#define DSC_VGA_CTL1r_VGA_TIMER_T2f_GET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_TIMER_T2f_GET
#define DSC_VGA_CTL1r_VGA_TIMER_T2f_SET BCMI_FALCON_XGXS_DSC_VGA_CTL1r_VGA_TIMER_T2f_SET
#define READ_DSC_VGA_CTL1r BCMI_FALCON_XGXS_READ_DSC_VGA_CTL1r
#define WRITE_DSC_VGA_CTL1r BCMI_FALCON_XGXS_WRITE_DSC_VGA_CTL1r
#define MODIFY_DSC_VGA_CTL1r BCMI_FALCON_XGXS_MODIFY_DSC_VGA_CTL1r
#define READLN_DSC_VGA_CTL1r BCMI_FALCON_XGXS_READLN_DSC_VGA_CTL1r
#define WRITELN_DSC_VGA_CTL1r BCMI_FALCON_XGXS_WRITELN_DSC_VGA_CTL1r
#define WRITEALL_DSC_VGA_CTL1r BCMI_FALCON_XGXS_WRITEALL_DSC_VGA_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_VGA_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_DATA_SLCR_THR_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05d
 * DEVAD:    1
 * DESC:     data slicer threshold control register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     THRESH_TIMER_T1  1,2,3,4 - indicates how many cycles to wait for before applying an inc or dec
 *     THRESH_STEP_SIZE 1,2,3 - auto increment step size for threshold
 *     DATA_THRESH_SEL_VAL Override mode value
 *     DATA_THRESH_WRITE self clearing data thresh write (for override mode)
 */
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr (0x0001d05d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DATA_SLCR_THR_CTL.
 */
typedef union BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_data_slcr_thr_ctl[1];
	uint32_t _dsc_data_slcr_thr_ctl;
} BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_t;

#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_CLR(r) (r).dsc_data_slcr_thr_ctl[0] = 0
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_SET(r,d) (r).dsc_data_slcr_thr_ctl[0] = d
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_GET(r) (r).dsc_data_slcr_thr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_GET(r) ((((r).dsc_data_slcr_thr_ctl[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_GET(r) ((((r).dsc_data_slcr_thr_ctl[0]) >> 8) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_GET(r) ((((r).dsc_data_slcr_thr_ctl[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_GET(r) (((r).dsc_data_slcr_thr_ctl[0]) & 0x3)
#define BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_SET(r,f) (r).dsc_data_slcr_thr_ctl[0]=(((r).dsc_data_slcr_thr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access DSC_DATA_SLCR_THR_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_DATA_SLCR_THR_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr,(_r._dsc_data_slcr_thr_ctl))
#define BCMI_FALCON_XGXS_WRITE_DSC_DATA_SLCR_THR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr,(_r._dsc_data_slcr_thr_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_DATA_SLCR_THR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr,(_r._dsc_data_slcr_thr_ctl))
#define BCMI_FALCON_XGXS_READLN_DSC_DATA_SLCR_THR_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_data_slcr_thr_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DSC_DATA_SLCR_THR_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_data_slcr_thr_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_DATA_SLCR_THR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_data_slcr_thr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DATA_SLCR_THR_CTLr BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr
#define DSC_DATA_SLCR_THR_CTLr_SIZE BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_t DSC_DATA_SLCR_THR_CTLr_t;
#define DSC_DATA_SLCR_THR_CTLr_CLR BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_CLR
#define DSC_DATA_SLCR_THR_CTLr_SET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_SET
#define DSC_DATA_SLCR_THR_CTLr_GET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_GET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_GET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_GET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_SET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_WRITEf_SET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_GET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_GET
#define DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_SET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_DATA_THRESH_SEL_VALf_SET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_GET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_GET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_SET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_STEP_SIZEf_SET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_GET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_GET
#define DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_SET BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr_THRESH_TIMER_T1f_SET
#define READ_DSC_DATA_SLCR_THR_CTLr BCMI_FALCON_XGXS_READ_DSC_DATA_SLCR_THR_CTLr
#define WRITE_DSC_DATA_SLCR_THR_CTLr BCMI_FALCON_XGXS_WRITE_DSC_DATA_SLCR_THR_CTLr
#define MODIFY_DSC_DATA_SLCR_THR_CTLr BCMI_FALCON_XGXS_MODIFY_DSC_DATA_SLCR_THR_CTLr
#define READLN_DSC_DATA_SLCR_THR_CTLr BCMI_FALCON_XGXS_READLN_DSC_DATA_SLCR_THR_CTLr
#define WRITELN_DSC_DATA_SLCR_THR_CTLr BCMI_FALCON_XGXS_WRITELN_DSC_DATA_SLCR_THR_CTLr
#define WRITEALL_DSC_DATA_SLCR_THR_CTLr BCMI_FALCON_XGXS_WRITEALL_DSC_DATA_SLCR_THR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_DATA_SLCR_THR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_DC_OFFS_CTL
 * BLOCKS:   DSC_C
 * REGADDR:  0xd05e
 * DEVAD:    1
 * DESC:     dc offset control register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     DC_OFFS_EN       Enables DC Offset tap for adaptation (still needs trnsum to be un-frozen)
 *     DC_OFFS_HYS_EN   Needs to be 1 for hysteresis to be on
 *     DC_OFFS_HYS_MAG  0: 11th bit <<7; 1: 11th bit <<5
 *     DC_OFFS_GRADIENT_INVERT Inverts the sense of the update (inc,dec swap)
 *     DC_OFFS_GAIN     multiplies the +-40 error by 2^{0,1,2,3}
 *     DC_OFFS_ACC_CLR  Clears the internal state except for the final tap
 *     DC_OFFS_WRITE_VAL write value for the dc offset in override modeThe logic walks to this value @ the start of automatic adaptation
 *     DC_OFFS_WRITE_FRC_EN self clearing dc offset force write strobeThis is simply an override to everything. This write gets sign gray converted and written to the dc_offset register
 */
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr (0x0001d05e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DSC_DC_OFFS_CTL.
 */
typedef union BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_s {
	uint32_t v[1];
	uint32_t dsc_dc_offs_ctl[1];
	uint32_t _dsc_dc_offs_ctl;
} BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_t;

#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_CLR(r) (r).dsc_dc_offs_ctl[0] = 0
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_SET(r,d) (r).dsc_dc_offs_ctl[0] = d
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_GET(r) (r).dsc_dc_offs_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 8) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x7f << 8)) | ((((uint32_t)f) & 0x7f) << 8)) | (127 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 5) & 0x3)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET(r) ((((r).dsc_dc_offs_ctl[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET(r) (((r).dsc_dc_offs_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET(r,f) (r).dsc_dc_offs_ctl[0]=(((r).dsc_dc_offs_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_DC_OFFS_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr,(_r._dsc_dc_offs_ctl))
#define BCMI_FALCON_XGXS_WRITE_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr,(_r._dsc_dc_offs_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr,(_r._dsc_dc_offs_ctl))
#define BCMI_FALCON_XGXS_READLN_DSC_DC_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DSC_DC_OFFS_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_dc_offs_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_DC_OFFS_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_dc_offs_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_DC_OFFS_CTLr BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr
#define DSC_DC_OFFS_CTLr_SIZE BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_t DSC_DC_OFFS_CTLr_t;
#define DSC_DC_OFFS_CTLr_CLR BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_CLR
#define DSC_DC_OFFS_CTLr_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_SET
#define DSC_DC_OFFS_CTLr_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_FRC_ENf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_WRITE_VALf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ACC_CLRf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GAINf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_GRADIENT_INVERTf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_MAGf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_HYS_ENf_SET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_GET
#define DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr_DC_OFFS_ENf_SET
#define READ_DSC_DC_OFFS_CTLr BCMI_FALCON_XGXS_READ_DSC_DC_OFFS_CTLr
#define WRITE_DSC_DC_OFFS_CTLr BCMI_FALCON_XGXS_WRITE_DSC_DC_OFFS_CTLr
#define MODIFY_DSC_DC_OFFS_CTLr BCMI_FALCON_XGXS_MODIFY_DSC_DC_OFFS_CTLr
#define READLN_DSC_DC_OFFS_CTLr BCMI_FALCON_XGXS_READLN_DSC_DC_OFFS_CTLr
#define WRITELN_DSC_DC_OFFS_CTLr BCMI_FALCON_XGXS_WRITELN_DSC_DC_OFFS_CTLr
#define WRITEALL_DSC_DC_OFFS_CTLr BCMI_FALCON_XGXS_WRITEALL_DSC_DC_OFFS_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_DC_OFFS_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL0
 * BLOCKS:   DSC_D
 * REGADDR:  0xd060
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 0
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_MODE_EN      1'b1 will enable the EEE mode.
 *     EEE_QUIET_RX_AFE_PWRDWN_VAL 1'b1 will enable the RX AFE powerdown in EEE_QUIET mode.
 *     IGNORE_RX_MODE   If set to 1'b1 then pmd_rx_mode input will be ignored in DSC SM.
 *     CL72_TIMER_EN    If enabled to 1'b1 then LFSR is loaded with 0x01CD else it is loaded with 0x1C1E for all non-EEE and non-MEASURE states.
 *     UC_TUNE_EN       uc_tune_en is used to move in and out of UC_TUNE state. Look for DSC SM state diagram for more details.
 *     HW_TUNE_EN       Should be 1'b1 along with uc_tune_en==1'b1 to move from UC_TUNE to HW_TUNE state.  This is a self-clear register bit.
 *     EEE_MEASURE_EN   1'b1 Enables the measurement during EEE_MEASURE.
 *     UC_ACK_DSC_EEE_DONE 1'b1 will enable the EEE_DONE to DONE transition. This is a self-clear bit.
 *     UC_ACK_DSC_RESTART 1'b1 will enable the RESTART to CONFIG transition. This is a self-clear bit.
 *     UC_ACK_DSC_CONFIG 1'b1 will enable the CONFIG to WAIT_FOR_SIG transition. This is a self-clear bit.
 *     SET_MEAS_INCOMPLETE 1'b1 will force meas_incomplete to be 1'b1 to start a new measurement in EEE mode. This is a self-clear bit.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r (0x0001d060 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL0.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL0r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl0[1];
	uint32_t _dsc_sm_ctl0;
} BCMI_FALCON_XGXS_DSC_SM_CTL0r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_CLR(r) (r).dsc_sm_ctl0[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_SET(r,d) (r).dsc_sm_ctl0[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_GET(r) (r).dsc_sm_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET(r) ((((r).dsc_sm_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET(r,f) (r).dsc_sm_ctl0[0]=(((r).dsc_sm_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access DSC_SM_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL0r,(_r._dsc_sm_ctl0))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL0r BCMI_FALCON_XGXS_DSC_SM_CTL0r
#define DSC_SM_CTL0r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL0r_t DSC_SM_CTL0r_t;
#define DSC_SM_CTL0r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL0r_CLR
#define DSC_SM_CTL0r_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_SET
#define DSC_SM_CTL0r_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_GET
#define DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_SET_MEAS_INCOMPLETEf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_CONFIGf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_RESTARTf_SET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_GET
#define DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_ACK_DSC_EEE_DONEf_SET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_GET
#define DSC_SM_CTL0r_EEE_MEASURE_ENf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MEASURE_ENf_SET
#define DSC_SM_CTL0r_HW_TUNE_ENf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_GET
#define DSC_SM_CTL0r_HW_TUNE_ENf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_HW_TUNE_ENf_SET
#define DSC_SM_CTL0r_UC_TUNE_ENf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_GET
#define DSC_SM_CTL0r_UC_TUNE_ENf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_UC_TUNE_ENf_SET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_GET
#define DSC_SM_CTL0r_CL72_TIMER_ENf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_CL72_TIMER_ENf_SET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_GET
#define DSC_SM_CTL0r_IGNORE_RX_MODEf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_IGNORE_RX_MODEf_SET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_GET
#define DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_QUIET_RX_AFE_PWRDWN_VALf_SET
#define DSC_SM_CTL0r_EEE_MODE_ENf_GET BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_GET
#define DSC_SM_CTL0r_EEE_MODE_ENf_SET BCMI_FALCON_XGXS_DSC_SM_CTL0r_EEE_MODE_ENf_SET
#define READ_DSC_SM_CTL0r BCMI_FALCON_XGXS_READ_DSC_SM_CTL0r
#define WRITE_DSC_SM_CTL0r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL0r
#define MODIFY_DSC_SM_CTL0r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL0r
#define READLN_DSC_SM_CTL0r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL0r
#define WRITELN_DSC_SM_CTL0r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL0r
#define WRITEALL_DSC_SM_CTL0r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL1
 * BLOCKS:   DSC_D
 * REGADDR:  0xd061
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 1
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_DSC_LOCK_FRC  rx_dsc_lock force.
 *     RX_DSC_LOCK_FRC_VAL rx_dsc_lock force value.
 *     DSC_CLR_FRC      DSC clear force.
 *     DSC_CLR_FRC_VAL  DSC clear force value.
 *     TRNSUM_FRZ_FRC   Training Sum freeze force.
 *     TRNSUM_FRZ_FRC_VAL raining Sum freeze force value.
 *     TIMER_DONE_FRC   Can be forced to 1'b1 which will disable the H/W timer in HW_TUNE and MEASURE states.
 *     TIMER_DONE_FRC_VAL If timer_done_frc is set to 1'b1 and DSC SM is in HW_TUNE or MEASURE states then setting this bit to 1 will move the state to next state.
 *     FREQ_UPD_EN_FRC  Frequency update force.
 *     FREQ_UPD_EN_FRC_VAL Frequency update force value.
 *     CDR_FRZ_FRC      CDR Freeze force.
 *     CDR_FRZ_FRC_VAL  CDR Freeze force value.
 *     TRNSUM_CLR_FRC   Training Sum freeze force.
 *     TRNSUM_CLR_FRC_VAL raining Sum freeze force value.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r (0x0001d061 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL1.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL1r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl1[1];
	uint32_t _dsc_sm_ctl1;
} BCMI_FALCON_XGXS_DSC_SM_CTL1r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_CLR(r) (r).dsc_sm_ctl1[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_SET(r,d) (r).dsc_sm_ctl1[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_GET(r) (r).dsc_sm_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET(r) ((((r).dsc_sm_ctl1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET(r) (((r).dsc_sm_ctl1[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET(r,f) (r).dsc_sm_ctl1[0]=(((r).dsc_sm_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL1r,(_r._dsc_sm_ctl1))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL1r BCMI_FALCON_XGXS_DSC_SM_CTL1r
#define DSC_SM_CTL1r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL1r_t DSC_SM_CTL1r_t;
#define DSC_SM_CTL1r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL1r_CLR
#define DSC_SM_CTL1r_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_SET
#define DSC_SM_CTL1r_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_CLR_FRCf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_GET
#define DSC_SM_CTL1r_CDR_FRZ_FRCf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_CDR_FRZ_FRCf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRC_VALf_SET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_GET
#define DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_FREQ_UPD_EN_FRCf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRC_VALf_SET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_GET
#define DSC_SM_CTL1r_TIMER_DONE_FRCf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TIMER_DONE_FRCf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRC_VALf_SET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_GET
#define DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_TRNSUM_FRZ_FRCf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRC_VALf_SET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_GET
#define DSC_SM_CTL1r_DSC_CLR_FRCf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_DSC_CLR_FRCf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRC_VALf_SET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_GET
#define DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET BCMI_FALCON_XGXS_DSC_SM_CTL1r_RX_DSC_LOCK_FRCf_SET
#define READ_DSC_SM_CTL1r BCMI_FALCON_XGXS_READ_DSC_SM_CTL1r
#define WRITE_DSC_SM_CTL1r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL1r
#define MODIFY_DSC_SM_CTL1r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL1r
#define READLN_DSC_SM_CTL1r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL1r
#define WRITELN_DSC_SM_CTL1r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL1r
#define WRITEALL_DSC_SM_CTL1r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL2
 * BLOCKS:   DSC_D
 * REGADDR:  0xd062
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 2
 * RESETVAL: 0x87 (135)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_LFSR_CNT     LFSR timer start value for all EEE timers except EEE_MEASURE.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL2r (0x0001d062 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL2.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL2r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl2[1];
	uint32_t _dsc_sm_ctl2;
} BCMI_FALCON_XGXS_DSC_SM_CTL2r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL2r_CLR(r) (r).dsc_sm_ctl2[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL2r_SET(r,d) (r).dsc_sm_ctl2[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL2r_GET(r) (r).dsc_sm_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl2[0]) & 0x1fff)
#define BCMI_FALCON_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl2[0]=(((r).dsc_sm_ctl2[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL2r,(_r._dsc_sm_ctl2))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL2r BCMI_FALCON_XGXS_DSC_SM_CTL2r
#define DSC_SM_CTL2r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL2r_t DSC_SM_CTL2r_t;
#define DSC_SM_CTL2r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL2r_CLR
#define DSC_SM_CTL2r_SET BCMI_FALCON_XGXS_DSC_SM_CTL2r_SET
#define DSC_SM_CTL2r_GET BCMI_FALCON_XGXS_DSC_SM_CTL2r_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_GET
#define DSC_SM_CTL2r_EEE_LFSR_CNTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL2r_EEE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL2r BCMI_FALCON_XGXS_READ_DSC_SM_CTL2r
#define WRITE_DSC_SM_CTL2r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL2r
#define MODIFY_DSC_SM_CTL2r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL2r
#define READLN_DSC_SM_CTL2r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL2r
#define WRITELN_DSC_SM_CTL2r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL2r
#define WRITEALL_DSC_SM_CTL2r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL3
 * BLOCKS:   DSC_D
 * REGADDR:  0xd063
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 3
 * RESETVAL: 0x1c1e (7198)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_LFSR_CNT LFSR timer start value for MEASURE and EEE_MEASURE state timers.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL3r (0x0001d063 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL3.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL3r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl3[1];
	uint32_t _dsc_sm_ctl3;
} BCMI_FALCON_XGXS_DSC_SM_CTL3r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL3r_CLR(r) (r).dsc_sm_ctl3[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL3r_SET(r,d) (r).dsc_sm_ctl3[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL3r_GET(r) (r).dsc_sm_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET(r) (((r).dsc_sm_ctl3[0]) & 0x1fff)
#define BCMI_FALCON_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET(r,f) (r).dsc_sm_ctl3[0]=(((r).dsc_sm_ctl3[0] & ~((uint32_t)0x1fff)) | (((uint32_t)f) & 0x1fff)) | (0x1fff << 16)

/*
 * These macros can be used to access DSC_SM_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL3r,(_r._dsc_sm_ctl3))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL3r BCMI_FALCON_XGXS_DSC_SM_CTL3r
#define DSC_SM_CTL3r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL3r_t DSC_SM_CTL3r_t;
#define DSC_SM_CTL3r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL3r_CLR
#define DSC_SM_CTL3r_SET BCMI_FALCON_XGXS_DSC_SM_CTL3r_SET
#define DSC_SM_CTL3r_GET BCMI_FALCON_XGXS_DSC_SM_CTL3r_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_GET
#define DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL3r_MEASURE_LFSR_CNTf_SET
#define READ_DSC_SM_CTL3r BCMI_FALCON_XGXS_READ_DSC_SM_CTL3r
#define WRITE_DSC_SM_CTL3r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL3r
#define MODIFY_DSC_SM_CTL3r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL3r
#define READLN_DSC_SM_CTL3r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL3r
#define WRITELN_DSC_SM_CTL3r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL3r
#define WRITEALL_DSC_SM_CTL3r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL4
 * BLOCKS:   DSC_D
 * REGADDR:  0xd064
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     ACQ_CDR_TIMEOUT  Defines timeout value for the ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     CDR_SETTLE_TIMEOUT Defines timeout value for the CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     HW_TUNE_TIMEOUT  Defines timeout value for the HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r (0x0001d064 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL4.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL4r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl4[1];
	uint32_t _dsc_sm_ctl4;
} BCMI_FALCON_XGXS_DSC_SM_CTL4r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_CLR(r) (r).dsc_sm_ctl4[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_SET(r,d) (r).dsc_sm_ctl4[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_GET(r) (r).dsc_sm_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 10) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl4[0]) >> 5) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET(r) (((r).dsc_sm_ctl4[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl4[0]=(((r).dsc_sm_ctl4[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL4.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL4r,(_r._dsc_sm_ctl4))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl4))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL4r BCMI_FALCON_XGXS_DSC_SM_CTL4r
#define DSC_SM_CTL4r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL4r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL4r_t DSC_SM_CTL4r_t;
#define DSC_SM_CTL4r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL4r_CLR
#define DSC_SM_CTL4r_SET BCMI_FALCON_XGXS_DSC_SM_CTL4r_SET
#define DSC_SM_CTL4r_GET BCMI_FALCON_XGXS_DSC_SM_CTL4r_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL4r_HW_TUNE_TIMEOUTf_SET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL4r_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL4r_ACQ_CDR_TIMEOUTf_SET
#define READ_DSC_SM_CTL4r BCMI_FALCON_XGXS_READ_DSC_SM_CTL4r
#define WRITE_DSC_SM_CTL4r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL4r
#define MODIFY_DSC_SM_CTL4r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL4r
#define READLN_DSC_SM_CTL4r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL4r
#define WRITELN_DSC_SM_CTL4r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL4r
#define WRITEALL_DSC_SM_CTL4r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL5
 * BLOCKS:   DSC_D
 * REGADDR:  0xd065
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 5
 * RESETVAL: 0x35ad (13741)
 * ACCESS:   R/W
 * FIELDS:
 *     MEASURE_TIMEOUT  Defines timeout value for the MEASURE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ACQ_CDR_TIMEOUT Defines timeout value for the EEE_ACQ_CDR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_CDR_SETTLE_TIMEOUT Defines timeout value for the EEE_CDR_SETTLE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r (0x0001d065 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL5.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL5r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl5[1];
	uint32_t _dsc_sm_ctl5;
} BCMI_FALCON_XGXS_DSC_SM_CTL5r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_CLR(r) (r).dsc_sm_ctl5[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_SET(r,d) (r).dsc_sm_ctl5[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_GET(r) (r).dsc_sm_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 10) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl5[0]) >> 5) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl5[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl5[0]=(((r).dsc_sm_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL5.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL5r,(_r._dsc_sm_ctl5))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl5))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL5r BCMI_FALCON_XGXS_DSC_SM_CTL5r
#define DSC_SM_CTL5r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL5r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL5r_t DSC_SM_CTL5r_t;
#define DSC_SM_CTL5r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL5r_CLR
#define DSC_SM_CTL5r_SET BCMI_FALCON_XGXS_DSC_SM_CTL5r_SET
#define DSC_SM_CTL5r_GET BCMI_FALCON_XGXS_DSC_SM_CTL5r_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_CDR_SETTLE_TIMEOUTf_SET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_GET
#define DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL5r_EEE_ACQ_CDR_TIMEOUTf_SET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_GET
#define DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL5r_MEASURE_TIMEOUTf_SET
#define READ_DSC_SM_CTL5r BCMI_FALCON_XGXS_READ_DSC_SM_CTL5r
#define WRITE_DSC_SM_CTL5r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL5r
#define MODIFY_DSC_SM_CTL5r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL5r
#define READLN_DSC_SM_CTL5r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL5r
#define WRITELN_DSC_SM_CTL5r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL5r
#define WRITEALL_DSC_SM_CTL5r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL6
 * BLOCKS:   DSC_D
 * REGADDR:  0xd066
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 6
 * RESETVAL: 0x340d (13325)
 * ACCESS:   R/W
 * FIELDS:
 *     EEE_HW_TUNE_TIMEOUT Defines timeout value for the EEE_HW_TUNE state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 *     EEE_ANA_PWR_TIMEOUT Defines timeout value for the EEE_ANA_PWR state timer.  Valid range is 0 to 31 which is mapped to 0 to 448 LFSR wraps.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL6r (0x0001d066 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL6.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL6r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl6[1];
	uint32_t _dsc_sm_ctl6;
} BCMI_FALCON_XGXS_DSC_SM_CTL6r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_CLR(r) (r).dsc_sm_ctl6[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_SET(r,d) (r).dsc_sm_ctl6[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_GET(r) (r).dsc_sm_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET(r) ((((r).dsc_sm_ctl6[0]) >> 10) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET(r) (((r).dsc_sm_ctl6[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET(r,f) (r).dsc_sm_ctl6[0]=(((r).dsc_sm_ctl6[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DSC_SM_CTL6.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL6r,(_r._dsc_sm_ctl6))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl6))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL6r BCMI_FALCON_XGXS_DSC_SM_CTL6r
#define DSC_SM_CTL6r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL6r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL6r_t DSC_SM_CTL6r_t;
#define DSC_SM_CTL6r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL6r_CLR
#define DSC_SM_CTL6r_SET BCMI_FALCON_XGXS_DSC_SM_CTL6r_SET
#define DSC_SM_CTL6r_GET BCMI_FALCON_XGXS_DSC_SM_CTL6r_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_ANA_PWR_TIMEOUTf_SET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_GET
#define DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET BCMI_FALCON_XGXS_DSC_SM_CTL6r_EEE_HW_TUNE_TIMEOUTf_SET
#define READ_DSC_SM_CTL6r BCMI_FALCON_XGXS_READ_DSC_SM_CTL6r
#define WRITE_DSC_SM_CTL6r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL6r
#define MODIFY_DSC_SM_CTL6r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL6r
#define READLN_DSC_SM_CTL6r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL6r
#define WRITELN_DSC_SM_CTL6r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL6r
#define WRITEALL_DSC_SM_CTL6r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL7
 * BLOCKS:   DSC_D
 * REGADDR:  0xd067
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CDR_BWSEL_INTEG_ACQCDR CDR Integ Bandwidth select for ACQ_CDR state.
 *     CDR_BWSEL_INTEG_EEE_ACQCDR CDR Integ Bandwidth select for EEE_ACQ_CDR state.
 *     CDR_BWSEL_INTEG_NORM CDR Integ Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.
 *     CDR_BWSEL_PROP_ACQCDR CDR Proportional Bandwidth select for ACQ_CDR state.TODO: update desription as per Falcon tcore: {0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 *     CDR_BWSEL_PROP_NORM CDR Proportional Bandwidth select for non ACQ_CDR and EEE_ACQ_CDR states.TODO: update desription as per Falcon tcore: {0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r (0x0001d067 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL7.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL7r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl7[1];
	uint32_t _dsc_sm_ctl7;
} BCMI_FALCON_XGXS_DSC_SM_CTL7r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CLR(r) (r).dsc_sm_ctl7[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_SET(r,d) (r).dsc_sm_ctl7[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_GET(r) (r).dsc_sm_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl7[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET(r) (((r).dsc_sm_ctl7[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET(r,f) (r).dsc_sm_ctl7[0]=(((r).dsc_sm_ctl7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL7.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL7r,(_r._dsc_sm_ctl7))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl7))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL7r BCMI_FALCON_XGXS_DSC_SM_CTL7r
#define DSC_SM_CTL7r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL7r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL7r_t DSC_SM_CTL7r_t;
#define DSC_SM_CTL7r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL7r_CLR
#define DSC_SM_CTL7r_SET BCMI_FALCON_XGXS_DSC_SM_CTL7r_SET
#define DSC_SM_CTL7r_GET BCMI_FALCON_XGXS_DSC_SM_CTL7r_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_PROP_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_NORMf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_EEE_ACQCDRf_SET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_GET
#define DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET BCMI_FALCON_XGXS_DSC_SM_CTL7r_CDR_BWSEL_INTEG_ACQCDRf_SET
#define READ_DSC_SM_CTL7r BCMI_FALCON_XGXS_READ_DSC_SM_CTL7r
#define WRITE_DSC_SM_CTL7r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL7r
#define MODIFY_DSC_SM_CTL7r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL7r
#define READLN_DSC_SM_CTL7r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL7r
#define WRITELN_DSC_SM_CTL7r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL7r
#define WRITEALL_DSC_SM_CTL7r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL8
 * BLOCKS:   DSC_D
 * REGADDR:  0xd068
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 8
 * RESETVAL: 0x11 (17)
 * ACCESS:   R/W
 * FIELDS:
 *     PHASE_ERR_OFFSET Phase Error Offset for non-EEE_ACQ_CDR states. Signed value. Valid range is -8 to 7. This translates to either -8/2 to 7/2 or -8/4 to 7/4, depending on how rg_phase_err_offset_mult_2 is set. By default is is -8/4 to 7/4 adding into VCO reg.
 *     EEE_PHASE_ERR_OFFSET Phase Error Offset for EEE_ACQ_CDR state. Signed value. Valid range is -8 to 7.
 *     PHASE_ERR_OFFSET_EN Phase Error Offset Enable for non-EEE_ACQ_CDR states.
 *     EEE_PHASE_ERR_OFFSET_EN Phase Error Offset Enable for EEE_ACQ_CDR state.
 *     CDR_BWSEL_PROP_EEE_ACQCDR CDR Proportional Bandwidth select for EEE_ACQ_CDR state.{0, 1, 2} map to {2^1, 2^2, 2^0}2^2 has a user beware attached to it. Use is when max number of edges per rclk20 * osx2p_pherr_gain are guaranteed to be < 15
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r (0x0001d068 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL8.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL8r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl8[1];
	uint32_t _dsc_sm_ctl8;
} BCMI_FALCON_XGXS_DSC_SM_CTL8r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_CLR(r) (r).dsc_sm_ctl8[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_SET(r,d) (r).dsc_sm_ctl8[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_GET(r) (r).dsc_sm_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 10) & 0x3)
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET(r) ((((r).dsc_sm_ctl8[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET(r) (((r).dsc_sm_ctl8[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET(r,f) (r).dsc_sm_ctl8[0]=(((r).dsc_sm_ctl8[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_CTL8.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL8r,(_r._dsc_sm_ctl8))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl8))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL8r BCMI_FALCON_XGXS_DSC_SM_CTL8r
#define DSC_SM_CTL8r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL8r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL8r_t DSC_SM_CTL8r_t;
#define DSC_SM_CTL8r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL8r_CLR
#define DSC_SM_CTL8r_SET BCMI_FALCON_XGXS_DSC_SM_CTL8r_SET
#define DSC_SM_CTL8r_GET BCMI_FALCON_XGXS_DSC_SM_CTL8r_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET BCMI_FALCON_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_GET
#define DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET BCMI_FALCON_XGXS_DSC_SM_CTL8r_CDR_BWSEL_PROP_EEE_ACQCDRf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSET_ENf_SET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET BCMI_FALCON_XGXS_DSC_SM_CTL8r_EEE_PHASE_ERR_OFFSETf_SET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_GET
#define DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET BCMI_FALCON_XGXS_DSC_SM_CTL8r_PHASE_ERR_OFFSETf_SET
#define READ_DSC_SM_CTL8r BCMI_FALCON_XGXS_READ_DSC_SM_CTL8r
#define WRITE_DSC_SM_CTL8r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL8r
#define MODIFY_DSC_SM_CTL8r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL8r
#define READLN_DSC_SM_CTL8r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL8r
#define WRITELN_DSC_SM_CTL8r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL8r
#define WRITEALL_DSC_SM_CTL8r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_CTL9
 * BLOCKS:   DSC_D
 * REGADDR:  0xd069
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE CONTROL 9
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_RESTART_PMD   1'b1 will reset the DSC SM into RESTART state. This is a self-clear register bit.
 *     RX_RESTART_PMD_HOLD 1'b1 will reset the DSC SM into RESTART state and HOLD it there until set to 1'b0.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL9r (0x0001d069 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_CTL9.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_CTL9r_s {
	uint32_t v[1];
	uint32_t dsc_sm_ctl9[1];
	uint32_t _dsc_sm_ctl9;
} BCMI_FALCON_XGXS_DSC_SM_CTL9r_t;

#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_CLR(r) (r).dsc_sm_ctl9[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_SET(r,d) (r).dsc_sm_ctl9[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_GET(r) (r).dsc_sm_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET(r) ((((r).dsc_sm_ctl9[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET(r) (((r).dsc_sm_ctl9[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET(r,f) (r).dsc_sm_ctl9[0]=(((r).dsc_sm_ctl9[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_CTL9.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL9r,(_r._dsc_sm_ctl9))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL9r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_ctl9))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_CTL9r BCMI_FALCON_XGXS_DSC_SM_CTL9r
#define DSC_SM_CTL9r_SIZE BCMI_FALCON_XGXS_DSC_SM_CTL9r_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_CTL9r_t DSC_SM_CTL9r_t;
#define DSC_SM_CTL9r_CLR BCMI_FALCON_XGXS_DSC_SM_CTL9r_CLR
#define DSC_SM_CTL9r_SET BCMI_FALCON_XGXS_DSC_SM_CTL9r_SET
#define DSC_SM_CTL9r_GET BCMI_FALCON_XGXS_DSC_SM_CTL9r_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMD_HOLDf_SET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_GET BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_GET
#define DSC_SM_CTL9r_RX_RESTART_PMDf_SET BCMI_FALCON_XGXS_DSC_SM_CTL9r_RX_RESTART_PMDf_SET
#define READ_DSC_SM_CTL9r BCMI_FALCON_XGXS_READ_DSC_SM_CTL9r
#define WRITE_DSC_SM_CTL9r BCMI_FALCON_XGXS_WRITE_DSC_SM_CTL9r
#define MODIFY_DSC_SM_CTL9r BCMI_FALCON_XGXS_MODIFY_DSC_SM_CTL9r
#define READLN_DSC_SM_CTL9r BCMI_FALCON_XGXS_READLN_DSC_SM_CTL9r
#define WRITELN_DSC_SM_CTL9r BCMI_FALCON_XGXS_WRITELN_DSC_SM_CTL9r
#define WRITEALL_DSC_SM_CTL9r BCMI_FALCON_XGXS_WRITEALL_DSC_SM_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_STS_DSC_LOCK
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06a
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE DSC_LOCK STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DSC_LOCK      1 indicates that DSC is locked.
 *     MEAS_INCOMPLETE  1 indicates that measurement is incomplete. 0 indicates that measurement is complete.
 *     EEE_MEASURE_CNT  Indicates the eee_measure_cnt status. This is a debug register.
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr (0x0001d06a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_LOCK.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_lock[1];
	uint32_t _dsc_sm_sts_dsc_lock;
} BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_t;

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_CLR(r) (r).dsc_sm_sts_dsc_lock[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_SET(r,d) (r).dsc_sm_sts_dsc_lock[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_GET(r) (r).dsc_sm_sts_dsc_lock[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 7) & 0x1ff)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1ff << 7)) | ((((uint32_t)f) & 0x1ff) << 7)) | (511 << (16 + 7))
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET(r) ((((r).dsc_sm_sts_dsc_lock[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET(r) (((r).dsc_sm_sts_dsc_lock[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET(r,f) (r).dsc_sm_sts_dsc_lock[0]=(((r).dsc_sm_sts_dsc_lock[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_LOCK.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr,(_r._dsc_sm_sts_dsc_lock))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_lock))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_lock))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_LOCKr BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr
#define DSC_SM_STS_DSC_LOCKr_SIZE BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_t DSC_SM_STS_DSC_LOCKr_t;
#define DSC_SM_STS_DSC_LOCKr_CLR BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_CLR
#define DSC_SM_STS_DSC_LOCKr_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_SET
#define DSC_SM_STS_DSC_LOCKr_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_GET
#define DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_EEE_MEASURE_CNTf_SET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_GET
#define DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_MEAS_INCOMPLETEf_SET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_GET
#define DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr_RX_DSC_LOCKf_SET
#define READ_DSC_SM_STS_DSC_LOCKr BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_LOCKr
#define WRITE_DSC_SM_STS_DSC_LOCKr BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_LOCKr
#define MODIFY_DSC_SM_STS_DSC_LOCKr BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_LOCKr
#define READLN_DSC_SM_STS_DSC_LOCKr BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_LOCKr
#define WRITELN_DSC_SM_STS_DSC_LOCKr BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_LOCKr
#define WRITEALL_DSC_SM_STS_DSC_LOCKr BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_LOCKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_STS_DSC_LOCKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_ONE_HOT
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06b
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_ONE_HOT Sticky one-hot coded states. These registers are cleared on read.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr (0x0001d06b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_ONE_HOT.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_one_hot;
} BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t;

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_one_hot[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_one_hot[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_one_hot[0]) & 0x3ff)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_one_hot[0]=(((r).dsc_sm_sts_dsc_st_one_hot[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_ONE_HOT.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_one_hot))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_one_hot))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_t DSC_SM_STS_DSC_ST_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_ONE_HOTr_CLR BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_ONE_HOTr_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr_DSC_STATE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_ST_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_ST_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_ST_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST_EEE_ONE_HOT
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06c
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS EEE ONE HOT
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_STATE_EEE_ONE_HOT Sticky one-hot coded EEE state . These registers are cleared on read.EEE_QUIET       =  0EEE_ANA_PWR     =  1EEE_ACQ_CDR     =  2EEE_CDR_SETTLE  =  3EEE_HW_TUNE     =  4EEE_MEASURE     =  5EEE_DONE        =  6
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr (0x0001d06c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st_eee_one_hot[1];
	uint32_t _dsc_sm_sts_dsc_st_eee_one_hot;
} BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET(r,d) (r).dsc_sm_sts_dsc_st_eee_one_hot[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET(r) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET(r) (((r).dsc_sm_sts_dsc_st_eee_one_hot[0]) & 0x7f)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET(r,f) (r).dsc_sm_sts_dsc_st_eee_one_hot[0]=(((r).dsc_sm_sts_dsc_st_eee_one_hot[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST_EEE_ONE_HOT.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr,(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st_eee_one_hot))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st_eee_one_hot))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_t;
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_CLR
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_SET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_GET
#define DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr_DSC_STATE_EEE_ONE_HOTf_SET
#define READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr
#define WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_STS_DSC_ST_EEE_ONE_HOTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_STS_RESTART
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06d
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS RESTART
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RESTART_PI_EXT_MODE Indicates when SM moves to RESTART state due to enabling of RX_PI external control (i.e. digital loopback enable). This is clear on read.
 *     RESTART_SIGDET   Indicates when SM moves to RESTART state due to sigdet==0 and eee_mode_en register is 1'b0. This is clear on read.
 *     RESTART_PMD_RESTART Indicates when SM moves to RESTART state due to assertion of pmd_restart to 1'b1. This is clear on read.
 *     EEE_QUIET_FROM_EEE_STATES Indicates when SM moves from any EEE states to EEE_QUIET state. This is clear on read.
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr (0x0001d06d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_RESTART.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_restart[1];
	uint32_t _dsc_sm_sts_restart;
} BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_t;

#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_CLR(r) (r).dsc_sm_sts_restart[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_SET(r,d) (r).dsc_sm_sts_restart[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_GET(r) (r).dsc_sm_sts_restart[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET(r) ((((r).dsc_sm_sts_restart[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET(r) (((r).dsc_sm_sts_restart[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET(r,f) (r).dsc_sm_sts_restart[0]=(((r).dsc_sm_sts_restart[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_SM_STS_RESTART.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr,(_r._dsc_sm_sts_restart))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_STS_RESTARTr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_RESTARTr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_restart))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_RESTARTr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_restart))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_RESTARTr BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr
#define DSC_SM_STS_RESTARTr_SIZE BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_t DSC_SM_STS_RESTARTr_t;
#define DSC_SM_STS_RESTARTr_CLR BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_CLR
#define DSC_SM_STS_RESTARTr_SET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_SET
#define DSC_SM_STS_RESTARTr_GET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_GET
#define DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_EEE_QUIET_FROM_EEE_STATESf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PMD_RESTARTf_SET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_GET
#define DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_SIGDETf_SET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_GET
#define DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr_RESTART_PI_EXT_MODEf_SET
#define READ_DSC_SM_STS_RESTARTr BCMI_FALCON_XGXS_READ_DSC_SM_STS_RESTARTr
#define WRITE_DSC_SM_STS_RESTARTr BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_RESTARTr
#define MODIFY_DSC_SM_STS_RESTARTr BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_RESTARTr
#define READLN_DSC_SM_STS_RESTARTr BCMI_FALCON_XGXS_READLN_DSC_SM_STS_RESTARTr
#define WRITELN_DSC_SM_STS_RESTARTr BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_RESTARTr
#define WRITEALL_DSC_SM_STS_RESTARTr BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_RESTARTr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_STS_RESTARTr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_SM_STS_DSC_ST
 * BLOCKS:   DSC_D
 * REGADDR:  0xd06e
 * DEVAD:    1
 * DESC:     DSC STATE MACHINE STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     DSC_SM_SCRATCH   4 LSB bits of dsc_scratch
 *     DSC_SM_READY_FOR_CMD Ready for Command.
 *     DSC_SM_GP_UC_REQ gp_uc_req.
 *     DSC_STATE        Live DSC SM state. Following are the state encodings.RESET           =  0RESTART         =  1CONFIG          =  2WAIT_FOR_SIG    =  3ACQ_CDR         =  4CDR_SETTLE      =  5HW_TUNE         =  6UC_TUNE         =  7MEASURE         =  8DONE            =  9EEE_QUIET       =  10EEE_ANA_PWR     =  11EEE_ACQ_CDR     =  12EEE_CDR_SETTLE  =  13EEE_HW_TUNE     =  14EEE_MEASURE     =  15EEE_DONE        =  16
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr (0x0001d06e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_SIZE 4

/*
 * This structure should be used to declare and program DSC_SM_STS_DSC_ST.
 */
typedef union BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_s {
	uint32_t v[1];
	uint32_t dsc_sm_sts_dsc_st[1];
	uint32_t _dsc_sm_sts_dsc_st;
} BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_t;

#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_CLR(r) (r).dsc_sm_sts_dsc_st[0] = 0
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_SET(r,d) (r).dsc_sm_sts_dsc_st[0] = d
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_GET(r) (r).dsc_sm_sts_dsc_st[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 11) & 0x1f)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 5) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x3f << 5)) | ((((uint32_t)f) & 0x3f) << 5)) | (63 << (16 + 5))
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET(r) ((((r).dsc_sm_sts_dsc_st[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET(r) (((r).dsc_sm_sts_dsc_st[0]) & 0xf)
#define BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET(r,f) (r).dsc_sm_sts_dsc_st[0]=(((r).dsc_sm_sts_dsc_st[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DSC_SM_STS_DSC_ST.
 */
#define BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr,(_r._dsc_sm_sts_dsc_st))
#define BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_STr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_sm_sts_dsc_st))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_STr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_sm_sts_dsc_st))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_SM_STS_DSC_STr BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr
#define DSC_SM_STS_DSC_STr_SIZE BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_SIZE
typedef BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_t DSC_SM_STS_DSC_STr_t;
#define DSC_SM_STS_DSC_STr_CLR BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_CLR
#define DSC_SM_STS_DSC_STr_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_SET
#define DSC_SM_STS_DSC_STr_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_GET
#define DSC_SM_STS_DSC_STr_DSC_STATEf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_STATEf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_GP_UC_REQf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_READY_FOR_CMDf_SET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_GET
#define DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr_DSC_SM_SCRATCHf_SET
#define READ_DSC_SM_STS_DSC_STr BCMI_FALCON_XGXS_READ_DSC_SM_STS_DSC_STr
#define WRITE_DSC_SM_STS_DSC_STr BCMI_FALCON_XGXS_WRITE_DSC_SM_STS_DSC_STr
#define MODIFY_DSC_SM_STS_DSC_STr BCMI_FALCON_XGXS_MODIFY_DSC_SM_STS_DSC_STr
#define READLN_DSC_SM_STS_DSC_STr BCMI_FALCON_XGXS_READLN_DSC_SM_STS_DSC_STr
#define WRITELN_DSC_SM_STS_DSC_STr BCMI_FALCON_XGXS_WRITELN_DSC_SM_STS_DSC_STr
#define WRITEALL_DSC_SM_STS_DSC_STr BCMI_FALCON_XGXS_WRITEALL_DSC_SM_STS_DSC_STr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_SM_STS_DSC_STr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_PD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd070
 * DEVAD:    1
 * DESC:     rx_pi status register, both p and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PI_CNT_BIN_P_PD PI counter value for phase slicer
 *     RX_PI_CNT_BIN_D_PD PI counter value for phase quadrature slicer
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr (0x0001d070 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_PD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_pd[1];
	uint32_t _dsc_rx_pi_cnt_bin_pd;
} BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_CLR(r) (r).dsc_rx_pi_cnt_bin_pd[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_pd[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_GET(r) (r).dsc_rx_pi_cnt_bin_pd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_D_PDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_pd[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_D_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_P_PDf_GET(r) (((r).dsc_rx_pi_cnt_bin_pd[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_P_PDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_pd[0]=(((r).dsc_rx_pi_cnt_bin_pd[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_PD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr,(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_PDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_PDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_pd))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_PDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_pd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_PDr BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr
#define DSC_RX_PI_CNT_BIN_PDr_SIZE BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_t DSC_RX_PI_CNT_BIN_PDr_t;
#define DSC_RX_PI_CNT_BIN_PDr_CLR BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_CLR
#define DSC_RX_PI_CNT_BIN_PDr_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_SET
#define DSC_RX_PI_CNT_BIN_PDr_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_GET
#define DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_D_PDf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_D_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_D_PDf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_D_PDf_SET
#define DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_P_PDf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_P_PDf_GET
#define DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_P_PDf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr_RX_PI_CNT_BIN_P_PDf_SET
#define READ_DSC_RX_PI_CNT_BIN_PDr BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_PDr
#define WRITE_DSC_RX_PI_CNT_BIN_PDr BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_PDr
#define MODIFY_DSC_RX_PI_CNT_BIN_PDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_PDr
#define READLN_DSC_RX_PI_CNT_BIN_PDr BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_PDr
#define WRITELN_DSC_RX_PI_CNT_BIN_PDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_PDr
#define WRITEALL_DSC_RX_PI_CNT_BIN_PDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_PDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_PDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_LD
 * BLOCKS:   DSC_E
 * REGADDR:  0xd071
 * DEVAD:    1
 * DESC:     rx_pi status register, both l and d.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PI_CNT_BIN_L_LD PI counter value for LMS slicer
 *     RX_PI_CNT_BIN_D_LD PI counter value for LMS quadrature slicer
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr (0x0001d071 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_LD.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_ld[1];
	uint32_t _dsc_rx_pi_cnt_bin_ld;
} BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_CLR(r) (r).dsc_rx_pi_cnt_bin_ld[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_SET(r,d) (r).dsc_rx_pi_cnt_bin_ld[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_GET(r) (r).dsc_rx_pi_cnt_bin_ld[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_D_LDf_GET(r) ((((r).dsc_rx_pi_cnt_bin_ld[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_D_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_L_LDf_GET(r) (((r).dsc_rx_pi_cnt_bin_ld[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_L_LDf_SET(r,f) (r).dsc_rx_pi_cnt_bin_ld[0]=(((r).dsc_rx_pi_cnt_bin_ld[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_LD.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr,(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_LDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_LDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_ld))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_LDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_ld))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_LDr BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr
#define DSC_RX_PI_CNT_BIN_LDr_SIZE BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_t DSC_RX_PI_CNT_BIN_LDr_t;
#define DSC_RX_PI_CNT_BIN_LDr_CLR BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_CLR
#define DSC_RX_PI_CNT_BIN_LDr_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_SET
#define DSC_RX_PI_CNT_BIN_LDr_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_GET
#define DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_D_LDf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_D_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_D_LDf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_D_LDf_SET
#define DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_L_LDf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_L_LDf_GET
#define DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_L_LDf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr_RX_PI_CNT_BIN_L_LDf_SET
#define READ_DSC_RX_PI_CNT_BIN_LDr BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_LDr
#define WRITE_DSC_RX_PI_CNT_BIN_LDr BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_LDr
#define MODIFY_DSC_RX_PI_CNT_BIN_LDr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_LDr
#define READLN_DSC_RX_PI_CNT_BIN_LDr BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_LDr
#define WRITELN_DSC_RX_PI_CNT_BIN_LDr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_LDr
#define WRITEALL_DSC_RX_PI_CNT_BIN_LDr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_LDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_LDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DATA_15_TO0
 * BLOCKS:   DSC_E
 * REGADDR:  0xd072
 * DEVAD:    1
 * DESC:     rx data bits 15 to 0.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_15_TO_0  Rx data is 40 bit wide in rclk40 domain. These are bits 15 to 0.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r (0x0001d072 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DATA_15_TO0.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_s {
	uint32_t v[1];
	uint32_t dsc_rx_data_15_to0[1];
	uint32_t _dsc_rx_data_15_to0;
} BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_t;

#define BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_CLR(r) (r).dsc_rx_data_15_to0[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_SET(r,d) (r).dsc_rx_data_15_to0[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_GET(r) (r).dsc_rx_data_15_to0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET(r) (((r).dsc_rx_data_15_to0[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET(r,f) (r).dsc_rx_data_15_to0[0]=(((r).dsc_rx_data_15_to0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_RX_DATA_15_TO0.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r,(_r._dsc_rx_data_15_to0))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r,(_r._dsc_rx_data_15_to0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r,(_r._dsc_rx_data_15_to0))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DATA_15_TO0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_15_to0))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DATA_15_TO0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_15_to0))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DATA_15_TO0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_data_15_to0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DATA_15_TO0r BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r
#define DSC_RX_DATA_15_TO0r_SIZE BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_t DSC_RX_DATA_15_TO0r_t;
#define DSC_RX_DATA_15_TO0r_CLR BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_CLR
#define DSC_RX_DATA_15_TO0r_SET BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_SET
#define DSC_RX_DATA_15_TO0r_GET BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_GET
#define DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_GET
#define DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r_RX_DATA_15_TO_0f_SET
#define READ_DSC_RX_DATA_15_TO0r BCMI_FALCON_XGXS_READ_DSC_RX_DATA_15_TO0r
#define WRITE_DSC_RX_DATA_15_TO0r BCMI_FALCON_XGXS_WRITE_DSC_RX_DATA_15_TO0r
#define MODIFY_DSC_RX_DATA_15_TO0r BCMI_FALCON_XGXS_MODIFY_DSC_RX_DATA_15_TO0r
#define READLN_DSC_RX_DATA_15_TO0r BCMI_FALCON_XGXS_READLN_DSC_RX_DATA_15_TO0r
#define WRITELN_DSC_RX_DATA_15_TO0r BCMI_FALCON_XGXS_WRITELN_DSC_RX_DATA_15_TO0r
#define WRITEALL_DSC_RX_DATA_15_TO0r BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DATA_15_TO0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DATA_15_TO0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_DATA_35_TO_20
 * BLOCKS:   DSC_E
 * REGADDR:  0xd073
 * DEVAD:    1
 * DESC:     rx data bits 35 to 20.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_DATA_35_TO_20 Rx data is 40 bit wide in rclk40 domain. These are bits 35 to 20.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r (0x0001d073 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_DATA_35_TO_20.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_s {
	uint32_t v[1];
	uint32_t dsc_rx_data_35_to_20[1];
	uint32_t _dsc_rx_data_35_to_20;
} BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_t;

#define BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_CLR(r) (r).dsc_rx_data_35_to_20[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_SET(r,d) (r).dsc_rx_data_35_to_20[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_GET(r) (r).dsc_rx_data_35_to_20[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET(r) (((r).dsc_rx_data_35_to_20[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET(r,f) (r).dsc_rx_data_35_to_20[0]=(((r).dsc_rx_data_35_to_20[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_RX_DATA_35_TO_20.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r,(_r._dsc_rx_data_35_to_20))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r,(_r._dsc_rx_data_35_to_20)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r,(_r._dsc_rx_data_35_to_20))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_DATA_35_TO_20r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_35_to_20))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_DATA_35_TO_20r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_data_35_to_20))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DATA_35_TO_20r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_data_35_to_20))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_DATA_35_TO_20r BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r
#define DSC_RX_DATA_35_TO_20r_SIZE BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_t DSC_RX_DATA_35_TO_20r_t;
#define DSC_RX_DATA_35_TO_20r_CLR BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_CLR
#define DSC_RX_DATA_35_TO_20r_SET BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_SET
#define DSC_RX_DATA_35_TO_20r_GET BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_GET
#define DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_GET
#define DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r_RX_DATA_35_TO_20f_SET
#define READ_DSC_RX_DATA_35_TO_20r BCMI_FALCON_XGXS_READ_DSC_RX_DATA_35_TO_20r
#define WRITE_DSC_RX_DATA_35_TO_20r BCMI_FALCON_XGXS_WRITE_DSC_RX_DATA_35_TO_20r
#define MODIFY_DSC_RX_DATA_35_TO_20r BCMI_FALCON_XGXS_MODIFY_DSC_RX_DATA_35_TO_20r
#define READLN_DSC_RX_DATA_35_TO_20r BCMI_FALCON_XGXS_READLN_DSC_RX_DATA_35_TO_20r
#define WRITELN_DSC_RX_DATA_35_TO_20r BCMI_FALCON_XGXS_WRITELN_DSC_RX_DATA_35_TO_20r
#define WRITEALL_DSC_RX_DATA_35_TO_20r BCMI_FALCON_XGXS_WRITEALL_DSC_RX_DATA_35_TO_20r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_DATA_35_TO_20r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_CDR_STS_PHASE_ERR
 * BLOCKS:   DSC_E
 * REGADDR:  0xd074
 * DEVAD:    1
 * DESC:     cdr status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_PHASE_ERROR  shadowed version of phase error value
 *     CDR_VCO_REG      shadowed version of cdr_vco_reg[3:0]
 */
#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr (0x0001d074 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_PHASE_ERR.
 */
typedef union BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_phase_err[1];
	uint32_t _dsc_cdr_sts_phase_err;
} BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_t;

#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR(r) (r).dsc_cdr_sts_phase_err[0] = 0
#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_SET(r,d) (r).dsc_cdr_sts_phase_err[0] = d
#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_GET(r) (r).dsc_cdr_sts_phase_err[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET(r) ((((r).dsc_cdr_sts_phase_err[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET(r) (((r).dsc_cdr_sts_phase_err[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET(r,f) (r).dsc_cdr_sts_phase_err[0]=(((r).dsc_cdr_sts_phase_err[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DSC_CDR_STS_PHASE_ERR.
 */
#define BCMI_FALCON_XGXS_READ_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_FALCON_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr,(_r._dsc_cdr_sts_phase_err))
#define BCMI_FALCON_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_FALCON_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_phase_err))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_phase_err))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_PHASE_ERRr BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr
#define DSC_CDR_STS_PHASE_ERRr_SIZE BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_SIZE
typedef BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_t DSC_CDR_STS_PHASE_ERRr_t;
#define DSC_CDR_STS_PHASE_ERRr_CLR BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CLR
#define DSC_CDR_STS_PHASE_ERRr_SET BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_SET
#define DSC_CDR_STS_PHASE_ERRr_GET BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_VCO_REGf_SET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_GET
#define DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr_CDR_PHASE_ERRORf_SET
#define READ_DSC_CDR_STS_PHASE_ERRr BCMI_FALCON_XGXS_READ_DSC_CDR_STS_PHASE_ERRr
#define WRITE_DSC_CDR_STS_PHASE_ERRr BCMI_FALCON_XGXS_WRITE_DSC_CDR_STS_PHASE_ERRr
#define MODIFY_DSC_CDR_STS_PHASE_ERRr BCMI_FALCON_XGXS_MODIFY_DSC_CDR_STS_PHASE_ERRr
#define READLN_DSC_CDR_STS_PHASE_ERRr BCMI_FALCON_XGXS_READLN_DSC_CDR_STS_PHASE_ERRr
#define WRITELN_DSC_CDR_STS_PHASE_ERRr BCMI_FALCON_XGXS_WRITELN_DSC_CDR_STS_PHASE_ERRr
#define WRITEALL_DSC_CDR_STS_PHASE_ERRr BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_STS_PHASE_ERRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_CDR_STS_PHASE_ERRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_D
 * BLOCKS:   DSC_E
 * REGADDR:  0xd075
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PI_CNT_BIN_D  PI counter value for data slicer
 *     RX_PI_CNT_BIN_DQ PI counter value for data quadrature slicer
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr (0x0001d075 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_D.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_d[1];
	uint32_t _dsc_rx_pi_cnt_bin_d;
} BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR(r) (r).dsc_rx_pi_cnt_bin_d[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET(r,d) (r).dsc_rx_pi_cnt_bin_d[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET(r) (r).dsc_rx_pi_cnt_bin_d[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_DQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_d[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_DQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_Df_GET(r) (((r).dsc_rx_pi_cnt_bin_d[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_Df_SET(r,f) (r).dsc_rx_pi_cnt_bin_d[0]=(((r).dsc_rx_pi_cnt_bin_d[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_D.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr,(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_d))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_d))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Dr BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr
#define DSC_RX_PI_CNT_BIN_Dr_SIZE BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_t DSC_RX_PI_CNT_BIN_Dr_t;
#define DSC_RX_PI_CNT_BIN_Dr_CLR BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_CLR
#define DSC_RX_PI_CNT_BIN_Dr_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_SET
#define DSC_RX_PI_CNT_BIN_Dr_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_GET
#define DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_DQf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_DQf_GET
#define DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_DQf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_DQf_SET
#define DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_Df_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_Df_GET
#define DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_Df_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr_RX_PI_CNT_BIN_Df_SET
#define READ_DSC_RX_PI_CNT_BIN_Dr BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_Dr
#define WRITE_DSC_RX_PI_CNT_BIN_Dr BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Dr
#define MODIFY_DSC_RX_PI_CNT_BIN_Dr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Dr
#define READLN_DSC_RX_PI_CNT_BIN_Dr BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_Dr
#define WRITELN_DSC_RX_PI_CNT_BIN_Dr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Dr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Dr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Dr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Dr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_P
 * BLOCKS:   DSC_E
 * REGADDR:  0xd076
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PI_CNT_BIN_P  PI counter value for phase slicer
 *     RX_PI_CNT_BIN_PQ PI counter value for phase quadrature slicer
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr (0x0001d076 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_P.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_p[1];
	uint32_t _dsc_rx_pi_cnt_bin_p;
} BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR(r) (r).dsc_rx_pi_cnt_bin_p[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET(r,d) (r).dsc_rx_pi_cnt_bin_p[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET(r) (r).dsc_rx_pi_cnt_bin_p[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_PQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_p[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_PQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_Pf_GET(r) (((r).dsc_rx_pi_cnt_bin_p[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_Pf_SET(r,f) (r).dsc_rx_pi_cnt_bin_p[0]=(((r).dsc_rx_pi_cnt_bin_p[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_P.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr,(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_p))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_p))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Pr BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr
#define DSC_RX_PI_CNT_BIN_Pr_SIZE BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_t DSC_RX_PI_CNT_BIN_Pr_t;
#define DSC_RX_PI_CNT_BIN_Pr_CLR BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_CLR
#define DSC_RX_PI_CNT_BIN_Pr_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_SET
#define DSC_RX_PI_CNT_BIN_Pr_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_GET
#define DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_PQf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_PQf_GET
#define DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_PQf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_PQf_SET
#define DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_Pf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_Pf_GET
#define DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_Pf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr_RX_PI_CNT_BIN_Pf_SET
#define READ_DSC_RX_PI_CNT_BIN_Pr BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_Pr
#define WRITE_DSC_RX_PI_CNT_BIN_Pr BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Pr
#define MODIFY_DSC_RX_PI_CNT_BIN_Pr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Pr
#define READLN_DSC_RX_PI_CNT_BIN_Pr BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_Pr
#define WRITELN_DSC_RX_PI_CNT_BIN_Pr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Pr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Pr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Pr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Pr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_RX_PI_CNT_BIN_L
 * BLOCKS:   DSC_E
 * REGADDR:  0xd077
 * DEVAD:    1
 * DESC:     rx_pi status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     RX_PI_CNT_BIN_L  PI counter value for LMS slicer
 *     RX_PI_CNT_BIN_LQ PI counter value for LMS quadrature slicer
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr (0x0001d077 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_SIZE 4

/*
 * This structure should be used to declare and program DSC_RX_PI_CNT_BIN_L.
 */
typedef union BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_s {
	uint32_t v[1];
	uint32_t dsc_rx_pi_cnt_bin_l[1];
	uint32_t _dsc_rx_pi_cnt_bin_l;
} BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_t;

#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_CLR(r) (r).dsc_rx_pi_cnt_bin_l[0] = 0
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_SET(r,d) (r).dsc_rx_pi_cnt_bin_l[0] = d
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_GET(r) (r).dsc_rx_pi_cnt_bin_l[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_LQf_GET(r) ((((r).dsc_rx_pi_cnt_bin_l[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_LQf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_Lf_GET(r) (((r).dsc_rx_pi_cnt_bin_l[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_Lf_SET(r,f) (r).dsc_rx_pi_cnt_bin_l[0]=(((r).dsc_rx_pi_cnt_bin_l[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_RX_PI_CNT_BIN_L.
 */
#define BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr,(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_Lr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Lr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_rx_pi_cnt_bin_l))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Lr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_rx_pi_cnt_bin_l))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_RX_PI_CNT_BIN_Lr BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr
#define DSC_RX_PI_CNT_BIN_Lr_SIZE BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_SIZE
typedef BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_t DSC_RX_PI_CNT_BIN_Lr_t;
#define DSC_RX_PI_CNT_BIN_Lr_CLR BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_CLR
#define DSC_RX_PI_CNT_BIN_Lr_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_SET
#define DSC_RX_PI_CNT_BIN_Lr_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_GET
#define DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_LQf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_LQf_GET
#define DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_LQf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_LQf_SET
#define DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_Lf_GET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_Lf_GET
#define DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_Lf_SET BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr_RX_PI_CNT_BIN_Lf_SET
#define READ_DSC_RX_PI_CNT_BIN_Lr BCMI_FALCON_XGXS_READ_DSC_RX_PI_CNT_BIN_Lr
#define WRITE_DSC_RX_PI_CNT_BIN_Lr BCMI_FALCON_XGXS_WRITE_DSC_RX_PI_CNT_BIN_Lr
#define MODIFY_DSC_RX_PI_CNT_BIN_Lr BCMI_FALCON_XGXS_MODIFY_DSC_RX_PI_CNT_BIN_Lr
#define READLN_DSC_RX_PI_CNT_BIN_Lr BCMI_FALCON_XGXS_READLN_DSC_RX_PI_CNT_BIN_Lr
#define WRITELN_DSC_RX_PI_CNT_BIN_Lr BCMI_FALCON_XGXS_WRITELN_DSC_RX_PI_CNT_BIN_Lr
#define WRITEALL_DSC_RX_PI_CNT_BIN_Lr BCMI_FALCON_XGXS_WRITEALL_DSC_RX_PI_CNT_BIN_Lr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_RX_PI_CNT_BIN_Lr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_CDR_STS_INTEG
 * BLOCKS:   DSC_E
 * REGADDR:  0xd078
 * DEVAD:    1
 * DESC:     cdr status register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_INTEG_REG    shadowed version of integration Register value
 */
#define BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr (0x0001d078 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_INTEG.
 */
typedef union BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_integ[1];
	uint32_t _dsc_cdr_sts_integ;
} BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_t;

#define BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_CLR(r) (r).dsc_cdr_sts_integ[0] = 0
#define BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_SET(r,d) (r).dsc_cdr_sts_integ[0] = d
#define BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_GET(r) (r).dsc_cdr_sts_integ[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET(r) (((r).dsc_cdr_sts_integ[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET(r,f) (r).dsc_cdr_sts_integ[0]=(((r).dsc_cdr_sts_integ[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DSC_CDR_STS_INTEG.
 */
#define BCMI_FALCON_XGXS_READ_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_FALCON_XGXS_WRITE_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr,(_r._dsc_cdr_sts_integ))
#define BCMI_FALCON_XGXS_READLN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_FALCON_XGXS_WRITELN_DSC_CDR_STS_INTEGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_integ))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_STS_INTEGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_integ))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_INTEGr BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr
#define DSC_CDR_STS_INTEGr_SIZE BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_SIZE
typedef BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_t DSC_CDR_STS_INTEGr_t;
#define DSC_CDR_STS_INTEGr_CLR BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_CLR
#define DSC_CDR_STS_INTEGr_SET BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_SET
#define DSC_CDR_STS_INTEGr_GET BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_GET
#define DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr_CDR_INTEG_REGf_SET
#define READ_DSC_CDR_STS_INTEGr BCMI_FALCON_XGXS_READ_DSC_CDR_STS_INTEGr
#define WRITE_DSC_CDR_STS_INTEGr BCMI_FALCON_XGXS_WRITE_DSC_CDR_STS_INTEGr
#define MODIFY_DSC_CDR_STS_INTEGr BCMI_FALCON_XGXS_MODIFY_DSC_CDR_STS_INTEGr
#define READLN_DSC_CDR_STS_INTEGr BCMI_FALCON_XGXS_READLN_DSC_CDR_STS_INTEGr
#define WRITELN_DSC_CDR_STS_INTEGr BCMI_FALCON_XGXS_WRITELN_DSC_CDR_STS_INTEGr
#define WRITEALL_DSC_CDR_STS_INTEGr BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_STS_INTEGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_CDR_STS_INTEGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_CDR_STS_MISC
 * BLOCKS:   DSC_E
 * REGADDR:  0xd079
 * DEVAD:    1
 * DESC:     cdr status miscellaneous register.
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_LM_OUTOFLOCK CDR Lock Monitor loss of lock (1 implies a potential loss of lock). This bit sets itself on register read.And if the cdr_integ_reg is within bounds it clears itself in the next cycle from which it detects within bounds. Note: Set on readThe valid bounds on the cdr_integ_reg are programmed using cdr_lm_thr_selHas more meaning after rx_dsc_lock is asserted.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr (0x0001d079 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_STS_MISC.
 */
typedef union BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_sts_misc[1];
	uint32_t _dsc_cdr_sts_misc;
} BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_t;

#define BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_CLR(r) (r).dsc_cdr_sts_misc[0] = 0
#define BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_SET(r,d) (r).dsc_cdr_sts_misc[0] = d
#define BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_GET(r) (r).dsc_cdr_sts_misc[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_CDR_LM_OUTOFLOCKf_GET(r) (((r).dsc_cdr_sts_misc[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_CDR_LM_OUTOFLOCKf_SET(r,f) (r).dsc_cdr_sts_misc[0]=(((r).dsc_cdr_sts_misc[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_CDR_STS_MISC.
 */
#define BCMI_FALCON_XGXS_READ_DSC_CDR_STS_MISCr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr,(_r._dsc_cdr_sts_misc))
#define BCMI_FALCON_XGXS_WRITE_DSC_CDR_STS_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr,(_r._dsc_cdr_sts_misc)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_CDR_STS_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr,(_r._dsc_cdr_sts_misc))
#define BCMI_FALCON_XGXS_READLN_DSC_CDR_STS_MISCr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_misc))
#define BCMI_FALCON_XGXS_WRITELN_DSC_CDR_STS_MISCr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_sts_misc))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_STS_MISCr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_sts_misc))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_STS_MISCr BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr
#define DSC_CDR_STS_MISCr_SIZE BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_SIZE
typedef BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_t DSC_CDR_STS_MISCr_t;
#define DSC_CDR_STS_MISCr_CLR BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_CLR
#define DSC_CDR_STS_MISCr_SET BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_SET
#define DSC_CDR_STS_MISCr_GET BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_GET
#define DSC_CDR_STS_MISCr_CDR_LM_OUTOFLOCKf_GET BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_CDR_LM_OUTOFLOCKf_GET
#define DSC_CDR_STS_MISCr_CDR_LM_OUTOFLOCKf_SET BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr_CDR_LM_OUTOFLOCKf_SET
#define READ_DSC_CDR_STS_MISCr BCMI_FALCON_XGXS_READ_DSC_CDR_STS_MISCr
#define WRITE_DSC_CDR_STS_MISCr BCMI_FALCON_XGXS_WRITE_DSC_CDR_STS_MISCr
#define MODIFY_DSC_CDR_STS_MISCr BCMI_FALCON_XGXS_MODIFY_DSC_CDR_STS_MISCr
#define READLN_DSC_CDR_STS_MISCr BCMI_FALCON_XGXS_READLN_DSC_CDR_STS_MISCr
#define WRITELN_DSC_CDR_STS_MISCr BCMI_FALCON_XGXS_WRITELN_DSC_CDR_STS_MISCr
#define WRITEALL_DSC_CDR_STS_MISCr BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_STS_MISCr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_CDR_STS_MISCr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_CDR_1G_STS
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07a
 * DEVAD:    1
 * DESC:     1g cdr status reg
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CDR_1G_PHASE_POINTER 1G phase pointer - currently wraps @ 33. Not used for 20.625
 */
#define BCMI_FALCON_XGXS_DSC_CDR_1G_STSr (0x0001d07a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_SIZE 4

/*
 * This structure should be used to declare and program DSC_CDR_1G_STS.
 */
typedef union BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_s {
	uint32_t v[1];
	uint32_t dsc_cdr_1g_sts[1];
	uint32_t _dsc_cdr_1g_sts;
} BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_t;

#define BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_CLR(r) (r).dsc_cdr_1g_sts[0] = 0
#define BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_SET(r,d) (r).dsc_cdr_1g_sts[0] = d
#define BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_GET(r) (r).dsc_cdr_1g_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET(r) (((r).dsc_cdr_1g_sts[0]) & 0xff)
#define BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET(r,f) (r).dsc_cdr_1g_sts[0]=(((r).dsc_cdr_1g_sts[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access DSC_CDR_1G_STS.
 */
#define BCMI_FALCON_XGXS_READ_DSC_CDR_1G_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_1G_STSr,(_r._dsc_cdr_1g_sts))
#define BCMI_FALCON_XGXS_WRITE_DSC_CDR_1G_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_1G_STSr,(_r._dsc_cdr_1g_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_CDR_1G_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_1G_STSr,(_r._dsc_cdr_1g_sts))
#define BCMI_FALCON_XGXS_READLN_DSC_CDR_1G_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_CDR_1G_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_1g_sts))
#define BCMI_FALCON_XGXS_WRITELN_DSC_CDR_1G_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_1G_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_cdr_1g_sts))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_1G_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_CDR_1G_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_cdr_1g_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_CDR_1G_STSr BCMI_FALCON_XGXS_DSC_CDR_1G_STSr
#define DSC_CDR_1G_STSr_SIZE BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_SIZE
typedef BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_t DSC_CDR_1G_STSr_t;
#define DSC_CDR_1G_STSr_CLR BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_CLR
#define DSC_CDR_1G_STSr_SET BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_SET
#define DSC_CDR_1G_STSr_GET BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_GET
#define DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_GET
#define DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET BCMI_FALCON_XGXS_DSC_CDR_1G_STSr_CDR_1G_PHASE_POINTERf_SET
#define READ_DSC_CDR_1G_STSr BCMI_FALCON_XGXS_READ_DSC_CDR_1G_STSr
#define WRITE_DSC_CDR_1G_STSr BCMI_FALCON_XGXS_WRITE_DSC_CDR_1G_STSr
#define MODIFY_DSC_CDR_1G_STSr BCMI_FALCON_XGXS_MODIFY_DSC_CDR_1G_STSr
#define READLN_DSC_CDR_1G_STSr BCMI_FALCON_XGXS_READLN_DSC_CDR_1G_STSr
#define WRITELN_DSC_CDR_1G_STSr BCMI_FALCON_XGXS_WRITELN_DSC_CDR_1G_STSr
#define WRITEALL_DSC_CDR_1G_STSr BCMI_FALCON_XGXS_WRITEALL_DSC_CDR_1G_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_CDR_1G_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DSC_PRESET
 * BLOCKS:   DSC_E
 * REGADDR:  0xd07e
 * DEVAD:    1
 * DESC:     preset register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRESET_DSC_C_BANK Preset bit 1. Hooked up to dsc_sm bank
 *     PRESET_DSC_D_BANK Preset bit 2. Hooked up to CDR trnsum bank
 *     PRESET_DSC_A_BANK Preset bit 3. Hooked up to gen purpose bank a
 */
#define BCMI_FALCON_XGXS_DSC_PRESETr (0x0001d07e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DSC_PRESETr_SIZE 4

/*
 * This structure should be used to declare and program DSC_PRESET.
 */
typedef union BCMI_FALCON_XGXS_DSC_PRESETr_s {
	uint32_t v[1];
	uint32_t dsc_preset[1];
	uint32_t _dsc_preset;
} BCMI_FALCON_XGXS_DSC_PRESETr_t;

#define BCMI_FALCON_XGXS_DSC_PRESETr_CLR(r) (r).dsc_preset[0] = 0
#define BCMI_FALCON_XGXS_DSC_PRESETr_SET(r,d) (r).dsc_preset[0] = d
#define BCMI_FALCON_XGXS_DSC_PRESETr_GET(r) (r).dsc_preset[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_A_BANKf_GET(r) ((((r).dsc_preset[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_A_BANKf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_D_BANKf_GET(r) ((((r).dsc_preset[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_D_BANKf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_C_BANKf_GET(r) (((r).dsc_preset[0]) & 0x1)
#define BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_C_BANKf_SET(r,f) (r).dsc_preset[0]=(((r).dsc_preset[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DSC_PRESET.
 */
#define BCMI_FALCON_XGXS_READ_DSC_PRESETr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_PRESETr,(_r._dsc_preset))
#define BCMI_FALCON_XGXS_WRITE_DSC_PRESETr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_PRESETr,(_r._dsc_preset)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DSC_PRESETr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_PRESETr,(_r._dsc_preset))
#define BCMI_FALCON_XGXS_READLN_DSC_PRESETr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DSC_PRESETr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_preset))
#define BCMI_FALCON_XGXS_WRITELN_DSC_PRESETr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_PRESETr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dsc_preset))
#define BCMI_FALCON_XGXS_WRITEALL_DSC_PRESETr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DSC_PRESETr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dsc_preset))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DSC_PRESETr BCMI_FALCON_XGXS_DSC_PRESETr
#define DSC_PRESETr_SIZE BCMI_FALCON_XGXS_DSC_PRESETr_SIZE
typedef BCMI_FALCON_XGXS_DSC_PRESETr_t DSC_PRESETr_t;
#define DSC_PRESETr_CLR BCMI_FALCON_XGXS_DSC_PRESETr_CLR
#define DSC_PRESETr_SET BCMI_FALCON_XGXS_DSC_PRESETr_SET
#define DSC_PRESETr_GET BCMI_FALCON_XGXS_DSC_PRESETr_GET
#define DSC_PRESETr_PRESET_DSC_A_BANKf_GET BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_A_BANKf_GET
#define DSC_PRESETr_PRESET_DSC_A_BANKf_SET BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_A_BANKf_SET
#define DSC_PRESETr_PRESET_DSC_D_BANKf_GET BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_D_BANKf_GET
#define DSC_PRESETr_PRESET_DSC_D_BANKf_SET BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_D_BANKf_SET
#define DSC_PRESETr_PRESET_DSC_C_BANKf_GET BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_C_BANKf_GET
#define DSC_PRESETr_PRESET_DSC_C_BANKf_SET BCMI_FALCON_XGXS_DSC_PRESETr_PRESET_DSC_C_BANKf_SET
#define READ_DSC_PRESETr BCMI_FALCON_XGXS_READ_DSC_PRESETr
#define WRITE_DSC_PRESETr BCMI_FALCON_XGXS_WRITE_DSC_PRESETr
#define MODIFY_DSC_PRESETr BCMI_FALCON_XGXS_MODIFY_DSC_PRESETr
#define READLN_DSC_PRESETr BCMI_FALCON_XGXS_READLN_DSC_PRESETr
#define WRITELN_DSC_PRESETr BCMI_FALCON_XGXS_WRITELN_DSC_PRESETr
#define WRITEALL_DSC_PRESETr BCMI_FALCON_XGXS_WRITEALL_DSC_PRESETr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DSC_PRESETr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UR_CTL0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd080
 * DEVAD:    1
 * DESC:     Control 0 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_RX_TRAINING_EN RX Training EnableEnables the frame lock fsm on the RX sides
 *     CL93N72_TR_COARSE_LOCK Set to TRUE (1'b1) by the micro when coarse lock to recovered clock has occured.Cl93n72_pmd, then, proceeds with establishing frame_lock.
 *     CL93N72_RX_SIGNAL_OK Firmware sets this bit to 1'b0 when the training is in progressand sets this bit to 1'b1 when the training is complete
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r (0x0001d080 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_CTL0.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_ctl0[1];
	uint32_t _cl93n72_ur_ctl0;
} BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_t;

#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CLR(r) (r).cl93n72_ur_ctl0[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_SET(r,d) (r).cl93n72_ur_ctl0[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_GET(r) (r).cl93n72_ur_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_GET(r) ((((r).cl93n72_ur_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_SET(r,f) (r).cl93n72_ur_ctl0[0]=(((r).cl93n72_ur_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_GET(r) ((((r).cl93n72_ur_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_SET(r,f) (r).cl93n72_ur_ctl0[0]=(((r).cl93n72_ur_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_GET(r) (((r).cl93n72_ur_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_SET(r,f) (r).cl93n72_ur_ctl0[0]=(((r).cl93n72_ur_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL0r,(_r._cl93n72_ur_ctl0))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL0r,(_r._cl93n72_ur_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL0r,(_r._cl93n72_ur_ctl0))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ur_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_CTL0r BCMI_FALCON_XGXS_CL93N72_UR_CTL0r
#define CL93N72_UR_CTL0r_SIZE BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_t CL93N72_UR_CTL0r_t;
#define CL93N72_UR_CTL0r_CLR BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CLR
#define CL93N72_UR_CTL0r_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_SET
#define CL93N72_UR_CTL0r_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_GET
#define CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_GET
#define CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_SIGNAL_OKf_SET
#define CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_GET
#define CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_TR_COARSE_LOCKf_SET
#define CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_GET
#define CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL0r_CL93N72_RX_TRAINING_ENf_SET
#define READ_CL93N72_UR_CTL0r BCMI_FALCON_XGXS_READ_CL93N72_UR_CTL0r
#define WRITE_CL93N72_UR_CTL0r BCMI_FALCON_XGXS_WRITE_CL93N72_UR_CTL0r
#define MODIFY_CL93N72_UR_CTL0r BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_CTL0r
#define READLN_CL93N72_UR_CTL0r BCMI_FALCON_XGXS_READLN_CL93N72_UR_CTL0r
#define WRITELN_CL93N72_UR_CTL0r BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_CTL0r
#define WRITEALL_CL93N72_UR_CTL0r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UR_CTL1
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd081
 * DEVAD:    1
 * DESC:     Control 1 Register
 * RESETVAL: 0x52 (82)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_GOOD_MARKER_CNT Number of good marker to checkbefore enabling frame lock
 *     CL93N72_BAD_MARKER_CNT Number of bad marker to checkbefore losing frame lock
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r (0x0001d081 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_CTL1.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_ctl1[1];
	uint32_t _cl93n72_ur_ctl1;
} BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_t;

#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CLR(r) (r).cl93n72_ur_ctl1[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_SET(r,d) (r).cl93n72_ur_ctl1[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_GET(r) (r).cl93n72_ur_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_GET(r) ((((r).cl93n72_ur_ctl1[0]) >> 4) & 0x7)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_SET(r,f) (r).cl93n72_ur_ctl1[0]=(((r).cl93n72_ur_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_GET(r) (((r).cl93n72_ur_ctl1[0]) & 0x3)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_SET(r,f) (r).cl93n72_ur_ctl1[0]=(((r).cl93n72_ur_ctl1[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access CL93N72_UR_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UR_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL1r,(_r._cl93n72_ur_ctl1))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL1r,(_r._cl93n72_ur_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL1r,(_r._cl93n72_ur_ctl1))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ur_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_CTL1r BCMI_FALCON_XGXS_CL93N72_UR_CTL1r
#define CL93N72_UR_CTL1r_SIZE BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_t CL93N72_UR_CTL1r_t;
#define CL93N72_UR_CTL1r_CLR BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CLR
#define CL93N72_UR_CTL1r_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_SET
#define CL93N72_UR_CTL1r_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_GET
#define CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_GET
#define CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_BAD_MARKER_CNTf_SET
#define CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_GET
#define CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL1r_CL93N72_GOOD_MARKER_CNTf_SET
#define READ_CL93N72_UR_CTL1r BCMI_FALCON_XGXS_READ_CL93N72_UR_CTL1r
#define WRITE_CL93N72_UR_CTL1r BCMI_FALCON_XGXS_WRITE_CL93N72_UR_CTL1r
#define MODIFY_CL93N72_UR_CTL1r BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_CTL1r
#define READLN_CL93N72_UR_CTL1r BCMI_FALCON_XGXS_READLN_CL93N72_UR_CTL1r
#define WRITELN_CL93N72_UR_CTL1r BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_CTL1r
#define WRITEALL_CL93N72_UR_CTL1r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UR_CTL2
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd082
 * DEVAD:    1
 * DESC:     Control 2 Register
 * RESETVAL: 0x310 (784)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_CTRL_FRAME_DLY 0   : dis1-7 : early delay w.r.t cl93n72 rcvd data (7 vals)8  : sync to cl93n72 rcvd data9-15 : late delay w.r.t cl93n72 rcvd data (7 vals)
 *     CL93N72_DME_CELL_BOUNDARY_CHK Check for DME cell boundary transitions
 *     CL93N72_STRICT_DME_CHK Check for std. specified dme
 *     CL93N72_STRICT_MARKER_CHK Check for std. specified marker
 *     CL93N72_PPM_OFFSET_EN if enabled, cl93n72 tracks ppm offset of incoming datawhile checking from frame lock, one bit offset ineither direction for every frame (~4384 bits)
 *     CL93N72_RX_DP_LN_CLK_EN Cl93n72 Rx datapath lane clock enable0 - disabled1 - enabled
 *     CL93N72_FRAME_CONSISTENCY_CHK_EN Cl93n72 frame consistency check enable0 - disabled1 - enabled - checks that three consective frames from the link partnerhas the same status response/coffcient update request informationbefore it set the sets the latched status bits
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r (0x0001d082 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_CTL2.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_ctl2[1];
	uint32_t _cl93n72_ur_ctl2;
} BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_t;

#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CLR(r) (r).cl93n72_ur_ctl2[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_SET(r,d) (r).cl93n72_ur_ctl2[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_GET(r) (r).cl93n72_ur_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_GET(r) ((((r).cl93n72_ur_ctl2[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_GET(r) (((r).cl93n72_ur_ctl2[0]) & 0xf)
#define BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_SET(r,f) (r).cl93n72_ur_ctl2[0]=(((r).cl93n72_ur_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CL93N72_UR_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UR_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL2r,(_r._cl93n72_ur_ctl2))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL2r,(_r._cl93n72_ur_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL2r,(_r._cl93n72_ur_ctl2))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ur_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_CTL2r BCMI_FALCON_XGXS_CL93N72_UR_CTL2r
#define CL93N72_UR_CTL2r_SIZE BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_t CL93N72_UR_CTL2r_t;
#define CL93N72_UR_CTL2r_CLR BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CLR
#define CL93N72_UR_CTL2r_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_SET
#define CL93N72_UR_CTL2r_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_GET
#define CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_GET
#define CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_FRAME_CONSISTENCY_CHK_ENf_SET
#define CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_GET
#define CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_RX_DP_LN_CLK_ENf_SET
#define CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_GET
#define CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_PPM_OFFSET_ENf_SET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_GET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_MARKER_CHKf_SET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_GET
#define CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_STRICT_DME_CHKf_SET
#define CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_GET
#define CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_DME_CELL_BOUNDARY_CHKf_SET
#define CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_GET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_GET
#define CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_SET BCMI_FALCON_XGXS_CL93N72_UR_CTL2r_CL93N72_CTRL_FRAME_DLYf_SET
#define READ_CL93N72_UR_CTL2r BCMI_FALCON_XGXS_READ_CL93N72_UR_CTL2r
#define WRITE_CL93N72_UR_CTL2r BCMI_FALCON_XGXS_WRITE_CL93N72_UR_CTL2r
#define MODIFY_CL93N72_UR_CTL2r BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_CTL2r
#define READLN_CL93N72_UR_CTL2r BCMI_FALCON_XGXS_READLN_CL93N72_UR_CTL2r
#define WRITELN_CL93N72_UR_CTL2r BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_CTL2r
#define WRITEALL_CL93N72_UR_CTL2r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UR_STS0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd083
 * DEVAD:    1
 * DESC:     Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_FRAME_LOCK Frame Lock signal statusThis bit provides status of the frame lock signal from the frame lock fsm.1 - frame locked0 - frame not lockedThe status bit in the IEEE registers space is set by firmware
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_STS0r (0x0001d083 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_STS0.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UR_STS0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_sts0[1];
	uint32_t _cl93n72_ur_sts0;
} BCMI_FALCON_XGXS_CL93N72_UR_STS0r_t;

#define BCMI_FALCON_XGXS_CL93N72_UR_STS0r_CLR(r) (r).cl93n72_ur_sts0[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UR_STS0r_SET(r,d) (r).cl93n72_ur_sts0[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UR_STS0r_GET(r) (r).cl93n72_ur_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_GET(r) (((r).cl93n72_ur_sts0[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_SET(r,f) (r).cl93n72_ur_sts0[0]=(((r).cl93n72_ur_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_STS0.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UR_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_STS0r,(_r._cl93n72_ur_sts0))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_STS0r,(_r._cl93n72_ur_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_STS0r,(_r._cl93n72_ur_sts0))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UR_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_sts0))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ur_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_STS0r BCMI_FALCON_XGXS_CL93N72_UR_STS0r
#define CL93N72_UR_STS0r_SIZE BCMI_FALCON_XGXS_CL93N72_UR_STS0r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UR_STS0r_t CL93N72_UR_STS0r_t;
#define CL93N72_UR_STS0r_CLR BCMI_FALCON_XGXS_CL93N72_UR_STS0r_CLR
#define CL93N72_UR_STS0r_SET BCMI_FALCON_XGXS_CL93N72_UR_STS0r_SET
#define CL93N72_UR_STS0r_GET BCMI_FALCON_XGXS_CL93N72_UR_STS0r_GET
#define CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_GET BCMI_FALCON_XGXS_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_GET
#define CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_SET BCMI_FALCON_XGXS_CL93N72_UR_STS0r_CL93N72_FRAME_LOCKf_SET
#define READ_CL93N72_UR_STS0r BCMI_FALCON_XGXS_READ_CL93N72_UR_STS0r
#define WRITE_CL93N72_UR_STS0r BCMI_FALCON_XGXS_WRITE_CL93N72_UR_STS0r
#define MODIFY_CL93N72_UR_STS0r BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_STS0r
#define READLN_CL93N72_UR_STS0r BCMI_FALCON_XGXS_READLN_CL93N72_UR_STS0r
#define WRITELN_CL93N72_UR_STS0r BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_STS0r
#define WRITEALL_CL93N72_UR_STS0r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UR_UC_INTR_CTL0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd084
 * DEVAD:    1
 * DESC:     Micro Interrupt Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_MICRO_UPDATE_CHG_INT_EN Update field micro interrupt enable. Enables an interrupt when the update field value changes in the training frame received from Link PartnerThe Link parnter request a change to the Local Device TX FIR tap values via the update field1 - Enable. Generates an interrupt when cl93n72_micro_lstatus_update_chg = 1'b1.0 - Disable
 *     CL93N72_MICRO_STATUS_CHG_INT_EN Status field change micro interrupt enable. Enables an interrupt when the status field value changes in the training frame received from Link PartnerWhen the Local Devices requests Link Partner to change its TX FIR tap values, then the Link Partner updatestaps and sends a response on the stataus field of the training frame1 - Enable. Generates an interrupt when cl93n72_micro_lstatus_status_chg = 1'b1.0 - Disable
 *     CL93N72_MICRO_FRAME_LOCK_INT_EN frame_lock change micro interrupt enable.1 - Enable0 - Disable
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r (0x0001d084 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_UC_INTR_CTL0.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_uc_intr_ctl0[1];
	uint32_t _cl93n72_ur_uc_intr_ctl0;
} BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_t;

#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CLR(r) (r).cl93n72_ur_uc_intr_ctl0[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_SET(r,d) (r).cl93n72_ur_uc_intr_ctl0[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_GET(r) (r).cl93n72_ur_uc_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_GET(r) ((((r).cl93n72_ur_uc_intr_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_GET(r) (((r).cl93n72_ur_uc_intr_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_SET(r,f) (r).cl93n72_ur_uc_intr_ctl0[0]=(((r).cl93n72_ur_uc_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_UC_INTR_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r,(_r._cl93n72_ur_uc_intr_ctl0))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r,(_r._cl93n72_ur_uc_intr_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r,(_r._cl93n72_ur_uc_intr_ctl0))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UR_UC_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_uc_intr_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_UC_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_uc_intr_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_UC_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ur_uc_intr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_UC_INTR_CTL0r BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r
#define CL93N72_UR_UC_INTR_CTL0r_SIZE BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_t CL93N72_UR_UC_INTR_CTL0r_t;
#define CL93N72_UR_UC_INTR_CTL0r_CLR BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CLR
#define CL93N72_UR_UC_INTR_CTL0r_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_SET
#define CL93N72_UR_UC_INTR_CTL0r_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_FRAME_LOCK_INT_ENf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_STATUS_CHG_INT_ENf_SET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_GET
#define CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r_CL93N72_MICRO_UPDATE_CHG_INT_ENf_SET
#define READ_CL93N72_UR_UC_INTR_CTL0r BCMI_FALCON_XGXS_READ_CL93N72_UR_UC_INTR_CTL0r
#define WRITE_CL93N72_UR_UC_INTR_CTL0r BCMI_FALCON_XGXS_WRITE_CL93N72_UR_UC_INTR_CTL0r
#define MODIFY_CL93N72_UR_UC_INTR_CTL0r BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_UC_INTR_CTL0r
#define READLN_CL93N72_UR_UC_INTR_CTL0r BCMI_FALCON_XGXS_READLN_CL93N72_UR_UC_INTR_CTL0r
#define WRITELN_CL93N72_UR_UC_INTR_CTL0r BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_UC_INTR_CTL0r
#define WRITEALL_CL93N72_UR_UC_INTR_CTL0r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_UC_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UR_UC_INTR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UR_UC_STS0
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd085
 * DEVAD:    1
 * DESC:     Micro Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_MICRO_UPDATE_CHG_LSTATUS coeffcient update field change latched status -  This bit is set to 1'b1 when the update field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r (0x0001d085 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_UC_STS0.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_uc_sts0[1];
	uint32_t _cl93n72_ur_uc_sts0;
} BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_t;

#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_CLR(r) (r).cl93n72_ur_uc_sts0[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_SET(r,d) (r).cl93n72_ur_uc_sts0[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_GET(r) (r).cl93n72_ur_uc_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_GET(r) (((r).cl93n72_ur_uc_sts0[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_SET(r,f) (r).cl93n72_ur_uc_sts0[0]=(((r).cl93n72_ur_uc_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_UC_STS0.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r,(_r._cl93n72_ur_uc_sts0))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r,(_r._cl93n72_ur_uc_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r,(_r._cl93n72_ur_uc_sts0))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UR_UC_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_uc_sts0))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_UC_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_uc_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_UC_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ur_uc_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_UC_STS0r BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r
#define CL93N72_UR_UC_STS0r_SIZE BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_t CL93N72_UR_UC_STS0r_t;
#define CL93N72_UR_UC_STS0r_CLR BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_CLR
#define CL93N72_UR_UC_STS0r_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_SET
#define CL93N72_UR_UC_STS0r_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_GET
#define CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_GET
#define CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r_CL93N72_MICRO_UPDATE_CHG_LSTATUSf_SET
#define READ_CL93N72_UR_UC_STS0r BCMI_FALCON_XGXS_READ_CL93N72_UR_UC_STS0r
#define WRITE_CL93N72_UR_UC_STS0r BCMI_FALCON_XGXS_WRITE_CL93N72_UR_UC_STS0r
#define MODIFY_CL93N72_UR_UC_STS0r BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_UC_STS0r
#define READLN_CL93N72_UR_UC_STS0r BCMI_FALCON_XGXS_READLN_CL93N72_UR_UC_STS0r
#define WRITELN_CL93N72_UR_UC_STS0r BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_UC_STS0r
#define WRITEALL_CL93N72_UR_UC_STS0r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_UC_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UR_UC_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UR_UC_STS1
 * BLOCKS:   CL93N72_USER_RX
 * REGADDR:  0xd086
 * DEVAD:    1
 * DESC:     Micro Status 1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_MICRO_STATUS_CHG_LSTATUS coeffcient status field latched status - This bit is set to 1'b1 when the status field value changes in thetraining frame received from the Link Partner.This bit cleared when this register is read.
 *     CL93N72_MICRO_FRAME_LOCK_LSTATUS Frame lock change latched status - This bit is set to 1'b1 when a change is detected on the frame lock signalThis bit cleared when this register is read.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r (0x0001d086 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UR_UC_STS1.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_s {
	uint32_t v[1];
	uint32_t cl93n72_ur_uc_sts1[1];
	uint32_t _cl93n72_ur_uc_sts1;
} BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_t;

#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CLR(r) (r).cl93n72_ur_uc_sts1[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_SET(r,d) (r).cl93n72_ur_uc_sts1[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_GET(r) (r).cl93n72_ur_uc_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_GET(r) ((((r).cl93n72_ur_uc_sts1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_SET(r,f) (r).cl93n72_ur_uc_sts1[0]=(((r).cl93n72_ur_uc_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_GET(r) (((r).cl93n72_ur_uc_sts1[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_SET(r,f) (r).cl93n72_ur_uc_sts1[0]=(((r).cl93n72_ur_uc_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UR_UC_STS1.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r,(_r._cl93n72_ur_uc_sts1))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r,(_r._cl93n72_ur_uc_sts1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r,(_r._cl93n72_ur_uc_sts1))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UR_UC_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_uc_sts1))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_UC_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ur_uc_sts1))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_UC_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ur_uc_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UR_UC_STS1r BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r
#define CL93N72_UR_UC_STS1r_SIZE BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_t CL93N72_UR_UC_STS1r_t;
#define CL93N72_UR_UC_STS1r_CLR BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CLR
#define CL93N72_UR_UC_STS1r_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_SET
#define CL93N72_UR_UC_STS1r_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_GET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_GET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_FRAME_LOCK_LSTATUSf_SET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_GET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_GET
#define CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_SET BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r_CL93N72_MICRO_STATUS_CHG_LSTATUSf_SET
#define READ_CL93N72_UR_UC_STS1r BCMI_FALCON_XGXS_READ_CL93N72_UR_UC_STS1r
#define WRITE_CL93N72_UR_UC_STS1r BCMI_FALCON_XGXS_WRITE_CL93N72_UR_UC_STS1r
#define MODIFY_CL93N72_UR_UC_STS1r BCMI_FALCON_XGXS_MODIFY_CL93N72_UR_UC_STS1r
#define READLN_CL93N72_UR_UC_STS1r BCMI_FALCON_XGXS_READLN_CL93N72_UR_UC_STS1r
#define WRITELN_CL93N72_UR_UC_STS1r BCMI_FALCON_XGXS_WRITELN_CL93N72_UR_UC_STS1r
#define WRITEALL_CL93N72_UR_UC_STS1r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UR_UC_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UR_UC_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UT_XMT_UPD_PAGE
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd090
 * DEVAD:    1
 * DESC:     CL93N72 Send Coefficient Update Request to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_XMT_UPDATE_PAGE Local Device (LD) Coefficient Update registerContains correction information from the local receiverto the link partner transmit equalizer.Bit15:14   Reserved Transmitted as 0, ignored on reception.13   Preset1 = Preset coefficients0 = Normal operation12   Initialize 1 = Initialize coefficients0 = Normal operation11:6 Reserved Transmitted as 0, ignored on reception.5:4  Coefficient (+1) update5 41 1 = reserved0 1 = increment1 0 = decrement0 0 = hold3:2  Coefficient (0) update3 21 1 = reserved0 1 = increment1 0 = decrement0 0 = hold1:0  Coefficient (1) update1 01 1 = reserved0 1 = increment1 0 = decrement0 0 = hold
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr (0x0001d090 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_XMT_UPD_PAGE.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_xmt_upd_page[1];
	uint32_t _cl93n72_ut_xmt_upd_page;
} BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_t;

#define BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_CLR(r) (r).cl93n72_ut_xmt_upd_page[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_SET(r,d) (r).cl93n72_ut_xmt_upd_page[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_GET(r) (r).cl93n72_ut_xmt_upd_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_GET(r) (((r).cl93n72_ut_xmt_upd_page[0]) & 0xffff)
#define BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_SET(r,f) (r).cl93n72_ut_xmt_upd_page[0]=(((r).cl93n72_ut_xmt_upd_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_UT_XMT_UPD_PAGE.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr,(_r._cl93n72_ut_xmt_upd_page))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr,(_r._cl93n72_ut_xmt_upd_page)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr,(_r._cl93n72_ut_xmt_upd_page))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UT_XMT_UPD_PAGEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_xmt_upd_page))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_XMT_UPD_PAGEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_xmt_upd_page))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_XMT_UPD_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ut_xmt_upd_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_XMT_UPD_PAGEr BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr
#define CL93N72_UT_XMT_UPD_PAGEr_SIZE BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_t CL93N72_UT_XMT_UPD_PAGEr_t;
#define CL93N72_UT_XMT_UPD_PAGEr_CLR BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_CLR
#define CL93N72_UT_XMT_UPD_PAGEr_SET BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_SET
#define CL93N72_UT_XMT_UPD_PAGEr_GET BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_GET
#define CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_GET BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_GET
#define CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_SET BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr_CL93N72_XMT_UPDATE_PAGEf_SET
#define READ_CL93N72_UT_XMT_UPD_PAGEr BCMI_FALCON_XGXS_READ_CL93N72_UT_XMT_UPD_PAGEr
#define WRITE_CL93N72_UT_XMT_UPD_PAGEr BCMI_FALCON_XGXS_WRITE_CL93N72_UT_XMT_UPD_PAGEr
#define MODIFY_CL93N72_UT_XMT_UPD_PAGEr BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_XMT_UPD_PAGEr
#define READLN_CL93N72_UT_XMT_UPD_PAGEr BCMI_FALCON_XGXS_READLN_CL93N72_UT_XMT_UPD_PAGEr
#define WRITELN_CL93N72_UT_XMT_UPD_PAGEr BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_XMT_UPD_PAGEr
#define WRITEALL_CL93N72_UT_XMT_UPD_PAGEr BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_XMT_UPD_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UT_XMT_UPD_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UT_LD_XMT_STS_PAGE
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd091
 * DEVAD:    1
 * DESC:     CL93N72 Send Local Device's Coeffcient Status to Link Partner Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_LD_XMT_STATUS_PAGE Local Device's transmit status page
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr (0x0001d091 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_LD_XMT_STS_PAGE.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ld_xmt_sts_page[1];
	uint32_t _cl93n72_ut_ld_xmt_sts_page;
} BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_t;

#define BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_CLR(r) (r).cl93n72_ut_ld_xmt_sts_page[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_SET(r,d) (r).cl93n72_ut_ld_xmt_sts_page[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_GET(r) (r).cl93n72_ut_ld_xmt_sts_page[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_GET(r) (((r).cl93n72_ut_ld_xmt_sts_page[0]) & 0xffff)
#define BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_SET(r,f) (r).cl93n72_ut_ld_xmt_sts_page[0]=(((r).cl93n72_ut_ld_xmt_sts_page[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CL93N72_UT_LD_XMT_STS_PAGE.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr,(_r._cl93n72_ut_ld_xmt_sts_page))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr,(_r._cl93n72_ut_ld_xmt_sts_page)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr,(_r._cl93n72_ut_ld_xmt_sts_page))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ld_xmt_sts_page))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ld_xmt_sts_page))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_LD_XMT_STS_PAGEr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ut_ld_xmt_sts_page))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_LD_XMT_STS_PAGEr BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr
#define CL93N72_UT_LD_XMT_STS_PAGEr_SIZE BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_t CL93N72_UT_LD_XMT_STS_PAGEr_t;
#define CL93N72_UT_LD_XMT_STS_PAGEr_CLR BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_CLR
#define CL93N72_UT_LD_XMT_STS_PAGEr_SET BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_SET
#define CL93N72_UT_LD_XMT_STS_PAGEr_GET BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_GET
#define CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_GET BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_GET
#define CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_SET BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr_CL93N72_LD_XMT_STATUS_PAGEf_SET
#define READ_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_FALCON_XGXS_READ_CL93N72_UT_LD_XMT_STS_PAGEr
#define WRITE_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_FALCON_XGXS_WRITE_CL93N72_UT_LD_XMT_STS_PAGEr
#define MODIFY_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_LD_XMT_STS_PAGEr
#define READLN_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_FALCON_XGXS_READLN_CL93N72_UT_LD_XMT_STS_PAGEr
#define WRITELN_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_LD_XMT_STS_PAGEr
#define WRITEALL_CL93N72_UT_LD_XMT_STS_PAGEr BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_LD_XMT_STS_PAGEr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UT_LD_XMT_STS_PAGEr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UT_CTL0
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd092
 * DEVAD:    1
 * DESC:     CL93N72 Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_SW_RX_TRAINED Set to TRUE (1'b1) by the micro when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     CL93N72_SW_FRAME_LOCK Set to TRUE (1'b1) by the micro to indicate to the training fsmframe lock has been achieved
 *     CL93N72_SW_REMOTE_RX_READY Set to TRUE (1'b1) by the micro to indicate to the training fsmlink parnter rx ready bit is set. It indicates that the remote is trained
 *     CL93N72_PRBS_SEL prbs mode sel3'b0xx: cl72, random seed every frame3'b100: cl93, lane03'b101: cl93, lane13'b110: cl93, lane23'b111: cl93, lane3
 *     CL93N72_CL93PRBSSEED_ORDER cl93 prbs seed definitionIn Table 92-5 of the IEEE P802.3bj/D2.0 spec. if the seed values are definedfrom S10 to S0 (MSB:LSB) then the initial output from the prbs does not match the valuesindicated in the table. However, the initial value from the prbs and the table match ifthe seeds are defined from S0 to S10. Due to this uncertainty the field field is addedto select seed order0 - seed order S0 to S101 - seed order S10 to S0
 *     CL93N72_CL93PRBSSEED_RANDOM cl93 prbs seed randomTable 92-5 of the IEEE P802.3bj/D2.0 spec. indicates the seed and first 32-bits of thetraining pattern inside the cl93 frame.  The seed value are set at the begining of the trainingpattern and this implies that the training pattern portion of the cl93 frame is the same for all framesThis field allows the cl93 prbs seed values to be random so that the training pattern will be different0 - cl93 prbs seed value - as per the spec1 - cl93 prbs seed value - random
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r (0x0001d092 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL0.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl0[1];
	uint32_t _cl93n72_ut_ctl0;
} BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_t;

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CLR(r) (r).cl93n72_ut_ctl0[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_SET(r,d) (r).cl93n72_ut_ctl0[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_GET(r) (r).cl93n72_ut_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_RANDOMf_GET(r) ((((r).cl93n72_ut_ctl0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_RANDOMf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_ORDERf_GET(r) ((((r).cl93n72_ut_ctl0[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_ORDERf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_PRBS_SELf_GET(r) ((((r).cl93n72_ut_ctl0[0]) >> 4) & 0x7)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_PRBS_SELf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_GET(r) ((((r).cl93n72_ut_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_GET(r) ((((r).cl93n72_ut_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_GET(r) (((r).cl93n72_ut_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_SET(r,f) (r).cl93n72_ut_ctl0[0]=(((r).cl93n72_ut_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL0r,(_r._cl93n72_ut_ctl0))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL0r,(_r._cl93n72_ut_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL0r,(_r._cl93n72_ut_ctl0))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ut_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL0r BCMI_FALCON_XGXS_CL93N72_UT_CTL0r
#define CL93N72_UT_CTL0r_SIZE BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_t CL93N72_UT_CTL0r_t;
#define CL93N72_UT_CTL0r_CLR BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CLR
#define CL93N72_UT_CTL0r_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_SET
#define CL93N72_UT_CTL0r_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_GET
#define CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_RANDOMf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_RANDOMf_GET
#define CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_RANDOMf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_RANDOMf_SET
#define CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_ORDERf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_ORDERf_GET
#define CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_ORDERf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_CL93PRBSSEED_ORDERf_SET
#define CL93N72_UT_CTL0r_CL93N72_PRBS_SELf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_PRBS_SELf_GET
#define CL93N72_UT_CTL0r_CL93N72_PRBS_SELf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_PRBS_SELf_SET
#define CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_GET
#define CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_REMOTE_RX_READYf_SET
#define CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_GET
#define CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_FRAME_LOCKf_SET
#define CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_GET
#define CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL0r_CL93N72_SW_RX_TRAINEDf_SET
#define READ_CL93N72_UT_CTL0r BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL0r
#define WRITE_CL93N72_UT_CTL0r BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL0r
#define MODIFY_CL93N72_UT_CTL0r BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL0r
#define READLN_CL93N72_UT_CTL0r BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL0r
#define WRITELN_CL93N72_UT_CTL0r BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL0r
#define WRITEALL_CL93N72_UT_CTL0r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UT_CTL1
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd093
 * DEVAD:    1
 * DESC:     CL93N72 Control 1 Register
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_BRK_RING_OSC PRBS 11 Ring Oscillator control1: No oscillating - low power mode0: Osciallate - normal mode
 *     CL93N72_DIS_MAX_WAIT_TIMER disable max wait timer1 = max wait timer disabled0 = max wait timer enabled
 *     CL93N72_TX_DP_LN_CLK_EN Cl93n72 Tx Datapath lane clock enable0 - disabled1 - enabled
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r (0x0001d093 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL1.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl1[1];
	uint32_t _cl93n72_ut_ctl1;
} BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_t;

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CLR(r) (r).cl93n72_ut_ctl1[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_SET(r,d) (r).cl93n72_ut_ctl1[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_GET(r) (r).cl93n72_ut_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_GET(r) ((((r).cl93n72_ut_ctl1[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_SET(r,f) (r).cl93n72_ut_ctl1[0]=(((r).cl93n72_ut_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_GET(r) ((((r).cl93n72_ut_ctl1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_SET(r,f) (r).cl93n72_ut_ctl1[0]=(((r).cl93n72_ut_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_GET(r) (((r).cl93n72_ut_ctl1[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_SET(r,f) (r).cl93n72_ut_ctl1[0]=(((r).cl93n72_ut_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL1r,(_r._cl93n72_ut_ctl1))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL1r,(_r._cl93n72_ut_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL1r,(_r._cl93n72_ut_ctl1))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ut_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL1r BCMI_FALCON_XGXS_CL93N72_UT_CTL1r
#define CL93N72_UT_CTL1r_SIZE BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_t CL93N72_UT_CTL1r_t;
#define CL93N72_UT_CTL1r_CLR BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CLR
#define CL93N72_UT_CTL1r_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_SET
#define CL93N72_UT_CTL1r_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_GET
#define CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_GET
#define CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_TX_DP_LN_CLK_ENf_SET
#define CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_GET
#define CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_DIS_MAX_WAIT_TIMERf_SET
#define CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_GET
#define CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL1r_CL93N72_BRK_RING_OSCf_SET
#define READ_CL93N72_UT_CTL1r BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL1r
#define WRITE_CL93N72_UT_CTL1r BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL1r
#define MODIFY_CL93N72_UT_CTL1r BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL1r
#define READLN_CL93N72_UT_CTL1r BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL1r
#define WRITELN_CL93N72_UT_CTL1r BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL1r
#define WRITEALL_CL93N72_UT_CTL1r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UT_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UT_CTL2
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd094
 * DEVAD:    1
 * DESC:     CL93N72 Control 2 Register
 * RESETVAL: 0x2c08 (11272)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_TXFIR_PRE pre cursor tap coeeficient value.
 *     CL93N72_TXFIR_POST post cursor tap coeeficient value.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r (0x0001d094 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL2.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl2[1];
	uint32_t _cl93n72_ut_ctl2;
} BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_t;

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CLR(r) (r).cl93n72_ut_ctl2[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_SET(r,d) (r).cl93n72_ut_ctl2[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_GET(r) (r).cl93n72_ut_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_GET(r) ((((r).cl93n72_ut_ctl2[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_SET(r,f) (r).cl93n72_ut_ctl2[0]=(((r).cl93n72_ut_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_GET(r) (((r).cl93n72_ut_ctl2[0]) & 0x1f)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_SET(r,f) (r).cl93n72_ut_ctl2[0]=(((r).cl93n72_ut_ctl2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL2r,(_r._cl93n72_ut_ctl2))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL2r,(_r._cl93n72_ut_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL2r,(_r._cl93n72_ut_ctl2))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ut_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL2r BCMI_FALCON_XGXS_CL93N72_UT_CTL2r
#define CL93N72_UT_CTL2r_SIZE BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_t CL93N72_UT_CTL2r_t;
#define CL93N72_UT_CTL2r_CLR BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CLR
#define CL93N72_UT_CTL2r_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_SET
#define CL93N72_UT_CTL2r_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_GET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_GET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_POSTf_SET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_GET
#define CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL2r_CL93N72_TXFIR_PREf_SET
#define READ_CL93N72_UT_CTL2r BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL2r
#define WRITE_CL93N72_UT_CTL2r BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL2r
#define MODIFY_CL93N72_UT_CTL2r BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL2r
#define READLN_CL93N72_UT_CTL2r BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL2r
#define WRITELN_CL93N72_UT_CTL2r BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL2r
#define WRITEALL_CL93N72_UT_CTL2r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UT_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UT_CTL3
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd095
 * DEVAD:    1
 * DESC:     CL93N72 Control 3 Register
 * RESETVAL: 0x3c (60)
 * ACCESS:   R/W
 * FIELDS:
 *     CL93N72_TXFIR_MAIN main cursor tap coeeficient value.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL3r (0x0001d095 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_CTL3.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_ctl3[1];
	uint32_t _cl93n72_ut_ctl3;
} BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_t;

#define BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_CLR(r) (r).cl93n72_ut_ctl3[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_SET(r,d) (r).cl93n72_ut_ctl3[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_GET(r) (r).cl93n72_ut_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_GET(r) (((r).cl93n72_ut_ctl3[0]) & 0x7f)
#define BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_SET(r,f) (r).cl93n72_ut_ctl3[0]=(((r).cl93n72_ut_ctl3[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access CL93N72_UT_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL3r,(_r._cl93n72_ut_ctl3))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL3r,(_r._cl93n72_ut_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL3r,(_r._cl93n72_ut_ctl3))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ut_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_CTL3r BCMI_FALCON_XGXS_CL93N72_UT_CTL3r
#define CL93N72_UT_CTL3r_SIZE BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_t CL93N72_UT_CTL3r_t;
#define CL93N72_UT_CTL3r_CLR BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_CLR
#define CL93N72_UT_CTL3r_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_SET
#define CL93N72_UT_CTL3r_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_GET
#define CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_GET BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_GET
#define CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_SET BCMI_FALCON_XGXS_CL93N72_UT_CTL3r_CL93N72_TXFIR_MAINf_SET
#define READ_CL93N72_UT_CTL3r BCMI_FALCON_XGXS_READ_CL93N72_UT_CTL3r
#define WRITE_CL93N72_UT_CTL3r BCMI_FALCON_XGXS_WRITE_CL93N72_UT_CTL3r
#define MODIFY_CL93N72_UT_CTL3r BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_CTL3r
#define READLN_CL93N72_UT_CTL3r BCMI_FALCON_XGXS_READLN_CL93N72_UT_CTL3r
#define WRITELN_CL93N72_UT_CTL3r BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_CTL3r
#define WRITEALL_CL93N72_UT_CTL3r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UT_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CL93N72_UT_STS0
 * BLOCKS:   CL93N72_USER_TX
 * REGADDR:  0xd096
 * DEVAD:    1
 * DESC:     CL93N72 Status 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CL93N72_LOCAL_RX_READY Set to TRUE (1'b1) by the FSM when the remote transmitand local equalizers have been optimized and normal datatransmission may commence; set to FALSE (1'b0) otherwise.
 *     CL93N72_TRAINING_FSM_SIGNAL_DETECT 1 - CL93N72 is in SEND_DATA state0 - CL93N72 is in training state
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r (0x0001d096 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program CL93N72_UT_STS0.
 */
typedef union BCMI_FALCON_XGXS_CL93N72_UT_STS0r_s {
	uint32_t v[1];
	uint32_t cl93n72_ut_sts0[1];
	uint32_t _cl93n72_ut_sts0;
} BCMI_FALCON_XGXS_CL93N72_UT_STS0r_t;

#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CLR(r) (r).cl93n72_ut_sts0[0] = 0
#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_SET(r,d) (r).cl93n72_ut_sts0[0] = d
#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_GET(r) (r).cl93n72_ut_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_GET(r) ((((r).cl93n72_ut_sts0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_SET(r,f) (r).cl93n72_ut_sts0[0]=(((r).cl93n72_ut_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_GET(r) (((r).cl93n72_ut_sts0[0]) & 0x1)
#define BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_SET(r,f) (r).cl93n72_ut_sts0[0]=(((r).cl93n72_ut_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CL93N72_UT_STS0.
 */
#define BCMI_FALCON_XGXS_READ_CL93N72_UT_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_STS0r,(_r._cl93n72_ut_sts0))
#define BCMI_FALCON_XGXS_WRITE_CL93N72_UT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_STS0r,(_r._cl93n72_ut_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_STS0r,(_r._cl93n72_ut_sts0))
#define BCMI_FALCON_XGXS_READLN_CL93N72_UT_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CL93N72_UT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_sts0))
#define BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._cl93n72_ut_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CL93N72_UT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._cl93n72_ut_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CL93N72_UT_STS0r BCMI_FALCON_XGXS_CL93N72_UT_STS0r
#define CL93N72_UT_STS0r_SIZE BCMI_FALCON_XGXS_CL93N72_UT_STS0r_SIZE
typedef BCMI_FALCON_XGXS_CL93N72_UT_STS0r_t CL93N72_UT_STS0r_t;
#define CL93N72_UT_STS0r_CLR BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CLR
#define CL93N72_UT_STS0r_SET BCMI_FALCON_XGXS_CL93N72_UT_STS0r_SET
#define CL93N72_UT_STS0r_GET BCMI_FALCON_XGXS_CL93N72_UT_STS0r_GET
#define CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_GET BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_GET
#define CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_SET BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_TRAINING_FSM_SIGNAL_DETECTf_SET
#define CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_GET BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_GET
#define CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_SET BCMI_FALCON_XGXS_CL93N72_UT_STS0r_CL93N72_LOCAL_RX_READYf_SET
#define READ_CL93N72_UT_STS0r BCMI_FALCON_XGXS_READ_CL93N72_UT_STS0r
#define WRITE_CL93N72_UT_STS0r BCMI_FALCON_XGXS_WRITE_CL93N72_UT_STS0r
#define MODIFY_CL93N72_UT_STS0r BCMI_FALCON_XGXS_MODIFY_CL93N72_UT_STS0r
#define READLN_CL93N72_UT_STS0r BCMI_FALCON_XGXS_READLN_CL93N72_UT_STS0r
#define WRITELN_CL93N72_UT_STS0r BCMI_FALCON_XGXS_WRITELN_CL93N72_UT_STS0r
#define WRITEALL_CL93N72_UT_STS0r BCMI_FALCON_XGXS_WRITEALL_CL93N72_UT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CL93N72_UT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_CTL0
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0a0
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 0
 * RESETVAL: 0x7000 (28672)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_EN         Transmit Phase Interpolator Enable. If 1'b0 will gate off the TX PI clock and also freeze the PI code.
 *     TX_PI_JITTER_FILTER_EN This enables the IIR filter for the phase_sum_val logic from the CDR ( or external CDR in case of Repeater ) .
 *     TX_PI_EXT_CTRL_EN Enable for the phase error (inc/dec) from the remote loopback ( or HS Phase FIFO in case of Repeater )
 *     TX_PI_FREQ_OVERRIDE_EN Enable for the frequency override mode. It should be 1'b1 for fixed frequency and jitter generation modes.
 *     TX_PI_SJ_GEN_EN  Sinusoidal Jitter (SJ) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_SSC_GEN_EN Spread Spectrum Jitter (SSC) Enable. This has priority over tx_pi_ssc_gen_en if both are enabled simultaneously.
 *     TX_PI_JIT_SSC_FREQ_MODE SSJ Mode Select:1'b1 : 10G SSC mode and 1'b0: 6G SSC mode
 *     TX_PI_SECOND_ORDER_LOOP_EN 2nd Order Loop Enable. 1'b1 will enable the 2nd order loop of the IIR filter. 1'b0 will reset the all the flops related to the 2nd order loop.This bit is only valid when tx_pi_jitter_filter_en is set to 1'b1.
 *     TX_PI_FIRST_ORDER_BWSEL_INTEG First order bandwidth control.2'd0 -  80 KHz2'd1 - 160 KHz2'd2 - 321 KHz2'd3 - 642 KHz
 *     TX_PI_SECOND_ORDER_BWSEL_INTEG Second order bandwidth control. Valid values are 0, 1, 2 and 3.
 *     TX_PI_EXT_PHASE_BWSEL_INTEG External Phase bandwidth control. Valid values are 0 to 7.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r (0x0001d0a0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_CTL0.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_ctl0[1];
	uint32_t _tx_pi_pmd_ctl0;
} BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_CLR(r) (r).tx_pi_pmd_ctl0[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_SET(r,d) (r).tx_pi_pmd_ctl0[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_GET(r) (r).tx_pi_pmd_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 12) & 0x7)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 10) & 0x3)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SSC_GEN_ENf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SSC_GEN_ENf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SJ_GEN_ENf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SJ_GEN_ENf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_CTRL_ENf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_CTRL_ENf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JITTER_FILTER_ENf_GET(r) ((((r).tx_pi_pmd_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JITTER_FILTER_ENf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_ENf_GET(r) (((r).tx_pi_pmd_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_ENf_SET(r,f) (r).tx_pi_pmd_ctl0[0]=(((r).tx_pi_pmd_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_PMD_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r,(_r._tx_pi_pmd_ctl0))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r,(_r._tx_pi_pmd_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r,(_r._tx_pi_pmd_ctl0))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_CTL0r BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r
#define TX_PI_PMD_CTL0r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_t TX_PI_PMD_CTL0r_t;
#define TX_PI_PMD_CTL0r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_CLR
#define TX_PI_PMD_CTL0r_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_SET
#define TX_PI_PMD_CTL0r_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_GET
#define TX_PI_PMD_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_GET
#define TX_PI_PMD_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_PHASE_BWSEL_INTEGf_SET
#define TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_GET
#define TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_BWSEL_INTEGf_SET
#define TX_PI_PMD_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_GET
#define TX_PI_PMD_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FIRST_ORDER_BWSEL_INTEGf_SET
#define TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_GET
#define TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SECOND_ORDER_LOOP_ENf_SET
#define TX_PI_PMD_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_GET
#define TX_PI_PMD_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JIT_SSC_FREQ_MODEf_SET
#define TX_PI_PMD_CTL0r_TX_PI_SSC_GEN_ENf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SSC_GEN_ENf_GET
#define TX_PI_PMD_CTL0r_TX_PI_SSC_GEN_ENf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SSC_GEN_ENf_SET
#define TX_PI_PMD_CTL0r_TX_PI_SJ_GEN_ENf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SJ_GEN_ENf_GET
#define TX_PI_PMD_CTL0r_TX_PI_SJ_GEN_ENf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_SJ_GEN_ENf_SET
#define TX_PI_PMD_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_GET
#define TX_PI_PMD_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_FREQ_OVERRIDE_ENf_SET
#define TX_PI_PMD_CTL0r_TX_PI_EXT_CTRL_ENf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_CTRL_ENf_GET
#define TX_PI_PMD_CTL0r_TX_PI_EXT_CTRL_ENf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_EXT_CTRL_ENf_SET
#define TX_PI_PMD_CTL0r_TX_PI_JITTER_FILTER_ENf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JITTER_FILTER_ENf_GET
#define TX_PI_PMD_CTL0r_TX_PI_JITTER_FILTER_ENf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_JITTER_FILTER_ENf_SET
#define TX_PI_PMD_CTL0r_TX_PI_ENf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_ENf_GET
#define TX_PI_PMD_CTL0r_TX_PI_ENf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r_TX_PI_ENf_SET
#define READ_TX_PI_PMD_CTL0r BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL0r
#define WRITE_TX_PI_PMD_CTL0r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL0r
#define MODIFY_TX_PI_PMD_CTL0r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL0r
#define READLN_TX_PI_PMD_CTL0r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL0r
#define WRITELN_TX_PI_PMD_CTL0r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL0r
#define WRITEALL_TX_PI_PMD_CTL0r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_CTL1
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0a1
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FREQ_OVERRIDE_VAL Fixed Frequncy Override Value: Valid values are -8192 to +8192. Register tx_pi_freq_override_en should be 1'b1 to enable the Fixed Frequncy Override mode.+8192 (-8192) value in this register will result into 1 TX PI phase inc (dec) every 20T tclk. This results into (1/64 * 1/20)UI phase inc (or dec) per UI = 781.25(-781.25) ppm. So 1 ppm = 10.486 value.If tx_pi_jit_gen_en is set to 1'b1 then this register provides initilization value for Jitter Gen Integ Reg. Valid values in jitter generation mode are -8192 to +8191
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r (0x0001d0a1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_CTL1.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_ctl1[1];
	uint32_t _tx_pi_pmd_ctl1;
} BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_CLR(r) (r).tx_pi_pmd_ctl1[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_SET(r,d) (r).tx_pi_pmd_ctl1[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_GET(r) (r).tx_pi_pmd_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET(r) (((r).tx_pi_pmd_ctl1[0]) & 0x7fff)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET(r,f) (r).tx_pi_pmd_ctl1[0]=(((r).tx_pi_pmd_ctl1[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_PMD_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r,(_r._tx_pi_pmd_ctl1))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r,(_r._tx_pi_pmd_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r,(_r._tx_pi_pmd_ctl1))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_CTL1r BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r
#define TX_PI_PMD_CTL1r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_t TX_PI_PMD_CTL1r_t;
#define TX_PI_PMD_CTL1r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_CLR
#define TX_PI_PMD_CTL1r_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_SET
#define TX_PI_PMD_CTL1r_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_GET
#define TX_PI_PMD_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_GET
#define TX_PI_PMD_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r_TX_PI_FREQ_OVERRIDE_VALf_SET
#define READ_TX_PI_PMD_CTL1r BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL1r
#define WRITE_TX_PI_PMD_CTL1r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL1r
#define MODIFY_TX_PI_PMD_CTL1r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL1r
#define READLN_TX_PI_PMD_CTL1r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL1r
#define WRITELN_TX_PI_PMD_CTL1r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL1r
#define WRITEALL_TX_PI_PMD_CTL1r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_CTL2
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0a2
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_JIT_FREQ_IDX Jitter Generator Frequency Index. Valid values are from 0 to 63. Each value maps to a table into the spec which then provides various Jitter generator parameters.In SJ  mode: It provides ndiv, Nsj (or Nsj_div_ndiv), sj_gain1 and sj_gain2. Refer Jitter Generator spec for the table details.In SSC mode: It provides Nssc.                                               Refer Jitter Generator spec for the table details.
 *     TX_PI_JIT_AMP    Jitter Generator Amplification Factor. Valid values are 0 to 63.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r (0x0001d0a2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_CTL2.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_ctl2[1];
	uint32_t _tx_pi_pmd_ctl2;
} BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_CLR(r) (r).tx_pi_pmd_ctl2[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_SET(r,d) (r).tx_pi_pmd_ctl2[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_GET(r) (r).tx_pi_pmd_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_AMPf_GET(r) ((((r).tx_pi_pmd_ctl2[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_AMPf_SET(r,f) (r).tx_pi_pmd_ctl2[0]=(((r).tx_pi_pmd_ctl2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_FREQ_IDXf_GET(r) (((r).tx_pi_pmd_ctl2[0]) & 0x3f)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_FREQ_IDXf_SET(r,f) (r).tx_pi_pmd_ctl2[0]=(((r).tx_pi_pmd_ctl2[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_PMD_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r,(_r._tx_pi_pmd_ctl2))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r,(_r._tx_pi_pmd_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r,(_r._tx_pi_pmd_ctl2))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_CTL2r BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r
#define TX_PI_PMD_CTL2r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_t TX_PI_PMD_CTL2r_t;
#define TX_PI_PMD_CTL2r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_CLR
#define TX_PI_PMD_CTL2r_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_SET
#define TX_PI_PMD_CTL2r_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_GET
#define TX_PI_PMD_CTL2r_TX_PI_JIT_AMPf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_AMPf_GET
#define TX_PI_PMD_CTL2r_TX_PI_JIT_AMPf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_AMPf_SET
#define TX_PI_PMD_CTL2r_TX_PI_JIT_FREQ_IDXf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_FREQ_IDXf_GET
#define TX_PI_PMD_CTL2r_TX_PI_JIT_FREQ_IDXf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r_TX_PI_JIT_FREQ_IDXf_SET
#define READ_TX_PI_PMD_CTL2r BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL2r
#define WRITE_TX_PI_PMD_CTL2r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL2r
#define MODIFY_TX_PI_PMD_CTL2r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL2r
#define READLN_TX_PI_PMD_CTL2r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL2r
#define WRITELN_TX_PI_PMD_CTL2r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL2r
#define WRITEALL_TX_PI_PMD_CTL2r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_CTL3
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0a3
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 3
 * RESETVAL: 0x100 (256)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_PHASE_OVERRIDE Manual Phase Override Mode. When 1'b1 the PI phase can be moved manually using registers. All the filter logic is bypassed during manual mode.
 *     TX_PI_PHASE_STROBE Manual Phase strobe. When set to 1'b1 then it will generate 1 phase step (inc/dec depending on tx_pi_phase_step_dir) or multiple phase steps if tx_pi_phase_step_osr is 1'b1.If tx_pi_phase_override is 1'b0 then manual phase steps will be added with the output of the IIR filter phase steps during the time when there is no phase steps from the IIR filter.Self Clearing Register. Must be polled for 1'b0 before writing it to 1'b1 again for correct Manual Phase Step Shift.
 *     TX_PI_PHASE_STEP_DIR Manual Phase Step direction.1'b0: Increment1'b1: Decrement
 *     TX_PI_PHASE_INVERT 1'b1 : will invert (i.e. swap) the final inc and dec before the PI code shifter logic.
 *     TX_PI_PHASE_STEP_NUM Defines the number of phase steps movement for every manual strobe. Valid values are 1 to 15.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r (0x0001d0a3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_CTL3.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_ctl3[1];
	uint32_t _tx_pi_pmd_ctl3;
} BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_CLR(r) (r).tx_pi_pmd_ctl3[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_SET(r,d) (r).tx_pi_pmd_ctl3[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_GET(r) (r).tx_pi_pmd_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_NUMf_GET(r) ((((r).tx_pi_pmd_ctl3[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_NUMf_SET(r,f) (r).tx_pi_pmd_ctl3[0]=(((r).tx_pi_pmd_ctl3[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_INVERTf_GET(r) ((((r).tx_pi_pmd_ctl3[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_INVERTf_SET(r,f) (r).tx_pi_pmd_ctl3[0]=(((r).tx_pi_pmd_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_DIRf_GET(r) ((((r).tx_pi_pmd_ctl3[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_DIRf_SET(r,f) (r).tx_pi_pmd_ctl3[0]=(((r).tx_pi_pmd_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STROBEf_GET(r) ((((r).tx_pi_pmd_ctl3[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STROBEf_SET(r,f) (r).tx_pi_pmd_ctl3[0]=(((r).tx_pi_pmd_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_OVERRIDEf_GET(r) (((r).tx_pi_pmd_ctl3[0]) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_OVERRIDEf_SET(r,f) (r).tx_pi_pmd_ctl3[0]=(((r).tx_pi_pmd_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_PMD_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r,(_r._tx_pi_pmd_ctl3))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r,(_r._tx_pi_pmd_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r,(_r._tx_pi_pmd_ctl3))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_CTL3r BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r
#define TX_PI_PMD_CTL3r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_t TX_PI_PMD_CTL3r_t;
#define TX_PI_PMD_CTL3r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_CLR
#define TX_PI_PMD_CTL3r_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_SET
#define TX_PI_PMD_CTL3r_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_GET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_NUMf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_NUMf_GET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_NUMf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_NUMf_SET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_INVERTf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_INVERTf_GET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_INVERTf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_INVERTf_SET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_DIRf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_DIRf_GET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_DIRf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STEP_DIRf_SET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_STROBEf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STROBEf_GET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_STROBEf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_STROBEf_SET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_OVERRIDEf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_OVERRIDEf_GET
#define TX_PI_PMD_CTL3r_TX_PI_PHASE_OVERRIDEf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r_TX_PI_PHASE_OVERRIDEf_SET
#define READ_TX_PI_PMD_CTL3r BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL3r
#define WRITE_TX_PI_PMD_CTL3r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL3r
#define MODIFY_TX_PI_PMD_CTL3r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL3r
#define READLN_TX_PI_PMD_CTL3r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL3r
#define WRITELN_TX_PI_PMD_CTL3r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL3r
#define WRITEALL_TX_PI_PMD_CTL3r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_CTL4
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0a4
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Control 4
 * RESETVAL: 0x4 (4)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PI_FRZ_FRC    IIR filter freeze control by force. 1'b1 will force the freeze value indicated by tx_pi_frz_frc_val otherwise Normal IIR operation.
 *     TX_PI_FRZ_FRC_VAL Force value for the IIR filter freeze. 1'b1 is freeze, 1'b0 is normal IIR operation.
 *     TX_PI_FRZ_MODE   Freeze Mode. 1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b1 will freeze the integ2 reg so that during the freeze, TX PI will generate the phase steps based on the integ2 freeze value.1'b0 will force the phase_sum_val input from the CDR loop timing path of the IIR filter to 0s which will result in slowly bringing the TX clock to 0 ppm from PLL/VCO clock.
 *     TX_PI_RESET_CODE_DBG Debug register.Resets the TX PI code going to AFE. This is just a debug register and is not recommended to be used during normal operation of TX PI.
 *     TX_PI_RMT_LPBK_BYPASS_FLT 1'b1 will enable filter bypass for inc/dec indication from Remote loopback PD to quicker phase locking time. This mode is recommended for faster simulation time.Note that it is only applicable if tx_pi_ext_ctrl_en is 1'b1 and tx_pi_pass_thru_sel is 1'b0.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r (0x0001d0a4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_CTL4.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_ctl4[1];
	uint32_t _tx_pi_pmd_ctl4;
} BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_CLR(r) (r).tx_pi_pmd_ctl4[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_SET(r,d) (r).tx_pi_pmd_ctl4[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_GET(r) (r).tx_pi_pmd_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_GET(r) ((((r).tx_pi_pmd_ctl4[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_SET(r,f) (r).tx_pi_pmd_ctl4[0]=(((r).tx_pi_pmd_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RESET_CODE_DBGf_GET(r) ((((r).tx_pi_pmd_ctl4[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RESET_CODE_DBGf_SET(r,f) (r).tx_pi_pmd_ctl4[0]=(((r).tx_pi_pmd_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_MODEf_GET(r) ((((r).tx_pi_pmd_ctl4[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_MODEf_SET(r,f) (r).tx_pi_pmd_ctl4[0]=(((r).tx_pi_pmd_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRC_VALf_GET(r) ((((r).tx_pi_pmd_ctl4[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRC_VALf_SET(r,f) (r).tx_pi_pmd_ctl4[0]=(((r).tx_pi_pmd_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRCf_GET(r) (((r).tx_pi_pmd_ctl4[0]) & 0x1)
#define BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRCf_SET(r,f) (r).tx_pi_pmd_ctl4[0]=(((r).tx_pi_pmd_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TX_PI_PMD_CTL4.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r,(_r._tx_pi_pmd_ctl4))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r,(_r._tx_pi_pmd_ctl4)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r,(_r._tx_pi_pmd_ctl4))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl4))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_ctl4))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_CTL4r BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r
#define TX_PI_PMD_CTL4r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_t TX_PI_PMD_CTL4r_t;
#define TX_PI_PMD_CTL4r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_CLR
#define TX_PI_PMD_CTL4r_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_SET
#define TX_PI_PMD_CTL4r_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_GET
#define TX_PI_PMD_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_GET
#define TX_PI_PMD_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RMT_LPBK_BYPASS_FLTf_SET
#define TX_PI_PMD_CTL4r_TX_PI_RESET_CODE_DBGf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RESET_CODE_DBGf_GET
#define TX_PI_PMD_CTL4r_TX_PI_RESET_CODE_DBGf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_RESET_CODE_DBGf_SET
#define TX_PI_PMD_CTL4r_TX_PI_FRZ_MODEf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_MODEf_GET
#define TX_PI_PMD_CTL4r_TX_PI_FRZ_MODEf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_MODEf_SET
#define TX_PI_PMD_CTL4r_TX_PI_FRZ_FRC_VALf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRC_VALf_GET
#define TX_PI_PMD_CTL4r_TX_PI_FRZ_FRC_VALf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRC_VALf_SET
#define TX_PI_PMD_CTL4r_TX_PI_FRZ_FRCf_GET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRCf_GET
#define TX_PI_PMD_CTL4r_TX_PI_FRZ_FRCf_SET BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r_TX_PI_FRZ_FRCf_SET
#define READ_TX_PI_PMD_CTL4r BCMI_FALCON_XGXS_READ_TX_PI_PMD_CTL4r
#define WRITE_TX_PI_PMD_CTL4r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_CTL4r
#define MODIFY_TX_PI_PMD_CTL4r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_CTL4r
#define READLN_TX_PI_PMD_CTL4r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_CTL4r
#define WRITELN_TX_PI_PMD_CTL4r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_CTL4r
#define WRITEALL_TX_PI_PMD_CTL4r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_STS0
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0a8
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_CNTR TX PI Phase Counter. Signed Value.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS0r (0x0001d0a8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_STS0.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_sts0[1];
	uint32_t _tx_pi_pmd_sts0;
} BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_CLR(r) (r).tx_pi_pmd_sts0[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_SET(r,d) (r).tx_pi_pmd_sts0[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_GET(r) (r).tx_pi_pmd_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_TX_PI_PHASE_CNTRf_GET(r) (((r).tx_pi_pmd_sts0[0]) & 0x7f)
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_TX_PI_PHASE_CNTRf_SET(r,f) (r).tx_pi_pmd_sts0[0]=(((r).tx_pi_pmd_sts0[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TX_PI_PMD_STS0.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS0r,(_r._tx_pi_pmd_sts0))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS0r,(_r._tx_pi_pmd_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS0r,(_r._tx_pi_pmd_sts0))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts0))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_STS0r BCMI_FALCON_XGXS_TX_PI_PMD_STS0r
#define TX_PI_PMD_STS0r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_t TX_PI_PMD_STS0r_t;
#define TX_PI_PMD_STS0r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_CLR
#define TX_PI_PMD_STS0r_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_SET
#define TX_PI_PMD_STS0r_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_GET
#define TX_PI_PMD_STS0r_TX_PI_PHASE_CNTRf_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_TX_PI_PHASE_CNTRf_GET
#define TX_PI_PMD_STS0r_TX_PI_PHASE_CNTRf_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS0r_TX_PI_PHASE_CNTRf_SET
#define READ_TX_PI_PMD_STS0r BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS0r
#define WRITE_TX_PI_PMD_STS0r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS0r
#define MODIFY_TX_PI_PMD_STS0r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS0r
#define READLN_TX_PI_PMD_STS0r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS0r
#define WRITELN_TX_PI_PMD_STS0r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS0r
#define WRITEALL_TX_PI_PMD_STS0r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_STS1
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0a9
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG1_REG TX PI integ1 register. Signed Value.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS1r (0x0001d0a9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_STS1.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_sts1[1];
	uint32_t _tx_pi_pmd_sts1;
} BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_CLR(r) (r).tx_pi_pmd_sts1[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_SET(r,d) (r).tx_pi_pmd_sts1[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_GET(r) (r).tx_pi_pmd_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_TX_PI_INTEG1_REGf_GET(r) (((r).tx_pi_pmd_sts1[0]) & 0x3fff)
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_TX_PI_INTEG1_REGf_SET(r,f) (r).tx_pi_pmd_sts1[0]=(((r).tx_pi_pmd_sts1[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access TX_PI_PMD_STS1.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS1r,(_r._tx_pi_pmd_sts1))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS1r,(_r._tx_pi_pmd_sts1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS1r,(_r._tx_pi_pmd_sts1))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts1))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts1))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_STS1r BCMI_FALCON_XGXS_TX_PI_PMD_STS1r
#define TX_PI_PMD_STS1r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_t TX_PI_PMD_STS1r_t;
#define TX_PI_PMD_STS1r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_CLR
#define TX_PI_PMD_STS1r_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_SET
#define TX_PI_PMD_STS1r_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_GET
#define TX_PI_PMD_STS1r_TX_PI_INTEG1_REGf_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_TX_PI_INTEG1_REGf_GET
#define TX_PI_PMD_STS1r_TX_PI_INTEG1_REGf_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS1r_TX_PI_INTEG1_REGf_SET
#define READ_TX_PI_PMD_STS1r BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS1r
#define WRITE_TX_PI_PMD_STS1r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS1r
#define MODIFY_TX_PI_PMD_STS1r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS1r
#define READLN_TX_PI_PMD_STS1r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS1r
#define WRITELN_TX_PI_PMD_STS1r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS1r
#define WRITEALL_TX_PI_PMD_STS1r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_STS2
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0aa
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_INTEG2_REG TX PI integ2 register. Signed Value. Once settled, it can provide the information of the ppm on the TX clock w.r.t. PLL/VCO clock.+8192 (-8192) is equal to +781.25 (-781.25) ppm which means tclk is slower (faster) w.r.t. PLL/VCO clock.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS2r (0x0001d0aa | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_STS2.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_sts2[1];
	uint32_t _tx_pi_pmd_sts2;
} BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_CLR(r) (r).tx_pi_pmd_sts2[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_SET(r,d) (r).tx_pi_pmd_sts2[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_GET(r) (r).tx_pi_pmd_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_TX_PI_INTEG2_REGf_GET(r) (((r).tx_pi_pmd_sts2[0]) & 0x7fff)
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_TX_PI_INTEG2_REGf_SET(r,f) (r).tx_pi_pmd_sts2[0]=(((r).tx_pi_pmd_sts2[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TX_PI_PMD_STS2.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS2r,(_r._tx_pi_pmd_sts2))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS2r,(_r._tx_pi_pmd_sts2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS2r,(_r._tx_pi_pmd_sts2))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts2))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts2))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_STS2r BCMI_FALCON_XGXS_TX_PI_PMD_STS2r
#define TX_PI_PMD_STS2r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_t TX_PI_PMD_STS2r_t;
#define TX_PI_PMD_STS2r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_CLR
#define TX_PI_PMD_STS2r_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_SET
#define TX_PI_PMD_STS2r_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_GET
#define TX_PI_PMD_STS2r_TX_PI_INTEG2_REGf_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_TX_PI_INTEG2_REGf_GET
#define TX_PI_PMD_STS2r_TX_PI_INTEG2_REGf_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS2r_TX_PI_INTEG2_REGf_SET
#define READ_TX_PI_PMD_STS2r BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS2r
#define WRITE_TX_PI_PMD_STS2r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS2r
#define MODIFY_TX_PI_PMD_STS2r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS2r
#define READLN_TX_PI_PMD_STS2r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS2r
#define WRITELN_TX_PI_PMD_STS2r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS2r
#define WRITEALL_TX_PI_PMD_STS2r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_PI_PMD_STS3
 * BLOCKS:   TX_PI_PMD_COM
 * REGADDR:  0xd0ab
 * DEVAD:    1
 * DESC:     TX Phase Interpolator Status 3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     TX_PI_PHASE_ERR  TX PI Phase Error. Signed Value. Valid values are -8 to +8.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS3r (0x0001d0ab | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TX_PI_PMD_STS3.
 */
typedef union BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_s {
	uint32_t v[1];
	uint32_t tx_pi_pmd_sts3[1];
	uint32_t _tx_pi_pmd_sts3;
} BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_t;

#define BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_CLR(r) (r).tx_pi_pmd_sts3[0] = 0
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_SET(r,d) (r).tx_pi_pmd_sts3[0] = d
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_GET(r) (r).tx_pi_pmd_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_TX_PI_PHASE_ERRf_GET(r) (((r).tx_pi_pmd_sts3[0]) & 0x3f)
#define BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_TX_PI_PHASE_ERRf_SET(r,f) (r).tx_pi_pmd_sts3[0]=(((r).tx_pi_pmd_sts3[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_PI_PMD_STS3.
 */
#define BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS3r,(_r._tx_pi_pmd_sts3))
#define BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS3r,(_r._tx_pi_pmd_sts3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS3r,(_r._tx_pi_pmd_sts3))
#define BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts3))
#define BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_pi_pmd_sts3))
#define BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_PI_PMD_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_pi_pmd_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_PI_PMD_STS3r BCMI_FALCON_XGXS_TX_PI_PMD_STS3r
#define TX_PI_PMD_STS3r_SIZE BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_SIZE
typedef BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_t TX_PI_PMD_STS3r_t;
#define TX_PI_PMD_STS3r_CLR BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_CLR
#define TX_PI_PMD_STS3r_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_SET
#define TX_PI_PMD_STS3r_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_GET
#define TX_PI_PMD_STS3r_TX_PI_PHASE_ERRf_GET BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_TX_PI_PHASE_ERRf_GET
#define TX_PI_PMD_STS3r_TX_PI_PHASE_ERRf_SET BCMI_FALCON_XGXS_TX_PI_PMD_STS3r_TX_PI_PHASE_ERRf_SET
#define READ_TX_PI_PMD_STS3r BCMI_FALCON_XGXS_READ_TX_PI_PMD_STS3r
#define WRITE_TX_PI_PMD_STS3r BCMI_FALCON_XGXS_WRITE_TX_PI_PMD_STS3r
#define MODIFY_TX_PI_PMD_STS3r BCMI_FALCON_XGXS_MODIFY_TX_PI_PMD_STS3r
#define READLN_TX_PI_PMD_STS3r BCMI_FALCON_XGXS_READLN_TX_PI_PMD_STS3r
#define WRITELN_TX_PI_PMD_STS3r BCMI_FALCON_XGXS_WRITELN_TX_PI_PMD_STS3r
#define WRITEALL_TX_PI_PMD_STS3r BCMI_FALCON_XGXS_WRITEALL_TX_PI_PMD_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_PI_PMD_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_OSR_MODE_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b0
 * DEVAD:    1
 * DESC:     OSR_MODE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     OSR_MODE_FRC_VAL oversample (OS) mode
 *     OSR_MODE_FRC     oversample (OS) mode force. Setting this bit will allow the register value to be used for OS mode.Othersise, the pin input values are used for OS mode
 */
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr (0x0001d0b0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_OSR_MODE_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_osr_mode_ctl[1];
	uint32_t _ckrst_osr_mode_ctl;
} BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_CLR(r) (r).ckrst_osr_mode_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_SET(r,d) (r).ckrst_osr_mode_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_GET(r) (r).ckrst_osr_mode_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_GET(r) ((((r).ckrst_osr_mode_ctl[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_SET(r,f) (r).ckrst_osr_mode_ctl[0]=(((r).ckrst_osr_mode_ctl[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET(r) (((r).ckrst_osr_mode_ctl[0]) & 0xf)
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET(r,f) (r).ckrst_osr_mode_ctl[0]=(((r).ckrst_osr_mode_ctl[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CKRST_OSR_MODE_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr,(_r._ckrst_osr_mode_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr,(_r._ckrst_osr_mode_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr,(_r._ckrst_osr_mode_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_OSR_MODE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_OSR_MODE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_osr_mode_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_OSR_MODE_CTLr BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr
#define CKRST_OSR_MODE_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_t CKRST_OSR_MODE_CTLr_t;
#define CKRST_OSR_MODE_CTLr_CLR BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_CLR
#define CKRST_OSR_MODE_CTLr_SET BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_SET
#define CKRST_OSR_MODE_CTLr_GET BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_GET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_GET BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_GET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_SET BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRCf_SET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_GET
#define CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr_OSR_MODE_FRC_VALf_SET
#define READ_CKRST_OSR_MODE_CTLr BCMI_FALCON_XGXS_READ_CKRST_OSR_MODE_CTLr
#define WRITE_CKRST_OSR_MODE_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_OSR_MODE_CTLr
#define MODIFY_CKRST_OSR_MODE_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_OSR_MODE_CTLr
#define READLN_CKRST_OSR_MODE_CTLr BCMI_FALCON_XGXS_READLN_CKRST_OSR_MODE_CTLr
#define WRITELN_CKRST_OSR_MODE_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_OSR_MODE_CTLr
#define WRITEALL_CKRST_OSR_MODE_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_OSR_MODE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_OSR_MODE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_CLK_RST_N_PWRDWN_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b1
 * DEVAD:    1
 * DESC:     LANE_CLK_RESET_N_POWERDOWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_DP_S_RSTB     Active Low Lane Soft Reset for datapath. If asserted by writing to 1'b0 will reset the datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_dp_h_rstb_i.
 *     LN_RX_S_PWRDN    Active High Power Down control for RX Lane.If asserted by writing to 1'b1 will power down the RX Lane.
 *     LN_TX_S_PWRDN    Active High Power Down control for TX Lane.If asserted by writing to 1'b1 will power down the TX Lane.
 *     AFE_SIGDET_PWRDN Power Down for Signal Detect. 1=power down
 */
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr (0x0001d0b1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_CLK_RST_N_PWRDWN_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_clk_rst_n_pwrdwn_ctl[1];
	uint32_t _ckrst_ln_clk_rst_n_pwrdwn_ctl;
} BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_CLR(r) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SET(r,d) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_GET(r) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET(r) ((((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET(r,f) (r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0]=(((r).ckrst_ln_clk_rst_n_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access CKRST_LN_CLK_RST_N_PWRDWN_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_CLK_RST_N_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_clk_rst_n_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_t CKRST_LN_CLK_RST_N_PWRDWN_CTLr_t;
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_CLR BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_CLR
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_GET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_AFE_SIGDET_PWRDNf_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_TX_S_PWRDNf_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_RX_S_PWRDNf_SET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_GET
#define CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr_LN_DP_S_RSTBf_SET
#define READ_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_FALCON_XGXS_READ_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITE_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define MODIFY_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define READLN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_FALCON_XGXS_READLN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITELN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_CLK_RST_N_PWRDWN_CTLr
#define WRITEALL_CKRST_LN_CLK_RST_N_PWRDWN_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_CLK_RST_N_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_CLK_RST_N_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_AFE_RST_PWRDWN_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b2
 * DEVAD:    1
 * DESC:     LANE_AFE_RESET_PWRDWN_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_RX_PWRDN_FRC AFE RX Lane powerdown force.
 *     AFE_RX_PWRDN_FRC_VAL AFE RX Lane powerdown force value.
 *     AFE_RX_RESET_FRC AFE RX Lane reset force.
 *     AFE_RX_RESET_FRC_VAL AFE RX Lane reset force value.
 *     AFE_TX_PWRDN_FRC AFE TX Lane powerdown force.
 *     AFE_TX_PWRDN_FRC_VAL AFE TX Lane powerdown force value.
 *     AFE_TX_RESET_FRC AFE TX Lane reset force.
 *     AFE_TX_RESET_FRC_VAL AFE TX Lane reset force value.
 *     AFE_RX_RCLK20_PWRDN_FRC AFE RX Lane rx_rclk20_pwrdwn force.
 *     AFE_RX_RCLK20_PWRDN_FRC_VAL AFE RX Lane rx_rclk20_pwrdwn force value.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr (0x0001d0b2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_AFE_RST_PWRDWN_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_afe_rst_pwrdwn_ctl[1];
	uint32_t _ckrst_ln_afe_rst_pwrdwn_ctl;
} BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_CLR(r) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_SET(r,d) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_GET(r) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRCf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRCf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRCf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRC_VALf_GET(r) ((((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRC_VALf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRCf_GET(r) (((r).ckrst_ln_afe_rst_pwrdwn_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRCf_SET(r,f) (r).ckrst_ln_afe_rst_pwrdwn_ctl[0]=(((r).ckrst_ln_afe_rst_pwrdwn_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_LN_AFE_RST_PWRDWN_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_AFE_RST_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr,(_r._ckrst_ln_afe_rst_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_AFE_RST_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr,(_r._ckrst_ln_afe_rst_pwrdwn_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_AFE_RST_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr,(_r._ckrst_ln_afe_rst_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_AFE_RST_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_afe_rst_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_AFE_RST_PWRDWN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_afe_rst_pwrdwn_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_AFE_RST_PWRDWN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_afe_rst_pwrdwn_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_AFE_RST_PWRDWN_CTLr BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_t CKRST_LN_AFE_RST_PWRDWN_CTLr_t;
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_CLR BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_CLR
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RCLK20_PWRDN_FRCf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRC_VALf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRC_VALf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRCf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRCf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_RESET_FRCf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRC_VALf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRC_VALf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRCf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRCf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_TX_PWRDN_FRCf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRC_VALf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRC_VALf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRCf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRCf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_RESET_FRCf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRC_VALf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRC_VALf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRC_VALf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRC_VALf_SET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRCf_GET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRCf_GET
#define CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRCf_SET BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr_AFE_RX_PWRDN_FRCf_SET
#define READ_CKRST_LN_AFE_RST_PWRDWN_CTLr BCMI_FALCON_XGXS_READ_CKRST_LN_AFE_RST_PWRDWN_CTLr
#define WRITE_CKRST_LN_AFE_RST_PWRDWN_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_LN_AFE_RST_PWRDWN_CTLr
#define MODIFY_CKRST_LN_AFE_RST_PWRDWN_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_AFE_RST_PWRDWN_CTLr
#define READLN_CKRST_LN_AFE_RST_PWRDWN_CTLr BCMI_FALCON_XGXS_READLN_CKRST_LN_AFE_RST_PWRDWN_CTLr
#define WRITELN_CKRST_LN_AFE_RST_PWRDWN_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_AFE_RST_PWRDWN_CTLr
#define WRITEALL_CKRST_LN_AFE_RST_PWRDWN_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_AFE_RST_PWRDWN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_AFE_RST_PWRDWN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_RST_N_PWRDN_PIN_KILL_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b3
 * DEVAD:    1
 * DESC:     LANE_RESET_N_PWRDN_PIN_KILL_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_LN_H_RSTB_PKILL 1'b1 will disable the pmd_ln_h_rstb input pin.
 *     PMD_LN_DP_H_RSTB_PKILL 1'b1 will disable the pmd_ln_dp_h_rstb input pin.
 *     PMD_LN_RX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_rx_h_pwrdn input pin.
 *     PMD_LN_TX_H_PWRDN_PKILL 1'b1 will disable the pmd_ln_tx_h_pwrdn input pin.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr (0x0001d0b3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_rst_n_pwrdn_pin_kill_ctl[1];
	uint32_t _ckrst_ln_rst_n_pwrdn_pin_kill_ctl;
} BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR(r) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET(r,d) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET(r) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET(r) ((((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET(r) ((((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET(r) ((((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET(r) (((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET(r,f) (r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0]=(((r).ckrst_ln_rst_n_pwrdn_pin_kill_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_LN_RST_N_PWRDN_PIN_KILL_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_rst_n_pwrdn_pin_kill_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_t CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_t;
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_CLR
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_TX_H_PWRDN_PKILLf_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_RX_H_PWRDN_PKILLf_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_DP_H_RSTB_PKILLf_SET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_GET
#define CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr_PMD_LN_H_RSTB_PKILLf_SET
#define READ_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_FALCON_XGXS_READ_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITE_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define MODIFY_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define READLN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_FALCON_XGXS_READLN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITELN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr
#define WRITEALL_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_RST_N_PWRDN_PIN_KILL_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_DBG_RST_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b4
 * DEVAD:    1
 * DESC:     LANE_DEBUG_RESET_CONTROL
 * RESETVAL: 0x303 (771)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_RSTB     Active Low Lane Soft Reset for RX datapath and registers. If asserted by writing to 1'b0 will reset the RX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_RX_DP_S_RSTB  Active Low Lane Soft Reset for RX datapath. If asserted by writing to 1'b0 will reset the RX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     SIGDET_DP_RSTB_EN If asserted by writing to 1'b1 then lane datapath reset will also reset the sigdet filetr logic alomg with lane register reset.
 *     LN_TX_S_RSTB     Active Low Lane Soft Reset for TX datapath and registers. If asserted by writing to 1'b0 will reset the TX registers and datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 *     LN_TX_DP_S_RSTB  Active Low Lane Soft Reset for TX datapath. If asserted by writing to 1'b0 will reset the TX datapath for a lane.This is a debug only register and it is not handled by FW-HW handshake
 */
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr (0x0001d0b4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_DBG_RST_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_dbg_rst_ctl[1];
	uint32_t _ckrst_ln_dbg_rst_ctl;
} BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_CLR(r) (r).ckrst_ln_dbg_rst_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SET(r,d) (r).ckrst_ln_dbg_rst_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_GET(r) (r).ckrst_ln_dbg_rst_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET(r) ((((r).ckrst_ln_dbg_rst_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET(r) (((r).ckrst_ln_dbg_rst_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET(r,f) (r).ckrst_ln_dbg_rst_ctl[0]=(((r).ckrst_ln_dbg_rst_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_LN_DBG_RST_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr,(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr,(_r._ckrst_ln_dbg_rst_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr,(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_DBG_RST_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dbg_rst_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_DBG_RST_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_dbg_rst_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_DBG_RST_CTLr BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr
#define CKRST_LN_DBG_RST_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_t CKRST_LN_DBG_RST_CTLr_t;
#define CKRST_LN_DBG_RST_CTLr_CLR BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_CLR
#define CKRST_LN_DBG_RST_CTLr_SET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SET
#define CKRST_LN_DBG_RST_CTLr_GET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_GET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_DP_S_RSTBf_SET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_TX_S_RSTBf_SET
#define CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_GET
#define CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_SIGDET_DP_RSTB_ENf_SET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_DP_S_RSTBf_SET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_GET
#define CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr_LN_RX_S_RSTBf_SET
#define READ_CKRST_LN_DBG_RST_CTLr BCMI_FALCON_XGXS_READ_CKRST_LN_DBG_RST_CTLr
#define WRITE_CKRST_LN_DBG_RST_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_LN_DBG_RST_CTLr
#define MODIFY_CKRST_LN_DBG_RST_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_DBG_RST_CTLr
#define READLN_CKRST_LN_DBG_RST_CTLr BCMI_FALCON_XGXS_READLN_CKRST_LN_DBG_RST_CTLr
#define WRITELN_CKRST_LN_DBG_RST_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_DBG_RST_CTLr
#define WRITEALL_CKRST_LN_DBG_RST_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_DBG_RST_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_DBG_RST_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_UC_ACK_LN_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b5
 * DEVAD:    1
 * DESC:     UC_ACK_LANE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_LANE_CFG_DONE uC will write this to 1 to indicate it's configuration of the lane is complete. Writing to 1'b1 willshould release internal hold on lane_dp_reset, only if lane_dp_reset_state is 3'b001.
 *     UC_ACK_LANE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "lane_dp_reset_coccured".
 */
#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr (0x0001d0b5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_UC_ACK_LN_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_uc_ack_ln_ctl[1];
	uint32_t _ckrst_uc_ack_ln_ctl;
} BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_CLR(r) (r).ckrst_uc_ack_ln_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_SET(r,d) (r).ckrst_uc_ack_ln_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_GET(r) (r).ckrst_uc_ack_ln_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET(r) ((((r).ckrst_uc_ack_ln_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET(r,f) (r).ckrst_uc_ack_ln_ctl[0]=(((r).ckrst_uc_ack_ln_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET(r) (((r).ckrst_uc_ack_ln_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET(r,f) (r).ckrst_uc_ack_ln_ctl[0]=(((r).ckrst_uc_ack_ln_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_UC_ACK_LN_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr,(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr,(_r._ckrst_uc_ack_ln_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr,(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_UC_ACK_LN_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_uc_ack_ln_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_UC_ACK_LN_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_uc_ack_ln_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_UC_ACK_LN_CTLr BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr
#define CKRST_UC_ACK_LN_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_t CKRST_UC_ACK_LN_CTLr_t;
#define CKRST_UC_ACK_LN_CTLr_CLR BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_CLR
#define CKRST_UC_ACK_LN_CTLr_SET BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_SET
#define CKRST_UC_ACK_LN_CTLr_GET BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_GET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_GET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_DP_RESETf_SET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_GET
#define CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr_UC_ACK_LANE_CFG_DONEf_SET
#define READ_CKRST_UC_ACK_LN_CTLr BCMI_FALCON_XGXS_READ_CKRST_UC_ACK_LN_CTLr
#define WRITE_CKRST_UC_ACK_LN_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_UC_ACK_LN_CTLr
#define MODIFY_CKRST_UC_ACK_LN_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_UC_ACK_LN_CTLr
#define READLN_CKRST_UC_ACK_LN_CTLr BCMI_FALCON_XGXS_READLN_CKRST_UC_ACK_LN_CTLr
#define WRITELN_CKRST_UC_ACK_LN_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_UC_ACK_LN_CTLr
#define WRITEALL_CKRST_UC_ACK_LN_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_UC_ACK_LN_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_UC_ACK_LN_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_RST_OCC_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b6
 * DEVAD:    1
 * DESC:     LANE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_REG_RESET_OCCURRED Set to 1'b1 upon lane level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr (0x0001d0b6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_RST_OCC_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_rst_occ_ctl[1];
	uint32_t _ckrst_ln_rst_occ_ctl;
} BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_CLR(r) (r).ckrst_ln_rst_occ_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_SET(r,d) (r).ckrst_ln_rst_occ_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_GET(r) (r).ckrst_ln_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET(r) (((r).ckrst_ln_rst_occ_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET(r,f) (r).ckrst_ln_rst_occ_ctl[0]=(((r).ckrst_ln_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_LN_RST_OCC_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr,(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr,(_r._ckrst_ln_rst_occ_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr,(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_rst_occ_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_RST_OCC_CTLr BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr
#define CKRST_LN_RST_OCC_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_t CKRST_LN_RST_OCC_CTLr_t;
#define CKRST_LN_RST_OCC_CTLr_CLR BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_CLR
#define CKRST_LN_RST_OCC_CTLr_SET BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_SET
#define CKRST_LN_RST_OCC_CTLr_GET BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_GET
#define CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_GET
#define CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr_LANE_REG_RESET_OCCURREDf_SET
#define READ_CKRST_LN_RST_OCC_CTLr BCMI_FALCON_XGXS_READ_CKRST_LN_RST_OCC_CTLr
#define WRITE_CKRST_LN_RST_OCC_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_LN_RST_OCC_CTLr
#define MODIFY_CKRST_LN_RST_OCC_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_RST_OCC_CTLr
#define READLN_CKRST_LN_RST_OCC_CTLr BCMI_FALCON_XGXS_READLN_CKRST_LN_RST_OCC_CTLr
#define WRITELN_CKRST_LN_RST_OCC_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_RST_OCC_CTLr
#define WRITEALL_CKRST_LN_RST_OCC_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_CLK_N_RST_DBG_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b7
 * DEVAD:    1
 * DESC:     CLOCK_N_RESET_DEBUG_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_RX_S_CLKGATE_FRC_ON Active High Lane clock gate control for RX clock gator.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_clkgate_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_SEL Mux control for selection of comclk for RX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_sel is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     LN_RX_S_COMCLK_FRC_ON Mux control for selection of comclk for RX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_rx_clk_vld to 1'b0 while ln_rx_s_comclk_frc_on is asserted to 1'b1by using pmd_rx_clk_vld_frc/frc_val registers.
 *     PMD_RX_CLK_VLD_FRC pmd_rx_clk_vld core output pin force.
 *     PMD_RX_CLK_VLD_FRC_VAL pmd_rx_clk_vld core output pin force value.
 */
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr (0x0001d0b7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_CLK_N_RST_DBG_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_clk_n_rst_dbg_ctl[1];
	uint32_t _ckrst_clk_n_rst_dbg_ctl;
} BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_CLR(r) (r).ckrst_clk_n_rst_dbg_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SET(r,d) (r).ckrst_clk_n_rst_dbg_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_GET(r) (r).ckrst_clk_n_rst_dbg_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET(r) ((((r).ckrst_clk_n_rst_dbg_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET(r) (((r).ckrst_clk_n_rst_dbg_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET(r,f) (r).ckrst_clk_n_rst_dbg_ctl[0]=(((r).ckrst_clk_n_rst_dbg_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_CLK_N_RST_DBG_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr,(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr,(_r._ckrst_clk_n_rst_dbg_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr,(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_CLK_N_RST_DBG_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_clk_n_rst_dbg_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_CLK_N_RST_DBG_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_clk_n_rst_dbg_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_CLK_N_RST_DBG_CTLr BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr
#define CKRST_CLK_N_RST_DBG_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_t CKRST_CLK_N_RST_DBG_CTLr_t;
#define CKRST_CLK_N_RST_DBG_CTLr_CLR BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_CLR
#define CKRST_CLK_N_RST_DBG_CTLr_SET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_SET
#define CKRST_CLK_N_RST_DBG_CTLr_GET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_GET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRC_VALf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_PMD_RX_CLK_VLD_FRCf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_FRC_ONf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_COMCLK_SELf_SET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_GET
#define CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr_LN_RX_S_CLKGATE_FRC_ONf_SET
#define READ_CKRST_CLK_N_RST_DBG_CTLr BCMI_FALCON_XGXS_READ_CKRST_CLK_N_RST_DBG_CTLr
#define WRITE_CKRST_CLK_N_RST_DBG_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_CLK_N_RST_DBG_CTLr
#define MODIFY_CKRST_CLK_N_RST_DBG_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_CLK_N_RST_DBG_CTLr
#define READLN_CKRST_CLK_N_RST_DBG_CTLr BCMI_FALCON_XGXS_READLN_CKRST_CLK_N_RST_DBG_CTLr
#define WRITELN_CKRST_CLK_N_RST_DBG_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_CLK_N_RST_DBG_CTLr
#define WRITEALL_CKRST_CLK_N_RST_DBG_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_CLK_N_RST_DBG_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_CLK_N_RST_DBG_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_PMD_LN_MODE_STS
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b8
 * DEVAD:    1
 * DESC:     PMD_LANE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_LANE_MODE    This indicates the status of the core input pin pmd_lane_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr (0x0001d0b8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_PMD_LN_MODE_STS.
 */
typedef union BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_pmd_ln_mode_sts[1];
	uint32_t _ckrst_pmd_ln_mode_sts;
} BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_t;

#define BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_CLR(r) (r).ckrst_pmd_ln_mode_sts[0] = 0
#define BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_SET(r,d) (r).ckrst_pmd_ln_mode_sts[0] = d
#define BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_GET(r) (r).ckrst_pmd_ln_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET(r) (((r).ckrst_pmd_ln_mode_sts[0]) & 0xffff)
#define BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET(r,f) (r).ckrst_pmd_ln_mode_sts[0]=(((r).ckrst_pmd_ln_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access CKRST_PMD_LN_MODE_STS.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr,(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_FALCON_XGXS_WRITE_CKRST_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr,(_r._ckrst_pmd_ln_mode_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr,(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_FALCON_XGXS_READLN_CKRST_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_PMD_LN_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_pmd_ln_mode_sts))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_PMD_LN_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_pmd_ln_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_PMD_LN_MODE_STSr BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr
#define CKRST_PMD_LN_MODE_STSr_SIZE BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_t CKRST_PMD_LN_MODE_STSr_t;
#define CKRST_PMD_LN_MODE_STSr_CLR BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_CLR
#define CKRST_PMD_LN_MODE_STSr_SET BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_SET
#define CKRST_PMD_LN_MODE_STSr_GET BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_GET
#define CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_GET
#define CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr_PMD_LANE_MODEf_SET
#define READ_CKRST_PMD_LN_MODE_STSr BCMI_FALCON_XGXS_READ_CKRST_PMD_LN_MODE_STSr
#define WRITE_CKRST_PMD_LN_MODE_STSr BCMI_FALCON_XGXS_WRITE_CKRST_PMD_LN_MODE_STSr
#define MODIFY_CKRST_PMD_LN_MODE_STSr BCMI_FALCON_XGXS_MODIFY_CKRST_PMD_LN_MODE_STSr
#define READLN_CKRST_PMD_LN_MODE_STSr BCMI_FALCON_XGXS_READLN_CKRST_PMD_LN_MODE_STSr
#define WRITELN_CKRST_PMD_LN_MODE_STSr BCMI_FALCON_XGXS_WRITELN_CKRST_PMD_LN_MODE_STSr
#define WRITEALL_CKRST_PMD_LN_MODE_STSr BCMI_FALCON_XGXS_WRITEALL_CKRST_PMD_LN_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_PMD_LN_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_DP_RST_ST_STS
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0b9
 * DEVAD:    1
 * DESC:     LANE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     LANE_DP_RESET_STATE Bit 2: lane_dp_reset_active   : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls.Bit 1: lane_dp_reset_occurred : Set to 1'b1 whenenver lane_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: lane_dp_reset_held     : Set to 1'b1 whenenver lane_dp_reset is internally held. Cleared to 1'b0, only if lane_dp_reset_state==001 and uc_ack_lane_cfg_done == 1.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr (0x0001d0b9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_DP_RST_ST_STS.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_dp_rst_st_sts[1];
	uint32_t _ckrst_ln_dp_rst_st_sts;
} BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_CLR(r) (r).ckrst_ln_dp_rst_st_sts[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_SET(r,d) (r).ckrst_ln_dp_rst_st_sts[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_GET(r) (r).ckrst_ln_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET(r) (((r).ckrst_ln_dp_rst_st_sts[0]) & 0x7)
#define BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET(r,f) (r).ckrst_ln_dp_rst_st_sts[0]=(((r).ckrst_ln_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access CKRST_LN_DP_RST_ST_STS.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr,(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr,(_r._ckrst_ln_dp_rst_st_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr,(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_DP_RST_ST_STSr BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr
#define CKRST_LN_DP_RST_ST_STSr_SIZE BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_t CKRST_LN_DP_RST_ST_STSr_t;
#define CKRST_LN_DP_RST_ST_STSr_CLR BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_CLR
#define CKRST_LN_DP_RST_ST_STSr_SET BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_SET
#define CKRST_LN_DP_RST_ST_STSr_GET BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_GET
#define CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_GET
#define CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr_LANE_DP_RESET_STATEf_SET
#define READ_CKRST_LN_DP_RST_ST_STSr BCMI_FALCON_XGXS_READ_CKRST_LN_DP_RST_ST_STSr
#define WRITE_CKRST_LN_DP_RST_ST_STSr BCMI_FALCON_XGXS_WRITE_CKRST_LN_DP_RST_ST_STSr
#define MODIFY_CKRST_LN_DP_RST_ST_STSr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_DP_RST_ST_STSr
#define READLN_CKRST_LN_DP_RST_ST_STSr BCMI_FALCON_XGXS_READLN_CKRST_LN_DP_RST_ST_STSr
#define WRITELN_CKRST_LN_DP_RST_ST_STSr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_DP_RST_ST_STSr
#define WRITEALL_CKRST_LN_DP_RST_ST_STSr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_MASK
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0ba
 * DEVAD:    1
 * DESC:     LN_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_MASKr (0x0001d0ba | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_MASKr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_MASK.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_MASKr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_mask[1];
	uint32_t _ckrst_ln_mask;
} BCMI_FALCON_XGXS_CKRST_LN_MASKr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_MASKr_CLR(r) (r).ckrst_ln_mask[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_MASKr_SET(r,d) (r).ckrst_ln_mask[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_MASKr_GET(r) (r).ckrst_ln_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_MASKr_LANE_MULTICAST_MASK_CONTROLf_GET(r) (((r).ckrst_ln_mask[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_MASKr_LANE_MULTICAST_MASK_CONTROLf_SET(r,f) (r).ckrst_ln_mask[0]=(((r).ckrst_ln_mask[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_LN_MASK.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_MASKr,(_r._ckrst_ln_mask))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_MASKr,(_r._ckrst_ln_mask)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_MASKr,(_r._ckrst_ln_mask))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_MASKr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_mask))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_MASKr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_mask))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_MASKr BCMI_FALCON_XGXS_CKRST_LN_MASKr
#define CKRST_LN_MASKr_SIZE BCMI_FALCON_XGXS_CKRST_LN_MASKr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_MASKr_t CKRST_LN_MASKr_t;
#define CKRST_LN_MASKr_CLR BCMI_FALCON_XGXS_CKRST_LN_MASKr_CLR
#define CKRST_LN_MASKr_SET BCMI_FALCON_XGXS_CKRST_LN_MASKr_SET
#define CKRST_LN_MASKr_GET BCMI_FALCON_XGXS_CKRST_LN_MASKr_GET
#define CKRST_LN_MASKr_LANE_MULTICAST_MASK_CONTROLf_GET BCMI_FALCON_XGXS_CKRST_LN_MASKr_LANE_MULTICAST_MASK_CONTROLf_GET
#define CKRST_LN_MASKr_LANE_MULTICAST_MASK_CONTROLf_SET BCMI_FALCON_XGXS_CKRST_LN_MASKr_LANE_MULTICAST_MASK_CONTROLf_SET
#define READ_CKRST_LN_MASKr BCMI_FALCON_XGXS_READ_CKRST_LN_MASKr
#define WRITE_CKRST_LN_MASKr BCMI_FALCON_XGXS_WRITE_CKRST_LN_MASKr
#define MODIFY_CKRST_LN_MASKr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_MASKr
#define READLN_CKRST_LN_MASKr BCMI_FALCON_XGXS_READLN_CKRST_LN_MASKr
#define WRITELN_CKRST_LN_MASKr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_MASKr
#define WRITEALL_CKRST_LN_MASKr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_OSR_MODE_STS
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0bb
 * DEVAD:    1
 * DESC:     OSR_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     OSR_MODE         OSR Mode status after the mux.
 */
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr (0x0001d0bb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_OSR_MODE_STS.
 */
typedef union BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_osr_mode_sts[1];
	uint32_t _ckrst_osr_mode_sts;
} BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_t;

#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_CLR(r) (r).ckrst_osr_mode_sts[0] = 0
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_SET(r,d) (r).ckrst_osr_mode_sts[0] = d
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_GET(r) (r).ckrst_osr_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_GET(r) (((r).ckrst_osr_mode_sts[0]) & 0xf)
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_SET(r,f) (r).ckrst_osr_mode_sts[0]=(((r).ckrst_osr_mode_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CKRST_OSR_MODE_STS.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_OSR_MODE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr,(_r._ckrst_osr_mode_sts))
#define BCMI_FALCON_XGXS_WRITE_CKRST_OSR_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr,(_r._ckrst_osr_mode_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_OSR_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr,(_r._ckrst_osr_mode_sts))
#define BCMI_FALCON_XGXS_READLN_CKRST_OSR_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_sts))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_OSR_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_sts))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_OSR_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_osr_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_OSR_MODE_STSr BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr
#define CKRST_OSR_MODE_STSr_SIZE BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_t CKRST_OSR_MODE_STSr_t;
#define CKRST_OSR_MODE_STSr_CLR BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_CLR
#define CKRST_OSR_MODE_STSr_SET BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_SET
#define CKRST_OSR_MODE_STSr_GET BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_GET
#define CKRST_OSR_MODE_STSr_OSR_MODEf_GET BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_GET
#define CKRST_OSR_MODE_STSr_OSR_MODEf_SET BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr_OSR_MODEf_SET
#define READ_CKRST_OSR_MODE_STSr BCMI_FALCON_XGXS_READ_CKRST_OSR_MODE_STSr
#define WRITE_CKRST_OSR_MODE_STSr BCMI_FALCON_XGXS_WRITE_CKRST_OSR_MODE_STSr
#define MODIFY_CKRST_OSR_MODE_STSr BCMI_FALCON_XGXS_MODIFY_CKRST_OSR_MODE_STSr
#define READLN_CKRST_OSR_MODE_STSr BCMI_FALCON_XGXS_READLN_CKRST_OSR_MODE_STSr
#define WRITELN_CKRST_OSR_MODE_STSr BCMI_FALCON_XGXS_WRITELN_CKRST_OSR_MODE_STSr
#define WRITEALL_CKRST_OSR_MODE_STSr BCMI_FALCON_XGXS_WRITEALL_CKRST_OSR_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_OSR_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_OSR_MODE_PIN_STS
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0bc
 * DEVAD:    1
 * DESC:     OSR_MODE_PIN_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     OSR_MODE_PIN     Indicates the status of the pmd_osr_mode input pin.Decoding of pmd_osr_mode[3:0] pin and osr_mode registers are as follows.OSX1          4'd0OSX2          4'd1OSX4          4'd2OSX16P5       4'd8OSX20P625     4'd12
 */
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr (0x0001d0bc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_OSR_MODE_PIN_STS.
 */
typedef union BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_s {
	uint32_t v[1];
	uint32_t ckrst_osr_mode_pin_sts[1];
	uint32_t _ckrst_osr_mode_pin_sts;
} BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_t;

#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_CLR(r) (r).ckrst_osr_mode_pin_sts[0] = 0
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_SET(r,d) (r).ckrst_osr_mode_pin_sts[0] = d
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_GET(r) (r).ckrst_osr_mode_pin_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET(r) (((r).ckrst_osr_mode_pin_sts[0]) & 0xf)
#define BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET(r,f) (r).ckrst_osr_mode_pin_sts[0]=(((r).ckrst_osr_mode_pin_sts[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access CKRST_OSR_MODE_PIN_STS.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr,(_r._ckrst_osr_mode_pin_sts))
#define BCMI_FALCON_XGXS_WRITE_CKRST_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr,(_r._ckrst_osr_mode_pin_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr,(_r._ckrst_osr_mode_pin_sts))
#define BCMI_FALCON_XGXS_READLN_CKRST_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_pin_sts))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_OSR_MODE_PIN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_osr_mode_pin_sts))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_OSR_MODE_PIN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_osr_mode_pin_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_OSR_MODE_PIN_STSr BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr
#define CKRST_OSR_MODE_PIN_STSr_SIZE BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_t CKRST_OSR_MODE_PIN_STSr_t;
#define CKRST_OSR_MODE_PIN_STSr_CLR BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_CLR
#define CKRST_OSR_MODE_PIN_STSr_SET BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_SET
#define CKRST_OSR_MODE_PIN_STSr_GET BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_GET
#define CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_GET
#define CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr_OSR_MODE_PINf_SET
#define READ_CKRST_OSR_MODE_PIN_STSr BCMI_FALCON_XGXS_READ_CKRST_OSR_MODE_PIN_STSr
#define WRITE_CKRST_OSR_MODE_PIN_STSr BCMI_FALCON_XGXS_WRITE_CKRST_OSR_MODE_PIN_STSr
#define MODIFY_CKRST_OSR_MODE_PIN_STSr BCMI_FALCON_XGXS_MODIFY_CKRST_OSR_MODE_PIN_STSr
#define READLN_CKRST_OSR_MODE_PIN_STSr BCMI_FALCON_XGXS_READLN_CKRST_OSR_MODE_PIN_STSr
#define WRITELN_CKRST_OSR_MODE_PIN_STSr BCMI_FALCON_XGXS_WRITELN_CKRST_OSR_MODE_PIN_STSr
#define WRITEALL_CKRST_OSR_MODE_PIN_STSr BCMI_FALCON_XGXS_WRITEALL_CKRST_OSR_MODE_PIN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_OSR_MODE_PIN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  CKRST_LN_S_RSTB_CTL
 * BLOCKS:   CKRST_CTRL_PMD
 * REGADDR:  0xd0be
 * DEVAD:    1
 * DESC:     LN_S_RSTB_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     LN_S_RSTB        Active Low Lane Soft Reset. If asserted by writing to 1'b0 will reset the registers and datapath for a lane.This soft reset is equivalent to the hard reset input pin pmd_ln_h_rstb_i.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr (0x0001d0be | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_SIZE 4

/*
 * This structure should be used to declare and program CKRST_LN_S_RSTB_CTL.
 */
typedef union BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_s {
	uint32_t v[1];
	uint32_t ckrst_ln_s_rstb_ctl[1];
	uint32_t _ckrst_ln_s_rstb_ctl;
} BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_t;

#define BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_CLR(r) (r).ckrst_ln_s_rstb_ctl[0] = 0
#define BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_SET(r,d) (r).ckrst_ln_s_rstb_ctl[0] = d
#define BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_GET(r) (r).ckrst_ln_s_rstb_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_GET(r) (((r).ckrst_ln_s_rstb_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_SET(r,f) (r).ckrst_ln_s_rstb_ctl[0]=(((r).ckrst_ln_s_rstb_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access CKRST_LN_S_RSTB_CTL.
 */
#define BCMI_FALCON_XGXS_READ_CKRST_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr,(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_FALCON_XGXS_WRITE_CKRST_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr,(_r._ckrst_ln_s_rstb_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_CKRST_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr,(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_FALCON_XGXS_READLN_CKRST_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_FALCON_XGXS_WRITELN_CKRST_LN_S_RSTB_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ckrst_ln_s_rstb_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_S_RSTB_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ckrst_ln_s_rstb_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define CKRST_LN_S_RSTB_CTLr BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr
#define CKRST_LN_S_RSTB_CTLr_SIZE BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_SIZE
typedef BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_t CKRST_LN_S_RSTB_CTLr_t;
#define CKRST_LN_S_RSTB_CTLr_CLR BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_CLR
#define CKRST_LN_S_RSTB_CTLr_SET BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_SET
#define CKRST_LN_S_RSTB_CTLr_GET BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_GET
#define CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_GET BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_GET
#define CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_SET BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr_LN_S_RSTBf_SET
#define READ_CKRST_LN_S_RSTB_CTLr BCMI_FALCON_XGXS_READ_CKRST_LN_S_RSTB_CTLr
#define WRITE_CKRST_LN_S_RSTB_CTLr BCMI_FALCON_XGXS_WRITE_CKRST_LN_S_RSTB_CTLr
#define MODIFY_CKRST_LN_S_RSTB_CTLr BCMI_FALCON_XGXS_MODIFY_CKRST_LN_S_RSTB_CTLr
#define READLN_CKRST_LN_S_RSTB_CTLr BCMI_FALCON_XGXS_READLN_CKRST_LN_S_RSTB_CTLr
#define WRITELN_CKRST_LN_S_RSTB_CTLr BCMI_FALCON_XGXS_WRITELN_CKRST_LN_S_RSTB_CTLr
#define WRITEALL_CKRST_LN_S_RSTB_CTLr BCMI_FALCON_XGXS_WRITEALL_CKRST_LN_S_RSTB_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_CKRST_LN_S_RSTB_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL0
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c0
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_0
 * RESETVAL: 0x10 (16)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_MASTER_DIODES_IBIAS master diodes ibias (max, mode, min)
 *     AMS_RX_SIGDET_THRESHOLD NA. Please use afe_sigdet_thresh from sigdet module.
 *     AMS_RX_SIGDET_PWRDN default=0 for enable signal detector
 *     AMS_RX_SIGDET_BYPASS force sigdet output = 1
 *     AMS_RX_TPORT_EN  output rx_rclk20 to PLL test port
 *     AMS_RX_VGA_10G_BW enables lower freq EQ peaking used in 10G mode
 *     AMS_RX_EQ_LZ_EN  DFE summer and buffer for non-DFE modes
 *     AMS_RX_DFE_HGAIN_EN enables high, fixed gain for the DFE summer and buffer.
 *     AMS_RX_DC_COUPLE for QSGMII DC mode with 50 Ohm pull-up to RVDD1p0
 *     AMS_RX_PEAKING_FILTER_IBIAS peaking filter ibias (max, mode, min)
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r (0x0001d0c0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL0.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl0[1];
	uint32_t _ams_rx_ctl0;
} BCMI_FALCON_XGXS_AMS_RX_CTL0r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_CLR(r) (r).ams_rx_ctl0[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_SET(r,d) (r).ams_rx_ctl0[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_GET(r) (r).ams_rx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET(r) ((((r).ams_rx_ctl0[0]) >> 13) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_GET(r) ((((r).ams_rx_ctl0[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET(r) ((((r).ams_rx_ctl0[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET(r) ((((r).ams_rx_ctl0[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET(r) ((((r).ams_rx_ctl0[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_GET(r) ((((r).ams_rx_ctl0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET(r) ((((r).ams_rx_ctl0[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET(r) ((((r).ams_rx_ctl0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET(r) ((((r).ams_rx_ctl0[0]) >> 3) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET(r) (((r).ams_rx_ctl0[0]) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET(r,f) (r).ams_rx_ctl0[0]=(((r).ams_rx_ctl0[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL0r,(_r._ams_rx_ctl0))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL0r,(_r._ams_rx_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL0r,(_r._ams_rx_ctl0))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL0r BCMI_FALCON_XGXS_AMS_RX_CTL0r
#define AMS_RX_CTL0r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL0r_t AMS_RX_CTL0r_t;
#define AMS_RX_CTL0r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL0r_CLR
#define AMS_RX_CTL0r_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_SET
#define AMS_RX_CTL0r_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_GET
#define AMS_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_GET
#define AMS_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_PEAKING_FILTER_IBIASf_SET
#define AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_GET
#define AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DC_COUPLEf_SET
#define AMS_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_GET
#define AMS_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_DFE_HGAIN_ENf_SET
#define AMS_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_EQ_LZ_ENf_GET
#define AMS_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_EQ_LZ_ENf_SET
#define AMS_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_10G_BWf_GET
#define AMS_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_VGA_10G_BWf_SET
#define AMS_RX_CTL0r_AMS_RX_TPORT_ENf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_GET
#define AMS_RX_CTL0r_AMS_RX_TPORT_ENf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_TPORT_ENf_SET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_GET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_BYPASSf_SET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_GET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_PWRDNf_SET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_GET
#define AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_SIGDET_THRESHOLDf_SET
#define AMS_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_GET
#define AMS_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL0r_AMS_RX_MASTER_DIODES_IBIASf_SET
#define READ_AMS_RX_CTL0r BCMI_FALCON_XGXS_READ_AMS_RX_CTL0r
#define WRITE_AMS_RX_CTL0r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL0r
#define MODIFY_AMS_RX_CTL0r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL0r
#define READLN_AMS_RX_CTL0r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL0r
#define WRITELN_AMS_RX_CTL0r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL0r
#define WRITEALL_AMS_RX_CTL0r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL1
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c1
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_SPARE_16  ams rx reserved [16]
 *     AMS_RX_VGA0_IBIAS VGA0 ibias (max, mode, min)
 *     AMS_RX_VGA1_IBIAS VGA1 ibias (max, mode, min)
 *     AMS_RX_VGA2_IBIAS VGA2 ibias (max, mode, min)
 *     AMS_RX_VGA3_IBIAS VGA3 ibias (max, mode, min)
 *     AMS_RX_CM_VOLTAGE_IBIAS input CM voltage ibias (max, mode, min)
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r (0x0001d0c1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL1.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl1[1];
	uint32_t _ams_rx_ctl1;
} BCMI_FALCON_XGXS_AMS_RX_CTL1r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_CLR(r) (r).ams_rx_ctl1[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_SET(r,d) (r).ams_rx_ctl1[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_GET(r) (r).ams_rx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET(r) ((((r).ams_rx_ctl1[0]) >> 13) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x7 << 13)) | ((((uint32_t)f) & 0x7) << 13)) | (7 << (16 + 13))
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA3_IBIASf_GET(r) ((((r).ams_rx_ctl1[0]) >> 10) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA3_IBIASf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x7 << 10)) | ((((uint32_t)f) & 0x7) << 10)) | (7 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET(r) ((((r).ams_rx_ctl1[0]) >> 7) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x7 << 7)) | ((((uint32_t)f) & 0x7) << 7)) | (7 << (16 + 7))
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET(r) ((((r).ams_rx_ctl1[0]) >> 4) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET(r) ((((r).ams_rx_ctl1[0]) >> 1) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_SPARE_16f_GET(r) (((r).ams_rx_ctl1[0]) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_SPARE_16f_SET(r,f) (r).ams_rx_ctl1[0]=(((r).ams_rx_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_RX_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL1r,(_r._ams_rx_ctl1))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL1r,(_r._ams_rx_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL1r,(_r._ams_rx_ctl1))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL1r BCMI_FALCON_XGXS_AMS_RX_CTL1r
#define AMS_RX_CTL1r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL1r_t AMS_RX_CTL1r_t;
#define AMS_RX_CTL1r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL1r_CLR
#define AMS_RX_CTL1r_SET BCMI_FALCON_XGXS_AMS_RX_CTL1r_SET
#define AMS_RX_CTL1r_GET BCMI_FALCON_XGXS_AMS_RX_CTL1r_GET
#define AMS_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_GET
#define AMS_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_CM_VOLTAGE_IBIASf_SET
#define AMS_RX_CTL1r_AMS_RX_VGA3_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA3_IBIASf_GET
#define AMS_RX_CTL1r_AMS_RX_VGA3_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA3_IBIASf_SET
#define AMS_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA2_IBIASf_GET
#define AMS_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA2_IBIASf_SET
#define AMS_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA1_IBIASf_GET
#define AMS_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA1_IBIASf_SET
#define AMS_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA0_IBIASf_GET
#define AMS_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_VGA0_IBIASf_SET
#define AMS_RX_CTL1r_AMS_RX_SPARE_16f_GET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_SPARE_16f_GET
#define AMS_RX_CTL1r_AMS_RX_SPARE_16f_SET BCMI_FALCON_XGXS_AMS_RX_CTL1r_AMS_RX_SPARE_16f_SET
#define READ_AMS_RX_CTL1r BCMI_FALCON_XGXS_READ_AMS_RX_CTL1r
#define WRITE_AMS_RX_CTL1r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL1r
#define MODIFY_AMS_RX_CTL1r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL1r
#define READLN_AMS_RX_CTL1r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL1r
#define WRITELN_AMS_RX_CTL1r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL1r
#define WRITEALL_AMS_RX_CTL1r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL2
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c2
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_2
 * RESETVAL: 0xe00 (3584)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_SIGDET_IBIAS signal detect ibias (max, mode, min)
 *     AMS_RX_PHASE_INTERPOLATORS_IBIAS phase interpolators ibias (max, mode, min)
 *     AMS_RX_DFE_TAP_WEIGHT_IBIAS DFE tap weight ibias (max, mode, min)
 *     AMS_RX_SEL_UGBW  unity gain buffer BW
 *     AMS_RX_SEL_TH4DFE DFE tap threshold voltage
 *     AMS_RX_PD_CH_P1  powers down the p1
 *     AMS_RX_SIGDET_POWER_SAVE see AMS
 *     AMS_RX_PWRDN_FTAP power down for floating taps
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r (0x0001d0c2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL2.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl2[1];
	uint32_t _ams_rx_ctl2;
} BCMI_FALCON_XGXS_AMS_RX_CTL2r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_CLR(r) (r).ams_rx_ctl2[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_SET(r,d) (r).ams_rx_ctl2[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_GET(r) (r).ams_rx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET(r) ((((r).ams_rx_ctl2[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_GET(r) ((((r).ams_rx_ctl2[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PD_CH_P1f_GET(r) ((((r).ams_rx_ctl2[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PD_CH_P1f_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET(r) ((((r).ams_rx_ctl2[0]) >> 11) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x3 << 11)) | ((((uint32_t)f) & 0x3) << 11)) | (3 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_GET(r) ((((r).ams_rx_ctl2[0]) >> 9) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET(r) ((((r).ams_rx_ctl2[0]) >> 6) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET(r) ((((r).ams_rx_ctl2[0]) >> 3) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET(r) (((r).ams_rx_ctl2[0]) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET(r,f) (r).ams_rx_ctl2[0]=(((r).ams_rx_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL2r,(_r._ams_rx_ctl2))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL2r,(_r._ams_rx_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL2r,(_r._ams_rx_ctl2))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL2r BCMI_FALCON_XGXS_AMS_RX_CTL2r
#define AMS_RX_CTL2r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL2r_t AMS_RX_CTL2r_t;
#define AMS_RX_CTL2r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL2r_CLR
#define AMS_RX_CTL2r_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_SET
#define AMS_RX_CTL2r_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_GET
#define AMS_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PWRDN_FTAPf_GET
#define AMS_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PWRDN_FTAPf_SET
#define AMS_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_GET
#define AMS_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_POWER_SAVEf_SET
#define AMS_RX_CTL2r_AMS_RX_PD_CH_P1f_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PD_CH_P1f_GET
#define AMS_RX_CTL2r_AMS_RX_PD_CH_P1f_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PD_CH_P1f_SET
#define AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_GET
#define AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_TH4DFEf_SET
#define AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_GET
#define AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SEL_UGBWf_SET
#define AMS_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_GET
#define AMS_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_DFE_TAP_WEIGHT_IBIASf_SET
#define AMS_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_GET
#define AMS_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_PHASE_INTERPOLATORS_IBIASf_SET
#define AMS_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_IBIASf_GET
#define AMS_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL2r_AMS_RX_SIGDET_IBIASf_SET
#define READ_AMS_RX_CTL2r BCMI_FALCON_XGXS_READ_AMS_RX_CTL2r
#define WRITE_AMS_RX_CTL2r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL2r
#define MODIFY_AMS_RX_CTL2r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL2r
#define READLN_AMS_RX_CTL2r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL2r
#define WRITELN_AMS_RX_CTL2r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL2r
#define WRITEALL_AMS_RX_CTL2r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL3
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c3
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_MET_R_IBIAS met R ibias (max, mode, min)
 *     AMS_RX_DLL_IBIAS DLL ibias (max, mode, min)
 *     AMS_RX_OFFSET_CORRECTION_IBIAS offset correction ibias (max, mode, min)
 *     AMS_RX_DFE_SUM_BUF_IBIAS DFE sum/buf ibias (max, mode, min)
 *     AMS_RX_DFE_SLICER_IBIAS dfe_slicer_ibias
 *     AMS_RX_SPARE_63  ams rx reserved[63]
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r (0x0001d0c3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL3.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl3[1];
	uint32_t _ams_rx_ctl3;
} BCMI_FALCON_XGXS_AMS_RX_CTL3r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_CLR(r) (r).ams_rx_ctl3[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_SET(r,d) (r).ams_rx_ctl3[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_GET(r) (r).ams_rx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_GET(r) ((((r).ams_rx_ctl3[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET(r) ((((r).ams_rx_ctl3[0]) >> 12) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET(r) ((((r).ams_rx_ctl3[0]) >> 9) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET(r) ((((r).ams_rx_ctl3[0]) >> 6) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DLL_IBIASf_GET(r) ((((r).ams_rx_ctl3[0]) >> 3) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DLL_IBIASf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET(r) (((r).ams_rx_ctl3[0]) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET(r,f) (r).ams_rx_ctl3[0]=(((r).ams_rx_ctl3[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL3r,(_r._ams_rx_ctl3))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL3r,(_r._ams_rx_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL3r,(_r._ams_rx_ctl3))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL3r BCMI_FALCON_XGXS_AMS_RX_CTL3r
#define AMS_RX_CTL3r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL3r_t AMS_RX_CTL3r_t;
#define AMS_RX_CTL3r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL3r_CLR
#define AMS_RX_CTL3r_SET BCMI_FALCON_XGXS_AMS_RX_CTL3r_SET
#define AMS_RX_CTL3r_GET BCMI_FALCON_XGXS_AMS_RX_CTL3r_GET
#define AMS_RX_CTL3r_AMS_RX_SPARE_63f_GET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_GET
#define AMS_RX_CTL3r_AMS_RX_SPARE_63f_SET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_SPARE_63f_SET
#define AMS_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_GET
#define AMS_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SLICER_IBIASf_SET
#define AMS_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_GET
#define AMS_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DFE_SUM_BUF_IBIASf_SET
#define AMS_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_GET
#define AMS_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_OFFSET_CORRECTION_IBIASf_SET
#define AMS_RX_CTL3r_AMS_RX_DLL_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DLL_IBIASf_GET
#define AMS_RX_CTL3r_AMS_RX_DLL_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_DLL_IBIASf_SET
#define AMS_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_MET_R_IBIASf_GET
#define AMS_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL3r_AMS_RX_MET_R_IBIASf_SET
#define READ_AMS_RX_CTL3r BCMI_FALCON_XGXS_READ_AMS_RX_CTL3r
#define WRITE_AMS_RX_CTL3r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL3r
#define MODIFY_AMS_RX_CTL3r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL3r
#define READLN_AMS_RX_CTL3r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL3r
#define WRITELN_AMS_RX_CTL3r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL3r
#define WRITEALL_AMS_RX_CTL3r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL4
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c4
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_4
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DFE_SLICER_CAL_IBIAS DFE slicer cal ibias (max, mode, min)
 *     AMS_RX_TBD_IBIAS TBD ibias (max, mode, min)
 *     AMS_RX_VGA0_RESCAL_MUX VGA0 rescal mux (force, ctrl[3:0]) - rescal override
 *     AMS_RX_VGA1_RESCAL_MUX VGA1 rescal mux (force, ctrl[3:0]) - rescal override
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r (0x0001d0c4 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL4.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl4[1];
	uint32_t _ams_rx_ctl4;
} BCMI_FALCON_XGXS_AMS_RX_CTL4r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_CLR(r) (r).ams_rx_ctl4[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_SET(r,d) (r).ams_rx_ctl4[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_GET(r) (r).ams_rx_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET(r) ((((r).ams_rx_ctl4[0]) >> 11) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET(r) ((((r).ams_rx_ctl4[0]) >> 6) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_TBD_IBIASf_GET(r) ((((r).ams_rx_ctl4[0]) >> 3) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_TBD_IBIASf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_GET(r) (((r).ams_rx_ctl4[0]) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_SET(r,f) (r).ams_rx_ctl4[0]=(((r).ams_rx_ctl4[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_RX_CTL4.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL4r,(_r._ams_rx_ctl4))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL4r,(_r._ams_rx_ctl4)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL4r,(_r._ams_rx_ctl4))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl4))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl4))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL4r BCMI_FALCON_XGXS_AMS_RX_CTL4r
#define AMS_RX_CTL4r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL4r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL4r_t AMS_RX_CTL4r_t;
#define AMS_RX_CTL4r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL4r_CLR
#define AMS_RX_CTL4r_SET BCMI_FALCON_XGXS_AMS_RX_CTL4r_SET
#define AMS_RX_CTL4r_GET BCMI_FALCON_XGXS_AMS_RX_CTL4r_GET
#define AMS_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_GET
#define AMS_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA1_RESCAL_MUXf_SET
#define AMS_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_GET
#define AMS_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_VGA0_RESCAL_MUXf_SET
#define AMS_RX_CTL4r_AMS_RX_TBD_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_TBD_IBIASf_GET
#define AMS_RX_CTL4r_AMS_RX_TBD_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_TBD_IBIASf_SET
#define AMS_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_GET
#define AMS_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL4r_AMS_RX_DFE_SLICER_CAL_IBIASf_SET
#define READ_AMS_RX_CTL4r BCMI_FALCON_XGXS_READ_AMS_RX_CTL4r
#define WRITE_AMS_RX_CTL4r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL4r
#define MODIFY_AMS_RX_CTL4r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL4r
#define READLN_AMS_RX_CTL4r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL4r
#define WRITELN_AMS_RX_CTL4r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL4r
#define WRITEALL_AMS_RX_CTL4r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL5
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c5
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_5
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_VGA2_RESCAL_MUX VGA2 rescal mux (force, ctrl[3:0]) - rescal override
 *     AMS_RX_VGA3_RESCAL_MUX VGA3 rescal mux (force, ctrl[3:0]) - rescal override
 *     AMS_RX_TERMINATION_RESISTOR_RESCAL_MUX rescal mux (force, ctrl[3:0]) - rescal override
 *     AMS_RX_SPARE_95  ams_rx reserved[95]
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r (0x0001d0c5 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL5.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL5r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl5[1];
	uint32_t _ams_rx_ctl5;
} BCMI_FALCON_XGXS_AMS_RX_CTL5r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_CLR(r) (r).ams_rx_ctl5[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_SET(r,d) (r).ams_rx_ctl5[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_GET(r) (r).ams_rx_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_SPARE_95f_GET(r) ((((r).ams_rx_ctl5[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_SPARE_95f_SET(r,f) (r).ams_rx_ctl5[0]=(((r).ams_rx_ctl5[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_TERMINATION_RESISTOR_RESCAL_MUXf_GET(r) ((((r).ams_rx_ctl5[0]) >> 10) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_TERMINATION_RESISTOR_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl5[0]=(((r).ams_rx_ctl5[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_GET(r) ((((r).ams_rx_ctl5[0]) >> 5) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl5[0]=(((r).ams_rx_ctl5[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET(r) (((r).ams_rx_ctl5[0]) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl5[0]=(((r).ams_rx_ctl5[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access AMS_RX_CTL5.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL5r,(_r._ams_rx_ctl5))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL5r,(_r._ams_rx_ctl5)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL5r,(_r._ams_rx_ctl5))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl5))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl5))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL5r BCMI_FALCON_XGXS_AMS_RX_CTL5r
#define AMS_RX_CTL5r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL5r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL5r_t AMS_RX_CTL5r_t;
#define AMS_RX_CTL5r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL5r_CLR
#define AMS_RX_CTL5r_SET BCMI_FALCON_XGXS_AMS_RX_CTL5r_SET
#define AMS_RX_CTL5r_GET BCMI_FALCON_XGXS_AMS_RX_CTL5r_GET
#define AMS_RX_CTL5r_AMS_RX_SPARE_95f_GET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_SPARE_95f_GET
#define AMS_RX_CTL5r_AMS_RX_SPARE_95f_SET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_SPARE_95f_SET
#define AMS_RX_CTL5r_AMS_RX_TERMINATION_RESISTOR_RESCAL_MUXf_GET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_TERMINATION_RESISTOR_RESCAL_MUXf_GET
#define AMS_RX_CTL5r_AMS_RX_TERMINATION_RESISTOR_RESCAL_MUXf_SET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_TERMINATION_RESISTOR_RESCAL_MUXf_SET
#define AMS_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_GET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_GET
#define AMS_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_SET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA3_RESCAL_MUXf_SET
#define AMS_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_GET
#define AMS_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET BCMI_FALCON_XGXS_AMS_RX_CTL5r_AMS_RX_VGA2_RESCAL_MUXf_SET
#define READ_AMS_RX_CTL5r BCMI_FALCON_XGXS_READ_AMS_RX_CTL5r
#define WRITE_AMS_RX_CTL5r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL5r
#define MODIFY_AMS_RX_CTL5r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL5r
#define READLN_AMS_RX_CTL5r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL5r
#define WRITELN_AMS_RX_CTL5r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL5r
#define WRITEALL_AMS_RX_CTL5r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL6
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c6
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_6
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_PEAKING_FILTER_RESCAL_MUX peaking filter rescal mux- (force, ctrl[3:1]) -rescal override
 *     AMS_RX_OFFSET_CORRECTION_RESCAL_MUX offset correction rescal mux (force, ctrl[3:1]) -rescal override
 *     AMS_RX_SPARE_111_104 ams rx reserved[111:104]
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r (0x0001d0c6 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL6.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl6[1];
	uint32_t _ams_rx_ctl6;
} BCMI_FALCON_XGXS_AMS_RX_CTL6r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_CLR(r) (r).ams_rx_ctl6[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_SET(r,d) (r).ams_rx_ctl6[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_GET(r) (r).ams_rx_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_SPARE_111_104f_GET(r) ((((r).ams_rx_ctl6[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_SPARE_111_104f_SET(r,f) (r).ams_rx_ctl6[0]=(((r).ams_rx_ctl6[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET(r) ((((r).ams_rx_ctl6[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl6[0]=(((r).ams_rx_ctl6[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET(r) (((r).ams_rx_ctl6[0]) & 0xf)
#define BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET(r,f) (r).ams_rx_ctl6[0]=(((r).ams_rx_ctl6[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_RX_CTL6.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL6r,(_r._ams_rx_ctl6))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL6r,(_r._ams_rx_ctl6)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL6r,(_r._ams_rx_ctl6))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl6))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl6))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL6r BCMI_FALCON_XGXS_AMS_RX_CTL6r
#define AMS_RX_CTL6r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL6r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL6r_t AMS_RX_CTL6r_t;
#define AMS_RX_CTL6r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL6r_CLR
#define AMS_RX_CTL6r_SET BCMI_FALCON_XGXS_AMS_RX_CTL6r_SET
#define AMS_RX_CTL6r_GET BCMI_FALCON_XGXS_AMS_RX_CTL6r_GET
#define AMS_RX_CTL6r_AMS_RX_SPARE_111_104f_GET BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_SPARE_111_104f_GET
#define AMS_RX_CTL6r_AMS_RX_SPARE_111_104f_SET BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_SPARE_111_104f_SET
#define AMS_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_GET
#define AMS_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_OFFSET_CORRECTION_RESCAL_MUXf_SET
#define AMS_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_GET
#define AMS_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET BCMI_FALCON_XGXS_AMS_RX_CTL6r_AMS_RX_PEAKING_FILTER_RESCAL_MUXf_SET
#define READ_AMS_RX_CTL6r BCMI_FALCON_XGXS_READ_AMS_RX_CTL6r
#define WRITE_AMS_RX_CTL6r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL6r
#define MODIFY_AMS_RX_CTL6r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL6r
#define READLN_AMS_RX_CTL6r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL6r
#define WRITELN_AMS_RX_CTL6r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL6r
#define WRITEALL_AMS_RX_CTL6r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL7
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c7
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_7
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DC_OFFSET dc_offset
 *     AMS_RX_FORCE_DC_OFFSET enables override using register bits
 *     AMS_RX_DC_OFFSET_RANGE dc_offset range, 2x
 *     AMS_RX_RX_OFFSET_PD pwrdn AFE offset cancellation DAC
 *     AMS_RX_SHORT_VGA_OUTPUT used for slicer calibration
 *     AMS_RX_SPARE_123 ams rx reserved [123]
 *     AMS_RX_VGA_LOW_GAIN extends low gain range by ~ -4dB per stage
 *     AMS_RX_VGA_STEP_MODE stage sequential. See AMS
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r (0x0001d0c7 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL7.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl7[1];
	uint32_t _ams_rx_ctl7;
} BCMI_FALCON_XGXS_AMS_RX_CTL7r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_CLR(r) (r).ams_rx_ctl7[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_SET(r,d) (r).ams_rx_ctl7[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_GET(r) (r).ams_rx_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET(r) ((((r).ams_rx_ctl7[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_GET(r) ((((r).ams_rx_ctl7[0]) >> 12) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SPARE_123f_GET(r) ((((r).ams_rx_ctl7[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SPARE_123f_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET(r) ((((r).ams_rx_ctl7[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET(r) ((((r).ams_rx_ctl7[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_GET(r) ((((r).ams_rx_ctl7[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET(r) ((((r).ams_rx_ctl7[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSETf_GET(r) (((r).ams_rx_ctl7[0]) & 0x7f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSETf_SET(r,f) (r).ams_rx_ctl7[0]=(((r).ams_rx_ctl7[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access AMS_RX_CTL7.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL7r,(_r._ams_rx_ctl7))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL7r,(_r._ams_rx_ctl7)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL7r,(_r._ams_rx_ctl7))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl7))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl7))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL7r BCMI_FALCON_XGXS_AMS_RX_CTL7r
#define AMS_RX_CTL7r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL7r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL7r_t AMS_RX_CTL7r_t;
#define AMS_RX_CTL7r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL7r_CLR
#define AMS_RX_CTL7r_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_SET
#define AMS_RX_CTL7r_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_GET
#define AMS_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_GET
#define AMS_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_STEP_MODEf_SET
#define AMS_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_GET
#define AMS_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_VGA_LOW_GAINf_SET
#define AMS_RX_CTL7r_AMS_RX_SPARE_123f_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SPARE_123f_GET
#define AMS_RX_CTL7r_AMS_RX_SPARE_123f_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SPARE_123f_SET
#define AMS_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_GET
#define AMS_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_SHORT_VGA_OUTPUTf_SET
#define AMS_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_GET
#define AMS_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_RX_OFFSET_PDf_SET
#define AMS_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_GET
#define AMS_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSET_RANGEf_SET
#define AMS_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_GET
#define AMS_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_FORCE_DC_OFFSETf_SET
#define AMS_RX_CTL7r_AMS_RX_DC_OFFSETf_GET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSETf_GET
#define AMS_RX_CTL7r_AMS_RX_DC_OFFSETf_SET BCMI_FALCON_XGXS_AMS_RX_CTL7r_AMS_RX_DC_OFFSETf_SET
#define READ_AMS_RX_CTL7r BCMI_FALCON_XGXS_READ_AMS_RX_CTL7r
#define WRITE_AMS_RX_CTL7r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL7r
#define MODIFY_AMS_RX_CTL7r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL7r
#define READLN_AMS_RX_CTL7r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL7r
#define WRITELN_AMS_RX_CTL7r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL7r
#define WRITEALL_AMS_RX_CTL7r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL8
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c8
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_8
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DAC4CK_LMS dac4ck_lms
 *     AMS_RX_SPARE_135_134 ams rx reserved[135:134]
 *     AMS_RX_DAC4CK_PHS dac4ck_phs
 *     AMS_RX_SPARE_143_142 ams rx reserved[143:142]
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r (0x0001d0c8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL8.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL8r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl8[1];
	uint32_t _ams_rx_ctl8;
} BCMI_FALCON_XGXS_AMS_RX_CTL8r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_CLR(r) (r).ams_rx_ctl8[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_SET(r,d) (r).ams_rx_ctl8[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_GET(r) (r).ams_rx_ctl8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_143_142f_GET(r) ((((r).ams_rx_ctl8[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_143_142f_SET(r,f) (r).ams_rx_ctl8[0]=(((r).ams_rx_ctl8[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_PHSf_GET(r) ((((r).ams_rx_ctl8[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_PHSf_SET(r,f) (r).ams_rx_ctl8[0]=(((r).ams_rx_ctl8[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_135_134f_GET(r) ((((r).ams_rx_ctl8[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_135_134f_SET(r,f) (r).ams_rx_ctl8[0]=(((r).ams_rx_ctl8[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_LMSf_GET(r) (((r).ams_rx_ctl8[0]) & 0x3f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_LMSf_SET(r,f) (r).ams_rx_ctl8[0]=(((r).ams_rx_ctl8[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access AMS_RX_CTL8.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL8r,(_r._ams_rx_ctl8))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL8r,(_r._ams_rx_ctl8)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL8r,(_r._ams_rx_ctl8))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl8))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl8))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL8r BCMI_FALCON_XGXS_AMS_RX_CTL8r
#define AMS_RX_CTL8r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL8r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL8r_t AMS_RX_CTL8r_t;
#define AMS_RX_CTL8r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL8r_CLR
#define AMS_RX_CTL8r_SET BCMI_FALCON_XGXS_AMS_RX_CTL8r_SET
#define AMS_RX_CTL8r_GET BCMI_FALCON_XGXS_AMS_RX_CTL8r_GET
#define AMS_RX_CTL8r_AMS_RX_SPARE_143_142f_GET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_143_142f_GET
#define AMS_RX_CTL8r_AMS_RX_SPARE_143_142f_SET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_143_142f_SET
#define AMS_RX_CTL8r_AMS_RX_DAC4CK_PHSf_GET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_PHSf_GET
#define AMS_RX_CTL8r_AMS_RX_DAC4CK_PHSf_SET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_PHSf_SET
#define AMS_RX_CTL8r_AMS_RX_SPARE_135_134f_GET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_135_134f_GET
#define AMS_RX_CTL8r_AMS_RX_SPARE_135_134f_SET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_SPARE_135_134f_SET
#define AMS_RX_CTL8r_AMS_RX_DAC4CK_LMSf_GET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_LMSf_GET
#define AMS_RX_CTL8r_AMS_RX_DAC4CK_LMSf_SET BCMI_FALCON_XGXS_AMS_RX_CTL8r_AMS_RX_DAC4CK_LMSf_SET
#define READ_AMS_RX_CTL8r BCMI_FALCON_XGXS_READ_AMS_RX_CTL8r
#define WRITE_AMS_RX_CTL8r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL8r
#define MODIFY_AMS_RX_CTL8r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL8r
#define READLN_AMS_RX_CTL8r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL8r
#define WRITELN_AMS_RX_CTL8r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL8r
#define WRITEALL_AMS_RX_CTL8r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_CTL9
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0c9
 * DEVAD:    1
 * DESC:     AMS RX CONTROL_9
 * RESETVAL: 0x300 (768)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_RX_DAC4CK_DAT dac4ck_dat
 *     AMS_RX_SPARE_151_150 ams rx reserved[151:150]
 *     AMS_RX_CLK_BW_CTRL clk_bw_ctrl<1:0> for 20G to 28G
 *     AMS_RX_EN_TAP9DELAY 0 less delay for 25-28g
 *     AMS_RX_SEL_D2CLP 0, high power for 25-28g
 *     AMS_RX_D2C_CLKBUF_IBIAS d2c and clock buffer ibias (max, mode, min)
 *     AMS_RX_SPARE_159 ams rx reserved[159]
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r (0x0001d0c9 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_CTL9.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_CTL9r_s {
	uint32_t v[1];
	uint32_t ams_rx_ctl9[1];
	uint32_t _ams_rx_ctl9;
} BCMI_FALCON_XGXS_AMS_RX_CTL9r_t;

#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_CLR(r) (r).ams_rx_ctl9[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_SET(r,d) (r).ams_rx_ctl9[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_GET(r) (r).ams_rx_ctl9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_159f_GET(r) ((((r).ams_rx_ctl9[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_159f_SET(r,f) (r).ams_rx_ctl9[0]=(((r).ams_rx_ctl9[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET(r) ((((r).ams_rx_ctl9[0]) >> 12) & 0x7)
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET(r,f) (r).ams_rx_ctl9[0]=(((r).ams_rx_ctl9[0] & ~((uint32_t)0x7 << 12)) | ((((uint32_t)f) & 0x7) << 12)) | (7 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET(r) ((((r).ams_rx_ctl9[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET(r,f) (r).ams_rx_ctl9[0]=(((r).ams_rx_ctl9[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_GET(r) ((((r).ams_rx_ctl9[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_SET(r,f) (r).ams_rx_ctl9[0]=(((r).ams_rx_ctl9[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET(r) ((((r).ams_rx_ctl9[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET(r,f) (r).ams_rx_ctl9[0]=(((r).ams_rx_ctl9[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_151_150f_GET(r) ((((r).ams_rx_ctl9[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_151_150f_SET(r,f) (r).ams_rx_ctl9[0]=(((r).ams_rx_ctl9[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_DAC4CK_DATf_GET(r) (((r).ams_rx_ctl9[0]) & 0x3f)
#define BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_DAC4CK_DATf_SET(r,f) (r).ams_rx_ctl9[0]=(((r).ams_rx_ctl9[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access AMS_RX_CTL9.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_CTL9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL9r,(_r._ams_rx_ctl9))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL9r,(_r._ams_rx_ctl9)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL9r,(_r._ams_rx_ctl9))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_CTL9r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl9))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL9r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_ctl9))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_CTL9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_ctl9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_CTL9r BCMI_FALCON_XGXS_AMS_RX_CTL9r
#define AMS_RX_CTL9r_SIZE BCMI_FALCON_XGXS_AMS_RX_CTL9r_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_CTL9r_t AMS_RX_CTL9r_t;
#define AMS_RX_CTL9r_CLR BCMI_FALCON_XGXS_AMS_RX_CTL9r_CLR
#define AMS_RX_CTL9r_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_SET
#define AMS_RX_CTL9r_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_GET
#define AMS_RX_CTL9r_AMS_RX_SPARE_159f_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_159f_GET
#define AMS_RX_CTL9r_AMS_RX_SPARE_159f_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_159f_SET
#define AMS_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_GET
#define AMS_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_D2C_CLKBUF_IBIASf_SET
#define AMS_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SEL_D2CLPf_GET
#define AMS_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SEL_D2CLPf_SET
#define AMS_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_GET
#define AMS_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_EN_TAP9DELAYf_SET
#define AMS_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_GET
#define AMS_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_CLK_BW_CTRLf_SET
#define AMS_RX_CTL9r_AMS_RX_SPARE_151_150f_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_151_150f_GET
#define AMS_RX_CTL9r_AMS_RX_SPARE_151_150f_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_SPARE_151_150f_SET
#define AMS_RX_CTL9r_AMS_RX_DAC4CK_DATf_GET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_DAC4CK_DATf_GET
#define AMS_RX_CTL9r_AMS_RX_DAC4CK_DATf_SET BCMI_FALCON_XGXS_AMS_RX_CTL9r_AMS_RX_DAC4CK_DATf_SET
#define READ_AMS_RX_CTL9r BCMI_FALCON_XGXS_READ_AMS_RX_CTL9r
#define WRITE_AMS_RX_CTL9r BCMI_FALCON_XGXS_WRITE_AMS_RX_CTL9r
#define MODIFY_AMS_RX_CTL9r BCMI_FALCON_XGXS_MODIFY_AMS_RX_CTL9r
#define READLN_AMS_RX_CTL9r BCMI_FALCON_XGXS_READLN_AMS_RX_CTL9r
#define WRITELN_AMS_RX_CTL9r BCMI_FALCON_XGXS_WRITELN_AMS_RX_CTL9r
#define WRITEALL_AMS_RX_CTL9r BCMI_FALCON_XGXS_WRITEALL_AMS_RX_CTL9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_CTL9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_RX_STS
 * BLOCKS:   AMS_RX
 * REGADDR:  0xd0cb
 * DEVAD:    1
 * DESC:     AMS RX STATUS
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_RX_STS       RX status from AFE
 */
#define BCMI_FALCON_XGXS_AMS_RX_STSr (0x0001d0cb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_RX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_RX_STS.
 */
typedef union BCMI_FALCON_XGXS_AMS_RX_STSr_s {
	uint32_t v[1];
	uint32_t ams_rx_sts[1];
	uint32_t _ams_rx_sts;
} BCMI_FALCON_XGXS_AMS_RX_STSr_t;

#define BCMI_FALCON_XGXS_AMS_RX_STSr_CLR(r) (r).ams_rx_sts[0] = 0
#define BCMI_FALCON_XGXS_AMS_RX_STSr_SET(r,d) (r).ams_rx_sts[0] = d
#define BCMI_FALCON_XGXS_AMS_RX_STSr_GET(r) (r).ams_rx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_RX_STSr_AMS_RX_STSf_GET(r) (((r).ams_rx_sts[0]) & 0xffff)
#define BCMI_FALCON_XGXS_AMS_RX_STSr_AMS_RX_STSf_SET(r,f) (r).ams_rx_sts[0]=(((r).ams_rx_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AMS_RX_STS.
 */
#define BCMI_FALCON_XGXS_READ_AMS_RX_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_STSr,(_r._ams_rx_sts))
#define BCMI_FALCON_XGXS_WRITE_AMS_RX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_STSr,(_r._ams_rx_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_RX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_STSr,(_r._ams_rx_sts))
#define BCMI_FALCON_XGXS_READLN_AMS_RX_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_sts))
#define BCMI_FALCON_XGXS_WRITELN_AMS_RX_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_rx_sts))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_RX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_RX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_rx_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_RX_STSr BCMI_FALCON_XGXS_AMS_RX_STSr
#define AMS_RX_STSr_SIZE BCMI_FALCON_XGXS_AMS_RX_STSr_SIZE
typedef BCMI_FALCON_XGXS_AMS_RX_STSr_t AMS_RX_STSr_t;
#define AMS_RX_STSr_CLR BCMI_FALCON_XGXS_AMS_RX_STSr_CLR
#define AMS_RX_STSr_SET BCMI_FALCON_XGXS_AMS_RX_STSr_SET
#define AMS_RX_STSr_GET BCMI_FALCON_XGXS_AMS_RX_STSr_GET
#define AMS_RX_STSr_AMS_RX_STSf_GET BCMI_FALCON_XGXS_AMS_RX_STSr_AMS_RX_STSf_GET
#define AMS_RX_STSr_AMS_RX_STSf_SET BCMI_FALCON_XGXS_AMS_RX_STSr_AMS_RX_STSf_SET
#define READ_AMS_RX_STSr BCMI_FALCON_XGXS_READ_AMS_RX_STSr
#define WRITE_AMS_RX_STSr BCMI_FALCON_XGXS_WRITE_AMS_RX_STSr
#define MODIFY_AMS_RX_STSr BCMI_FALCON_XGXS_MODIFY_AMS_RX_STSr
#define READLN_AMS_RX_STSr BCMI_FALCON_XGXS_READLN_AMS_RX_STSr
#define WRITELN_AMS_RX_STSr BCMI_FALCON_XGXS_WRITELN_AMS_RX_STSr
#define WRITEALL_AMS_RX_STSr BCMI_FALCON_XGXS_WRITEALL_AMS_RX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_RX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_TX_CTL0
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d0
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_0
 * RESETVAL: 0xc0 (192)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_SPARE_0   AMS reserved[0]
 *     AMS_TX_SPARE_3_1 AMS reserved[3:1]
 *     AMS_TX_TEST_DATA generates output pattern
 *     AMS_TX_TICKSEL   timing control of load signal at ana/dig interface
 *     AMS_TX_VDDR_BGB  bias mode control
 *     AMS_TX_DCC_SEL   select DCC mode. 0=using DCC circuit. 1= signle ended
 *     AMS_TX_DCC_DIS   disable DCC
 *     AMS_TX_CAL_OFF   disable RESCAL[3:0], enable cal_aux[3:0]
 *     AMS_TX_CAL_AUX   Rescal manual control when cal_off=1
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r (0x0001d0d0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_CTL0.
 */
typedef union BCMI_FALCON_XGXS_AMS_TX_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_tx_ctl0[1];
	uint32_t _ams_tx_ctl0;
} BCMI_FALCON_XGXS_AMS_TX_CTL0r_t;

#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_CLR(r) (r).ams_tx_ctl0[0] = 0
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_SET(r,d) (r).ams_tx_ctl0[0] = d
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_GET(r) (r).ams_tx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_GET(r) ((((r).ams_tx_ctl0[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_GET(r) ((((r).ams_tx_ctl0[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_GET(r) ((((r).ams_tx_ctl0[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_GET(r) ((((r).ams_tx_ctl0[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_VDDR_BGBf_GET(r) ((((r).ams_tx_ctl0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_VDDR_BGBf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_GET(r) ((((r).ams_tx_ctl0[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_GET(r) ((((r).ams_tx_ctl0[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3_1f_GET(r) ((((r).ams_tx_ctl0[0]) >> 1) & 0x7)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3_1f_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_0f_GET(r) (((r).ams_tx_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_0f_SET(r,f) (r).ams_tx_ctl0[0]=(((r).ams_tx_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_TX_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_AMS_TX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL0r,(_r._ams_tx_ctl0))
#define BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL0r,(_r._ams_tx_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL0r,(_r._ams_tx_ctl0))
#define BCMI_FALCON_XGXS_READLN_AMS_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_CTL0r BCMI_FALCON_XGXS_AMS_TX_CTL0r
#define AMS_TX_CTL0r_SIZE BCMI_FALCON_XGXS_AMS_TX_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_AMS_TX_CTL0r_t AMS_TX_CTL0r_t;
#define AMS_TX_CTL0r_CLR BCMI_FALCON_XGXS_AMS_TX_CTL0r_CLR
#define AMS_TX_CTL0r_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_SET
#define AMS_TX_CTL0r_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_GET
#define AMS_TX_CTL0r_AMS_TX_CAL_AUXf_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_GET
#define AMS_TX_CTL0r_AMS_TX_CAL_AUXf_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_AUXf_SET
#define AMS_TX_CTL0r_AMS_TX_CAL_OFFf_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_GET
#define AMS_TX_CTL0r_AMS_TX_CAL_OFFf_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_CAL_OFFf_SET
#define AMS_TX_CTL0r_AMS_TX_DCC_DISf_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_GET
#define AMS_TX_CTL0r_AMS_TX_DCC_DISf_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_DISf_SET
#define AMS_TX_CTL0r_AMS_TX_DCC_SELf_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_GET
#define AMS_TX_CTL0r_AMS_TX_DCC_SELf_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_DCC_SELf_SET
#define AMS_TX_CTL0r_AMS_TX_VDDR_BGBf_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_VDDR_BGBf_GET
#define AMS_TX_CTL0r_AMS_TX_VDDR_BGBf_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_VDDR_BGBf_SET
#define AMS_TX_CTL0r_AMS_TX_TICKSELf_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_GET
#define AMS_TX_CTL0r_AMS_TX_TICKSELf_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TICKSELf_SET
#define AMS_TX_CTL0r_AMS_TX_TEST_DATAf_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_GET
#define AMS_TX_CTL0r_AMS_TX_TEST_DATAf_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_TEST_DATAf_SET
#define AMS_TX_CTL0r_AMS_TX_SPARE_3_1f_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3_1f_GET
#define AMS_TX_CTL0r_AMS_TX_SPARE_3_1f_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_3_1f_SET
#define AMS_TX_CTL0r_AMS_TX_SPARE_0f_GET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_0f_GET
#define AMS_TX_CTL0r_AMS_TX_SPARE_0f_SET BCMI_FALCON_XGXS_AMS_TX_CTL0r_AMS_TX_SPARE_0f_SET
#define READ_AMS_TX_CTL0r BCMI_FALCON_XGXS_READ_AMS_TX_CTL0r
#define WRITE_AMS_TX_CTL0r BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL0r
#define MODIFY_AMS_TX_CTL0r BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL0r
#define READLN_AMS_TX_CTL0r BCMI_FALCON_XGXS_READLN_AMS_TX_CTL0r
#define WRITELN_AMS_TX_CTL0r BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL0r
#define WRITEALL_AMS_TX_CTL0r BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_TX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_TX_CTL1
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d1
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_1
 * RESETVAL: 0x2000 (8192)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_IBIAS     master bias diode
 *     AMS_TX_SPARE_21_19 AMS reserved [21:19]
 *     AMS_TX_ICML      clock input buffer current control
 *     AMS_TX_ILDO      LDO bias current control
 *     AMS_TX_LDO_VREF  Vref. Adjustment
 *     AMS_TX_SEL_EMPH_MODE KR pre-emphasis mode enable
 *     AMS_TX_SPARE_31  AMS reserved[31]
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r (0x0001d0d1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_CTL1.
 */
typedef union BCMI_FALCON_XGXS_AMS_TX_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_tx_ctl1[1];
	uint32_t _ams_tx_ctl1;
} BCMI_FALCON_XGXS_AMS_TX_CTL1r_t;

#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_CLR(r) (r).ams_tx_ctl1[0] = 0
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_SET(r,d) (r).ams_tx_ctl1[0] = d
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_GET(r) (r).ams_tx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_31f_GET(r) ((((r).ams_tx_ctl1[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_31f_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_GET(r) ((((r).ams_tx_ctl1[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_LDO_VREFf_GET(r) ((((r).ams_tx_ctl1[0]) >> 12) & 0x3)
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_LDO_VREFf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ILDOf_GET(r) ((((r).ams_tx_ctl1[0]) >> 9) & 0x7)
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ILDOf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x7 << 9)) | ((((uint32_t)f) & 0x7) << 9)) | (7 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_GET(r) ((((r).ams_tx_ctl1[0]) >> 6) & 0x7)
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_21_19f_GET(r) ((((r).ams_tx_ctl1[0]) >> 3) & 0x7)
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_21_19f_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x7 << 3)) | ((((uint32_t)f) & 0x7) << 3)) | (7 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_GET(r) (((r).ams_tx_ctl1[0]) & 0x7)
#define BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_SET(r,f) (r).ams_tx_ctl1[0]=(((r).ams_tx_ctl1[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access AMS_TX_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_AMS_TX_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL1r,(_r._ams_tx_ctl1))
#define BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL1r,(_r._ams_tx_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL1r,(_r._ams_tx_ctl1))
#define BCMI_FALCON_XGXS_READLN_AMS_TX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_CTL1r BCMI_FALCON_XGXS_AMS_TX_CTL1r
#define AMS_TX_CTL1r_SIZE BCMI_FALCON_XGXS_AMS_TX_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_AMS_TX_CTL1r_t AMS_TX_CTL1r_t;
#define AMS_TX_CTL1r_CLR BCMI_FALCON_XGXS_AMS_TX_CTL1r_CLR
#define AMS_TX_CTL1r_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_SET
#define AMS_TX_CTL1r_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_GET
#define AMS_TX_CTL1r_AMS_TX_SPARE_31f_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_31f_GET
#define AMS_TX_CTL1r_AMS_TX_SPARE_31f_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_31f_SET
#define AMS_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_GET
#define AMS_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SEL_EMPH_MODEf_SET
#define AMS_TX_CTL1r_AMS_TX_LDO_VREFf_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_LDO_VREFf_GET
#define AMS_TX_CTL1r_AMS_TX_LDO_VREFf_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_LDO_VREFf_SET
#define AMS_TX_CTL1r_AMS_TX_ILDOf_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ILDOf_GET
#define AMS_TX_CTL1r_AMS_TX_ILDOf_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ILDOf_SET
#define AMS_TX_CTL1r_AMS_TX_ICMLf_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_GET
#define AMS_TX_CTL1r_AMS_TX_ICMLf_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_ICMLf_SET
#define AMS_TX_CTL1r_AMS_TX_SPARE_21_19f_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_21_19f_GET
#define AMS_TX_CTL1r_AMS_TX_SPARE_21_19f_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_SPARE_21_19f_SET
#define AMS_TX_CTL1r_AMS_TX_IBIASf_GET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_GET
#define AMS_TX_CTL1r_AMS_TX_IBIASf_SET BCMI_FALCON_XGXS_AMS_TX_CTL1r_AMS_TX_IBIASf_SET
#define READ_AMS_TX_CTL1r BCMI_FALCON_XGXS_READ_AMS_TX_CTL1r
#define WRITE_AMS_TX_CTL1r BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL1r
#define MODIFY_AMS_TX_CTL1r BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL1r
#define READLN_AMS_TX_CTL1r BCMI_FALCON_XGXS_READLN_AMS_TX_CTL1r
#define WRITELN_AMS_TX_CTL1r BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL1r
#define WRITEALL_AMS_TX_CTL1r BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_TX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_TX_CTL2
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d2
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_2
 * RESETVAL: 0xf (15)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_AMP_CTL   master amplitude control
 *     AMS_TX_POST3_COEF 3rd post cursor de-emphasis tap, driven by hardware
 *     AMS_TX_SIGN_POST3 polarity control for 3rd post cursor tap, driven by hardware
 *     AMS_TX_POST2_COEF 2nd post cursor de-emphasis tap, driven by hardware
 *     AMS_TX_SIGN_POST2 polarity control for 2nd post cursor tap, driven by hardware.
 *     AMS_TX_DRIVERMODE half amplitude / double resolution for main tap
 *     AMS_TX_ELEC_IDLE_AUX force electrical idle mode
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r (0x0001d0d2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_CTL2.
 */
typedef union BCMI_FALCON_XGXS_AMS_TX_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_tx_ctl2[1];
	uint32_t _ams_tx_ctl2;
} BCMI_FALCON_XGXS_AMS_TX_CTL2r_t;

#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_CLR(r) (r).ams_tx_ctl2[0] = 0
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_SET(r,d) (r).ams_tx_ctl2[0] = d
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_GET(r) (r).ams_tx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET(r) ((((r).ams_tx_ctl2[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_GET(r) ((((r).ams_tx_ctl2[0]) >> 13) & 0x3)
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x3 << 13)) | ((((uint32_t)f) & 0x3) << 13)) | (3 << (16 + 13))
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_GET(r) ((((r).ams_tx_ctl2[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_GET(r) ((((r).ams_tx_ctl2[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_GET(r) ((((r).ams_tx_ctl2[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_GET(r) ((((r).ams_tx_ctl2[0]) >> 4) & 0x7)
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_GET(r) (((r).ams_tx_ctl2[0]) & 0xf)
#define BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_SET(r,f) (r).ams_tx_ctl2[0]=(((r).ams_tx_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_TX_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_AMS_TX_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL2r,(_r._ams_tx_ctl2))
#define BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL2r,(_r._ams_tx_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL2r,(_r._ams_tx_ctl2))
#define BCMI_FALCON_XGXS_READLN_AMS_TX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_CTL2r BCMI_FALCON_XGXS_AMS_TX_CTL2r
#define AMS_TX_CTL2r_SIZE BCMI_FALCON_XGXS_AMS_TX_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_AMS_TX_CTL2r_t AMS_TX_CTL2r_t;
#define AMS_TX_CTL2r_CLR BCMI_FALCON_XGXS_AMS_TX_CTL2r_CLR
#define AMS_TX_CTL2r_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_SET
#define AMS_TX_CTL2r_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_GET
#define AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_GET
#define AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_ELEC_IDLE_AUXf_SET
#define AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_GET
#define AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_DRIVERMODEf_SET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_GET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST2f_SET
#define AMS_TX_CTL2r_AMS_TX_POST2_COEFf_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_GET
#define AMS_TX_CTL2r_AMS_TX_POST2_COEFf_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST2_COEFf_SET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_GET
#define AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_SIGN_POST3f_SET
#define AMS_TX_CTL2r_AMS_TX_POST3_COEFf_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_GET
#define AMS_TX_CTL2r_AMS_TX_POST3_COEFf_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_POST3_COEFf_SET
#define AMS_TX_CTL2r_AMS_TX_AMP_CTLf_GET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_GET
#define AMS_TX_CTL2r_AMS_TX_AMP_CTLf_SET BCMI_FALCON_XGXS_AMS_TX_CTL2r_AMS_TX_AMP_CTLf_SET
#define READ_AMS_TX_CTL2r BCMI_FALCON_XGXS_READ_AMS_TX_CTL2r
#define WRITE_AMS_TX_CTL2r BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL2r
#define MODIFY_AMS_TX_CTL2r BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL2r
#define READLN_AMS_TX_CTL2r BCMI_FALCON_XGXS_READLN_AMS_TX_CTL2r
#define WRITELN_AMS_TX_CTL2r BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL2r
#define WRITEALL_AMS_TX_CTL2r BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_TX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_TX_CTL3
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d3
 * DEVAD:    1
 * DESC:     AMS TX CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_TX_SPARE_63_48 AMS reserved[63:48]
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL3r (0x0001d0d3 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_TX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_CTL3.
 */
typedef union BCMI_FALCON_XGXS_AMS_TX_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_tx_ctl3[1];
	uint32_t _ams_tx_ctl3;
} BCMI_FALCON_XGXS_AMS_TX_CTL3r_t;

#define BCMI_FALCON_XGXS_AMS_TX_CTL3r_CLR(r) (r).ams_tx_ctl3[0] = 0
#define BCMI_FALCON_XGXS_AMS_TX_CTL3r_SET(r,d) (r).ams_tx_ctl3[0] = d
#define BCMI_FALCON_XGXS_AMS_TX_CTL3r_GET(r) (r).ams_tx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_TX_CTL3r_AMS_TX_SPARE_63_48f_GET(r) (((r).ams_tx_ctl3[0]) & 0xffff)
#define BCMI_FALCON_XGXS_AMS_TX_CTL3r_AMS_TX_SPARE_63_48f_SET(r,f) (r).ams_tx_ctl3[0]=(((r).ams_tx_ctl3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AMS_TX_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_AMS_TX_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL3r,(_r._ams_tx_ctl3))
#define BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL3r,(_r._ams_tx_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL3r,(_r._ams_tx_ctl3))
#define BCMI_FALCON_XGXS_READLN_AMS_TX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_CTL3r BCMI_FALCON_XGXS_AMS_TX_CTL3r
#define AMS_TX_CTL3r_SIZE BCMI_FALCON_XGXS_AMS_TX_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_AMS_TX_CTL3r_t AMS_TX_CTL3r_t;
#define AMS_TX_CTL3r_CLR BCMI_FALCON_XGXS_AMS_TX_CTL3r_CLR
#define AMS_TX_CTL3r_SET BCMI_FALCON_XGXS_AMS_TX_CTL3r_SET
#define AMS_TX_CTL3r_GET BCMI_FALCON_XGXS_AMS_TX_CTL3r_GET
#define AMS_TX_CTL3r_AMS_TX_SPARE_63_48f_GET BCMI_FALCON_XGXS_AMS_TX_CTL3r_AMS_TX_SPARE_63_48f_GET
#define AMS_TX_CTL3r_AMS_TX_SPARE_63_48f_SET BCMI_FALCON_XGXS_AMS_TX_CTL3r_AMS_TX_SPARE_63_48f_SET
#define READ_AMS_TX_CTL3r BCMI_FALCON_XGXS_READ_AMS_TX_CTL3r
#define WRITE_AMS_TX_CTL3r BCMI_FALCON_XGXS_WRITE_AMS_TX_CTL3r
#define MODIFY_AMS_TX_CTL3r BCMI_FALCON_XGXS_MODIFY_AMS_TX_CTL3r
#define READLN_AMS_TX_CTL3r BCMI_FALCON_XGXS_READLN_AMS_TX_CTL3r
#define WRITELN_AMS_TX_CTL3r BCMI_FALCON_XGXS_WRITELN_AMS_TX_CTL3r
#define WRITEALL_AMS_TX_CTL3r BCMI_FALCON_XGXS_WRITEALL_AMS_TX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_TX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_TX_STS
 * BLOCKS:   AMS_TX
 * REGADDR:  0xd0d8
 * DEVAD:    1
 * DESC:     AMS TX STATUS
 * RESETVAL: 0xa0 (160)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_TX_STS       tx status from AFE
 */
#define BCMI_FALCON_XGXS_AMS_TX_STSr (0x0001d0d8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_TX_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_TX_STS.
 */
typedef union BCMI_FALCON_XGXS_AMS_TX_STSr_s {
	uint32_t v[1];
	uint32_t ams_tx_sts[1];
	uint32_t _ams_tx_sts;
} BCMI_FALCON_XGXS_AMS_TX_STSr_t;

#define BCMI_FALCON_XGXS_AMS_TX_STSr_CLR(r) (r).ams_tx_sts[0] = 0
#define BCMI_FALCON_XGXS_AMS_TX_STSr_SET(r,d) (r).ams_tx_sts[0] = d
#define BCMI_FALCON_XGXS_AMS_TX_STSr_GET(r) (r).ams_tx_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_TX_STSr_AMS_TX_STSf_GET(r) (((r).ams_tx_sts[0]) & 0xffff)
#define BCMI_FALCON_XGXS_AMS_TX_STSr_AMS_TX_STSf_SET(r,f) (r).ams_tx_sts[0]=(((r).ams_tx_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AMS_TX_STS.
 */
#define BCMI_FALCON_XGXS_READ_AMS_TX_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_STSr,(_r._ams_tx_sts))
#define BCMI_FALCON_XGXS_WRITE_AMS_TX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_STSr,(_r._ams_tx_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_TX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_STSr,(_r._ams_tx_sts))
#define BCMI_FALCON_XGXS_READLN_AMS_TX_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_sts))
#define BCMI_FALCON_XGXS_WRITELN_AMS_TX_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_tx_sts))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_TX_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_TX_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_tx_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_TX_STSr BCMI_FALCON_XGXS_AMS_TX_STSr
#define AMS_TX_STSr_SIZE BCMI_FALCON_XGXS_AMS_TX_STSr_SIZE
typedef BCMI_FALCON_XGXS_AMS_TX_STSr_t AMS_TX_STSr_t;
#define AMS_TX_STSr_CLR BCMI_FALCON_XGXS_AMS_TX_STSr_CLR
#define AMS_TX_STSr_SET BCMI_FALCON_XGXS_AMS_TX_STSr_SET
#define AMS_TX_STSr_GET BCMI_FALCON_XGXS_AMS_TX_STSr_GET
#define AMS_TX_STSr_AMS_TX_STSf_GET BCMI_FALCON_XGXS_AMS_TX_STSr_AMS_TX_STSf_GET
#define AMS_TX_STSr_AMS_TX_STSf_SET BCMI_FALCON_XGXS_AMS_TX_STSr_AMS_TX_STSf_SET
#define READ_AMS_TX_STSr BCMI_FALCON_XGXS_READ_AMS_TX_STSr
#define WRITE_AMS_TX_STSr BCMI_FALCON_XGXS_WRITE_AMS_TX_STSr
#define MODIFY_AMS_TX_STSr BCMI_FALCON_XGXS_MODIFY_AMS_TX_STSr
#define READLN_AMS_TX_STSr BCMI_FALCON_XGXS_READLN_AMS_TX_STSr
#define WRITELN_AMS_TX_STSr BCMI_FALCON_XGXS_WRITELN_AMS_TX_STSr
#define WRITEALL_AMS_TX_STSr BCMI_FALCON_XGXS_WRITEALL_AMS_TX_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_TX_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  SIGDET_CTL0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e0
 * DEVAD:    1
 * DESC:     CTRL_0
 * RESETVAL: 0x1109 (4361)
 * ACCESS:   R/W
 * FIELDS:
 *     SIGNAL_DETECT_FILTER_COUNT Defines the width of the signal_detect==1'b1 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 *     LOS_FILTER_COUNT Defines the width of the signal_detect==1'b0 pulses which will be filtered. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 */
#define BCMI_FALCON_XGXS_SIGDET_CTL0r (0x0001d0e0 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_SIGDET_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL0.
 */
typedef union BCMI_FALCON_XGXS_SIGDET_CTL0r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl0[1];
	uint32_t _sigdet_ctl0;
} BCMI_FALCON_XGXS_SIGDET_CTL0r_t;

#define BCMI_FALCON_XGXS_SIGDET_CTL0r_CLR(r) (r).sigdet_ctl0[0] = 0
#define BCMI_FALCON_XGXS_SIGDET_CTL0r_SET(r,d) (r).sigdet_ctl0[0] = d
#define BCMI_FALCON_XGXS_SIGDET_CTL0r_GET(r) (r).sigdet_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET(r) ((((r).sigdet_ctl0[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET(r) (((r).sigdet_ctl0[0]) & 0x1f)
#define BCMI_FALCON_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET(r,f) (r).sigdet_ctl0[0]=(((r).sigdet_ctl0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access SIGDET_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_FALCON_XGXS_WRITE_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL0r,(_r._sigdet_ctl0))
#define BCMI_FALCON_XGXS_READLN_SIGDET_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_SIGDET_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_SIGDET_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL0r BCMI_FALCON_XGXS_SIGDET_CTL0r
#define SIGDET_CTL0r_SIZE BCMI_FALCON_XGXS_SIGDET_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_SIGDET_CTL0r_t SIGDET_CTL0r_t;
#define SIGDET_CTL0r_CLR BCMI_FALCON_XGXS_SIGDET_CTL0r_CLR
#define SIGDET_CTL0r_SET BCMI_FALCON_XGXS_SIGDET_CTL0r_SET
#define SIGDET_CTL0r_GET BCMI_FALCON_XGXS_SIGDET_CTL0r_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_GET BCMI_FALCON_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_GET
#define SIGDET_CTL0r_LOS_FILTER_COUNTf_SET BCMI_FALCON_XGXS_SIGDET_CTL0r_LOS_FILTER_COUNTf_SET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET BCMI_FALCON_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_GET
#define SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET BCMI_FALCON_XGXS_SIGDET_CTL0r_SIGNAL_DETECT_FILTER_COUNTf_SET
#define READ_SIGDET_CTL0r BCMI_FALCON_XGXS_READ_SIGDET_CTL0r
#define WRITE_SIGDET_CTL0r BCMI_FALCON_XGXS_WRITE_SIGDET_CTL0r
#define MODIFY_SIGDET_CTL0r BCMI_FALCON_XGXS_MODIFY_SIGDET_CTL0r
#define READLN_SIGDET_CTL0r BCMI_FALCON_XGXS_READLN_SIGDET_CTL0r
#define WRITELN_SIGDET_CTL0r BCMI_FALCON_XGXS_WRITELN_SIGDET_CTL0r
#define WRITEALL_SIGDET_CTL0r BCMI_FALCON_XGXS_WRITEALL_SIGDET_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_SIGDET_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  SIGDET_CTL1
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e1
 * DEVAD:    1
 * DESC:     CTRL_1
 * RESETVAL: 0xa008 (40968)
 * ACCESS:   R/W
 * FIELDS:
 *     AFE_SIGNAL_DETECT_DIS 1'b1 will disable the signal_detect from AFE.
 *     EXT_LOS_EN       1'b1 will enable the external (optical) LOS path into the sigdet filter.
 *     EXT_LOS_INV      1'b1 will invert the polarity of the pmd_ext_los pin.
 *     IGNORE_LP_MODE   1'b1 will ignore the pmd_rx_mode (low power mode) input pin. Set to 1'b0 if EEE mode is supported by the PCS
 *     SIGNAL_DETECT_FILTER_1US 1'b1 will use 1us heartbeat for los_count, signal_detect_count and mask_count counters instead of comclk.
 *     ENERGY_DETECT_FRC pmd_energy_detect Force.
 *     ENERGY_DETECT_FRC_VAL pmd_energy_detect Force Value.
 *     SIGNAL_DETECT_FRC pmd_signal_detect Force.
 *     SIGNAL_DETECT_FRC_VAL pmd_signal_detect Force Value.
 *     ENERGY_DETECT_MASK_COUNT Defines the mask_count timer for energy_detect. Valid range is 0 to 31which maps to 0 to 448 clock cycles. Refer PMD spec for more details about the mapping.
 */
#define BCMI_FALCON_XGXS_SIGDET_CTL1r (0x0001d0e1 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL1.
 */
typedef union BCMI_FALCON_XGXS_SIGDET_CTL1r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl1[1];
	uint32_t _sigdet_ctl1;
} BCMI_FALCON_XGXS_SIGDET_CTL1r_t;

#define BCMI_FALCON_XGXS_SIGDET_CTL1r_CLR(r) (r).sigdet_ctl1[0] = 0
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SET(r,d) (r).sigdet_ctl1[0] = d
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_GET(r) (r).sigdet_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET(r) ((((r).sigdet_ctl1[0]) >> 11) & 0x1f)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET(r) ((((r).sigdet_ctl1[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET(r) ((((r).sigdet_ctl1[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET(r) ((((r).sigdet_ctl1[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET(r) ((((r).sigdet_ctl1[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET(r) ((((r).sigdet_ctl1[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET(r) ((((r).sigdet_ctl1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET(r) (((r).sigdet_ctl1[0]) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET(r,f) (r).sigdet_ctl1[0]=(((r).sigdet_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_FALCON_XGXS_WRITE_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL1r,(_r._sigdet_ctl1))
#define BCMI_FALCON_XGXS_READLN_SIGDET_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_SIGDET_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_SIGDET_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL1r BCMI_FALCON_XGXS_SIGDET_CTL1r
#define SIGDET_CTL1r_SIZE BCMI_FALCON_XGXS_SIGDET_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_SIGDET_CTL1r_t SIGDET_CTL1r_t;
#define SIGDET_CTL1r_CLR BCMI_FALCON_XGXS_SIGDET_CTL1r_CLR
#define SIGDET_CTL1r_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_SET
#define SIGDET_CTL1r_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_MASK_COUNTf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FRCf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRC_VALf_SET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_GET
#define SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_ENERGY_DETECT_FRCf_SET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_GET
#define SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_SIGNAL_DETECT_FILTER_1USf_SET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_GET
#define SIGDET_CTL1r_IGNORE_LP_MODEf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_IGNORE_LP_MODEf_SET
#define SIGDET_CTL1r_EXT_LOS_INVf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_GET
#define SIGDET_CTL1r_EXT_LOS_INVf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_INVf_SET
#define SIGDET_CTL1r_EXT_LOS_ENf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_GET
#define SIGDET_CTL1r_EXT_LOS_ENf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_EXT_LOS_ENf_SET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET BCMI_FALCON_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_GET
#define SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET BCMI_FALCON_XGXS_SIGDET_CTL1r_AFE_SIGNAL_DETECT_DISf_SET
#define READ_SIGDET_CTL1r BCMI_FALCON_XGXS_READ_SIGDET_CTL1r
#define WRITE_SIGDET_CTL1r BCMI_FALCON_XGXS_WRITE_SIGDET_CTL1r
#define MODIFY_SIGDET_CTL1r BCMI_FALCON_XGXS_MODIFY_SIGDET_CTL1r
#define READLN_SIGDET_CTL1r BCMI_FALCON_XGXS_READLN_SIGDET_CTL1r
#define WRITELN_SIGDET_CTL1r BCMI_FALCON_XGXS_WRITELN_SIGDET_CTL1r
#define WRITEALL_SIGDET_CTL1r BCMI_FALCON_XGXS_WRITEALL_SIGDET_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_SIGDET_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  SIGDET_CTL2
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e2
 * DEVAD:    1
 * DESC:     CTRL_2
 * RESETVAL: 0x3f22 (16162)
 * ACCESS:   R/W
 * FIELDS:
 *     LOS_THRESH       AFE signal detect threshold to be used when filtered signal_detect == 1.
 *     SIGNAL_DETECT_THRESH AFE signal detect threshold to be used when filtered signal_detect == 0.
 *     HOLD_LOS_COUNT   HOLD_LOS state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 *     HOLD_SD_COUNT    HOLD_SD state counter. Value 0 to 7 maps to 2 to 16 in increments of 2.
 */
#define BCMI_FALCON_XGXS_SIGDET_CTL2r (0x0001d0e2 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_SIGDET_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_CTL2.
 */
typedef union BCMI_FALCON_XGXS_SIGDET_CTL2r_s {
	uint32_t v[1];
	uint32_t sigdet_ctl2[1];
	uint32_t _sigdet_ctl2;
} BCMI_FALCON_XGXS_SIGDET_CTL2r_t;

#define BCMI_FALCON_XGXS_SIGDET_CTL2r_CLR(r) (r).sigdet_ctl2[0] = 0
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_SET(r,d) (r).sigdet_ctl2[0] = d
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_GET(r) (r).sigdet_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 11) & 0x7)
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET(r) ((((r).sigdet_ctl2[0]) >> 8) & 0x7)
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET(r) ((((r).sigdet_ctl2[0]) >> 4) & 0x7)
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7 << 4)) | ((((uint32_t)f) & 0x7) << 4)) | (7 << (16 + 4))
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET(r) (((r).sigdet_ctl2[0]) & 0x7)
#define BCMI_FALCON_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET(r,f) (r).sigdet_ctl2[0]=(((r).sigdet_ctl2[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access SIGDET_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_FALCON_XGXS_WRITE_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL2r,(_r._sigdet_ctl2))
#define BCMI_FALCON_XGXS_READLN_SIGDET_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_SIGDET_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_SIGDET_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_CTL2r BCMI_FALCON_XGXS_SIGDET_CTL2r
#define SIGDET_CTL2r_SIZE BCMI_FALCON_XGXS_SIGDET_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_SIGDET_CTL2r_t SIGDET_CTL2r_t;
#define SIGDET_CTL2r_CLR BCMI_FALCON_XGXS_SIGDET_CTL2r_CLR
#define SIGDET_CTL2r_SET BCMI_FALCON_XGXS_SIGDET_CTL2r_SET
#define SIGDET_CTL2r_GET BCMI_FALCON_XGXS_SIGDET_CTL2r_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_GET BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_GET
#define SIGDET_CTL2r_HOLD_SD_COUNTf_SET BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_SD_COUNTf_SET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_GET BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_GET
#define SIGDET_CTL2r_HOLD_LOS_COUNTf_SET BCMI_FALCON_XGXS_SIGDET_CTL2r_HOLD_LOS_COUNTf_SET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET BCMI_FALCON_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_GET
#define SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET BCMI_FALCON_XGXS_SIGDET_CTL2r_SIGNAL_DETECT_THRESHf_SET
#define SIGDET_CTL2r_LOS_THRESHf_GET BCMI_FALCON_XGXS_SIGDET_CTL2r_LOS_THRESHf_GET
#define SIGDET_CTL2r_LOS_THRESHf_SET BCMI_FALCON_XGXS_SIGDET_CTL2r_LOS_THRESHf_SET
#define READ_SIGDET_CTL2r BCMI_FALCON_XGXS_READ_SIGDET_CTL2r
#define WRITE_SIGDET_CTL2r BCMI_FALCON_XGXS_WRITE_SIGDET_CTL2r
#define MODIFY_SIGDET_CTL2r BCMI_FALCON_XGXS_MODIFY_SIGDET_CTL2r
#define READLN_SIGDET_CTL2r BCMI_FALCON_XGXS_READLN_SIGDET_CTL2r
#define WRITELN_SIGDET_CTL2r BCMI_FALCON_XGXS_WRITELN_SIGDET_CTL2r
#define WRITEALL_SIGDET_CTL2r BCMI_FALCON_XGXS_WRITEALL_SIGDET_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_SIGDET_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  SIGDET_STS0
 * BLOCKS:   SIGDET
 * REGADDR:  0xd0e8
 * DEVAD:    1
 * DESC:     STATUS_0
 * RESETVAL: 0x200 (512)
 * ACCESS:   R/O
 * FIELDS:
 *     SIGNAL_DETECT    Filtered version of Signal Detect after frc/frc_val.
 *     SIGNAL_DETECT_CHANGE This latches the transition on signal_detect and cleared on read.
 *     ENERGY_DETECT    Filtered version of Energy Detect after frc/frc_val.
 *     ENERGY_DETECT_CHANGE This latches the transition on energy_detect and cleared on read.
 *     SIGNAL_DETECT_RAW Raw version of Signal Detect going into the filter.
 *     SIGNAL_DETECT_RAW_CHANGE This latches the transition on signal_detect_raw and cleared on read.
 *     AFE_SIGDET_THRESH Live status of sigdet_thresh going to AFE.
 */
#define BCMI_FALCON_XGXS_SIGDET_STS0r (0x0001d0e8 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIZE 4

/*
 * This structure should be used to declare and program SIGDET_STS0.
 */
typedef union BCMI_FALCON_XGXS_SIGDET_STS0r_s {
	uint32_t v[1];
	uint32_t sigdet_sts0[1];
	uint32_t _sigdet_sts0;
} BCMI_FALCON_XGXS_SIGDET_STS0r_t;

#define BCMI_FALCON_XGXS_SIGDET_STS0r_CLR(r) (r).sigdet_sts0[0] = 0
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SET(r,d) (r).sigdet_sts0[0] = d
#define BCMI_FALCON_XGXS_SIGDET_STS0r_GET(r) (r).sigdet_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_GET(r) ((((r).sigdet_sts0[0]) >> 8) & 0x7)
#define BCMI_FALCON_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET(r) ((((r).sigdet_sts0[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECTf_GET(r) ((((r).sigdet_sts0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET(r) ((((r).sigdet_sts0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET(r) (((r).sigdet_sts0[0]) & 0x1)
#define BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET(r,f) (r).sigdet_sts0[0]=(((r).sigdet_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access SIGDET_STS0.
 */
#define BCMI_FALCON_XGXS_READ_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_FALCON_XGXS_WRITE_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_STS0r,(_r._sigdet_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_STS0r,(_r._sigdet_sts0))
#define BCMI_FALCON_XGXS_READLN_SIGDET_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_FALCON_XGXS_WRITELN_SIGDET_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._sigdet_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_SIGDET_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_SIGDET_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._sigdet_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define SIGDET_STS0r BCMI_FALCON_XGXS_SIGDET_STS0r
#define SIGDET_STS0r_SIZE BCMI_FALCON_XGXS_SIGDET_STS0r_SIZE
typedef BCMI_FALCON_XGXS_SIGDET_STS0r_t SIGDET_STS0r_t;
#define SIGDET_STS0r_CLR BCMI_FALCON_XGXS_SIGDET_STS0r_CLR
#define SIGDET_STS0r_SET BCMI_FALCON_XGXS_SIGDET_STS0r_SET
#define SIGDET_STS0r_GET BCMI_FALCON_XGXS_SIGDET_STS0r_GET
#define SIGDET_STS0r_AFE_SIGDET_THRESHf_GET BCMI_FALCON_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_GET
#define SIGDET_STS0r_AFE_SIGDET_THRESHf_SET BCMI_FALCON_XGXS_SIGDET_STS0r_AFE_SIGDET_THRESHf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAW_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_RAWf_SET
#define SIGDET_STS0r_ENERGY_DETECT_CHANGEf_GET BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_GET
#define SIGDET_STS0r_ENERGY_DETECT_CHANGEf_SET BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECT_CHANGEf_SET
#define SIGDET_STS0r_ENERGY_DETECTf_GET BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECTf_GET
#define SIGDET_STS0r_ENERGY_DETECTf_SET BCMI_FALCON_XGXS_SIGDET_STS0r_ENERGY_DETECTf_SET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_GET
#define SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECT_CHANGEf_SET
#define SIGDET_STS0r_SIGNAL_DETECTf_GET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_GET
#define SIGDET_STS0r_SIGNAL_DETECTf_SET BCMI_FALCON_XGXS_SIGDET_STS0r_SIGNAL_DETECTf_SET
#define READ_SIGDET_STS0r BCMI_FALCON_XGXS_READ_SIGDET_STS0r
#define WRITE_SIGDET_STS0r BCMI_FALCON_XGXS_WRITE_SIGDET_STS0r
#define MODIFY_SIGDET_STS0r BCMI_FALCON_XGXS_MODIFY_SIGDET_STS0r
#define READLN_SIGDET_STS0r BCMI_FALCON_XGXS_READLN_SIGDET_STS0r
#define WRITELN_SIGDET_STS0r BCMI_FALCON_XGXS_WRITELN_SIGDET_STS0r
#define WRITEALL_SIGDET_STS0r BCMI_FALCON_XGXS_WRITEALL_SIGDET_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_SIGDET_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_REVID0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd100
 * DEVAD:    1
 * DESC:     REVID0
 * RESETVAL: 0x2db (731)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_MODEL      model number
 *     REVID_PROCESS    technology process0 = 90nm1 = 65nm2 = 40nm3 = 28nm4 = 20nm5 = 16nm6-7 = reserved
 *     REVID_BONDING    bonding0 = wire bond1 = flip chip2-3 = reserved
 *     REVID_REV_NUMBER Metal mask revision number
 *     REVID_REV_LETTER All layer revision letter0 = revA1 = revB2 = revC3 = revD
 */
#define BCMI_FALCON_XGXS_DIG_REVID0r (0x0001d100 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_REVID0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID0.
 */
typedef union BCMI_FALCON_XGXS_DIG_REVID0r_s {
	uint32_t v[1];
	uint32_t dig_revid0[1];
	uint32_t _dig_revid0;
} BCMI_FALCON_XGXS_DIG_REVID0r_t;

#define BCMI_FALCON_XGXS_DIG_REVID0r_CLR(r) (r).dig_revid0[0] = 0
#define BCMI_FALCON_XGXS_DIG_REVID0r_SET(r,d) (r).dig_revid0[0] = d
#define BCMI_FALCON_XGXS_DIG_REVID0r_GET(r) (r).dig_revid0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET(r) ((((r).dig_revid0[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET(r) ((((r).dig_revid0[0]) >> 11) & 0x7)
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_BONDINGf_GET(r) ((((r).dig_revid0[0]) >> 9) & 0x3)
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_BONDINGf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3 << 9)) | ((((uint32_t)f) & 0x3) << 9)) | (3 << (16 + 9))
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_PROCESSf_GET(r) ((((r).dig_revid0[0]) >> 6) & 0x7)
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_PROCESSf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x7 << 6)) | ((((uint32_t)f) & 0x7) << 6)) | (7 << (16 + 6))
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_MODELf_GET(r) (((r).dig_revid0[0]) & 0x3f)
#define BCMI_FALCON_XGXS_DIG_REVID0r_REVID_MODELf_SET(r,f) (r).dig_revid0[0]=(((r).dig_revid0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access DIG_REVID0.
 */
#define BCMI_FALCON_XGXS_READ_DIG_REVID0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_FALCON_XGXS_WRITE_DIG_REVID0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID0r,(_r._dig_revid0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_REVID0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID0r,(_r._dig_revid0))
#define BCMI_FALCON_XGXS_READLN_DIG_REVID0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_FALCON_XGXS_WRITELN_DIG_REVID0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid0))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_REVID0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID0r BCMI_FALCON_XGXS_DIG_REVID0r
#define DIG_REVID0r_SIZE BCMI_FALCON_XGXS_DIG_REVID0r_SIZE
typedef BCMI_FALCON_XGXS_DIG_REVID0r_t DIG_REVID0r_t;
#define DIG_REVID0r_CLR BCMI_FALCON_XGXS_DIG_REVID0r_CLR
#define DIG_REVID0r_SET BCMI_FALCON_XGXS_DIG_REVID0r_SET
#define DIG_REVID0r_GET BCMI_FALCON_XGXS_DIG_REVID0r_GET
#define DIG_REVID0r_REVID_REV_LETTERf_GET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_LETTERf_GET
#define DIG_REVID0r_REVID_REV_LETTERf_SET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_LETTERf_SET
#define DIG_REVID0r_REVID_REV_NUMBERf_GET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_GET
#define DIG_REVID0r_REVID_REV_NUMBERf_SET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_REV_NUMBERf_SET
#define DIG_REVID0r_REVID_BONDINGf_GET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_BONDINGf_GET
#define DIG_REVID0r_REVID_BONDINGf_SET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_BONDINGf_SET
#define DIG_REVID0r_REVID_PROCESSf_GET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_PROCESSf_GET
#define DIG_REVID0r_REVID_PROCESSf_SET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_PROCESSf_SET
#define DIG_REVID0r_REVID_MODELf_GET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_MODELf_GET
#define DIG_REVID0r_REVID_MODELf_SET BCMI_FALCON_XGXS_DIG_REVID0r_REVID_MODELf_SET
#define READ_DIG_REVID0r BCMI_FALCON_XGXS_READ_DIG_REVID0r
#define WRITE_DIG_REVID0r BCMI_FALCON_XGXS_WRITE_DIG_REVID0r
#define MODIFY_DIG_REVID0r BCMI_FALCON_XGXS_MODIFY_DIG_REVID0r
#define READLN_DIG_REVID0r BCMI_FALCON_XGXS_READLN_DIG_REVID0r
#define WRITELN_DIG_REVID0r BCMI_FALCON_XGXS_WRITELN_DIG_REVID0r
#define WRITEALL_DIG_REVID0r BCMI_FALCON_XGXS_WRITEALL_DIG_REVID0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_REVID0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_RST_CTL_PMD
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd101
 * DEVAD:    1
 * DESC:     RESET_CONTROL_PMD
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_S_RSTB      Active Low Core Level Soft Reset. If asserted by writing to 1'b0 will reset the whole core.This soft reset is equivalent to the hard reset input pin pmd_por_h_rstb. This regiter bit can only bereset by assertion of the hard reset input pin pmd_por_h_rstb
 */
#define BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr (0x0001d101 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_PMD.
 */
typedef union BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_pmd[1];
	uint32_t _dig_rst_ctl_pmd;
} BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_t;

#define BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_CLR(r) (r).dig_rst_ctl_pmd[0] = 0
#define BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_SET(r,d) (r).dig_rst_ctl_pmd[0] = d
#define BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_GET(r) (r).dig_rst_ctl_pmd[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET(r) (((r).dig_rst_ctl_pmd[0]) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET(r,f) (r).dig_rst_ctl_pmd[0]=(((r).dig_rst_ctl_pmd[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_RST_CTL_PMD.
 */
#define BCMI_FALCON_XGXS_READ_DIG_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_FALCON_XGXS_WRITE_DIG_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr,(_r._dig_rst_ctl_pmd))
#define BCMI_FALCON_XGXS_READLN_DIG_RST_CTL_PMDr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_FALCON_XGXS_WRITELN_DIG_RST_CTL_PMDr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_pmd))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_RST_CTL_PMDr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_pmd))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_PMDr BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr
#define DIG_RST_CTL_PMDr_SIZE BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_SIZE
typedef BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_t DIG_RST_CTL_PMDr_t;
#define DIG_RST_CTL_PMDr_CLR BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_CLR
#define DIG_RST_CTL_PMDr_SET BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_SET
#define DIG_RST_CTL_PMDr_GET BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_GET
#define DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr_CORE_S_RSTBf_SET
#define READ_DIG_RST_CTL_PMDr BCMI_FALCON_XGXS_READ_DIG_RST_CTL_PMDr
#define WRITE_DIG_RST_CTL_PMDr BCMI_FALCON_XGXS_WRITE_DIG_RST_CTL_PMDr
#define MODIFY_DIG_RST_CTL_PMDr BCMI_FALCON_XGXS_MODIFY_DIG_RST_CTL_PMDr
#define READLN_DIG_RST_CTL_PMDr BCMI_FALCON_XGXS_READLN_DIG_RST_CTL_PMDr
#define WRITELN_DIG_RST_CTL_PMDr BCMI_FALCON_XGXS_WRITELN_DIG_RST_CTL_PMDr
#define WRITEALL_DIG_RST_CTL_PMDr BCMI_FALCON_XGXS_WRITEALL_DIG_RST_CTL_PMDr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_RST_CTL_PMDr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_RST_CTL_CORE_DP
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd102
 * DEVAD:    1
 * DESC:     RESET_CONTROL_CORE_DP
 * RESETVAL: 0x4000 (16384)
 * ACCESS:   R/W
 * FIELDS:
 *     PMD_CORE_DP_H_RSTB_PKILL 1'b1 will disable the pmd_core_dp_h_rstb pin.
 *     SUP_RST_SEQ_FRC_VAL Suppress reset sequence force value.
 *     SUP_RST_SEQ_FRC  Suppress reset sequence force.
 *     PMD_MDIO_TRANS_PKILL 1'b1 will disable the pmd_mdio_trans pin.
 *     PMD_TX_CLK_VLD_FRC pmd_tx_clk_vld core output pin force.
 *     PMD_TX_CLK_VLD_FRC_VAL pmd_tx_clk_vld core output pin force value.
 *     TX_S_COMCLK_SEL  Mux control for selection of comclk for TX Lane clocks.If asserted by writing to 1'b1 will select the comclk for the lane clocks.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_sel is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     TX_S_COMCLK_FRC_ON Mux control for selection of comclk for TX Lane clocks by force.If asserted by writing to 1'b1 will select the comclk for the TX lane clocks. This is a debug bit and should be only used if lane clock from AFE is dead.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_comclk_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     TX_S_CLKGATE_FRC_ON TX Active High Lane clock gator enable. If 1'1b1 then tx lane clock will be gated off. It does not affect the tclk goingto RMIC block so tx lane based registers can still be readable but not writable.It is recommended for user to force pmd_tx_clk_vld to 1'b0 while tx_s_clkgate_frc_on is asserted to 1'b1by using pmd_tx_clk_vld_frc/frc_val registers.
 *     AFE_S_PLL_RESET_FRC_VAL Active High PLL Reset force value control.
 *     AFE_S_PLL_RESET_FRC Active High PLL Reset force control.
 *     TX_PI_LOOP_FILTER_STABLE This register bit is ANDed with pmd_tx_clk_vld before frc/frc_val mux. This register will be controlled by the firmware when TX_PI is enabled.When TX_PI is enabled then this register will be written to 1'b0 while TX_PI is acquiring the lock with the source clock and will be written to 1'b1 by firmwareto indicate that clocks are locked. It indicates to chip level via pmd_tx_clk_vld to reset any datapath FIFOs and come out of reset when TX clock is stable.
 */
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr (0x0001d102 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_CTL_CORE_DP.
 */
typedef union BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_s {
	uint32_t v[1];
	uint32_t dig_rst_ctl_core_dp[1];
	uint32_t _dig_rst_ctl_core_dp;
} BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_t;

#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_CLR(r) (r).dig_rst_ctl_core_dp[0] = 0
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SET(r,d) (r).dig_rst_ctl_core_dp[0] = d
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_GET(r) (r).dig_rst_ctl_core_dp[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET(r) ((((r).dig_rst_ctl_core_dp[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET(r,f) (r).dig_rst_ctl_core_dp[0]=(((r).dig_rst_ctl_core_dp[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))

/*
 * These macros can be used to access DIG_RST_CTL_CORE_DP.
 */
#define BCMI_FALCON_XGXS_READ_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_FALCON_XGXS_WRITE_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr,(_r._dig_rst_ctl_core_dp))
#define BCMI_FALCON_XGXS_READLN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_FALCON_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_ctl_core_dp))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_ctl_core_dp))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_CTL_CORE_DPr BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr
#define DIG_RST_CTL_CORE_DPr_SIZE BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SIZE
typedef BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_t DIG_RST_CTL_CORE_DPr_t;
#define DIG_RST_CTL_CORE_DPr_CLR BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_CLR
#define DIG_RST_CTL_CORE_DPr_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SET
#define DIG_RST_CTL_CORE_DPr_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_GET
#define DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_GET
#define DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_PI_LOOP_FILTER_STABLEf_SET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_AFE_S_PLL_RESET_FRC_VALf_SET
#define DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_GET
#define DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_CLKGATE_FRC_ONf_SET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_GET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_FRC_ONf_SET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_GET
#define DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_TX_S_COMCLK_SELf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRC_VALf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_TX_CLK_VLD_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_MDIO_TRANS_PKILLf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRCf_SET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_GET
#define DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_SUP_RST_SEQ_FRC_VALf_SET
#define DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_GET
#define DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr_PMD_CORE_DP_H_RSTB_PKILLf_SET
#define READ_DIG_RST_CTL_CORE_DPr BCMI_FALCON_XGXS_READ_DIG_RST_CTL_CORE_DPr
#define WRITE_DIG_RST_CTL_CORE_DPr BCMI_FALCON_XGXS_WRITE_DIG_RST_CTL_CORE_DPr
#define MODIFY_DIG_RST_CTL_CORE_DPr BCMI_FALCON_XGXS_MODIFY_DIG_RST_CTL_CORE_DPr
#define READLN_DIG_RST_CTL_CORE_DPr BCMI_FALCON_XGXS_READLN_DIG_RST_CTL_CORE_DPr
#define WRITELN_DIG_RST_CTL_CORE_DPr BCMI_FALCON_XGXS_WRITELN_DIG_RST_CTL_CORE_DPr
#define WRITEALL_DIG_RST_CTL_CORE_DPr BCMI_FALCON_XGXS_WRITEALL_DIG_RST_CTL_CORE_DPr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_RST_CTL_CORE_DPr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_LN_MASK
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd103
 * DEVAD:    1
 * DESC:     LANE_MASK
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_MULTICAST_MASK_CONTROL This masks the lane from a broadcast or multicast write operation.
 */
#define BCMI_FALCON_XGXS_DIG_LN_MASKr (0x0001d103 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_LN_MASKr_SIZE 4

/*
 * This structure should be used to declare and program DIG_LN_MASK.
 */
typedef union BCMI_FALCON_XGXS_DIG_LN_MASKr_s {
	uint32_t v[1];
	uint32_t dig_ln_mask[1];
	uint32_t _dig_ln_mask;
} BCMI_FALCON_XGXS_DIG_LN_MASKr_t;

#define BCMI_FALCON_XGXS_DIG_LN_MASKr_CLR(r) (r).dig_ln_mask[0] = 0
#define BCMI_FALCON_XGXS_DIG_LN_MASKr_SET(r,d) (r).dig_ln_mask[0] = d
#define BCMI_FALCON_XGXS_DIG_LN_MASKr_GET(r) (r).dig_ln_mask[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_LN_MASKr_CORE_MULTICAST_MASK_CONTROLf_GET(r) (((r).dig_ln_mask[0]) & 0xf)
#define BCMI_FALCON_XGXS_DIG_LN_MASKr_CORE_MULTICAST_MASK_CONTROLf_SET(r,f) (r).dig_ln_mask[0]=(((r).dig_ln_mask[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DIG_LN_MASK.
 */
#define BCMI_FALCON_XGXS_READ_DIG_LN_MASKr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_LN_MASKr,(_r._dig_ln_mask))
#define BCMI_FALCON_XGXS_WRITE_DIG_LN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_MASKr,(_r._dig_ln_mask)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_LN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_MASKr,(_r._dig_ln_mask))
#define BCMI_FALCON_XGXS_READLN_DIG_LN_MASKr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_LN_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_ln_mask))
#define BCMI_FALCON_XGXS_WRITELN_DIG_LN_MASKr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_MASKr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_ln_mask))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_LN_MASKr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_MASKr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_ln_mask))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_LN_MASKr BCMI_FALCON_XGXS_DIG_LN_MASKr
#define DIG_LN_MASKr_SIZE BCMI_FALCON_XGXS_DIG_LN_MASKr_SIZE
typedef BCMI_FALCON_XGXS_DIG_LN_MASKr_t DIG_LN_MASKr_t;
#define DIG_LN_MASKr_CLR BCMI_FALCON_XGXS_DIG_LN_MASKr_CLR
#define DIG_LN_MASKr_SET BCMI_FALCON_XGXS_DIG_LN_MASKr_SET
#define DIG_LN_MASKr_GET BCMI_FALCON_XGXS_DIG_LN_MASKr_GET
#define DIG_LN_MASKr_CORE_MULTICAST_MASK_CONTROLf_GET BCMI_FALCON_XGXS_DIG_LN_MASKr_CORE_MULTICAST_MASK_CONTROLf_GET
#define DIG_LN_MASKr_CORE_MULTICAST_MASK_CONTROLf_SET BCMI_FALCON_XGXS_DIG_LN_MASKr_CORE_MULTICAST_MASK_CONTROLf_SET
#define READ_DIG_LN_MASKr BCMI_FALCON_XGXS_READ_DIG_LN_MASKr
#define WRITE_DIG_LN_MASKr BCMI_FALCON_XGXS_WRITE_DIG_LN_MASKr
#define MODIFY_DIG_LN_MASKr BCMI_FALCON_XGXS_MODIFY_DIG_LN_MASKr
#define READLN_DIG_LN_MASKr BCMI_FALCON_XGXS_READLN_DIG_LN_MASKr
#define WRITELN_DIG_LN_MASKr BCMI_FALCON_XGXS_WRITELN_DIG_LN_MASKr
#define WRITEALL_DIG_LN_MASKr BCMI_FALCON_XGXS_WRITEALL_DIG_LN_MASKr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_LN_MASKr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_TOP_USER_CTL0
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd104
 * DEVAD:    1
 * DESC:     TOP_USER_CONTROL_0
 * RESETVAL: 0x271 (625)
 * ACCESS:   R/W
 * FIELDS:
 *     HEARTBEAT_COUNT_1US Heartbeat timer count in comclk cycles to create 1us heartbeat_1us period. It should be programmed to the nearest increment of 0.25Mhz value of the comclk frequency in Mhz.For example, for comclk of 125 Mhz, it should be programmed to 10'd500. For 156.25 Mhz comclk, it should be programmed to 10'd625 and similarly for any other comclk frequency.
 *     CORE_DP_S_RSTB   Active Low Core Level Datapath Soft Reset. If asserted by writingto 1'b0 will reset datapath logic of all the lanes. This soft resetis equivalent to the hard reset input pin core_dp_h_rstb. Assertion of this
 *     AFE_S_PLL_PWRDN  Active High PLL Power Down control.
 *     UC_ACTIVE        When set to 1'b1 then Hardware should wait for uC handshakes to wake up from datapath resetWhen set to 1'b0 then Hardware can internally assume that uc_ack_* = 1.
 */
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r (0x0001d104 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TOP_USER_CTL0.
 */
typedef union BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_s {
	uint32_t v[1];
	uint32_t dig_top_user_ctl0[1];
	uint32_t _dig_top_user_ctl0;
} BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_t;

#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_CLR(r) (r).dig_top_user_ctl0[0] = 0
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_SET(r,d) (r).dig_top_user_ctl0[0] = d
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_GET(r) (r).dig_top_user_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET(r) ((((r).dig_top_user_ctl0[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET(r) (((r).dig_top_user_ctl0[0]) & 0x3ff)
#define BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET(r,f) (r).dig_top_user_ctl0[0]=(((r).dig_top_user_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access DIG_TOP_USER_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_FALCON_XGXS_WRITE_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r,(_r._dig_top_user_ctl0))
#define BCMI_FALCON_XGXS_READLN_DIG_TOP_USER_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_DIG_TOP_USER_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_top_user_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_TOP_USER_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_top_user_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_TOP_USER_CTL0r BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r
#define DIG_TOP_USER_CTL0r_SIZE BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_t DIG_TOP_USER_CTL0r_t;
#define DIG_TOP_USER_CTL0r_CLR BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_CLR
#define DIG_TOP_USER_CTL0r_SET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_SET
#define DIG_TOP_USER_CTL0r_GET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_GET
#define DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_GET
#define DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_UC_ACTIVEf_SET
#define DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_GET
#define DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_AFE_S_PLL_PWRDNf_SET
#define DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_GET
#define DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_CORE_DP_S_RSTBf_SET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_GET
#define DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r_HEARTBEAT_COUNT_1USf_SET
#define READ_DIG_TOP_USER_CTL0r BCMI_FALCON_XGXS_READ_DIG_TOP_USER_CTL0r
#define WRITE_DIG_TOP_USER_CTL0r BCMI_FALCON_XGXS_WRITE_DIG_TOP_USER_CTL0r
#define MODIFY_DIG_TOP_USER_CTL0r BCMI_FALCON_XGXS_MODIFY_DIG_TOP_USER_CTL0r
#define READLN_DIG_TOP_USER_CTL0r BCMI_FALCON_XGXS_READLN_DIG_TOP_USER_CTL0r
#define WRITELN_DIG_TOP_USER_CTL0r BCMI_FALCON_XGXS_WRITELN_DIG_TOP_USER_CTL0r
#define WRITEALL_DIG_TOP_USER_CTL0r BCMI_FALCON_XGXS_WRITEALL_DIG_TOP_USER_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_TOP_USER_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_UC_ACK_CORE_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd105
 * DEVAD:    1
 * DESC:     UC_ACK_CORE_CONTROL
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     UC_ACK_CORE_CFG_DONE uC will write this to 1 to indicate it's configuration of the core is complete. Writing to 1'b1 willshould release internal hold on core_dp_reset, only if core_dp_reset_state is 3'b001.
 *     UC_ACK_CORE_DP_RESET uC will write this to 1 to acknowledge a reset event after seeing "core_dp_reset_coccured".
 */
#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr (0x0001d105 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_UC_ACK_CORE_CTL.
 */
typedef union BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_s {
	uint32_t v[1];
	uint32_t dig_uc_ack_core_ctl[1];
	uint32_t _dig_uc_ack_core_ctl;
} BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_t;

#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_CLR(r) (r).dig_uc_ack_core_ctl[0] = 0
#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_SET(r,d) (r).dig_uc_ack_core_ctl[0] = d
#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_GET(r) (r).dig_uc_ack_core_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET(r) ((((r).dig_uc_ack_core_ctl[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET(r,f) (r).dig_uc_ack_core_ctl[0]=(((r).dig_uc_ack_core_ctl[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET(r) (((r).dig_uc_ack_core_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET(r,f) (r).dig_uc_ack_core_ctl[0]=(((r).dig_uc_ack_core_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_UC_ACK_CORE_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DIG_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr,(_r._dig_uc_ack_core_ctl))
#define BCMI_FALCON_XGXS_WRITE_DIG_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr,(_r._dig_uc_ack_core_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr,(_r._dig_uc_ack_core_ctl))
#define BCMI_FALCON_XGXS_READLN_DIG_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_uc_ack_core_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DIG_UC_ACK_CORE_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_uc_ack_core_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_UC_ACK_CORE_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_uc_ack_core_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_UC_ACK_CORE_CTLr BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr
#define DIG_UC_ACK_CORE_CTLr_SIZE BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_t DIG_UC_ACK_CORE_CTLr_t;
#define DIG_UC_ACK_CORE_CTLr_CLR BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_CLR
#define DIG_UC_ACK_CORE_CTLr_SET BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_SET
#define DIG_UC_ACK_CORE_CTLr_GET BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_GET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_GET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_DP_RESETf_SET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_GET
#define DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr_UC_ACK_CORE_CFG_DONEf_SET
#define READ_DIG_UC_ACK_CORE_CTLr BCMI_FALCON_XGXS_READ_DIG_UC_ACK_CORE_CTLr
#define WRITE_DIG_UC_ACK_CORE_CTLr BCMI_FALCON_XGXS_WRITE_DIG_UC_ACK_CORE_CTLr
#define MODIFY_DIG_UC_ACK_CORE_CTLr BCMI_FALCON_XGXS_MODIFY_DIG_UC_ACK_CORE_CTLr
#define READLN_DIG_UC_ACK_CORE_CTLr BCMI_FALCON_XGXS_READLN_DIG_UC_ACK_CORE_CTLr
#define WRITELN_DIG_UC_ACK_CORE_CTLr BCMI_FALCON_XGXS_WRITELN_DIG_UC_ACK_CORE_CTLr
#define WRITEALL_DIG_UC_ACK_CORE_CTLr BCMI_FALCON_XGXS_WRITEALL_DIG_UC_ACK_CORE_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_UC_ACK_CORE_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_CORE_RST_OCC_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd106
 * DEVAD:    1
 * DESC:     CORE_REG_RESET_OCCURRED_CONTROL
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/W
 * FIELDS:
 *     CORE_REG_RESET_OCCURRED Set to 1'b1 upon core level register reset and remains so until cleared by register write from uC.
 */
#define BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr (0x0001d106 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_RST_OCC_CTL.
 */
typedef union BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_s {
	uint32_t v[1];
	uint32_t dig_core_rst_occ_ctl[1];
	uint32_t _dig_core_rst_occ_ctl;
} BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_t;

#define BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_CLR(r) (r).dig_core_rst_occ_ctl[0] = 0
#define BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_SET(r,d) (r).dig_core_rst_occ_ctl[0] = d
#define BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_GET(r) (r).dig_core_rst_occ_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET(r) (((r).dig_core_rst_occ_ctl[0]) & 0x1)
#define BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET(r,f) (r).dig_core_rst_occ_ctl[0]=(((r).dig_core_rst_occ_ctl[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_CORE_RST_OCC_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl))
#define BCMI_FALCON_XGXS_WRITE_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr,(_r._dig_core_rst_occ_ctl))
#define BCMI_FALCON_XGXS_READLN_DIG_CORE_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_rst_occ_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DIG_CORE_RST_OCC_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_rst_occ_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_CORE_RST_OCC_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_rst_occ_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_RST_OCC_CTLr BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr
#define DIG_CORE_RST_OCC_CTLr_SIZE BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_t DIG_CORE_RST_OCC_CTLr_t;
#define DIG_CORE_RST_OCC_CTLr_CLR BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_CLR
#define DIG_CORE_RST_OCC_CTLr_SET BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_SET
#define DIG_CORE_RST_OCC_CTLr_GET BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_GET
#define DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr_CORE_REG_RESET_OCCURREDf_SET
#define READ_DIG_CORE_RST_OCC_CTLr BCMI_FALCON_XGXS_READ_DIG_CORE_RST_OCC_CTLr
#define WRITE_DIG_CORE_RST_OCC_CTLr BCMI_FALCON_XGXS_WRITE_DIG_CORE_RST_OCC_CTLr
#define MODIFY_DIG_CORE_RST_OCC_CTLr BCMI_FALCON_XGXS_MODIFY_DIG_CORE_RST_OCC_CTLr
#define READLN_DIG_CORE_RST_OCC_CTLr BCMI_FALCON_XGXS_READLN_DIG_CORE_RST_OCC_CTLr
#define WRITELN_DIG_CORE_RST_OCC_CTLr BCMI_FALCON_XGXS_WRITELN_DIG_CORE_RST_OCC_CTLr
#define WRITEALL_DIG_CORE_RST_OCC_CTLr BCMI_FALCON_XGXS_WRITEALL_DIG_CORE_RST_OCC_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_CORE_RST_OCC_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_RST_SEQ_TMR_CTL
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd107
 * DEVAD:    1
 * DESC:     RST_SEQ_TIMER_CONTROL
 * RESETVAL: 0x8304 (33540)
 * ACCESS:   R/W
 * FIELDS:
 *     RST_SEQ_TIMER    Defines the number of comclk cycles between de-assertion of AFE RX/TX lane reset and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 2 to 16 clock cycles between de-assertion of AFE RX/TX lane resetand clock muxing from comclk to lane clock. Wait_time = 2 * (rst_seq_timer + 1).
 *     PWRDN_SEQ_TIMER  Defines the number of comclk cycles between de-assertion of AFE RX/TX lane pwrdn and clock muxing from comclk to lane clock.Valid value range is from 0 to 7 which will provide from 8 to 64 clock cycles between de-assertion of AFE RX/TX lane pwrdnand clock muxing from comclk to lane clock. Wait_time = 8 * (pwrdn_seq_timer + 1).
 *     RST_SEQ_DIS_FLT_MODE Defines the filter mode for rst_seq_dis/pmd_mdio_trans pin.2'd0 - filter is bypassed where input is passed to output untouched.2'd1 - filter output is 16 comclk cycles if input is > 16 comclk cycles else output is same as input signal.2'd2 - filter output is 20 comclk cycles if input is > 20 comclk cycles else output is same as input signal.2'd3 - filter output is 24 comclk cycles if input is > 24 comclk cycles else output is same as input signal.
 */
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr (0x0001d107 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program DIG_RST_SEQ_TMR_CTL.
 */
typedef union BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t dig_rst_seq_tmr_ctl[1];
	uint32_t _dig_rst_seq_tmr_ctl;
} BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_t;

#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_CLR(r) (r).dig_rst_seq_tmr_ctl[0] = 0
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_SET(r,d) (r).dig_rst_seq_tmr_ctl[0] = d
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_GET(r) (r).dig_rst_seq_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 14) & 0x3)
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x3 << 14)) | ((((uint32_t)f) & 0x3) << 14)) | (3 << (16 + 14))
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET(r) ((((r).dig_rst_seq_tmr_ctl[0]) >> 8) & 0x7)
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7 << 8)) | ((((uint32_t)f) & 0x7) << 8)) | (7 << (16 + 8))
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET(r) (((r).dig_rst_seq_tmr_ctl[0]) & 0x7)
#define BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET(r,f) (r).dig_rst_seq_tmr_ctl[0]=(((r).dig_rst_seq_tmr_ctl[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DIG_RST_SEQ_TMR_CTL.
 */
#define BCMI_FALCON_XGXS_READ_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl))
#define BCMI_FALCON_XGXS_WRITE_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr,(_r._dig_rst_seq_tmr_ctl))
#define BCMI_FALCON_XGXS_READLN_DIG_RST_SEQ_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_seq_tmr_ctl))
#define BCMI_FALCON_XGXS_WRITELN_DIG_RST_SEQ_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_rst_seq_tmr_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_RST_SEQ_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_rst_seq_tmr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_RST_SEQ_TMR_CTLr BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr
#define DIG_RST_SEQ_TMR_CTLr_SIZE BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_SIZE
typedef BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_t DIG_RST_SEQ_TMR_CTLr_t;
#define DIG_RST_SEQ_TMR_CTLr_CLR BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_CLR
#define DIG_RST_SEQ_TMR_CTLr_SET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_SET
#define DIG_RST_SEQ_TMR_CTLr_GET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_DIS_FLT_MODEf_SET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_PWRDN_SEQ_TIMERf_SET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_GET
#define DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr_RST_SEQ_TIMERf_SET
#define READ_DIG_RST_SEQ_TMR_CTLr BCMI_FALCON_XGXS_READ_DIG_RST_SEQ_TMR_CTLr
#define WRITE_DIG_RST_SEQ_TMR_CTLr BCMI_FALCON_XGXS_WRITE_DIG_RST_SEQ_TMR_CTLr
#define MODIFY_DIG_RST_SEQ_TMR_CTLr BCMI_FALCON_XGXS_MODIFY_DIG_RST_SEQ_TMR_CTLr
#define READLN_DIG_RST_SEQ_TMR_CTLr BCMI_FALCON_XGXS_READLN_DIG_RST_SEQ_TMR_CTLr
#define WRITELN_DIG_RST_SEQ_TMR_CTLr BCMI_FALCON_XGXS_WRITELN_DIG_RST_SEQ_TMR_CTLr
#define WRITEALL_DIG_RST_SEQ_TMR_CTLr BCMI_FALCON_XGXS_WRITEALL_DIG_RST_SEQ_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_RST_SEQ_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_CORE_DP_RST_ST_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd108
 * DEVAD:    1
 * DESC:     CORE_DP_RESET_STATE_STATUS
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/O
 * FIELDS:
 *     CORE_DP_RESET_STATE Bit 2: core_dp_reset_active   : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls.Bit 1: core_dp_reset_occurred : Set to 1'b1 whenenver core_dp_reset is currently requested through any register or pin controls and is latched high.Bit 0: core_dp_reset_held     : Set to 1'b1 whenenver core_dp_reset is internally held. Cleared to 1'b0, only if core_dp_reset_state==001 and uc_ack_core_cfg_done == 1.
 *     LANE_RESET_RELEASED_INDEX Index of the lane number of the first lane in lane_reset_released state.
 *     LANE_RESET_RELEASED indicates if a lane is currently at {lane_dp_reset_active, lane_dp_reset_occurred} = 01.
 */
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr (0x0001d108 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_CORE_DP_RST_ST_STS.
 */
typedef union BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_s {
	uint32_t v[1];
	uint32_t dig_core_dp_rst_st_sts[1];
	uint32_t _dig_core_dp_rst_st_sts;
} BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_t;

#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR(r) (r).dig_core_dp_rst_st_sts[0] = 0
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_SET(r,d) (r).dig_core_dp_rst_st_sts[0] = d
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_GET(r) (r).dig_core_dp_rst_st_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET(r) ((((r).dig_core_dp_rst_st_sts[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET(r) (((r).dig_core_dp_rst_st_sts[0]) & 0x7)
#define BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET(r,f) (r).dig_core_dp_rst_st_sts[0]=(((r).dig_core_dp_rst_st_sts[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access DIG_CORE_DP_RST_ST_STS.
 */
#define BCMI_FALCON_XGXS_READ_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr,(_r._dig_core_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_core_dp_rst_st_sts))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_core_dp_rst_st_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_CORE_DP_RST_ST_STSr BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr
#define DIG_CORE_DP_RST_ST_STSr_SIZE BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_SIZE
typedef BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_t DIG_CORE_DP_RST_ST_STSr_t;
#define DIG_CORE_DP_RST_ST_STSr_CLR BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_CLR
#define DIG_CORE_DP_RST_ST_STSr_SET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_SET
#define DIG_CORE_DP_RST_ST_STSr_GET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASEDf_SET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_GET
#define DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_LANE_RESET_RELEASED_INDEXf_SET
#define DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_GET
#define DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr_CORE_DP_RESET_STATEf_SET
#define READ_DIG_CORE_DP_RST_ST_STSr BCMI_FALCON_XGXS_READ_DIG_CORE_DP_RST_ST_STSr
#define WRITE_DIG_CORE_DP_RST_ST_STSr BCMI_FALCON_XGXS_WRITE_DIG_CORE_DP_RST_ST_STSr
#define MODIFY_DIG_CORE_DP_RST_ST_STSr BCMI_FALCON_XGXS_MODIFY_DIG_CORE_DP_RST_ST_STSr
#define READLN_DIG_CORE_DP_RST_ST_STSr BCMI_FALCON_XGXS_READLN_DIG_CORE_DP_RST_ST_STSr
#define WRITELN_DIG_CORE_DP_RST_ST_STSr BCMI_FALCON_XGXS_WRITELN_DIG_CORE_DP_RST_ST_STSr
#define WRITEALL_DIG_CORE_DP_RST_ST_STSr BCMI_FALCON_XGXS_WRITEALL_DIG_CORE_DP_RST_ST_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_CORE_DP_RST_ST_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_PMD_CORE_MODE_STS
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd109
 * DEVAD:    1
 * DESC:     PMD_CORE_MODE_STATUS
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_CORE_MODE    This indicates the status of the core input pin pmd_core_mode.This is driven from PCS and used for communication between PCS and PMD Micro code.
 */
#define BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr (0x0001d109 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_SIZE 4

/*
 * This structure should be used to declare and program DIG_PMD_CORE_MODE_STS.
 */
typedef union BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_s {
	uint32_t v[1];
	uint32_t dig_pmd_core_mode_sts[1];
	uint32_t _dig_pmd_core_mode_sts;
} BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_t;

#define BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_CLR(r) (r).dig_pmd_core_mode_sts[0] = 0
#define BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_SET(r,d) (r).dig_pmd_core_mode_sts[0] = d
#define BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_GET(r) (r).dig_pmd_core_mode_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET(r) (((r).dig_pmd_core_mode_sts[0]) & 0xffff)
#define BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET(r,f) (r).dig_pmd_core_mode_sts[0]=(((r).dig_pmd_core_mode_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access DIG_PMD_CORE_MODE_STS.
 */
#define BCMI_FALCON_XGXS_READ_DIG_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr,(_r._dig_pmd_core_mode_sts))
#define BCMI_FALCON_XGXS_WRITE_DIG_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr,(_r._dig_pmd_core_mode_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr,(_r._dig_pmd_core_mode_sts))
#define BCMI_FALCON_XGXS_READLN_DIG_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_pmd_core_mode_sts))
#define BCMI_FALCON_XGXS_WRITELN_DIG_PMD_CORE_MODE_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_pmd_core_mode_sts))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_PMD_CORE_MODE_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_pmd_core_mode_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_PMD_CORE_MODE_STSr BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr
#define DIG_PMD_CORE_MODE_STSr_SIZE BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_SIZE
typedef BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_t DIG_PMD_CORE_MODE_STSr_t;
#define DIG_PMD_CORE_MODE_STSr_CLR BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_CLR
#define DIG_PMD_CORE_MODE_STSr_SET BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_SET
#define DIG_PMD_CORE_MODE_STSr_GET BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_GET
#define DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_GET
#define DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr_PMD_CORE_MODEf_SET
#define READ_DIG_PMD_CORE_MODE_STSr BCMI_FALCON_XGXS_READ_DIG_PMD_CORE_MODE_STSr
#define WRITE_DIG_PMD_CORE_MODE_STSr BCMI_FALCON_XGXS_WRITE_DIG_PMD_CORE_MODE_STSr
#define MODIFY_DIG_PMD_CORE_MODE_STSr BCMI_FALCON_XGXS_MODIFY_DIG_PMD_CORE_MODE_STSr
#define READLN_DIG_PMD_CORE_MODE_STSr BCMI_FALCON_XGXS_READLN_DIG_PMD_CORE_MODE_STSr
#define WRITELN_DIG_PMD_CORE_MODE_STSr BCMI_FALCON_XGXS_WRITELN_DIG_PMD_CORE_MODE_STSr
#define WRITEALL_DIG_PMD_CORE_MODE_STSr BCMI_FALCON_XGXS_WRITEALL_DIG_PMD_CORE_MODE_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_PMD_CORE_MODE_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_REVID1
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10a
 * DEVAD:    1
 * DESC:     REVID1
 * RESETVAL: 0x403c (16444)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID_EEE        EEE support present in core
 *     REVID_LLP        Ultra low latency path present in core
 *     REVID_PIR        PCS interface retiming flops present in core
 *     REVID_CL72       Clause 72 present in core
 *     REVID_MICRO      Microcontroller present in core
 *     REVID_MDIO       MDIO interface present in core
 *     REVID_MULTIPLICITY Number of lanes
 */
#define BCMI_FALCON_XGXS_DIG_REVID1r (0x0001d10a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_REVID1r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID1.
 */
typedef union BCMI_FALCON_XGXS_DIG_REVID1r_s {
	uint32_t v[1];
	uint32_t dig_revid1[1];
	uint32_t _dig_revid1;
} BCMI_FALCON_XGXS_DIG_REVID1r_t;

#define BCMI_FALCON_XGXS_DIG_REVID1r_CLR(r) (r).dig_revid1[0] = 0
#define BCMI_FALCON_XGXS_DIG_REVID1r_SET(r,d) (r).dig_revid1[0] = d
#define BCMI_FALCON_XGXS_DIG_REVID1r_GET(r) (r).dig_revid1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET(r) ((((r).dig_revid1[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MDIOf_GET(r) ((((r).dig_revid1[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MDIOf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MICROf_GET(r) ((((r).dig_revid1[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MICROf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_CL72f_GET(r) ((((r).dig_revid1[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_CL72f_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_PIRf_GET(r) ((((r).dig_revid1[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_PIRf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_LLPf_GET(r) ((((r).dig_revid1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_LLPf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_EEEf_GET(r) (((r).dig_revid1[0]) & 0x1)
#define BCMI_FALCON_XGXS_DIG_REVID1r_REVID_EEEf_SET(r,f) (r).dig_revid1[0]=(((r).dig_revid1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access DIG_REVID1.
 */
#define BCMI_FALCON_XGXS_READ_DIG_REVID1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_FALCON_XGXS_WRITE_DIG_REVID1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID1r,(_r._dig_revid1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_REVID1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID1r,(_r._dig_revid1))
#define BCMI_FALCON_XGXS_READLN_DIG_REVID1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_FALCON_XGXS_WRITELN_DIG_REVID1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid1))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_REVID1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID1r BCMI_FALCON_XGXS_DIG_REVID1r
#define DIG_REVID1r_SIZE BCMI_FALCON_XGXS_DIG_REVID1r_SIZE
typedef BCMI_FALCON_XGXS_DIG_REVID1r_t DIG_REVID1r_t;
#define DIG_REVID1r_CLR BCMI_FALCON_XGXS_DIG_REVID1r_CLR
#define DIG_REVID1r_SET BCMI_FALCON_XGXS_DIG_REVID1r_SET
#define DIG_REVID1r_GET BCMI_FALCON_XGXS_DIG_REVID1r_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_GET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_GET
#define DIG_REVID1r_REVID_MULTIPLICITYf_SET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MULTIPLICITYf_SET
#define DIG_REVID1r_REVID_MDIOf_GET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MDIOf_GET
#define DIG_REVID1r_REVID_MDIOf_SET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MDIOf_SET
#define DIG_REVID1r_REVID_MICROf_GET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MICROf_GET
#define DIG_REVID1r_REVID_MICROf_SET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_MICROf_SET
#define DIG_REVID1r_REVID_CL72f_GET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_CL72f_GET
#define DIG_REVID1r_REVID_CL72f_SET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_CL72f_SET
#define DIG_REVID1r_REVID_PIRf_GET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_PIRf_GET
#define DIG_REVID1r_REVID_PIRf_SET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_PIRf_SET
#define DIG_REVID1r_REVID_LLPf_GET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_LLPf_GET
#define DIG_REVID1r_REVID_LLPf_SET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_LLPf_SET
#define DIG_REVID1r_REVID_EEEf_GET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_EEEf_GET
#define DIG_REVID1r_REVID_EEEf_SET BCMI_FALCON_XGXS_DIG_REVID1r_REVID_EEEf_SET
#define READ_DIG_REVID1r BCMI_FALCON_XGXS_READ_DIG_REVID1r
#define WRITE_DIG_REVID1r BCMI_FALCON_XGXS_WRITE_DIG_REVID1r
#define MODIFY_DIG_REVID1r BCMI_FALCON_XGXS_MODIFY_DIG_REVID1r
#define READLN_DIG_REVID1r BCMI_FALCON_XGXS_READLN_DIG_REVID1r
#define WRITELN_DIG_REVID1r BCMI_FALCON_XGXS_WRITELN_DIG_REVID1r
#define WRITEALL_DIG_REVID1r BCMI_FALCON_XGXS_WRITEALL_DIG_REVID1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_REVID1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_TX_LN_MAP_0_1_2
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10b
 * DEVAD:    1
 * DESC:     TX_LANE_MAP_0_1_2
 * RESETVAL: 0x820 (2080)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LANE_MAP_0    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 0
 *     TX_LANE_MAP_1    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 1
 *     TX_LANE_MAP_2    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 2
 */
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r (0x0001d10b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TX_LN_MAP_0_1_2.
 */
typedef union BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_s {
	uint32_t v[1];
	uint32_t dig_tx_ln_map_0_1_2[1];
	uint32_t _dig_tx_ln_map_0_1_2;
} BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_t;

#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_CLR(r) (r).dig_tx_ln_map_0_1_2[0] = 0
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_SET(r,d) (r).dig_tx_ln_map_0_1_2[0] = d
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_GET(r) (r).dig_tx_ln_map_0_1_2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_GET(r) ((((r).dig_tx_ln_map_0_1_2[0]) >> 10) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_SET(r,f) (r).dig_tx_ln_map_0_1_2[0]=(((r).dig_tx_ln_map_0_1_2[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_GET(r) ((((r).dig_tx_ln_map_0_1_2[0]) >> 5) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_SET(r,f) (r).dig_tx_ln_map_0_1_2[0]=(((r).dig_tx_ln_map_0_1_2[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_GET(r) (((r).dig_tx_ln_map_0_1_2[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_SET(r,f) (r).dig_tx_ln_map_0_1_2[0]=(((r).dig_tx_ln_map_0_1_2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DIG_TX_LN_MAP_0_1_2.
 */
#define BCMI_FALCON_XGXS_READ_DIG_TX_LN_MAP_0_1_2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r,(_r._dig_tx_ln_map_0_1_2))
#define BCMI_FALCON_XGXS_WRITE_DIG_TX_LN_MAP_0_1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r,(_r._dig_tx_ln_map_0_1_2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_TX_LN_MAP_0_1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r,(_r._dig_tx_ln_map_0_1_2))
#define BCMI_FALCON_XGXS_READLN_DIG_TX_LN_MAP_0_1_2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_0_1_2))
#define BCMI_FALCON_XGXS_WRITELN_DIG_TX_LN_MAP_0_1_2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_0_1_2))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_TX_LN_MAP_0_1_2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_tx_ln_map_0_1_2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_TX_LN_MAP_0_1_2r BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r
#define DIG_TX_LN_MAP_0_1_2r_SIZE BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_SIZE
typedef BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_t DIG_TX_LN_MAP_0_1_2r_t;
#define DIG_TX_LN_MAP_0_1_2r_CLR BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_CLR
#define DIG_TX_LN_MAP_0_1_2r_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_SET
#define DIG_TX_LN_MAP_0_1_2r_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_2f_SET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_1f_SET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_GET
#define DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r_TX_LANE_MAP_0f_SET
#define READ_DIG_TX_LN_MAP_0_1_2r BCMI_FALCON_XGXS_READ_DIG_TX_LN_MAP_0_1_2r
#define WRITE_DIG_TX_LN_MAP_0_1_2r BCMI_FALCON_XGXS_WRITE_DIG_TX_LN_MAP_0_1_2r
#define MODIFY_DIG_TX_LN_MAP_0_1_2r BCMI_FALCON_XGXS_MODIFY_DIG_TX_LN_MAP_0_1_2r
#define READLN_DIG_TX_LN_MAP_0_1_2r BCMI_FALCON_XGXS_READLN_DIG_TX_LN_MAP_0_1_2r
#define WRITELN_DIG_TX_LN_MAP_0_1_2r BCMI_FALCON_XGXS_WRITELN_DIG_TX_LN_MAP_0_1_2r
#define WRITEALL_DIG_TX_LN_MAP_0_1_2r BCMI_FALCON_XGXS_WRITEALL_DIG_TX_LN_MAP_0_1_2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_TX_LN_MAP_0_1_2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_TX_LN_MAP_3_N_LN_ADDR_0_1
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10c
 * DEVAD:    1
 * DESC:     TX_LANE_MAP_3_N_LANE_ADDR_0_1
 * RESETVAL: 0x403 (1027)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_LANE_MAP_3    Physical PMD pin index indicated by value of this register will be mapped to the physical TX AFE Lane Number 3
 *     LANE_ADDR_0      Determines the logical address associated with the PMD lane with physical index  "_0" at the PCS interface.lane_addr_0 is the logical address of the lane with pins at the PCS interface labeled "_0".
 *     LANE_ADDR_1      Determines the logical address associated with the PMD lane with physical index  "_1" at the PCS interface.lane_addr_1 is the logical address of the lane with pins at the PCS interface labeled "_1".
 */
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r (0x0001d10c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SIZE 4

/*
 * This structure should be used to declare and program DIG_TX_LN_MAP_3_N_LN_ADDR_0_1.
 */
typedef union BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_s {
	uint32_t v[1];
	uint32_t dig_tx_ln_map_3_n_ln_addr_0_1[1];
	uint32_t _dig_tx_ln_map_3_n_ln_addr_0_1;
} BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_t;

#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_CLR(r) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0] = 0
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SET(r,d) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0] = d
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_GET(r) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_GET(r) ((((r).dig_tx_ln_map_3_n_ln_addr_0_1[0]) >> 10) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_SET(r,f) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]=(((r).dig_tx_ln_map_3_n_ln_addr_0_1[0] & ~((uint32_t)0x1f << 10)) | ((((uint32_t)f) & 0x1f) << 10)) | (31 << (16 + 10))
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_GET(r) ((((r).dig_tx_ln_map_3_n_ln_addr_0_1[0]) >> 5) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_SET(r,f) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]=(((r).dig_tx_ln_map_3_n_ln_addr_0_1[0] & ~((uint32_t)0x1f << 5)) | ((((uint32_t)f) & 0x1f) << 5)) | (31 << (16 + 5))
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_GET(r) (((r).dig_tx_ln_map_3_n_ln_addr_0_1[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_SET(r,f) (r).dig_tx_ln_map_3_n_ln_addr_0_1[0]=(((r).dig_tx_ln_map_3_n_ln_addr_0_1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DIG_TX_LN_MAP_3_N_LN_ADDR_0_1.
 */
#define BCMI_FALCON_XGXS_READ_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r,(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_FALCON_XGXS_WRITE_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r,(_r._dig_tx_ln_map_3_n_ln_addr_0_1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r,(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_FALCON_XGXS_READLN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_FALCON_XGXS_WRITELN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_tx_ln_map_3_n_ln_addr_0_1))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_tx_ln_map_3_n_ln_addr_0_1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SIZE BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SIZE
typedef BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_t DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_t;
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_CLR BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_CLR
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_SET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_1f_SET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_LANE_ADDR_0f_SET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_GET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_GET
#define DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_SET BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r_TX_LANE_MAP_3f_SET
#define READ_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_FALCON_XGXS_READ_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define WRITE_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_FALCON_XGXS_WRITE_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define MODIFY_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_FALCON_XGXS_MODIFY_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define READLN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_FALCON_XGXS_READLN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define WRITELN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_FALCON_XGXS_WRITELN_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r
#define WRITEALL_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r BCMI_FALCON_XGXS_WRITEALL_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_TX_LN_MAP_3_N_LN_ADDR_0_1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_LN_ADDR_2_3
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10d
 * DEVAD:    1
 * DESC:     LANE_ADDR_2_3
 * RESETVAL: 0x302 (770)
 * ACCESS:   R/W
 * FIELDS:
 *     LANE_ADDR_2      Determines the logical address associated with the PMD lane with physical index  "_2" at the PCS interface.lane_addr_2 is the logical address of the lane with pins at the PCS interface labeled "_2".
 *     LANE_ADDR_3      Determines the logical address associated with the PMD lane with physical index  "_3" at the PCS interface.lane_addr_3 is the logical address of the lane with pins at the PCS interface labeled "_3".
 */
#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r (0x0001d10d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_SIZE 4

/*
 * This structure should be used to declare and program DIG_LN_ADDR_2_3.
 */
typedef union BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_s {
	uint32_t v[1];
	uint32_t dig_ln_addr_2_3[1];
	uint32_t _dig_ln_addr_2_3;
} BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_t;

#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_CLR(r) (r).dig_ln_addr_2_3[0] = 0
#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_SET(r,d) (r).dig_ln_addr_2_3[0] = d
#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_GET(r) (r).dig_ln_addr_2_3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_GET(r) ((((r).dig_ln_addr_2_3[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_SET(r,f) (r).dig_ln_addr_2_3[0]=(((r).dig_ln_addr_2_3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_GET(r) (((r).dig_ln_addr_2_3[0]) & 0x1f)
#define BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_SET(r,f) (r).dig_ln_addr_2_3[0]=(((r).dig_ln_addr_2_3[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access DIG_LN_ADDR_2_3.
 */
#define BCMI_FALCON_XGXS_READ_DIG_LN_ADDR_2_3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r,(_r._dig_ln_addr_2_3))
#define BCMI_FALCON_XGXS_WRITE_DIG_LN_ADDR_2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r,(_r._dig_ln_addr_2_3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_LN_ADDR_2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r,(_r._dig_ln_addr_2_3))
#define BCMI_FALCON_XGXS_READLN_DIG_LN_ADDR_2_3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_ln_addr_2_3))
#define BCMI_FALCON_XGXS_WRITELN_DIG_LN_ADDR_2_3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_ln_addr_2_3))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_LN_ADDR_2_3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_ln_addr_2_3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_LN_ADDR_2_3r BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r
#define DIG_LN_ADDR_2_3r_SIZE BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_SIZE
typedef BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_t DIG_LN_ADDR_2_3r_t;
#define DIG_LN_ADDR_2_3r_CLR BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_CLR
#define DIG_LN_ADDR_2_3r_SET BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_SET
#define DIG_LN_ADDR_2_3r_GET BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_GET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_3f_GET BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_GET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_3f_SET BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_3f_SET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_2f_GET BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_GET
#define DIG_LN_ADDR_2_3r_LANE_ADDR_2f_SET BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r_LANE_ADDR_2f_SET
#define READ_DIG_LN_ADDR_2_3r BCMI_FALCON_XGXS_READ_DIG_LN_ADDR_2_3r
#define WRITE_DIG_LN_ADDR_2_3r BCMI_FALCON_XGXS_WRITE_DIG_LN_ADDR_2_3r
#define MODIFY_DIG_LN_ADDR_2_3r BCMI_FALCON_XGXS_MODIFY_DIG_LN_ADDR_2_3r
#define READLN_DIG_LN_ADDR_2_3r BCMI_FALCON_XGXS_READLN_DIG_LN_ADDR_2_3r
#define WRITELN_DIG_LN_ADDR_2_3r BCMI_FALCON_XGXS_WRITELN_DIG_LN_ADDR_2_3r
#define WRITEALL_DIG_LN_ADDR_2_3r BCMI_FALCON_XGXS_WRITEALL_DIG_LN_ADDR_2_3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_LN_ADDR_2_3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  DIG_REVID2
 * BLOCKS:   DIG_COM
 * REGADDR:  0xd10e
 * DEVAD:    1
 * DESC:     REVID2
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     REVID2           Revision ID2 code
 */
#define BCMI_FALCON_XGXS_DIG_REVID2r (0x0001d10e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_DIG_REVID2r_SIZE 4

/*
 * This structure should be used to declare and program DIG_REVID2.
 */
typedef union BCMI_FALCON_XGXS_DIG_REVID2r_s {
	uint32_t v[1];
	uint32_t dig_revid2[1];
	uint32_t _dig_revid2;
} BCMI_FALCON_XGXS_DIG_REVID2r_t;

#define BCMI_FALCON_XGXS_DIG_REVID2r_CLR(r) (r).dig_revid2[0] = 0
#define BCMI_FALCON_XGXS_DIG_REVID2r_SET(r,d) (r).dig_revid2[0] = d
#define BCMI_FALCON_XGXS_DIG_REVID2r_GET(r) (r).dig_revid2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_DIG_REVID2r_REVID2f_GET(r) (((r).dig_revid2[0]) & 0xf)
#define BCMI_FALCON_XGXS_DIG_REVID2r_REVID2f_SET(r,f) (r).dig_revid2[0]=(((r).dig_revid2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access DIG_REVID2.
 */
#define BCMI_FALCON_XGXS_READ_DIG_REVID2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_FALCON_XGXS_WRITE_DIG_REVID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID2r,(_r._dig_revid2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_DIG_REVID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID2r,(_r._dig_revid2))
#define BCMI_FALCON_XGXS_READLN_DIG_REVID2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_FALCON_XGXS_WRITELN_DIG_REVID2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._dig_revid2))
#define BCMI_FALCON_XGXS_WRITEALL_DIG_REVID2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_DIG_REVID2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._dig_revid2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define DIG_REVID2r BCMI_FALCON_XGXS_DIG_REVID2r
#define DIG_REVID2r_SIZE BCMI_FALCON_XGXS_DIG_REVID2r_SIZE
typedef BCMI_FALCON_XGXS_DIG_REVID2r_t DIG_REVID2r_t;
#define DIG_REVID2r_CLR BCMI_FALCON_XGXS_DIG_REVID2r_CLR
#define DIG_REVID2r_SET BCMI_FALCON_XGXS_DIG_REVID2r_SET
#define DIG_REVID2r_GET BCMI_FALCON_XGXS_DIG_REVID2r_GET
#define DIG_REVID2r_REVID2f_GET BCMI_FALCON_XGXS_DIG_REVID2r_REVID2f_GET
#define DIG_REVID2r_REVID2f_SET BCMI_FALCON_XGXS_DIG_REVID2r_REVID2f_SET
#define READ_DIG_REVID2r BCMI_FALCON_XGXS_READ_DIG_REVID2r
#define WRITE_DIG_REVID2r BCMI_FALCON_XGXS_WRITE_DIG_REVID2r
#define MODIFY_DIG_REVID2r BCMI_FALCON_XGXS_MODIFY_DIG_REVID2r
#define READLN_DIG_REVID2r BCMI_FALCON_XGXS_READLN_DIG_REVID2r
#define WRITELN_DIG_REVID2r BCMI_FALCON_XGXS_WRITELN_DIG_REVID2r
#define WRITEALL_DIG_REVID2r BCMI_FALCON_XGXS_WRITEALL_DIG_REVID2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_DIG_REVID2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL0
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd110
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_SET_CLK4TSC program clk freq for TSC clk
 *     AMS_PLL_IMIN_ICLKINT see AMS
 *     AMS_PLL_IMAX_ICLKINT see AMS
 *     AMS_PLL_IMODE_ICLKINT Interpolator bias current control
 *     AMS_PLL_IMIN_ICLKODRV1 see AMS
 *     AMS_PLL_IMAX_ICLKODRV1 see AMS
 *     AMS_PLL_IMODE_ICLKODRV1 Current control for output CML
 *     AMS_PLL_IMIN_ICLKIDRV1 see AMS
 *     AMS_PLL_IMAX_ICLKIDRV1 see AMS
 *     AMS_PLL_IMODE_ICLKIDRV1 Current control for input CML
 *     AMS_PLL_CAL_OFF  Turns off ResCal, turns on cal_aux[3:0]
 *     AMS_PLL_CAL_AUX  see AMS
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r (0x0001d110 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL0.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL0r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl0[1];
	uint32_t _ams_pll_ctl0;
} BCMI_FALCON_XGXS_AMS_PLL_CTL0r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_CLR(r) (r).ams_pll_ctl0[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_SET(r,d) (r).ams_pll_ctl0[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_GET(r) (r).ams_pll_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_AUXf_GET(r) ((((r).ams_pll_ctl0[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_AUXf_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_OFFf_GET(r) ((((r).ams_pll_ctl0[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_OFFf_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET(r) ((((r).ams_pll_ctl0[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET(r) ((((r).ams_pll_ctl0[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET(r) ((((r).ams_pll_ctl0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKODRV1f_GET(r) ((((r).ams_pll_ctl0[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKODRV1f_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKODRV1f_GET(r) ((((r).ams_pll_ctl0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKODRV1f_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKODRV1f_GET(r) ((((r).ams_pll_ctl0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKODRV1f_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKINTf_GET(r) ((((r).ams_pll_ctl0[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKINTf_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKINTf_GET(r) ((((r).ams_pll_ctl0[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKINTf_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKINTf_GET(r) ((((r).ams_pll_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKINTf_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_SET_CLK4TSCf_GET(r) (((r).ams_pll_ctl0[0]) & 0x3)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_SET_CLK4TSCf_SET(r,f) (r).ams_pll_ctl0[0]=(((r).ams_pll_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access AMS_PLL_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL0r,(_r._ams_pll_ctl0))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL0r,(_r._ams_pll_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL0r,(_r._ams_pll_ctl0))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL0r BCMI_FALCON_XGXS_AMS_PLL_CTL0r
#define AMS_PLL_CTL0r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL0r_t AMS_PLL_CTL0r_t;
#define AMS_PLL_CTL0r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL0r_CLR
#define AMS_PLL_CTL0r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_SET
#define AMS_PLL_CTL0r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_GET
#define AMS_PLL_CTL0r_AMS_PLL_CAL_AUXf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_AUXf_GET
#define AMS_PLL_CTL0r_AMS_PLL_CAL_AUXf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_AUXf_SET
#define AMS_PLL_CTL0r_AMS_PLL_CAL_OFFf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_OFFf_GET
#define AMS_PLL_CTL0r_AMS_PLL_CAL_OFFf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_CAL_OFFf_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKIDRV1f_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKIDRV1f_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKIDRV1f_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKODRV1f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKODRV1f_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKODRV1f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKODRV1f_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKODRV1f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKODRV1f_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKODRV1f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKODRV1f_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKODRV1f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKODRV1f_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKODRV1f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKODRV1f_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKINTf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKINTf_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKINTf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMODE_ICLKINTf_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKINTf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKINTf_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKINTf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMAX_ICLKINTf_SET
#define AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKINTf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKINTf_GET
#define AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKINTf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_IMIN_ICLKINTf_SET
#define AMS_PLL_CTL0r_AMS_PLL_SET_CLK4TSCf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_SET_CLK4TSCf_GET
#define AMS_PLL_CTL0r_AMS_PLL_SET_CLK4TSCf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL0r_AMS_PLL_SET_CLK4TSCf_SET
#define READ_AMS_PLL_CTL0r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL0r
#define WRITE_AMS_PLL_CTL0r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL0r
#define MODIFY_AMS_PLL_CTL0r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL0r
#define READLN_AMS_PLL_CTL0r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL0r
#define WRITELN_AMS_PLL_CTL0r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL0r
#define WRITEALL_AMS_PLL_CTL0r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL1
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd111
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_1
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_IMIN_ICKGEN see AMS
 *     AMS_PLL_IMAX_ICKGEN see AMS
 *     AMS_PLL_IMODE_ICKGEN Master current mirror control
 *     AMS_PLL_DRV_HV_DISABLE see AMS
 *     AMS_PLL_TEST_BG_OPAMP_BIAS test BG opamp bias[1:0]
 *     AMS_PLL_SPARE_23_22 AMS reserved[23:22]
 *     AMS_PLL_VCOICTRL adjusts VCO bias current
 *     AMS_PLL_VCO_INDICATOR enables transformer mode
 *     AMS_PLL_IVCO     see AMS
 *     AMS_PLL_RESET    active high
 *     AMS_PLL_ENABLE_FTUNE see AMS
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r (0x0001d111 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL1.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL1r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl1[1];
	uint32_t _ams_pll_ctl1;
} BCMI_FALCON_XGXS_AMS_PLL_CTL1r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_CLR(r) (r).ams_pll_ctl1[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_SET(r,d) (r).ams_pll_ctl1[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_GET(r) (r).ams_pll_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET(r) ((((r).ams_pll_ctl1[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_RESETf_GET(r) ((((r).ams_pll_ctl1[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_RESETf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IVCOf_GET(r) ((((r).ams_pll_ctl1[0]) >> 11) & 0x7)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IVCOf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x7 << 11)) | ((((uint32_t)f) & 0x7) << 11)) | (7 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_GET(r) ((((r).ams_pll_ctl1[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET(r) ((((r).ams_pll_ctl1[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_SPARE_23_22f_GET(r) ((((r).ams_pll_ctl1[0]) >> 6) & 0x3)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_SPARE_23_22f_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x3 << 6)) | ((((uint32_t)f) & 0x3) << 6)) | (3 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_GET(r) ((((r).ams_pll_ctl1[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET(r) ((((r).ams_pll_ctl1[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_GET(r) ((((r).ams_pll_ctl1[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_GET(r) ((((r).ams_pll_ctl1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_GET(r) (((r).ams_pll_ctl1[0]) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_SET(r,f) (r).ams_pll_ctl1[0]=(((r).ams_pll_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL1r,(_r._ams_pll_ctl1))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL1r,(_r._ams_pll_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL1r,(_r._ams_pll_ctl1))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL1r BCMI_FALCON_XGXS_AMS_PLL_CTL1r
#define AMS_PLL_CTL1r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL1r_t AMS_PLL_CTL1r_t;
#define AMS_PLL_CTL1r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL1r_CLR
#define AMS_PLL_CTL1r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_SET
#define AMS_PLL_CTL1r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_GET
#define AMS_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_GET
#define AMS_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_ENABLE_FTUNEf_SET
#define AMS_PLL_CTL1r_AMS_PLL_RESETf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_RESETf_GET
#define AMS_PLL_CTL1r_AMS_PLL_RESETf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_RESETf_SET
#define AMS_PLL_CTL1r_AMS_PLL_IVCOf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IVCOf_GET
#define AMS_PLL_CTL1r_AMS_PLL_IVCOf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IVCOf_SET
#define AMS_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_GET
#define AMS_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCO_INDICATORf_SET
#define AMS_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCOICTRLf_GET
#define AMS_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_VCOICTRLf_SET
#define AMS_PLL_CTL1r_AMS_PLL_SPARE_23_22f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_SPARE_23_22f_GET
#define AMS_PLL_CTL1r_AMS_PLL_SPARE_23_22f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_SPARE_23_22f_SET
#define AMS_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_GET
#define AMS_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_TEST_BG_OPAMP_BIASf_SET
#define AMS_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_GET
#define AMS_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_DRV_HV_DISABLEf_SET
#define AMS_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_GET
#define AMS_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMODE_ICKGENf_SET
#define AMS_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_GET
#define AMS_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMAX_ICKGENf_SET
#define AMS_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_GET
#define AMS_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL1r_AMS_PLL_IMIN_ICKGENf_SET
#define READ_AMS_PLL_CTL1r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL1r
#define WRITE_AMS_PLL_CTL1r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL1r
#define MODIFY_AMS_PLL_CTL1r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL1r
#define READLN_AMS_PLL_CTL1r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL1r
#define WRITELN_AMS_PLL_CTL1r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL1r
#define WRITEALL_AMS_PLL_CTL1r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL2
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd112
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_2
 * RESETVAL: 0x1e (30)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_EN_HRZ   increases Rz, 2.4K ==> 4.8K
 *     AMS_PLL_IQP      charge pump current, 50,100,150,..800uA
 *     AMS_PLL_REFL_PLL see AMS
 *     AMS_PLL_REFH_PLL see AMS
 *     AMS_PLL_IMIN_IBIAS see AMS
 *     AMS_PLL_IMODE_IBIAS see AMS
 *     AMS_PLL_IMAX_IBIAS ibias all 6 above
 *     AMS_PLL_IMIN_ICP see AMS
 *     AMS_PLL_IMODE_ICP see AMS
 *     AMS_PLL_IMAX_ICP charge pump
 *     AMS_PLL_IMIN_ICK see AMS
 *     AMS_PLL_IMODE_ICK see AMS
 *     AMS_PLL_IMAX_ICK fref buffer
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r (0x0001d112 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL2.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL2r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl2[1];
	uint32_t _ams_pll_ctl2;
} BCMI_FALCON_XGXS_AMS_PLL_CTL2r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_CLR(r) (r).ams_pll_ctl2[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_SET(r,d) (r).ams_pll_ctl2[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_GET(r) (r).ams_pll_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET(r) ((((r).ams_pll_ctl2[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET(r) ((((r).ams_pll_ctl2[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET(r) ((((r).ams_pll_ctl2[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET(r) ((((r).ams_pll_ctl2[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET(r) ((((r).ams_pll_ctl2[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET(r) ((((r).ams_pll_ctl2[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET(r) ((((r).ams_pll_ctl2[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET(r) ((((r).ams_pll_ctl2[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET(r) ((((r).ams_pll_ctl2[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET(r) ((((r).ams_pll_ctl2[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET(r) ((((r).ams_pll_ctl2[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IQPf_GET(r) ((((r).ams_pll_ctl2[0]) >> 1) & 0xf)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IQPf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0xf << 1)) | ((((uint32_t)f) & 0xf) << 1)) | (15 << (16 + 1))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_EN_HRZf_GET(r) (((r).ams_pll_ctl2[0]) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_EN_HRZf_SET(r,f) (r).ams_pll_ctl2[0]=(((r).ams_pll_ctl2[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL2r,(_r._ams_pll_ctl2))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL2r,(_r._ams_pll_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL2r,(_r._ams_pll_ctl2))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL2r BCMI_FALCON_XGXS_AMS_PLL_CTL2r
#define AMS_PLL_CTL2r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL2r_t AMS_PLL_CTL2r_t;
#define AMS_PLL_CTL2r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL2r_CLR
#define AMS_PLL_CTL2r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_SET
#define AMS_PLL_CTL2r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICKf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICKf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICKf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICKf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICKf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICKf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICPf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_ICPf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICPf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_ICPf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICPf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_ICPf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMAX_IBIASf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMODE_IBIASf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IMIN_IBIASf_SET
#define AMS_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFH_PLLf_GET
#define AMS_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFH_PLLf_SET
#define AMS_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFL_PLLf_GET
#define AMS_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_REFL_PLLf_SET
#define AMS_PLL_CTL2r_AMS_PLL_IQPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IQPf_GET
#define AMS_PLL_CTL2r_AMS_PLL_IQPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_IQPf_SET
#define AMS_PLL_CTL2r_AMS_PLL_EN_HRZf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_EN_HRZf_GET
#define AMS_PLL_CTL2r_AMS_PLL_EN_HRZf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL2r_AMS_PLL_EN_HRZf_SET
#define READ_AMS_PLL_CTL2r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL2r
#define WRITE_AMS_PLL_CTL2r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL2r
#define MODIFY_AMS_PLL_CTL2r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL2r
#define READLN_AMS_PLL_CTL2r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL2r
#define WRITELN_AMS_PLL_CTL2r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL2r
#define WRITEALL_AMS_PLL_CTL2r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL3
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd113
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_3
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_IMIN_IRXCLKBUF see AMS
 *     AMS_PLL_IMODE_IRXCLKBUF see AMS
 *     AMS_PLL_IMAX_IRXCLKBUF rxclk buf
 *     AMS_PLL_IMIN_ICMLDIV see AMS
 *     AMS_PLL_IMODE_ICMLDIV see AMS
 *     AMS_PLL_IMAX_ICMLDIV VCO divider/buffer
 *     AMS_PLL_IMIN_ICOMP see AMS
 *     AMS_PLL_IMODE_ICOMP see AMS
 *     AMS_PLL_IMAX_ICOMP VCO comparator
 *     AMS_PLL_IMIN_IOP see AMS
 *     AMS_PLL_IMODE_IOP see AMS
 *     AMS_PLL_IMAX_IOP test current
 *     AMS_PLL_TEST_VREF see AMS
 *     AMS_PLL_TEST_VC  test Vcontrol
 *     AMS_PLL_TEST_PLL test LC
 *     AMS_PLL_TEST_RX  send RX word ck to PLL test port
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r (0x0001d113 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL3.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL3r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl3[1];
	uint32_t _ams_pll_ctl3;
} BCMI_FALCON_XGXS_AMS_PLL_CTL3r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_CLR(r) (r).ams_pll_ctl3[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_SET(r,d) (r).ams_pll_ctl3[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_GET(r) (r).ams_pll_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_RXf_GET(r) ((((r).ams_pll_ctl3[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_RXf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET(r) ((((r).ams_pll_ctl3[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VCf_GET(r) ((((r).ams_pll_ctl3[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VCf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET(r) ((((r).ams_pll_ctl3[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET(r) ((((r).ams_pll_ctl3[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET(r) ((((r).ams_pll_ctl3[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET(r) ((((r).ams_pll_ctl3[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET(r) ((((r).ams_pll_ctl3[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET(r) ((((r).ams_pll_ctl3[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET(r) ((((r).ams_pll_ctl3[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET(r) ((((r).ams_pll_ctl3[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET(r) ((((r).ams_pll_ctl3[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET(r) ((((r).ams_pll_ctl3[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET(r) ((((r).ams_pll_ctl3[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET(r) ((((r).ams_pll_ctl3[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET(r) (((r).ams_pll_ctl3[0]) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET(r,f) (r).ams_pll_ctl3[0]=(((r).ams_pll_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL3r,(_r._ams_pll_ctl3))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL3r,(_r._ams_pll_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL3r,(_r._ams_pll_ctl3))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL3r BCMI_FALCON_XGXS_AMS_PLL_CTL3r
#define AMS_PLL_CTL3r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL3r_t AMS_PLL_CTL3r_t;
#define AMS_PLL_CTL3r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL3r_CLR
#define AMS_PLL_CTL3r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_SET
#define AMS_PLL_CTL3r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_GET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_RXf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_RXf_GET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_RXf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_RXf_SET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_PLLf_GET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_PLLf_SET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_VCf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VCf_GET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_VCf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VCf_SET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VREFf_GET
#define AMS_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_TEST_VREFf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IOPf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IOPf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IOPf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IOPf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IOPf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IOPf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICOMPf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICOMPf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICOMPf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_ICMLDIVf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_ICMLDIVf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_ICMLDIVf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMAX_IRXCLKBUFf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMODE_IRXCLKBUFf_SET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_GET
#define AMS_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL3r_AMS_PLL_IMIN_IRXCLKBUFf_SET
#define READ_AMS_PLL_CTL3r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL3r
#define WRITE_AMS_PLL_CTL3r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL3r
#define MODIFY_AMS_PLL_CTL3r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL3r
#define READLN_AMS_PLL_CTL3r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL3r
#define WRITELN_AMS_PLL_CTL3r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL3r
#define WRITEALL_AMS_PLL_CTL3r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL4
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd114
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_4
 * RESETVAL: 0x77 (119)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_BGR_PTATADJ BG bias, same decoder as CTAT
 *     AMS_PLL_BGR_CTATADJ BG CTAT bias control
 *     AMS_PLL_PLL2RX_CLKBW controls BW of interpolator input
 *     AMS_PLL_COMP_VTH tuning comparator threshold
 *     AMS_PLL_VDDR_BGB select between PVDD or BG Vbias
 *     AMS_PLL_KVH_FORCE force Kvco, override tuning control
 *     AMS_PLL_FORCE_KVH_BW enable force kvh and bw modes
 *     AMS_PLL_FORCE_RESCAL force_rescal with pll_ctrl<15:12>
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r (0x0001d114 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL4.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL4r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl4[1];
	uint32_t _ams_pll_ctl4;
} BCMI_FALCON_XGXS_AMS_PLL_CTL4r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_CLR(r) (r).ams_pll_ctl4[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_SET(r,d) (r).ams_pll_ctl4[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_GET(r) (r).ams_pll_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET(r) ((((r).ams_pll_ctl4[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET(r) ((((r).ams_pll_ctl4[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET(r) ((((r).ams_pll_ctl4[0]) >> 12) & 0x3)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0x3 << 12)) | ((((uint32_t)f) & 0x3) << 12)) | (3 << (16 + 12))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET(r) ((((r).ams_pll_ctl4[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_COMP_VTHf_GET(r) ((((r).ams_pll_ctl4[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_COMP_VTHf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET(r) ((((r).ams_pll_ctl4[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET(r) ((((r).ams_pll_ctl4[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET(r) (((r).ams_pll_ctl4[0]) & 0xf)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET(r,f) (r).ams_pll_ctl4[0]=(((r).ams_pll_ctl4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access AMS_PLL_CTL4.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL4r,(_r._ams_pll_ctl4))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL4r,(_r._ams_pll_ctl4)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL4r,(_r._ams_pll_ctl4))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl4))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl4))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL4r BCMI_FALCON_XGXS_AMS_PLL_CTL4r
#define AMS_PLL_CTL4r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL4r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL4r_t AMS_PLL_CTL4r_t;
#define AMS_PLL_CTL4r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL4r_CLR
#define AMS_PLL_CTL4r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_SET
#define AMS_PLL_CTL4r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_GET
#define AMS_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_GET
#define AMS_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_RESCALf_SET
#define AMS_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_GET
#define AMS_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_FORCE_KVH_BWf_SET
#define AMS_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_KVH_FORCEf_GET
#define AMS_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_KVH_FORCEf_SET
#define AMS_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_VDDR_BGBf_GET
#define AMS_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_VDDR_BGBf_SET
#define AMS_PLL_CTL4r_AMS_PLL_COMP_VTHf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_COMP_VTHf_GET
#define AMS_PLL_CTL4r_AMS_PLL_COMP_VTHf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_COMP_VTHf_SET
#define AMS_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_GET
#define AMS_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_PLL2RX_CLKBWf_SET
#define AMS_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_GET
#define AMS_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_CTATADJf_SET
#define AMS_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_GET
#define AMS_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL4r_AMS_PLL_BGR_PTATADJf_SET
#define READ_AMS_PLL_CTL4r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL4r
#define WRITE_AMS_PLL_CTL4r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL4r
#define MODIFY_AMS_PLL_CTL4r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL4r
#define READLN_AMS_PLL_CTL4r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL4r
#define WRITELN_AMS_PLL_CTL4r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL4r
#define WRITEALL_AMS_PLL_CTL4r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL5
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd115
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_5
 * RESETVAL: 0x1f00 (7936)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_TEST_PORT_MAX_AMPLITUDE test port max amplitude
 *     AMS_PLL_BGIP     test, measure Ibg internal PMOS current
 *     AMS_PLL_BGINT    test, measure Vbg internal
 *     AMS_PLL_VBYPASS  test, bypass test port opamp buffer
 *     AMS_PLL_TEST_PNP see AMS
 *     AMS_PLL_MIX3P1C_CALR_CTATADJ bias control for Mix3P1C/calR
 *     AMS_PLL_MIX3P1C_CALR_PTATADJ bias control for Mix3P1C/calR
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r (0x0001d115 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL5.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL5r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl5[1];
	uint32_t _ams_pll_ctl5;
} BCMI_FALCON_XGXS_AMS_PLL_CTL5r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_CLR(r) (r).ams_pll_ctl5[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_SET(r,d) (r).ams_pll_ctl5[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_GET(r) (r).ams_pll_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET(r) ((((r).ams_pll_ctl5[0]) >> 11) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET(r,f) (r).ams_pll_ctl5[0]=(((r).ams_pll_ctl5[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET(r) ((((r).ams_pll_ctl5[0]) >> 6) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET(r,f) (r).ams_pll_ctl5[0]=(((r).ams_pll_ctl5[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET(r) ((((r).ams_pll_ctl5[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET(r,f) (r).ams_pll_ctl5[0]=(((r).ams_pll_ctl5[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_VBYPASSf_GET(r) ((((r).ams_pll_ctl5[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_VBYPASSf_SET(r,f) (r).ams_pll_ctl5[0]=(((r).ams_pll_ctl5[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGINTf_GET(r) ((((r).ams_pll_ctl5[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGINTf_SET(r,f) (r).ams_pll_ctl5[0]=(((r).ams_pll_ctl5[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGIPf_GET(r) ((((r).ams_pll_ctl5[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGIPf_SET(r,f) (r).ams_pll_ctl5[0]=(((r).ams_pll_ctl5[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_GET(r) (((r).ams_pll_ctl5[0]) & 0x1)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_SET(r,f) (r).ams_pll_ctl5[0]=(((r).ams_pll_ctl5[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access AMS_PLL_CTL5.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL5r,(_r._ams_pll_ctl5))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL5r,(_r._ams_pll_ctl5)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL5r,(_r._ams_pll_ctl5))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl5))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl5))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL5r BCMI_FALCON_XGXS_AMS_PLL_CTL5r
#define AMS_PLL_CTL5r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL5r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL5r_t AMS_PLL_CTL5r_t;
#define AMS_PLL_CTL5r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL5r_CLR
#define AMS_PLL_CTL5r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_SET
#define AMS_PLL_CTL5r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_GET
#define AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_GET
#define AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_PTATADJf_SET
#define AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_GET
#define AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_MIX3P1C_CALR_CTATADJf_SET
#define AMS_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PNPf_GET
#define AMS_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PNPf_SET
#define AMS_PLL_CTL5r_AMS_PLL_VBYPASSf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_VBYPASSf_GET
#define AMS_PLL_CTL5r_AMS_PLL_VBYPASSf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_VBYPASSf_SET
#define AMS_PLL_CTL5r_AMS_PLL_BGINTf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGINTf_GET
#define AMS_PLL_CTL5r_AMS_PLL_BGINTf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGINTf_SET
#define AMS_PLL_CTL5r_AMS_PLL_BGIPf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGIPf_GET
#define AMS_PLL_CTL5r_AMS_PLL_BGIPf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_BGIPf_SET
#define AMS_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_GET
#define AMS_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL5r_AMS_PLL_TEST_PORT_MAX_AMPLITUDEf_SET
#define READ_AMS_PLL_CTL5r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL5r
#define WRITE_AMS_PLL_CTL5r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL5r
#define MODIFY_AMS_PLL_CTL5r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL5r
#define READLN_AMS_PLL_CTL5r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL5r
#define WRITELN_AMS_PLL_CTL5r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL5r
#define WRITEALL_AMS_PLL_CTL5r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL6
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd116
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_6
 * RESETVAL: 0xc1c0 (49600)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_SPARE_101_96 AMS reserved[101:96]
 *     AMS_PLL_MIX1P2CR_CTATADJ CTAT bias control for Mix1P2C/R
 *     AMS_PLL_MIX1P2CR_PTATADJ PTAT bias control for Mix1P2C/R
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r (0x0001d116 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL6.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL6r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl6[1];
	uint32_t _ams_pll_ctl6;
} BCMI_FALCON_XGXS_AMS_PLL_CTL6r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_CLR(r) (r).ams_pll_ctl6[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_SET(r,d) (r).ams_pll_ctl6[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_GET(r) (r).ams_pll_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_GET(r) ((((r).ams_pll_ctl6[0]) >> 11) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_SET(r,f) (r).ams_pll_ctl6[0]=(((r).ams_pll_ctl6[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_GET(r) ((((r).ams_pll_ctl6[0]) >> 6) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_SET(r,f) (r).ams_pll_ctl6[0]=(((r).ams_pll_ctl6[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_SPARE_101_96f_GET(r) (((r).ams_pll_ctl6[0]) & 0x3f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_SPARE_101_96f_SET(r,f) (r).ams_pll_ctl6[0]=(((r).ams_pll_ctl6[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access AMS_PLL_CTL6.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL6r,(_r._ams_pll_ctl6))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL6r,(_r._ams_pll_ctl6)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL6r,(_r._ams_pll_ctl6))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl6))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl6))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL6r BCMI_FALCON_XGXS_AMS_PLL_CTL6r
#define AMS_PLL_CTL6r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL6r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL6r_t AMS_PLL_CTL6r_t;
#define AMS_PLL_CTL6r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL6r_CLR
#define AMS_PLL_CTL6r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_SET
#define AMS_PLL_CTL6r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_GET
#define AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_GET
#define AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_PTATADJf_SET
#define AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_GET
#define AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_MIX1P2CR_CTATADJf_SET
#define AMS_PLL_CTL6r_AMS_PLL_SPARE_101_96f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_SPARE_101_96f_GET
#define AMS_PLL_CTL6r_AMS_PLL_SPARE_101_96f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL6r_AMS_PLL_SPARE_101_96f_SET
#define READ_AMS_PLL_CTL6r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL6r
#define WRITE_AMS_PLL_CTL6r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL6r
#define MODIFY_AMS_PLL_CTL6r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL6r
#define READLN_AMS_PLL_CTL6r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL6r
#define WRITELN_AMS_PLL_CTL6r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL6r
#define WRITEALL_AMS_PLL_CTL6r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_CTL7
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd117
 * DEVAD:    1
 * DESC:     AMS PLL CONTROL_7
 * RESETVAL: 0x1f00 (7936)
 * ACCESS:   R/W
 * FIELDS:
 *     AMS_PLL_SPARE_117_112 AMS reserved[117:112]
 *     AMS_PLL_MIX3P1CR_CTATADJ CTAT bias control for Mix3P1C/R
 *     AMS_PLL_MIX3P1CR_PTATADJ PTAT bias control for Mix3P1C/R
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r (0x0001d117 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_CTL7.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_CTL7r_s {
	uint32_t v[1];
	uint32_t ams_pll_ctl7[1];
	uint32_t _ams_pll_ctl7;
} BCMI_FALCON_XGXS_AMS_PLL_CTL7r_t;

#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_CLR(r) (r).ams_pll_ctl7[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_SET(r,d) (r).ams_pll_ctl7[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_GET(r) (r).ams_pll_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET(r) ((((r).ams_pll_ctl7[0]) >> 11) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET(r,f) (r).ams_pll_ctl7[0]=(((r).ams_pll_ctl7[0] & ~((uint32_t)0x1f << 11)) | ((((uint32_t)f) & 0x1f) << 11)) | (31 << (16 + 11))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET(r) ((((r).ams_pll_ctl7[0]) >> 6) & 0x1f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET(r,f) (r).ams_pll_ctl7[0]=(((r).ams_pll_ctl7[0] & ~((uint32_t)0x1f << 6)) | ((((uint32_t)f) & 0x1f) << 6)) | (31 << (16 + 6))
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_SPARE_117_112f_GET(r) (((r).ams_pll_ctl7[0]) & 0x3f)
#define BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_SPARE_117_112f_SET(r,f) (r).ams_pll_ctl7[0]=(((r).ams_pll_ctl7[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access AMS_PLL_CTL7.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL7r,(_r._ams_pll_ctl7))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL7r,(_r._ams_pll_ctl7)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL7r,(_r._ams_pll_ctl7))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl7))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_ctl7))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_CTL7r BCMI_FALCON_XGXS_AMS_PLL_CTL7r
#define AMS_PLL_CTL7r_SIZE BCMI_FALCON_XGXS_AMS_PLL_CTL7r_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_CTL7r_t AMS_PLL_CTL7r_t;
#define AMS_PLL_CTL7r_CLR BCMI_FALCON_XGXS_AMS_PLL_CTL7r_CLR
#define AMS_PLL_CTL7r_SET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_SET
#define AMS_PLL_CTL7r_GET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_GET
#define AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_GET
#define AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_PTATADJf_SET
#define AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_GET
#define AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_MIX3P1CR_CTATADJf_SET
#define AMS_PLL_CTL7r_AMS_PLL_SPARE_117_112f_GET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_SPARE_117_112f_GET
#define AMS_PLL_CTL7r_AMS_PLL_SPARE_117_112f_SET BCMI_FALCON_XGXS_AMS_PLL_CTL7r_AMS_PLL_SPARE_117_112f_SET
#define READ_AMS_PLL_CTL7r BCMI_FALCON_XGXS_READ_AMS_PLL_CTL7r
#define WRITE_AMS_PLL_CTL7r BCMI_FALCON_XGXS_WRITE_AMS_PLL_CTL7r
#define MODIFY_AMS_PLL_CTL7r BCMI_FALCON_XGXS_MODIFY_AMS_PLL_CTL7r
#define READLN_AMS_PLL_CTL7r BCMI_FALCON_XGXS_READLN_AMS_PLL_CTL7r
#define WRITELN_AMS_PLL_CTL7r BCMI_FALCON_XGXS_WRITELN_AMS_PLL_CTL7r
#define WRITEALL_AMS_PLL_CTL7r BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  AMS_PLL_STS
 * BLOCKS:   AMS_COM
 * REGADDR:  0xd119
 * DEVAD:    1
 * DESC:     AMS PLL STATUS
 * RESETVAL: 0xc007 (49159)
 * ACCESS:   R/O
 * FIELDS:
 *     AMS_PLL_STS      pll status from AFE
 */
#define BCMI_FALCON_XGXS_AMS_PLL_STSr (0x0001d119 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_AMS_PLL_STSr_SIZE 4

/*
 * This structure should be used to declare and program AMS_PLL_STS.
 */
typedef union BCMI_FALCON_XGXS_AMS_PLL_STSr_s {
	uint32_t v[1];
	uint32_t ams_pll_sts[1];
	uint32_t _ams_pll_sts;
} BCMI_FALCON_XGXS_AMS_PLL_STSr_t;

#define BCMI_FALCON_XGXS_AMS_PLL_STSr_CLR(r) (r).ams_pll_sts[0] = 0
#define BCMI_FALCON_XGXS_AMS_PLL_STSr_SET(r,d) (r).ams_pll_sts[0] = d
#define BCMI_FALCON_XGXS_AMS_PLL_STSr_GET(r) (r).ams_pll_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_AMS_PLL_STSr_AMS_PLL_STSf_GET(r) (((r).ams_pll_sts[0]) & 0xffff)
#define BCMI_FALCON_XGXS_AMS_PLL_STSr_AMS_PLL_STSf_SET(r,f) (r).ams_pll_sts[0]=(((r).ams_pll_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access AMS_PLL_STS.
 */
#define BCMI_FALCON_XGXS_READ_AMS_PLL_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_STSr,(_r._ams_pll_sts))
#define BCMI_FALCON_XGXS_WRITE_AMS_PLL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_STSr,(_r._ams_pll_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_AMS_PLL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_STSr,(_r._ams_pll_sts))
#define BCMI_FALCON_XGXS_READLN_AMS_PLL_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_AMS_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_sts))
#define BCMI_FALCON_XGXS_WRITELN_AMS_PLL_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._ams_pll_sts))
#define BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_AMS_PLL_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._ams_pll_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define AMS_PLL_STSr BCMI_FALCON_XGXS_AMS_PLL_STSr
#define AMS_PLL_STSr_SIZE BCMI_FALCON_XGXS_AMS_PLL_STSr_SIZE
typedef BCMI_FALCON_XGXS_AMS_PLL_STSr_t AMS_PLL_STSr_t;
#define AMS_PLL_STSr_CLR BCMI_FALCON_XGXS_AMS_PLL_STSr_CLR
#define AMS_PLL_STSr_SET BCMI_FALCON_XGXS_AMS_PLL_STSr_SET
#define AMS_PLL_STSr_GET BCMI_FALCON_XGXS_AMS_PLL_STSr_GET
#define AMS_PLL_STSr_AMS_PLL_STSf_GET BCMI_FALCON_XGXS_AMS_PLL_STSr_AMS_PLL_STSf_GET
#define AMS_PLL_STSr_AMS_PLL_STSf_SET BCMI_FALCON_XGXS_AMS_PLL_STSr_AMS_PLL_STSf_SET
#define READ_AMS_PLL_STSr BCMI_FALCON_XGXS_READ_AMS_PLL_STSr
#define WRITE_AMS_PLL_STSr BCMI_FALCON_XGXS_WRITE_AMS_PLL_STSr
#define MODIFY_AMS_PLL_STSr BCMI_FALCON_XGXS_MODIFY_AMS_PLL_STSr
#define READLN_AMS_PLL_STSr BCMI_FALCON_XGXS_READLN_AMS_PLL_STSr
#define WRITELN_AMS_PLL_STSr BCMI_FALCON_XGXS_WRITELN_AMS_PLL_STSr
#define WRITEALL_AMS_PLL_STSr BCMI_FALCON_XGXS_WRITEALL_AMS_PLL_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_AMS_PLL_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ0
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd120
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 0
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_0   Fixed Pattern Generator Sequence Word 0. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted last.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ0r (0x0001d120 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ0.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq0[1];
	uint32_t _patt_gen_seq0;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_CLR(r) (r).patt_gen_seq0[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_SET(r,d) (r).patt_gen_seq0[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_GET(r) (r).patt_gen_seq0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_GET(r) (((r).patt_gen_seq0[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_SET(r,f) (r).patt_gen_seq0[0]=(((r).patt_gen_seq0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ0.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ0r,(_r._patt_gen_seq0))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ0r,(_r._patt_gen_seq0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ0r,(_r._patt_gen_seq0))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq0))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq0))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ0r BCMI_FALCON_XGXS_PATT_GEN_SEQ0r
#define PATT_GEN_SEQ0r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_t PATT_GEN_SEQ0r_t;
#define PATT_GEN_SEQ0r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_CLR
#define PATT_GEN_SEQ0r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_SET
#define PATT_GEN_SEQ0r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_GET
#define PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_GET
#define PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ0r_PATT_GEN_SEQ_0f_SET
#define READ_PATT_GEN_SEQ0r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ0r
#define WRITE_PATT_GEN_SEQ0r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ0r
#define MODIFY_PATT_GEN_SEQ0r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ0r
#define READLN_PATT_GEN_SEQ0r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ0r
#define WRITELN_PATT_GEN_SEQ0r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ0r
#define WRITEALL_PATT_GEN_SEQ0r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ1
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd121
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 1
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_1   Fixed Pattern Generator Sequence Word 1. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ1r (0x0001d121 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ1.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq1[1];
	uint32_t _patt_gen_seq1;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_CLR(r) (r).patt_gen_seq1[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_SET(r,d) (r).patt_gen_seq1[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_GET(r) (r).patt_gen_seq1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_GET(r) (((r).patt_gen_seq1[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_SET(r,f) (r).patt_gen_seq1[0]=(((r).patt_gen_seq1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ1.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ1r,(_r._patt_gen_seq1))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ1r,(_r._patt_gen_seq1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ1r,(_r._patt_gen_seq1))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq1))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq1))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ1r BCMI_FALCON_XGXS_PATT_GEN_SEQ1r
#define PATT_GEN_SEQ1r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_t PATT_GEN_SEQ1r_t;
#define PATT_GEN_SEQ1r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_CLR
#define PATT_GEN_SEQ1r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_SET
#define PATT_GEN_SEQ1r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_GET
#define PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_GET
#define PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ1r_PATT_GEN_SEQ_1f_SET
#define READ_PATT_GEN_SEQ1r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ1r
#define WRITE_PATT_GEN_SEQ1r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ1r
#define MODIFY_PATT_GEN_SEQ1r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ1r
#define READLN_PATT_GEN_SEQ1r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ1r
#define WRITELN_PATT_GEN_SEQ1r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ1r
#define WRITEALL_PATT_GEN_SEQ1r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ2
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd122
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 2
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_2   Fixed Pattern Generator Sequence Word 2. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ2r (0x0001d122 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ2.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq2[1];
	uint32_t _patt_gen_seq2;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_CLR(r) (r).patt_gen_seq2[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_SET(r,d) (r).patt_gen_seq2[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_GET(r) (r).patt_gen_seq2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_GET(r) (((r).patt_gen_seq2[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_SET(r,f) (r).patt_gen_seq2[0]=(((r).patt_gen_seq2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ2.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ2r,(_r._patt_gen_seq2))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ2r,(_r._patt_gen_seq2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ2r,(_r._patt_gen_seq2))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq2))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq2))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ2r BCMI_FALCON_XGXS_PATT_GEN_SEQ2r
#define PATT_GEN_SEQ2r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_t PATT_GEN_SEQ2r_t;
#define PATT_GEN_SEQ2r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_CLR
#define PATT_GEN_SEQ2r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_SET
#define PATT_GEN_SEQ2r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_GET
#define PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_GET
#define PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ2r_PATT_GEN_SEQ_2f_SET
#define READ_PATT_GEN_SEQ2r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ2r
#define WRITE_PATT_GEN_SEQ2r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ2r
#define MODIFY_PATT_GEN_SEQ2r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ2r
#define READLN_PATT_GEN_SEQ2r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ2r
#define WRITELN_PATT_GEN_SEQ2r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ2r
#define WRITEALL_PATT_GEN_SEQ2r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ3
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd123
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 3
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_3   Fixed Pattern Generator Sequence Word 3. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ3r (0x0001d123 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ3.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq3[1];
	uint32_t _patt_gen_seq3;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_CLR(r) (r).patt_gen_seq3[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_SET(r,d) (r).patt_gen_seq3[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_GET(r) (r).patt_gen_seq3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_GET(r) (((r).patt_gen_seq3[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_SET(r,f) (r).patt_gen_seq3[0]=(((r).patt_gen_seq3[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ3.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ3r,(_r._patt_gen_seq3))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ3r,(_r._patt_gen_seq3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ3r,(_r._patt_gen_seq3))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq3))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq3))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ3r BCMI_FALCON_XGXS_PATT_GEN_SEQ3r
#define PATT_GEN_SEQ3r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_t PATT_GEN_SEQ3r_t;
#define PATT_GEN_SEQ3r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_CLR
#define PATT_GEN_SEQ3r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_SET
#define PATT_GEN_SEQ3r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_GET
#define PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_GET
#define PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ3r_PATT_GEN_SEQ_3f_SET
#define READ_PATT_GEN_SEQ3r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ3r
#define WRITE_PATT_GEN_SEQ3r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ3r
#define MODIFY_PATT_GEN_SEQ3r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ3r
#define READLN_PATT_GEN_SEQ3r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ3r
#define WRITELN_PATT_GEN_SEQ3r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ3r
#define WRITEALL_PATT_GEN_SEQ3r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ4
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd124
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 4
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_4   Fixed Pattern Generator Sequence Word 4. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ4r (0x0001d124 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ4.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq4[1];
	uint32_t _patt_gen_seq4;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_CLR(r) (r).patt_gen_seq4[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_SET(r,d) (r).patt_gen_seq4[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_GET(r) (r).patt_gen_seq4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_GET(r) (((r).patt_gen_seq4[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_SET(r,f) (r).patt_gen_seq4[0]=(((r).patt_gen_seq4[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ4.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ4r,(_r._patt_gen_seq4))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ4r,(_r._patt_gen_seq4)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ4r,(_r._patt_gen_seq4))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq4))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq4))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ4r BCMI_FALCON_XGXS_PATT_GEN_SEQ4r
#define PATT_GEN_SEQ4r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_t PATT_GEN_SEQ4r_t;
#define PATT_GEN_SEQ4r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_CLR
#define PATT_GEN_SEQ4r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_SET
#define PATT_GEN_SEQ4r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_GET
#define PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_GET
#define PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ4r_PATT_GEN_SEQ_4f_SET
#define READ_PATT_GEN_SEQ4r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ4r
#define WRITE_PATT_GEN_SEQ4r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ4r
#define MODIFY_PATT_GEN_SEQ4r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ4r
#define READLN_PATT_GEN_SEQ4r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ4r
#define WRITELN_PATT_GEN_SEQ4r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ4r
#define WRITEALL_PATT_GEN_SEQ4r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ5
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd125
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 5
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_5   Fixed Pattern Generator Sequence Word 5. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ5r (0x0001d125 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ5.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq5[1];
	uint32_t _patt_gen_seq5;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_CLR(r) (r).patt_gen_seq5[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_SET(r,d) (r).patt_gen_seq5[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_GET(r) (r).patt_gen_seq5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_GET(r) (((r).patt_gen_seq5[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_SET(r,f) (r).patt_gen_seq5[0]=(((r).patt_gen_seq5[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ5.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ5r,(_r._patt_gen_seq5))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ5r,(_r._patt_gen_seq5)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ5r,(_r._patt_gen_seq5))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq5))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq5))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ5r BCMI_FALCON_XGXS_PATT_GEN_SEQ5r
#define PATT_GEN_SEQ5r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_t PATT_GEN_SEQ5r_t;
#define PATT_GEN_SEQ5r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_CLR
#define PATT_GEN_SEQ5r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_SET
#define PATT_GEN_SEQ5r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_GET
#define PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_GET
#define PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ5r_PATT_GEN_SEQ_5f_SET
#define READ_PATT_GEN_SEQ5r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ5r
#define WRITE_PATT_GEN_SEQ5r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ5r
#define MODIFY_PATT_GEN_SEQ5r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ5r
#define READLN_PATT_GEN_SEQ5r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ5r
#define WRITELN_PATT_GEN_SEQ5r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ5r
#define WRITEALL_PATT_GEN_SEQ5r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ6
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd126
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 6
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_6   Fixed Pattern Generator Sequence Word 6. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ6r (0x0001d126 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ6.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq6[1];
	uint32_t _patt_gen_seq6;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_CLR(r) (r).patt_gen_seq6[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_SET(r,d) (r).patt_gen_seq6[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_GET(r) (r).patt_gen_seq6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_GET(r) (((r).patt_gen_seq6[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_SET(r,f) (r).patt_gen_seq6[0]=(((r).patt_gen_seq6[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ6.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ6r,(_r._patt_gen_seq6))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ6r,(_r._patt_gen_seq6)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ6r,(_r._patt_gen_seq6))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq6))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq6))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ6r BCMI_FALCON_XGXS_PATT_GEN_SEQ6r
#define PATT_GEN_SEQ6r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_t PATT_GEN_SEQ6r_t;
#define PATT_GEN_SEQ6r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_CLR
#define PATT_GEN_SEQ6r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_SET
#define PATT_GEN_SEQ6r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_GET
#define PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_GET
#define PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ6r_PATT_GEN_SEQ_6f_SET
#define READ_PATT_GEN_SEQ6r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ6r
#define WRITE_PATT_GEN_SEQ6r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ6r
#define MODIFY_PATT_GEN_SEQ6r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ6r
#define READLN_PATT_GEN_SEQ6r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ6r
#define WRITELN_PATT_GEN_SEQ6r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ6r
#define WRITEALL_PATT_GEN_SEQ6r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ7
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd127
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 7
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_7   Fixed Pattern Generator Sequence Word 7. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ7r (0x0001d127 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ7.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq7[1];
	uint32_t _patt_gen_seq7;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_CLR(r) (r).patt_gen_seq7[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_SET(r,d) (r).patt_gen_seq7[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_GET(r) (r).patt_gen_seq7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_GET(r) (((r).patt_gen_seq7[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_SET(r,f) (r).patt_gen_seq7[0]=(((r).patt_gen_seq7[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ7.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ7r,(_r._patt_gen_seq7))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ7r,(_r._patt_gen_seq7)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ7r,(_r._patt_gen_seq7))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq7))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq7))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ7r BCMI_FALCON_XGXS_PATT_GEN_SEQ7r
#define PATT_GEN_SEQ7r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_t PATT_GEN_SEQ7r_t;
#define PATT_GEN_SEQ7r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_CLR
#define PATT_GEN_SEQ7r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_SET
#define PATT_GEN_SEQ7r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_GET
#define PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_GET
#define PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ7r_PATT_GEN_SEQ_7f_SET
#define READ_PATT_GEN_SEQ7r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ7r
#define WRITE_PATT_GEN_SEQ7r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ7r
#define MODIFY_PATT_GEN_SEQ7r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ7r
#define READLN_PATT_GEN_SEQ7r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ7r
#define WRITELN_PATT_GEN_SEQ7r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ7r
#define WRITEALL_PATT_GEN_SEQ7r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ8
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd128
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 8
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_8   Fixed Pattern Generator Sequence Word 8. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ8r (0x0001d128 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ8.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq8[1];
	uint32_t _patt_gen_seq8;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_CLR(r) (r).patt_gen_seq8[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_SET(r,d) (r).patt_gen_seq8[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_GET(r) (r).patt_gen_seq8[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_GET(r) (((r).patt_gen_seq8[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_SET(r,f) (r).patt_gen_seq8[0]=(((r).patt_gen_seq8[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ8.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ8r,(_r._patt_gen_seq8))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ8r,(_r._patt_gen_seq8)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ8r,(_r._patt_gen_seq8))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ8r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq8))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ8r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq8))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ8r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ8r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq8))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ8r BCMI_FALCON_XGXS_PATT_GEN_SEQ8r
#define PATT_GEN_SEQ8r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_t PATT_GEN_SEQ8r_t;
#define PATT_GEN_SEQ8r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_CLR
#define PATT_GEN_SEQ8r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_SET
#define PATT_GEN_SEQ8r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_GET
#define PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_GET
#define PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ8r_PATT_GEN_SEQ_8f_SET
#define READ_PATT_GEN_SEQ8r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ8r
#define WRITE_PATT_GEN_SEQ8r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ8r
#define MODIFY_PATT_GEN_SEQ8r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ8r
#define READLN_PATT_GEN_SEQ8r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ8r
#define WRITELN_PATT_GEN_SEQ8r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ8r
#define WRITEALL_PATT_GEN_SEQ8r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ8r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ8r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ9
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd129
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 9
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_9   Fixed Pattern Generator Sequence Word 9. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ9r (0x0001d129 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ9.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq9[1];
	uint32_t _patt_gen_seq9;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_CLR(r) (r).patt_gen_seq9[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_SET(r,d) (r).patt_gen_seq9[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_GET(r) (r).patt_gen_seq9[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_GET(r) (((r).patt_gen_seq9[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_SET(r,f) (r).patt_gen_seq9[0]=(((r).patt_gen_seq9[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ9.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ9r,(_r._patt_gen_seq9))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ9r,(_r._patt_gen_seq9)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ9r,(_r._patt_gen_seq9))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ9r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq9))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ9r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq9))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ9r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ9r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq9))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ9r BCMI_FALCON_XGXS_PATT_GEN_SEQ9r
#define PATT_GEN_SEQ9r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_t PATT_GEN_SEQ9r_t;
#define PATT_GEN_SEQ9r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_CLR
#define PATT_GEN_SEQ9r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_SET
#define PATT_GEN_SEQ9r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_GET
#define PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_GET
#define PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ9r_PATT_GEN_SEQ_9f_SET
#define READ_PATT_GEN_SEQ9r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ9r
#define WRITE_PATT_GEN_SEQ9r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ9r
#define MODIFY_PATT_GEN_SEQ9r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ9r
#define READLN_PATT_GEN_SEQ9r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ9r
#define WRITELN_PATT_GEN_SEQ9r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ9r
#define WRITEALL_PATT_GEN_SEQ9r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ9r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ9r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ_10
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12a
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 10
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_10  Fixed Pattern Generator Sequence Word 10. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r (0x0001d12a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_10.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_10[1];
	uint32_t _patt_gen_seq_10;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_CLR(r) (r).patt_gen_seq_10[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_SET(r,d) (r).patt_gen_seq_10[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_GET(r) (r).patt_gen_seq_10[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_GET(r) (((r).patt_gen_seq_10[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_SET(r,f) (r).patt_gen_seq_10[0]=(((r).patt_gen_seq_10[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_10.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r,(_r._patt_gen_seq_10))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r,(_r._patt_gen_seq_10)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r,(_r._patt_gen_seq_10))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_10r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_10))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_10r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_10))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_10r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_10))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_10r BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r
#define PATT_GEN_SEQ_10r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_t PATT_GEN_SEQ_10r_t;
#define PATT_GEN_SEQ_10r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_CLR
#define PATT_GEN_SEQ_10r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_SET
#define PATT_GEN_SEQ_10r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_GET
#define PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_GET
#define PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r_PATT_GEN_SEQ_10f_SET
#define READ_PATT_GEN_SEQ_10r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_10r
#define WRITE_PATT_GEN_SEQ_10r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_10r
#define MODIFY_PATT_GEN_SEQ_10r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_10r
#define READLN_PATT_GEN_SEQ_10r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_10r
#define WRITELN_PATT_GEN_SEQ_10r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_10r
#define WRITEALL_PATT_GEN_SEQ_10r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_10r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ_10r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ_11
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12b
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 11
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_11  Fixed Pattern Generator Sequence Word 11. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r (0x0001d12b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_11.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_11[1];
	uint32_t _patt_gen_seq_11;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_CLR(r) (r).patt_gen_seq_11[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_SET(r,d) (r).patt_gen_seq_11[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_GET(r) (r).patt_gen_seq_11[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_GET(r) (((r).patt_gen_seq_11[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_SET(r,f) (r).patt_gen_seq_11[0]=(((r).patt_gen_seq_11[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_11.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r,(_r._patt_gen_seq_11))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r,(_r._patt_gen_seq_11)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r,(_r._patt_gen_seq_11))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_11r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_11))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_11r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_11))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_11r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_11))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_11r BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r
#define PATT_GEN_SEQ_11r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_t PATT_GEN_SEQ_11r_t;
#define PATT_GEN_SEQ_11r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_CLR
#define PATT_GEN_SEQ_11r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_SET
#define PATT_GEN_SEQ_11r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_GET
#define PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_GET
#define PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r_PATT_GEN_SEQ_11f_SET
#define READ_PATT_GEN_SEQ_11r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_11r
#define WRITE_PATT_GEN_SEQ_11r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_11r
#define MODIFY_PATT_GEN_SEQ_11r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_11r
#define READLN_PATT_GEN_SEQ_11r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_11r
#define WRITELN_PATT_GEN_SEQ_11r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_11r
#define WRITEALL_PATT_GEN_SEQ_11r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_11r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ_11r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ_12
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12c
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 12
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_12  Fixed Pattern Generator Sequence Word 12. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r (0x0001d12c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_12.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_12[1];
	uint32_t _patt_gen_seq_12;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_CLR(r) (r).patt_gen_seq_12[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_SET(r,d) (r).patt_gen_seq_12[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_GET(r) (r).patt_gen_seq_12[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_GET(r) (((r).patt_gen_seq_12[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_SET(r,f) (r).patt_gen_seq_12[0]=(((r).patt_gen_seq_12[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_12.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r,(_r._patt_gen_seq_12))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r,(_r._patt_gen_seq_12)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r,(_r._patt_gen_seq_12))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_12r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_12))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_12r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_12))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_12r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_12))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_12r BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r
#define PATT_GEN_SEQ_12r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_t PATT_GEN_SEQ_12r_t;
#define PATT_GEN_SEQ_12r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_CLR
#define PATT_GEN_SEQ_12r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_SET
#define PATT_GEN_SEQ_12r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_GET
#define PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_GET
#define PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r_PATT_GEN_SEQ_12f_SET
#define READ_PATT_GEN_SEQ_12r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_12r
#define WRITE_PATT_GEN_SEQ_12r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_12r
#define MODIFY_PATT_GEN_SEQ_12r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_12r
#define READLN_PATT_GEN_SEQ_12r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_12r
#define WRITELN_PATT_GEN_SEQ_12r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_12r
#define WRITEALL_PATT_GEN_SEQ_12r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_12r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ_12r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ_13
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12d
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 13
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_13  Fixed Pattern Generator Sequence Word 13. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r (0x0001d12d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_13.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_13[1];
	uint32_t _patt_gen_seq_13;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_CLR(r) (r).patt_gen_seq_13[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_SET(r,d) (r).patt_gen_seq_13[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_GET(r) (r).patt_gen_seq_13[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_GET(r) (((r).patt_gen_seq_13[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_SET(r,f) (r).patt_gen_seq_13[0]=(((r).patt_gen_seq_13[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_13.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r,(_r._patt_gen_seq_13))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r,(_r._patt_gen_seq_13)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r,(_r._patt_gen_seq_13))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_13r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_13))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_13r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_13))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_13r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_13))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_13r BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r
#define PATT_GEN_SEQ_13r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_t PATT_GEN_SEQ_13r_t;
#define PATT_GEN_SEQ_13r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_CLR
#define PATT_GEN_SEQ_13r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_SET
#define PATT_GEN_SEQ_13r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_GET
#define PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_GET
#define PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r_PATT_GEN_SEQ_13f_SET
#define READ_PATT_GEN_SEQ_13r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_13r
#define WRITE_PATT_GEN_SEQ_13r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_13r
#define MODIFY_PATT_GEN_SEQ_13r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_13r
#define READLN_PATT_GEN_SEQ_13r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_13r
#define WRITELN_PATT_GEN_SEQ_13r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_13r
#define WRITEALL_PATT_GEN_SEQ_13r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_13r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ_13r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PATT_GEN_SEQ_14
 * BLOCKS:   PATT_GEN_COM
 * REGADDR:  0xd12e
 * DEVAD:    1
 * DESC:     Pattern Generator Sequence Word 14
 * RESETVAL: 0xff00 (65280)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_SEQ_14  Fixed Pattern Generator Sequence Word 14. MSB bits will be transmitted first on serial transmit lane in both shared and slice mode. This word will be transmitted first.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r (0x0001d12e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_SIZE 4

/*
 * This structure should be used to declare and program PATT_GEN_SEQ_14.
 */
typedef union BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_s {
	uint32_t v[1];
	uint32_t patt_gen_seq_14[1];
	uint32_t _patt_gen_seq_14;
} BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_t;

#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_CLR(r) (r).patt_gen_seq_14[0] = 0
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_SET(r,d) (r).patt_gen_seq_14[0] = d
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_GET(r) (r).patt_gen_seq_14[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_GET(r) (((r).patt_gen_seq_14[0]) & 0xffff)
#define BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_SET(r,f) (r).patt_gen_seq_14[0]=(((r).patt_gen_seq_14[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access PATT_GEN_SEQ_14.
 */
#define BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r,(_r._patt_gen_seq_14))
#define BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r,(_r._patt_gen_seq_14)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r,(_r._patt_gen_seq_14))
#define BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_14r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_14))
#define BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_14r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._patt_gen_seq_14))
#define BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_14r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._patt_gen_seq_14))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PATT_GEN_SEQ_14r BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r
#define PATT_GEN_SEQ_14r_SIZE BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_SIZE
typedef BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_t PATT_GEN_SEQ_14r_t;
#define PATT_GEN_SEQ_14r_CLR BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_CLR
#define PATT_GEN_SEQ_14r_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_SET
#define PATT_GEN_SEQ_14r_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_GET
#define PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_GET BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_GET
#define PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_SET BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r_PATT_GEN_SEQ_14f_SET
#define READ_PATT_GEN_SEQ_14r BCMI_FALCON_XGXS_READ_PATT_GEN_SEQ_14r
#define WRITE_PATT_GEN_SEQ_14r BCMI_FALCON_XGXS_WRITE_PATT_GEN_SEQ_14r
#define MODIFY_PATT_GEN_SEQ_14r BCMI_FALCON_XGXS_MODIFY_PATT_GEN_SEQ_14r
#define READLN_PATT_GEN_SEQ_14r BCMI_FALCON_XGXS_READLN_PATT_GEN_SEQ_14r
#define WRITELN_PATT_GEN_SEQ_14r BCMI_FALCON_XGXS_WRITELN_PATT_GEN_SEQ_14r
#define WRITEALL_PATT_GEN_SEQ_14r BCMI_FALCON_XGXS_WRITEALL_PATT_GEN_SEQ_14r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PATT_GEN_SEQ_14r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd130
 * DEVAD:    1
 * DESC:     TX FIR Control0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_PRE_OFFSET tx fir pre tap offset values -8 to +7 (2's complement format)This field is used to adjust the Pre tap values
 *     TXFIR_MAIN_OFFSET tx fir main tap offset value -8 to +7 (2's complement format)This field is used to adjust the Main tap values
 *     TXFIR_POST_OFFSET tx fir post tap offset value -8 to +7 (2's complement format)This field is used to adjust the Post tap values
 */
#define BCMI_FALCON_XGXS_TXFIR_CTL0r (0x0001d130 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL0.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_ctl0[1];
	uint32_t _txfir_ctl0;
} BCMI_FALCON_XGXS_TXFIR_CTL0r_t;

#define BCMI_FALCON_XGXS_TXFIR_CTL0r_CLR(r) (r).txfir_ctl0[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_SET(r,d) (r).txfir_ctl0[0] = d
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_GET(r) (r).txfir_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_POST_OFFSETf_GET(r) ((((r).txfir_ctl0[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_POST_OFFSETf_SET(r,f) (r).txfir_ctl0[0]=(((r).txfir_ctl0[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_GET(r) ((((r).txfir_ctl0[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_SET(r,f) (r).txfir_ctl0[0]=(((r).txfir_ctl0[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_GET(r) (((r).txfir_ctl0[0]) & 0xf)
#define BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_SET(r,f) (r).txfir_ctl0[0]=(((r).txfir_ctl0[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXFIR_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_CTL0r,(_r._txfir_ctl0))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL0r,(_r._txfir_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL0r,(_r._txfir_ctl0))
#define BCMI_FALCON_XGXS_READLN_TXFIR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL0r BCMI_FALCON_XGXS_TXFIR_CTL0r
#define TXFIR_CTL0r_SIZE BCMI_FALCON_XGXS_TXFIR_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_CTL0r_t TXFIR_CTL0r_t;
#define TXFIR_CTL0r_CLR BCMI_FALCON_XGXS_TXFIR_CTL0r_CLR
#define TXFIR_CTL0r_SET BCMI_FALCON_XGXS_TXFIR_CTL0r_SET
#define TXFIR_CTL0r_GET BCMI_FALCON_XGXS_TXFIR_CTL0r_GET
#define TXFIR_CTL0r_TXFIR_POST_OFFSETf_GET BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_POST_OFFSETf_GET
#define TXFIR_CTL0r_TXFIR_POST_OFFSETf_SET BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_POST_OFFSETf_SET
#define TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_GET BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_GET
#define TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_SET BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_MAIN_OFFSETf_SET
#define TXFIR_CTL0r_TXFIR_PRE_OFFSETf_GET BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_GET
#define TXFIR_CTL0r_TXFIR_PRE_OFFSETf_SET BCMI_FALCON_XGXS_TXFIR_CTL0r_TXFIR_PRE_OFFSETf_SET
#define READ_TXFIR_CTL0r BCMI_FALCON_XGXS_READ_TXFIR_CTL0r
#define WRITE_TXFIR_CTL0r BCMI_FALCON_XGXS_WRITE_TXFIR_CTL0r
#define MODIFY_TXFIR_CTL0r BCMI_FALCON_XGXS_MODIFY_TXFIR_CTL0r
#define READLN_TXFIR_CTL0r BCMI_FALCON_XGXS_READLN_TXFIR_CTL0r
#define WRITELN_TXFIR_CTL0r BCMI_FALCON_XGXS_WRITELN_TXFIR_CTL0r
#define WRITEALL_TXFIR_CTL0r BCMI_FALCON_XGXS_WRITEALL_TXFIR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_CTL1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd131
 * DEVAD:    1
 * DESC:     TX FIR Control1 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_POST2      tx fir post2 tap value -16 ..+15 (2's complement format)Post2 tap value only driven from a register
 *     TXFIR_POST2_OFFSET tx fir post2 tap offset value -8 to +7 (2's complement format)This field is used to adjust the Post2 tap values
 */
#define BCMI_FALCON_XGXS_TXFIR_CTL1r (0x0001d131 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL1.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_CTL1r_s {
	uint32_t v[1];
	uint32_t txfir_ctl1[1];
	uint32_t _txfir_ctl1;
} BCMI_FALCON_XGXS_TXFIR_CTL1r_t;

#define BCMI_FALCON_XGXS_TXFIR_CTL1r_CLR(r) (r).txfir_ctl1[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_CTL1r_SET(r,d) (r).txfir_ctl1[0] = d
#define BCMI_FALCON_XGXS_TXFIR_CTL1r_GET(r) (r).txfir_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_GET(r) ((((r).txfir_ctl1[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_SET(r,f) (r).txfir_ctl1[0]=(((r).txfir_ctl1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2f_GET(r) (((r).txfir_ctl1[0]) & 0x1f)
#define BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2f_SET(r,f) (r).txfir_ctl1[0]=(((r).txfir_ctl1[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TXFIR_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_CTL1r,(_r._txfir_ctl1))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL1r,(_r._txfir_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL1r,(_r._txfir_ctl1))
#define BCMI_FALCON_XGXS_READLN_TXFIR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL1r BCMI_FALCON_XGXS_TXFIR_CTL1r
#define TXFIR_CTL1r_SIZE BCMI_FALCON_XGXS_TXFIR_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_CTL1r_t TXFIR_CTL1r_t;
#define TXFIR_CTL1r_CLR BCMI_FALCON_XGXS_TXFIR_CTL1r_CLR
#define TXFIR_CTL1r_SET BCMI_FALCON_XGXS_TXFIR_CTL1r_SET
#define TXFIR_CTL1r_GET BCMI_FALCON_XGXS_TXFIR_CTL1r_GET
#define TXFIR_CTL1r_TXFIR_POST2_OFFSETf_GET BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_GET
#define TXFIR_CTL1r_TXFIR_POST2_OFFSETf_SET BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2_OFFSETf_SET
#define TXFIR_CTL1r_TXFIR_POST2f_GET BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2f_GET
#define TXFIR_CTL1r_TXFIR_POST2f_SET BCMI_FALCON_XGXS_TXFIR_CTL1r_TXFIR_POST2f_SET
#define READ_TXFIR_CTL1r BCMI_FALCON_XGXS_READ_TXFIR_CTL1r
#define WRITE_TXFIR_CTL1r BCMI_FALCON_XGXS_WRITE_TXFIR_CTL1r
#define MODIFY_TXFIR_CTL1r BCMI_FALCON_XGXS_MODIFY_TXFIR_CTL1r
#define READLN_TXFIR_CTL1r BCMI_FALCON_XGXS_READLN_TXFIR_CTL1r
#define WRITELN_TXFIR_CTL1r BCMI_FALCON_XGXS_WRITELN_TXFIR_CTL1r
#define WRITEALL_TXFIR_CTL1r BCMI_FALCON_XGXS_WRITEALL_TXFIR_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_CTL2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd132
 * DEVAD:    1
 * DESC:     TX FIR Control2 Register
 * RESETVAL: 0x800 (2048)
 * ACCESS:   R/W
 * FIELDS:
 *     TXFIR_POST3      tx fir post3 tap value.Post3 tap value only driven from a registerThe value range is -8 ..+7 and it is in 2's complement format
 *     TXFIR_POST3_OFFSET tx fir post3 tap offset value -8 to +7This field is used to adjust the Post3 tap valuesThe mapping is not 2's complement, please txfir_pre_offset field description
 */
#define BCMI_FALCON_XGXS_TXFIR_CTL2r (0x0001d132 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_CTL2.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_CTL2r_s {
	uint32_t v[1];
	uint32_t txfir_ctl2[1];
	uint32_t _txfir_ctl2;
} BCMI_FALCON_XGXS_TXFIR_CTL2r_t;

#define BCMI_FALCON_XGXS_TXFIR_CTL2r_CLR(r) (r).txfir_ctl2[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_CTL2r_SET(r,d) (r).txfir_ctl2[0] = d
#define BCMI_FALCON_XGXS_TXFIR_CTL2r_GET(r) (r).txfir_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3_OFFSETf_GET(r) ((((r).txfir_ctl2[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3_OFFSETf_SET(r,f) (r).txfir_ctl2[0]=(((r).txfir_ctl2[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3f_GET(r) (((r).txfir_ctl2[0]) & 0xf)
#define BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3f_SET(r,f) (r).txfir_ctl2[0]=(((r).txfir_ctl2[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXFIR_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_CTL2r,(_r._txfir_ctl2))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL2r,(_r._txfir_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL2r,(_r._txfir_ctl2))
#define BCMI_FALCON_XGXS_READLN_TXFIR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_CTL2r BCMI_FALCON_XGXS_TXFIR_CTL2r
#define TXFIR_CTL2r_SIZE BCMI_FALCON_XGXS_TXFIR_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_CTL2r_t TXFIR_CTL2r_t;
#define TXFIR_CTL2r_CLR BCMI_FALCON_XGXS_TXFIR_CTL2r_CLR
#define TXFIR_CTL2r_SET BCMI_FALCON_XGXS_TXFIR_CTL2r_SET
#define TXFIR_CTL2r_GET BCMI_FALCON_XGXS_TXFIR_CTL2r_GET
#define TXFIR_CTL2r_TXFIR_POST3_OFFSETf_GET BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3_OFFSETf_GET
#define TXFIR_CTL2r_TXFIR_POST3_OFFSETf_SET BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3_OFFSETf_SET
#define TXFIR_CTL2r_TXFIR_POST3f_GET BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3f_GET
#define TXFIR_CTL2r_TXFIR_POST3f_SET BCMI_FALCON_XGXS_TXFIR_CTL2r_TXFIR_POST3f_SET
#define READ_TXFIR_CTL2r BCMI_FALCON_XGXS_READ_TXFIR_CTL2r
#define WRITE_TXFIR_CTL2r BCMI_FALCON_XGXS_WRITE_TXFIR_CTL2r
#define MODIFY_TXFIR_CTL2r BCMI_FALCON_XGXS_MODIFY_TXFIR_CTL2r
#define READLN_TXFIR_CTL2r BCMI_FALCON_XGXS_READLN_TXFIR_CTL2r
#define WRITELN_TXFIR_CTL2r BCMI_FALCON_XGXS_WRITELN_TXFIR_CTL2r
#define WRITEALL_TXFIR_CTL2r BCMI_FALCON_XGXS_WRITEALL_TXFIR_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_STS0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd133
 * DEVAD:    1
 * DESC:     TX FIR Status0 Register
 * RESETVAL: 0x2c08 (11272)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_PRE_AFTER_OVR tx fir pre tap value after override mux. status
 *     TXFIR_POST_AFTER_OVR tx fir post tap value after override mux. status
 */
#define BCMI_FALCON_XGXS_TXFIR_STS0r (0x0001d133 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS0.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_STS0r_s {
	uint32_t v[1];
	uint32_t txfir_sts0[1];
	uint32_t _txfir_sts0;
} BCMI_FALCON_XGXS_TXFIR_STS0r_t;

#define BCMI_FALCON_XGXS_TXFIR_STS0r_CLR(r) (r).txfir_sts0[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_STS0r_SET(r,d) (r).txfir_sts0[0] = d
#define BCMI_FALCON_XGXS_TXFIR_STS0r_GET(r) (r).txfir_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_GET(r) ((((r).txfir_sts0[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_SET(r,f) (r).txfir_sts0[0]=(((r).txfir_sts0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_GET(r) (((r).txfir_sts0[0]) & 0x1f)
#define BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_SET(r,f) (r).txfir_sts0[0]=(((r).txfir_sts0[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TXFIR_STS0.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS0r,(_r._txfir_sts0))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS0r,(_r._txfir_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS0r,(_r._txfir_sts0))
#define BCMI_FALCON_XGXS_READLN_TXFIR_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts0))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS0r BCMI_FALCON_XGXS_TXFIR_STS0r
#define TXFIR_STS0r_SIZE BCMI_FALCON_XGXS_TXFIR_STS0r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_STS0r_t TXFIR_STS0r_t;
#define TXFIR_STS0r_CLR BCMI_FALCON_XGXS_TXFIR_STS0r_CLR
#define TXFIR_STS0r_SET BCMI_FALCON_XGXS_TXFIR_STS0r_SET
#define TXFIR_STS0r_GET BCMI_FALCON_XGXS_TXFIR_STS0r_GET
#define TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_GET BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_GET
#define TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_SET BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_POST_AFTER_OVRf_SET
#define TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_GET BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_GET
#define TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_SET BCMI_FALCON_XGXS_TXFIR_STS0r_TXFIR_PRE_AFTER_OVRf_SET
#define READ_TXFIR_STS0r BCMI_FALCON_XGXS_READ_TXFIR_STS0r
#define WRITE_TXFIR_STS0r BCMI_FALCON_XGXS_WRITE_TXFIR_STS0r
#define MODIFY_TXFIR_STS0r BCMI_FALCON_XGXS_MODIFY_TXFIR_STS0r
#define READLN_TXFIR_STS0r BCMI_FALCON_XGXS_READLN_TXFIR_STS0r
#define WRITELN_TXFIR_STS0r BCMI_FALCON_XGXS_WRITELN_TXFIR_STS0r
#define WRITEALL_TXFIR_STS0r BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_STS1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd134
 * DEVAD:    1
 * DESC:     TX FIR Status1 Register
 * RESETVAL: 0x3c (60)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_MAIN_AFTER_OVR tx fir main tap value after override mux. status
 */
#define BCMI_FALCON_XGXS_TXFIR_STS1r (0x0001d134 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_STS1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS1.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_STS1r_s {
	uint32_t v[1];
	uint32_t txfir_sts1[1];
	uint32_t _txfir_sts1;
} BCMI_FALCON_XGXS_TXFIR_STS1r_t;

#define BCMI_FALCON_XGXS_TXFIR_STS1r_CLR(r) (r).txfir_sts1[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_STS1r_SET(r,d) (r).txfir_sts1[0] = d
#define BCMI_FALCON_XGXS_TXFIR_STS1r_GET(r) (r).txfir_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_GET(r) (((r).txfir_sts1[0]) & 0x7f)
#define BCMI_FALCON_XGXS_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_SET(r,f) (r).txfir_sts1[0]=(((r).txfir_sts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_STS1.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS1r,(_r._txfir_sts1))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS1r,(_r._txfir_sts1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS1r,(_r._txfir_sts1))
#define BCMI_FALCON_XGXS_READLN_TXFIR_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts1))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts1))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS1r BCMI_FALCON_XGXS_TXFIR_STS1r
#define TXFIR_STS1r_SIZE BCMI_FALCON_XGXS_TXFIR_STS1r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_STS1r_t TXFIR_STS1r_t;
#define TXFIR_STS1r_CLR BCMI_FALCON_XGXS_TXFIR_STS1r_CLR
#define TXFIR_STS1r_SET BCMI_FALCON_XGXS_TXFIR_STS1r_SET
#define TXFIR_STS1r_GET BCMI_FALCON_XGXS_TXFIR_STS1r_GET
#define TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_GET BCMI_FALCON_XGXS_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_GET
#define TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_SET BCMI_FALCON_XGXS_TXFIR_STS1r_TXFIR_MAIN_AFTER_OVRf_SET
#define READ_TXFIR_STS1r BCMI_FALCON_XGXS_READ_TXFIR_STS1r
#define WRITE_TXFIR_STS1r BCMI_FALCON_XGXS_WRITE_TXFIR_STS1r
#define MODIFY_TXFIR_STS1r BCMI_FALCON_XGXS_MODIFY_TXFIR_STS1r
#define READLN_TXFIR_STS1r BCMI_FALCON_XGXS_READLN_TXFIR_STS1r
#define WRITELN_TXFIR_STS1r BCMI_FALCON_XGXS_WRITELN_TXFIR_STS1r
#define WRITEALL_TXFIR_STS1r BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_STS2
 * BLOCKS:   TX_FED
 * REGADDR:  0xd135
 * DEVAD:    1
 * DESC:     TX FIR Status2 Register
 * RESETVAL: 0x2c08 (11272)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_PRE_ADJUSTED tx fir pre tap value after offset adjustment. status
 *     TXFIR_POST_ADJUSTED tx fir post tap value after offset adjustment. status
 */
#define BCMI_FALCON_XGXS_TXFIR_STS2r (0x0001d135 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_STS2r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS2.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_STS2r_s {
	uint32_t v[1];
	uint32_t txfir_sts2[1];
	uint32_t _txfir_sts2;
} BCMI_FALCON_XGXS_TXFIR_STS2r_t;

#define BCMI_FALCON_XGXS_TXFIR_STS2r_CLR(r) (r).txfir_sts2[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_STS2r_SET(r,d) (r).txfir_sts2[0] = d
#define BCMI_FALCON_XGXS_TXFIR_STS2r_GET(r) (r).txfir_sts2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_GET(r) ((((r).txfir_sts2[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_SET(r,f) (r).txfir_sts2[0]=(((r).txfir_sts2[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_GET(r) (((r).txfir_sts2[0]) & 0x1f)
#define BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_SET(r,f) (r).txfir_sts2[0]=(((r).txfir_sts2[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TXFIR_STS2.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_STS2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS2r,(_r._txfir_sts2))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS2r,(_r._txfir_sts2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS2r,(_r._txfir_sts2))
#define BCMI_FALCON_XGXS_READLN_TXFIR_STS2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts2))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_STS2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts2))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS2r BCMI_FALCON_XGXS_TXFIR_STS2r
#define TXFIR_STS2r_SIZE BCMI_FALCON_XGXS_TXFIR_STS2r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_STS2r_t TXFIR_STS2r_t;
#define TXFIR_STS2r_CLR BCMI_FALCON_XGXS_TXFIR_STS2r_CLR
#define TXFIR_STS2r_SET BCMI_FALCON_XGXS_TXFIR_STS2r_SET
#define TXFIR_STS2r_GET BCMI_FALCON_XGXS_TXFIR_STS2r_GET
#define TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_GET BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_GET
#define TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_SET BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_POST_ADJUSTEDf_SET
#define TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_GET BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_GET
#define TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_SET BCMI_FALCON_XGXS_TXFIR_STS2r_TXFIR_PRE_ADJUSTEDf_SET
#define READ_TXFIR_STS2r BCMI_FALCON_XGXS_READ_TXFIR_STS2r
#define WRITE_TXFIR_STS2r BCMI_FALCON_XGXS_WRITE_TXFIR_STS2r
#define MODIFY_TXFIR_STS2r BCMI_FALCON_XGXS_MODIFY_TXFIR_STS2r
#define READLN_TXFIR_STS2r BCMI_FALCON_XGXS_READLN_TXFIR_STS2r
#define WRITELN_TXFIR_STS2r BCMI_FALCON_XGXS_WRITELN_TXFIR_STS2r
#define WRITEALL_TXFIR_STS2r BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_STS2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_STS3
 * BLOCKS:   TX_FED
 * REGADDR:  0xd136
 * DEVAD:    1
 * DESC:     TX FIR Status3 Register
 * RESETVAL: 0x3c (60)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_MAIN_ADJUSTED tx fir main tap value after offset adjustment. status
 *     TXFIR_POST2_ADJUSTED tx fir post2 tap value after offset adjustment. statusThe value range is -16 ..+15 and it is in 2's complement format
 */
#define BCMI_FALCON_XGXS_TXFIR_STS3r (0x0001d136 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_STS3r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS3.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_STS3r_s {
	uint32_t v[1];
	uint32_t txfir_sts3[1];
	uint32_t _txfir_sts3;
} BCMI_FALCON_XGXS_TXFIR_STS3r_t;

#define BCMI_FALCON_XGXS_TXFIR_STS3r_CLR(r) (r).txfir_sts3[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_STS3r_SET(r,d) (r).txfir_sts3[0] = d
#define BCMI_FALCON_XGXS_TXFIR_STS3r_GET(r) (r).txfir_sts3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_GET(r) ((((r).txfir_sts3[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_SET(r,f) (r).txfir_sts3[0]=(((r).txfir_sts3[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_GET(r) (((r).txfir_sts3[0]) & 0x7f)
#define BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_SET(r,f) (r).txfir_sts3[0]=(((r).txfir_sts3[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TXFIR_STS3.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_STS3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS3r,(_r._txfir_sts3))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS3r,(_r._txfir_sts3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS3r,(_r._txfir_sts3))
#define BCMI_FALCON_XGXS_READLN_TXFIR_STS3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts3))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_STS3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts3))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS3r BCMI_FALCON_XGXS_TXFIR_STS3r
#define TXFIR_STS3r_SIZE BCMI_FALCON_XGXS_TXFIR_STS3r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_STS3r_t TXFIR_STS3r_t;
#define TXFIR_STS3r_CLR BCMI_FALCON_XGXS_TXFIR_STS3r_CLR
#define TXFIR_STS3r_SET BCMI_FALCON_XGXS_TXFIR_STS3r_SET
#define TXFIR_STS3r_GET BCMI_FALCON_XGXS_TXFIR_STS3r_GET
#define TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_GET BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_GET
#define TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_SET BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_POST2_ADJUSTEDf_SET
#define TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_GET BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_GET
#define TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_SET BCMI_FALCON_XGXS_TXFIR_STS3r_TXFIR_MAIN_ADJUSTEDf_SET
#define READ_TXFIR_STS3r BCMI_FALCON_XGXS_READ_TXFIR_STS3r
#define WRITE_TXFIR_STS3r BCMI_FALCON_XGXS_WRITE_TXFIR_STS3r
#define MODIFY_TXFIR_STS3r BCMI_FALCON_XGXS_MODIFY_TXFIR_STS3r
#define READLN_TXFIR_STS3r BCMI_FALCON_XGXS_READLN_TXFIR_STS3r
#define WRITELN_TXFIR_STS3r BCMI_FALCON_XGXS_WRITELN_TXFIR_STS3r
#define WRITEALL_TXFIR_STS3r BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_STS3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_STS4
 * BLOCKS:   TX_FED
 * REGADDR:  0xd137
 * DEVAD:    1
 * DESC:     TX FIR Status4 Register
 * RESETVAL: 0x8 (8)
 * ACCESS:   R/O
 * FIELDS:
 *     TXFIR_POST3_ADJUSTED tx fir post3 tap value after offset adjustment. statusThe value range is -8 ..+7 and it is in 2's complement format
 */
#define BCMI_FALCON_XGXS_TXFIR_STS4r (0x0001d137 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_STS4r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_STS4.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_STS4r_s {
	uint32_t v[1];
	uint32_t txfir_sts4[1];
	uint32_t _txfir_sts4;
} BCMI_FALCON_XGXS_TXFIR_STS4r_t;

#define BCMI_FALCON_XGXS_TXFIR_STS4r_CLR(r) (r).txfir_sts4[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_STS4r_SET(r,d) (r).txfir_sts4[0] = d
#define BCMI_FALCON_XGXS_TXFIR_STS4r_GET(r) (r).txfir_sts4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET(r) (((r).txfir_sts4[0]) & 0xf)
#define BCMI_FALCON_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET(r,f) (r).txfir_sts4[0]=(((r).txfir_sts4[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access TXFIR_STS4.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_STS4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS4r,(_r._txfir_sts4))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS4r,(_r._txfir_sts4)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS4r,(_r._txfir_sts4))
#define BCMI_FALCON_XGXS_READLN_TXFIR_STS4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts4))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_STS4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_sts4))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_STS4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_sts4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_STS4r BCMI_FALCON_XGXS_TXFIR_STS4r
#define TXFIR_STS4r_SIZE BCMI_FALCON_XGXS_TXFIR_STS4r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_STS4r_t TXFIR_STS4r_t;
#define TXFIR_STS4r_CLR BCMI_FALCON_XGXS_TXFIR_STS4r_CLR
#define TXFIR_STS4r_SET BCMI_FALCON_XGXS_TXFIR_STS4r_SET
#define TXFIR_STS4r_GET BCMI_FALCON_XGXS_TXFIR_STS4r_GET
#define TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET BCMI_FALCON_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_GET
#define TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET BCMI_FALCON_XGXS_TXFIR_STS4r_TXFIR_POST3_ADJUSTEDf_SET
#define READ_TXFIR_STS4r BCMI_FALCON_XGXS_READ_TXFIR_STS4r
#define WRITE_TXFIR_STS4r BCMI_FALCON_XGXS_WRITE_TXFIR_STS4r
#define MODIFY_TXFIR_STS4r BCMI_FALCON_XGXS_MODIFY_TXFIR_STS4r
#define READLN_TXFIR_STS4r BCMI_FALCON_XGXS_READLN_TXFIR_STS4r
#define WRITELN_TXFIR_STS4r BCMI_FALCON_XGXS_WRITELN_TXFIR_STS4r
#define WRITEALL_TXFIR_STS4r BCMI_FALCON_XGXS_WRITEALL_TXFIR_STS4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_STS4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_UC_CTL0
 * BLOCKS:   TX_FED
 * REGADDR:  0xd138
 * DEVAD:    1
 * DESC:     Micro Control 0 Register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_TX_DISABLE micro tx disableThis field is used by the Microcontroller for tx disable control during CL72 forced modePlease see Eagle & Merlin PMD Internal Functional Specification for details
 */
#define BCMI_FALCON_XGXS_TXFIR_UC_CTL0r (0x0001d138 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_UC_CTL0.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_s {
	uint32_t v[1];
	uint32_t txfir_uc_ctl0[1];
	uint32_t _txfir_uc_ctl0;
} BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_t;

#define BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_CLR(r) (r).txfir_uc_ctl0[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_SET(r,d) (r).txfir_uc_ctl0[0] = d
#define BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_GET(r) (r).txfir_uc_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET(r) (((r).txfir_uc_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET(r,f) (r).txfir_uc_ctl0[0]=(((r).txfir_uc_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_UC_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_UC_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_UC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_UC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_UC_CTL0r,(_r._txfir_uc_ctl0))
#define BCMI_FALCON_XGXS_READLN_TXFIR_UC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_UC_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_uc_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_UC_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_UC_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_uc_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_UC_CTL0r BCMI_FALCON_XGXS_TXFIR_UC_CTL0r
#define TXFIR_UC_CTL0r_SIZE BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_t TXFIR_UC_CTL0r_t;
#define TXFIR_UC_CTL0r_CLR BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_CLR
#define TXFIR_UC_CTL0r_SET BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_SET
#define TXFIR_UC_CTL0r_GET BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_GET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_GET
#define TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET BCMI_FALCON_XGXS_TXFIR_UC_CTL0r_MICRO_TX_DISABLEf_SET
#define READ_TXFIR_UC_CTL0r BCMI_FALCON_XGXS_READ_TXFIR_UC_CTL0r
#define WRITE_TXFIR_UC_CTL0r BCMI_FALCON_XGXS_WRITE_TXFIR_UC_CTL0r
#define MODIFY_TXFIR_UC_CTL0r BCMI_FALCON_XGXS_MODIFY_TXFIR_UC_CTL0r
#define READLN_TXFIR_UC_CTL0r BCMI_FALCON_XGXS_READLN_TXFIR_UC_CTL0r
#define WRITELN_TXFIR_UC_CTL0r BCMI_FALCON_XGXS_WRITELN_TXFIR_UC_CTL0r
#define WRITEALL_TXFIR_UC_CTL0r BCMI_FALCON_XGXS_WRITEALL_TXFIR_UC_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_UC_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TXFIR_MISC_CTL1
 * BLOCKS:   TX_FED
 * REGADDR:  0xd139
 * DEVAD:    1
 * DESC:     Misc Control 1 Register
 * RESETVAL: 0x300 (768)
 * ACCESS:   R/W
 * FIELDS:
 *     SDK_TX_DISABLE   sdk tx disableThis tx disable control field is for SDK use during TX programmingPlease see Eagle & Merlin PMD Internal Functional Specification for details
 *     PMD_TX_DISABLE_PIN_DIS Tx disable using the pmd_tx_disable pin disable control0 - enable tx disable from pmd_tx_disable pin1 - disable tx disable from pmd_tx_disable pin
 *     TX_DISABLE_TIMER_CTRL tx_disable timer value controlstx_disable_timer_ctrl[5] (MSB) selects the timer units0 - 2us units1 - 1ms unitstx_disable_timer_ctrl[4:0] (LSB[4:0]) = controls the number of units perthe list below0                 0 units1                 1 units2                 2 units3                 3 units4                 4 units5                 5 units6                 6 units7                 7 units8                 8 units9                10 units10               12 units11               14 units12               16 units13               20 units14               24 units15               28 units16               32 units17               40 units18               48 units19               56 units20               64 units21               80 units22               96 units23              112 units24              128 units25              160 units26              192 units27              224 units28              256 units29              320 units30              384 units31              448 units
 *     TX_EEE_QUIET_EN  Tx eee quiet mode control1 - Enable eee quiet mode when pmd_tx_mode (input pins) == 2'b010 - Disable eee quiet mode
 *     TX_EEE_ALERT_EN  Tx eee alert mode control1 - Enable eee alert mode when pmd_tx_mode (input pins) == 2'b100 - Disable eee alert mode
 *     TX_DISABLE_OUTPUT_SEL These bits select tx disable output function2'b00 - send electrical idles2'b01 - send power down2'b10 - send ones2'b11 - send zeroes
 *     DP_RESET_TX_DISABLE_DIS Tx disable based on data path reset0 - Enable tx disable based on data path reset1 - Disable tx disable based on data path reset
 */
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r (0x0001d139 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TXFIR_MISC_CTL1.
 */
typedef union BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_s {
	uint32_t v[1];
	uint32_t txfir_misc_ctl1[1];
	uint32_t _txfir_misc_ctl1;
} BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_t;

#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_CLR(r) (r).txfir_misc_ctl1[0] = 0
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SET(r,d) (r).txfir_misc_ctl1[0] = d
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_GET(r) (r).txfir_misc_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 10) & 0x3)
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x3 << 10)) | ((((uint32_t)f) & 0x3) << 10)) | (3 << (16 + 10))
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 2) & 0x3f)
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x3f << 2)) | ((((uint32_t)f) & 0x3f) << 2)) | (63 << (16 + 2))
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_GET(r) ((((r).txfir_misc_ctl1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_GET(r) (((r).txfir_misc_ctl1[0]) & 0x1)
#define BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_SET(r,f) (r).txfir_misc_ctl1[0]=(((r).txfir_misc_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TXFIR_MISC_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_TXFIR_MISC_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r,(_r._txfir_misc_ctl1))
#define BCMI_FALCON_XGXS_WRITE_TXFIR_MISC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r,(_r._txfir_misc_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TXFIR_MISC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r,(_r._txfir_misc_ctl1))
#define BCMI_FALCON_XGXS_READLN_TXFIR_MISC_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_TXFIR_MISC_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._txfir_misc_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_TXFIR_MISC_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._txfir_misc_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TXFIR_MISC_CTL1r BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r
#define TXFIR_MISC_CTL1r_SIZE BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_t TXFIR_MISC_CTL1r_t;
#define TXFIR_MISC_CTL1r_CLR BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_CLR
#define TXFIR_MISC_CTL1r_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SET
#define TXFIR_MISC_CTL1r_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_GET
#define TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_GET
#define TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_DP_RESET_TX_DISABLE_DISf_SET
#define TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_GET
#define TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_OUTPUT_SELf_SET
#define TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_GET
#define TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_ALERT_ENf_SET
#define TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_GET
#define TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_EEE_QUIET_ENf_SET
#define TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_GET
#define TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_TX_DISABLE_TIMER_CTRLf_SET
#define TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_GET
#define TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_PMD_TX_DISABLE_PIN_DISf_SET
#define TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_GET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_GET
#define TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_SET BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r_SDK_TX_DISABLEf_SET
#define READ_TXFIR_MISC_CTL1r BCMI_FALCON_XGXS_READ_TXFIR_MISC_CTL1r
#define WRITE_TXFIR_MISC_CTL1r BCMI_FALCON_XGXS_WRITE_TXFIR_MISC_CTL1r
#define MODIFY_TXFIR_MISC_CTL1r BCMI_FALCON_XGXS_MODIFY_TXFIR_MISC_CTL1r
#define READLN_TXFIR_MISC_CTL1r BCMI_FALCON_XGXS_READLN_TXFIR_MISC_CTL1r
#define WRITELN_TXFIR_MISC_CTL1r BCMI_FALCON_XGXS_WRITELN_TXFIR_MISC_CTL1r
#define WRITEALL_TXFIR_MISC_CTL1r BCMI_FALCON_XGXS_WRITEALL_TXFIR_MISC_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TXFIR_MISC_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd140
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 0.
 * RESETVAL: 0xc803 (51203)
 * ACCESS:   R/W
 * FIELDS:
 *     VCO_STEP_TIME    VCO time between iterations
 *     VCO_START_TIME   VCO powerup wait time
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r (0x0001d140 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL0.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl0[1];
	uint32_t _pll_cal_ctl0;
} BCMI_FALCON_XGXS_PLL_CAL_CTL0r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_CLR(r) (r).pll_cal_ctl0[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_SET(r,d) (r).pll_cal_ctl0[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_GET(r) (r).pll_cal_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_GET(r) ((((r).pll_cal_ctl0[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET(r) (((r).pll_cal_ctl0[0]) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET(r,f) (r).pll_cal_ctl0[0]=(((r).pll_cal_ctl0[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL0r,(_r._pll_cal_ctl0))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL0r BCMI_FALCON_XGXS_PLL_CAL_CTL0r
#define PLL_CAL_CTL0r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL0r_t PLL_CAL_CTL0r_t;
#define PLL_CAL_CTL0r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL0r_CLR
#define PLL_CAL_CTL0r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL0r_SET
#define PLL_CAL_CTL0r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL0r_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_START_TIMEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_START_TIMEf_SET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_GET
#define PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL0r_VCO_STEP_TIMEf_SET
#define READ_PLL_CAL_CTL0r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL0r
#define WRITE_PLL_CAL_CTL0r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL0r
#define MODIFY_PLL_CAL_CTL0r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL0r
#define READLN_PLL_CAL_CTL0r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL0r
#define WRITELN_PLL_CAL_CTL0r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL0r
#define WRITEALL_PLL_CAL_CTL0r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd141
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 1.
 * RESETVAL: 0xc8ff (51455)
 * ACCESS:   R/W
 * FIELDS:
 *     RETRY_TIME       retry wait time
 *     PRE_FREQ_DET_TIME wait time prior to freq det
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r (0x0001d141 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL1.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl1[1];
	uint32_t _pll_cal_ctl1;
} BCMI_FALCON_XGXS_PLL_CAL_CTL1r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_CLR(r) (r).pll_cal_ctl1[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_SET(r,d) (r).pll_cal_ctl1[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_GET(r) (r).pll_cal_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET(r) ((((r).pll_cal_ctl1[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_GET(r) (((r).pll_cal_ctl1[0]) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_SET(r,f) (r).pll_cal_ctl1[0]=(((r).pll_cal_ctl1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL1r,(_r._pll_cal_ctl1))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL1r BCMI_FALCON_XGXS_PLL_CAL_CTL1r
#define PLL_CAL_CTL1r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL1r_t PLL_CAL_CTL1r_t;
#define PLL_CAL_CTL1r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL1r_CLR
#define PLL_CAL_CTL1r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL1r_SET
#define PLL_CAL_CTL1r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL1r_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_GET
#define PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL1r_PRE_FREQ_DET_TIMEf_SET
#define PLL_CAL_CTL1r_RETRY_TIMEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_GET
#define PLL_CAL_CTL1r_RETRY_TIMEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL1r_RETRY_TIMEf_SET
#define READ_PLL_CAL_CTL1r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL1r
#define WRITE_PLL_CAL_CTL1r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL1r
#define MODIFY_PLL_CAL_CTL1r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL1r
#define READLN_PLL_CAL_CTL1r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL1r
#define WRITELN_PLL_CAL_CTL1r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL1r
#define WRITEALL_PLL_CAL_CTL1r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL2
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd142
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 2.
 * RESETVAL: 0xff01 (65281)
 * ACCESS:   R/W
 * FIELDS:
 *     WIN_CAL_CNTR     freq. counter's 8-lsbits stoping value
 *     RES_CAL_CNTR     freq. counter's 8-msbits starting value
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r (0x0001d142 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL2.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL2r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl2[1];
	uint32_t _pll_cal_ctl2;
} BCMI_FALCON_XGXS_PLL_CAL_CTL2r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_CLR(r) (r).pll_cal_ctl2[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_SET(r,d) (r).pll_cal_ctl2[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_GET(r) (r).pll_cal_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET(r) ((((r).pll_cal_ctl2[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET(r) (((r).pll_cal_ctl2[0]) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET(r,f) (r).pll_cal_ctl2[0]=(((r).pll_cal_ctl2[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL2r,(_r._pll_cal_ctl2))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL2r BCMI_FALCON_XGXS_PLL_CAL_CTL2r
#define PLL_CAL_CTL2r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL2r_t PLL_CAL_CTL2r_t;
#define PLL_CAL_CTL2r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL2r_CLR
#define PLL_CAL_CTL2r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL2r_SET
#define PLL_CAL_CTL2r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL2r_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_RES_CAL_CNTRf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL2r_RES_CAL_CNTRf_SET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_GET
#define PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL2r_WIN_CAL_CNTRf_SET
#define READ_PLL_CAL_CTL2r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL2r
#define WRITE_PLL_CAL_CTL2r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL2r
#define MODIFY_PLL_CAL_CTL2r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL2r
#define READLN_PLL_CAL_CTL2r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL2r
#define WRITELN_PLL_CAL_CTL2r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL2r
#define WRITEALL_PLL_CAL_CTL2r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL3
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd143
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 3.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     FAST_SEARCH_MODE force cap sequencer using select_m value for fast searching
 *     CAP_CNT_MASK_EN  masks cap count to allow control of max value
 *     CAP_SEQ_CYA      cya bit to revert cap sequencer back to original hyper/xaui sequence
 *     CAP_RESTART      force cap sequencer to restart, set to high then low
 *     CAP_RETRY_EN     enable retry on cap search failure
 *     CAP_FORCE_SLOWDOWN slowdown force value
 *     CAP_FORCE_SLOWDOWN_EN slowdown force enable
 *     CAP_SELECT_M_EN  Manual vco cap value mode, force using pll_range force value
 *     CAP_SELECT_M     Manual vco cap value (i.e pll_range[7:0])
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r (0x0001d143 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL3.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL3r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl3[1];
	uint32_t _pll_cal_ctl3;
} BCMI_FALCON_XGXS_PLL_CAL_CTL3r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CLR(r) (r).pll_cal_ctl3[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_SET(r,d) (r).pll_cal_ctl3[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_GET(r) (r).pll_cal_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET(r) ((((r).pll_cal_ctl3[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET(r) ((((r).pll_cal_ctl3[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_GET(r) ((((r).pll_cal_ctl3[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET(r) ((((r).pll_cal_ctl3[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET(r) ((((r).pll_cal_ctl3[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET(r) (((r).pll_cal_ctl3[0]) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET(r,f) (r).pll_cal_ctl3[0]=(((r).pll_cal_ctl3[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL3r,(_r._pll_cal_ctl3))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL3r BCMI_FALCON_XGXS_PLL_CAL_CTL3r
#define PLL_CAL_CTL3r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL3r_t PLL_CAL_CTL3r_t;
#define PLL_CAL_CTL3r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CLR
#define PLL_CAL_CTL3r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_SET
#define PLL_CAL_CTL3r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_Mf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_Mf_SET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_GET
#define PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SELECT_M_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWN_ENf_SET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_GET
#define PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_FORCE_SLOWDOWNf_SET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_GET
#define PLL_CAL_CTL3r_CAP_RETRY_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RETRY_ENf_SET
#define PLL_CAL_CTL3r_CAP_RESTARTf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_GET
#define PLL_CAL_CTL3r_CAP_RESTARTf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_RESTARTf_SET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_GET
#define PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_SEQ_CYAf_SET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_GET
#define PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_CAP_CNT_MASK_ENf_SET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_GET
#define PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL3r_FAST_SEARCH_MODEf_SET
#define READ_PLL_CAL_CTL3r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL3r
#define WRITE_PLL_CAL_CTL3r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL3r
#define MODIFY_PLL_CAL_CTL3r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL3r
#define READLN_PLL_CAL_CTL3r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL3r
#define WRITELN_PLL_CAL_CTL3r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL3r
#define WRITEALL_PLL_CAL_CTL3r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL4
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd144
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 4.
 * RESETVAL: 0xa80d (43021)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_LOCK_FRC_VAL force pll lock value
 *     PLL_LOCK_FRC     force pll lock
 *     PLL_FORCE_CAP_PASS force cappass
 *     PLL_FORCE_CAP_PASS_EN enable pllforcecappass
 *     PLL_FORCE_CAP_DONE force capdone
 *     PLL_FORCE_CAP_DONE_EN enable pllforcecapdone
 *     PLL_FORCE_FPASS  force freqpass
 *     PLL_FORCE_FDONE  force freqdone
 *     PLL_FORCE_FDONE_EN enable pllforcefdone & pllforcefpass into pllseq
 *     VCO_RST_EN       enable pll reset when state machine is in start state. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 *     SLOWDN_XOR       invert sense of the slowdn/pll_low input from AFE
 *     FREQ_MONITOR_EN  continuously monitor vco freq
 *     FREQ_DET_RESTART_EN enable restart when not freq locked
 *     FREQ_DET_RETRY_EN enable retry on freq det failure
 *     VCO_DONE_EN      enable vco_done status bit
 *     PLL_SEQ_START    start pll sequencer by writing to 1'b0 followed by writing to 1'b1. For debug only, use core_dp_s/h_rstb to restart PLL calibration
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r (0x0001d144 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL4.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL4r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl4[1];
	uint32_t _pll_cal_ctl4;
} BCMI_FALCON_XGXS_PLL_CAL_CTL4r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_CLR(r) (r).pll_cal_ctl4[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SET(r,d) (r).pll_cal_ctl4[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_GET(r) (r).pll_cal_ctl4[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET(r) ((((r).pll_cal_ctl4[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_GET(r) ((((r).pll_cal_ctl4[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET(r) ((((r).pll_cal_ctl4[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET(r) ((((r).pll_cal_ctl4[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET(r) ((((r).pll_cal_ctl4[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET(r) ((((r).pll_cal_ctl4[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET(r) (((r).pll_cal_ctl4[0]) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET(r,f) (r).pll_cal_ctl4[0]=(((r).pll_cal_ctl4[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL4.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL4r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL4r,(_r._pll_cal_ctl4))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL4r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl4))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL4r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl4))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL4r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL4r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl4))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL4r BCMI_FALCON_XGXS_PLL_CAL_CTL4r
#define PLL_CAL_CTL4r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL4r_t PLL_CAL_CTL4r_t;
#define PLL_CAL_CTL4r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL4r_CLR
#define PLL_CAL_CTL4r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SET
#define PLL_CAL_CTL4r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_GET
#define PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_SEQ_STARTf_SET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_GET
#define PLL_CAL_CTL4r_VCO_DONE_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_DONE_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RETRY_ENf_SET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_GET
#define PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_DET_RESTART_ENf_SET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_GET
#define PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_FREQ_MONITOR_ENf_SET
#define PLL_CAL_CTL4r_SLOWDN_XORf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_GET
#define PLL_CAL_CTL4r_SLOWDN_XORf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_SLOWDN_XORf_SET
#define PLL_CAL_CTL4r_VCO_RST_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_GET
#define PLL_CAL_CTL4r_VCO_RST_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_VCO_RST_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FDONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_FPASSf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONE_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_DONEf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASS_ENf_SET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_GET
#define PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_FORCE_CAP_PASSf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRCf_SET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_GET
#define PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL4r_PLL_LOCK_FRC_VALf_SET
#define READ_PLL_CAL_CTL4r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL4r
#define WRITE_PLL_CAL_CTL4r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL4r
#define MODIFY_PLL_CAL_CTL4r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL4r
#define READLN_PLL_CAL_CTL4r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL4r
#define WRITELN_PLL_CAL_CTL4r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL4r
#define WRITEALL_PLL_CAL_CTL4r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL4r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL4r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL5
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd145
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 5.
 * RESETVAL: 0x27 (39)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_DIVCNT    Refclk Divider Count to generate 25 Khz clock enable (40 us period apart) for PLL control logic.   change dfs from 0x186A to 0x27 (decimal 39) for faster pll lock time
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL5r (0x0001d145 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL5r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL5.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL5r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl5[1];
	uint32_t _pll_cal_ctl5;
} BCMI_FALCON_XGXS_PLL_CAL_CTL5r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL5r_CLR(r) (r).pll_cal_ctl5[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL5r_SET(r,d) (r).pll_cal_ctl5[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL5r_GET(r) (r).pll_cal_ctl5[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET(r) (((r).pll_cal_ctl5[0]) & 0x3fff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET(r,f) (r).pll_cal_ctl5[0]=(((r).pll_cal_ctl5[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL5.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL5r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL5r,(_r._pll_cal_ctl5))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL5r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl5))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL5r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl5))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL5r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL5r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl5))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL5r BCMI_FALCON_XGXS_PLL_CAL_CTL5r
#define PLL_CAL_CTL5r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL5r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL5r_t PLL_CAL_CTL5r_t;
#define PLL_CAL_CTL5r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL5r_CLR
#define PLL_CAL_CTL5r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL5r_SET
#define PLL_CAL_CTL5r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL5r_GET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_GET
#define PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL5r_REFCLK_DIVCNTf_SET
#define READ_PLL_CAL_CTL5r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL5r
#define WRITE_PLL_CAL_CTL5r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL5r
#define MODIFY_PLL_CAL_CTL5r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL5r
#define READLN_PLL_CAL_CTL5r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL5r
#define WRITELN_PLL_CAL_CTL5r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL5r
#define WRITEALL_PLL_CAL_CTL5r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL5r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL5r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL6
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd146
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 6.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     REFCLK_DIVCNT_SEL Refclk Divider Mode Select.refclk      refclk_divcnt value to generate 25 Khz signal   refclk_divcnt_sel[2:0]----------------------------------------------------------------------------------390.625 Mhz               15625                             3'd0161.1328185 Mhz           6445.31274 = ~6445                3'd1156.25 Mhz                6250                              3'd2   (default)125.00 Mhz                5000                              3'd3106.25 Mhz                4250                              3'd478.125 Mhz                3125                              3'd5-                         -                                 3'd6   (rsvd for future use)-                         refclk_divcnt[13:0]               3'd7   (programmable with max value of 16383)defaulted to 0x7 for faster pll lock time (0x2 before)
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL6r (0x0001d146 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL6r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL6.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL6r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl6[1];
	uint32_t _pll_cal_ctl6;
} BCMI_FALCON_XGXS_PLL_CAL_CTL6r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL6r_CLR(r) (r).pll_cal_ctl6[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL6r_SET(r,d) (r).pll_cal_ctl6[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL6r_GET(r) (r).pll_cal_ctl6[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET(r) (((r).pll_cal_ctl6[0]) & 0x7)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET(r,f) (r).pll_cal_ctl6[0]=(((r).pll_cal_ctl6[0] & ~((uint32_t)0x7)) | (((uint32_t)f) & 0x7)) | (0x7 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL6.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL6r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL6r,(_r._pll_cal_ctl6))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL6r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl6))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL6r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl6))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL6r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL6r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl6))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL6r BCMI_FALCON_XGXS_PLL_CAL_CTL6r
#define PLL_CAL_CTL6r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL6r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL6r_t PLL_CAL_CTL6r_t;
#define PLL_CAL_CTL6r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL6r_CLR
#define PLL_CAL_CTL6r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL6r_SET
#define PLL_CAL_CTL6r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL6r_GET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_GET
#define PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL6r_REFCLK_DIVCNT_SELf_SET
#define READ_PLL_CAL_CTL6r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL6r
#define WRITE_PLL_CAL_CTL6r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL6r
#define MODIFY_PLL_CAL_CTL6r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL6r
#define READLN_PLL_CAL_CTL6r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL6r
#define WRITELN_PLL_CAL_CTL6r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL6r
#define WRITEALL_PLL_CAL_CTL6r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL6r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL6r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL7
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd147
 * DEVAD:    1
 * DESC:     PLL CAL Configuration Registers 7.
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     PLL_MODE         PLL Multiplier.0000  = 64;0001  = 66;0010  = 80;0011  = 128;0100  = 132;0101  = 140;0110  = 160;0111  = 165;1000  = 168;1001  = 170;1010  = 175;1011  = 180;1100  = 184;1101  = 200;1110  = 224;1111  = 264;
 *     RESCAL_FRC_VAL   rescal force value.
 *     RESCAL_FRC       rescal force to use rescal force value.
 *     VCO_RANGE_ADJUST signed 2's complement by firmware for current temperature
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r (0x0001d147 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL7.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL7r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl7[1];
	uint32_t _pll_cal_ctl7;
} BCMI_FALCON_XGXS_PLL_CAL_CTL7r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_CLR(r) (r).pll_cal_ctl7[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_SET(r,d) (r).pll_cal_ctl7[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_GET(r) (r).pll_cal_ctl7[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_GET(r) ((((r).pll_cal_ctl7[0]) >> 9) & 0x1f)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1f << 9)) | ((((uint32_t)f) & 0x1f) << 9)) | (31 << (16 + 9))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET(r) ((((r).pll_cal_ctl7[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET(r) ((((r).pll_cal_ctl7[0]) >> 4) & 0xf)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0xf << 4)) | ((((uint32_t)f) & 0xf) << 4)) | (15 << (16 + 4))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET(r) (((r).pll_cal_ctl7[0]) & 0xf)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET(r,f) (r).pll_cal_ctl7[0]=(((r).pll_cal_ctl7[0] & ~((uint32_t)0xf)) | (((uint32_t)f) & 0xf)) | (0xf << 16)

/*
 * These macros can be used to access PLL_CAL_CTL7.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL7r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL7r,(_r._pll_cal_ctl7))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL7r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL7r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl7))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL7r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL7r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl7))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL7r BCMI_FALCON_XGXS_PLL_CAL_CTL7r
#define PLL_CAL_CTL7r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL7r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL7r_t PLL_CAL_CTL7r_t;
#define PLL_CAL_CTL7r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL7r_CLR
#define PLL_CAL_CTL7r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_SET
#define PLL_CAL_CTL7r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_GET
#define PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_GET
#define PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_VCO_RANGE_ADJUSTf_SET
#define PLL_CAL_CTL7r_RESCAL_FRCf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_GET
#define PLL_CAL_CTL7r_RESCAL_FRCf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRCf_SET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_GET
#define PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_RESCAL_FRC_VALf_SET
#define PLL_CAL_CTL7r_PLL_MODEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_PLL_MODEf_GET
#define PLL_CAL_CTL7r_PLL_MODEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL7r_PLL_MODEf_SET
#define READ_PLL_CAL_CTL7r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL7r
#define WRITE_PLL_CAL_CTL7r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL7r
#define MODIFY_PLL_CAL_CTL7r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL7r
#define READLN_PLL_CAL_CTL7r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL7r
#define WRITELN_PLL_CAL_CTL7r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL7r
#define WRITEALL_PLL_CAL_CTL7r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL7r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL7r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL_STS0
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd148
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PLL_LOCK_LH_LL   indicates change on pll_lock status bit. It is clear on read status register
 *     PLL_SEQ_PASS_LH_LL indicates change on pll_seq_pass status bit. It is clear on read status register
 *     PLL_SEQ_DONE_LH_LL indicates change on pll_seq_done status bit. It is clear on read status register
 *     FREQ_PASS_SM_LH_LL indicates change on freq_pass_sm status bit. It is clear on read status register
 *     FREQ_DONE_SM_LH_LL indicates change on freq_done_sm status bit. It is clear on read status register
 *     CAP_PASS_LH_LL   indicates change on cap_pass status bit. It is clear on read status register
 *     CAP_DONE_LH_LL   indicates change on cap_done status bit. It is clear on read status register
 *     PLL_LOCK         status bit indicating PLL is locked
 *     PLL_SEQ_PASS     status bit indicating pll sequencer finised successfully
 *     PLL_SEQ_DONE     status bit indicating pll sequencer is done
 *     FREQ_PASS_SM     status bit indicating frequency lock
 *     FREQ_DONE_SM     status bit indicating freq det is done
 *     CAP_PASS         status indicating cap value was found
 *     CAP_DONE         status indicating cap sequencer is done
 *     LOST_PLL_LOCK_SM status bit indicating pll_lock was lost, clear on read
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r (0x0001d148 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS0.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts0[1];
	uint32_t _pll_cal_ctl_sts0;
} BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CLR(r) (r).pll_cal_ctl_sts0[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_SET(r,d) (r).pll_cal_ctl_sts0[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_GET(r) (r).pll_cal_ctl_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET(r) ((((r).pll_cal_ctl_sts0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET(r) (((r).pll_cal_ctl_sts0[0]) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET(r,f) (r).pll_cal_ctl_sts0[0]=(((r).pll_cal_ctl_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS0.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r,(_r._pll_cal_ctl_sts0))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS0r BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r
#define PLL_CAL_CTL_STS0r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_t PLL_CAL_CTL_STS0r_t;
#define PLL_CAL_CTL_STS0r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CLR
#define PLL_CAL_CTL_STS0r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_SET
#define PLL_CAL_CTL_STS0r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_GET
#define PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_LOST_PLL_LOCK_SMf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONEf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASSf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASSf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SMf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SMf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONEf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASSf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCKf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCKf_SET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_CAP_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_DONE_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_FREQ_PASS_SM_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_DONE_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_SEQ_PASS_LH_LLf_SET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_GET
#define PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r_PLL_LOCK_LH_LLf_SET
#define READ_PLL_CAL_CTL_STS0r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL_STS0r
#define WRITE_PLL_CAL_CTL_STS0r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL_STS0r
#define MODIFY_PLL_CAL_CTL_STS0r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL_STS0r
#define READLN_PLL_CAL_CTL_STS0r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL_STS0r
#define WRITELN_PLL_CAL_CTL_STS0r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL_STS0r
#define WRITEALL_PLL_CAL_CTL_STS0r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL_STS1
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd149
 * DEVAD:    1
 * DESC:     PLL CAL status registers register.
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     CAP_SELECT       status bit indicating the selected cap value (i.e. pll_range[7:0])
 *     RESCAL_IN        rescal input value
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r (0x0001d149 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS1.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts1[1];
	uint32_t _pll_cal_ctl_sts1;
} BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_CLR(r) (r).pll_cal_ctl_sts1[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_SET(r,d) (r).pll_cal_ctl_sts1[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_GET(r) (r).pll_cal_ctl_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_GET(r) ((((r).pll_cal_ctl_sts1[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET(r) (((r).pll_cal_ctl_sts1[0]) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET(r,f) (r).pll_cal_ctl_sts1[0]=(((r).pll_cal_ctl_sts1[0] & ~((uint32_t)0xff)) | (((uint32_t)f) & 0xff)) | (0xff << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS1.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r,(_r._pll_cal_ctl_sts1))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts1))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts1))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS1r BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r
#define PLL_CAL_CTL_STS1r_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_t PLL_CAL_CTL_STS1r_t;
#define PLL_CAL_CTL_STS1r_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_CLR
#define PLL_CAL_CTL_STS1r_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_SET
#define PLL_CAL_CTL_STS1r_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_GET
#define PLL_CAL_CTL_STS1r_RESCAL_INf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_RESCAL_INf_SET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_GET
#define PLL_CAL_CTL_STS1r_CAP_SELECTf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r_CAP_SELECTf_SET
#define READ_PLL_CAL_CTL_STS1r BCMI_FALCON_XGXS_READ_PLL_CAL_CTL_STS1r
#define WRITE_PLL_CAL_CTL_STS1r BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL_STS1r
#define MODIFY_PLL_CAL_CTL_STS1r BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL_STS1r
#define READLN_PLL_CAL_CTL_STS1r BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL_STS1r
#define WRITELN_PLL_CAL_CTL_STS1r BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL_STS1r
#define WRITEALL_PLL_CAL_CTL_STS1r BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  PLL_CAL_CTL_STS_DBG
 * BLOCKS:   PLL_CAL_COM
 * REGADDR:  0xd14a
 * DEVAD:    1
 * DESC:     PLL CAL debug status registers register.
 * RESETVAL: 0x1 (1)
 * ACCESS:   R/O
 * FIELDS:
 *     DBG_SLOWDN       Indicates AFE pll_low/slowdn output signal status.
 *     DBG_SLOWDN_CHANGE Indicates change on AFE pll_low/slowdn output signal. It is clear on read status register
 *     DBG_FDBCK        Indicates change on AFE fdbck output signal. clear on read status register.Will be used to see if fdbck clock from AFE is toggling and alive
 *     DBG_CAP_STATE_ONE_HOT Indicates one hot encoded Cap Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State    dbg_cap_state_one_hot[x] where x is :==================================================Start          0WaitAmpL       1WaitSpeedL     2IncCapL        3Finish         4
 *     DBG_PLL_STATE_ONE_HOT Indicates one hot encoded PLL Sequence State Machines states. clear on read register.Following are the one-hot state assignments.State   dbg_pll_state_one_hot[x] where x is :==============================================Start          0WaitVco        1VcoAdjust      2WaitFreq       3FreqDet        4Fail           5FreqMon        6Finish         7
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr (0x0001d14a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_SIZE 4

/*
 * This structure should be used to declare and program PLL_CAL_CTL_STS_DBG.
 */
typedef union BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_s {
	uint32_t v[1];
	uint32_t pll_cal_ctl_sts_dbg[1];
	uint32_t _pll_cal_ctl_sts_dbg;
} BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_t;

#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_CLR(r) (r).pll_cal_ctl_sts_dbg[0] = 0
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_SET(r,d) (r).pll_cal_ctl_sts_dbg[0] = d
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_GET(r) (r).pll_cal_ctl_sts_dbg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 8) & 0xff)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0xff << 8)) | ((((uint32_t)f) & 0xff) << 8)) | (255 << (16 + 8))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 3) & 0x1f)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1f << 3)) | ((((uint32_t)f) & 0x1f) << 3)) | (31 << (16 + 3))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET(r) ((((r).pll_cal_ctl_sts_dbg[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET(r) (((r).pll_cal_ctl_sts_dbg[0]) & 0x1)
#define BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET(r,f) (r).pll_cal_ctl_sts_dbg[0]=(((r).pll_cal_ctl_sts_dbg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access PLL_CAL_CTL_STS_DBG.
 */
#define BCMI_FALCON_XGXS_READ_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg))
#define BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr,(_r._pll_cal_ctl_sts_dbg))
#define BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL_STS_DBGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts_dbg))
#define BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL_STS_DBGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._pll_cal_ctl_sts_dbg))
#define BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL_STS_DBGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._pll_cal_ctl_sts_dbg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define PLL_CAL_CTL_STS_DBGr BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr
#define PLL_CAL_CTL_STS_DBGr_SIZE BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_SIZE
typedef BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_t PLL_CAL_CTL_STS_DBGr_t;
#define PLL_CAL_CTL_STS_DBGr_CLR BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_CLR
#define PLL_CAL_CTL_STS_DBGr_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_SET
#define PLL_CAL_CTL_STS_DBGr_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_PLL_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_CAP_STATE_ONE_HOTf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_FDBCKf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDN_CHANGEf_SET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_GET
#define PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr_DBG_SLOWDNf_SET
#define READ_PLL_CAL_CTL_STS_DBGr BCMI_FALCON_XGXS_READ_PLL_CAL_CTL_STS_DBGr
#define WRITE_PLL_CAL_CTL_STS_DBGr BCMI_FALCON_XGXS_WRITE_PLL_CAL_CTL_STS_DBGr
#define MODIFY_PLL_CAL_CTL_STS_DBGr BCMI_FALCON_XGXS_MODIFY_PLL_CAL_CTL_STS_DBGr
#define READLN_PLL_CAL_CTL_STS_DBGr BCMI_FALCON_XGXS_READLN_PLL_CAL_CTL_STS_DBGr
#define WRITELN_PLL_CAL_CTL_STS_DBGr BCMI_FALCON_XGXS_WRITELN_PLL_CAL_CTL_STS_DBGr
#define WRITEALL_PLL_CAL_CTL_STS_DBGr BCMI_FALCON_XGXS_WRITEALL_PLL_CAL_CTL_STS_DBGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_PLL_CAL_CTL_STS_DBGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_CTL0
 * BLOCKS:   TX_COM
 * REGADDR:  0xd150
 * DEVAD:    1
 * DESC:     TX common control 0 register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_POST_TAP_ALERT_VAL txfir post tap value during EEE alert mode
 *     TXCOM_PRE_TAP_ALERT_VAL txfir pre tap value during EEE alert mode
 */
#define BCMI_FALCON_XGXS_TX_CTL0r (0x0001d150 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL0.
 */
typedef union BCMI_FALCON_XGXS_TX_CTL0r_s {
	uint32_t v[1];
	uint32_t tx_ctl0[1];
	uint32_t _tx_ctl0;
} BCMI_FALCON_XGXS_TX_CTL0r_t;

#define BCMI_FALCON_XGXS_TX_CTL0r_CLR(r) (r).tx_ctl0[0] = 0
#define BCMI_FALCON_XGXS_TX_CTL0r_SET(r,d) (r).tx_ctl0[0] = d
#define BCMI_FALCON_XGXS_TX_CTL0r_GET(r) (r).tx_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_GET(r) ((((r).tx_ctl0[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_POST_TAP_ALERT_VALf_GET(r) (((r).tx_ctl0[0]) & 0x3f)
#define BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_POST_TAP_ALERT_VALf_SET(r,f) (r).tx_ctl0[0]=(((r).tx_ctl0[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TX_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_TX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL0r,(_r._tx_ctl0))
#define BCMI_FALCON_XGXS_WRITE_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL0r,(_r._tx_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL0r,(_r._tx_ctl0))
#define BCMI_FALCON_XGXS_READLN_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_TX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_TX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL0r BCMI_FALCON_XGXS_TX_CTL0r
#define TX_CTL0r_SIZE BCMI_FALCON_XGXS_TX_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_TX_CTL0r_t TX_CTL0r_t;
#define TX_CTL0r_CLR BCMI_FALCON_XGXS_TX_CTL0r_CLR
#define TX_CTL0r_SET BCMI_FALCON_XGXS_TX_CTL0r_SET
#define TX_CTL0r_GET BCMI_FALCON_XGXS_TX_CTL0r_GET
#define TX_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_GET BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_GET
#define TX_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_SET BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_PRE_TAP_ALERT_VALf_SET
#define TX_CTL0r_TXCOM_POST_TAP_ALERT_VALf_GET BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_POST_TAP_ALERT_VALf_GET
#define TX_CTL0r_TXCOM_POST_TAP_ALERT_VALf_SET BCMI_FALCON_XGXS_TX_CTL0r_TXCOM_POST_TAP_ALERT_VALf_SET
#define READ_TX_CTL0r BCMI_FALCON_XGXS_READ_TX_CTL0r
#define WRITE_TX_CTL0r BCMI_FALCON_XGXS_WRITE_TX_CTL0r
#define MODIFY_TX_CTL0r BCMI_FALCON_XGXS_MODIFY_TX_CTL0r
#define READLN_TX_CTL0r BCMI_FALCON_XGXS_READLN_TX_CTL0r
#define WRITELN_TX_CTL0r BCMI_FALCON_XGXS_WRITELN_TX_CTL0r
#define WRITEALL_TX_CTL0r BCMI_FALCON_XGXS_WRITEALL_TX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_CTL1
 * BLOCKS:   TX_COM
 * REGADDR:  0xd151
 * DEVAD:    1
 * DESC:     TX common control 1 register
 * RESETVAL: 0x70 (112)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_MAIN_TAP_ALERT_VAL txfir main tap value during EEE alert mode
 */
#define BCMI_FALCON_XGXS_TX_CTL1r (0x0001d151 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL1.
 */
typedef union BCMI_FALCON_XGXS_TX_CTL1r_s {
	uint32_t v[1];
	uint32_t tx_ctl1[1];
	uint32_t _tx_ctl1;
} BCMI_FALCON_XGXS_TX_CTL1r_t;

#define BCMI_FALCON_XGXS_TX_CTL1r_CLR(r) (r).tx_ctl1[0] = 0
#define BCMI_FALCON_XGXS_TX_CTL1r_SET(r,d) (r).tx_ctl1[0] = d
#define BCMI_FALCON_XGXS_TX_CTL1r_GET(r) (r).tx_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_GET(r) (((r).tx_ctl1[0]) & 0x7f)
#define BCMI_FALCON_XGXS_TX_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_SET(r,f) (r).tx_ctl1[0]=(((r).tx_ctl1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access TX_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_TX_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL1r,(_r._tx_ctl1))
#define BCMI_FALCON_XGXS_WRITE_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL1r,(_r._tx_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL1r,(_r._tx_ctl1))
#define BCMI_FALCON_XGXS_READLN_TX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_TX_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_TX_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL1r BCMI_FALCON_XGXS_TX_CTL1r
#define TX_CTL1r_SIZE BCMI_FALCON_XGXS_TX_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_TX_CTL1r_t TX_CTL1r_t;
#define TX_CTL1r_CLR BCMI_FALCON_XGXS_TX_CTL1r_CLR
#define TX_CTL1r_SET BCMI_FALCON_XGXS_TX_CTL1r_SET
#define TX_CTL1r_GET BCMI_FALCON_XGXS_TX_CTL1r_GET
#define TX_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_GET BCMI_FALCON_XGXS_TX_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_GET
#define TX_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_SET BCMI_FALCON_XGXS_TX_CTL1r_TXCOM_MAIN_TAP_ALERT_VALf_SET
#define READ_TX_CTL1r BCMI_FALCON_XGXS_READ_TX_CTL1r
#define WRITE_TX_CTL1r BCMI_FALCON_XGXS_WRITE_TX_CTL1r
#define MODIFY_TX_CTL1r BCMI_FALCON_XGXS_MODIFY_TX_CTL1r
#define READLN_TX_CTL1r BCMI_FALCON_XGXS_READLN_TX_CTL1r
#define WRITELN_TX_CTL1r BCMI_FALCON_XGXS_WRITELN_TX_CTL1r
#define WRITEALL_TX_CTL1r BCMI_FALCON_XGXS_WRITEALL_TX_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_CTL2
 * BLOCKS:   TX_COM
 * REGADDR:  0xd152
 * DEVAD:    1
 * DESC:     TX common control 2 register
 * RESETVAL: 0x1f4 (500)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL93N72_MAX_WAIT_TIMER_PERIOD Maximum Training Time in msPeriod/range is 500 ms
 */
#define BCMI_FALCON_XGXS_TX_CTL2r (0x0001d152 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_CTL2r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL2.
 */
typedef union BCMI_FALCON_XGXS_TX_CTL2r_s {
	uint32_t v[1];
	uint32_t tx_ctl2[1];
	uint32_t _tx_ctl2;
} BCMI_FALCON_XGXS_TX_CTL2r_t;

#define BCMI_FALCON_XGXS_TX_CTL2r_CLR(r) (r).tx_ctl2[0] = 0
#define BCMI_FALCON_XGXS_TX_CTL2r_SET(r,d) (r).tx_ctl2[0] = d
#define BCMI_FALCON_XGXS_TX_CTL2r_GET(r) (r).tx_ctl2[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_GET(r) (((r).tx_ctl2[0]) & 0xffff)
#define BCMI_FALCON_XGXS_TX_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_SET(r,f) (r).tx_ctl2[0]=(((r).tx_ctl2[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TX_CTL2.
 */
#define BCMI_FALCON_XGXS_READ_TX_CTL2r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL2r,(_r._tx_ctl2))
#define BCMI_FALCON_XGXS_WRITE_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL2r,(_r._tx_ctl2)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL2r,(_r._tx_ctl2))
#define BCMI_FALCON_XGXS_READLN_TX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl2))
#define BCMI_FALCON_XGXS_WRITELN_TX_CTL2r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl2))
#define BCMI_FALCON_XGXS_WRITEALL_TX_CTL2r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL2r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl2))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL2r BCMI_FALCON_XGXS_TX_CTL2r
#define TX_CTL2r_SIZE BCMI_FALCON_XGXS_TX_CTL2r_SIZE
typedef BCMI_FALCON_XGXS_TX_CTL2r_t TX_CTL2r_t;
#define TX_CTL2r_CLR BCMI_FALCON_XGXS_TX_CTL2r_CLR
#define TX_CTL2r_SET BCMI_FALCON_XGXS_TX_CTL2r_SET
#define TX_CTL2r_GET BCMI_FALCON_XGXS_TX_CTL2r_GET
#define TX_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_GET BCMI_FALCON_XGXS_TX_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_GET
#define TX_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_SET BCMI_FALCON_XGXS_TX_CTL2r_TXCOM_CL93N72_MAX_WAIT_TIMER_PERIODf_SET
#define READ_TX_CTL2r BCMI_FALCON_XGXS_READ_TX_CTL2r
#define WRITE_TX_CTL2r BCMI_FALCON_XGXS_WRITE_TX_CTL2r
#define MODIFY_TX_CTL2r BCMI_FALCON_XGXS_MODIFY_TX_CTL2r
#define READLN_TX_CTL2r BCMI_FALCON_XGXS_READLN_TX_CTL2r
#define WRITELN_TX_CTL2r BCMI_FALCON_XGXS_WRITELN_TX_CTL2r
#define WRITEALL_TX_CTL2r BCMI_FALCON_XGXS_WRITEALL_TX_CTL2r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_CTL2r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TX_CTL3
 * BLOCKS:   TX_COM
 * REGADDR:  0xd153
 * DEVAD:    1
 * DESC:     TX common control 3 register
 * RESETVAL: 0xc8 (200)
 * ACCESS:   R/W
 * FIELDS:
 *     TXCOM_CL93N72_WAIT_CNTR_LIMIT Period/range is 100-300 framesPeriod to keep transiming frames after the local device has completed trainingThe units are training pages.
 */
#define BCMI_FALCON_XGXS_TX_CTL3r (0x0001d153 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TX_CTL3r_SIZE 4

/*
 * This structure should be used to declare and program TX_CTL3.
 */
typedef union BCMI_FALCON_XGXS_TX_CTL3r_s {
	uint32_t v[1];
	uint32_t tx_ctl3[1];
	uint32_t _tx_ctl3;
} BCMI_FALCON_XGXS_TX_CTL3r_t;

#define BCMI_FALCON_XGXS_TX_CTL3r_CLR(r) (r).tx_ctl3[0] = 0
#define BCMI_FALCON_XGXS_TX_CTL3r_SET(r,d) (r).tx_ctl3[0] = d
#define BCMI_FALCON_XGXS_TX_CTL3r_GET(r) (r).tx_ctl3[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TX_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_GET(r) (((r).tx_ctl3[0]) & 0x1ff)
#define BCMI_FALCON_XGXS_TX_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_SET(r,f) (r).tx_ctl3[0]=(((r).tx_ctl3[0] & ~((uint32_t)0x1ff)) | (((uint32_t)f) & 0x1ff)) | (0x1ff << 16)

/*
 * These macros can be used to access TX_CTL3.
 */
#define BCMI_FALCON_XGXS_READ_TX_CTL3r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL3r,(_r._tx_ctl3))
#define BCMI_FALCON_XGXS_WRITE_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL3r,(_r._tx_ctl3)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL3r,(_r._tx_ctl3))
#define BCMI_FALCON_XGXS_READLN_TX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl3))
#define BCMI_FALCON_XGXS_WRITELN_TX_CTL3r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tx_ctl3))
#define BCMI_FALCON_XGXS_WRITEALL_TX_CTL3r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TX_CTL3r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tx_ctl3))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TX_CTL3r BCMI_FALCON_XGXS_TX_CTL3r
#define TX_CTL3r_SIZE BCMI_FALCON_XGXS_TX_CTL3r_SIZE
typedef BCMI_FALCON_XGXS_TX_CTL3r_t TX_CTL3r_t;
#define TX_CTL3r_CLR BCMI_FALCON_XGXS_TX_CTL3r_CLR
#define TX_CTL3r_SET BCMI_FALCON_XGXS_TX_CTL3r_SET
#define TX_CTL3r_GET BCMI_FALCON_XGXS_TX_CTL3r_GET
#define TX_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_GET BCMI_FALCON_XGXS_TX_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_GET
#define TX_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_SET BCMI_FALCON_XGXS_TX_CTL3r_TXCOM_CL93N72_WAIT_CNTR_LIMITf_SET
#define READ_TX_CTL3r BCMI_FALCON_XGXS_READ_TX_CTL3r
#define WRITE_TX_CTL3r BCMI_FALCON_XGXS_WRITE_TX_CTL3r
#define MODIFY_TX_CTL3r BCMI_FALCON_XGXS_MODIFY_TX_CTL3r
#define READLN_TX_CTL3r BCMI_FALCON_XGXS_READLN_TX_CTL3r
#define WRITELN_TX_CTL3r BCMI_FALCON_XGXS_WRITELN_TX_CTL3r
#define WRITEALL_TX_CTL3r BCMI_FALCON_XGXS_WRITEALL_TX_CTL3r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TX_CTL3r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CNT_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd160
 * DEVAD:    1
 * DESC:     PRBS Checker Count Control
 * RESETVAL: 0x602 (1538)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_LOCK_CNT specifies the number of consecutive valid clock cycles without any bit errorfor PRBS checker to go into PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will lock as soon as it gets the first clock cycle with no bit error.likewise 31 indicates that PRBS will lock as soon as it gets the 32 consecutive clocks with no error.
 *     PRBS_CHK_OOL_CNT specifies the number of consecutive valid clock cycles with 1 or more bit errorsfor PRBS checker to go out of PRBS lock state. Valid values are 0 to 31 where0 indicate that PRBS will go out of lock as soon as it gets the first clock cycle with 1 or more bit errors.likewise 31 indicates that PRBS will go out of lock as soon as it gets the 32 consecutive clocks with 1 or more errors.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr (0x0001d160 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CNT_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cnt_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cnt_cfg;
} BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cnt_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cnt_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET(r) (r).tlb_rx_prbs_chk_cnt_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET(r) ((((r).tlb_rx_prbs_chk_cnt_cfg[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET(r) (((r).tlb_rx_prbs_chk_cnt_cfg[0]) & 0x1f)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET(r,f) (r).tlb_rx_prbs_chk_cnt_cfg[0]=(((r).tlb_rx_prbs_chk_cnt_cfg[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CNT_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr,(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cnt_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cnt_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CNT_CFGr BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr
#define TLB_RX_PRBS_CHK_CNT_CFGr_SIZE BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_t TLB_RX_PRBS_CHK_CNT_CFGr_t;
#define TLB_RX_PRBS_CHK_CNT_CFGr_CLR BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_CLR
#define TLB_RX_PRBS_CHK_CNT_CFGr_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_OOL_CNTf_SET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_GET
#define TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr_PRBS_CHK_LOCK_CNTf_SET
#define READ_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_CNT_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_CNT_CFGr
#define READLN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_CNT_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CNT_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CNT_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd161
 * DEVAD:    1
 * DESC:     PRBS Checker Control
 * RESETVAL: 0x10a (266)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN      PRBS checker enable.1 => enable  the PRBS checker.0 => disable the PRBS checker.
 *     PRBS_CHK_MODE_SEL PRBS checker mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_CHK_INV     PRBS Invert enable.1 => will invert all the data bits to the PRBS checker.0 => will send normal data to the PRBS checker.
 *     PRBS_CHK_MODE    PRBS LOCK state machine select.2'd0 -> Self-sync mode w/ hysteresis. PRBS seed register is continuously seeded with previous received bits.2'd1 -> Initial seed mode w/ hysteresis. PRBS seed registers is seeded with previous received bits only till PRBS lock isacquired and then they run locally independently from the received data until the checker goes out of PRBS lock.2'd2 -> Initial seed mode w/o hysteresis. Similar to mode 1 above except once locked it stays locked until PRBS is disabled.2'd3 -> reserved for future use.
 *     PRBS_CHK_EN_AUTO_MODE PRBS Checker Enable Mode Control.1 => select (rx_dsc_lock & prbs_chk_en) as PRBS checker enable control.0 => select                prbs_chk_en  as PRBS checker enable control.
 *     PRBS_BURST_LEN_CHK_EN 0 => disbale, 1=> enable (default)
 *     PRBS_CHK_ERR_CNT_BURST_MODE PRBS Error Counter Mode.1 => Each busrt of error will be counted as 1 error in the error counter. Each error busrt must be separated by 1 error-free cycle of data which in worst case should be 39 bits.0 => Each bit error will be counted.
 *     TRNSUM_ERROR_COUNT_EN Training sum error counter Mode enable.1 => will make the PRBS error counter used as trnsum_error counter. PRBS checker can not be used during this mode.0 => PRBS checker mode.
 *     PRBS_CHK_CLK_EN_FRC_ON PRBS checker clock enable.1'b1 will enable the PRBS checker clock. Recommended to be enabled before enabling the prbs_chk_en.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr (0x0001d161 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_cfg[1];
	uint32_t _tlb_rx_prbs_chk_cfg;
} BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR(r) (r).tlb_rx_prbs_chk_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_SET(r,d) (r).tlb_rx_prbs_chk_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_GET(r) (r).tlb_rx_prbs_chk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 11) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 11)) | ((((uint32_t)f) & 0x1) << 11)) | (1 << (16 + 11))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 10) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 10)) | ((((uint32_t)f) & 0x1) << 10)) | (1 << (16 + 10))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 7) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 7)) | ((((uint32_t)f) & 0x1) << 7)) | (1 << (16 + 7))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 5) & 0x3)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x3 << 5)) | ((((uint32_t)f) & 0x3) << 5)) | (3 << (16 + 5))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET(r) ((((r).tlb_rx_prbs_chk_cfg[0]) >> 1) & 0x7)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET(r) (((r).tlb_rx_prbs_chk_cfg[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET(r,f) (r).tlb_rx_prbs_chk_cfg[0]=(((r).tlb_rx_prbs_chk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr,(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_CFGr BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr
#define TLB_RX_PRBS_CHK_CFGr_SIZE BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_t TLB_RX_PRBS_CHK_CFGr_t;
#define TLB_RX_PRBS_CHK_CFGr_CLR BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_CLR
#define TLB_RX_PRBS_CHK_CFGr_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_SET
#define TLB_RX_PRBS_CHK_CFGr_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_CLK_EN_FRC_ONf_SET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_TRNSUM_ERROR_COUNT_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ERR_CNT_BURST_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_BURST_LEN_CHK_ENf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_EN_AUTO_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODEf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_INVf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_MODE_SELf_SET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_GET
#define TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr_PRBS_CHK_ENf_SET
#define READ_TLB_RX_PRBS_CHK_CFGr BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_CFGr
#define WRITE_TLB_RX_PRBS_CHK_CFGr BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_CFGr
#define MODIFY_TLB_RX_PRBS_CHK_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_CFGr
#define READLN_TLB_RX_PRBS_CHK_CFGr BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_CFGr
#define WRITELN_TLB_RX_PRBS_CHK_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_CFGr
#define WRITEALL_TLB_RX_PRBS_CHK_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd162
 * DEVAD:    1
 * DESC:     Digital Loopback Control
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     DIG_LPBK_EN      TX to RX Parallel Loopback (Digital Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     DIG_LPBK_PD_MODE Digital Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     DIG_LPBK_PD_BIAS_EN 1'b1 will enable PD inc bias mode where there will be inc generated every 16th clock cycle..1'b0 will disable the PD bias mode so inc/dec will be generated based on the PD output.
 */
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr (0x0001d162 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_cfg[1];
	uint32_t _tlb_rx_dig_lpbk_cfg;
} BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR(r) (r).tlb_rx_dig_lpbk_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_SET(r,d) (r).tlb_rx_dig_lpbk_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_GET(r) (r).tlb_rx_dig_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET(r) ((((r).tlb_rx_dig_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET(r) (((r).tlb_rx_dig_lpbk_cfg[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_dig_lpbk_cfg[0]=(((r).tlb_rx_dig_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr,(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_CFGr BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr
#define TLB_RX_DIG_LPBK_CFGr_SIZE BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_t TLB_RX_DIG_LPBK_CFGr_t;
#define TLB_RX_DIG_LPBK_CFGr_CLR BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_CLR
#define TLB_RX_DIG_LPBK_CFGr_SET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_SET
#define TLB_RX_DIG_LPBK_CFGr_GET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_BIAS_ENf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_PD_MODEf_SET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_GET
#define TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr_DIG_LPBK_ENf_SET
#define READ_TLB_RX_DIG_LPBK_CFGr BCMI_FALCON_XGXS_READ_TLB_RX_DIG_LPBK_CFGr
#define WRITE_TLB_RX_DIG_LPBK_CFGr BCMI_FALCON_XGXS_WRITE_TLB_RX_DIG_LPBK_CFGr
#define MODIFY_TLB_RX_DIG_LPBK_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_RX_DIG_LPBK_CFGr
#define READLN_TLB_RX_DIG_LPBK_CFGr BCMI_FALCON_XGXS_READLN_TLB_RX_DIG_LPBK_CFGr
#define WRITELN_TLB_RX_DIG_LPBK_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_RX_DIG_LPBK_CFGr
#define WRITEALL_TLB_RX_DIG_LPBK_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_DIG_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_MISC_CFG
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd163
 * DEVAD:    1
 * DESC:     TLB RX Misc. Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     RX_PMD_DP_INVERT RX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     DBG_MASK_DIG_LPBK_EN Mask bit for dig_lpbk_en in the pmd_rx_lock equation. This is a debug register.1 => pmd_rx_lock will be forced to 1'b0 during digital loopback.0 => pmd_rx_lock will be forced to 1'b1 during digital loopback.
 *     TLB_RX_DIFF_DEC_EN 1'b1 will enable the Differential Decoder for pmd_rx_data. Only applicable to PCS RX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 */
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr (0x0001d163 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_MISC_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_rx_misc_cfg[1];
	uint32_t _tlb_rx_misc_cfg;
} BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_CLR(r) (r).tlb_rx_misc_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_SET(r,d) (r).tlb_rx_misc_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_GET(r) (r).tlb_rx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET(r) ((((r).tlb_rx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET(r,f) (r).tlb_rx_misc_cfg[0]=(((r).tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET(r) ((((r).tlb_rx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET(r,f) (r).tlb_rx_misc_cfg[0]=(((r).tlb_rx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET(r) (((r).tlb_rx_misc_cfg[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET(r,f) (r).tlb_rx_misc_cfg[0]=(((r).tlb_rx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_MISC_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr,(_r._tlb_rx_misc_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr,(_r._tlb_rx_misc_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr,(_r._tlb_rx_misc_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_misc_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_misc_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_MISC_CFGr BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr
#define TLB_RX_MISC_CFGr_SIZE BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_t TLB_RX_MISC_CFGr_t;
#define TLB_RX_MISC_CFGr_CLR BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_CLR
#define TLB_RX_MISC_CFGr_SET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_SET
#define TLB_RX_MISC_CFGr_GET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_GET
#define TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_GET
#define TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_TLB_RX_DIFF_DEC_ENf_SET
#define TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_GET
#define TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_DBG_MASK_DIG_LPBK_ENf_SET
#define TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_GET
#define TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr_RX_PMD_DP_INVERTf_SET
#define READ_TLB_RX_MISC_CFGr BCMI_FALCON_XGXS_READ_TLB_RX_MISC_CFGr
#define WRITE_TLB_RX_MISC_CFGr BCMI_FALCON_XGXS_WRITE_TLB_RX_MISC_CFGr
#define MODIFY_TLB_RX_MISC_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_RX_MISC_CFGr
#define READLN_TLB_RX_MISC_CFGr BCMI_FALCON_XGXS_READLN_TLB_RX_MISC_CFGr
#define WRITELN_TLB_RX_MISC_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_RX_MISC_CFGr
#define WRITEALL_TLB_RX_MISC_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_EN_TMR_CTL
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd164
 * DEVAD:    1
 * DESC:     TLB RX PRBS Checker Enable Timer Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_CHK_EN_TIMER_MODE prbs_chk_en timer mode.2'b0x => prbs_chk_en timer is disabled and PRBS checker mode is enabled as per prbs_chk_en register.2'b10 => use heartbeat_toggle_1us for the timer.2'b11 => use heartbeat_toggle_1ms for the timer.
 *     PRBS_CHK_EN_TIMEOUT PRBS timer timeout value.Valid range 0 to 31 which maps to 0 to 448. Should be programmed before enabling the PRBS checker in timer mode.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr (0x0001d164 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_en_tmr_ctl[1];
	uint32_t _tlb_rx_prbs_chk_en_tmr_ctl;
} BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET(r,d) (r).tlb_rx_prbs_chk_en_tmr_ctl[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET(r) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET(r) ((((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) >> 8) & 0x1f)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x1f << 8)) | ((((uint32_t)f) & 0x1f) << 8)) | (31 << (16 + 8))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET(r) (((r).tlb_rx_prbs_chk_en_tmr_ctl[0]) & 0x3)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET(r,f) (r).tlb_rx_prbs_chk_en_tmr_ctl[0]=(((r).tlb_rx_prbs_chk_en_tmr_ctl[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_EN_TMR_CTL.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr,(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_en_tmr_ctl))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_en_tmr_ctl))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_t TLB_RX_PRBS_CHK_EN_TMR_CTLr_t;
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_CLR
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMEOUTf_SET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_GET
#define TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr_PRBS_CHK_EN_TIMER_MODEf_SET
#define READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_EN_TMR_CTLr
#define WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_EN_TMR_CTLr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_EN_TMR_CTLr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_DIG_LPBK_PD_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd168
 * DEVAD:    1
 * DESC:     Digital Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     DIG_LPBK_PD_LATE_IND 1 means dp_rclk20 is sampling data late so reduce the delay of the dp_rclk20 clock phase. This will result in RX PI phase step decrement.
 *     DIG_LPBK_PD_EARLY_IND 1 means dp_rclk20 is sampling data earlier so delay the dp_rclk20 clock phase. This will result in RX PI phase step increment.
 */
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr (0x0001d168 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_DIG_LPBK_PD_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_dig_lpbk_pd_sts[1];
	uint32_t _tlb_rx_dig_lpbk_pd_sts;
} BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t;

#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR(r) (r).tlb_rx_dig_lpbk_pd_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET(r,d) (r).tlb_rx_dig_lpbk_pd_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET(r) (r).tlb_rx_dig_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_rx_dig_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_rx_dig_lpbk_pd_sts[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_rx_dig_lpbk_pd_sts[0]=(((r).tlb_rx_dig_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_DIG_LPBK_PD_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr,(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_dig_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_dig_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_DIG_LPBK_PD_STSr BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr
#define TLB_RX_DIG_LPBK_PD_STSr_SIZE BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_t TLB_RX_DIG_LPBK_PD_STSr_t;
#define TLB_RX_DIG_LPBK_PD_STSr_CLR BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_CLR
#define TLB_RX_DIG_LPBK_PD_STSr_SET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_SET
#define TLB_RX_DIG_LPBK_PD_STSr_GET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_EARLY_INDf_SET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_GET
#define TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr_DIG_LPBK_PD_LATE_INDf_SET
#define READ_TLB_RX_DIG_LPBK_PD_STSr BCMI_FALCON_XGXS_READ_TLB_RX_DIG_LPBK_PD_STSr
#define WRITE_TLB_RX_DIG_LPBK_PD_STSr BCMI_FALCON_XGXS_WRITE_TLB_RX_DIG_LPBK_PD_STSr
#define MODIFY_TLB_RX_DIG_LPBK_PD_STSr BCMI_FALCON_XGXS_MODIFY_TLB_RX_DIG_LPBK_PD_STSr
#define READLN_TLB_RX_DIG_LPBK_PD_STSr BCMI_FALCON_XGXS_READLN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITELN_TLB_RX_DIG_LPBK_PD_STSr BCMI_FALCON_XGXS_WRITELN_TLB_RX_DIG_LPBK_PD_STSr
#define WRITEALL_TLB_RX_DIG_LPBK_PD_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_DIG_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_DIG_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd169
 * DEVAD:    1
 * DESC:     PRBS Checker LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_LOCK    PRBS Checker LOCK Indication. This is a live indication of the status of the PRBS Checker state machine.1 => PRBS Checker is in LOCKED state.0 => PRBS Checker is out of LOCK state and state machine is seraching for a LOCK.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr (0x0001d169 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_LOCK_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_lock_sts[1];
	uint32_t _tlb_rx_prbs_chk_lock_sts;
} BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR(r) (r).tlb_rx_prbs_chk_lock_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET(r,d) (r).tlb_rx_prbs_chk_lock_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET(r) (r).tlb_rx_prbs_chk_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET(r) (((r).tlb_rx_prbs_chk_lock_sts[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET(r,f) (r).tlb_rx_prbs_chk_lock_sts[0]=(((r).tlb_rx_prbs_chk_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_LOCK_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr,(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_lock_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_LOCK_STSr BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr
#define TLB_RX_PRBS_CHK_LOCK_STSr_SIZE BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_t TLB_RX_PRBS_CHK_LOCK_STSr_t;
#define TLB_RX_PRBS_CHK_LOCK_STSr_CLR BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_CLR
#define TLB_RX_PRBS_CHK_LOCK_STSr_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_SET
#define TLB_RX_PRBS_CHK_LOCK_STSr_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_GET
#define TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr_PRBS_CHK_LOCKf_SET
#define READ_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITE_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_LOCK_STSr
#define MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_LOCK_STSr
#define READLN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_LOCK_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16a
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter MSB Status
 * RESETVAL: 0x8000 (32768)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_MSB 15 bits MSB portion of PRBS Checker Error Counter Status Register. It is a clear on read register.Once MSB bits [30:16] of the counter are read then LSB bits [15:0] of the error counter is loadedinto a holding register and internal PRBS error counter's all bits are cleared to 0s(or if there are any error in that particular clock cycle then that will be loaded).MSB portion must be read first before reading the LSB portion of the error counter.
 *     PRBS_CHK_LOCK_LOST_LH PRBS Checker LOCK_LOST Latch High Indication. This register captures the 1->0 transition on theprbs_chk_lock live status register and keep it latched until read. This is a clear on read status registers.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr (0x0001d16a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_msb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_msb_sts;
} BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET(r) ((((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]) & 0x7fff)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_msb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_msb_sts[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_MSB_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_msb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_LOCK_LOST_LHf_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr_PRBS_CHK_ERR_CNT_MSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_MSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16b
 * DEVAD:    1
 * DESC:     PRBS Checker Error Counter LSB Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_CHK_ERR_CNT_LSB 16 bits LSB portion of PRBS Checker Error Counter Status Register. This register indicatesthe value in the holding register when MSB portion [30:16] of the error counter are read.MSB portion must be read first before reading the LSB portion of the error counter.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr (0x0001d16b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_chk_err_cnt_lsb_sts[1];
	uint32_t _tlb_rx_prbs_chk_err_cnt_lsb_sts;
} BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET(r,d) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET(r) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET(r) (((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]) & 0xffff)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET(r,f) (r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0]=(((r).tlb_rx_prbs_chk_err_cnt_lsb_sts[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_CHK_ERR_CNT_LSB_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_chk_err_cnt_lsb_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_t;
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_CLR
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_SET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_GET
#define TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr_PRBS_CHK_ERR_CNT_LSBf_SET
#define READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr
#define WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PRBS_CHK_ERR_CNT_LSB_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PMD_RX_LOCK_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16c
 * DEVAD:    1
 * DESC:     PMD RX LOCK Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PMD_RX_LOCK      PMD RX LOCK Indication. This is a live indication of the status of the pmd_rx_lock output port.1 => PMD is in LOCKED state and RX PCS data should have acceptable BER.0 => PMD is not LOCKED yet.
 *     PMD_RX_LOCK_CHANGE Set to 1'b1 when change/transition on PMD RX LOCK. This is a sticky bit and cleared upon read.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr (0x0001d16c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PMD_RX_LOCK_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_pmd_rx_lock_sts[1];
	uint32_t _tlb_rx_pmd_rx_lock_sts;
} BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR(r) (r).tlb_rx_pmd_rx_lock_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET(r,d) (r).tlb_rx_pmd_rx_lock_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET(r) (r).tlb_rx_pmd_rx_lock_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET(r) ((((r).tlb_rx_pmd_rx_lock_sts[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET(r) (((r).tlb_rx_pmd_rx_lock_sts[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET(r,f) (r).tlb_rx_pmd_rx_lock_sts[0]=(((r).tlb_rx_pmd_rx_lock_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_RX_PMD_RX_LOCK_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr,(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_pmd_rx_lock_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_pmd_rx_lock_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PMD_RX_LOCK_STSr BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr
#define TLB_RX_PMD_RX_LOCK_STSr_SIZE BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_t TLB_RX_PMD_RX_LOCK_STSr_t;
#define TLB_RX_PMD_RX_LOCK_STSr_CLR BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_CLR
#define TLB_RX_PMD_RX_LOCK_STSr_SET BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_SET
#define TLB_RX_PMD_RX_LOCK_STSr_GET BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCK_CHANGEf_SET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_GET
#define TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr_PMD_RX_LOCKf_SET
#define READ_TLB_RX_PMD_RX_LOCK_STSr BCMI_FALCON_XGXS_READ_TLB_RX_PMD_RX_LOCK_STSr
#define WRITE_TLB_RX_PMD_RX_LOCK_STSr BCMI_FALCON_XGXS_WRITE_TLB_RX_PMD_RX_LOCK_STSr
#define MODIFY_TLB_RX_PMD_RX_LOCK_STSr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PMD_RX_LOCK_STSr
#define READLN_TLB_RX_PMD_RX_LOCK_STSr BCMI_FALCON_XGXS_READLN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITELN_TLB_RX_PMD_RX_LOCK_STSr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PMD_RX_LOCK_STSr
#define WRITEALL_TLB_RX_PMD_RX_LOCK_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PMD_RX_LOCK_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PMD_RX_LOCK_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16d
 * DEVAD:    1
 * DESC:     PRBS Burst Error Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error length count. This the live indication of the live status of the PRBS burst error length and max at 6'd63.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr (0x0001d16d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_prbs_burst_err_len_sts;
} BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_prbs_burst_err_len_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_prbs_burst_err_len_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_prbs_burst_err_len_sts[0]=(((r).tlb_rx_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_prbs_burst_err_len_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_READ_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_WRITE_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_MODIFY_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_READLN_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_WRITELN_TLB_RX_PRBS_BURST_ERR_LEN_STSr
#define WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS
 * BLOCKS:   TLB_RX
 * REGADDR:  0xd16e
 * DEVAD:    1
 * DESC:     PRBS Burst Error Maximum Length Status
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MAX_PRBS_BURST_ERR_LENGTH_STATUS PRBS burst error max length count. This the status of the PRBS burst error max length and max at 6'd63.
 */
#define BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr (0x0001d16e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_s {
	uint32_t v[1];
	uint32_t tlb_rx_max_prbs_burst_err_len_sts[1];
	uint32_t _tlb_rx_max_prbs_burst_err_len_sts;
} BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;

#define BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET(r,d) (r).tlb_rx_max_prbs_burst_err_len_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET(r) (r).tlb_rx_max_prbs_burst_err_len_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET(r) (((r).tlb_rx_max_prbs_burst_err_len_sts[0]) & 0x3f)
#define BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET(r,f) (r).tlb_rx_max_prbs_burst_err_len_sts[0]=(((r).tlb_rx_max_prbs_burst_err_len_sts[0] & ~((uint32_t)0x3f)) | (((uint32_t)f) & 0x3f)) | (0x3f << 16)

/*
 * These macros can be used to access TLB_RX_MAX_PRBS_BURST_ERR_LEN_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr,(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_rx_max_prbs_burst_err_len_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_rx_max_prbs_burst_err_len_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_t;
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_CLR
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_SET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_GET
#define TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr_MAX_PRBS_BURST_ERR_LENGTH_STATUSf_SET
#define READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_READ_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_WRITE_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_MODIFY_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_READLN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_WRITELN_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr
#define WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_RX_MAX_PRBS_BURST_ERR_LEN_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_TX_PATT_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd170
 * DEVAD:    1
 * DESC:     Pattern Generator Control
 * RESETVAL: 0xb000 (45056)
 * ACCESS:   R/W
 * FIELDS:
 *     PATT_GEN_EN      Fixed pattern generator enable.1 => enable  the fixed pattern generator.0 => disable the fixed pattern generator.
 *     PATT_GEN_STOP_POS Valid values are 11 to 0. Defines the stop  position of the pattern in 20 bit chunks.This register value should be less than or equal to rg_patt_gen_start_pos.11 means stop at bit  220,10 means stop at bit  200, ...,0 means stop at bit    0so stop  bit is (rg_patt_gen_stop_pos*20).
 *     PATT_GEN_START_POS Valid values are 11 to 0. Defines the start position of the pattern in 20 bit chunks.11 means start at bit 239,10 means start at bit 219, ...,0 means start at bit  19so start bit is (rg_patt_gen_start_pos*20 + 19).
 */
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr (0x0001d170 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PATT_GEN_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_patt_gen_cfg[1];
	uint32_t _tlb_tx_patt_gen_cfg;
} BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_CLR(r) (r).tlb_tx_patt_gen_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_SET(r,d) (r).tlb_tx_patt_gen_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_GET(r) (r).tlb_tx_patt_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_GET(r) ((((r).tlb_tx_patt_gen_cfg[0]) >> 12) & 0xf)
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_SET(r,f) (r).tlb_tx_patt_gen_cfg[0]=(((r).tlb_tx_patt_gen_cfg[0] & ~((uint32_t)0xf << 12)) | ((((uint32_t)f) & 0xf) << 12)) | (15 << (16 + 12))
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_GET(r) ((((r).tlb_tx_patt_gen_cfg[0]) >> 8) & 0xf)
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_SET(r,f) (r).tlb_tx_patt_gen_cfg[0]=(((r).tlb_tx_patt_gen_cfg[0] & ~((uint32_t)0xf << 8)) | ((((uint32_t)f) & 0xf) << 8)) | (15 << (16 + 8))
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_GET(r) (((r).tlb_tx_patt_gen_cfg[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_SET(r,f) (r).tlb_tx_patt_gen_cfg[0]=(((r).tlb_tx_patt_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PATT_GEN_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr,(_r._tlb_tx_patt_gen_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr,(_r._tlb_tx_patt_gen_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr,(_r._tlb_tx_patt_gen_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_TX_PATT_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patt_gen_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_TX_PATT_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_patt_gen_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_TX_PATT_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_patt_gen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PATT_GEN_CFGr BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr
#define TLB_TX_PATT_GEN_CFGr_SIZE BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_t TLB_TX_PATT_GEN_CFGr_t;
#define TLB_TX_PATT_GEN_CFGr_CLR BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_CLR
#define TLB_TX_PATT_GEN_CFGr_SET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_SET
#define TLB_TX_PATT_GEN_CFGr_GET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_GET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_SET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_START_POSf_SET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_GET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_SET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_STOP_POSf_SET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_GET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_GET
#define TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_SET BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr_PATT_GEN_ENf_SET
#define READ_TLB_TX_PATT_GEN_CFGr BCMI_FALCON_XGXS_READ_TLB_TX_PATT_GEN_CFGr
#define WRITE_TLB_TX_PATT_GEN_CFGr BCMI_FALCON_XGXS_WRITE_TLB_TX_PATT_GEN_CFGr
#define MODIFY_TLB_TX_PATT_GEN_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_TX_PATT_GEN_CFGr
#define READLN_TLB_TX_PATT_GEN_CFGr BCMI_FALCON_XGXS_READLN_TLB_TX_PATT_GEN_CFGr
#define WRITELN_TLB_TX_PATT_GEN_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_TX_PATT_GEN_CFGr
#define WRITEALL_TLB_TX_PATT_GEN_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_TX_PATT_GEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_TX_PATT_GEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_TX_PRBS_GEN_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd171
 * DEVAD:    1
 * DESC:     PRBS Generator Control
 * RESETVAL: 0xa (10)
 * ACCESS:   R/W
 * FIELDS:
 *     PRBS_GEN_EN      PRBS generator enable.1 => enable  the PRBS generator.0 => disable the PRBS generator.
 *     PRBS_GEN_MODE_SEL PRBS generator mode select. Selects the PRBS polynomial as shown below3'd0 -> PRBS 73'd1 -> PRBS 93'd2 -> PRBS 113'd3 -> PRBS 153'd4 -> PRBS 233'd5 -> PRBS 313'd6 -> PRBS 58 (1 + x^39 + x^58)3'd7 -> reserved for future use.
 *     PRBS_GEN_INV     PRBS Invert enable.1 => will invert all the data bits from the PRBS generator.0 => will send normal data from the PRBS generator.
 *     PRBS_GEN_ERR_INS PRBS Error Insert.0 to 1 transition on this signal will insert single bit error in the MSB bit of the data bus.
 */
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr (0x0001d171 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_PRBS_GEN_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_prbs_gen_cfg[1];
	uint32_t _tlb_tx_prbs_gen_cfg;
} BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR(r) (r).tlb_tx_prbs_gen_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_SET(r,d) (r).tlb_tx_prbs_gen_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_GET(r) (r).tlb_tx_prbs_gen_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET(r) ((((r).tlb_tx_prbs_gen_cfg[0]) >> 1) & 0x7)
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x7 << 1)) | ((((uint32_t)f) & 0x7) << 1)) | (7 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET(r) (((r).tlb_tx_prbs_gen_cfg[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET(r,f) (r).tlb_tx_prbs_gen_cfg[0]=(((r).tlb_tx_prbs_gen_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_PRBS_GEN_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr,(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_prbs_gen_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_prbs_gen_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_PRBS_GEN_CFGr BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr
#define TLB_TX_PRBS_GEN_CFGr_SIZE BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_t TLB_TX_PRBS_GEN_CFGr_t;
#define TLB_TX_PRBS_GEN_CFGr_CLR BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_CLR
#define TLB_TX_PRBS_GEN_CFGr_SET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_SET
#define TLB_TX_PRBS_GEN_CFGr_GET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ERR_INSf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_INVf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_MODE_SELf_SET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_GET
#define TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr_PRBS_GEN_ENf_SET
#define READ_TLB_TX_PRBS_GEN_CFGr BCMI_FALCON_XGXS_READ_TLB_TX_PRBS_GEN_CFGr
#define WRITE_TLB_TX_PRBS_GEN_CFGr BCMI_FALCON_XGXS_WRITE_TLB_TX_PRBS_GEN_CFGr
#define MODIFY_TLB_TX_PRBS_GEN_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_TX_PRBS_GEN_CFGr
#define READLN_TLB_TX_PRBS_GEN_CFGr BCMI_FALCON_XGXS_READLN_TLB_TX_PRBS_GEN_CFGr
#define WRITELN_TLB_TX_PRBS_GEN_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_TX_PRBS_GEN_CFGr
#define WRITEALL_TLB_TX_PRBS_GEN_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_TX_PRBS_GEN_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_TX_PRBS_GEN_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd172
 * DEVAD:    1
 * DESC:     Remote Loopback Control
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/W
 * FIELDS:
 *     RMT_LPBK_EN      RX to TX Parallel Loopback (Remote Loopback) Enable.1 => Loopback is Enabled.0 => Loopback is Disabled.
 *     RMT_LPBK_PD_MODE Remote Loopback Phase Detector Mode. For normal operating conditions keep it at the default value of 1'b1.1'b0 - swap inc/dec. 1'b1 - normal mode.
 *     RMT_LPBK_PD_FRC_ON Remote loopback PD enable by force irrespective of rg_rmt_lpbk_en.1'b1 - enable the phase detector without the remote loopback enable. Can be used to lock RX and TXclock phases when there is a remote loopback outside PMD
 */
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr (0x0001d172 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_cfg[1];
	uint32_t _tlb_tx_rmt_lpbk_cfg;
} BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR(r) (r).tlb_tx_rmt_lpbk_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_SET(r,d) (r).tlb_tx_rmt_lpbk_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_GET(r) (r).tlb_tx_rmt_lpbk_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET(r) ((((r).tlb_tx_rmt_lpbk_cfg[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET(r) (((r).tlb_tx_rmt_lpbk_cfg[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET(r,f) (r).tlb_tx_rmt_lpbk_cfg[0]=(((r).tlb_tx_rmt_lpbk_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr,(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_CFGr BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr
#define TLB_TX_RMT_LPBK_CFGr_SIZE BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_t TLB_TX_RMT_LPBK_CFGr_t;
#define TLB_TX_RMT_LPBK_CFGr_CLR BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_CLR
#define TLB_TX_RMT_LPBK_CFGr_SET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_SET
#define TLB_TX_RMT_LPBK_CFGr_GET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_FRC_ONf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_PD_MODEf_SET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_GET
#define TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr_RMT_LPBK_ENf_SET
#define READ_TLB_TX_RMT_LPBK_CFGr BCMI_FALCON_XGXS_READ_TLB_TX_RMT_LPBK_CFGr
#define WRITE_TLB_TX_RMT_LPBK_CFGr BCMI_FALCON_XGXS_WRITE_TLB_TX_RMT_LPBK_CFGr
#define MODIFY_TLB_TX_RMT_LPBK_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_TX_RMT_LPBK_CFGr
#define READLN_TLB_TX_RMT_LPBK_CFGr BCMI_FALCON_XGXS_READLN_TLB_TX_RMT_LPBK_CFGr
#define WRITELN_TLB_TX_RMT_LPBK_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_TX_RMT_LPBK_CFGr
#define WRITEALL_TLB_TX_RMT_LPBK_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_TX_RMT_LPBK_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_TX_MISC_CFG
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd173
 * DEVAD:    1
 * DESC:     TLB TX Misc. Control
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     TX_PMD_DP_INVERT TX PMD Datapath Invert Control.When Enabled by writing to 1'b1, it will invert all the datapath bits of the logical lane.Recommended for use in case P and N pads are swapped on the PCB board.
 *     TX_PCS_NATIVE_ANA_FRMT_EN TX PCS Interface Native Analog Format Enable.1 => TX PCS Interface is enabled in the Native Analog Format mode. TX PCS sends the over-sampled data in this mode which is sent directly to AFE.0 => Raw Data Mode where for every data request TX PCS will send 20 bits of valid data.
 *     TX_MUX_SEL_ORDER TX Data MUX Select Priority Order. When 1'b1 then priority of Pattern and PRBS generators are swapped w.r.t. CL72.0 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, patt_gen, cl72_tx, prbs_gen, tx_pcs}.1 => TX Data Mux select order from higher to lower priority is {rmt_lpbk, prbs_gen, cl72_tx, patt_gen, tx_pcs}.
 *     TLB_TX_DIFF_ENC_EN 1'b1 will enable the Differential Encoder for pmd_tx_data. Only applicable to PCS TX data in OS1, 2 and 4 modes.Write it to 1'b0 for 1G OSR modes 16P5 and 20P625.
 */
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr (0x0001d173 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_MISC_CFG.
 */
typedef union BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_s {
	uint32_t v[1];
	uint32_t tlb_tx_misc_cfg[1];
	uint32_t _tlb_tx_misc_cfg;
} BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_t;

#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_CLR(r) (r).tlb_tx_misc_cfg[0] = 0
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_SET(r,d) (r).tlb_tx_misc_cfg[0] = d
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_GET(r) (r).tlb_tx_misc_cfg[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET(r) ((((r).tlb_tx_misc_cfg[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET(r,f) (r).tlb_tx_misc_cfg[0]=(((r).tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET(r) ((((r).tlb_tx_misc_cfg[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET(r,f) (r).tlb_tx_misc_cfg[0]=(((r).tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET(r) ((((r).tlb_tx_misc_cfg[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET(r,f) (r).tlb_tx_misc_cfg[0]=(((r).tlb_tx_misc_cfg[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET(r) (((r).tlb_tx_misc_cfg[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET(r,f) (r).tlb_tx_misc_cfg[0]=(((r).tlb_tx_misc_cfg[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_MISC_CFG.
 */
#define BCMI_FALCON_XGXS_READ_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr,(_r._tlb_tx_misc_cfg))
#define BCMI_FALCON_XGXS_WRITE_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr,(_r._tlb_tx_misc_cfg)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr,(_r._tlb_tx_misc_cfg))
#define BCMI_FALCON_XGXS_READLN_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_misc_cfg))
#define BCMI_FALCON_XGXS_WRITELN_TLB_TX_MISC_CFGr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_misc_cfg))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_TX_MISC_CFGr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_misc_cfg))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_MISC_CFGr BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr
#define TLB_TX_MISC_CFGr_SIZE BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_SIZE
typedef BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_t TLB_TX_MISC_CFGr_t;
#define TLB_TX_MISC_CFGr_CLR BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_CLR
#define TLB_TX_MISC_CFGr_SET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_SET
#define TLB_TX_MISC_CFGr_GET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_GET
#define TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_GET
#define TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TLB_TX_DIFF_ENC_ENf_SET
#define TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_GET
#define TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_MUX_SEL_ORDERf_SET
#define TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_GET
#define TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PCS_NATIVE_ANA_FRMT_ENf_SET
#define TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_GET
#define TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr_TX_PMD_DP_INVERTf_SET
#define READ_TLB_TX_MISC_CFGr BCMI_FALCON_XGXS_READ_TLB_TX_MISC_CFGr
#define WRITE_TLB_TX_MISC_CFGr BCMI_FALCON_XGXS_WRITE_TLB_TX_MISC_CFGr
#define MODIFY_TLB_TX_MISC_CFGr BCMI_FALCON_XGXS_MODIFY_TLB_TX_MISC_CFGr
#define READLN_TLB_TX_MISC_CFGr BCMI_FALCON_XGXS_READLN_TLB_TX_MISC_CFGr
#define WRITELN_TLB_TX_MISC_CFGr BCMI_FALCON_XGXS_WRITELN_TLB_TX_MISC_CFGr
#define WRITEALL_TLB_TX_MISC_CFGr BCMI_FALCON_XGXS_WRITEALL_TLB_TX_MISC_CFGr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_TX_MISC_CFGr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  TLB_TX_RMT_LPBK_PD_STS
 * BLOCKS:   TLB_TX
 * REGADDR:  0xd178
 * DEVAD:    1
 * DESC:     Remote Loopback Status
 * RESETVAL: 0x2 (2)
 * ACCESS:   R/O
 * FIELDS:
 *     RMT_LPBK_PD_LATE_IND 1 means dp_tclk20 is sampling data late so reduce the delay of the dp_tclk20 clock phase. This will result in TX PI phase step decrement.
 *     RMT_LPBK_PD_EARLY_IND 1 means dp_tclk20 is sampling data earlier so delay the dp_tclk20 clock phase. This will result in TX PI phase step increment.
 */
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr (0x0001d178 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE 4

/*
 * This structure should be used to declare and program TLB_TX_RMT_LPBK_PD_STS.
 */
typedef union BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_s {
	uint32_t v[1];
	uint32_t tlb_tx_rmt_lpbk_pd_sts[1];
	uint32_t _tlb_tx_rmt_lpbk_pd_sts;
} BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t;

#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR(r) (r).tlb_tx_rmt_lpbk_pd_sts[0] = 0
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET(r,d) (r).tlb_tx_rmt_lpbk_pd_sts[0] = d
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET(r) (r).tlb_tx_rmt_lpbk_pd_sts[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET(r) ((((r).tlb_tx_rmt_lpbk_pd_sts[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET(r) (((r).tlb_tx_rmt_lpbk_pd_sts[0]) & 0x1)
#define BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET(r,f) (r).tlb_tx_rmt_lpbk_pd_sts[0]=(((r).tlb_tx_rmt_lpbk_pd_sts[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access TLB_TX_RMT_LPBK_PD_STS.
 */
#define BCMI_FALCON_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr,(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._tlb_tx_rmt_lpbk_pd_sts))
#define BCMI_FALCON_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._tlb_tx_rmt_lpbk_pd_sts))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define TLB_TX_RMT_LPBK_PD_STSr BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr
#define TLB_TX_RMT_LPBK_PD_STSr_SIZE BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SIZE
typedef BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_t TLB_TX_RMT_LPBK_PD_STSr_t;
#define TLB_TX_RMT_LPBK_PD_STSr_CLR BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_CLR
#define TLB_TX_RMT_LPBK_PD_STSr_SET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_SET
#define TLB_TX_RMT_LPBK_PD_STSr_GET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_EARLY_INDf_SET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_GET
#define TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr_RMT_LPBK_PD_LATE_INDf_SET
#define READ_TLB_TX_RMT_LPBK_PD_STSr BCMI_FALCON_XGXS_READ_TLB_TX_RMT_LPBK_PD_STSr
#define WRITE_TLB_TX_RMT_LPBK_PD_STSr BCMI_FALCON_XGXS_WRITE_TLB_TX_RMT_LPBK_PD_STSr
#define MODIFY_TLB_TX_RMT_LPBK_PD_STSr BCMI_FALCON_XGXS_MODIFY_TLB_TX_RMT_LPBK_PD_STSr
#define READLN_TLB_TX_RMT_LPBK_PD_STSr BCMI_FALCON_XGXS_READLN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITELN_TLB_TX_RMT_LPBK_PD_STSr BCMI_FALCON_XGXS_WRITELN_TLB_TX_RMT_LPBK_PD_STSr
#define WRITEALL_TLB_TX_RMT_LPBK_PD_STSr BCMI_FALCON_XGXS_WRITEALL_TLB_TX_RMT_LPBK_PD_STSr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_TLB_TX_RMT_LPBK_PD_STSr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_CLK_CTL0
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd200
 * DEVAD:    1
 * DESC:     Clock control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_CLK_EN master clock enable:By default the clock to micro sub-system is disabled andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 enable the master clock0 - disabled1 - enables
 *     MICRO_CORE_CLK_EN micro core clock enable (m0):While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted0 - disabled1 - enables
 */
#define BCMI_FALCON_XGXS_UC_CLK_CTL0r (0x0001d200 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CLK_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_CLK_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_clk_ctl0[1];
	uint32_t _uc_clk_ctl0;
} BCMI_FALCON_XGXS_UC_CLK_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_CLR(r) (r).uc_clk_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_SET(r,d) (r).uc_clk_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_GET(r) (r).uc_clk_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET(r) ((((r).uc_clk_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET(r) (((r).uc_clk_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET(r,f) (r).uc_clk_ctl0[0]=(((r).uc_clk_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CLK_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CLK_CTL0r,(_r._uc_clk_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_CLK_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_clk_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_CLK_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CLK_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_clk_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CLK_CTL0r BCMI_FALCON_XGXS_UC_CLK_CTL0r
#define UC_CLK_CTL0r_SIZE BCMI_FALCON_XGXS_UC_CLK_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_CLK_CTL0r_t UC_CLK_CTL0r_t;
#define UC_CLK_CTL0r_CLR BCMI_FALCON_XGXS_UC_CLK_CTL0r_CLR
#define UC_CLK_CTL0r_SET BCMI_FALCON_XGXS_UC_CLK_CTL0r_SET
#define UC_CLK_CTL0r_GET BCMI_FALCON_XGXS_UC_CLK_CTL0r_GET
#define UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_CORE_CLK_ENf_SET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_GET
#define UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET BCMI_FALCON_XGXS_UC_CLK_CTL0r_MICRO_MASTER_CLK_ENf_SET
#define READ_UC_CLK_CTL0r BCMI_FALCON_XGXS_READ_UC_CLK_CTL0r
#define WRITE_UC_CLK_CTL0r BCMI_FALCON_XGXS_WRITE_UC_CLK_CTL0r
#define MODIFY_UC_CLK_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_CLK_CTL0r
#define READLN_UC_CLK_CTL0r BCMI_FALCON_XGXS_READLN_UC_CLK_CTL0r
#define WRITELN_UC_CLK_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_CLK_CTL0r
#define WRITEALL_UC_CLK_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_CLK_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_CLK_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RST_CTL0
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd201
 * DEVAD:    1
 * DESC:     Reset control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_MASTER_RSTB master reset :By default a reset to micro controller sub-system is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the micro-subsystem0 - asserted1 - de-asserted
 *     MICRO_CORE_RSTB  micro core reset (m0):While the micro-code is being loaded into the code RAM, the clock tomicro_core (m0) is normally disabled and a reset is asserted.Setting this field to 1'b1 de-asserts a reset to the micro.0 - disabled1 - enables
 *     MICRO_PRAM_IF_RSTB PRAM interface reset :By default a reset to the PRAM interface is asserted, andonly the micro control and status registers can be accessed throughthe RMIC interface. Setting this field to 1'b1 de-assert a reset to the PRAM interface0 - asserted1 - de-asserted
 */
#define BCMI_FALCON_XGXS_UC_RST_CTL0r (0x0001d201 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RST_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RST_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_RST_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rst_ctl0[1];
	uint32_t _uc_rst_ctl0;
} BCMI_FALCON_XGXS_UC_RST_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_RST_CTL0r_CLR(r) (r).uc_rst_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_SET(r,d) (r).uc_rst_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_GET(r) (r).uc_rst_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_GET(r) ((((r).uc_rst_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET(r) (((r).uc_rst_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET(r,f) (r).uc_rst_ctl0[0]=(((r).uc_rst_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RST_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RST_CTL0r,(_r._uc_rst_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_RST_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_RST_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rst_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RST_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RST_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rst_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RST_CTL0r BCMI_FALCON_XGXS_UC_RST_CTL0r
#define UC_RST_CTL0r_SIZE BCMI_FALCON_XGXS_UC_RST_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_RST_CTL0r_t UC_RST_CTL0r_t;
#define UC_RST_CTL0r_CLR BCMI_FALCON_XGXS_UC_RST_CTL0r_CLR
#define UC_RST_CTL0r_SET BCMI_FALCON_XGXS_UC_RST_CTL0r_SET
#define UC_RST_CTL0r_GET BCMI_FALCON_XGXS_UC_RST_CTL0r_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_GET
#define UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_PRAM_IF_RSTBf_SET
#define UC_RST_CTL0r_MICRO_CORE_RSTBf_GET BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_GET
#define UC_RST_CTL0r_MICRO_CORE_RSTBf_SET BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_CORE_RSTBf_SET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_GET
#define UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET BCMI_FALCON_XGXS_UC_RST_CTL0r_MICRO_MASTER_RSTBf_SET
#define READ_UC_RST_CTL0r BCMI_FALCON_XGXS_READ_UC_RST_CTL0r
#define WRITE_UC_RST_CTL0r BCMI_FALCON_XGXS_WRITE_UC_RST_CTL0r
#define MODIFY_UC_RST_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_RST_CTL0r
#define READLN_UC_RST_CTL0r BCMI_FALCON_XGXS_READLN_UC_RST_CTL0r
#define WRITELN_UC_RST_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_RST_CTL0r
#define WRITEALL_UC_RST_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_RST_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RST_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_CTL0
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd202
 * DEVAD:    1
 * DESC:     rmi to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATASIZE write data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_RDDATASIZE read data size select'd0 : 8-bit'd1 : 16-bit'd2 : 32-bit'd3 : reserved
 *     MICRO_RA_INIT    Intialize code/data RAM2'b01: initailize code RAM - write zeroes to all locations2'b10: initialize data RAM - write zeroes to all loactions2'b00, 2'b11: ignored
 *     MICRO_AUTOINC_WRADDR_EN Automatic increment write address enable0 - disabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the constant addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.1 - enabled, micro_ra_wraddr_lsw and micro_ra_wraddr_msw field specify the start addresswhere the data from the micro_ra_wrdata_msw and micro_ra_wrdata_lsw is written.the address automatically increments based on the micro_ra_wrdatasize field afterthe write has been performed
 *     MICRO_AUTOINC_RDADDR_EN Automatic increment read address enable0 - disabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the constant addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw fileds1 - enabled, micro_ra_rdaddr_lsw and micro_ra_rdaddr_msw field specify the start addresswhere the data is read via the micro_ra_rddata_msw and micro_ra_rddata_lsw filedsthe address automatically increments based on the micro_ra_rddatasize field afterthe read has been performed
 */
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r (0x0001d202 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_ctl0[1];
	uint32_t _uc_ahb_ctl0;
} BCMI_FALCON_XGXS_UC_AHB_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_CLR(r) (r).uc_ahb_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_SET(r,d) (r).uc_ahb_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_GET(r) (r).uc_ahb_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 13) & 0x1)
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 13)) | ((((uint32_t)f) & 0x1) << 13)) | (1 << (16 + 13))
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 8) & 0x3)
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 8)) | ((((uint32_t)f) & 0x3) << 8)) | (3 << (16 + 8))
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET(r) ((((r).uc_ahb_ctl0[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET(r) (((r).uc_ahb_ctl0[0]) & 0x3)
#define BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET(r,f) (r).uc_ahb_ctl0[0]=(((r).uc_ahb_ctl0[0] & ~((uint32_t)0x3)) | (((uint32_t)f) & 0x3)) | (0x3 << 16)

/*
 * These macros can be used to access UC_AHB_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_CTL0r,(_r._uc_ahb_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_CTL0r BCMI_FALCON_XGXS_UC_AHB_CTL0r
#define UC_AHB_CTL0r_SIZE BCMI_FALCON_XGXS_UC_AHB_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_CTL0r_t UC_AHB_CTL0r_t;
#define UC_AHB_CTL0r_CLR BCMI_FALCON_XGXS_UC_AHB_CTL0r_CLR
#define UC_AHB_CTL0r_SET BCMI_FALCON_XGXS_UC_AHB_CTL0r_SET
#define UC_AHB_CTL0r_GET BCMI_FALCON_XGXS_UC_AHB_CTL0r_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_RDADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_GET
#define UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_AUTOINC_WRADDR_ENf_SET
#define UC_AHB_CTL0r_MICRO_RA_INITf_GET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_GET
#define UC_AHB_CTL0r_MICRO_RA_INITf_SET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_INITf_SET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_RDDATASIZEf_SET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_GET
#define UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET BCMI_FALCON_XGXS_UC_AHB_CTL0r_MICRO_RA_WRDATASIZEf_SET
#define READ_UC_AHB_CTL0r BCMI_FALCON_XGXS_READ_UC_AHB_CTL0r
#define WRITE_UC_AHB_CTL0r BCMI_FALCON_XGXS_WRITE_UC_AHB_CTL0r
#define MODIFY_UC_AHB_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_AHB_CTL0r
#define READLN_UC_AHB_CTL0r BCMI_FALCON_XGXS_READLN_UC_AHB_CTL0r
#define WRITELN_UC_AHB_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_AHB_CTL0r
#define WRITEALL_UC_AHB_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_AHB_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_STS0
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd203
 * DEVAD:    1
 * DESC:     rmi to ahb status registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_INITDONE When this bit is set, it indicate that code/data RAM initialization process is completeThis reamins set until
 */
#define BCMI_FALCON_XGXS_UC_AHB_STS0r (0x0001d203 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_STS0.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_STS0r_s {
	uint32_t v[1];
	uint32_t uc_ahb_sts0[1];
	uint32_t _uc_ahb_sts0;
} BCMI_FALCON_XGXS_UC_AHB_STS0r_t;

#define BCMI_FALCON_XGXS_UC_AHB_STS0r_CLR(r) (r).uc_ahb_sts0[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_STS0r_SET(r,d) (r).uc_ahb_sts0[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_STS0r_GET(r) (r).uc_ahb_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET(r) (((r).uc_ahb_sts0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET(r,f) (r).uc_ahb_sts0[0]=(((r).uc_ahb_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_AHB_STS0.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_STS0r,(_r._uc_ahb_sts0))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_STS0r BCMI_FALCON_XGXS_UC_AHB_STS0r
#define UC_AHB_STS0r_SIZE BCMI_FALCON_XGXS_UC_AHB_STS0r_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_STS0r_t UC_AHB_STS0r_t;
#define UC_AHB_STS0r_CLR BCMI_FALCON_XGXS_UC_AHB_STS0r_CLR
#define UC_AHB_STS0r_SET BCMI_FALCON_XGXS_UC_AHB_STS0r_SET
#define UC_AHB_STS0r_GET BCMI_FALCON_XGXS_UC_AHB_STS0r_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_GET BCMI_FALCON_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_GET
#define UC_AHB_STS0r_MICRO_RA_INITDONEf_SET BCMI_FALCON_XGXS_UC_AHB_STS0r_MICRO_RA_INITDONEf_SET
#define READ_UC_AHB_STS0r BCMI_FALCON_XGXS_READ_UC_AHB_STS0r
#define WRITE_UC_AHB_STS0r BCMI_FALCON_XGXS_WRITE_UC_AHB_STS0r
#define MODIFY_UC_AHB_STS0r BCMI_FALCON_XGXS_MODIFY_UC_AHB_STS0r
#define READLN_UC_AHB_STS0r BCMI_FALCON_XGXS_READLN_UC_AHB_STS0r
#define WRITELN_UC_AHB_STS0r BCMI_FALCON_XGXS_WRITELN_UC_AHB_STS0r
#define WRITEALL_UC_AHB_STS0r BCMI_FALCON_XGXS_WRITEALL_UC_AHB_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd204
 * DEVAD:    1
 * DESC:     rmi to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during write transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactions
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr (0x0001d204 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_lsw[1];
	uint32_t _uc_ahb_wraddr_lsw;
} BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_CLR(r) (r).uc_ahb_wraddr_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_SET(r,d) (r).uc_ahb_wraddr_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_GET(r) (r).uc_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET(r) (((r).uc_ahb_wraddr_lsw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET(r,f) (r).uc_ahb_wraddr_lsw[0]=(((r).uc_ahb_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr,(_r._uc_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr
#define UC_AHB_WRADDR_LSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_t UC_AHB_WRADDR_LSWr_t;
#define UC_AHB_WRADDR_LSWr_CLR BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_CLR
#define UC_AHB_WRADDR_LSWr_SET BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_SET
#define UC_AHB_WRADDR_LSWr_GET BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_GET
#define UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr_MICRO_RA_WRADDR_LSWf_SET
#define READ_UC_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_READ_UC_AHB_WRADDR_LSWr
#define WRITE_UC_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_WRADDR_LSWr
#define MODIFY_UC_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRADDR_LSWr
#define READLN_UC_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_READLN_UC_AHB_WRADDR_LSWr
#define WRITELN_UC_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRADDR_LSWr
#define WRITEALL_UC_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd205
 * DEVAD:    1
 * DESC:     rmi to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during write transactions
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr (0x0001d205 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRADDR_MSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wraddr_msw[1];
	uint32_t _uc_ahb_wraddr_msw;
} BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_CLR(r) (r).uc_ahb_wraddr_msw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_SET(r,d) (r).uc_ahb_wraddr_msw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_GET(r) (r).uc_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET(r) (((r).uc_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET(r,f) (r).uc_ahb_wraddr_msw[0]=(((r).uc_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRADDR_MSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr,(_r._uc_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr
#define UC_AHB_WRADDR_MSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_t UC_AHB_WRADDR_MSWr_t;
#define UC_AHB_WRADDR_MSWr_CLR BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_CLR
#define UC_AHB_WRADDR_MSWr_SET BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_SET
#define UC_AHB_WRADDR_MSWr_GET BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_GET
#define UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr_MICRO_RA_WRADDR_MSWf_SET
#define READ_UC_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_READ_UC_AHB_WRADDR_MSWr
#define WRITE_UC_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_WRADDR_MSWr
#define MODIFY_UC_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRADDR_MSWr
#define READLN_UC_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_READLN_UC_AHB_WRADDR_MSWr
#define WRITELN_UC_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRADDR_MSWr
#define WRITEALL_UC_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_WRDATA_LSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd206
 * DEVAD:    1
 * DESC:     rmi to ahb write data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_LSW These bits are used to generate the lower 16-bits of the data on the AHB-Lite bus during write transactionsWrite transaction on the AHB-Lite is initiated when this register is written
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr (0x0001d206 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_lsw[1];
	uint32_t _uc_ahb_wrdata_lsw;
} BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_CLR(r) (r).uc_ahb_wrdata_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_SET(r,d) (r).uc_ahb_wrdata_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_GET(r) (r).uc_ahb_wrdata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET(r) (((r).uc_ahb_wrdata_lsw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET(r,f) (r).uc_ahb_wrdata_lsw[0]=(((r).uc_ahb_wrdata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr,(_r._uc_ahb_wrdata_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_LSWr BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr
#define UC_AHB_WRDATA_LSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_t UC_AHB_WRDATA_LSWr_t;
#define UC_AHB_WRDATA_LSWr_CLR BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_CLR
#define UC_AHB_WRDATA_LSWr_SET BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_SET
#define UC_AHB_WRDATA_LSWr_GET BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_GET
#define UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr_MICRO_RA_WRDATA_LSWf_SET
#define READ_UC_AHB_WRDATA_LSWr BCMI_FALCON_XGXS_READ_UC_AHB_WRDATA_LSWr
#define WRITE_UC_AHB_WRDATA_LSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_WRDATA_LSWr
#define MODIFY_UC_AHB_WRDATA_LSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRDATA_LSWr
#define READLN_UC_AHB_WRDATA_LSWr BCMI_FALCON_XGXS_READLN_UC_AHB_WRDATA_LSWr
#define WRITELN_UC_AHB_WRDATA_LSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRDATA_LSWr
#define WRITEALL_UC_AHB_WRDATA_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_WRDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_WRDATA_MSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd207
 * DEVAD:    1
 * DESC:     rmi to ahb write data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_WRDATA_MSW These bits are used  to generate the upper 16-bits of the data on the AHB-Lite bus during write transactions
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr (0x0001d207 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_WRDATA_MSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_wrdata_msw[1];
	uint32_t _uc_ahb_wrdata_msw;
} BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_CLR(r) (r).uc_ahb_wrdata_msw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_SET(r,d) (r).uc_ahb_wrdata_msw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_GET(r) (r).uc_ahb_wrdata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET(r) (((r).uc_ahb_wrdata_msw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET(r,f) (r).uc_ahb_wrdata_msw[0]=(((r).uc_ahb_wrdata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_WRDATA_MSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr,(_r._uc_ahb_wrdata_msw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_wrdata_msw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_wrdata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_WRDATA_MSWr BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr
#define UC_AHB_WRDATA_MSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_t UC_AHB_WRDATA_MSWr_t;
#define UC_AHB_WRDATA_MSWr_CLR BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_CLR
#define UC_AHB_WRDATA_MSWr_SET BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_SET
#define UC_AHB_WRDATA_MSWr_GET BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_GET
#define UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr_MICRO_RA_WRDATA_MSWf_SET
#define READ_UC_AHB_WRDATA_MSWr BCMI_FALCON_XGXS_READ_UC_AHB_WRDATA_MSWr
#define WRITE_UC_AHB_WRDATA_MSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_WRDATA_MSWr
#define MODIFY_UC_AHB_WRDATA_MSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_WRDATA_MSWr
#define READLN_UC_AHB_WRDATA_MSWr BCMI_FALCON_XGXS_READLN_UC_AHB_WRDATA_MSWr
#define WRITELN_UC_AHB_WRDATA_MSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_WRDATA_MSWr
#define WRITEALL_UC_AHB_WRDATA_MSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_WRDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_WRDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_RDADDR_LSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd208
 * DEVAD:    1
 * DESC:     rmi to ahb read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_LSW These bits are used to generate the lower 16-bits of the address on the AHB-Lite bus during read transactionsbit 0 is not used during 16-bit transactions andbits[1:0] are not used during 32-bit transactionsRead transaction is initiated on the AHB-Lite when this register is written
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr (0x0001d208 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_lsw[1];
	uint32_t _uc_ahb_rdaddr_lsw;
} BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_CLR(r) (r).uc_ahb_rdaddr_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_SET(r,d) (r).uc_ahb_rdaddr_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_GET(r) (r).uc_ahb_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET(r) (((r).uc_ahb_rdaddr_lsw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET(r,f) (r).uc_ahb_rdaddr_lsw[0]=(((r).uc_ahb_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr,(_r._uc_ahb_rdaddr_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_LSWr BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr
#define UC_AHB_RDADDR_LSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_t UC_AHB_RDADDR_LSWr_t;
#define UC_AHB_RDADDR_LSWr_CLR BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_CLR
#define UC_AHB_RDADDR_LSWr_SET BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_SET
#define UC_AHB_RDADDR_LSWr_GET BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_GET
#define UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr_MICRO_RA_RDADDR_LSWf_SET
#define READ_UC_AHB_RDADDR_LSWr BCMI_FALCON_XGXS_READ_UC_AHB_RDADDR_LSWr
#define WRITE_UC_AHB_RDADDR_LSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_RDADDR_LSWr
#define MODIFY_UC_AHB_RDADDR_LSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDADDR_LSWr
#define READLN_UC_AHB_RDADDR_LSWr BCMI_FALCON_XGXS_READLN_UC_AHB_RDADDR_LSWr
#define WRITELN_UC_AHB_RDADDR_LSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDADDR_LSWr
#define WRITEALL_UC_AHB_RDADDR_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_RDADDR_MSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd209
 * DEVAD:    1
 * DESC:     rmi to ahb read address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_RDADDR_MSW These bits are used by to generate the upper 16-bits of the address on the AHB-Lite bus during read transactions
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr (0x0001d209 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDADDR_MSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rdaddr_msw[1];
	uint32_t _uc_ahb_rdaddr_msw;
} BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_CLR(r) (r).uc_ahb_rdaddr_msw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_SET(r,d) (r).uc_ahb_rdaddr_msw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_GET(r) (r).uc_ahb_rdaddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET(r) (((r).uc_ahb_rdaddr_msw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET(r,f) (r).uc_ahb_rdaddr_msw[0]=(((r).uc_ahb_rdaddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDADDR_MSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr,(_r._uc_ahb_rdaddr_msw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rdaddr_msw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rdaddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDADDR_MSWr BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr
#define UC_AHB_RDADDR_MSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_t UC_AHB_RDADDR_MSWr_t;
#define UC_AHB_RDADDR_MSWr_CLR BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_CLR
#define UC_AHB_RDADDR_MSWr_SET BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_SET
#define UC_AHB_RDADDR_MSWr_GET BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_GET
#define UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr_MICRO_RA_RDADDR_MSWf_SET
#define READ_UC_AHB_RDADDR_MSWr BCMI_FALCON_XGXS_READ_UC_AHB_RDADDR_MSWr
#define WRITE_UC_AHB_RDADDR_MSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_RDADDR_MSWr
#define MODIFY_UC_AHB_RDADDR_MSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDADDR_MSWr
#define READLN_UC_AHB_RDADDR_MSWr BCMI_FALCON_XGXS_READLN_UC_AHB_RDADDR_MSWr
#define WRITELN_UC_AHB_RDADDR_MSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDADDR_MSWr
#define WRITEALL_UC_AHB_RDADDR_MSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_RDADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_RDDATA_LSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20a
 * DEVAD:    1
 * DESC:     rmi to ahb read data LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_LSW These are the lower 16-bits of the read data from the AHB-Lite slave deviceRead transaction is initiated on the AHB-Lite when this register is read
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr (0x0001d20a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_lsw[1];
	uint32_t _uc_ahb_rddata_lsw;
} BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_CLR(r) (r).uc_ahb_rddata_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_SET(r,d) (r).uc_ahb_rddata_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_GET(r) (r).uc_ahb_rddata_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET(r) (((r).uc_ahb_rddata_lsw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET(r,f) (r).uc_ahb_rddata_lsw[0]=(((r).uc_ahb_rddata_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr,(_r._uc_ahb_rddata_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDDATA_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_LSWr BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr
#define UC_AHB_RDDATA_LSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_t UC_AHB_RDDATA_LSWr_t;
#define UC_AHB_RDDATA_LSWr_CLR BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_CLR
#define UC_AHB_RDDATA_LSWr_SET BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_SET
#define UC_AHB_RDDATA_LSWr_GET BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_GET
#define UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr_MICRO_RA_RDDATA_LSWf_SET
#define READ_UC_AHB_RDDATA_LSWr BCMI_FALCON_XGXS_READ_UC_AHB_RDDATA_LSWr
#define WRITE_UC_AHB_RDDATA_LSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_RDDATA_LSWr
#define MODIFY_UC_AHB_RDDATA_LSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDDATA_LSWr
#define READLN_UC_AHB_RDDATA_LSWr BCMI_FALCON_XGXS_READLN_UC_AHB_RDDATA_LSWr
#define WRITELN_UC_AHB_RDDATA_LSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDDATA_LSWr
#define WRITEALL_UC_AHB_RDDATA_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDDATA_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_RDDATA_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_AHB_RDDATA_MSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20b
 * DEVAD:    1
 * DESC:     rmi to ahb read data MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_RDDATA_MSW These are the upper 16-bits of the read data from the AHB-Lite slave device
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr (0x0001d20b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_AHB_RDDATA_MSW.
 */
typedef union BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_s {
	uint32_t v[1];
	uint32_t uc_ahb_rddata_msw[1];
	uint32_t _uc_ahb_rddata_msw;
} BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_t;

#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_CLR(r) (r).uc_ahb_rddata_msw[0] = 0
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_SET(r,d) (r).uc_ahb_rddata_msw[0] = d
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_GET(r) (r).uc_ahb_rddata_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET(r) (((r).uc_ahb_rddata_msw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET(r,f) (r).uc_ahb_rddata_msw[0]=(((r).uc_ahb_rddata_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_AHB_RDDATA_MSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_FALCON_XGXS_WRITE_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr,(_r._uc_ahb_rddata_msw))
#define BCMI_FALCON_XGXS_READLN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDDATA_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ahb_rddata_msw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ahb_rddata_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_AHB_RDDATA_MSWr BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr
#define UC_AHB_RDDATA_MSWr_SIZE BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_t UC_AHB_RDDATA_MSWr_t;
#define UC_AHB_RDDATA_MSWr_CLR BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_CLR
#define UC_AHB_RDDATA_MSWr_SET BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_SET
#define UC_AHB_RDDATA_MSWr_GET BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_GET
#define UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr_MICRO_RA_RDDATA_MSWf_SET
#define READ_UC_AHB_RDDATA_MSWr BCMI_FALCON_XGXS_READ_UC_AHB_RDDATA_MSWr
#define WRITE_UC_AHB_RDDATA_MSWr BCMI_FALCON_XGXS_WRITE_UC_AHB_RDDATA_MSWr
#define MODIFY_UC_AHB_RDDATA_MSWr BCMI_FALCON_XGXS_MODIFY_UC_AHB_RDDATA_MSWr
#define READLN_UC_AHB_RDDATA_MSWr BCMI_FALCON_XGXS_READLN_UC_AHB_RDDATA_MSWr
#define WRITELN_UC_AHB_RDDATA_MSWr BCMI_FALCON_XGXS_WRITELN_UC_AHB_RDDATA_MSWr
#define WRITEALL_UC_AHB_RDDATA_MSWr BCMI_FALCON_XGXS_WRITEALL_UC_AHB_RDDATA_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_AHB_RDDATA_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_PRAMIF_CTL0
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20c
 * DEVAD:    1
 * DESC:     pram i/f to ahb control registers 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_EN  When this bit is set, pram if interface can generate write transactions on theAHB-Lite bus, the start address of the transaction is specifieldin the pramif_ahb_wraddr_lsw and pramif_ahb_wraddr_msw fields
 */
#define BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r (0x0001d20c | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_pramif_ctl0[1];
	uint32_t _uc_pramif_ctl0;
} BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_CLR(r) (r).uc_pramif_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_SET(r,d) (r).uc_pramif_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_GET(r) (r).uc_pramif_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET(r) (((r).uc_pramif_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET(r,f) (r).uc_pramif_ctl0[0]=(((r).uc_pramif_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_PRAMIF_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r,(_r._uc_pramif_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_PRAMIF_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_PRAMIF_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_CTL0r BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r
#define UC_PRAMIF_CTL0r_SIZE BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_t UC_PRAMIF_CTL0r_t;
#define UC_PRAMIF_CTL0r_CLR BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_CLR
#define UC_PRAMIF_CTL0r_SET BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_SET
#define UC_PRAMIF_CTL0r_GET BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_GET
#define UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r_MICRO_PRAMIF_ENf_SET
#define READ_UC_PRAMIF_CTL0r BCMI_FALCON_XGXS_READ_UC_PRAMIF_CTL0r
#define WRITE_UC_PRAMIF_CTL0r BCMI_FALCON_XGXS_WRITE_UC_PRAMIF_CTL0r
#define MODIFY_UC_PRAMIF_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_PRAMIF_CTL0r
#define READLN_UC_PRAMIF_CTL0r BCMI_FALCON_XGXS_READLN_UC_PRAMIF_CTL0r
#define WRITELN_UC_PRAMIF_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_PRAMIF_CTL0r
#define WRITEALL_UC_PRAMIF_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_PRAMIF_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_PRAMIF_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_LSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20d
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_LSW These bits are used to generate the lower 14-bits of the address on the AHB-Lite bus during pram interface write transactionsbits[1:0] are not used for 32 transactions
 */
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr (0x0001d20d | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_lsw[1];
	uint32_t _uc_pramif_ahb_wraddr_lsw;
} BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t;

#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR(r) (r).uc_pramif_ahb_wraddr_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET(r) (r).uc_pramif_ahb_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET(r) ((((r).uc_pramif_ahb_wraddr_lsw[0]) >> 2) & 0x3fff)
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_lsw[0]=(((r).uc_pramif_ahb_wraddr_lsw[0] & ~((uint32_t)0x3fff << 2)) | ((((uint32_t)f) & 0x3fff) << 2)) | (16383 << (16 + 2))

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr,(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr
#define UC_PRAMIF_AHB_WRADDR_LSWr_SIZE BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_t UC_PRAMIF_AHB_WRADDR_LSWr_t;
#define UC_PRAMIF_AHB_WRADDR_LSWr_CLR BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_LSWr_SET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_SET
#define UC_PRAMIF_AHB_WRADDR_LSWr_GET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_GET
#define UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr_MICRO_PRAMIF_AHB_WRADDR_LSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_READ_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_LSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_LSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_LSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_PRAMIF_AHB_WRADDR_MSW
 * BLOCKS:   MICRO_A_COM
 * REGADDR:  0xd20e
 * DEVAD:    1
 * DESC:     pram i/f to ahb write address MSW (bits 31:16) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PRAMIF_AHB_WRADDR_MSW These bits are used to generate the upper 16-bits of the address on the AHB-Lite bus during pram interface write transactions
 */
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr (0x0001d20e | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_PRAMIF_AHB_WRADDR_MSW.
 */
typedef union BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_s {
	uint32_t v[1];
	uint32_t uc_pramif_ahb_wraddr_msw[1];
	uint32_t _uc_pramif_ahb_wraddr_msw;
} BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t;

#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR(r) (r).uc_pramif_ahb_wraddr_msw[0] = 0
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET(r,d) (r).uc_pramif_ahb_wraddr_msw[0] = d
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET(r) (r).uc_pramif_ahb_wraddr_msw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET(r) (((r).uc_pramif_ahb_wraddr_msw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET(r,f) (r).uc_pramif_ahb_wraddr_msw[0]=(((r).uc_pramif_ahb_wraddr_msw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_PRAMIF_AHB_WRADDR_MSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr,(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pramif_ahb_wraddr_msw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pramif_ahb_wraddr_msw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PRAMIF_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr
#define UC_PRAMIF_AHB_WRADDR_MSWr_SIZE BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_t UC_PRAMIF_AHB_WRADDR_MSWr_t;
#define UC_PRAMIF_AHB_WRADDR_MSWr_CLR BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_CLR
#define UC_PRAMIF_AHB_WRADDR_MSWr_SET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_SET
#define UC_PRAMIF_AHB_WRADDR_MSWr_GET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_GET
#define UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr_MICRO_PRAMIF_AHB_WRADDR_MSWf_SET
#define READ_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_READ_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITE_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_WRITE_UC_PRAMIF_AHB_WRADDR_MSWr
#define MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_MODIFY_UC_PRAMIF_AHB_WRADDR_MSWr
#define READLN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_READLN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_WRITELN_UC_PRAMIF_AHB_WRADDR_MSWr
#define WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr BCMI_FALCON_XGXS_WRITEALL_UC_PRAMIF_AHB_WRADDR_MSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_PRAMIF_AHB_WRADDR_MSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_PVT_STS0
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd210
 * DEVAD:    1
 * DESC:     pvt temperature status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_RMI temperature data{6'd0,tempearture_data[9:0]}reads the current value of the temperature data capatured
 */
#define BCMI_FALCON_XGXS_UC_PVT_STS0r (0x0001d210 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_PVT_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_PVT_STS0.
 */
typedef union BCMI_FALCON_XGXS_UC_PVT_STS0r_s {
	uint32_t v[1];
	uint32_t uc_pvt_sts0[1];
	uint32_t _uc_pvt_sts0;
} BCMI_FALCON_XGXS_UC_PVT_STS0r_t;

#define BCMI_FALCON_XGXS_UC_PVT_STS0r_CLR(r) (r).uc_pvt_sts0[0] = 0
#define BCMI_FALCON_XGXS_UC_PVT_STS0r_SET(r,d) (r).uc_pvt_sts0[0] = d
#define BCMI_FALCON_XGXS_UC_PVT_STS0r_GET(r) (r).uc_pvt_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET(r) (((r).uc_pvt_sts0[0]) & 0x3ff)
#define BCMI_FALCON_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET(r,f) (r).uc_pvt_sts0[0]=(((r).uc_pvt_sts0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_PVT_STS0.
 */
#define BCMI_FALCON_XGXS_READ_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_FALCON_XGXS_WRITE_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PVT_STS0r,(_r._uc_pvt_sts0))
#define BCMI_FALCON_XGXS_READLN_UC_PVT_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_FALCON_XGXS_WRITELN_UC_PVT_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_pvt_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_PVT_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_PVT_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_pvt_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_PVT_STS0r BCMI_FALCON_XGXS_UC_PVT_STS0r
#define UC_PVT_STS0r_SIZE BCMI_FALCON_XGXS_UC_PVT_STS0r_SIZE
typedef BCMI_FALCON_XGXS_UC_PVT_STS0r_t UC_PVT_STS0r_t;
#define UC_PVT_STS0r_CLR BCMI_FALCON_XGXS_UC_PVT_STS0r_CLR
#define UC_PVT_STS0r_SET BCMI_FALCON_XGXS_UC_PVT_STS0r_SET
#define UC_PVT_STS0r_GET BCMI_FALCON_XGXS_UC_PVT_STS0r_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET BCMI_FALCON_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_GET
#define UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET BCMI_FALCON_XGXS_UC_PVT_STS0r_MICRO_PVT_TEMPDATA_RMIf_SET
#define READ_UC_PVT_STS0r BCMI_FALCON_XGXS_READ_UC_PVT_STS0r
#define WRITE_UC_PVT_STS0r BCMI_FALCON_XGXS_WRITE_UC_PVT_STS0r
#define MODIFY_UC_PVT_STS0r BCMI_FALCON_XGXS_MODIFY_UC_PVT_STS0r
#define READLN_UC_PVT_STS0r BCMI_FALCON_XGXS_READLN_UC_PVT_STS0r
#define WRITELN_UC_PVT_STS0r BCMI_FALCON_XGXS_WRITELN_UC_PVT_STS0r
#define WRITEALL_UC_PVT_STS0r BCMI_FALCON_XGXS_WRITEALL_UC_PVT_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_PVT_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_TO_UC_MBOX0
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd211
 * DEVAD:    1
 * DESC:     rmi to micro mailbox register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_TO_MICRO_MBOX0 There bits represents bits [15:0] of the message from rmi to microWrite to this registers can optionaly generate an interrupt to the micro
 */
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r (0x0001d211 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_TO_UC_MBOX0.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_to_uc_mbox0[1];
	uint32_t _uc_rmi_to_uc_mbox0;
} BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_t;

#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_CLR(r) (r).uc_rmi_to_uc_mbox0[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_SET(r,d) (r).uc_rmi_to_uc_mbox0[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_GET(r) (r).uc_rmi_to_uc_mbox0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET(r) (((r).uc_rmi_to_uc_mbox0[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET(r,f) (r).uc_rmi_to_uc_mbox0[0]=(((r).uc_rmi_to_uc_mbox0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_TO_UC_MBOX0.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r,(_r._uc_rmi_to_uc_mbox0))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r,(_r._uc_rmi_to_uc_mbox0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r,(_r._uc_rmi_to_uc_mbox0))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_TO_UC_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox0))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_TO_UC_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_to_uc_mbox0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_TO_UC_MBOX0r BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r
#define UC_RMI_TO_UC_MBOX0r_SIZE BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_t UC_RMI_TO_UC_MBOX0r_t;
#define UC_RMI_TO_UC_MBOX0r_CLR BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_CLR
#define UC_RMI_TO_UC_MBOX0r_SET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_SET
#define UC_RMI_TO_UC_MBOX0r_GET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_GET
#define UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_GET
#define UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r_MICRO_RMI_TO_MICRO_MBOX0f_SET
#define READ_UC_RMI_TO_UC_MBOX0r BCMI_FALCON_XGXS_READ_UC_RMI_TO_UC_MBOX0r
#define WRITE_UC_RMI_TO_UC_MBOX0r BCMI_FALCON_XGXS_WRITE_UC_RMI_TO_UC_MBOX0r
#define MODIFY_UC_RMI_TO_UC_MBOX0r BCMI_FALCON_XGXS_MODIFY_UC_RMI_TO_UC_MBOX0r
#define READLN_UC_RMI_TO_UC_MBOX0r BCMI_FALCON_XGXS_READLN_UC_RMI_TO_UC_MBOX0r
#define WRITELN_UC_RMI_TO_UC_MBOX0r BCMI_FALCON_XGXS_WRITELN_UC_RMI_TO_UC_MBOX0r
#define WRITEALL_UC_RMI_TO_UC_MBOX0r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_TO_UC_MBOX1
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd212
 * DEVAD:    1
 * DESC:     rmi to micro mailbox register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_TO_MICRO_MBOX1 There bits represents bits [31:16] of the message from rmi to micro
 */
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r (0x0001d212 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_TO_UC_MBOX1.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_to_uc_mbox1[1];
	uint32_t _uc_rmi_to_uc_mbox1;
} BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_t;

#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_CLR(r) (r).uc_rmi_to_uc_mbox1[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_SET(r,d) (r).uc_rmi_to_uc_mbox1[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_GET(r) (r).uc_rmi_to_uc_mbox1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET(r) (((r).uc_rmi_to_uc_mbox1[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET(r,f) (r).uc_rmi_to_uc_mbox1[0]=(((r).uc_rmi_to_uc_mbox1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_TO_UC_MBOX1.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r,(_r._uc_rmi_to_uc_mbox1))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r,(_r._uc_rmi_to_uc_mbox1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r,(_r._uc_rmi_to_uc_mbox1))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_TO_UC_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox1))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_TO_UC_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_to_uc_mbox1))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_to_uc_mbox1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_TO_UC_MBOX1r BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r
#define UC_RMI_TO_UC_MBOX1r_SIZE BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_t UC_RMI_TO_UC_MBOX1r_t;
#define UC_RMI_TO_UC_MBOX1r_CLR BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_CLR
#define UC_RMI_TO_UC_MBOX1r_SET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_SET
#define UC_RMI_TO_UC_MBOX1r_GET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_GET
#define UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_GET
#define UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r_MICRO_RMI_TO_MICRO_MBOX1f_SET
#define READ_UC_RMI_TO_UC_MBOX1r BCMI_FALCON_XGXS_READ_UC_RMI_TO_UC_MBOX1r
#define WRITE_UC_RMI_TO_UC_MBOX1r BCMI_FALCON_XGXS_WRITE_UC_RMI_TO_UC_MBOX1r
#define MODIFY_UC_RMI_TO_UC_MBOX1r BCMI_FALCON_XGXS_MODIFY_UC_RMI_TO_UC_MBOX1r
#define READLN_UC_RMI_TO_UC_MBOX1r BCMI_FALCON_XGXS_READLN_UC_RMI_TO_UC_MBOX1r
#define WRITELN_UC_RMI_TO_UC_MBOX1r BCMI_FALCON_XGXS_WRITELN_UC_RMI_TO_UC_MBOX1r
#define WRITEALL_UC_RMI_TO_UC_MBOX1r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_TO_UC_MBOX1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_TO_UC_MBOX1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_UC_TO_RMI_MBOX0
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd213
 * DEVAD:    1
 * DESC:     micro to rmi mailbox register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_TO_RMI_MBOX0 There bits represents bits [15:0] of the message from rmi to micro
 */
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r (0x0001d213 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_TO_RMI_MBOX0.
 */
typedef union BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_s {
	uint32_t v[1];
	uint32_t uc_uc_to_rmi_mbox0[1];
	uint32_t _uc_uc_to_rmi_mbox0;
} BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_t;

#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_CLR(r) (r).uc_uc_to_rmi_mbox0[0] = 0
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_SET(r,d) (r).uc_uc_to_rmi_mbox0[0] = d
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_GET(r) (r).uc_uc_to_rmi_mbox0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET(r) (((r).uc_uc_to_rmi_mbox0[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET(r,f) (r).uc_uc_to_rmi_mbox0[0]=(((r).uc_uc_to_rmi_mbox0[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_TO_RMI_MBOX0.
 */
#define BCMI_FALCON_XGXS_READ_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r,(_r._uc_uc_to_rmi_mbox0))
#define BCMI_FALCON_XGXS_WRITE_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r,(_r._uc_uc_to_rmi_mbox0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r,(_r._uc_uc_to_rmi_mbox0))
#define BCMI_FALCON_XGXS_READLN_UC_UC_TO_RMI_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox0))
#define BCMI_FALCON_XGXS_WRITELN_UC_UC_TO_RMI_MBOX0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_to_rmi_mbox0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_TO_RMI_MBOX0r BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r
#define UC_UC_TO_RMI_MBOX0r_SIZE BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_SIZE
typedef BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_t UC_UC_TO_RMI_MBOX0r_t;
#define UC_UC_TO_RMI_MBOX0r_CLR BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_CLR
#define UC_UC_TO_RMI_MBOX0r_SET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_SET
#define UC_UC_TO_RMI_MBOX0r_GET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_GET
#define UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_GET
#define UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r_MICRO_TO_RMI_MBOX0f_SET
#define READ_UC_UC_TO_RMI_MBOX0r BCMI_FALCON_XGXS_READ_UC_UC_TO_RMI_MBOX0r
#define WRITE_UC_UC_TO_RMI_MBOX0r BCMI_FALCON_XGXS_WRITE_UC_UC_TO_RMI_MBOX0r
#define MODIFY_UC_UC_TO_RMI_MBOX0r BCMI_FALCON_XGXS_MODIFY_UC_UC_TO_RMI_MBOX0r
#define READLN_UC_UC_TO_RMI_MBOX0r BCMI_FALCON_XGXS_READLN_UC_UC_TO_RMI_MBOX0r
#define WRITELN_UC_UC_TO_RMI_MBOX0r BCMI_FALCON_XGXS_WRITELN_UC_UC_TO_RMI_MBOX0r
#define WRITEALL_UC_UC_TO_RMI_MBOX0r BCMI_FALCON_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_UC_TO_RMI_MBOX1
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd214
 * DEVAD:    1
 * DESC:     micro to rmi mailbox register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_TO_RMI_MBOX1 There bits represents bits [31:16] of the message from rmi to micro
 */
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r (0x0001d214 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_SIZE 4

/*
 * This structure should be used to declare and program UC_UC_TO_RMI_MBOX1.
 */
typedef union BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_s {
	uint32_t v[1];
	uint32_t uc_uc_to_rmi_mbox1[1];
	uint32_t _uc_uc_to_rmi_mbox1;
} BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_t;

#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_CLR(r) (r).uc_uc_to_rmi_mbox1[0] = 0
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_SET(r,d) (r).uc_uc_to_rmi_mbox1[0] = d
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_GET(r) (r).uc_uc_to_rmi_mbox1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET(r) (((r).uc_uc_to_rmi_mbox1[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET(r,f) (r).uc_uc_to_rmi_mbox1[0]=(((r).uc_uc_to_rmi_mbox1[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_UC_TO_RMI_MBOX1.
 */
#define BCMI_FALCON_XGXS_READ_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r,(_r._uc_uc_to_rmi_mbox1))
#define BCMI_FALCON_XGXS_WRITE_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r,(_r._uc_uc_to_rmi_mbox1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r,(_r._uc_uc_to_rmi_mbox1))
#define BCMI_FALCON_XGXS_READLN_UC_UC_TO_RMI_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox1))
#define BCMI_FALCON_XGXS_WRITELN_UC_UC_TO_RMI_MBOX1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_uc_to_rmi_mbox1))
#define BCMI_FALCON_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_uc_to_rmi_mbox1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_UC_TO_RMI_MBOX1r BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r
#define UC_UC_TO_RMI_MBOX1r_SIZE BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_SIZE
typedef BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_t UC_UC_TO_RMI_MBOX1r_t;
#define UC_UC_TO_RMI_MBOX1r_CLR BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_CLR
#define UC_UC_TO_RMI_MBOX1r_SET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_SET
#define UC_UC_TO_RMI_MBOX1r_GET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_GET
#define UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_GET
#define UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r_MICRO_TO_RMI_MBOX1f_SET
#define READ_UC_UC_TO_RMI_MBOX1r BCMI_FALCON_XGXS_READ_UC_UC_TO_RMI_MBOX1r
#define WRITE_UC_UC_TO_RMI_MBOX1r BCMI_FALCON_XGXS_WRITE_UC_UC_TO_RMI_MBOX1r
#define MODIFY_UC_UC_TO_RMI_MBOX1r BCMI_FALCON_XGXS_MODIFY_UC_UC_TO_RMI_MBOX1r
#define READLN_UC_UC_TO_RMI_MBOX1r BCMI_FALCON_XGXS_READLN_UC_UC_TO_RMI_MBOX1r
#define WRITELN_UC_UC_TO_RMI_MBOX1r BCMI_FALCON_XGXS_WRITELN_UC_UC_TO_RMI_MBOX1r
#define WRITEALL_UC_UC_TO_RMI_MBOX1r BCMI_FALCON_XGXS_WRITEALL_UC_UC_TO_RMI_MBOX1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_UC_TO_RMI_MBOX1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_MBOX_CTL0
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd215
 * DEVAD:    1
 * DESC:     rmi mailbox control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_MBOX_SEND_MSGIN Send message in (to the micro)This field is set by the RMIC to indicate to the Micro that the message in thermi_to_micro_mbox1, and rmi_to_micro_mbox0 regiters is valid.
 *     MICRO_GEN_INTR_RMI_MBOX0WR Generate interrupt when micro_rmi_to_micro_mbox0 field is written0 - disabled1 - enbled
 *     MICRO_GEN_INTR_RMI_MBOX1WR Generate interrupt when micro_rmi_to_micro_mbox1 field is written0 - disabled1 - enbled
 */
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r (0x0001d215 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_MBOX_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_mbox_ctl0[1];
	uint32_t _uc_rmi_mbox_ctl0;
} BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_CLR(r) (r).uc_rmi_mbox_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_SET(r,d) (r).uc_rmi_mbox_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_GET(r) (r).uc_rmi_mbox_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET(r) ((((r).uc_rmi_mbox_ctl0[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET(r) ((((r).uc_rmi_mbox_ctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET(r) (((r).uc_rmi_mbox_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET(r,f) (r).uc_rmi_mbox_ctl0[0]=(((r).uc_rmi_mbox_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_MBOX_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r,(_r._uc_rmi_mbox_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r,(_r._uc_rmi_mbox_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r,(_r._uc_rmi_mbox_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_MBOX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_mbox_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_MBOX_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_mbox_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_MBOX_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_mbox_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_MBOX_CTL0r BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r
#define UC_RMI_MBOX_CTL0r_SIZE BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_t UC_RMI_MBOX_CTL0r_t;
#define UC_RMI_MBOX_CTL0r_CLR BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_CLR
#define UC_RMI_MBOX_CTL0r_SET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_SET
#define UC_RMI_MBOX_CTL0r_GET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX1WRf_SET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_GEN_INTR_RMI_MBOX0WRf_SET
#define UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_GET
#define UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r_MICRO_RMI_MBOX_SEND_MSGINf_SET
#define READ_UC_RMI_MBOX_CTL0r BCMI_FALCON_XGXS_READ_UC_RMI_MBOX_CTL0r
#define WRITE_UC_RMI_MBOX_CTL0r BCMI_FALCON_XGXS_WRITE_UC_RMI_MBOX_CTL0r
#define MODIFY_UC_RMI_MBOX_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_RMI_MBOX_CTL0r
#define READLN_UC_RMI_MBOX_CTL0r BCMI_FALCON_XGXS_READLN_UC_RMI_MBOX_CTL0r
#define WRITELN_UC_RMI_MBOX_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_RMI_MBOX_CTL0r
#define WRITEALL_UC_RMI_MBOX_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_MBOX_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_MBOX_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_AHB_CTL1
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd216
 * DEVAD:    1
 * DESC:     ahb control register 1
 * RESETVAL: 0x7 (7)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_M0_HRESP_EN m0 response error signaling enable0 - disabled1 - enabled
 *     MICRO_SW_PMI_HP_RSTB Software reset pmi_hp interface logicThis bit is to initialize the pmi_hp block0 - reset asserted1 - reset de-asserted
 *     MICRO_SW_PMI_HP_EXT_RSTB Software reset pmi_hp_ext interface logicThis bit is to initialize the pmi_hp_ext block0 - reset asserted1 - reset de-asserted
 */
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r (0x0001d216 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_CTL1.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_ctl1[1];
	uint32_t _uc_rmi_ahb_ctl1;
} BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_t;

#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_CLR(r) (r).uc_rmi_ahb_ctl1[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_SET(r,d) (r).uc_rmi_ahb_ctl1[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_GET(r) (r).uc_rmi_ahb_ctl1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET(r) ((((r).uc_rmi_ahb_ctl1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET(r) (((r).uc_rmi_ahb_ctl1[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET(r,f) (r).uc_rmi_ahb_ctl1[0]=(((r).uc_rmi_ahb_ctl1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_CTL1.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r,(_r._uc_rmi_ahb_ctl1))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_AHB_CTL1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_ctl1))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_AHB_CTL1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_ctl1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_CTL1r BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r
#define UC_RMI_AHB_CTL1r_SIZE BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_t UC_RMI_AHB_CTL1r_t;
#define UC_RMI_AHB_CTL1r_CLR BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_CLR
#define UC_RMI_AHB_CTL1r_SET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_SET
#define UC_RMI_AHB_CTL1r_GET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_GET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_GET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_EXT_RSTBf_SET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_GET
#define UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_SW_PMI_HP_RSTBf_SET
#define UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_GET
#define UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r_MICRO_M0_HRESP_ENf_SET
#define READ_UC_RMI_AHB_CTL1r BCMI_FALCON_XGXS_READ_UC_RMI_AHB_CTL1r
#define WRITE_UC_RMI_AHB_CTL1r BCMI_FALCON_XGXS_WRITE_UC_RMI_AHB_CTL1r
#define MODIFY_UC_RMI_AHB_CTL1r BCMI_FALCON_XGXS_MODIFY_UC_RMI_AHB_CTL1r
#define READLN_UC_RMI_AHB_CTL1r BCMI_FALCON_XGXS_READLN_UC_RMI_AHB_CTL1r
#define WRITELN_UC_RMI_AHB_CTL1r BCMI_FALCON_XGXS_WRITELN_UC_RMI_AHB_CTL1r
#define WRITEALL_UC_RMI_AHB_CTL1r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_AHB_CTL1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_AHB_CTL1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_AHB_STS1
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd217
 * DEVAD:    1
 * DESC:     ahb status register 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_M0_DEFAULT_SLAVE_ERROR m0 default slave error detected. M0 attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_RMI_DEFAULT_SLAVE_ERROR register interface default slave error detected. Register interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 *     MICRO_PR_DEFAULT_SLAVE_ERROR PRAM interface default slave error detected. PRAM interface attempted to access un-used address1 - error detected - latched high clear on read0 - no error
 */
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r (0x0001d217 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_AHB_STS1.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ahb_sts1[1];
	uint32_t _uc_rmi_ahb_sts1;
} BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_t;

#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_CLR(r) (r).uc_rmi_ahb_sts1[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_SET(r,d) (r).uc_rmi_ahb_sts1[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_GET(r) (r).uc_rmi_ahb_sts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET(r) ((((r).uc_rmi_ahb_sts1[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET(r) (((r).uc_rmi_ahb_sts1[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET(r,f) (r).uc_rmi_ahb_sts1[0]=(((r).uc_rmi_ahb_sts1[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_AHB_STS1.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r,(_r._uc_rmi_ahb_sts1))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_AHB_STS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ahb_sts1))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_AHB_STS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ahb_sts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_AHB_STS1r BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r
#define UC_RMI_AHB_STS1r_SIZE BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_t UC_RMI_AHB_STS1r_t;
#define UC_RMI_AHB_STS1r_CLR BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_CLR
#define UC_RMI_AHB_STS1r_SET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_SET
#define UC_RMI_AHB_STS1r_GET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_PR_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_RMI_DEFAULT_SLAVE_ERRORf_SET
#define UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_GET
#define UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r_MICRO_M0_DEFAULT_SLAVE_ERRORf_SET
#define READ_UC_RMI_AHB_STS1r BCMI_FALCON_XGXS_READ_UC_RMI_AHB_STS1r
#define WRITE_UC_RMI_AHB_STS1r BCMI_FALCON_XGXS_WRITE_UC_RMI_AHB_STS1r
#define MODIFY_UC_RMI_AHB_STS1r BCMI_FALCON_XGXS_MODIFY_UC_RMI_AHB_STS1r
#define READLN_UC_RMI_AHB_STS1r BCMI_FALCON_XGXS_READLN_UC_RMI_AHB_STS1r
#define WRITELN_UC_RMI_AHB_STS1r BCMI_FALCON_XGXS_WRITELN_UC_RMI_AHB_STS1r
#define WRITEALL_UC_RMI_AHB_STS1r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_AHB_STS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_AHB_STS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd218
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_WRADDR_LSW When the micro_autoinc_wraddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr (0x0001d218 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_wraddr_lsw;
} BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t UC_RMI_RA_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr_MICRO_RA_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_READ_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_WRITE_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_READLN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_RA_AINC_NXT_RDADDR_LSW
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd219
 * DEVAD:    1
 * DESC:     rmi to ahb auto-incremented read address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_AUTOINC_NXT_RDADDR_LSW When the micro_autoinc_rdaddr_en is set, then these bitsindicate the lower 16-bits of the address that will be usedduring the next read transaction.These bits allow address tracking when rmi interface auto addressincrement mode is used
 */
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr (0x0001d219 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_ra_ainc_nxt_rdaddr_lsw[1];
	uint32_t _uc_rmi_ra_ainc_nxt_rdaddr_lsw;
} BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;

#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET(r,d) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET(r) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET(r) (((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET(r,f) (r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0]=(((r).uc_rmi_ra_ainc_nxt_rdaddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_RA_AINC_NXT_RDADDR_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ra_ainc_nxt_rdaddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t UC_RMI_RA_AINC_NXT_RDADDR_LSWr_t;
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_CLR
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_SET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_GET
#define UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr_MICRO_RA_AUTOINC_NXT_RDADDR_LSWf_SET
#define READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_FALCON_XGXS_READ_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_FALCON_XGXS_WRITE_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_FALCON_XGXS_MODIFY_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_FALCON_XGXS_READLN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_FALCON_XGXS_WRITELN_UC_RMI_RA_AINC_NXT_RDADDR_LSWr
#define WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_RMI_RA_AINC_NXT_RDADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_RA_AINC_NXT_RDADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_PR_AINC_NXT_WRADDR_LSW
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd21a
 * DEVAD:    1
 * DESC:     pram i/f to ahb auto-incremented write address LSW (bits 15:0) register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_PR_AUTOINC_NXT_WRADDR_LSW When pram interface is used to write to the code/data RAMthen these bits indicate the lower 16-bits of the address that will be usedduring the next write transaction.These bits allow address tracking
 */
#define BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr (0x0001d21a | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_s {
	uint32_t v[1];
	uint32_t uc_rmi_pr_ainc_nxt_wraddr_lsw[1];
	uint32_t _uc_rmi_pr_ainc_nxt_wraddr_lsw;
} BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;

#define BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET(r,d) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET(r) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET(r) (((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]) & 0xffff)
#define BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET(r,f) (r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0]=(((r).uc_rmi_pr_ainc_nxt_wraddr_lsw[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access UC_RMI_PR_AINC_NXT_WRADDR_LSW.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pr_ainc_nxt_wraddr_lsw))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t UC_RMI_PR_AINC_NXT_WRADDR_LSWr_t;
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_CLR
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_SET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_GET
#define UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr_MICRO_PR_AUTOINC_NXT_WRADDR_LSWf_SET
#define READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_READ_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_WRITE_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_MODIFY_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_READLN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_WRITELN_UC_RMI_PR_AINC_NXT_WRADDR_LSWr
#define WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr BCMI_FALCON_XGXS_WRITEALL_UC_RMI_PR_AINC_NXT_WRADDR_LSWr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_PR_AINC_NXT_WRADDR_LSWr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_PVT_CTL0
 * BLOCKS:   MICRO_B_COM
 * REGADDR:  0xd21b
 * DEVAD:    1
 * DESC:     rmi pvt temperature control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_PVT_TEMPDATA_FRCVAL temperature data force valueWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 *     MICRO_PVT_TEMPDATA_FRC temperature dat force enableWhen micro_pvt_tempdata_frc field is set to 1'b1 then micro_pvt_tempdata_frcvalfield is used to set the temperature value. The temperature value can be readvia micro_pvt_tempdata_rmi field of the pvt_status0 register orvia ahbcommon_pvt_tempdata filed of the ahbcommon_pvt_tempdata register
 */
#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r (0x0001d21b | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_PVT_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_pvt_ctl0[1];
	uint32_t _uc_rmi_pvt_ctl0;
} BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_CLR(r) (r).uc_rmi_pvt_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_SET(r,d) (r).uc_rmi_pvt_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_GET(r) (r).uc_rmi_pvt_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET(r) ((((r).uc_rmi_pvt_ctl0[0]) >> 12) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x1 << 12)) | ((((uint32_t)f) & 0x1) << 12)) | (1 << (16 + 12))
#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET(r) (((r).uc_rmi_pvt_ctl0[0]) & 0x3ff)
#define BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET(r,f) (r).uc_rmi_pvt_ctl0[0]=(((r).uc_rmi_pvt_ctl0[0] & ~((uint32_t)0x3ff)) | (((uint32_t)f) & 0x3ff)) | (0x3ff << 16)

/*
 * These macros can be used to access UC_RMI_PVT_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r,(_r._uc_rmi_pvt_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_PVT_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_pvt_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_PVT_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_pvt_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_PVT_CTL0r BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r
#define UC_RMI_PVT_CTL0r_SIZE BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_t UC_RMI_PVT_CTL0r_t;
#define UC_RMI_PVT_CTL0r_CLR BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_CLR
#define UC_RMI_PVT_CTL0r_SET BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_SET
#define UC_RMI_PVT_CTL0r_GET BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCf_SET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_GET
#define UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r_MICRO_PVT_TEMPDATA_FRCVALf_SET
#define READ_UC_RMI_PVT_CTL0r BCMI_FALCON_XGXS_READ_UC_RMI_PVT_CTL0r
#define WRITE_UC_RMI_PVT_CTL0r BCMI_FALCON_XGXS_WRITE_UC_RMI_PVT_CTL0r
#define MODIFY_UC_RMI_PVT_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_RMI_PVT_CTL0r
#define READLN_UC_RMI_PVT_CTL0r BCMI_FALCON_XGXS_READLN_UC_RMI_PVT_CTL0r
#define WRITELN_UC_RMI_PVT_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_RMI_PVT_CTL0r
#define WRITEALL_UC_RMI_PVT_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_PVT_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_PVT_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_CODE_RAM_ECCCTL0
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd220
 * DEVAD:    1
 * DESC:     code ram ecc control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_ECCG_MODE  ecc code generation mode0: Hardware mode - ECC code generated by hardware, ECC error checking enabled1: Software mode - ECC code from the rg_ra_ecc_wrdata field are written into code/data RAMECC error checking disabled. This mode is only supportedwhen register interface is used
 *     MICRO_ECC_FRC_DISABLE ecc force disable0: ECC Enabled  - ECC error code generation determine by the micro_eccg_mode fieldECC error checking enabled in hardware mode only1: ECC Disabled - ECC error codes values written into the RAM set to zeroECC error checking disabled
 *     MICRO_ECC_CORRUPT This field allows the ecc codes to be corrupted for testing.2'b00 - normal mode2'b01 - corrupt the ECC code written into the code/data RAM2'b10 - corrupt data - add 1 bit data error on the RX side2'b11 - corrupt data - add 2 bit data error on the RA side
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r (0x0001d220 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCCTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccctl0[1];
	uint32_t _uc_code_ram_eccctl0;
} BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_t;

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_CLR(r) (r).uc_code_ram_eccctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_SET(r,d) (r).uc_code_ram_eccctl0[0] = d
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_GET(r) (r).uc_code_ram_eccctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET(r) ((((r).uc_code_ram_eccctl0[0]) >> 4) & 0x3)
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x3 << 4)) | ((((uint32_t)f) & 0x3) << 4)) | (3 << (16 + 4))
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET(r) ((((r).uc_code_ram_eccctl0[0]) >> 1) & 0x1)
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x1 << 1)) | ((((uint32_t)f) & 0x1) << 1)) | (1 << (16 + 1))
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET(r) (((r).uc_code_ram_eccctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET(r,f) (r).uc_code_ram_eccctl0[0]=(((r).uc_code_ram_eccctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCCTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r,(_r._uc_code_ram_eccctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r,(_r._uc_code_ram_eccctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r,(_r._uc_code_ram_eccctl0))
#define BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCCTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCCTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_eccctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCCTL0r BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r
#define UC_CODE_RAM_ECCCTL0r_SIZE BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_t UC_CODE_RAM_ECCCTL0r_t;
#define UC_CODE_RAM_ECCCTL0r_CLR BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_CLR
#define UC_CODE_RAM_ECCCTL0r_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_SET
#define UC_CODE_RAM_ECCCTL0r_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_CORRUPTf_SET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECC_FRC_DISABLEf_SET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_GET
#define UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r_MICRO_ECCG_MODEf_SET
#define READ_UC_CODE_RAM_ECCCTL0r BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCCTL0r
#define WRITE_UC_CODE_RAM_ECCCTL0r BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCCTL0r
#define MODIFY_UC_CODE_RAM_ECCCTL0r BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCCTL0r
#define READLN_UC_CODE_RAM_ECCCTL0r BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCCTL0r
#define WRITELN_UC_CODE_RAM_ECCCTL0r BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCCTL0r
#define WRITEALL_UC_CODE_RAM_ECCCTL0r BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_CODE_RAM_ECCCONTRO1
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd221
 * DEVAD:    1
 * DESC:     code ram ecc control 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RA_ECC_WRDATA This foield is used to write the ECC codes into the code/data when ECC software modes is enabled
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r (0x0001d221 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCCONTRO1.
 */
typedef union BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_ecccontro1[1];
	uint32_t _uc_code_ram_ecccontro1;
} BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_t;

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_CLR(r) (r).uc_code_ram_ecccontro1[0] = 0
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_SET(r,d) (r).uc_code_ram_ecccontro1[0] = d
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_GET(r) (r).uc_code_ram_ecccontro1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET(r) (((r).uc_code_ram_ecccontro1[0]) & 0x7f)
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET(r,f) (r).uc_code_ram_ecccontro1[0]=(((r).uc_code_ram_ecccontro1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCCONTRO1.
 */
#define BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r,(_r._uc_code_ram_ecccontro1))
#define BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r,(_r._uc_code_ram_ecccontro1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r,(_r._uc_code_ram_ecccontro1))
#define BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCCONTRO1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_ecccontro1))
#define BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCCONTRO1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_ecccontro1))
#define BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCCONTRO1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_ecccontro1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCCONTRO1r BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r
#define UC_CODE_RAM_ECCCONTRO1r_SIZE BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_SIZE
typedef BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_t UC_CODE_RAM_ECCCONTRO1r_t;
#define UC_CODE_RAM_ECCCONTRO1r_CLR BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_CLR
#define UC_CODE_RAM_ECCCONTRO1r_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_SET
#define UC_CODE_RAM_ECCCONTRO1r_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_GET
#define UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_GET
#define UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r_MICRO_RA_ECC_WRDATAf_SET
#define READ_UC_CODE_RAM_ECCCONTRO1r BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCCONTRO1r
#define WRITE_UC_CODE_RAM_ECCCONTRO1r BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCCONTRO1r
#define MODIFY_UC_CODE_RAM_ECCCONTRO1r BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCCONTRO1r
#define READLN_UC_CODE_RAM_ECCCONTRO1r BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCCONTRO1r
#define WRITELN_UC_CODE_RAM_ECCCONTRO1r BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCCONTRO1r
#define WRITEALL_UC_CODE_RAM_ECCCONTRO1r BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCCONTRO1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_CODE_RAM_ECCCONTRO1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_CODE_RAM_ECCSTS0
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd222
 * DEVAD:    1
 * DESC:     code ram ecc status 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_CODE_RAM_ECC_ADDRESS First ecc error address
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r (0x0001d222 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCSTS0.
 */
typedef union BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccsts0[1];
	uint32_t _uc_code_ram_eccsts0;
} BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_t;

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_CLR(r) (r).uc_code_ram_eccsts0[0] = 0
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_SET(r,d) (r).uc_code_ram_eccsts0[0] = d
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_GET(r) (r).uc_code_ram_eccsts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET(r) (((r).uc_code_ram_eccsts0[0]) & 0x7fff)
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET(r,f) (r).uc_code_ram_eccsts0[0]=(((r).uc_code_ram_eccsts0[0] & ~((uint32_t)0x7fff)) | (((uint32_t)f) & 0x7fff)) | (0x7fff << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCSTS0.
 */
#define BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r,(_r._uc_code_ram_eccsts0))
#define BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r,(_r._uc_code_ram_eccsts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r,(_r._uc_code_ram_eccsts0))
#define BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCSTS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts0))
#define BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCSTS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_eccsts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCSTS0r BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r
#define UC_CODE_RAM_ECCSTS0r_SIZE BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_SIZE
typedef BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_t UC_CODE_RAM_ECCSTS0r_t;
#define UC_CODE_RAM_ECCSTS0r_CLR BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_CLR
#define UC_CODE_RAM_ECCSTS0r_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_SET
#define UC_CODE_RAM_ECCSTS0r_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_GET
#define UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_GET
#define UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r_MICRO_CODE_RAM_ECC_ADDRESSf_SET
#define READ_UC_CODE_RAM_ECCSTS0r BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCSTS0r
#define WRITE_UC_CODE_RAM_ECCSTS0r BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCSTS0r
#define MODIFY_UC_CODE_RAM_ECCSTS0r BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCSTS0r
#define READLN_UC_CODE_RAM_ECCSTS0r BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCSTS0r
#define WRITELN_UC_CODE_RAM_ECCSTS0r BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCSTS0r
#define WRITEALL_UC_CODE_RAM_ECCSTS0r BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_CODE_RAM_ECCSTS1
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd223
 * DEVAD:    1
 * DESC:     code ram ecc status 1
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RA_ECC_RDDATA When the register interface is used to read code/data RAM, then this field can be usedread the ECC codes currently stored in the code/data RAM
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r (0x0001d223 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_ECCSTS1.
 */
typedef union BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_eccsts1[1];
	uint32_t _uc_code_ram_eccsts1;
} BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_t;

#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_CLR(r) (r).uc_code_ram_eccsts1[0] = 0
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_SET(r,d) (r).uc_code_ram_eccsts1[0] = d
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_GET(r) (r).uc_code_ram_eccsts1[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET(r) (((r).uc_code_ram_eccsts1[0]) & 0x7f)
#define BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET(r,f) (r).uc_code_ram_eccsts1[0]=(((r).uc_code_ram_eccsts1[0] & ~((uint32_t)0x7f)) | (((uint32_t)f) & 0x7f)) | (0x7f << 16)

/*
 * These macros can be used to access UC_CODE_RAM_ECCSTS1.
 */
#define BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r,(_r._uc_code_ram_eccsts1))
#define BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r,(_r._uc_code_ram_eccsts1)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r,(_r._uc_code_ram_eccsts1))
#define BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCSTS1r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts1))
#define BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCSTS1r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_eccsts1))
#define BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS1r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_eccsts1))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_ECCSTS1r BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r
#define UC_CODE_RAM_ECCSTS1r_SIZE BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_SIZE
typedef BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_t UC_CODE_RAM_ECCSTS1r_t;
#define UC_CODE_RAM_ECCSTS1r_CLR BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_CLR
#define UC_CODE_RAM_ECCSTS1r_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_SET
#define UC_CODE_RAM_ECCSTS1r_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_GET
#define UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_GET
#define UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r_MICRO_RA_ECC_RDDATAf_SET
#define READ_UC_CODE_RAM_ECCSTS1r BCMI_FALCON_XGXS_READ_UC_CODE_RAM_ECCSTS1r
#define WRITE_UC_CODE_RAM_ECCSTS1r BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_ECCSTS1r
#define MODIFY_UC_CODE_RAM_ECCSTS1r BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_ECCSTS1r
#define READLN_UC_CODE_RAM_ECCSTS1r BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_ECCSTS1r
#define WRITELN_UC_CODE_RAM_ECCSTS1r BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_ECCSTS1r
#define WRITEALL_UC_CODE_RAM_ECCSTS1r BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_ECCSTS1r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_CODE_RAM_ECCSTS1r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_CODE_RAM_TESTIFCTL0
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd224
 * DEVAD:    1
 * DESC:     code ram test interface control 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_CODE_RAM_TM Test Mode.These pins are used to put the instance into various testmodes that can be used for a number of different purposesincluding extended screening, yield improvement and debug.The default mode of the instance is tm<13:0>=14'b0. It ishighly recommended that the user has control over all thetm<13:0> inputs. All tm<13:0> inputs are asynchronous. Seethe Test Modes section of the on line M28SP WebSpecification for further details.
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r (0x0001d224 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_CODE_RAM_TESTIFCTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_s {
	uint32_t v[1];
	uint32_t uc_code_ram_testifctl0[1];
	uint32_t _uc_code_ram_testifctl0;
} BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_t;

#define BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_CLR(r) (r).uc_code_ram_testifctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_SET(r,d) (r).uc_code_ram_testifctl0[0] = d
#define BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_GET(r) (r).uc_code_ram_testifctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET(r) (((r).uc_code_ram_testifctl0[0]) & 0x3fff)
#define BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET(r,f) (r).uc_code_ram_testifctl0[0]=(((r).uc_code_ram_testifctl0[0] & ~((uint32_t)0x3fff)) | (((uint32_t)f) & 0x3fff)) | (0x3fff << 16)

/*
 * These macros can be used to access UC_CODE_RAM_TESTIFCTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r,(_r._uc_code_ram_testifctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r,(_r._uc_code_ram_testifctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r,(_r._uc_code_ram_testifctl0))
#define BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_testifctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_TESTIFCTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_code_ram_testifctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_TESTIFCTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_code_ram_testifctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_CODE_RAM_TESTIFCTL0r BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r
#define UC_CODE_RAM_TESTIFCTL0r_SIZE BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_t UC_CODE_RAM_TESTIFCTL0r_t;
#define UC_CODE_RAM_TESTIFCTL0r_CLR BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_CLR
#define UC_CODE_RAM_TESTIFCTL0r_SET BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_SET
#define UC_CODE_RAM_TESTIFCTL0r_GET BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_GET
#define UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_GET
#define UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r_MICRO_CODE_RAM_TMf_SET
#define READ_UC_CODE_RAM_TESTIFCTL0r BCMI_FALCON_XGXS_READ_UC_CODE_RAM_TESTIFCTL0r
#define WRITE_UC_CODE_RAM_TESTIFCTL0r BCMI_FALCON_XGXS_WRITE_UC_CODE_RAM_TESTIFCTL0r
#define MODIFY_UC_CODE_RAM_TESTIFCTL0r BCMI_FALCON_XGXS_MODIFY_UC_CODE_RAM_TESTIFCTL0r
#define READLN_UC_CODE_RAM_TESTIFCTL0r BCMI_FALCON_XGXS_READLN_UC_CODE_RAM_TESTIFCTL0r
#define WRITELN_UC_CODE_RAM_TESTIFCTL0r BCMI_FALCON_XGXS_WRITELN_UC_CODE_RAM_TESTIFCTL0r
#define WRITEALL_UC_CODE_RAM_TESTIFCTL0r BCMI_FALCON_XGXS_WRITEALL_UC_CODE_RAM_TESTIFCTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_CODE_RAM_TESTIFCTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RAM_CTL0
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd225
 * DEVAD:    1
 * DESC:     ram configuration register 0
 * RESETVAL: 0x401 (1025)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_DR_LOOKTAB_EN Data RAM lookup table enable1 - Data RAM mapped in the data region by hardwarestarting at address 0x2000_0000 (for software compatibilty)0 - Data RAM not mapped by hardwareFirmware defines code/data regiions
 *     MICRO_DR_SIZE    Data/Code RAM allocation when the micro_dr_looktab_en field is set to 1'b1The RAM is 36KB and this field can be used to allocate data/code RAM on a 1KB granualarity6'd0  : Data RAM = 0KB,  Code RAM = 36KB6'd1  : Data RAM = 1KB,  Code RAM = 35KB6'd2  : Data RAM = 2KB,  Code RAM = 34KB...   : Data RAM = .. ,  Code RAM = .....   : Data RAM = .. ,  Code RAM = ..6'd35 : Data RAM = 35KB, Code RAM = 1KB6'd36 : Data RAM = 36KB, Code RAM = 0KBPLEASE NOTE: the micro in the PMD core does not have any additional RAM to store Code/Datatherfore a value of 0 and 36 should not be used
 */
#define BCMI_FALCON_XGXS_UC_RAM_CTL0r (0x0001d225 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RAM_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_RAM_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_ram_ctl0[1];
	uint32_t _uc_ram_ctl0;
} BCMI_FALCON_XGXS_UC_RAM_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_CLR(r) (r).uc_ram_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_SET(r,d) (r).uc_ram_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_GET(r) (r).uc_ram_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_GET(r) ((((r).uc_ram_ctl0[0]) >> 8) & 0x3f)
#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x3f << 8)) | ((((uint32_t)f) & 0x3f) << 8)) | (63 << (16 + 8))
#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET(r) (((r).uc_ram_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET(r,f) (r).uc_ram_ctl0[0]=(((r).uc_ram_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RAM_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RAM_CTL0r,(_r._uc_ram_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_RAM_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_ram_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RAM_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RAM_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_ram_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RAM_CTL0r BCMI_FALCON_XGXS_UC_RAM_CTL0r
#define UC_RAM_CTL0r_SIZE BCMI_FALCON_XGXS_UC_RAM_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_RAM_CTL0r_t UC_RAM_CTL0r_t;
#define UC_RAM_CTL0r_CLR BCMI_FALCON_XGXS_UC_RAM_CTL0r_CLR
#define UC_RAM_CTL0r_SET BCMI_FALCON_XGXS_UC_RAM_CTL0r_SET
#define UC_RAM_CTL0r_GET BCMI_FALCON_XGXS_UC_RAM_CTL0r_GET
#define UC_RAM_CTL0r_MICRO_DR_SIZEf_GET BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_GET
#define UC_RAM_CTL0r_MICRO_DR_SIZEf_SET BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_SIZEf_SET
#define UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_GET
#define UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET BCMI_FALCON_XGXS_UC_RAM_CTL0r_MICRO_DR_LOOKTAB_ENf_SET
#define READ_UC_RAM_CTL0r BCMI_FALCON_XGXS_READ_UC_RAM_CTL0r
#define WRITE_UC_RAM_CTL0r BCMI_FALCON_XGXS_WRITE_UC_RAM_CTL0r
#define MODIFY_UC_RAM_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_RAM_CTL0r
#define READLN_UC_RAM_CTL0r BCMI_FALCON_XGXS_READLN_UC_RAM_CTL0r
#define WRITELN_UC_RAM_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_RAM_CTL0r
#define WRITEALL_UC_RAM_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_RAM_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RAM_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_CTL0
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd226
 * DEVAD:    1
 * DESC:     rmi external interrupt control register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MICRO_RMI_MBOX_MSGOUT_INTR_EN Message out (from Micro) interrupt enableWhen this field is set to 1'b1 then the micro_rmi_mbox_msgout_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_CORR_ERR_INTR_EN ECC 1 bit correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_corr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_UNCORR_ERR_INTR_EN ECC 2 bit un-correctable error detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_uncorr_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_ECC_MULTIROW_ERR_INTR_EN ECC error on multiple row detect interrupt enableWhen this field is set to 1'b1 then the micro_rmi_ecc_multirow_err_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0_LOCKUP_INTR_EN M0 lockup interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_lockup_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 *     MICRO_RMI_M0_SYSTEMRESETREQ_INTR_EN M0 systemresetreq interrupt enableWhen this field is set to 1'b1 then the micro_rmi_m0_systemresetreq_status field of the rmi_ext_intr_status0registers generate an interrupt on the micro_ext_intr pin
 */
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r (0x0001d226 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_CTL0.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_ctl0[1];
	uint32_t _uc_rmi_ext_intr_ctl0;
} BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_t;

#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR(r) (r).uc_rmi_ext_intr_ctl0[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_SET(r,d) (r).uc_rmi_ext_intr_ctl0[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_GET(r) (r).uc_rmi_ext_intr_ctl0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET(r) ((((r).uc_rmi_ext_intr_ctl0[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET(r) (((r).uc_rmi_ext_intr_ctl0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET(r,f) (r).uc_rmi_ext_intr_ctl0[0]=(((r).uc_rmi_ext_intr_ctl0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_CTL0.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r,(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_ctl0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_ctl0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_CTL0r BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r
#define UC_RMI_EXT_INTR_CTL0r_SIZE BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_t UC_RMI_EXT_INTR_CTL0r_t;
#define UC_RMI_EXT_INTR_CTL0r_CLR BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_CLR
#define UC_RMI_EXT_INTR_CTL0r_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_SET
#define UC_RMI_EXT_INTR_CTL0r_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_SYSTEMRESETREQ_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_M0_LOCKUP_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_MULTIROW_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_UNCORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_ECC_CORR_ERR_INTR_ENf_SET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_GET
#define UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r_MICRO_RMI_MBOX_MSGOUT_INTR_ENf_SET
#define READ_UC_RMI_EXT_INTR_CTL0r BCMI_FALCON_XGXS_READ_UC_RMI_EXT_INTR_CTL0r
#define WRITE_UC_RMI_EXT_INTR_CTL0r BCMI_FALCON_XGXS_WRITE_UC_RMI_EXT_INTR_CTL0r
#define MODIFY_UC_RMI_EXT_INTR_CTL0r BCMI_FALCON_XGXS_MODIFY_UC_RMI_EXT_INTR_CTL0r
#define READLN_UC_RMI_EXT_INTR_CTL0r BCMI_FALCON_XGXS_READLN_UC_RMI_EXT_INTR_CTL0r
#define WRITELN_UC_RMI_EXT_INTR_CTL0r BCMI_FALCON_XGXS_WRITELN_UC_RMI_EXT_INTR_CTL0r
#define WRITEALL_UC_RMI_EXT_INTR_CTL0r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_EXT_INTR_CTL0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_CTL0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  UC_RMI_EXT_INTR_STS0
 * BLOCKS:   MICRO_C_COM
 * REGADDR:  0xd227
 * DEVAD:    1
 * DESC:     rmi external interrupt status register 0
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/O
 * FIELDS:
 *     MICRO_RMI_MBOX_MSGOUT_STATUS Message out (from Micro) statusThis field is set to 1'b1 when the RMIC receives a message from the Micro.It indicates to the RMIC that the message on the micro_to_rmi_mbox3,micro_to_rmi_mbox2, micro_to_rmi_mbox1 and micro_to_rmi_mbox0 registers is validThis bits remain remains set until this register is read
 *     MICRO_RMI_ECC_CORR_ERR_STATUS ECC 1 bit correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_ECC_UNCORR_ERR_STATUS ECC 2 bit un-correctable error detected statusThis field is set to 1'b1 when the ECC logic detects one bit un-correctable error.This bits remain remains set until this register is read
 *     MICRO_RMI_ECC_MULTIROW_ERR_STATUS ECC error on multiple row detected  statusThis field is set to 1'b1 when the ECC logic detects correctable or uncorrecatble errors on multiple rows.This bits remain remains set until this register is read
 *     MICRO_RMI_M0_LOCKUP_STATUS M0 lockup statusThis field indicates the status of the M0 "lockup" signal
 *     MICRO_RMI_M0_SYSTEMRESETREQ_STATUS M0 systemresetreq statusThis field indicates the status of the M0 "systemresetreq" signal
 */
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r (0x0001d227 | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE 4

/*
 * This structure should be used to declare and program UC_RMI_EXT_INTR_STS0.
 */
typedef union BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_s {
	uint32_t v[1];
	uint32_t uc_rmi_ext_intr_sts0[1];
	uint32_t _uc_rmi_ext_intr_sts0;
} BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_t;

#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_CLR(r) (r).uc_rmi_ext_intr_sts0[0] = 0
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_SET(r,d) (r).uc_rmi_ext_intr_sts0[0] = d
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_GET(r) (r).uc_rmi_ext_intr_sts0[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 9) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 9)) | ((((uint32_t)f) & 0x1) << 9)) | (1 << (16 + 9))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 8) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 8)) | ((((uint32_t)f) & 0x1) << 8)) | (1 << (16 + 8))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET(r) ((((r).uc_rmi_ext_intr_sts0[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET(r) (((r).uc_rmi_ext_intr_sts0[0]) & 0x1)
#define BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET(r,f) (r).uc_rmi_ext_intr_sts0[0]=(((r).uc_rmi_ext_intr_sts0[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access UC_RMI_EXT_INTR_STS0.
 */
#define BCMI_FALCON_XGXS_READ_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_FALCON_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r,(_r._uc_rmi_ext_intr_sts0))
#define BCMI_FALCON_XGXS_READLN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_FALCON_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._uc_rmi_ext_intr_sts0))
#define BCMI_FALCON_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._uc_rmi_ext_intr_sts0))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define UC_RMI_EXT_INTR_STS0r BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r
#define UC_RMI_EXT_INTR_STS0r_SIZE BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_SIZE
typedef BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_t UC_RMI_EXT_INTR_STS0r_t;
#define UC_RMI_EXT_INTR_STS0r_CLR BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_CLR
#define UC_RMI_EXT_INTR_STS0r_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_SET
#define UC_RMI_EXT_INTR_STS0r_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_SYSTEMRESETREQ_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_M0_LOCKUP_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_MULTIROW_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_UNCORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_ECC_CORR_ERR_STATUSf_SET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_GET
#define UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r_MICRO_RMI_MBOX_MSGOUT_STATUSf_SET
#define READ_UC_RMI_EXT_INTR_STS0r BCMI_FALCON_XGXS_READ_UC_RMI_EXT_INTR_STS0r
#define WRITE_UC_RMI_EXT_INTR_STS0r BCMI_FALCON_XGXS_WRITE_UC_RMI_EXT_INTR_STS0r
#define MODIFY_UC_RMI_EXT_INTR_STS0r BCMI_FALCON_XGXS_MODIFY_UC_RMI_EXT_INTR_STS0r
#define READLN_UC_RMI_EXT_INTR_STS0r BCMI_FALCON_XGXS_READLN_UC_RMI_EXT_INTR_STS0r
#define WRITELN_UC_RMI_EXT_INTR_STS0r BCMI_FALCON_XGXS_WRITELN_UC_RMI_EXT_INTR_STS0r
#define WRITEALL_UC_RMI_EXT_INTR_STS0r BCMI_FALCON_XGXS_WRITEALL_UC_RMI_EXT_INTR_STS0r

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_UC_RMI_EXT_INTR_STS0r'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  MDIO_MASKDATA
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdb
 * DEVAD:    1
 * DESC:     MDIO write mask register
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_MASKDATA    mask register for masked writes from mdio port.
 */
#define BCMI_FALCON_XGXS_MDIO_MASKDATAr (0x0001ffdb | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_MDIO_MASKDATAr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MASKDATA.
 */
typedef union BCMI_FALCON_XGXS_MDIO_MASKDATAr_s {
	uint32_t v[1];
	uint32_t mdio_maskdata[1];
	uint32_t _mdio_maskdata;
} BCMI_FALCON_XGXS_MDIO_MASKDATAr_t;

#define BCMI_FALCON_XGXS_MDIO_MASKDATAr_CLR(r) (r).mdio_maskdata[0] = 0
#define BCMI_FALCON_XGXS_MDIO_MASKDATAr_SET(r,d) (r).mdio_maskdata[0] = d
#define BCMI_FALCON_XGXS_MDIO_MASKDATAr_GET(r) (r).mdio_maskdata[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_GET(r) (((r).mdio_maskdata[0]) & 0xffff)
#define BCMI_FALCON_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_SET(r,f) (r).mdio_maskdata[0]=(((r).mdio_maskdata[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MDIO_MASKDATA.
 */
#define BCMI_FALCON_XGXS_READ_MDIO_MASKDATAr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_MASKDATAr,(_r._mdio_maskdata))
#define BCMI_FALCON_XGXS_WRITE_MDIO_MASKDATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MASKDATAr,(_r._mdio_maskdata)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_MDIO_MASKDATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MASKDATAr,(_r._mdio_maskdata))
#define BCMI_FALCON_XGXS_READLN_MDIO_MASKDATAr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_maskdata))
#define BCMI_FALCON_XGXS_WRITELN_MDIO_MASKDATAr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_maskdata))
#define BCMI_FALCON_XGXS_WRITEALL_MDIO_MASKDATAr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MASKDATAr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_maskdata))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MASKDATAr BCMI_FALCON_XGXS_MDIO_MASKDATAr
#define MDIO_MASKDATAr_SIZE BCMI_FALCON_XGXS_MDIO_MASKDATAr_SIZE
typedef BCMI_FALCON_XGXS_MDIO_MASKDATAr_t MDIO_MASKDATAr_t;
#define MDIO_MASKDATAr_CLR BCMI_FALCON_XGXS_MDIO_MASKDATAr_CLR
#define MDIO_MASKDATAr_SET BCMI_FALCON_XGXS_MDIO_MASKDATAr_SET
#define MDIO_MASKDATAr_GET BCMI_FALCON_XGXS_MDIO_MASKDATAr_GET
#define MDIO_MASKDATAr_MDIO_MASKDATAf_GET BCMI_FALCON_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_GET
#define MDIO_MASKDATAr_MDIO_MASKDATAf_SET BCMI_FALCON_XGXS_MDIO_MASKDATAr_MDIO_MASKDATAf_SET
#define READ_MDIO_MASKDATAr BCMI_FALCON_XGXS_READ_MDIO_MASKDATAr
#define WRITE_MDIO_MASKDATAr BCMI_FALCON_XGXS_WRITE_MDIO_MASKDATAr
#define MODIFY_MDIO_MASKDATAr BCMI_FALCON_XGXS_MODIFY_MDIO_MASKDATAr
#define READLN_MDIO_MASKDATAr BCMI_FALCON_XGXS_READLN_MDIO_MASKDATAr
#define WRITELN_MDIO_MASKDATAr BCMI_FALCON_XGXS_WRITELN_MDIO_MASKDATAr
#define WRITEALL_MDIO_MASKDATAr BCMI_FALCON_XGXS_WRITEALL_MDIO_MASKDATAr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_MDIO_MASKDATAr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  MDIO_BCST_PORT_ADDR
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdc
 * DEVAD:    1
 * DESC:     Broadcast Port Address
 * RESETVAL: 0x1f (31)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BRCST_PORT_ADDR Braodcast port address that can be used to broadcast mdio commandsto multiple controllers connected to the same mdio station manager
 */
#define BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr (0x0001ffdc | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BCST_PORT_ADDR.
 */
typedef union BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_bcst_port_addr[1];
	uint32_t _mdio_bcst_port_addr;
} BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_t;

#define BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_CLR(r) (r).mdio_bcst_port_addr[0] = 0
#define BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_SET(r,d) (r).mdio_bcst_port_addr[0] = d
#define BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_GET(r) (r).mdio_bcst_port_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET(r) (((r).mdio_bcst_port_addr[0]) & 0x1f)
#define BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET(r,f) (r).mdio_bcst_port_addr[0]=(((r).mdio_bcst_port_addr[0] & ~((uint32_t)0x1f)) | (((uint32_t)f) & 0x1f)) | (0x1f << 16)

/*
 * These macros can be used to access MDIO_BCST_PORT_ADDR.
 */
#define BCMI_FALCON_XGXS_READ_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_FALCON_XGXS_WRITE_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr,(_r._mdio_bcst_port_addr))
#define BCMI_FALCON_XGXS_READLN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_FALCON_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_bcst_port_addr))
#define BCMI_FALCON_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_bcst_port_addr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BCST_PORT_ADDRr BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr
#define MDIO_BCST_PORT_ADDRr_SIZE BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_SIZE
typedef BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_t MDIO_BCST_PORT_ADDRr_t;
#define MDIO_BCST_PORT_ADDRr_CLR BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_CLR
#define MDIO_BCST_PORT_ADDRr_SET BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_SET
#define MDIO_BCST_PORT_ADDRr_GET BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_GET
#define MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr_MDIO_BRCST_PORT_ADDRf_SET
#define READ_MDIO_BCST_PORT_ADDRr BCMI_FALCON_XGXS_READ_MDIO_BCST_PORT_ADDRr
#define WRITE_MDIO_BCST_PORT_ADDRr BCMI_FALCON_XGXS_WRITE_MDIO_BCST_PORT_ADDRr
#define MODIFY_MDIO_BCST_PORT_ADDRr BCMI_FALCON_XGXS_MODIFY_MDIO_BCST_PORT_ADDRr
#define READLN_MDIO_BCST_PORT_ADDRr BCMI_FALCON_XGXS_READLN_MDIO_BCST_PORT_ADDRr
#define WRITELN_MDIO_BCST_PORT_ADDRr BCMI_FALCON_XGXS_WRITELN_MDIO_BCST_PORT_ADDRr
#define WRITEALL_MDIO_BCST_PORT_ADDRr BCMI_FALCON_XGXS_WRITEALL_MDIO_BCST_PORT_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_MDIO_BCST_PORT_ADDRr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  MDIO_MMD_SEL
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffdd
 * DEVAD:    1
 * DESC:     MMD Select
 * RESETVAL: 0x404d (16461)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_DEV_CL22_EN When set and mdio_multi_mmds_en=1 then CL22 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PMD_EN  When set and mdio_multi_mmds_en=1 then the PMD device=1 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_AN_EN   When set and mdio_multi_mmds_en=1 then the AN device=7 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PHY_EN  When set and mdio_multi_mmds_en=1 then the PHY device=4 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_DTE_EN  When set and mdio_multi_mmds_en=1 then the DTE device=5 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_DEV_PCS_EN  When set and mdio_multi_mmds_en=1 then the PCS device=3 registers can be directlyaccessed through the MDIO serial data stream.
 *     MDIO_MULTI_MMDS_EN When set enables the multiple MMD functionality.  MD_ST is ignored andeach device can be accessed directly with the appropriate CL22 or CL45protocol.
 *     MDIO_MULTI_PRTS_EN When set enables multiple prtad functionality.  Each of the lanes'mmds can be accessed with consecutive PRTADs.  Lane 0 is accessedwith PRTAD_STRAP, lane 1 with PRTAD_STRAP+1, lane 2 with PRTAD_STRAP+2and lane 3 with PRTAD_STRAP+3.
 */
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr (0x0001ffdd | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_MMD_SEL.
 */
typedef union BCMI_FALCON_XGXS_MDIO_MMD_SELr_s {
	uint32_t v[1];
	uint32_t mdio_mmd_sel[1];
	uint32_t _mdio_mmd_sel;
} BCMI_FALCON_XGXS_MDIO_MMD_SELr_t;

#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_CLR(r) (r).mdio_mmd_sel[0] = 0
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_SET(r,d) (r).mdio_mmd_sel[0] = d
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_GET(r) (r).mdio_mmd_sel[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 15) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 15)) | ((((uint32_t)f) & 0x1) << 15)) | (1 << (16 + 15))
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 14) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 14)) | ((((uint32_t)f) & 0x1) << 14)) | (1 << (16 + 14))
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 6) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 6)) | ((((uint32_t)f) & 0x1) << 6)) | (1 << (16 + 6))
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 5) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 5)) | ((((uint32_t)f) & 0x1) << 5)) | (1 << (16 + 5))
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 4) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 4)) | ((((uint32_t)f) & 0x1) << 4)) | (1 << (16 + 4))
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 3) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 3)) | ((((uint32_t)f) & 0x1) << 3)) | (1 << (16 + 3))
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET(r) ((((r).mdio_mmd_sel[0]) >> 2) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1 << 2)) | ((((uint32_t)f) & 0x1) << 2)) | (1 << (16 + 2))
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET(r) (((r).mdio_mmd_sel[0]) & 0x1)
#define BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET(r,f) (r).mdio_mmd_sel[0]=(((r).mdio_mmd_sel[0] & ~((uint32_t)0x1)) | (((uint32_t)f) & 0x1)) | (0x1 << 16)

/*
 * These macros can be used to access MDIO_MMD_SEL.
 */
#define BCMI_FALCON_XGXS_READ_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_FALCON_XGXS_WRITE_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MMD_SELr,(_r._mdio_mmd_sel))
#define BCMI_FALCON_XGXS_READLN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_FALCON_XGXS_WRITELN_MDIO_MMD_SELr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_mmd_sel))
#define BCMI_FALCON_XGXS_WRITEALL_MDIO_MMD_SELr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_MMD_SELr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_mmd_sel))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_MMD_SELr BCMI_FALCON_XGXS_MDIO_MMD_SELr
#define MDIO_MMD_SELr_SIZE BCMI_FALCON_XGXS_MDIO_MMD_SELr_SIZE
typedef BCMI_FALCON_XGXS_MDIO_MMD_SELr_t MDIO_MMD_SELr_t;
#define MDIO_MMD_SELr_CLR BCMI_FALCON_XGXS_MDIO_MMD_SELr_CLR
#define MDIO_MMD_SELr_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_SET
#define MDIO_MMD_SELr_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_PRTS_ENf_SET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_GET
#define MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_MULTI_MMDS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PCS_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_DTE_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PHY_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_AN_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_PMD_ENf_SET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_GET
#define MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET BCMI_FALCON_XGXS_MDIO_MMD_SELr_MDIO_DEV_CL22_ENf_SET
#define READ_MDIO_MMD_SELr BCMI_FALCON_XGXS_READ_MDIO_MMD_SELr
#define WRITE_MDIO_MMD_SELr BCMI_FALCON_XGXS_WRITE_MDIO_MMD_SELr
#define MODIFY_MDIO_MMD_SELr BCMI_FALCON_XGXS_MODIFY_MDIO_MMD_SELr
#define READLN_MDIO_MMD_SELr BCMI_FALCON_XGXS_READLN_MDIO_MMD_SELr
#define WRITELN_MDIO_MMD_SELr BCMI_FALCON_XGXS_WRITELN_MDIO_MMD_SELr
#define WRITEALL_MDIO_MMD_SELr BCMI_FALCON_XGXS_WRITEALL_MDIO_MMD_SELr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_MDIO_MMD_SELr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  MDIO_AER
 * BLOCKS:   MDIO_MMDSEL_AER_COM
 * REGADDR:  0xffde
 * DEVAD:    1
 * DESC:     AER
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_AER         Provides upper 16-bits of 32-bit address for mdio transactions
 */
#define BCMI_FALCON_XGXS_MDIO_AERr (0x0001ffde | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_MDIO_AERr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_AER.
 */
typedef union BCMI_FALCON_XGXS_MDIO_AERr_s {
	uint32_t v[1];
	uint32_t mdio_aer[1];
	uint32_t _mdio_aer;
} BCMI_FALCON_XGXS_MDIO_AERr_t;

#define BCMI_FALCON_XGXS_MDIO_AERr_CLR(r) (r).mdio_aer[0] = 0
#define BCMI_FALCON_XGXS_MDIO_AERr_SET(r,d) (r).mdio_aer[0] = d
#define BCMI_FALCON_XGXS_MDIO_AERr_GET(r) (r).mdio_aer[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_MDIO_AERr_MDIO_AERf_GET(r) (((r).mdio_aer[0]) & 0xffff)
#define BCMI_FALCON_XGXS_MDIO_AERr_MDIO_AERf_SET(r,f) (r).mdio_aer[0]=(((r).mdio_aer[0] & ~((uint32_t)0xffff)) | (((uint32_t)f) & 0xffff)) | (0xffff << 16)

/*
 * These macros can be used to access MDIO_AER.
 */
#define BCMI_FALCON_XGXS_READ_MDIO_AERr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_FALCON_XGXS_WRITE_MDIO_AERr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_AERr,(_r._mdio_aer)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_MDIO_AERr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_AERr,(_r._mdio_aer))
#define BCMI_FALCON_XGXS_READLN_MDIO_AERr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_FALCON_XGXS_WRITELN_MDIO_AERr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_aer))
#define BCMI_FALCON_XGXS_WRITEALL_MDIO_AERr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_AERr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_aer))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_AERr BCMI_FALCON_XGXS_MDIO_AERr
#define MDIO_AERr_SIZE BCMI_FALCON_XGXS_MDIO_AERr_SIZE
typedef BCMI_FALCON_XGXS_MDIO_AERr_t MDIO_AERr_t;
#define MDIO_AERr_CLR BCMI_FALCON_XGXS_MDIO_AERr_CLR
#define MDIO_AERr_SET BCMI_FALCON_XGXS_MDIO_AERr_SET
#define MDIO_AERr_GET BCMI_FALCON_XGXS_MDIO_AERr_GET
#define MDIO_AERr_MDIO_AERf_GET BCMI_FALCON_XGXS_MDIO_AERr_MDIO_AERf_GET
#define MDIO_AERr_MDIO_AERf_SET BCMI_FALCON_XGXS_MDIO_AERr_MDIO_AERf_SET
#define READ_MDIO_AERr BCMI_FALCON_XGXS_READ_MDIO_AERr
#define WRITE_MDIO_AERr BCMI_FALCON_XGXS_WRITE_MDIO_AERr
#define MODIFY_MDIO_AERr BCMI_FALCON_XGXS_MODIFY_MDIO_AERr
#define READLN_MDIO_AERr BCMI_FALCON_XGXS_READLN_MDIO_AERr
#define WRITELN_MDIO_AERr BCMI_FALCON_XGXS_WRITELN_MDIO_AERr
#define WRITEALL_MDIO_AERr BCMI_FALCON_XGXS_WRITEALL_MDIO_AERr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_MDIO_AERr'
 */




/*******************************************************************************
 * CHIP:  BCMI_FALCON_XGXS
 * REGISTER:  MDIO_BLK_ADDR
 * BLOCKS:   MDIO_BLK_ADDR_COM
 * REGADDR:  0xffdf
 * DEVAD:    1
 * DESC:     BLK_ADDR
 * RESETVAL: 0x0 (0)
 * ACCESS:   R/W
 * FIELDS:
 *     MDIO_BLK_ADDR    Block address (used for clause 22 transactions to get the address bits 14:4)
 */
#define BCMI_FALCON_XGXS_MDIO_BLK_ADDRr (0x0001ffdf | PHYMOD_REG_ACC_TSC_IBLK)

#define BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_SIZE 4

/*
 * This structure should be used to declare and program MDIO_BLK_ADDR.
 */
typedef union BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_s {
	uint32_t v[1];
	uint32_t mdio_blk_addr[1];
	uint32_t _mdio_blk_addr;
} BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_t;

#define BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_CLR(r) (r).mdio_blk_addr[0] = 0
#define BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_SET(r,d) (r).mdio_blk_addr[0] = d
#define BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_GET(r) (r).mdio_blk_addr[0]

/*
 * These macros can be used to access individual fields.
 */
#define BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_GET(r) ((((r).mdio_blk_addr[0]) >> 4) & 0x7ff)
#define BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_SET(r,f) (r).mdio_blk_addr[0]=(((r).mdio_blk_addr[0] & ~((uint32_t)0x7ff << 4)) | ((((uint32_t)f) & 0x7ff) << 4)) | (2047 << (16 + 4))

/*
 * These macros can be used to access MDIO_BLK_ADDR.
 */
#define BCMI_FALCON_XGXS_READ_MDIO_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_BLK_ADDRr,(_r._mdio_blk_addr))
#define BCMI_FALCON_XGXS_WRITE_MDIO_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BLK_ADDRr,(_r._mdio_blk_addr)&0xffff)
#define BCMI_FALCON_XGXS_MODIFY_MDIO_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BLK_ADDRr,(_r._mdio_blk_addr))
#define BCMI_FALCON_XGXS_READLN_MDIO_BLK_ADDRr(_pc,_l,_r) phymod_tsc_iblk_read(_pc,BCMI_FALCON_XGXS_MDIO_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_blk_addr))
#define BCMI_FALCON_XGXS_WRITELN_MDIO_BLK_ADDRr(_pc,_l,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_FORCE_LANE|LSHIFT32(((_l)&0x3),PHYMOD_REG_ACCESS_FLAGS_SHIFT),(_r._mdio_blk_addr))
#define BCMI_FALCON_XGXS_WRITEALL_MDIO_BLK_ADDRr(_pc,_r) phymod_tsc_iblk_write(_pc,BCMI_FALCON_XGXS_MDIO_BLK_ADDRr|PHYMOD_REG_ACC_TSC_IBLK_BCAST,(_r._mdio_blk_addr))

/*
 * Unless PHYMOD_EXCLUDE_CHIPLESS_TYPES is defined, all of the above types
 * will be redefined without the chip prefix for easier programming.
 * If multiple chips will be programmed in the same source file, then you should
 * define PHYMOD_EXCLUDE_CHIPLESS_TYPES before including all chip header files
 * and refer to the fully qualified versions.
 */
#ifndef PHYMOD_EXCLUDE_CHIPLESS_TYPES

#define MDIO_BLK_ADDRr BCMI_FALCON_XGXS_MDIO_BLK_ADDRr
#define MDIO_BLK_ADDRr_SIZE BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_SIZE
typedef BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_t MDIO_BLK_ADDRr_t;
#define MDIO_BLK_ADDRr_CLR BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_CLR
#define MDIO_BLK_ADDRr_SET BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_SET
#define MDIO_BLK_ADDRr_GET BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_GET
#define MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_GET BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_GET
#define MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_SET BCMI_FALCON_XGXS_MDIO_BLK_ADDRr_MDIO_BLK_ADDRf_SET
#define READ_MDIO_BLK_ADDRr BCMI_FALCON_XGXS_READ_MDIO_BLK_ADDRr
#define WRITE_MDIO_BLK_ADDRr BCMI_FALCON_XGXS_WRITE_MDIO_BLK_ADDRr
#define MODIFY_MDIO_BLK_ADDRr BCMI_FALCON_XGXS_MODIFY_MDIO_BLK_ADDRr
#define READLN_MDIO_BLK_ADDRr BCMI_FALCON_XGXS_READLN_MDIO_BLK_ADDRr
#define WRITELN_MDIO_BLK_ADDRr BCMI_FALCON_XGXS_WRITELN_MDIO_BLK_ADDRr
#define WRITEALL_MDIO_BLK_ADDRr BCMI_FALCON_XGXS_WRITEALL_MDIO_BLK_ADDRr

#endif /* PHYMOD_EXCLUDE_CHIPLESS_TYPES */
/*******************************************************************************
 * End of 'BCMI_FALCON_XGXS_MDIO_BLK_ADDRr'
 */




#endif /* __BCMI_FALCON_XGXS_DEFS_H__ */
