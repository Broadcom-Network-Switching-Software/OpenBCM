/***********************************************************************************
 *                                                                                 *
 * Copyright: (c) 2021 Broadcom.                                                   *
 * Broadcom Proprietary and Confidential. All rights reserved.                     *
 *                                                                                 *
 ***********************************************************************************/

/**********************************************************************************
 **********************************************************************************
 *                                                                                *
 *  Revision    :   *
 *                                                                                *
 *  Description :  Internal API functions                                         *
 *                                                                                *
 **********************************************************************************
 **********************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#ifndef OSPREY7_V2L8P2_API_INTERNAL_H
#define OSPREY7_V2L8P2_API_INTERNAL_H

#include "osprey7_v2l8p2_ipconfig.h"
#include "osprey7_v2l8p2_select_defns.h"
#include "common/srds_api_err_code.h"
#include "common/srds_api_uc_common.h"
#include "common/srds_api_types.h"
#include "osprey7_v2l8p2_enum.h"
#include "osprey7_v2l8p2_types.h"
#include "osprey7_v2l8p2_usr_includes.h"
#include "osprey7_v2l8p2_prbs.h"
#include "osprey7_v2l8p2_lane_state.h"

/*! @file
 *  @brief Internal API functions
 */

/*! @addtogroup APITag
 * @{
 */

/*! @defgroup SerdesAPIInternalTag Internal Functions
 * Internal Serdes API functions which get called by other modules and
 * should not be called directly.
 */


/*! @addtogroup SerdesAPIInternalTag
 * @{
 */

/*---------------------------------------*/
/** Conversion for DFE tap 5-14 encoding */
/*---------------------------------------*/
/** DFE TAP 5-14 Signed-Gray-Binary to Signed-Gray encoding
 * @param[in] sgb is Signed-Gray-Binary value.
 * @return Signed-Gray value.
  */
int8_t osprey7_v2l8p2_INTERNAL_dfe_tap_sgb2sg(int8_t sgb);

/*----------------------------------------------------------*/
/** Calculate second order polynomial fitting coefficients. */
/*----------------------------------------------------------*/
/** y = a[2]*(x^2) + a[1]*x + a[0]
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] n number of samples used to do calculation.
 * @param[in] x pointer to data on x axis.
 * @param[in] y pointer to data on y axis.
 * @param[out] a pointer to coefficients.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_fit_second_order(srds_access_t *sa__, uint8_t n, USR_DOUBLE *x, USR_DOUBLE *y, USR_DOUBLE *a);


/*------------------------------*/
/** Serdes Core State Structure */
/*------------------------------*/
typedef struct {
  /** Core DP Reset State */
  uint8_t  core_reset;
  /**  PLL Powerdown enable */
  uint8_t  pll_pwrdn;
  /** Micro active enable */
  uint8_t  uc_active;
  /** Comclk Frequency in Mhz */
  uint16_t comclk_mhz;
  /** uCode Major Version number */
  uint16_t ucode_version;
  /** uCode Minor Version number */
  uint8_t  ucode_minor_version;
  /** API Version number*/
  uint32_t api_version;
  /** AFE Hardware version */
  uint8_t  afe_hardware_version;
  /** uC Die Temperature Index */
  uint8_t  temp_idx;
  /** Average Die Temperature (13-bit format) */
  int16_t  avg_tmon;
  /** Analog Resistor Calibration value */
  uint8_t  rescal;
  /** VCO Rate in MHz */
  uint16_t vco_rate_mhz;
  /**  Analog VCO Range */
  uint8_t  analog_vco_range;
  /** PLL Divider value.  (Same encoding as enum #osprey7_v2l8p2_pll_div_enum.) */
  uint32_t pll_div;
  /** PLL Lock */
  uint8_t  pll_lock;
  /** PLL Lock Change*/
  uint8_t  pll_lock_chg;
  /** Live die temperature in Celsius */
  int16_t die_temp;
  /** Core Status Variable */
  uint8_t core_status;
  /** Refclk doubler enable */
  uint8_t refclk_doubler;
} osprey7_v2l8p2_core_state_st;


#define RESCAL_MIN  (3)
#define RESCAL_MAX (13)

#define SRDS_INFO_SIGNATURE (0x50c1ab1e)

/* SW Limits for TXFIR Taps in PAM4 mode */
#define TXFIR_PAM4_SW_TAP_MIN   (-170)
#define TXFIR_PAM4_SW_TAP_MAX   ( 170)
#define TXFIR_PAM4_SW_SUM_LIMIT ( 170)

#define WRV_USR_DBSTOPPED_TO_0    EFUN(wrv_usr_dbstopped(0))

#ifndef SMALL_FOOTPRINT
/** Uses timestamps in uCode to check if heartbeat timer is programmed correctly
 *  for the COMCLK frequency it is running at.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] console_print_options to control/select what is printed to console.
 *            0x00        : No prints to console.
 *            0x01 - 0xFF : prints everything
 * @return Error Code if timestamp check fails (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_test_uc_timestamp_with_print_options(srds_access_t *sa__, uint8_t console_print_options);

/** Retrieve the num_bits_per_ms useful for BER calculations.
 * There is some Error in the calculation because only VCO rate in Mhz is stored.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] select_rx a flag to select rx or tx (1 -> rx, 0 -> tx).
 * @param[out] num_bits_per_ms is pointer to uint64_t which is used to store the num_bits_per_ms.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_num_bits_per_ms(srds_access_t *sa__, uint8_t select_rx, uint32_t *num_bits_per_ms);

/** Check PRBS status and print BER.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] time_ms is the amount of time to delay for BER calculation.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_display_BER(srds_access_t *sa__, uint16_t time_ms);

/** Check PRBS status and print BER.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] time_ms is the amount of time to delay for BER calculation.
 * @param[out] string is a pointer to char array of length >=10 in which to place string.
 * @param[in] string_size is the size of string in bytes.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_BER_string(srds_access_t *sa__, uint16_t time_ms, char *string, uint8_t string_size);

/** Check PRBS status and provide number of errors and number of bits for BER calculation.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] time_ms is the amount of time to delay for BER calculation.
 * @param[out] ber_data is a struct that will get populated with number of errors and number of bits as elements.
 * @param[in] timer_sel allows to measure BER using host computer time instead of using hardware timers.
 * @return Error code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_BER_data(srds_access_t *sa__, uint16_t time_ms, struct osprey7_v2l8p2_ber_data_st *ber_data, enum osprey7_v2l8p2_prbs_chk_timer_selection_enum timer_sel);

/** Check CDR lost lock.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] cdrlcklost is set if CDR loses lock.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_prbs_chk_cdr_lock_lost(srds_access_t *sa__, uint8_t *cdrlcklost);

#define PRBS_MAX_HW_TIMER_TIMEOUT           (1022)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_DISABLED (0x0)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_1US      (0x1)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_10US     (0x2)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_100US    (0x3)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_1MS      (0x4)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_10MS     (0x5)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_100MS    (0x6)
#define PRBS_CHK_EN_TIMER_UNIT_SEL_RESERVED (0x7)

/** Get timeout register value from time in ms value.
 * @param[in] time_ms is the amount of time to delay for BER calculation requested by a user.
 * @param[out] time_ms_adjusted is the amount of time to delay for BER calculation available by design (>= time_ms).
 * @param[out] prbs_chk_hw_timer_ctrl is a struct to hold timer mode and timeout value that needs to be programmed to corresponding registers.
 * @return Error code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_prbs_timeout_count_from_time(uint16_t time_ms, uint16_t * time_ms_adjusted, struct osprey7_v2l8p2_prbs_chk_hw_timer_ctrl_st * const prbs_chk_hw_timer_ctrl);

/** Function to add delay to account for hardware synchronization.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_hw_timer_sync_delay(srds_access_t *sa__);
#endif /* SMALL_FOOTPRINT */

/** Get Serdes Info pointer.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Serdes Info pointer.
 */
srds_info_t *osprey7_v2l8p2_INTERNAL_get_osprey7_v2l8p2_info_ptr(srds_access_t *sa__);

/** Get Serdes Info pointer and initialize it if signature doesn't match.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Serdes Info pointer.
 */
srds_info_t *osprey7_v2l8p2_INTERNAL_get_osprey7_v2l8p2_info_ptr_with_check(srds_access_t *sa__);

/** Checks to see if the stored ucode_version in osprey7_v2l8p2_info is matching with the current thread ucode_version.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] osprey7_v2l8p2_info_ptr pointer to Info_table to be verified.
 * @return Error Code generated if ucode_version does not match or uC rdvariable caused issues (else returns ERR_CODE_NONE).
 */
err_code_t osprey7_v2l8p2_INTERNAL_match_ucode_from_info(srds_access_t *sa__, srds_info_t const *osprey7_v2l8p2_info_ptr);

/** Verify the internal osprey7_v2l8p2_info.
 * NOTE: This function is getting deprecated. Instead, please use the functions
 * osprey7_v2l8p2_INTERNAL_get_osprey7_v2l8p2_info_ptr_with_check and osprey7_v2l8p2_INTERNAL_match_ucode_from_info
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] osprey7_v2l8p2_info_ptr pointer to Info_table to be verified.
 * @return Error code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_verify_osprey7_v2l8p2_info(srds_access_t *sa__, srds_info_t const *osprey7_v2l8p2_info_ptr);

#ifndef SMALL_FOOTPRINT

/** Calculate the mode_sel parameter for tx pattern generator.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] mode_sel Mode select to be used for generating required pattern.
 * @param[out] zero_pad_len Length of zero padding to be used for generating required pattern.
 * @param[in] patt_length Desired Pattern length.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_calc_patt_gen_mode_sel(srds_access_t *sa__, uint8_t *mode_sel, uint8_t *zero_pad_len, uint8_t patt_length);
#endif /*SMALL_FOOTPRINT */

/** Check if the micro's operations on that lane are stopped.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return err_code Error Code "ERR_CODE_UC_NOT_STOPPED" returned if micro NOT stopped.
 */
err_code_t osprey7_v2l8p2_INTERNAL_check_uc_lane_stopped(srds_access_t *sa__);

/*-----------------------------------------*/
/*  Write Core Config variables to uC RAM  */
/*-----------------------------------------*/

/** Write to core_config uC RAM variable.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] struct_val Value to be written into core_config RAM variable
 *                   (Note that struct_val.word must be = 0, only the fields are used).
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_uc_core_config(srds_access_t *sa__, struct osprey7_v2l8p2_uc_core_config_st struct_val);

/*---------------------*/
/*  PLL Configuration  */
/*---------------------*/

/** Return whether the fraction portion of a #osprey7_v2l8p2_pll_div_enum value is nonzero. */
#define SRDS_INTERNAL_IS_PLL_DIV_FRACTIONAL(div_) (((uint32_t)(div_) & 0xFFFFF000UL) != 0)

/** Extract the integer portion of a #osprey7_v2l8p2_pll_div_enum value. */
#define SRDS_INTERNAL_GET_PLL_DIV_INTEGER(div_) ((uint32_t)(((uint32_t)(div_)) & 0x00000FFFUL))

/** Extract the fraction portion of a #osprey7_v2l8p2_pll_div_enum value.
 *  The result would be suitable for the numerator of a fraction whose denominator is 2^(width_).
 *  width_ must be less than 32.
 */
#define SRDS_INTERNAL_GET_PLL_DIV_FRACTION_NUM(div_, width_)            \
    ((uint32_t)((((((uint32_t)(div_) & 0xFFFFF000UL) >> (32-(width_)-1)) + 1) >> 1)))

/** Compose a value in the same format as a #osprey7_v2l8p2_pll_div_enum value.
 *  (Though it's the same format, a U32 is used, because rounding may yield a non-enumerated result.)
 *  The fractional portion is fraction_num / (2^fraction_num_width_).
 *  fraction_num_width_ must be 32 or less.
 */
#define SRDS_INTERNAL_COMPOSE_PLL_DIV(integer_, fraction_num_, fraction_num_width_)                   \
     ((uint32_t)((integer_) & 0x00000FFFUL)                                                                 \
     | (uint32_t)((((((fraction_num_) << (32-(fraction_num_width_))) >> (32-20-1)) + 1) >> 1) << 12))


/** Resolve PLL parameters.
 * PLL configuration requires two out of the three parameters:  refclk frequency, divider value, and VCO output frequency.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] refclk Reference clock frequency (enumerated), or OSPREY7_V2L8P2_PLL_REFCLK_UNKNOWN to auto-compute.
 * @param[in,out] refclk_freq_hz Resultant reference clock frequency, in Hz.
 * @param[in,out] srds_div Divider value (enumerated), or OSPREY7_V2L8P2_PLL_DIV_UNKNOWN to auto-compute.
 *             The final divider value will be filled in if OSPREY7_V2L8P2_PLL_DIV_UNKNOWN.
 * @param[in,out] vco_freq_khz VCO output frequency, in kHz, or 0 to auto-compute.
 *                      The final VCO output frequency will be filled in if 0.
 * @param[in] pll_option Select PLL configuration option from enum #osprey7_v2l8p2_pll_option_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_resolve_pll_parameters(srds_access_t *sa__,
                                                  enum osprey7_v2l8p2_pll_refclk_enum refclk,
                                                  uint32_t *refclk_freq_hz,
                                                  enum osprey7_v2l8p2_pll_div_enum *srds_div,
                                                  uint32_t *vco_freq_khz,
                                                  enum osprey7_v2l8p2_pll_option_enum pll_option);


/** Check if VCO frequecy is in the allowed range.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] vco_freq_khz VCO output frequency, in kHz.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_check_vco_freq_khz(srds_access_t *sa__, uint32_t vco_freq_khz);

#ifndef SMALL_FOOTPRINT
/** Configure PLL.
 *
 * Use core_s_rstb to re-initialize all registers to default before calling this function.
 *
 * Configures PLL registers to obtain the required configuration.
 * PLL configuration requires two out of the three parameters:  refclk frequency, divider value, and VCO output frequency.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] refclk Reference clock frequency (enumerated), or OSPREY7_V2L8P2_PLL_REFCLK_UNKNOWN to auto-compute.
 * @param[in] srds_div Divider value (enumerated), or OSPREY7_V2L8P2_PLL_DIV_UNKNOWN to auto-compute.
 * @param[in] vco_freq_khz VCO output frequency, in kHz, or 0 to auto-compute.
 * @param[in] pll_option Select PLL configuration option from enum #osprey7_v2l8p2_pll_option_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
#else
 /** Configure PLL.
 *
 * Use core_s_rstb to re-initialize all registers to default before calling this function.
 *
 * Configures PLL registers to obtain the required configuration.
 * PLL configuration requires all four parameters:  refclk frequency, divider value, VCO output frequency and the PLL options.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] refclk Reference clock frequency (enumerated), or OSPREY7_V2L8P2_PLL_REFCLK_UNKNOWN to auto-compute.
 * @param[in] srds_div Divider value (enumerated).
 * @param[in] vco_freq_khz VCO output frequency, in kHz.
 * @param[in] pll_option Select PLL configuration option from enum #osprey7_v2l8p2_pll_option_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
#endif

err_code_t osprey7_v2l8p2_INTERNAL_configure_pll(srds_access_t *sa__,
                                         enum osprey7_v2l8p2_pll_refclk_enum refclk,
                                         enum osprey7_v2l8p2_pll_div_enum srds_div,
                                         uint32_t vco_freq_khz,
                                         enum osprey7_v2l8p2_pll_option_enum pll_option);

/** Special Configure PLL to 53.125 GHz.
 *
 * Note: This function is only needed for afe A0 silicon, but is forward
 *       compatible with future afe silicon versions.
 * PLL configuration requires one out of the two parameters:  refclk frequency and divider value.
 * This function operates on the currently selected PLL index, configures PLL registers
 * to obtain the required configuration, and calls osprey7_v2l8p2_core_dp_reset() as needed.
 * For afe A0 silicon, this function first attempts to configure using LBVCO.
 * If configuration is unsuccessful, attempts to use HBVCO.
 * For afe B0 silicon, this function only attempts to configure using HBVCO.
 * For afe C0 silicon and beyond, this function only attempts to configure using LBVCO.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] refclk Reference clock frequency (enumerated), or OSPREY7_V2L8P2_PLL_REFCLK_UNKNOWN to auto-compute.
 * @param[in] srds_div Divider value (enumerated), or OSPREY7_V2L8P2_PLL_DIV_UNKNOWN to auto-compute.
 * @param[in] pll_option Select PLL configuration option from enum #osprey7_v2l8p2_pll_option_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_configure_53P125_pll(srds_access_t *sa__,
                                                enum osprey7_v2l8p2_pll_refclk_enum refclk,
                                                enum osprey7_v2l8p2_pll_div_enum srds_div,
                                                enum osprey7_v2l8p2_pll_option_enum pll_option);

/** Special Configure PLL to 53.125 GHz using LB VCO.
 *
 * Note: This function is only needed for afe A0 silicon, but is forward
 *       compatible with future afe silicon versions.
 * PLL configuration requires one out of the two parameters:  refclk frequency and divider value.
 * This function operates on the currently selected PLL index, configures PLL registers
 * to obtain the required configuration, and calls osprey7_v2l8p2_core_dp_reset() as needed.
 * For afe A0 silicon, this function attempts to configure using LBVCO.
 * If configuration is unsuccessful, osprey7_v2l8p2_configure_53P125G_hb_pll() will need to be called.
 * For afe B0 silicon, this function only attempts to configure using HBVCO.
 * For afe C0 silicon and beyond, this function only attempts to configure using LBVCO.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] refclk Reference clock frequency (enumerated).
 * @param[in] srds_div Divider value (enumerated), or OSPREY7_V2L8P2_PLL_DIV_UNKNOWN to auto-compute.
 * @param[in] pll_option Select PLL configuration option from enum #osprey7_v2l8p2_pll_option_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_configure_lb_53P125_pll(srds_access_t *sa__,
                                                enum osprey7_v2l8p2_pll_refclk_enum refclk,
                                                enum osprey7_v2l8p2_pll_div_enum srds_div,
                                                enum osprey7_v2l8p2_pll_option_enum pll_option);

/** Special Force PLL to use HB VCO.
 *
 * Note: This function is only needed for afe A0 silicon, but is forward
 *       compatible with future afe silicon versions.
 * Note: This function should only be called after LB VCO configuration is attempted and is unsuccessful.
 * This function operates on the currently selected PLL index, configures PLL registers
 * to obtain the required configuration, and calls osprey7_v2l8p2_core_dp_reset() as needed.
 * For afe A0 silicon, this function attempts to configure using HBVCO.
 * For afe B0 silicon and beyond, this function does nothing.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_force_hb_53P125_pll(srds_access_t *sa__);

/** Special  LB VCO out of range check for 53.125 GHz.
 *
 * Note: This function is only needed for afe A0 silicon.
 * This function checks to make sure that the pll_range register field value is within the allowed LB VCO range.
 * This function should be called after osprey7_v2l8p2_configure_53P125G_lb_pll_div() or osprey7_v2l8p2_configure_53P125G_lb_pll_refclk().
 * If pll_out_range == 1, then osprey7_v2l8p2_configure_53P125G_hb_pll() should be called to configure HB VCO.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] pll_out_range Pointer which will be set to 1 if the PLL is out of range, otherwise will be set to 0.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_pll_lb_range_check(srds_access_t *sa__, uint8_t *pll_out_range);

/** Special  HB VCO out of range check for 53.125 GHz.
 *
 * Note: This function is only needed for afe A0 silicon.
 * This function checks to make sure that the pll_range register field value is within the allowed HB VCO range.
 * This function should be called after osprey7_v2l8p2_configure_53P125G_hb_pll.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] pll_out_range Pointer which will be set to 1 if the PLL is out of range, otherwise will be set to 0.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_pll_hb_range_check(srds_access_t *sa__, uint8_t *pll_out_range);

/** Read the programmed PLL div value from the SERDES.
 *  Due to rounding when writing the div value to the PLL,
 *      the returned result may be slightly different from what was written.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] srds_div Divider value, in the same encoding as enum #osprey7_v2l8p2_pll_div_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_pll_div(srds_access_t *sa__, uint32_t *srds_div);

/** Convert the PLL_DIV to actual PLL divider value and display
 * as part of osprey7_v2l8p2_display_core_state_line().
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] srds_div Divider value, in the same encoding as enum #osprey7_v2l8p2_pll_div_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_display_pll_to_divider(srds_access_t *sa__, uint32_t srds_div);

/** Get the VCO frequency in kHz, based on the reference clock frequency and divider value.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] refclk_freq_hz Reference clock frequency, in Hz.
 * @param[in] srds_div Divider value, in the same encoding as enum #osprey7_v2l8p2_pll_div_enum.
 * @param[out] vco_freq_khz VCO output frequency, in kHz, obtained based on reference clock frequency and div value.
 * @param[in] pll_option Select PLL configuration option from enum #osprey7_v2l8p2_pll_option_enum.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_vco_from_refclk_div(srds_access_t *sa__, uint32_t refclk_freq_hz, enum osprey7_v2l8p2_pll_div_enum srds_div, uint32_t *vco_freq_khz, enum osprey7_v2l8p2_pll_option_enum pll_option);

#ifndef SMALL_FOOTPRINT

/*-------------------*/
/*  Ladder controls  */
/*-------------------*/
/** Converts a ladder setting to mV, given the range.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] ctrl is the threshold control (-31..31) maps to -RANGE to RANGE in non-uniform steps.
 * @param[in] range_250 determines the range 0 = +/-150mV, 1 = +/-250mV (ignored for OSPREY7 and OSPREYLITE7).
 * @param[in] slicer_sel slicer for which ladder threshold needs to be calculated. (Required for OSPREY7 and OSPREYLITE7, unused (can be zero) for all other IPs).
 * @param[out] nlmv_val updated with claculated ladder threshold voltage(mV).
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_ladder_setting_to_mV(srds_access_t *sa__, int16_t ctrl, uint8_t range_250, afe_override_slicer_sel_t slicer_sel, int16_t *nlmv_val);



/*-----------------------*/
/*  TX_PI and ULL Setup  */
/*-----------------------*/

/** Safe multiply - multiplies 2 numbers and checks for overflow.
 * @param[in] a First input.
 * @param[in] b Second input.
 * @param[out] of Pointer to overflow indicator.
 * @return value of a * b.
 */
uint32_t osprey7_v2l8p2_INTERNAL_mult_with_overflow_check(uint32_t a, uint32_t b, uint8_t *of);

/*-----------------------------------------*/
/*  APIs used in Config Shared TX Pattern  */
/*-----------------------------------------*/
/** Compute Binary string for a PAM4 symbol ['0'to '3'].
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] var PAM4 symbol to be converted to Binary ('0', '1', '2', or '3').
 * @param[out] bin Binary string returned by API ('00', '01', '10' or '11').
 * @param[in] bin_size size of bin
 * @return Error Code generated by invalid hex variable (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_pam4_to_bin(srds_access_t *sa__, char var, char bin[], size_t bin_size);

/** Compute Binary string for a Hex value ['0' to 'F'].
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] var Hex value to be converted to Binary (eg: '6', 'A', ...).
 * @param[out] bin Binary string returned by API (eg: '0110', '1010', ...).
 * @param[in] bin_size size of bin
 * @return Error Code generated by invalid hex variable (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_compute_bin(srds_access_t *sa__, char var, char bin[], size_t bin_size);

/** Compute Hex value for a Binary string ['0000' to '1111'].
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] bin Binary string to be coverted (eg: '0110', '1010', ...).
 * @param[out] hex Hex value calculated from the input Binary string.
 * @return Error Code generated by invalid Binary string (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_compute_hex(srds_access_t *sa__, char bin[], uint8_t *hex);

/** Check micro state and request micro to stop. Stop micro only if micro is not stopped currently.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] graceful select the method for stopping (1=graceful stop; 0=Immediate).
 * @param[out] err_code_p pointer to err_code variable which will be returned (returns ERR_CODE_NONE if no errors).
 * @return The previous micro stop status.
  */
uint8_t osprey7_v2l8p2_INTERNAL_stop_micro(srds_access_t *sa__, uint8_t graceful, err_code_t *err_code_p);
/*-----------------------------------*/
/*  APIs used in Read Event Logger   */
/*-----------------------------------*/

/*! State variable for dumping event log.
 * This must be initialized with zeros.
 */
typedef struct {
  uint16_t index, line_start_index, zero_cnt;
} osprey7_v2l8p2_INTERNAL_event_log_dump_state_t;


/** Callback function for dumping event log, intended to be called by osprey7_v2l8p2_INTERNAL_read_event_log_with_callback.
 *  It must also be called once after, with a byte count of 0, to finish printing.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in,out] arg is a osprey7_v2l8p2_INTERNAL_event_log_dump_state_t pointer for holding state.
 * @param[in] byte_count is the number of bytes to dump.
 *        -# This function is called repeatedly with a byte count of 2 with U16 values to dump.
 *        -# This function may then be called with a byte count of 1 if the event log has an odd number of bytes.
 *        -# Finally, this function must be called with a byte count of 0 to finish up.
 * @param[in] data is the event log data to dump.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_event_log_dump_callback(srds_access_t *sa__, void *arg, uint8_t byte_count, uint16_t data);



/** Get Event Log from uC, and call callback for every two bytes.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] micro_num is the number of the microcontroller whose event log should be read.
 * @param[in] bypass_micro is 1 if the micro should not be involved (by stopping event log).
 *                     This mode works even when the micro is hung, and it does not consume the event log.
 * @param[in,out] arg is passed as the first argument to callback.
 * @param[in] callback is called with all of the data read, two bytes at a time.
 *                  The last call of callback may have one byte; in that case, the upper byte is undefined.
 *                  The call is in the form:  callback(arg, byte_count, data).
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_event_log_with_callback(srds_access_t *sa__,
                                                        uint8_t micro_num,
                                                        uint8_t bypass_micro,
                                                        void *arg,
                                                        err_code_t (*callback)(srds_access_t *, void *, uint8_t, uint16_t));

/** Convert float8 to unsigned int32.
 * uint32 = 1.XXX * 2^Y  where float8 bits are XXXYYYYY.
 * @param[in] input Float8 number.
 * @return Unsigned 32bit number.
 */
uint32_t osprey7_v2l8p2_INTERNAL_float8_to_uint32(float8_t input);

/** Convert uint8_t to 8-bit gray code.
 * @param[in] input Unsigned 8-bit number.
 * @return 8-bit gray code number.
 */
uint8_t osprey7_v2l8p2_INTERNAL_uint8_to_gray(uint8_t input);

/** Convert 8-bit gray code to uint8_t.
 * @param[in] input 8-bit gray code number.
 * @return Unsigned 8-bit number.
 */
uint8_t osprey7_v2l8p2_INTERNAL_gray_to_uint8(uint8_t input);

/** Convert seconds to hr:min:sec format.
 * @param[in] seconds 32bit input for time in seconds.
 * @param[out] hrs    Number of hours.
 * @param[out] mins   Number of minutes.
 * @param[out] secs   Number of seconds.
 * @return Unsigned 8-bit number.
 */
uint8_t osprey7_v2l8p2_INTERNAL_seconds_to_displayformat(uint32_t seconds, uint8_t *hrs, uint8_t *mins, uint8_t *secs);

#ifdef TO_FLOATS
/*-----------------------------------*/
/*  APIs used in uC data conversion  */
/*-----------------------------------*/

/** Convert usigned int32 to float8.
 * uint32 = 1.XXX * 2^Y  where float8 bits are XXXYYYYY.
 * @param[in] input Unsigned int.
 * @return Float8 8 bit representations of 32bit number.
 */
float8_t osprey7_v2l8p2_INTERNAL_int32_to_float8(uint32_t input);
#endif

/** Convert float12 to usigned int32.
 * uint32 = XXXXXXXX * 2^YYYY  where float12 bits X=byte and Y=multi.
 * @param[in] input Float8 8bit.
 * @param[in] multi 4 bit multipier.
 * @return Usigned 32bit number.
 */
uint32_t osprey7_v2l8p2_INTERNAL_float12_to_uint32(uint8_t input, uint8_t multi);

/** Get tx ppm value
 * Reads  current tx ppm value.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] tx_ppm returns the current tx_ppm value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_tx_ppm(srds_access_t *sa__, int16_t *tx_ppm);
#endif /* SMALL_FOOTPRINT */

/*-----------------------------*/
/*  Read / Display Core state  */
/*-----------------------------*/
/** Read current osprey7_v2l8p2 core status.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] istate Current osprey7_v2l8p2 core status read back and populated by the API.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_core_state(srds_access_t *sa__, osprey7_v2l8p2_core_state_st *istate);

#ifndef SMALL_FOOTPRINT
/** Display current core state.
 * Reads and displays all important core state values.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_display_core_state_no_newline(srds_access_t *sa__);

/*-----------------------------*/
/*  Read / Display Lane state  */
/*-----------------------------*/
/** Read current osprey7_v2l8p2 lane status.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] istate Current osprey7_v2l8p2 lane status read back and populated by the API.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *istate);

/*------------------------------------*/
/*  Read Lane state Helper Functions  */
/*------------------------------------*/
err_code_t osprey7_v2l8p2_INTERNAL_resume_micro_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_stop_state_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_pmd_lock_chg_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_osr_str_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_uc_cfg_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_txfir_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_uc_sts_decoded_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_pam_mode_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_disable_eye_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_TP0_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_pf_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_clk_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_dfe_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_afe_bw_metric_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_ffe_lane_state(srds_access_t *sa__, osprey7_v2l8p2_lane_state_st_t *st);

/*-----------------*/
/*  Get OSR mode   */
/*-----------------*/
/** Read current osprey7_v2l8p2 lane status.
 * Note: Returns the hardware status, not the control value.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] mode Returns with the osr mode structure.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_osr_mode(srds_access_t *sa__, osprey7_v2l8p2_osr_mode_st *mode);

#define GET_OSR_STR_SHORT  (0)
#define GET_OSR_STR_LONG   (1)

/** Get a string representation of an osprey7_v2l8p2_osr_mode_enum enum value.
 * @param[in] osr_val a osprey7_v2l8p2_osr_mode_enum value.
 * @param[in] osr_str_length return string length specifier. Set this to GET_OSR_STR_SHORT
 *            for a return string of length 2, or GET_OSR_STR_LONG for a return string
 *            of length 5.
 * @return const char pointer containing a string representation of the input osr_val.
 */
const char* osprey7_v2l8p2_INTERNAL_get_osr_str(uint8_t osr_val, uint8_t osr_str_length);

#endif /* SMALL_FOOTPRINT */

/*-------------------*/
/*  Get RX_PAM mode  */
/*-------------------*/
/** Read current RX PAM mode.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] pmode Returns the current RX PAM mode.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_pam_mode(srds_access_t *sa__, enum osprey7_v2l8p2_rx_pam_mode_enum *pmode);

#ifndef SMALL_FOOTPRINT
/*---------------------*/
/*  Decode BR/OS mode  */
/*---------------------*/
/** For PAM mode, read os_pattern_enhanced and os_all_edges.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] br_pd_en Returns the decoded BR/OS mode.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_decode_br_os_mode(srds_access_t *sa__, uint8_t *br_pd_en);
#endif /* SMALL_FOOTPRINT */

/*-------------------*/
/*  Get LCK status   */
/*-------------------*/
/** Read current Signal_detect and Signal_detect change status of a lane.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] sig_det Current osprey7_v2l8p2 lane signal_detect status read back and populated by the API.
 * @param[out] sig_det_chg Current osprey7_v2l8p2 lane signal_detect_change status read back and populated by the API.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_sigdet_status(srds_access_t *sa__, uint8_t *sig_det, uint8_t *sig_det_chg);

/** Serdes Core ClockGate.
 * Along with osprey7_v2l8p2_core_clkgate(), all lanes should also be clock gated using osprey7_v2l8p2_lane_clkgate() to complete a Core Clockgate.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] enable Enable clockgate (1 = Enable clokgate; 0 = Disable clockgate).
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_core_clkgate(srds_access_t *sa__, uint8_t enable);

/** Read current PLL Lock and PLL Lock change status of a core.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] pll_lock Current osprey7_v2l8p2 lane pll_lock status read back and populated by the API.
 * @param[out] pll_lock_chg Current osprey7_v2l8p2 lane pll_lock_change status read back and populated by the API.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_pll_lock_status(srds_access_t *sa__, uint8_t *pll_lock, uint8_t *pll_lock_chg);

#ifndef SMALL_FOOTPRINT
/** Read current PMD Lock and PMD Lock change status of a lane.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] pmd_lock Current osprey7_v2l8p2 lane pmd_rx_lock status read back and populated by the API.
 * @param[out] pmd_lock_chg Current osprey7_v2l8p2 lane pmd_rx_lock_change status read back and populated by the API.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_pmd_lock_status(srds_access_t *sa__, uint8_t *pmd_lock, uint8_t *pmd_lock_chg);

/** Obtain tuningdone time from status variable.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] tuningdone_time time measured in ms.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_tuningdone_time(srds_access_t *sa__, uint32_t *tuningdone_time);

/** Obtain link time from status variable.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] link_time Link time measured in ms.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_link_time(srds_access_t *sa__, uint32_t *link_time);

/** Display current lane state.
 * Reads and displays all important lane state values.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_display_lane_state_no_newline(srds_access_t *sa__);


/*-----------------------------------------------*/
/*  Get dynamic eye margin estimation values     */
/*-----------------------------------------------*/
/** Get dynamic eye estimation values.
 * Reads and converts the Eye margin estimation from the uC.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] left_eye_mUI a pointer to integer with return value of eye margin in units of mUI.
 * @param[out] right_eye_mUI a pointer to integer with return value of eye margin in units of mUI.
 * @param[out] upper_eye_mV a pointer to integer with return value of eye margin in units of mV.
 * @param[out] lower_eye_mV a pointer to integer with return value of eye margin in units of mV.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_eye_margin_est(srds_access_t *sa__, uint16_t *left_eye_mUI, uint16_t *right_eye_mUI, uint16_t  *upper_eye_mV, uint16_t *lower_eye_mV);

/** Convert eye margin to mV.
 * Takes in the ladder setting with 3 fractional bits and converts to mV.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] var Ladder setting with 3 fractional bits.
 * @param[in] ladder_range Specified if ladder is configured for 150mV or 250mV range.
 * @return Eye opening in mV.
 */
uint16_t osprey7_v2l8p2_INTERNAL_eye_to_mV(srds_access_t *sa__, uint8_t var, uint8_t ladder_range);

/** Convert eye margin to mUI.
 * Takes in a horizontal margin in Phase Interpolator codes and converts it to mUI.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] var Horizontal margin in Phase Interpolator codes with 3 fractional bits.
 * @return Eye opening in mV.
 */
uint16_t osprey7_v2l8p2_INTERNAL_eye_to_mUI(srds_access_t *sa__, uint8_t var);

#define NUM_PAM_EYES 3
/*-------------------------*/
/** PAM eye margin struct  */
/*-------------------------*/
typedef struct {
    uint16_t left_eye_mUI [NUM_PAM_EYES];
    uint16_t right_eye_mUI[NUM_PAM_EYES];
    uint16_t upper_eye_mV [NUM_PAM_EYES];
    uint16_t lower_eye_mV [NUM_PAM_EYES];
} osprey7_v2l8p2_eye_margin_t;

/*----------------------------------------------------*/
/*  Get dynamic eye margin estimation values (PAM)    */
/*----------------------------------------------------*/
/** Get dynamic eye estimation values for PAM mode.
 * Reads and converts the Eye margin estimation from the uC.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] eye_margin is a struct that contains all four corners - left(mUI), right(mUI), upper(mV) and lower(mV) for 3 eyes.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_pam_eye_margin_est(srds_access_t *sa__, osprey7_v2l8p2_eye_margin_t *eye_margin);

/*------------------------------------------------------*/
/*  Print dynamic eye margin estimation values (PAM)    */
/*------------------------------------------------------*/
/** Print dynamic eye estimation values for PAM mode.
 * Reads, converts and prints the Eye margin estimation from the uC.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_display_pam_eye_margin_est(srds_access_t *sa__);

/** Serdes Lane ClockGate.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] enable Enable lane clockgate (1 = Enable clockgate; 0 = Disable clockgate).
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_lane_clkgate(srds_access_t *sa__, uint8_t enable);

#endif /* !SMALL_FOOTPRINT */
#if !defined(SMALL_FOOTPRINT) 
/*--------------------*/
/*  Get/Set PF status */
/*--------------------*/
/** Set function for PF.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val PF value to be set.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_pf_main(srds_access_t *sa__, uint8_t val);

/** Set function for PF2.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val PF2 value to be set.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_pf2(srds_access_t *sa__, uint8_t val);

/** Set function for PF3.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val  PF3 value to be set.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_pf3(srds_access_t *sa__, uint8_t val);
#endif /* !SMALL_FOOTPRINT */

#ifndef SMALL_FOOTPRINT
/** Get function for PF
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val PF read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_pf_main(srds_access_t *sa__, uint8_t *val);

/** Get function for PF2.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val PF2 read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_pf2(srds_access_t *sa__, uint8_t *val);

/** Get function for PF3.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val PF3 read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_pf3(srds_access_t *sa__, uint8_t *val);

/** Get the reference ladder range.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val 16 bit signed value of the ladder range.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_vrefgen_range(srds_access_t *sa__, int16_t *val);

/** Get the reference ladder mode.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val 16 bit value of the ladder mode.
 * @return Error Code, if generated (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_vrefgen_ladder_mode(srds_access_t *sa__, uint16_t *val);

#endif /* !SMALL_FOOTPRINT */

#if !defined(SMALL_FOOTPRINT) 
/** Set function for VGA.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val unsigned input value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_vga(srds_access_t *sa__, uint8_t val);

/** Set function for FGA.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val unsigned input value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_fga(srds_access_t *sa__, uint8_t val);

/** Set function for DFE Tap1.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val signed input value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe1(srds_access_t *sa__, int8_t val);

/** Set function for DFE Tap2.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val signed input value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe2(srds_access_t *sa__, int8_t val);

/** Set function for DFE Tap3.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val signed input value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe3(srds_access_t *sa__, int8_t val);

/** Set function for DFE Tap4.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val signed input value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe4(srds_access_t *sa__, int8_t val);

/** Set function for DFE Tap5.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] val signed input value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe5(srds_access_t *sa__, int8_t val);

/* Set DFE tap values */
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe6(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe7(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe8(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe9(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe10(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe11(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe12(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe13(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe14(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe15(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe16(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe17(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_dfe18(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_ffe_pre(srds_access_t *sa__, int8_t val);
err_code_t osprey7_v2l8p2_INTERNAL_set_rx_ffe_post(srds_access_t *sa__, int8_t val);
#endif /* !SMALL_FOOTPRINT */

#ifndef SMALL_FOOTPRINT
/** Get function for VGA.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val VGA read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_vga(srds_access_t *sa__, uint8_t *val);

/** Get function for FGA.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val FGA read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_fga(srds_access_t *sa__, uint8_t *val);

/** Get function for DFE Tap1.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val DFE1 read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe1(srds_access_t *sa__, int8_t *val);

/** Get function for DFE Tap2.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val DFE2 read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe2(srds_access_t *sa__, int8_t *val);

/** Get function for DFE Tap3.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val DFE3 read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe3(srds_access_t *sa__, int8_t *val);

/** Get function for DFE Tap4.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val DFE4 read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe4(srds_access_t *sa__, int8_t *val);

/** Get function for DFE Tap5.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] val DFE5 read value.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe5(srds_access_t *sa__, int8_t *val);

/* Get DFE tap values */
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe6(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe7(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe8(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe9(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe10(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe11(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe12(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe13(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe14(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe15(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe16(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe17(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_dfe18(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_ffe_gain(srds_access_t *sa__, uint8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_ffe_pre(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_rx_ffe_post(srds_access_t *sa__, int8_t *val);
err_code_t osprey7_v2l8p2_INTERNAL_get_ffe_enabled(srds_access_t *sa__, uint8_t *val);

/** Get Intrusive Eye Scan data for 0 to 0.167 UI to BER 1e-5.
 *  Function uses uC to acquire data.
 *
 * @param sa__ is an opaque state vector passed through to device access functions.
 * @param[out] data is a pointer to the array for intrusive eye scan data collection.
 * @param[out] y_max is the starting point on vertical axis for eye scan plot.
 * @param[out] y_step is the step size on vertical axis for eye scan plot.
 * @param[out] lane_mask A mask of the lanes which successfully completed eye scan setup
 *             and data acquisition.
 * @param[in] num_lanes the number of lanes to run this function on. If this value is set to 1,
              then this function will only run on the currently selected lane. If num_lanes > 1,
 *            then this function will run on lanes 0 to num_lanes - 1.
 * @param[out] usr_diag_status is the diagnostic status information returned by microcode.
 * @return Error Code during data collection (returns ERR_CODE_NONE if no errors)
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_intrusive_eye_scan(srds_access_t *sa__, uint32_t *data, int16_t *y_max, int16_t *y_step, uint8_t *lane_mask, uint8_t num_lanes, uint16_t *usr_diag_status);

/** Internal Eye Scan setup function.
 *
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] intr_pass_b selects between intrusive (1) or passive (0) eye scan.
 * @param[out] y_max is the starting point on vertical axis for eye scan plot.
 * @param[out] y_step is the step size on vertical axis for eye scan plot.
 * @param[out] usr_diag_status is the diagnostic status information returned by microcode.
 * @return Error Code during data collection (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_eye_scan_setup(srds_access_t *sa__, uint8_t intr_pass_b, int16_t *y_max, int16_t *y_step, uint16_t *usr_diag_status);
#endif /* SMALL_FOOTPRINT */

/*----------------------*/
/*  Get/Set TXFIR Taps  */
/*----------------------*/

err_code_t osprey7_v2l8p2_INTERNAL_load_txfir_taps(srds_access_t *sa__);
err_code_t osprey7_v2l8p2_INTERNAL_set_tx_tap(srds_access_t *sa__, uint8_t tap_num, int16_t val);
err_code_t osprey7_v2l8p2_INTERNAL_get_tx_tap(srds_access_t *sa__, uint8_t tap_num, int16_t *val);

/** Validates Blackhawk TXFIR tap settings.
 * Returns failcodes if TXFIR settings are invalid.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] enable_taps Enable TXFIR TAPs based on #osprey7_v2l8p2_txfir_tap_enable_enum.
 * @param[in] txfir the 6 TXFIR tap values (-168 to +168 when in PAM4 mode, otherwise -127 to +127).
 * @return Error Code generated by invalid tap settings (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_validate_full_txfir_cfg(srds_access_t *sa__, enum osprey7_v2l8p2_txfir_tap_enable_enum enable_taps, osprey7_v2l8p2_txfir_st *txfir);

/** Writes Serdes TXFIR tap settings.
 * Returns failcodes if TXFIR settings are invalid.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] enable_taps Enable TXFIR TAPs based on #osprey7_v2l8p2_txfir_tap_enable_enum.
 * @param[in] txfir the 6 TXFIR tap values (-168 to +168 when in PAM4 mode, otherwise -63 to +63).
 * @return Error Code generated by invalid tap settings (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_apply_full_txfir_cfg(srds_access_t *sa__, enum osprey7_v2l8p2_txfir_tap_enable_enum enable_taps, osprey7_v2l8p2_txfir_st *txfir);


/* Lane Config Struct */
err_code_t osprey7_v2l8p2_INTERNAL_update_uc_lane_config_st(struct osprey7_v2l8p2_uc_lane_config_st *st);
err_code_t osprey7_v2l8p2_INTERNAL_update_uc_lane_config_word(struct osprey7_v2l8p2_uc_lane_config_st *st);

/* Lane User Control Disable Startup Function Struct */
err_code_t osprey7_v2l8p2_INTERNAL_update_usr_ctrl_disable_functions_st(struct osprey7_v2l8p2_usr_ctrl_disable_functions_st *st);
err_code_t osprey7_v2l8p2_INTERNAL_update_usr_ctrl_disable_functions_byte(struct osprey7_v2l8p2_usr_ctrl_disable_functions_st *st);

/* Lane User Control Disable Startup DFE Function Struct */
err_code_t osprey7_v2l8p2_INTERNAL_update_usr_ctrl_disable_dfe_functions_st(struct osprey7_v2l8p2_usr_ctrl_disable_dfe_functions_st *st);
err_code_t osprey7_v2l8p2_INTERNAL_update_usr_ctrl_disable_dfe_functions_byte(struct osprey7_v2l8p2_usr_ctrl_disable_dfe_functions_st *st);

/* Core Config Struct */
err_code_t osprey7_v2l8p2_INTERNAL_update_uc_core_config_st(struct  osprey7_v2l8p2_uc_core_config_st *st);
err_code_t osprey7_v2l8p2_INTERNAL_update_uc_core_config_word(struct  osprey7_v2l8p2_uc_core_config_st *st);

#ifndef SMALL_FOOTPRINT
uint8_t osprey7_v2l8p2_INTERNAL_rdb_uc_var(srds_access_t *sa__, err_code_t *err_code_p, uint32_t addr);
uint16_t osprey7_v2l8p2_INTERNAL_rdw_uc_var(srds_access_t *sa__, err_code_t *err_code_p, uint32_t addr);
err_code_t osprey7_v2l8p2_INTERNAL_wrb_uc_var(srds_access_t *sa__, uint32_t addr, uint8_t wr_val);
err_code_t osprey7_v2l8p2_INTERNAL_wrw_uc_var(srds_access_t *sa__, uint32_t addr, uint16_t wr_val);
#endif /* SMALL_FOOTPRINT */

/*--------------------------*/
/*  Register field polling  */
/*--------------------------*/

err_code_t osprey7_v2l8p2_INTERNAL_print_uc_dsc_error(srds_access_t *sa__, enum srds_pmd_uc_cmd_enum cmd);

/** Polls lane variable "usr_diag_status" to verify data is available in uC diag buffer.
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided.
 *
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] status returns a status byte. \n
 *    bit 15 - indicates the ey scan is complete. \n
 *    bit 14-0 - reserved for debug.
 *
 * @param[in] timeout_ms Maximum time interval in milliseconds for which the polling is done.
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_poll_diag_done(srds_access_t *sa__, uint16_t *status, uint32_t timeout_ms);

/** Polls for register field "uc_dsc_ready_for_cmd" to be 1 within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code.
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] timeout_ms Maximum time interval in milliseconds for which the polling is done.
 * @param[in] cmd The command that was issued; this is used for error reporting.
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_poll_uc_dsc_ready_for_cmd_equals_1(srds_access_t *sa__, uint32_t timeout_ms, enum srds_pmd_uc_cmd_enum cmd);

/** Polls for register field "dsc_state" to be "DSC_STATE_UC_TUNE".
 * within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code.
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] timeout_ms Maximum time interval in milliseconds for which the polling is done.
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_poll_dsc_state_equals_uc_tune(srds_access_t *sa__, uint32_t timeout_ms);


/** Polls for register field "micro_ra_initdone" to be 1 within the time interval specified by timeout_ms.
 * Function returns 0 if polling passes, else it returns error code.
 * Define macro CUSTOM_REG_POLLING to replace the default implementation provided.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] timeout_ms Maximum time interval in milliseconds for which the polling is done.
 * @return Error code generated by polling function (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_poll_micro_ra_initdone(srds_access_t *sa__, uint32_t timeout_ms);

/** Utility to figure out if running platform is big endian.
 * @return value of 1 if big endian else 0
 */
uint8_t osprey7_v2l8p2_INTERNAL_is_big_endian(void);
/*--------------------------------*/
/*  RAM Block Read with Callback  */
/*--------------------------------*/

/* Utilities to account for endianness when reading from uc RAM */
#define get_endian_offset(addr) (osprey7_v2l8p2_INTERNAL_is_big_endian() ? \
                                (\
                                (((USR_UINTPTR)(addr))%4 == 0) ?  3 : \
                                (((USR_UINTPTR)(addr))%4 == 1) ?  1 : \
                                (((USR_UINTPTR)(addr))%4 == 2) ? -1 : \
                                (((USR_UINTPTR)(addr))%4 == 3) ? -3 : \
                                0) \
                                : 0)
/*! Used for passing arg to callback function
 *
 */
typedef struct {
    uint8_t *mem_ptr;
} osprey7_v2l8p2_INTERNAL_rdblk_callback_arg_t;

/*! Ram Dump State struct
  *
  */
typedef struct {
    uint16_t index;
    uint16_t line_start_index;
    uint8_t  ram_idx;
    int32_t  count;
}osprey7_v2l8p2_INTERNAL_ram_dump_state_t;

/*! Read Block Ram Arg struct
  *
  */
typedef struct {
    char    *ram_buff;
    uint8_t *mem_ptr;
    uint32_t ram_size;
    osprey7_v2l8p2_INTERNAL_ram_dump_state_t *dump_state_ptr;
} osprey7_v2l8p2_INTERNAL_rdblk_ram_arg_t;

uint32_t _osprey7_v2l8p2_INTERNAL_get_addr_from_lane(srds_access_t *sa__, uint16_t addr, uint8_t lane);
uint32_t _osprey7_v2l8p2_INTERNAL_get_static_addr_from_lane(srds_access_t *sa__, uint16_t addr, uint8_t lane);
uint32_t _osprey7_v2l8p2_INTERNAL_get_uc_addr_from_lane(srds_access_t *sa__, uint16_t addr, uint8_t lane);
uint32_t _osprey7_v2l8p2_INTERNAL_get_addr_from_core(srds_access_t *sa__, uint16_t addr);

err_code_t osprey7_v2l8p2_INTERNAL_rdblk_ram_read_callback(srds_access_t *sa__,void *arg,uint8_t byte_count,uint16_t data);

err_code_t osprey7_v2l8p2_INTERNAL_ram_dump_callback(srds_access_t *sa__, void *arg, uint8_t byte_count, uint16_t data);
/** Callback function for reading uc RAM memory by osprey7_v2l8p2_INTERNAL_rdblk_uc_generic_ram().
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in,out] arg is a osprey7_v2l8p2_INTERNAL_rdblk_callback_arg_t pointer for holding state.
 * @param[in] byte_count is the number of bytes to store.
 *        -# This function is called repeatedly with a byte count of 2 with U16 values to store.
 *        -# This function may then be called with a byte count of 1 if there are an odd number of bytes.
 * @param[in] data is the RAM data to store.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_rdblk_callback(srds_access_t *sa__, void *arg, uint8_t byte_count, uint16_t data);

/** Callback function for reading uc RAM memory by osprey7_v2l8p2_INTERNAL_rdblk_uc_generic_ram() customized for
lane_var,core_var and micro_var functions.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in,out] arg is a osprey7_v2l8p2_INTERNAL_rdblk_callback_arg_t pointer for holding state.
 * @param[in] byte_count is the number of bytes to store.
 *        -# This function is called repeatedly with a byte count of 2 with U16 values to store.
 *        -# This function may then be called with a byte count of 1 if there are an odd number of bytes.
 * @param[in] data is the RAM data to store.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_rdblk_ram_callback(srds_access_t *sa__,void *arg,uint8_t byte_count, uint16_t data);

/** Block RAM read through Micro Register Interface, suitable for program RAM or non-program RAM.
 *  This reads a block of RAM, possibly starting midway through it and wrapping back to the beginning.
 *  The order of operations is:
 *      -# RAM will be read from (block_addr+start_offset) to (block_addr+block_size-1),
 *         up to cnt bytes.
 *      -# RAM will be read from block_addr to (block_addr+block_size-1), repeating
 *         indefinitely, until cnt bytes total are read.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] block_addr Address of RAM block to be read.
 *                   For program RAM, the upper 16 bits are 0x0000.  Otherwise, the upper 16 bits are 0x2000.
 * @param[in] block_size Length of RAM block to read.
 * @param[in] start_offset Offset within RAM block to start reading.
 * @param cnt Number of bytes to be read.
 * @param[in,out] arg is passed as the first argument to callback.
 * @param[in] callback is called with all of the data read, two bytes at a time.
 *                  The last call of callback may have one byte; in that case, the upper byte is undefined.
 *                  The call is in the form:  callback(arg, byte_count, data).
 * @return Error Code generated by API or the callback (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_rdblk_uc_generic_ram(srds_access_t *sa__,
                                                uint32_t block_addr,
                                                uint32_t block_size,
                                                uint32_t start_offset,
                                                uint32_t cnt,
                                                void *arg,
                                                err_code_t (*callback)(srds_access_t *, void *, uint8_t, uint16_t));

/** Block RAM read through Micro Register Interface, suitable for program RAM or non-program RAM.
 *  This reads a block of RAM, possibly starting midway through it and wrapping back to the beginning.
 *  The order of operations is:
 *      -# RAM will be read from (block_addr+start_offset) down to block_addr, up to cnt bytes.
 *      -# RAM will be read from (block_addr+block_size-1) down to block_addr, repeating
 *         indefinitely, until cnt bytes total are read.
 *  In other words, this is the same as osprey7_v2l8p2_INTERNAL_rdblk_uc_generic_ram(), but reading in descending address order.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param block_addr Address of RAM block to be read.
 *                   For program RAM, the upper 16 bits are 0x0000.  Otherwise, the upper 16 bits are 0x2000.
 * @param[in] block_size Length of RAM block to read.
 * @param[in] start_offset Offset within RAM block to start reading.
 * @param[in] cnt Number of bytes to be read.
 * @param[in,out] arg is passed as the first argument to callback.
 * @param[in] callback is called with all of the data read, two bytes at a time.
 *                  The last call of callback may have one byte; in that case, the upper byte is undefined.
 *                  The call is in the form:  callback(arg, byte_count, data).
 * @return Error Code generated by API or the callback (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_rdblk_uc_generic_ram_descending(srds_access_t *sa__,
                                                           uint32_t block_addr,
                                                           uint32_t block_size,
                                                           uint32_t start_offset,
                                                           uint32_t cnt,
                                                           void *arg,
                                                           err_code_t (*callback)(srds_access_t *, void *, uint8_t, uint16_t));

/** Retrieve micro index based on lane index.
 * @param lane Lane index.
 * @return Micro index.
 */
uint8_t osprey7_v2l8p2_INTERNAL_grp_idx_from_lane(uint8_t lane);


/** Extract the refclk frequency in Hz, based on a osprey7_v2l8p2_pll_refclk_enum value.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] refclk REFCLK input.
 * @param[out] refclk_in_hz REFCLK value in Hz updated by API.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_refclk_in_hz(srds_access_t *sa__, enum osprey7_v2l8p2_pll_refclk_enum refclk, uint32_t *refclk_in_hz);

/** Retrieve LMS threshold value.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] lms_thresh_bin lms_threshold value to be populated by the API.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_lms_thresh_bin(srds_access_t *sa__, int8_t *lms_thresh_bin);

#ifndef SMALL_FOOTPRINT
/** Polls for the dbgfb idx lock.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] timeout_ms polling timeout value in ms.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_poll_dbgfb_idx_lock(srds_access_t *sa__, uint8_t timeout_ms);

/** Reads dbgfb counters.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] dbgfb_cfg pointer to dbgfb_cfg_st.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_get_dbgfb_summary(srds_access_t *sa__, osprey7_v2l8p2_dbgfb_cfg_st *dbgfb_cfg);

/** collects dbgfb stats for all. Newer Osprey7 has feature in uCode, else use the api method.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] time_in_us 32 bit field that carries the run time for fb stats accumulation.
 *      NOTE: The uCode timer granularity is 10uS thus this timeout will not honor uS increments less than 10uS.
 * @param[out] dbgfb_stats pointer of type osprey7_v2l8p2_dbgfb_stats_st.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_dbgfb_collect_stats(srds_access_t *sa__, uint32_t time_in_us, osprey7_v2l8p2_dbgfb_stats_st *dbgfb_stats);

err_code_t osprey7_v2l8p2_dbgfb_collect_stats_api_method(srds_access_t *sa__, uint32_t time_in_us, osprey7_v2l8p2_dbgfb_stats_st *dbgfb_stats);

/* The following errors may be returned from the uCode for the following dbgfb functions
 *   #define DBG_FB_STATE_START       0
 *   #define DBG_FB_STATE_INVALID     1
 *   #define DBG_FB_STATE_POLL_ERR    2
 *   #define DBG_FB_STATE_IDX_ERR     3
 *   #define DBG_FB_STATE_IN_PROGRESS 4
 *   #define DBG_FB_STATE_DONE        5
 */

/** Configures and starts a dbgfb stats collection for a specific core:lane
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] sample_time_in_ms 16 bit field that carries the sample time for fb stats accumulation.
 *      NOTE: The uCode timer granularity is 10uS thus this timeout will not honor uS increments less than 10uS.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_dbgfb_stats_config_and_start(srds_access_t *sa__, uint16_t sample_time_in_ms);

/** Polls on a dbgfb stats collection looking for completion at the ucode. Once complete will restore that specific core:lane
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] poll_timeout_in_us 32 bit field that carries the polling time for fb stats accumulation before declaring a timeout error.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_dbgfb_stats_poll(srds_access_t *sa__, uint32_t poll_timeout_in_us);

/** Retreives fb data from a core:lane. Should be called after a successful configure/start/poll fb stats collection.
 ** Identical to osprey7_v2l8p2_dbgfb_stats_get_data_ptr() but usedful inside of functions that operate on multiple lanes in parallel.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] dbgfb_stats pointer of type osprey7_v2l8p2_dbgfb_stats_st where data from uCode will be copied.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_dbgfb_stats_get_data(srds_access_t *sa__, osprey7_v2l8p2_dbgfb_stats_st *dbgfb_stats);

#endif /* SMALL_FOOTPRINT */

/** Reads the slicer calibration error values.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] lms_err lms calibration error value.
 * @param[out] phase_err phase calibration error value.
 * @param[out] data_err data calibration error value.
 * @param[out] max_data_err max data calibration error value.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_cal_error(srds_access_t *sa__, int8_t *lms_err, int8_t *phase_err, int8_t *data_err, int8_t *max_data_err);
/** Reads horizontal calibration residual error values.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] lms_hcal_residual_error lms calibration error values.
 * @param[out] phs_hcal_residual_error phase calibration error values.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_hcal_residual_errors(srds_access_t *sa__, int8_t *lms_hcal_residual_error, int8_t *phs_hcal_residual_error);

#ifndef SMALL_FOOTPRINT
/** Select the clk from the clk4sync block.
 * Selects the fast clk(VCO divided) if enabled, or slow clk(comclk) when disabled.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] enable 1: enabled, 0: disabled.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_clk4sync_div2_sequence(srds_access_t *sa__, uint8_t enable);
#endif /* SMALL_FOOTPRINT */

/** Reads the slicer calibration error values.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] lms_err_q lms calibration error value.
 * @param[out] phase_err_q phase calibration error value.
 * @param[out] data_err_q data calibration error value.
 * @param[out] max_data_err_q max data calibration error value.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_cal_error_q(srds_access_t *sa__, int8_t *lms_err_q, int8_t *phase_err_q, int8_t *data_err_q, int8_t *max_data_err_q);

/** Reads the iq cal inl errors.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] inl_ary is an array[2][4] containing four inl measurements for each of the two PIs in Osprey
 * @param[out] residual_inl is the aggregate residual INL metric coming from the array above.
 * @return Error Code generated by API (ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_read_iq_cal_inls(srds_access_t *sa__, int8_t inl_ary[][4], int8_t *residual_inl);


/** Print info table.
 * Prints out all info_table struct member values.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_display_info_table(srds_access_t *sa__);
/** Get logical tx lane.
 * Given a physical tx lane, returns the logical tx lane mapped to it.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] physical_tx_lane index of the physical tx lane.
 * @param[out] logical_tx_lane pointer to the logical tx lane that will get populated.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_logical_tx_lane_addr(srds_access_t *sa__, uint8_t physical_tx_lane, uint8_t *logical_tx_lane);

/** Get logical rx lane.
 * Given a physical rx lane, returns the logical rx lane mapped to it.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] physical_rx_lane index of the physical rx lane.
 * @param[out] logical_rx_lane pointer to the logical rx lane that will get populated.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_get_logical_rx_lane_addr(srds_access_t *sa__, uint8_t physical_rx_lane, uint8_t *logical_rx_lane);
#ifndef SMALL_FOOTPRINT
/** Enable breakpoint.
 * Enables a breakpoint at the given breakpoint param value.
 * Note: This API should only be used under the direction of engineering.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] breakpoint index of breakpoint to enable.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_en_breakpoint(srds_access_t *sa__, uint8_t breakpoint);

/** Goto Breakpoint.
 * Goes to the breakpoint selected by the given breakpoint param value.
 * Note: This API should only be used under the direction of engineering.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] breakpoint index of breakpoint to enable.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_goto_breakpoint(srds_access_t *sa__, uint8_t breakpoint);

/** Read breakpoint.
 * Reads and prints status of breakpoint.
 * Note: This API should only be used under the direction of engineering.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_rd_breakpoint(srds_access_t *sa__);

/** Disable all breakpoint.
 * Disables all breakpoints and continues normal execution.
 * Note: This API should only be used under the direction of engineering.
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_dis_breakpoint(srds_access_t *sa__);

/** Convert osr_mode to an int
 * Returns the converted osr_mode x1000 for rate calculations
 * @param[in] osr_mode is the osr_mode to convert
 * @return The converted osr_mode number times 1000
 */
uint32_t osprey7_v2l8p2_osr_mode_enum_to_int_x1000(uint8_t osr_mode);

#endif /* SMALL_FOOTPRINT */

/** Checks if FLR is supported
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[out] flr_support a pointer with return value indicating if FLR is supported or not (0 = unsupported; 1 = supported)
 * @return Error Code generated by API (ERR_CODE_NONE if no errors)
 */
err_code_t osprey7_v2l8p2_INTERNAL_is_flr_supported(srds_access_t *sa__, uint8_t *flr_support);


#if !defined(SMALL_FOOTPRINT)
/** Poll for diag data
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] osprey7_v2l8p2_info_ptr Used for retrieving the diag mem RAM_size.
 * @param[out] status Returns read value of  usr diag status.
 * @param[out] diag_rd_ptr Returns read value of usr diag read pointer.
 * @param[in] byte_count The number of bytes to be read from diag mem.
 * @param[in] timeout_ms Time in milliseconds to wait for sufficient diag data.
 * @return Error Code generated by API (returns ERR_CODE_NONE if no errors)
 */
err_code_t osprey7_v2l8p2_INTERNAL_poll_diag_data(srds_access_t *sa__, const srds_info_t *osprey7_v2l8p2_info_ptr, uint16_t *status, uint8_t *diag_rd_ptr, uint8_t byte_count, uint32_t timeout_ms);

/** Example eye margin projection start API.
 * This is an example function which uses the following API to start BER margin projections measurement.
 * osprey7_v2l8p2_start_ber_scan_test().
 *
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] ber_scan_mode the type of test used to take the data(use #srds_diag_ber_mode_enum).
 * @param[in] timer_control sets the total test time in units of ~1.31 seconds.
 * @param[in] max_error_control sets the error threshold for test in units of 16.(4=64 errors).
 * @param[out] offset_start is the maximum offset setting which is present in data (usually 31).
 * @return Error Code during data collection (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_eye_margin_proj_start(srds_access_t *sa__, uint8_t ber_scan_mode, uint8_t timer_control, uint8_t max_error_control, int16_t *offset_start);
/** Example eye margin projection end API.
 * This is an example function which uses the following API's to read and display BER margin projections.
 * osprey7_v2l8p2_read_ber_scan_data(), osprey7_v2l8p2_display_ber_scan_data().
 *
 * @param[in] sa__ is an opaque state vector passed through to device access functions.
 * @param[in] rate specifies the data rate in Hz.
 * @param[in] ber_scan_mode the type of test used to take the data(use #srds_diag_ber_mode_enum).
 * @param[in] timer_control sets the total test time in units of ~1.31 seconds.
 * @param[in] offset_start is the maximum offset setting which is present in data (usually 31).
 * @return Error Code during data collection (returns ERR_CODE_NONE if no errors).
 */
err_code_t osprey7_v2l8p2_INTERNAL_eye_margin_proj_end(srds_access_t *sa__, USR_DOUBLE rate, uint8_t ber_scan_mode, uint8_t timer_control, int16_t offset_start);

#endif /* !defined(SMALL_FOOTPRINT */
/*-------------------*/
/*  Name resolution  */
/*-------------------*/

/* For bitfields that differ for different cores, these macros are defined to resolve the bitfield. */

#   define WR_RX_PF_CTRL  wr_rx_pfmid_zero_val
#   define RD_RX_PF_CTRL  rd_rx_pfmid_zero_val
#   define WR_RX_PF2_CTRL wr_rx_pflow_ctrl_val
#   define RD_RX_PF2_CTRL rd_rx_pflow_ctrl_val
#   define WR_RX_PF3_CTRL wr_rx_pfhi_zero_val
#   define RD_RX_PF3_CTRL rd_rx_pfhi_zero_val

/*! @} SerdesAPIInternalTag */
/*! @} APITag */
#endif /* !SERDES_API_INTERNAL_H */
#ifdef __cplusplus
}
#endif

