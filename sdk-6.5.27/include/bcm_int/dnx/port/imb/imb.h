
/*
 *         
 * 
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2022 Broadcom Inc. All rights reserved.
 *     
 * DO NOT EDIT THIS FILE!
 *
 */

#ifndef _IMB_H__H_
#define _IMB_H__H_

#include <soc/portmod/portmod.h>
#include <bcm/port.h>
#include <bcm/cosq.h>
#include <bcm_int/dnx/port/imb/imb_diag.h>
#include <bcm_int/dnx/cosq/ingress/cosq_ingress_port.h>
#include <soc/dnxc/dnxc_port.h>

/*!
 * @enum imb_dispatch_type_e
 * @brief Supported Drivers 
 */
typedef enum imb_dispatch_type_e
{
    imbDispatchTypeNone,
    imbDispatchTypeImb_cdu,
    imbDispatchTypeImb_clu,
    imbDispatchTypeImb_ile,
    imbDispatchTypeImb_ilu,
    imbDispatchTypeImb_feu_phy,
    imbDispatchTypeImb_fabric,
    imbDispatchTypeImb_cdu_shr,
    imbDispatchTypeImb_framer,
    imbDispatchTypeImb_otnu_phy,
    imbDispatchTypeCount
} imb_dispatch_type_t;

extern const enum_mapping_t imb_dispatch_type_t_mapping[];
/* imb_dispatch_type_t validation */
int imb_dispatch_type_t_validate(
    int unit,
    imb_dispatch_type_t imb_dispatch_type);

/*!
 * @struct imb_cdu_create_info_s
 * @brief CDU specific information required for IMB init. 
 */
typedef struct imb_cdu_create_info_s
{
    void *user_acc; /**< user access information to be passed to portmod layer. */
} imb_cdu_create_info_t;

/*!
 * @struct imb_clu_create_info_s
 * @brief CLU specific information required for IMB init. 
 */
typedef struct imb_clu_create_info_s
{
    void *user_acc; /**< user access information to be passed to portmod layer. */
} imb_clu_create_info_t;

/*!
 * @struct imb_ile_create_info_s
 * @brief ILU specific information required for IMB init. 
 */
typedef struct imb_ile_create_info_s
{
    int stub; /**< temp stub until ILKN is implemented */
} imb_ile_create_info_t;

/*!
 * @struct imb_nbu_create_info_s
 * @brief NBU specific information required for IMB init. 
 */
typedef struct imb_nbu_create_info_s
{
    void *user_acc; /**< user access information to be passed to portmod layer. */
} imb_nbu_create_info_t;

/*!
 * @struct imb_mgu_create_info_s
 * @brief MGU specific information required for IMB init. 
 */
typedef struct imb_mgu_create_info_s
{
    void *user_acc; /**< user access information to be passed to portmod layer. */
} imb_mgu_create_info_t;

/*!
 * @struct imb_framer_create_info_s
 * @brief FEU specific information required for IMB init. 
 */
typedef struct imb_framer_create_info_s
{
    int stub; /**< temp stub for FEU */
} imb_framer_create_info_t;

/*!
 * @struct imb_feu_phy_create_info_s
 * @brief FEU_PHY specific information required for IMB init. 
 */
typedef struct imb_feu_phy_create_info_s
{
    int stub; /**< temp stub for FEU_PHY */
} imb_feu_phy_create_info_t;

/*!
 * @struct imb_fabric_create_info_s
 * @brief Fabric specific information required for IMB init. 
 */
typedef struct imb_fabric_create_info_s
{
    int stub; /**< temp stub until Fabric is implemented */
} imb_fabric_create_info_t;

/*!
 * @struct imb_otnu_phy_create_info_s
 * @brief OTNU_PHY specific information required for IMB init. 
 */
typedef struct imb_otnu_phy_create_info_s
{
    int stub; /**< temp stub for OTNU_PHY */
} imb_otnu_phy_create_info_t;

typedef union imb_specific_create_info_u
{
    imb_cdu_create_info_t cdu;
    imb_clu_create_info_t clu;
    imb_nbu_create_info_t nbu;
    imb_mgu_create_info_t mgu;
    imb_ile_create_info_t ile;
    imb_framer_create_info_t framer;
    imb_feu_phy_create_info_t feu_phy;
    imb_fabric_create_info_t fabric;
    imb_otnu_phy_create_info_t otnu_phy;
} imb_specific_create_info_t;

/*!
 * @struct imb_create_info_s
 * @brief This struct contains the required information in order to add new IMB. 
 */
typedef struct imb_create_info_s
{
    imb_dispatch_type_t type; /**< IMB type */
    int inst_id; /**< instatnce number. The physical phys will be deducted from the instance id. */
    imb_specific_create_info_t imb_specific_info;
} imb_create_info_t;

/* imb_create_info_t initialization and validation */
int imb_create_info_t_validate(
    int unit,
    const imb_create_info_t * imb_create_info);
int imb_create_info_t_init(
    int unit,
    imb_create_info_t * imb_create_info);

#define IMB_PRD_PRIORITY_ALL (BCM_PORT_F_PRIORITY_0 | BCM_PORT_F_PRIORITY_1 | BCM_PORT_F_PRIORITY_2 | BCM_PORT_F_PRIORITY_3 | BCM_PORT_F_PRIORITY_TDM) /**< Abbriviation to set all PRD priorities */

/*! 
 * imb_init_all
 *
 * @brief Initialize all IMBs on the specified unit. 
 *
 * @param [in]  unit            - unit id
 */
int imb_init_all(
    int unit);

/*! 
 * imb_deinit_all
 *
 * @brief De-initialize all IMBs on the specified unit. 
 *
 * @param [in]  unit            - unit id
 */
int imb_deinit_all(
    int unit);

/*! 
 * imb_init
 *
 * @brief initialize an IMB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_info        - IMB information required for the IMB to initialize.
 * @param [out]  imb_specific_info   - IMB information to be initialized by the specific IMB type.
 */
int imb_init(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info);

/*! 
 * imb_deinit
 *
 * @brief De-initialize an existing IMB. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_info        - IMB information required for the IMB to de-init
 * @param [out]  imb_specific_info   - IMB information to be deinitialized by the IMB type.
 */
int imb_deinit(
    int unit,
    const imb_create_info_t * imb_info,
    imb_specific_create_info_t * imb_specific_info);

/*! 
 * imb_port_pad_size_set
 *
 * @brief TX pad packets to the specified size. value less than 17 means pad is disabled.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - TX packet pad size
 */
int imb_port_pad_size_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_pad_size_get
 *
 * @brief TX pad packets to the specified size. value less than 17 means pad is disabled.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - TX packet pad size
 */
int imb_port_pad_size_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_link_recovery_enable_set
 *
 * @brief Enable/disable link_recovery.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - link recovery status
 */
int imb_port_link_recovery_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_link_recovery_enable_get
 *
 * @brief Enable/disable link_recovery.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - link recovery status
 */
int imb_port_link_recovery_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * @brief Port Add Flags 
 */
#define IMB_PORT_ADD_F_INIT_PASS1 0x1 /**< imb port add PASS1: init port until firmware load */
#define IMB_PORT_ADD_F_INIT_PASS2 0x2 /**< imb port add PASS2: resume init port after firmware load */
#define IMB_PORT_ADD_F_SKIP_SETTINGS 0x4 /**< Skip IMB port settings */

#define IMB_PORT_ADD_F_INIT_PASS1_SET(flags) (flags |= IMB_PORT_ADD_F_INIT_PASS1)
#define IMB_PORT_ADD_F_INIT_PASS2_SET(flags) (flags |= IMB_PORT_ADD_F_INIT_PASS2)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_SET(flags) (flags |= IMB_PORT_ADD_F_SKIP_SETTINGS)

#define IMB_PORT_ADD_F_INIT_PASS1_CLR(flags) (flags &= ~IMB_PORT_ADD_F_INIT_PASS1)
#define IMB_PORT_ADD_F_INIT_PASS2_CLR(flags) (flags &= ~IMB_PORT_ADD_F_INIT_PASS2)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_CLR(flags) (flags &= ~IMB_PORT_ADD_F_SKIP_SETTINGS)

#define IMB_PORT_ADD_F_INIT_PASS1_GET(flags) (flags & IMB_PORT_ADD_F_INIT_PASS1 ? 1 : 0)
#define IMB_PORT_ADD_F_INIT_PASS2_GET(flags) (flags & IMB_PORT_ADD_F_INIT_PASS2 ? 1 : 0)
#define IMB_PORT_ADD_F_SKIP_SETTINGS_GET(flags) (flags & IMB_PORT_ADD_F_SKIP_SETTINGS ? 1 : 0)

/*! 
 * imb_port_add
 *
 * @brief Add new IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which pass through port add. see IMB_PORT_ADD_F_INIT_...
 */
int imb_port_add(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_remove
 *
 * @brief Remove an existing IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_remove(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_attach
 *
 * @brief Add new IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which pass through port add. see IMB_PORT_ADD_F_INIT_...
 */
int imb_port_attach(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_detach
 *
 * @brief Remove an existing IMB (Interface Management Block) port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_detach(
    int unit,
    bcm_port_t port);

/*! 
 * @brief Port Enable Flags 
 */
#define IMB_PORT_ENABLE_F_SKIP_PORTMOD 0x1 /**< Skip portmod enable */
#define IMB_PORT_ENABLE_F_SKIP_FEC 0x2 /**< Skip fec unit enable */

#define IMB_PORT_ENABLE_F_SKIP_PORTMOD_SET(flags) (flags |= IMB_PORT_ENABLE_F_SKIP_PORTMOD)
#define IMB_PORT_ENABLE_F_SKIP_FEC_SET(flags) (flags |= IMB_PORT_ENABLE_F_SKIP_FEC)

#define IMB_PORT_ENABLE_F_SKIP_PORTMOD_CLR(flags) (flags &= ~IMB_PORT_ENABLE_F_SKIP_PORTMOD)
#define IMB_PORT_ENABLE_F_SKIP_FEC_CLR(flags) (flags &= ~IMB_PORT_ENABLE_F_SKIP_FEC)

#define IMB_PORT_ENABLE_F_SKIP_PORTMOD_GET(flags) (flags & IMB_PORT_ENABLE_F_SKIP_PORTMOD ? 1 : 0)
#define IMB_PORT_ENABLE_F_SKIP_FEC_GET(flags) (flags & IMB_PORT_ENABLE_F_SKIP_FEC ? 1 : 0)

/*! 
 * imb_port_enable_set
 *
 * @brief Enable / disable a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags
 * @param [in]  enable          - Port enable/disable indication
 */
int imb_port_enable_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int enable);
/*! 
 * imb_port_enable_get
 *
 * @brief Enable / disable a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Port enabled indication
 */
int imb_port_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_rx_data_enable_set
 *
 * @brief Enable / disable port RX 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port Rx enable/disable
 */
int imb_port_rx_data_enable_set(
    int unit,
    bcm_port_t port,
    int enable);

/*! 
 * imb_port_loopback_set
 *
 * @brief Enable / disable loopback on a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  loopback        - Port loopback indication
 */
int imb_port_loopback_set(
    int unit,
    bcm_port_t port,
    int loopback);
/*! 
 * imb_port_loopback_get
 *
 * @brief Enable / disable loopback on a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  loopback        - Port loopback enabled indication
 */
int imb_port_loopback_get(
    int unit,
    bcm_port_t port,
    int *loopback);

/*! 
 * imb_port_phy_loopback_adapter_set
 *
 * @brief Enable / disable phy loopback adapter on a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  curr_loopback   - Port phy current loopback indication
 * @param [in]  loopback        - Port phy loopback indication
 */
int imb_port_phy_loopback_adapter_set(
    int unit,
    bcm_port_t port,
    int curr_loopback,
    int loopback);

/*! 
 * imb_port_link_state_get
 *
 * @brief Get port link state 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  clear_status    - clear latch down indication
 * @param [out]  link_state      - Port link state
 */
int imb_port_link_state_get(
    int unit,
    bcm_port_t port,
    int clear_status,
    bcm_port_link_state_t * link_state);

/*! 
 * imb_port_eee_enable_set
 *
 * @brief Enable / disable EEE for a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port EEE enable/disable indication
 */
int imb_port_eee_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_eee_enable_get
 *
 * @brief Enable / disable EEE for a port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Port EEE enabled indication
 */
int imb_port_eee_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_link_up_mac_update
 *
 * @brief Set Mac link according to Phy status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  link            - link status info
 */
int imb_port_link_up_mac_update(
    int unit,
    bcm_port_t port,
    int link);

/*! 
 * imb_port_link_up_mac_update_post
 *
 * @brief Set Mac link according to Phy status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  link            - link status info
 */
int imb_port_link_up_mac_update_post(
    int unit,
    bcm_port_t port,
    int link);

/*! 
 * imb_port_priority_config_set
 *
 * @brief Set / get priority configuration for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority_config   - Priority config info
 */
int imb_port_priority_config_set(
    int unit,
    bcm_port_t port,
    const bcm_port_prio_config_t * priority_config);
/*! 
 * imb_port_priority_config_get
 *
 * @brief Set / get priority configuration for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  priority_config   - Priority config info
 */
int imb_port_priority_config_get(
    int unit,
    bcm_port_t port,
    bcm_port_prio_config_t * priority_config);

/*! 
 * imb_port_phy_measure_get
 *
 * @brief We can't measure the serdes freq directly, but we can measure the sync_eth counter, 
            and reconstruct the serdes freq from it by multiplying it with the blocks dividers. 
            In PML and PMH GSMII the dividers are:
            VCO                                                   Sync_eth counter
              _        --> PM synce_div --> NBIL/H synce div -->         _
            _| |_                                                      _| |_
            So 
            VCO = Fsynce * PMH_40_PML_20 * PM_1_7_11
            and we need to do:
            SerDes_rate = VCO/Oversample = Fsynce * PMH_40_PML_20 * PM_1_7_11 / Oversample

            In PMH which is not GSMII the dividers are:
            Serdes freq                                            Sync_eth counter
              _         --> PM synce_div --> NBIL/H synce div -->        _
            _| |_                                                      _| |_
            So we need to do:
            SerDes_rate = Fsynce * PMH_40_PML_20 * PM_1_7_11  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  is_rx           - use RX or TX FIFO to measure Serdes rate, only relevant for Fabric Serdes.
 * @param [out]  phy_measure     - PHY measure structure
 */
int imb_port_phy_measure_get(
    int unit,
    bcm_port_t port,
    int is_rx,
    soc_dnxc_port_phy_measure_t * phy_measure);

/*! 
 * imb_port_over_sampling_get
 *
 * @brief Get the over-sampling factor for the port 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  os_int          - Over-sampling integer
 * @param [out]  os_remainder    - Over-sampling remainder after the decimal point
 */
int imb_port_over_sampling_get(
    int unit,
    bcm_port_t port,
    uint32 *os_int,
    uint32 *os_remainder);

/*! 
 * imb_port_autoneg_set
 *
 * @brief Set/Get autoneg properties 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [in]  an              - Auto Negotioation properties
 */
int imb_port_autoneg_set(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    const phymod_autoneg_control_t * an);
/*! 
 * imb_port_autoneg_get
 *
 * @brief Set/Get autoneg properties 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phy_flags       - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  an              - Auto Negotioation properties
 */
int imb_port_autoneg_get(
    int unit,
    bcm_port_t port,
    uint32 phy_flags,
    phymod_autoneg_control_t * an);

/*! 
 * imb_port_link_get
 *
 * @brief Get link status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Which phy in the chain should be affected. see PORTMOD_INIT_F...
 * @param [out]  link            - Link status indication up/down
 */
int imb_port_link_get(
    int unit,
    bcm_port_t port,
    int flags,
    int *link);

/*! 
 * imb_port_max_packet_size_set
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Max packet size
 */
int imb_port_max_packet_size_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_max_packet_size_get
 *
 * @brief Filter packets bigger than the specified value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Max packet size
 */
int imb_port_max_packet_size_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_tx_average_ipg_set
 *
 * @brief Set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ipg_value       - Inter-packet gap to set
 */
int imb_port_tx_average_ipg_set(
    int unit,
    bcm_port_t port,
    int ipg_value);
/*! 
 * imb_port_tx_average_ipg_get
 *
 * @brief Set/get Average inter-packet gap 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  ipg_value       - Get inter-packet gap
 */
int imb_port_tx_average_ipg_get(
    int unit,
    bcm_port_t port,
    int *ipg_value);

/*! 
 * imb_port_duplex_set
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Enable / disable port duplex. true=full duplex, false=half duplex
 */
int imb_port_duplex_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_duplex_get
 *
 * @brief Port duplex set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Get port duplex. true=full duplex, false=half duplex
 */
int imb_port_duplex_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_cntmaxsize_set
 *
 * @brief Config MIB counter max size. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  val             - Set max packet size that is used in statistics counter updates.
 */
int imb_port_cntmaxsize_set(
    int unit,
    bcm_port_t port,
    int val);
/*! 
 * imb_port_cntmaxsize_get
 *
 * @brief Config MIB counter max size. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - Get max packet size that is used in statistics counter updates.
 */
int imb_port_cntmaxsize_get(
    int unit,
    bcm_port_t port,
    int *val);

/*! 
 * imb_port_local_fault_status_get
 *
 * @brief Local fault steatus get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  local_fault     - Get local fault status
 */
int imb_port_local_fault_status_get(
    int unit,
    bcm_port_t port,
    int *local_fault);

/*! 
 * imb_port_local_fault_status_clear
 *
 * @brief Clear Local fault steatus 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_local_fault_status_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_remote_fault_status_get
 *
 * @brief Remote fault status get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  remote_fault    - Get remote fault status
 */
int imb_port_remote_fault_status_get(
    int unit,
    bcm_port_t port,
    int *remote_fault);

/*! 
 * imb_port_remote_fault_status_clear
 *
 * @brief Clear Remote fault status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_remote_fault_status_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_local_fault_enable_set
 *
 * @brief local fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int imb_port_local_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_local_fault_enable_get
 *
 * @brief local fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int imb_port_local_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_remote_fault_enable_set
 *
 * @brief remote fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - 
 */
int imb_port_remote_fault_enable_set(
    int unit,
    bcm_port_t port,
    int enable);
/*! 
 * imb_port_remote_fault_enable_get
 *
 * @brief remote fault enable set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - 
 */
int imb_port_remote_fault_enable_get(
    int unit,
    bcm_port_t port,
    int *enable);

/*! 
 * imb_port_faults_status_get
 *
 * @brief Get port local and emote faults status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  local_fault     - Get local fault status
 * @param [out]  remote_fault    - Get remote fault status
 */
int imb_port_faults_status_get(
    int unit,
    bcm_port_t port,
    int *local_fault,
    int *remote_fault);

/*! 
 * imb_port_eee_set
 *
 * @brief Set/get EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  eee             - EEE (Energy Eficient Ethernet) Timer Information.
 */
int imb_port_eee_set(
    int unit,
    bcm_port_t port,
    const portmod_eee_t * eee);
/*! 
 * imb_port_eee_get
 *
 * @brief Set/get EEE Config. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  eee             - EEE (Energy Eficient Ethernet) Timer Information.
 */
int imb_port_eee_get(
    int unit,
    bcm_port_t port,
    portmod_eee_t * eee);

/*! 
 * imb_bandwidth_get
 *
 * @brief Get the Bandwidth for the CDU. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  is_port_include   - indication wether to include the specified port in the BW calculation
 * @param [out]  bandwidth       - bandwidth for all ports in CDU.
 */
int imb_bandwidth_get(
    int unit,
    bcm_port_t port,
    int is_port_include,
    int *bandwidth);

/*! 
 * imb_port_tx_start_thr_set
 *
 * @brief Get/set the Start TX threshold. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - Port interface rate
 * @param [in]  start_tx_thr    - Start tx threshold
 */
int imb_port_tx_start_thr_set(
    int unit,
    bcm_port_t port,
    int speed,
    int start_tx_thr);
/*! 
 * imb_port_tx_start_thr_get
 *
 * @brief Get/set the Start TX threshold. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  start_tx_thr    - Start tx threshold
 */
int imb_port_tx_start_thr_get(
    int unit,
    bcm_port_t port,
    int *start_tx_thr);

/*! 
 * imb_prd_port_profile_map_is_supported
 *
 * @brief Is port profile map supported for this port dispatch type. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  is_supported    - is supported
 */
int imb_prd_port_profile_map_is_supported(
    int unit,
    bcm_port_t port,
    int *is_supported);

/*! 
 * imb_prd_nof_port_profiles_get
 *
 * @brief Get the number of prfiles for this port dispatch type.. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  nof_port_profiles   - number of port profiles
 */
int imb_prd_nof_port_profiles_get(
    int unit,
    bcm_port_t port,
    int *nof_port_profiles);

/*! 
 * imb_prd_enable_set
 *
 * @brief Set/get the PRD Enable mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable_mode     - PRD enable mode (0=>disable, 1=>only hard stage, 2=>hard and soft stgae)
 */
int imb_prd_enable_set(
    int unit,
    bcm_port_t port,
    int enable_mode);
/*! 
 * imb_prd_enable_get
 *
 * @brief Set/get the PRD Enable mode. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable_mode     - PRD enable mode (0=>disable, 1=>only hard stage, 2=>hard and soft stgae)
 */
int imb_prd_enable_get(
    int unit,
    bcm_port_t port,
    int *enable_mode);

/*!
 * @enum imb_prd_properties_e
 * @brief PRD properties 
 */
typedef enum imb_prd_properties_e
{
    imbImbPrdIgnoreIpDscp = 0,
    imbImbPrdIgnoreMplsExp = 1,
    imbImbPrdIgnoreInnerTag = 2,
    imbImbPrdIgnoreOuterTag = 3,
    imbImbPrdDefaultPriority = 4,
    imbImbPrdCount
} imb_prd_properties_t;

extern const enum_mapping_t imb_prd_properties_t_mapping[];
/* imb_prd_properties_t validation */
int imb_prd_properties_t_validate(
    int unit,
    imb_prd_properties_t imb_prd_properties);
/*! 
 * imb_prd_properties_set
 *
 * @brief Set/get PRD Properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  property        - PRD property to configure
 * @param [in]  val             - PRD Proeprty value
 */
int imb_prd_properties_set(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 val);
/*! 
 * imb_prd_properties_get
 *
 * @brief Set/get PRD Properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  property        - PRD property to configure
 * @param [out]  val             - PRD Proeprty value
 */
int imb_prd_properties_get(
    int unit,
    bcm_port_t port,
    imb_prd_properties_t property,
    uint32 *val);

/*! 
 * imb_prd_port_profile_map_set
 *
 * @brief Set/get PRD Port Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  profile         - PRD Port Profile value
 */
int imb_prd_port_profile_map_set(
    int unit,
    bcm_port_t port,
    uint32 profile);
/*! 
 * imb_prd_port_profile_map_get
 *
 * @brief Set/get PRD Port Profile. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  profile         - PRD Port Profile value
 */
int imb_prd_port_profile_map_get(
    int unit,
    bcm_port_t port,
    uint32 *profile);

/*! 
 * imb_prd_map_set
 *
 * @brief Configure PRD priority maps. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  map             - PRD Map to configure
 * @param [in]  key             - Map key. composed differently according to the map type.              should be set by the user using the following MACROs:                 BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY(pcp, dei)                   BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY(tc, dp)                   BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY(dscp)                   BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY(exp)
 * @param [in]  priority        - PRD priority value
 * @param [in]  is_tdm          - PRD is_tdm indication
 */
int imb_prd_map_set(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 priority,
    uint32 is_tdm);
/*! 
 * imb_prd_map_get
 *
 * @brief Configure PRD priority maps. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  map             - PRD Map to configure
 * @param [in]  key             - Map key. composed differently according to the map type.              should be set by the user using the following MACROs:                 BCM_COSQ_INGRESS_PORT_DROP_ETH_MAP_KEY(pcp, dei)                   BCM_COSQ_INGRESS_PORT_DROP_TM_MAP_KEY(tc, dp)                   BCM_COSQ_INGRESS_PORT_DROP_IP_MAP_KEY(dscp)                   BCM_COSQ_INGRESS_PORT_DROP_MPLS_MAP_KEY(exp)
 * @param [out]  priority        - PRD priority value
 * @param [out]  is_tdm          - PRD is_tdm indication
 */
int imb_prd_map_get(
    int unit,
    bcm_port_t port,
    bcm_cosq_ingress_port_drop_map_t map,
    uint32 key,
    uint32 *priority,
    uint32 *is_tdm);

/*! 
 * imb_prd_threshold_set
 *
 * @brief Configure PRD thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - PRD priority
 * @param [in]  threshold       - PRD threshols value (in entries) for the priority. threshold will be set for the RMC for which the priority is mapped.
 */
int imb_prd_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 threshold);
/*! 
 * imb_prd_threshold_get
 *
 * @brief Configure PRD thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - PRD priority
 * @param [out]  threshold       - PRD priority value (in entries) for the priority. threshold will be taken from the RMC for which the priority is mapped.
 */
int imb_prd_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *threshold);

/*! 
 * imb_prd_threshold_max_get
 *
 * @brief Get maximum PRD threshold value. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  threshold       - PRD threshold max value.
 */
int imb_prd_threshold_max_get(
    int unit,
    bcm_port_t port,
    uint32 *threshold);

/*! 
 * imb_prd_tpid_set
 *
 * @brief Configure PRD TPIDs per port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tpid_index      - TPID index to set (0-3)
 * @param [in]  tpid_value      - TPID to be recognized by the port
 */
int imb_prd_tpid_set(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 tpid_value);
/*! 
 * imb_prd_tpid_get
 *
 * @brief Configure PRD TPIDs per port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tpid_index      - TPID index to set (0-3)
 * @param [out]  tpid_value      - TPID recognized by the port
 */
int imb_prd_tpid_get(
    int unit,
    bcm_port_t port,
    uint32 tpid_index,
    uint32 *tpid_value);

/*! 
 * imb_prd_drop_count_get
 *
 * @brief Get PRD counter for the corresponding FIFO (RMC). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  sch_priority    - which scheduler is the PRD fifo mapped to
 * @param [out]  count           - PRD counter value
 */
int imb_prd_drop_count_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint64 *count);

/*! 
 * imb_prd_custom_ether_type_set
 *
 * @brief Set/Get PRD Configurable Ether types. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Custom Ether type code to assign to the Ether type(1-6)
 * @param [in]  ether_type_val   - Ether type value
 */
int imb_prd_custom_ether_type_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 ether_type_val);
/*! 
 * imb_prd_custom_ether_type_get
 *
 * @brief Set/Get PRD Configurable Ether types. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Custom Ether type code to assign to the Ether type(1-6)
 * @param [out]  ether_type_val   - Ether type value
 */
int imb_prd_custom_ether_type_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *ether_type_val);

/*! 
 * imb_prd_flex_key_entry_set
 *
 * @brief Set/Get PRD TCAM entries (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  key_index       - TCAM index to configure
 * @param [in]  entry_info      - TCAM entry information
 */
int imb_prd_flex_key_entry_set(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    const dnx_cosq_prd_tcam_entry_info_t * entry_info);
/*! 
 * imb_prd_flex_key_entry_get
 *
 * @brief Set/Get PRD TCAM entries (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  key_index       - TCAM index to configure
 * @param [out]  entry_info      - TCAM entry information
 */
int imb_prd_flex_key_entry_get(
    int unit,
    bcm_port_t port,
    uint32 key_index,
    dnx_cosq_prd_tcam_entry_info_t * entry_info);

/*! 
 * imb_prd_ether_type_size_set
 *
 * @brief Set/Get PRD TCAM key size per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  ether_type_size   - Ether type size
 */
int imb_prd_ether_type_size_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 ether_type_size);
/*! 
 * imb_prd_ether_type_size_get
 *
 * @brief Set/Get PRD TCAM key size per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [out]  ether_type_size   - Ether type size
 */
int imb_prd_ether_type_size_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *ether_type_size);

/*! 
 * imb_prd_tcam_entry_key_offset_base_set
 *
 * @brief Set/Get PRD TCAM key offset base per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  offset_base     - Ether type offset base
 */
int imb_prd_tcam_entry_key_offset_base_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_base);
/*! 
 * imb_prd_tcam_entry_key_offset_base_get
 *
 * @brief Set/Get PRD TCAM key offset base per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [out]  offset_base     - Ether type offset base
 */
int imb_prd_tcam_entry_key_offset_base_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 *offset_base);

/*! 
 * imb_prd_tcam_entry_key_offset_set
 *
 * @brief Set/Get PRD TCAM key offset value per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  offset_index    - Ether type offset index
 * @param [in]  offset_value    - Ether type offset value
 */
int imb_prd_tcam_entry_key_offset_set(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_index,
    uint32 offset_value);
/*! 
 * imb_prd_tcam_entry_key_offset_get
 *
 * @brief Set/Get PRD TCAM key offset value per Ether type (for the soft stage). 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ether_type_code   - Ether type code of the key
 * @param [in]  offset_index    - Ether type offset index
 * @param [out]  offset_value    - Ether type offset value
 */
int imb_prd_tcam_entry_key_offset_get(
    int unit,
    bcm_port_t port,
    uint32 ether_type_code,
    uint32 offset_index,
    uint32 *offset_value);

/*! 
 * imb_prd_control_frame_set
 *
 * @brief Set/Get PRD Control Frame proeprties. if a packet is identified as control frame, it will automatically get the highest priority. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control_frame_index   - Index of the control frame.
 * @param [in]  control_frame_config   - Control Frame properties
 */
int imb_prd_control_frame_set(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    const bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config);
/*! 
 * imb_prd_control_frame_get
 *
 * @brief Set/Get PRD Control Frame proeprties. if a packet is identified as control frame, it will automatically get the highest priority. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  control_frame_index   - Index of the control frame.
 * @param [out]  control_frame_config   - Control Frame properties
 */
int imb_prd_control_frame_get(
    int unit,
    bcm_port_t port,
    uint32 control_frame_index,
    bcm_cosq_ingress_drop_control_frame_config_t * control_frame_config);

/*! 
 * imb_prd_mpls_special_label_set
 *
 * @brief Set/Get PRD MPLS special label proeprties. if a packet is identified as MPLS special label and the label value matches to one of the saved special labels, the priority and TDM indication will be taken from the label properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  label_index     - Index of the control frame.
 * @param [in]  label_config    - MPLS special label properties
 */
int imb_prd_mpls_special_label_set(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    const bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config);
/*! 
 * imb_prd_mpls_special_label_get
 *
 * @brief Set/Get PRD MPLS special label proeprties. if a packet is identified as MPLS special label and the label value matches to one of the saved special labels, the priority and TDM indication will be taken from the label properties. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  label_index     - Index of the control frame.
 * @param [out]  label_config    - MPLS special label properties
 */
int imb_prd_mpls_special_label_get(
    int unit,
    bcm_port_t port,
    uint32 label_index,
    bcm_cosq_ingress_port_drop_mpls_special_label_config_t * label_config);

/*! 
 * imb_prd_port_last_packet_priority_get
 *
 * @brief Get maximum PRD threshold value. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  priority        - PRD last received packet priority.
 * @param [out]  tdm             - PRD last received packet TDM indication.
 * @param [out]  valid           - true if tdm and priority are valid
 */
int imb_prd_port_last_packet_priority_get(
    int unit,
    bcm_port_t port,
    uint32 *priority,
    uint32 *tdm,
    uint32 *valid);

/*! 
 * imb_port_logical_lane_order_set
 *
 * @brief Set/Get the logical lane order for ILKN ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  ilkn_lane       - array in size of num_of_lanes containing interface lanes
 * @param [in]  lane_order      - ILKN Logical lane order. For pmOsILKN_50G, lane_order[N] is represent for the Nth lane; otherwise it is represent for logical lane N
 * @param [in]  lane_order_size   - Nof lanes of the ILKN port
 */
int imb_port_logical_lane_order_set(
    int unit,
    bcm_port_t port,
    const int *ilkn_lane,
    const int *lane_order,
    int lane_order_size);
/*! 
 * imb_port_logical_lane_order_get
 *
 * @brief Set/Get the logical lane order for ILKN ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_order_max_size   - Max lane numbers when get ILKN lane order
 * @param [out]  lane_order      - Logical lane order, lane_order[N] is represent for the Nth lane
 * @param [out]  lane_order_actual_size   - The actual lane numbers when get ILKN lane order
 */
int imb_port_logical_lane_order_get(
    int unit,
    bcm_port_t port,
    int lane_order_max_size,
    int *lane_order,
    int *lane_order_actual_size);

/*! 
 * imb_port_prbs_polynomial_set
 *
 * @brief Set/Get prbs polnomial value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  value           - prbs polynomial value
 */
int imb_port_prbs_polynomial_set(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t value);
/*! 
 * imb_port_prbs_polynomial_get
 *
 * @brief Set/Get prbs polnomial value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  value           - prbs polynomial value
 */
int imb_port_prbs_polynomial_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    bcm_port_prbs_t * value);

/*! 
 * imb_port_prbs_invert_data_set
 *
 * @brief Set/Get prbs rx or tx data inversion status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  invert          - Enable or disable data inversion
 */
int imb_port_prbs_invert_data_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int invert);
/*! 
 * imb_port_prbs_invert_data_get
 *
 * @brief Set/Get prbs rx or tx data inversion status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  invert          - Enable or disablei data inversion
 */
int imb_port_prbs_invert_data_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *invert);

/*! 
 * imb_port_prbs_enable_set
 *
 * @brief Set prbs rx or tx enable status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [in]  enable          - Enable or disable prbs
 */
int imb_port_prbs_enable_set(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int enable);

/*! 
 * imb_port_prbs_enable_get
 *
 * @brief Get prbs rx or tx enable status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - indicate rx or tx prbs
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  enable          - Enable or disable prbs
 */
int imb_port_prbs_enable_get(
    int unit,
    bcm_port_t port,
    int type,
    portmod_prbs_mode_t prbs_mode,
    int *enable);

/*! 
 * imb_port_prbs_rx_status_get
 *
 * @brief Set/Get prbs status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  prbs_mode       - prbs mode
 * @param [out]  status          - Prbs status
 */
int imb_port_prbs_rx_status_get(
    int unit,
    bcm_port_t port,
    portmod_prbs_mode_t prbs_mode,
    int *status);

/*! 
 * imb_port_rx_rmc_priority_config_set
 *
 * @brief Map an array of RMC PRD priority to SCH priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  rmc_arr         - Array of RMC info to map from prd priority to sch priority
 * @param [in]  nof_rmcs        - Number of RMC in the mapping array
 */
int imb_port_rx_rmc_priority_config_set(
    int unit,
    bcm_port_t port,
    const dnx_algo_port_rmc_info_t * rmc_arr,
    int nof_rmcs);

/*! 
 * imb_port_rx_fifo_status_get
 *
 * @brief Get rx fifo status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  sch_priority    - which scheduler is the PRD fifo mapped to
 * @param [out]  max_occupancy   - Indicates the corresponding lane MLF MAX fullness level of the FIFO
 * @param [out]  fifo_level      - Indicates the corresponding lane MLF fullness level of the FIFO
 * @param [out]  mapped          - Indicates if port is mapped to a counter or not
 */
int imb_port_rx_fifo_status_get(
    int unit,
    bcm_port_t port,
    bcm_port_nif_scheduler_t sch_priority,
    uint32 *max_occupancy,
    uint32 *fifo_level,
    uint32 *mapped);

/*! 
 * imb_port_tx_fifo_status_get
 *
 * @brief Get tx fifo status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  max_occupancy   - Indicates the corresponding lane MLF MAX fullness level of the FIFO
 * @param [out]  fifo_level      - Indicates the corresponding lane MLF fullness level of the FIFO
 * @param [out]  pm_credits      - the number of credits received from the port-macro Tx buffer
 * @param [out]  mapped          - Indicates if port is mapped to a counter or not
 */
int imb_port_tx_fifo_status_get(
    int unit,
    bcm_port_t port,
    uint32 *max_occupancy,
    uint32 *fifo_level,
    uint32 *pm_credits,
    uint32 *mapped);

/*! 
 * imb_port_low_latency_llfc_enable_set
 *
 * @brief Enable/Disable Low Latency LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_low_latency_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_low_latency_llfc_enable_get
 *
 * @brief Enable/Disable Low Latency LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_low_latency_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_fec_error_detect_enable_set
 *
 * @brief Enable/Disable FEC error detect 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable Low Latency LLFC
 */
int imb_port_fec_error_detect_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_fec_error_detect_enable_get
 *
 * @brief Enable/Disable FEC error detect 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable FEC error detect
 */
int imb_port_fec_error_detect_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_llfc_after_fec_enable_set
 *
 * @brief Enable/Disable LLFC after FEC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable LLFC after FEC
 */
int imb_port_llfc_after_fec_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_llfc_after_fec_enable_get
 *
 * @brief Enable/Disable LLFC after FEC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable LLFC after FEC
 */
int imb_port_llfc_after_fec_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_extract_congestion_indication_from_llfc_enable_set
 *
 * @brief Enable/Disable extract congestion indication from LLFC cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable extract congestion indication from LLFC cells
 */
int imb_port_extract_congestion_indication_from_llfc_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_extract_congestion_indication_from_llfc_enable_get
 *
 * @brief Enable/Disable extract congestion indication from LLFC cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable extract congestion indication from LLFC cells
 */
int imb_port_extract_congestion_indication_from_llfc_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_control_cells_fec_bypass_enable_set
 *
 * @brief Enable/Disable FEC bypass on control cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  value           - Enable/Disable FEC bypass on control cells
 */
int imb_port_control_cells_fec_bypass_enable_set(
    int unit,
    bcm_port_t port,
    int value);
/*! 
 * imb_port_control_cells_fec_bypass_enable_get
 *
 * @brief Enable/Disable FEC bypass on control cells 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - Enable/Disable FEC bypass on control cells
 */
int imb_port_control_cells_fec_bypass_enable_get(
    int unit,
    bcm_port_t port,
    int *value);

/*! 
 * imb_port_speed_config_set
 *
 * @brief Port speed configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed_config    - Port speed configuration
 */
int imb_port_speed_config_set(
    int unit,
    bcm_port_t port,
    const portmod_speed_config_t * speed_config);

/*! 
 * imb_port_mib_counter_get
 *
 * @brief Get mib counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  counter_type    - counter type
 * @param [out]  counter_val     - counter value
 */
int imb_port_mib_counter_get(
    int unit,
    bcm_port_t port,
    int counter_type,
    uint64 *counter_val);

/*! 
 * imb_port_mib_counter_set
 *
 * @brief Set mib counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  counter_type    - counter type
 * @param [in]  counter_val     - counter value
 */
int imb_port_mib_counter_set(
    int unit,
    bcm_port_t port,
    int counter_type,
    const uint64 *counter_val);

/*! 
 * imb_port_mib_counter_clear
 *
 * @brief Clear mib counter 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_mib_counter_clear(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_autoneg_ability_advert_set
 *
 * @brief Set/Get port advertise abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  num_ability     - number of ability the port will advertise
 * @param [in]  abilities       - local advertisement for each ability
 */
int imb_port_autoneg_ability_advert_set(
    int unit,
    bcm_port_t port,
    int num_ability,
    const bcm_port_speed_ability_t * abilities);
/*! 
 * imb_port_autoneg_ability_advert_get
 *
 * @brief Set/Get port advertise abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_autoneg_ability_advert_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_speed_ability_local_get
 *
 * @brief Get the local speed abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_speed_ability_local_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_autoneg_ability_remote_get
 *
 * @brief Get the remote abilities 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  max_num_ability   - the max num of autoneg ability this port can advertise
 * @param [out]  abilities       - indicate the ability this port can advertise
 * @param [out]  actual_num_ability   - the actual num of ability that this port can advertise
 */
int imb_port_autoneg_ability_remote_get(
    int unit,
    bcm_port_t port,
    int max_num_ability,
    bcm_port_speed_ability_t * abilities,
    int *actual_num_ability);

/*! 
 * imb_port_scheduler_config_set
 *
 * @brief Set port scheduler 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - enable port scheduler
 */
int imb_port_scheduler_config_set(
    int unit,
    bcm_port_t port,
    int enable);

/*! 
 * imb_port_scheduler_priority_update
 *
 * @brief Update scheduler reset for High/Low priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_scheduler_priority_update(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_resource_default_get
 *
 * @brief Get port's default resource configurations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags
 * @param [out]  resource        - Port default resource configurations
 */
int imb_port_resource_default_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    bcm_port_resource_t * resource);

/*! 
 * imb_port_to_stif_instance_map_set
 *
 * @brief Map STIF instance ID with given port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  instace_id      - STIF instance id to map
 * @param [in]  instace_core    - STIF instance core to map
 * @param [in]  connect         - if TRUE connect the SIF instance to the port, if FALSE, disconnect the SIF instance
 */
int imb_port_to_stif_instance_map_set(
    int unit,
    bcm_port_t port,
    int instace_id,
    int instace_core,
    int connect);

/*! 
 * imb_port_gen_pfc_from_rmc_enable_set
 *
 * @brief Enable / disable a port's RMCs to produce PFC for the specified priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - Priority for the PFC that will be produced from the RMCs
 * @param [in]  enable          - Port RMCs to produce PFC enable/disable indication
 */
int imb_port_gen_pfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 enable);
/*! 
 * imb_port_gen_pfc_from_rmc_enable_get
 *
 * @brief Enable / disable a port's RMCs to produce PFC for the specified priority 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  priority        - Priority for the PFC that will be produced from the RMCs
 * @param [out]  enable          - Port RMCs to produce PFC enabled indication
 */
int imb_port_gen_pfc_from_rmc_enable_get(
    int unit,
    bcm_port_t port,
    uint32 priority,
    uint32 *enable);

/*! 
 * imb_port_gen_llfc_from_rmc_enable_set
 *
 * @brief Enable / disable port's RMCs(all lanes) to generate LLFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Port's RMCs(all lanes) to generate LLFC enable/disable indication
 */
int imb_port_gen_llfc_from_rmc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);

/*! 
 * imb_port_stop_pm_from_cfc_llfc_enable_set
 *
 * @brief Enable / disable PM to stop TX on all of a port's lanes according to a LLFC signal from CFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_port_stop_pm_from_cfc_llfc_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);

/*! 
 * imb_port_stop_pm_from_pfc_enable_set
 *
 * @brief Enable / disable PM to stop TX on a NIF port according to received PFC signal 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pfc             - PFC that is enabled/disabled to stop the PM
 * @param [in]  enable          - PM to stop TX on a NIF port enable/disable indication
 */
int imb_port_stop_pm_from_pfc_enable_set(
    int unit,
    bcm_port_t port,
    int pfc,
    uint32 enable);
/*! 
 * imb_port_stop_pm_from_pfc_enable_get
 *
 * @brief Enable / disable PM to stop TX on a NIF port according to received PFC signal 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pfc             - PFC that is enabled/disabled to stop the PM
 * @param [out]  enable          - PM to stop TX on a NIF port enable/disable indication
 */
int imb_port_stop_pm_from_pfc_enable_get(
    int unit,
    bcm_port_t port,
    int pfc,
    uint32 *enable);

/*! 
 * imb_port_pfc_force_enable_set
 *
 * @brief Set enable force received PFC signal. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  pfc             - PFC for which to enable forcing of PFC signal.
 * @param [in]  enable          - TRUE or FALSE
 */
int imb_port_pfc_force_enable_set(
    int unit,
    bcm_port_t port,
    int pfc,
    uint32 enable);

/*! 
 * imb_port_gen_pfc_from_llfc_thresh_enable_set
 *
 * @brief Enable / disable LLFC RMC threshold to generate PFC on the specified port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  enable          - Enable/disable LLFC RMC threshold to generate PFC on the specified port.
 */
int imb_port_gen_pfc_from_llfc_thresh_enable_set(
    int unit,
    bcm_port_t port,
    uint32 enable);
/*! 
 * imb_port_gen_pfc_from_llfc_thresh_enable_get
 *
 * @brief Enable / disable LLFC RMC threshold to generate PFC on the specified port. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  enable          - Get enable indication for LLFC RMC threshold to generate PFC on the specified port.
 */
int imb_port_gen_pfc_from_llfc_thresh_enable_get(
    int unit,
    bcm_port_t port,
    uint32 *enable);

/*! 
 * imb_port_fc_rx_qmlf_threshold_set
 *
 * @brief Set / get a port's Rx Quad MAC Lane FIFO (QMLF) Flow Control generation thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags to determine the threshold type (set/clear for PFC of set/clear for LLFC)
 * @param [in]  threshold       - Rx Quad MAC Lane FIFO (QMLF) Flow Control generation threshold value
 */
int imb_port_fc_rx_qmlf_threshold_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 threshold);
/*! 
 * imb_port_fc_rx_qmlf_threshold_get
 *
 * @brief Set / get a port's Rx Quad MAC Lane FIFO (QMLF) Flow Control generation thresholds. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Flags to determine the threshold type (set/clear for PFC of set/clear for LLFC)
 * @param [out]  threshold       - Rx Quad MAC Lane FIFO (QMLF) Flow Control generation threshold value
 */
int imb_port_fc_rx_qmlf_threshold_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    uint32 *threshold);

/*! 
 * imb_fc_reset_all
 *
 * @brief Set the Flow Control Interface in/out of reset for all CDUs. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_fc_reset_all(
    int unit,
    uint32 in_reset);

/*! 
 * imb_fc_reset_set
 *
 * @brief Set the Flow Control Interface in/out of reset for a specified CDU. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 * @param [in]  in_reset        - 1 - reset, 0 - out of reset
 */
int imb_fc_reset_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 in_reset);

/*! 
 * imb_llfc_from_glb_rsc_enable_all
 *
 * @brief Enable / disable the generation of a LLFC based on a signal from Global Resources thresholds for all CDUs 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_llfc_from_glb_rsc_enable_all(
    int unit,
    uint32 enable);

/*! 
 * imb_llfc_from_glb_rsc_enable_set
 *
 * @brief Enable / disable the generation of a LLFC based on a signal from Global Resources thresholds for a specified CDU 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 * @param [in]  enable          - PM to stop TX on all of a port's lanes enable/disable indication
 */
int imb_llfc_from_glb_rsc_enable_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 enable);

/*! 
 * imb_pfc_rec_priority_map
 *
 * @brief Per CDU map the received PFC - each priority received by NIF should be mapped to a priority that will be sent to EGQ in order to stop a Q-pair 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [in]  nif_priority    - Priority of the PFC received by NIF
 * @param [in]  egq_priority    - Priority of the PFC sent to EGQ
 */
int imb_pfc_rec_priority_map(
    int unit,
    int imb_id,
    uint32 nif_priority,
    uint32 egq_priority);

/*! 
 * imb_pfc_rec_priority_unmap
 *
 * @brief Per CDU unmap all priorities of the received PFC 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 */
int imb_pfc_rec_priority_unmap(
    int unit,
    int imb_id);

/*! 
 * imb_pfc_mask_on_link_fail_enable_all
 *
 * @brief Disable/Enable PFC ignore on link failure for all IMB units 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  enable          - Enable indication
 */
int imb_pfc_mask_on_link_fail_enable_all(
    int unit,
    uint32 enable);

/*! 
 * imb_pfc_mask_on_link_fail_enable_set
 *
 * @brief Disable/Enable PFC ignore on link failure for IMB unit 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 * @param [in]  enable          - Enable indication
 */
int imb_pfc_mask_on_link_fail_enable_set(
    int unit,
    const imb_create_info_t * imb_info,
    uint32 enable);

/*! 
 * imb_port_fec_speed_validate
 *
 * @brief Validate the FEC+SPEED combinations 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  fec_type        - fec type
 * @param [in]  speed           - speed
 */
int imb_port_fec_speed_validate(
    int unit,
    bcm_port_t port,
    bcm_port_phy_fec_t fec_type,
    int speed);

/*! 
 * imb_inband_ilkn_fc_init
 *
 * @brief Configure the specified ILKN core's Inband Flow Control parameters. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type and CDU
 */
int imb_inband_ilkn_fc_init(
    int unit,
    const imb_create_info_t * imb_info);

/*! 
 * imb_inband_ilkn_fc_init_all
 *
 * @brief Configure all ILKN interfaces' Inband Flow Control parameters. 
 *
 * @param [in]  unit            - Unit ID
 */
int imb_inband_ilkn_fc_init_all(
    int unit);

/*! 
 * @brief IMB FlexE related defines 
 */
#define IMB_FLEXE_DIRECTION_RX 0x1 /**< Rx direction */
#define IMB_FLEXE_DIRECTION_TX 0x2 /**< Tx direction */
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT 0x4 /**< USE SINGLE TMD slots for in NB calendar for specific port */
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT 0x8 /**< USE DOUBLE TMD slots for in NB calendar for specific port */
#define IMB_FLEXE_RESOURCE_PREPARE 0x10 /**< Prepare standby configuraion for calendar and Link list */
#define IMB_FLEXE_RESOURCE_SWITCH 0x20 /**< Switch to standby configuraion for calendar and Link list */
#define IMB_FLEXE_AM_TRANSPARENT 0x40 /**< Indicate AM transparent for L1 ETH ports */

#define IMB_FLEXE_DIRECTION_RX_SET(flags) (flags |= IMB_FLEXE_DIRECTION_RX)
#define IMB_FLEXE_DIRECTION_TX_SET(flags) (flags |= IMB_FLEXE_DIRECTION_TX)
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT_SET(flags) (flags |= IMB_FLEXE_SINGLE_NB_TDM_SLOT)
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT_SET(flags) (flags |= IMB_FLEXE_DOUBLE_NB_TDM_SLOT)
#define IMB_FLEXE_RESOURCE_PREPARE_SET(flags) (flags |= IMB_FLEXE_RESOURCE_PREPARE)
#define IMB_FLEXE_RESOURCE_SWITCH_SET(flags) (flags |= IMB_FLEXE_RESOURCE_SWITCH)
#define IMB_FLEXE_AM_TRANSPARENT_SET(flags) (flags |= IMB_FLEXE_AM_TRANSPARENT)

#define IMB_FLEXE_DIRECTION_RX_CLR(flags) (flags &= ~IMB_FLEXE_DIRECTION_RX)
#define IMB_FLEXE_DIRECTION_TX_CLR(flags) (flags &= ~IMB_FLEXE_DIRECTION_TX)
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT_CLR(flags) (flags &= ~IMB_FLEXE_SINGLE_NB_TDM_SLOT)
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT_CLR(flags) (flags &= ~IMB_FLEXE_DOUBLE_NB_TDM_SLOT)
#define IMB_FLEXE_RESOURCE_PREPARE_CLR(flags) (flags &= ~IMB_FLEXE_RESOURCE_PREPARE)
#define IMB_FLEXE_RESOURCE_SWITCH_CLR(flags) (flags &= ~IMB_FLEXE_RESOURCE_SWITCH)
#define IMB_FLEXE_AM_TRANSPARENT_CLR(flags) (flags &= ~IMB_FLEXE_AM_TRANSPARENT)

#define IMB_FLEXE_DIRECTION_RX_GET(flags) (flags & IMB_FLEXE_DIRECTION_RX ? 1 : 0)
#define IMB_FLEXE_DIRECTION_TX_GET(flags) (flags & IMB_FLEXE_DIRECTION_TX ? 1 : 0)
#define IMB_FLEXE_SINGLE_NB_TDM_SLOT_GET(flags) (flags & IMB_FLEXE_SINGLE_NB_TDM_SLOT ? 1 : 0)
#define IMB_FLEXE_DOUBLE_NB_TDM_SLOT_GET(flags) (flags & IMB_FLEXE_DOUBLE_NB_TDM_SLOT ? 1 : 0)
#define IMB_FLEXE_RESOURCE_PREPARE_GET(flags) (flags & IMB_FLEXE_RESOURCE_PREPARE ? 1 : 0)
#define IMB_FLEXE_RESOURCE_SWITCH_GET(flags) (flags & IMB_FLEXE_RESOURCE_SWITCH ? 1 : 0)
#define IMB_FLEXE_AM_TRANSPARENT_GET(flags) (flags & IMB_FLEXE_AM_TRANSPARENT ? 1 : 0)

/*! 
 * imb_calendar_set
 *
 * @brief Configure calendar for FlexE related ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags for resource set API
 */
int imb_calendar_set(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_port_fifo_resource_set
 *
 * @brief Configure FIFO resources for flexe client 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags for resource set API
 */
int imb_port_fifo_resource_set(
    int unit,
    bcm_port_t port,
    uint32 flags);

/*! 
 * imb_post_init
 *
 * @brief IMB post init after speed configuration is ready 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 */
int imb_post_init(
    int unit,
    int imb_id);

/*! 
 * imb_instru_synced_counters_config_set_all
 *
 * @brief Set the per IMB configuration for instrumentation counters for all IMBs 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  nof_intervals   - Number of records to count.
 * @param [in]  is_continuous   - Whether to override the records once nof_interval is done.
 */
int imb_instru_synced_counters_config_set_all(
    int unit,
    uint8 nof_intervals,
    uint8 is_continuous);

/*! 
 * imb_instru_synced_counters_config_set
 *
 * @brief Set the per IMB configuration for instrumentation counters 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [in]  nof_intervals   - Number of records to count.
 * @param [in]  is_continuous   - Whether to override the records once nof_interval is done.
 */
int imb_instru_synced_counters_config_set(
    int unit,
    int imb_id,
    uint8 nof_intervals,
    uint8 is_continuous);
/*! 
 * imb_instru_synced_counters_config_get
 *
 * @brief Set the per IMB configuration for instrumentation counters 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [out]  nof_intervals   - Number of records to count.
 * @param [out]  is_continuous   - Whether to override the records once nof_interval is done.
 */
int imb_instru_synced_counters_config_get(
    int unit,
    int imb_id,
    uint8 *nof_intervals,
    uint8 *is_continuous);

/*! 
 * imb_instru_synced_counters_last_write_get
 *
 * @brief Get per IMB last write and number of writes. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  last_write      - Index of last record written.
 * @param [out]  nof_writes      - Cyclical number of records written.
 */
int imb_instru_synced_counters_last_write_get(
    int unit,
    bcm_port_t port,
    uint32 *last_write,
    uint32 *nof_writes);

/*! 
 * imb_instru_synced_counters_per_record_get
 *
 * @brief Get per record per port the instrumentation counters. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  record_index    - Index of the record to be read.
 * @param [in]  nof_counters    - Number of counters to be read. Number of elements in dbal_fields and counter_values.
 * @param [in]  dbal_fields     - An array (with nof_counters elements) of the DBAL fields to collect.
 * @param [out]  counter_values   - An array (with nof_counters elements) of the values of the counters.
 */
int imb_instru_synced_counters_per_record_get(
    int unit,
    bcm_port_t port,
    int record_index,
    int nof_counters,
    const int *dbal_fields,
    uint64 *counter_values);

/*! 
 * imb_instru_counters_reset_set_all
 *
 * @brief Reset per IMB instrumentation counters for all IMBs. 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  reset           - If TRUE, take counters into reset
 */
int imb_instru_counters_reset_set_all(
    int unit,
    uint8 reset);

/*! 
 * imb_instru_counters_reset_set
 *
 * @brief Reset per IMB instrumentation counters 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [in]  reset           - If TRUE, take counters into reset
 */
int imb_instru_counters_reset_set(
    int unit,
    int imb_id,
    uint8 reset);
/*! 
 * imb_instru_counters_reset_get
 *
 * @brief Reset per IMB instrumentation counters 
 *
 * @param [in]  unit            - unit id
 * @param [in]  imb_id          - imb instance id
 * @param [out]  reset           - Get the reset status of the counters
 */
int imb_instru_counters_reset_get(
    int unit,
    int imb_id,
    uint8 *reset);

/*! 
 * imb_instru_traffic_counters_reset_all
 *
 * @brief Reset per port traffic instrumentation counters for all IMBs. 
 *
 * @param [in]  unit            - Unit ID
 */
int imb_instru_traffic_counters_reset_all(
    int unit);

/*! 
 * imb_instru_traffic_counters_reset
 *
 * @brief Reset per port traffic counters for PFC Deadlock detection for entire IMB 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type
 */
int imb_instru_traffic_counters_reset(
    int unit,
    const imb_create_info_t * imb_info);

/*! 
 * imb_port_instru_traffic_counters_reset
 *
 * @brief Reset per port counters for traffic instrumentation counters 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_instru_traffic_counters_reset(
    int unit,
    bcm_port_t port);

/*! 
 * imb_instru_pfc_deadlock_counters_reset_all
 *
 * @brief Reset per port PFC Deadlock detection and PFC insturmentation counters for all IMBs. 
 *
 * @param [in]  unit            - Unit ID
 */
int imb_instru_pfc_deadlock_counters_reset_all(
    int unit);

/*! 
 * imb_instru_pfc_deadlock_counters_reset
 *
 * @brief Reset per port counters for PFC Deadlock detection and PFC insturmentation for entire IMB 
 *
 * @param [in]  unit            - Unit ID
 * @param [in]  imb_info        - IMB info structure for IMB to retrieve the IMB type
 */
int imb_instru_pfc_deadlock_counters_reset(
    int unit,
    const imb_create_info_t * imb_info);

/*! 
 * imb_port_instru_pfc_deadlock_counters_reset
 *
 * @brief Reset per port counters for PFC Deadlock detection and PFC instrumentation 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_instru_pfc_deadlock_counters_reset(
    int unit,
    bcm_port_t port);

/*! 
 * imb_pfc_deadlock_debug_info_get
 *
 * @brief Get PFC Deadlock mechanism debug info 
 *
 * @param [in]  unit            - unit id
 * @param [in]  ethu_id         - Ethrnet unit ID
 * @param [out]  ethu_port_num   - Port internal for the ETHU that is currently in deadlock
 * @param [out]  pfc_num         - PFC that is currently in deadlock
 */
int imb_pfc_deadlock_debug_info_get(
    int unit,
    int ethu_id,
    int *ethu_port_num,
    int *pfc_num);

/*! 
 * imb_pfc_deadlock_max_duration_set
 *
 * @brief PFC Deadlock recovery mechanism max duration of PFC set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  ethu_id         - Ethrnet unit ID
 * @param [in]  max_duration    - PFC duration that will trigger the Deadlock breaking mechanism
 */
int imb_pfc_deadlock_max_duration_set(
    int unit,
    int ethu_id,
    uint32 max_duration);
/*! 
 * imb_pfc_deadlock_max_duration_get
 *
 * @brief PFC Deadlock recovery mechanism max duration of PFC set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  ethu_id         - Ethrnet unit ID
 * @param [out]  max_duration    - PFC duration that will trigger the Deadlock breaking mechanism
 */
int imb_pfc_deadlock_max_duration_get(
    int unit,
    int ethu_id,
    uint32 *max_duration);

/*! 
 * imb_port_phy_control_validate
 *
 * @brief Check if phy control is supported for current PM. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - Phy Control type
 * @param [in]  is_set          - if this fuction is called by set function
 */
int imb_port_phy_control_validate(
    int unit,
    bcm_port_t port,
    bcm_port_phy_control_t type,
    int is_set);

/*! 
 * imb_port_pre_add_validate_wrap
 *
 * @brief Finds port relevant IMB info and dispatches. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phys            - port phys
 */
int imb_port_pre_add_validate_wrap(
    int unit,
    bcm_port_t port,
    bcm_pbmp_t phys);

/*! 
 * imb_port_pre_add_validate
 *
 * @brief  Checks port validaity in a early stage before any DB is modified 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  phys            - port phys
 */
int imb_port_pre_add_validate(
    int unit,
    bcm_port_t port,
    bcm_pbmp_t phys);

/*! 
 * imb_port_autoneg_ability_verify
 *
 * @brief Verify input AN abilities. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  num_ability     - number of abilities
 * @param [in]  abilities       - array of abilities
 */
int imb_port_autoneg_ability_verify(
    int unit,
    bcm_port_t port,
    int num_ability,
    const bcm_port_speed_ability_t * abilities);

/*! 
 * imb_port_pcs_lane_map_set
 *
 * @brief Configure PCS lane map. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tx_lane_swap    - Tx lane map
 * @param [in]  rx_lane_swap    - Rx lane map
 */
int imb_port_pcs_lane_map_set(
    int unit,
    bcm_port_t port,
    uint32 tx_lane_swap,
    uint32 rx_lane_swap);

/*! 
 * imb_port_link_status_change_event
 *
 * @brief Action on link status change 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_link_status_change_event(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_pm_lock_status_change_event
 *
 * @brief Action on PM lock status change 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_pm_lock_status_change_event(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_rx_buffers_restart
 *
 * @brief Set RX buffers of the port in/out of reset 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_port_rx_buffers_restart(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_l1_mismatch_rate_rx_config_set
 *
 * @brief Configure L1 Mismatch rate configuration for RMC. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  tx_speed        - the Tx speed
 * @param [in]  enable          - enable or disable the L1 mismatch rate config in Rx
 */
int imb_port_l1_mismatch_rate_rx_config_set(
    int unit,
    bcm_port_t port,
    int tx_speed,
    int enable);

/*! 
 * imb_port_post_ber_proj_get
 *
 * @brief Get th BER histogram and port-FEC estimation values 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane            - lane number
 * @param [in]  ber_proj        - pointer to the BER projection parameters
 * @param [in]  max_errcnt      - size of max_errcnt
 * @param [out]  errcnt_array    - pointer to the errcnt_array array for storing post-FEC estimation values
 * @param [out]  actual_errcnt   - actual number of errcnt in errcnt_array
 */
int imb_port_post_ber_proj_get(
    int unit,
    bcm_port_t port,
    int lane,
    const bcm_port_ber_proj_params_t * ber_proj,
    int max_errcnt,
    bcm_port_ber_proj_analyzer_errcnt_t * errcnt_array,
    int *actual_errcnt);

/*! 
 * imb_flexe_core_port_config_set
 *
 * @brief FlexE core port related configuration. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - imb FlexE flags
 * @param [in]  instance_id     - flexe instance ID
 * @param [in]  speed           - flexe physical port speed
 */
int imb_flexe_core_port_config_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int instance_id,
    int speed);

/*! 
 * imb_portmod_add_info_config
 *
 * @brief Initialize Portmod add_info before calling portmod_port_add. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  add_info        - Portmod port add info
 */
int imb_portmod_add_info_config(
    int unit,
    bcm_port_t port,
    portmod_port_add_info_t * add_info);

/*! 
 * imb_portmod_soft_reset_lock
 *
 * @brief Lock the mutex that protects portmod soft_reset context 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_portmod_soft_reset_lock(
    int unit,
    bcm_port_t port);

/*! 
 * imb_portmod_soft_reset_unlock
 *
 * @brief Unlock the mutex that protects portmod soft_reset context 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 */
int imb_portmod_soft_reset_unlock(
    int unit,
    bcm_port_t port);

/*! 
 * imb_port_link_fault_force_set
 *
 * @brief Get/set the link fault forcing. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - Local fault or remote fault
 * @param [in]  enable          - Enable or disable
 */
int imb_port_link_fault_force_set(
    int unit,
    bcm_port_t port,
    bcm_port_control_t type,
    int enable);
/*! 
 * imb_port_link_fault_force_get
 *
 * @brief Get/set the link fault forcing. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - Local fault or remote fault
 * @param [out]  enable          - Enable or disable
 */
int imb_port_link_fault_force_get(
    int unit,
    bcm_port_t port,
    bcm_port_control_t type,
    int *enable);

/*! 
 * imb_fec_global_enable_set
 *
 * @brief Configure global reset of FEC for given core.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  ilkn_core       - logical ilkn core
 * @param [in]  fec_enable      - fec state to be configure
 */
int imb_fec_global_enable_set(
    int unit,
    int ilkn_core,
    int fec_enable);

/*! 
 * imb_port_timesync_tx_info_get
 *
 * @brief Get two-step PTP PHY timesync tx info for port.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  tx_info         - time sync tx info
 */
int imb_port_timesync_tx_info_get(
    int unit,
    bcm_port_t port,
    bcm_port_timesync_tx_info_t * tx_info);

/*! 
 * imb_portmod_port_add
 *
 * @brief add port to portmod.  
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  port_info       - portmod add info
 */
int imb_portmod_port_add(
    int unit,
    bcm_port_t port,
    const portmod_port_add_info_t * port_info);

/*! 
 * imb_port_txpi_sdm_override_set
 *
 * @brief TXPI override configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  override        - TXPI SDM override value
 */
int imb_port_txpi_sdm_override_set(
    int unit,
    bcm_port_t port,
    const portmod_txpi_override_t * override);
/*! 
 * imb_port_txpi_sdm_override_get
 *
 * @brief TXPI override configuration 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  override        - TXPI SDM override value
 */
int imb_port_txpi_sdm_override_get(
    int unit,
    bcm_port_t port,
    portmod_txpi_override_t * override);

/*! 
 * imb_port_txpi_sdm_status_get
 *
 * @brief Get TXPI SDM output value 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  val             - TXPI SDM output value
 */
int imb_port_txpi_sdm_status_get(
    int unit,
    bcm_port_t port,
    int *val);

/*! 
 * imb_port_lane_map_set
 *
 * @brief Set/Get the logical lane mapping for logical ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags for indication of tx and rx
 * @param [in]  lanes           - Logical lanes.
 * @param [in]  nof_lanes       - Nof lanes of the logical port
 */
int imb_port_lane_map_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    const int *lanes,
    int nof_lanes);
/*! 
 * imb_port_lane_map_get
 *
 * @brief Set/Get the logical lane mapping for logical ports 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - flags for indication of tx and rx
 * @param [in]  nof_max_lanes   - Max lane numbers when get lanes
 * @param [out]  lanes           - Logical lane order, lane_order[N] is represent for the Nth lane
 * @param [out]  nof_actual_lanes   - The actual lane numbers when get lane
 */
int imb_port_lane_map_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int nof_max_lanes,
    int *lanes,
    int *nof_actual_lanes);

/*! 
 * imb_preemption_control_set
 *
 * @brief Port preemption configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - preemption parameter of type bcm_port_preempt_control_t
 * @param [in]  value           - configured value
 */
int imb_preemption_control_set(
    int unit,
    bcm_port_t port,
    bcm_port_preempt_control_t type,
    uint32 value);
/*! 
 * imb_preemption_control_get
 *
 * @brief Port preemption configuration set/get 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  type            - preemption parameter of type bcm_port_preempt_control_t
 * @param [out]  value           - returns configured value
 */
int imb_preemption_control_get(
    int unit,
    bcm_port_t port,
    bcm_port_preempt_control_t type,
    uint32 *value);

/*! 
 * imb_preemption_verify_status_get
 *
 * @brief Get the preemption verification status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - returns verify operation status of type bcm_port_preempt_status_verify_t
 */
int imb_preemption_verify_status_get(
    int unit,
    bcm_port_t port,
    uint32 *value);

/*! 
 * imb_preemption_tx_status_get
 *
 * @brief Get the preemption status on the transmit side 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [out]  value           - returns preemption status of type bcm_port_preempt_status_tx_t
 */
int imb_preemption_tx_status_get(
    int unit,
    bcm_port_t port,
    uint32 *value);

/*! 
 * imb_port_flr_link_config_set
 *
 * @brief Port FLR link configuration set 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  lane_id         - the logical lane ID in the port. -1 means all the lanes of the port.
 * @param [in]  config          - FLR link configuration values
 */
int imb_port_flr_link_config_set(
    int unit,
    bcm_port_t port,
    int lane_id,
    const bcm_port_flr_link_config_t * config);

/*! 
 * imb_port_mac_tx_threshold_set
 *
 * @brief Configure the MAC tx threshold according to the speed. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - The speed of the port
 */
int imb_port_mac_tx_threshold_set(
    int unit,
    bcm_port_t port,
    int speed);

/*! 
 * imb_port_ghao_speed_config_set
 *
 * @brief Configure the port speed for G.hao. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - The speed of the port
 */
int imb_port_ghao_speed_config_set(
    int unit,
    bcm_port_t port,
    int speed);

/*! 
 * imb_port_l1_eth_1588_enable_set
 *
 * @brief 1588 for L1 ETH ports enable set/get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Rx or Tx flags
 * @param [in]  enable          - Enable or disable 1588
 */
int imb_port_l1_eth_1588_enable_set(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int enable);
/*! 
 * imb_port_l1_eth_1588_enable_get
 *
 * @brief 1588 for L1 ETH ports enable set/get. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  flags           - Rx or Tx flags
 * @param [out]  enable          - Get enable status
 */
int imb_port_l1_eth_1588_enable_get(
    int unit,
    bcm_port_t port,
    uint32 flags,
    int *enable);

/*! 
 * imb_port_txpi_sdm_divider_set
 *
 * @brief Configure the TXPI SDM divider in PM according to the port speed. 
 *
 * @param [in]  unit            - unit id
 * @param [in]  port            - logical port
 * @param [in]  speed           - The speed of the port
 */
int imb_port_txpi_sdm_divider_set(
    int unit,
    bcm_port_t port,
    int speed);

/*! 
 * imb_pm_reset_get
 *
 * @brief Get the PM reset status 
 *
 * @param [in]  unit            - unit id
 * @param [in]  ethu_id         - Ethrnet unit ID
 * @param [out]  in_reset        - Get PM reset status
 */
int imb_pm_reset_get(
    int unit,
    int ethu_id,
    int *in_reset);

/*! 
 * @brief Port link status mux define 
 */
#define IMB_PORT_LINK_STATUS_MUX_FLEXE 8 /**< Link status mux to FlexE related ports */
#define IMB_PORT_LINK_STATUS_MUX_ETH 9 /**< Link status mux to regular ETH ports */

#endif /*_IMB_H_*/
