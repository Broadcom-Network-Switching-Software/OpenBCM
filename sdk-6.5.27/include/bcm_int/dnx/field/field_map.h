/**
 * \file bcm_int/dnx/field/field_map.h
 *
 * Field Processor definitions for BCM to DNX qualifier/action translations and fetching DNX params
 *
 * Purpose:
 *     'Field Processor' (FP) Procedures for mapping BCM to DNX qualifiers & actions
 *     Providing info per DNX qualifier/actions
 */
/*
 * 
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2022 Broadcom Inc. All rights reserved.
 */

#ifndef FIELD_FIELD_MAP_H_INCLUDED
/* { */
#define FIELD_FIELD_MAP_H_INCLUDED

#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX family only!"
#endif
/*
 * Include files
 * {
 */
#include <bcm_int/dnx/field/field.h>
#include <bcm_int/dnx/field/field_entry.h>
#include <bcm_int/dnx/field/field_presel.h>
#include <bcm_int/dnx/field/field_range.h>
#include <include/bcm_int/dnx/lif/in_lif_profile.h>
#include <include/bcm_int/dnx/lif/out_lif_profile.h>
#include <soc/dnx/field/tcam/tcam_handler.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_qualifier_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_actions_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_context_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_group_types.h>
#include <soc/dnx/swstate/auto_generated/access/dnx_field_apptype_access.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_field_map.h>
#include <bcm/field.h>
#include <soc/dnx/pp_stage.h>
#include <include/soc/dnx/pemladrv/pemladrv_virtual_wires.h>
/*
 * }
 */

/*
 * Defines
 * {
 */
/**
 * The number of the bit, on output 'offset' (of bcm_field_qualifier_info_get())
 * on which we indicate whether the original qualifier was of class 'META2'.
 * A value of '1' indicates 'META2 offset'.
            */
#define QUAL_OFFSET_META2_BIT                       31
/**
 * The bit indicating if a base qualifier is encoded unto the 
 */
#define QUAL_OFFSET_BASE_QUAL_EXITS_BIT             30
/**
 * The lsb bit on offset where we place the qualifier the user defined qualifier is based upon.
 * Currently used only for split qualifiers.
 */
#define QUAL_OFFSET_BASE_QUAL_LSB                   18
/**
 * The mask indicates how many bit base BCM qualifier can we use.
 */
#define QUAL_OFFSET_BASE_QUAL_MASK                  0xFFF
/**
 * The mask indicates how many bit of the offset are not encoded.
 */
#define QUAL_OFFSET_SHIFT_MASK                      0xFFFF
/**
 * Maximum offset value(6b) for DNX_FIELD_INPUT_TYPE_LAYER_RECORDS qualifiers
 */
#define DNX_INPUT_TYPE_MAX_OFFSET_LAYER_RECORDS     63
/**
 * General purpose invalid value.
 */
#define DNX_BCM_ID_INVALID          -1
/**
 * Position of qualifier class inside dnx qualifier
 */
#define DNX_QUAL_CLASS_SHIFT        24
/**
 * Represents actual max size of qualifier class - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_QUAL_CLASS_MASK         0xFF

/**
 * Position of dnx stage inside dnx qualifier
 */
#define DNX_QUAL_STAGE_SHIFT        16
/**
 * Represents actual max size of dnx stage - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_QUAL_STAGE_MASK         0xFF
/**
 * Represents actual max size of qualifier id - 16b
 * In spite of the fact that actual underlying type may different per class, it will never go beyond
 */
#define DNX_QUAL_INDEX_MASK         0xFFFF

/**
 * \brief Calculates BCM qualifier from DNX qualifier id for user defined qualifiers, used only internally
 *        in special cases where DNX qual id value is important
 * \param [in] dnx_qual_id - user defined dnx qualifier id
 * \return
 *      bcm_field_qualify_t
 */
#define DNX_USER_ID_TO_BCM(dnx_qual_id) (dnx_qual_id  + dnx_data_field.qual.user_1st_get(unit))

/**
 * \brief Checks if a BCM qualifier is within the range of the user defined qualifiers.
 * \param [in] unit        - Unit ID
 * \param [in] bcm_qual_id - BCM qual ID
 * \return
 *      TRUE  - If bcm_qual_id is within the range of user defined qualifiers.
 *      FALSE - Otherwise.
 */
#define DNX_FIELD_BCM_QUAL_IS_USER(unit, bcm_qual_id)                                                               \
    (((bcm_qual_id >= dnx_data_field.qual.user_1st_get(unit))                                                       \
        && (bcm_qual_id < dnx_data_field.qual.user_1st_get(unit) + dnx_data_field.qual.user_nof_get(unit))))

/**
 * \brief Checks if a BCM action is within the range of the user defined actions.
 * \param [in] unit          - Unit ID
 * \param [in] bcm_action_id - BCM qual ID
 * \return
 *      TRUE  - If bcm_action_id is within the range of user defined actions.
 *      FALSE - Otherwise.
 */
#define DNX_FIELD_BCM_ACTION_IS_USER(unit, bcm_action_id)                                                            \
    (((bcm_action_id >= dnx_data_field.action.user_1st_get(unit))                                                    \
        && (bcm_action_id < dnx_data_field.action.user_1st_get(unit) + dnx_data_field.action.user_nof_get(unit))))

#define DNX_FIELD_DNX_ACTION_PARAM_GET(stage,action_id,param)                                                            \
    (dnx_data_field_map.action.params_get(unit, ((stage == DNX_FIELD_STAGE_IPMF2) ? (DNX_FIELD_STAGE_IPMF1) : (stage)), action_id)->param)

#define DNX_FIELD_DNX_ACTION_IS_DEVICE_SUPPORTED(stage,action_id)                                                            \
    (DNX_FIELD_DNX_ACTION_PARAM_GET(stage,action_id,size) > 0)

/**
 * \brief Retrieve Qualifier class from dnx qualifier
 * \param [in] dnx_field_qual - Encoded DNX qualifier
 * \return
 *      dnx_field_qual_class_e
 */
#define DNX_QUAL_CLASS(dnx_field_qual)  ((dnx_field_qual >> DNX_QUAL_CLASS_SHIFT) & DNX_QUAL_CLASS_MASK)
/**
 * \brief Retrieve Field Stage from dnx qualifier
 * \param [in] dnx_field_qual - Encoded DNX qualifier
 * \return
 *      dnx_field_stage_e
 */
#define DNX_QUAL_STAGE(dnx_field_qual)  ((dnx_field_qual >> DNX_QUAL_STAGE_SHIFT) & DNX_QUAL_STAGE_MASK)
/**
 * \brief Retrieve Qualifier ID from dnx qualifier
 * \param [in] dnx_field_qual - Encoded DNX qualifier
 * \return
 *      dnx_field_qual_id_t(16 bit)
 * \remark
 *   Meaning of ID is different per CLass
 *   DNX_FIELD_QUAL_CLASS_META(2)       - per stage metadata enum
 *   DNX_FIELD_QUAL_CLASS_LAYER_RECORD  - dnx_field_layer_record_qual_e
 *   DNX_FIELD_QUAL_CLASS_USER          - Id provided by user or generated by algo
 *   DNX_FIELD_QUAL_CLASS_HEADER        - dnx_field_header_qual_e
 *   DNX_FIELD_QUAL_CLASS_SW            - dnx_field_sw_qual_e
 */
#define DNX_QUAL_ID(dnx_field_qual)      (dnx_field_qual & DNX_QUAL_INDEX_MASK)

/**
 * \brief Check if 2 qualifier are the same (Little bit strange FMPOV, but whatever ...)
 * \param [in] dnx_qual1 - Encoded DNX qualifier
 * \param [in] dnx_qual2 - Encoded DNX qualifier
 * \return
 *   \retval TRUE  - if they are the same
 *   \retval FALSE - if they are different
 */
#define DNX_QUAL_IS_SAME(dnx_qual1,dnx_qual2) \
        (dnx_qual1 == dnx_qual2) ||  \
        ((DNX_QUAL_CLASS(dnx_qual1) == DNX_FIELD_QUAL_CLASS_USER) && \
         (DNX_QUAL_CLASS(dnx_qual2) == DNX_FIELD_QUAL_CLASS_USER) && \
         (DNX_QUAL_ID(dnx_qual1) == DNX_QUAL_ID(dnx_qual2)))
/**
 * \brief Verify QUAL CLass
 * \param [in] qual_class - DNX qualifier class encoded in qualifier itself
 * \return
 *   \retval TRUE  - if class is valid one
 *   \retval FALSE - if it is not valid
 */
#define DNX_QUAL_CLASS_VERIFY(qual_class)                                                       \
    if((qual_class < DNX_FIELD_QUAL_CLASS_FIRST) || (qual_class >= DNX_FIELD_QUAL_CLASS_NOF))   \
    {                                                                                           \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Qualifier Class:%d is out of range\n", qual_class);         \
    }

/**
 * MAximum number of dnx actions that may be assigned to one bcm action
 */
#define MAX_DNX_ACTION_PER_BCM      3

/**
 * Position of action class inside dnx qualifier
 */
#define DNX_ACTION_CLASS_SHIFT        24
/**
 * Represents actual max size of action class - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_ACTION_CLASS_MASK         0xFF

/**
 * Position of field stage inside dnx action
 */
#define DNX_ACTION_STAGE_SHIFT        16
/**
 * Represents actual max size of dnx stage - 8b
 * In spite of the fact that actual type is enum, it will never go beyond 256 values
 */
#define DNX_ACTION_STAGE_MASK         0xFF
/**
 * Represents actual max size of action id - 16b
 * In spite of the fact that actual underlying type may different per class, it will never go beyond
 */
#define DNX_ACTION_INDEX_MASK         0xFFFF

/**
 * \brief Retrieve Qualifier class from dnx action
 * \param [in] dnx_field_action - Encoded DNX action
 * \return
 *      dnx_field_action_class_e
 */
#define DNX_ACTION_CLASS(dnx_field_action)  ((dnx_field_action >> DNX_ACTION_CLASS_SHIFT) & DNX_ACTION_CLASS_MASK)
/**
 * \brief Retrieve Field Stage from dnx action
 * \param [in] dnx_field_action - Encoded DNX action
 * \return
 *      dnx_field_stage_e
 */
#define DNX_ACTION_STAGE(dnx_field_action)  ((dnx_field_action >> DNX_ACTION_STAGE_SHIFT) & DNX_ACTION_STAGE_MASK)
/**
 * \brief Retrieve Action ID from dnx qualifier
 * \param [in] dnx_field_action - Encoded DNX action
 * \return
 *      dnx_field_action_id_t(16 bit)
 * \remark
 *   Meaning of ID is different per CLass
 *   DNX_FIELD_ACTION_CLASS_STATIC  - per stage action enum - action type as unified typedef
 *   DNX_FIELD_ACTION_CLASS_USER    - Id provided by user or generated by algo
 *   DNX_FIELD_ACTION_CLASS_SW      - dnx_field_sw_action_e
 */
#define DNX_ACTION_ID(dnx_field_action)      (dnx_field_action & DNX_QUAL_INDEX_MASK)

/**
 * The maximum number of virtual wire qualifiers.
 */
#define DNX_FIELD_MAP_MAX_VW_QUAL (100)
/**
 * The maximum number of virtual wire actions.
 */
#define DNX_FIELD_MAP_MAX_VW_ACTION (100)
/**
 * The maximum number of virtual wires that have field actions associated with them.
 */
#define DNX_FIELD_MAP_MAX_VW_WITH_ACTION (100)
/**
 * The maximum number of actions per virtual write.
 * For now every virtual wire uses one mapping only, so we use the maximum actions per mapping.
 */
#define DNX_FIELD_ACTION_MAX_ACTION_PER_VM (DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF)

typedef enum
{
    DNX_FIELD_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_QUAL_FIRST = DNX_FIELD_QUAL_ID_FIRST,
    DNX_FIELD_QUAL_ACL_CONTEXT = DNX_FIELD_QUAL_FIRST,
    DNX_FIELD_QUAL_ACTION_PROFILE_DA_NOT_FOUND_INDEX,
    DNX_FIELD_QUAL_ACTION_PROFILE_SA_DROP_INDEX,
    DNX_FIELD_QUAL_ACTION_PROFILE_SA_NOT_FOUND_INDEX,
    DNX_FIELD_QUAL_AC_IN_LIF_WIDE_DATA,
    DNX_FIELD_QUAL_AC_IN_LIF_WIDE_DATA_EXTENDED,
    DNX_FIELD_QUAL_ADMT_PROFILE,
    DNX_FIELD_QUAL_ALGO_LPM_RESULT_1,
    DNX_FIELD_QUAL_ALGO_LPM_RESULT_2,
    DNX_FIELD_QUAL_ALL_ONES,
    DNX_FIELD_QUAL_ALT_CONTEXT,
    DNX_FIELD_QUAL_APPLICATION_SPECIFIC_EXT,
    DNX_FIELD_QUAL_BIER_BFR_EXT,
    DNX_FIELD_QUAL_BIER_STR_OFFSET,
    DNX_FIELD_QUAL_BIER_STR_SIZE,
    DNX_FIELD_QUAL_BTC_MINUS_BTK,
    DNX_FIELD_QUAL_BTC_OFFSET_SOP,
    DNX_FIELD_QUAL_BTK_OFFSET_SOP,
    DNX_FIELD_QUAL_BYTES_TO_REMOVE,
    DNX_FIELD_QUAL_CFG_CORE_ID,
    DNX_FIELD_QUAL_CMP_KEY_0_DECODED,
    DNX_FIELD_QUAL_CMP_KEY_1_DECODED,
    DNX_FIELD_QUAL_CMP_KEY_TCAM_0_DECODED,
    DNX_FIELD_QUAL_CMP_KEY_TCAM_1_DECODED,
    DNX_FIELD_QUAL_CONGESTION_INFO,
    DNX_FIELD_QUAL_CONTEXT,
    DNX_FIELD_QUAL_CONTEXT_KEY_GEN_VAR,
    DNX_FIELD_QUAL_CORE_ID,
    DNX_FIELD_QUAL_CPU_TRAP_CODE_PROFILE,
    DNX_FIELD_QUAL_CUD_OUTLIF_OR_MCDB_PTR,
    DNX_FIELD_QUAL_DISCARD,
    DNX_FIELD_QUAL_DP,
    DNX_FIELD_QUAL_DST_SYS_PORT,
    DNX_FIELD_QUAL_DUAL_QUEUE,
    DNX_FIELD_QUAL_ECL_VALID,
    DNX_FIELD_QUAL_ECMP_LB_KEY_0,
    DNX_FIELD_QUAL_ECMP_LB_KEY_1,
    DNX_FIELD_QUAL_ECMP_LB_KEY_2,
    DNX_FIELD_QUAL_ECN,
    DNX_FIELD_QUAL_EEI,
    DNX_FIELD_QUAL_EGRESS_LEARN_ENABLE,
    DNX_FIELD_QUAL_EGRESS_PARSING_INDEX,
    DNX_FIELD_QUAL_ELEPHANT_LEARN_NEEDED,
    DNX_FIELD_QUAL_ELEPHANT_TRAP_INFO,
    DNX_FIELD_QUAL_ELK_LKP_HIT_0,
    DNX_FIELD_QUAL_ELK_LKP_HIT_1,
    DNX_FIELD_QUAL_ELK_LKP_HIT_2,
    DNX_FIELD_QUAL_ELK_LKP_HIT_3,
    DNX_FIELD_QUAL_ELK_LKP_HIT_4,
    DNX_FIELD_QUAL_ELK_LKP_HIT_5,
    DNX_FIELD_QUAL_ELK_LKP_HIT_6,
    DNX_FIELD_QUAL_ELK_LKP_HIT_7,
    DNX_FIELD_QUAL_EXTERNAL_RESULT_BUFFER_PART_0,
    DNX_FIELD_QUAL_EXTERNAL_RESULT_BUFFER_PART_1,
    DNX_FIELD_QUAL_ENABLE_PP_INJECT,
    DNX_FIELD_QUAL_ENCODER0,
    DNX_FIELD_QUAL_ENCODER1,
    DNX_FIELD_QUAL_ENCODER2,
    DNX_FIELD_QUAL_ENCODER3,
    DNX_FIELD_QUAL_END_OF_PACKET_EDITING,
    DNX_FIELD_QUAL_EPMF_CONTEXT_LFSR_1,
    DNX_FIELD_QUAL_EPMF_CONTEXT_LFSR_2,
    DNX_FIELD_QUAL_EPMF_CONTEXT_VAR,
    DNX_FIELD_QUAL_ESTIMATED_BTR,
    DNX_FIELD_QUAL_ETHER_TYPE_CODE,
    DNX_FIELD_QUAL_ETH_TAG_FORMAT,
    DNX_FIELD_QUAL_EXT_STATISTICS_ATR_0,
    DNX_FIELD_QUAL_EXT_STATISTICS_ATR_1,
    DNX_FIELD_QUAL_EXT_STATISTICS_ATR_2,
    DNX_FIELD_QUAL_EXT_STATISTICS_ATR_3,
    DNX_FIELD_QUAL_EXT_STATISTICS_ID_0,
    DNX_FIELD_QUAL_EXT_STATISTICS_ID_1,
    DNX_FIELD_QUAL_EXT_STATISTICS_ID_2,
    DNX_FIELD_QUAL_EXT_STATISTICS_ID_3,
    DNX_FIELD_QUAL_EXT_STATISTICS_VALID,
    DNX_FIELD_QUAL_FABRIC_OR_EGRESS_MC,
    DNX_FIELD_QUAL_FAI_DO_NOT_DEC_TTL,
    DNX_FIELD_QUAL_FER_STAGE_0_IN_DST,
    DNX_FIELD_QUAL_FER_STAGE_1_IN_DST,
    DNX_FIELD_QUAL_FER_STAGE_2_IN_DST,
    DNX_FIELD_QUAL_FER_STAGE_0_IN_DST_IS_MINE,
    DNX_FIELD_QUAL_FER_STAGE_1_IN_DST_IS_MINE,
    DNX_FIELD_QUAL_FER_STAGE_2_IN_DST_IS_MINE,
    DNX_FIELD_QUAL_FER_STAGE_0_RESOLVED_FEC_PTR,
    DNX_FIELD_QUAL_FER_STAGE_1_RESOLVED_FEC_PTR,
    DNX_FIELD_QUAL_FER_STAGE_2_RESOLVED_FEC_PTR,
    DNX_FIELD_QUAL_FER_STAGE_0_RESOLVED_FEC_VALID,
    DNX_FIELD_QUAL_FER_STAGE_1_RESOLVED_FEC_VALID,
    DNX_FIELD_QUAL_FER_STAGE_2_RESOLVED_FEC_VALID,
    DNX_FIELD_QUAL_USER_HEADER_1_EXT,
    DNX_FIELD_QUAL_USER_HEADER_2_EXT,
    DNX_FIELD_QUAL_FER_STATISTICS_OBJ,
    DNX_FIELD_QUAL_FHEI_EXT,
    DNX_FIELD_QUAL_FLOW_ID_EXT,
    DNX_FIELD_QUAL_FLP_STATISTICS_ATR_0,
    DNX_FIELD_QUAL_FLP_STATISTICS_ATR_1,
    DNX_FIELD_QUAL_FLP_STATISTICS_ATR_2,
    DNX_FIELD_QUAL_FLP_STATISTICS_ATR_3,
    DNX_FIELD_QUAL_FLP_STATISTICS_ATR_4,
    DNX_FIELD_QUAL_FLP_STATISTICS_ATR_5,
    DNX_FIELD_QUAL_FLP_STATISTICS_ID_0,
    DNX_FIELD_QUAL_FLP_STATISTICS_ID_1,
    DNX_FIELD_QUAL_FLP_STATISTICS_ID_2,
    DNX_FIELD_QUAL_FLP_STATISTICS_ID_3,
    DNX_FIELD_QUAL_FLP_STATISTICS_ID_4,
    DNX_FIELD_QUAL_FLP_STATISTICS_ID_5,
    DNX_FIELD_QUAL_FTMH_APPLICATION_SPECIFIC_EXT_PRESENT,
    DNX_FIELD_QUAL_FTMH_AQM_PROFILE,
    DNX_FIELD_QUAL_FTMH_BIER_BFR_EXT_PRESENT,
    DNX_FIELD_QUAL_FTMH_CNI,
    DNX_FIELD_QUAL_FTMH_DP,
    DNX_FIELD_QUAL_FTMH_ECN_ENABLE,
    DNX_FIELD_QUAL_FTMH_FLOW_ID_EXT_PRESENT,
    DNX_FIELD_QUAL_FTMH_MCID_OR_OUTLIF_0_OR_MCDB_PTR,
    DNX_FIELD_QUAL_FTMH_PACKET_SIZE,
    DNX_FIELD_QUAL_FTMH_PPH_PRESENT,
    DNX_FIELD_QUAL_FTMH_RESERVED,
    DNX_FIELD_QUAL_FTMH_SRC_SYS_PORT,
    DNX_FIELD_QUAL_FTMH_TC,
    DNX_FIELD_QUAL_FTMH_TM_ACTION_IS_MC,
    DNX_FIELD_QUAL_FTMH_TM_ACTION_TYPE,
    DNX_FIELD_QUAL_FTMH_TM_DESTINATION_EXT_PRESENT,
    DNX_FIELD_QUAL_FTMH_TM_PROFILE,
    DNX_FIELD_QUAL_FTMH_TSH_EXT_PRESENT,
    DNX_FIELD_QUAL_FTMH_VISIBILITY,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_FWD_FOUND,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_FWD_PROFILE,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_FWD_RESULT,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_FWD_STRENGTH,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_RPF_FOUND,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_RPF_PROFILE,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_RPF_RESULT,
    DNX_FIELD_QUAL_FWD1_PRIORITY_DECODER_RPF_STRENGTH,
    DNX_FIELD_QUAL_FWD_ACTION_CPU_TRAP_CODE,
    DNX_FIELD_QUAL_FWD_ACTION_CPU_TRAP_QUAL,
    DNX_FIELD_QUAL_FWD_ACTION_DESTINATION,
    DNX_FIELD_QUAL_FWD_ACTION_DP,
    DNX_FIELD_QUAL_FWD_ACTION_DP_METER_COMMAND,
    DNX_FIELD_QUAL_FWD_ACTION_PROFILE_INDEX,
    DNX_FIELD_QUAL_FWD_ACTION_STRENGTH,
    DNX_FIELD_QUAL_FWD_ACTION_TC,
    DNX_FIELD_QUAL_FWD_CONTEXT,
    DNX_FIELD_QUAL_FWD_DOMAIN,
    DNX_FIELD_QUAL_FWD_DOMAIN_PROFILE,
    DNX_FIELD_QUAL_FWD_KAPSB_IF0_ERR,
    DNX_FIELD_QUAL_FWD_KAPSB_IF0_FOUND,
    DNX_FIELD_QUAL_FWD_KAPSB_IF0_PAYLOAD,
    DNX_FIELD_QUAL_FWD_KAPSB_IF1_ERR,
    DNX_FIELD_QUAL_FWD_KAPSB_IF1_FOUND,
    DNX_FIELD_QUAL_FWD_KAPSB_IF1_PAYLOAD,
    DNX_FIELD_QUAL_FWD_KAPSC_IF0_ERR,
    DNX_FIELD_QUAL_FWD_KAPSC_IF0_FOUND,
    DNX_FIELD_QUAL_FWD_KAPSC_IF0_PAYLOAD,
    DNX_FIELD_QUAL_FWD_KAPSC_IF1_ERR,
    DNX_FIELD_QUAL_FWD_KAPSC_IF1_FOUND,
    DNX_FIELD_QUAL_FWD_KAPSC_IF1_PAYLOAD,
    DNX_FIELD_QUAL_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_QUAL_FWD_LAYER_INDEX,
    DNX_FIELD_QUAL_FWD_OPAQUE_FIELD,
    DNX_FIELD_QUAL_FWD_PAYLOAD,
    DNX_FIELD_QUAL_FWD_PLUS1_REMARK_PROFILE,
    DNX_FIELD_QUAL_TYPE_FWD_REMARK_OR_KEEP,
    DNX_FIELD_QUAL_FWD_STAT_ATTRIBUTE_OBJ,
    DNX_FIELD_QUAL_FWD_STAT_ATTRIBUTE_OBJ_CMD,
    DNX_FIELD_QUAL_GENERAL_DATA,
    DNX_FIELD_QUAL_GENERAL_DATA_0,
    DNX_FIELD_QUAL_GENERAL_DATA_1,
    DNX_FIELD_QUAL_GENERAL_DATA_2,
    DNX_FIELD_QUAL_GENERAL_DATA_3,
    DNX_FIELD_QUAL_GENERAL_DATA_PMF_CONTAINER,
    DNX_FIELD_QUAL_GLOB_IN_LIF_0,
    DNX_FIELD_QUAL_GLOB_IN_LIF_1,
    DNX_FIELD_QUAL_GLOB_OUT_LIF_0,
    DNX_FIELD_QUAL_GLOB_OUT_LIF_1,
    DNX_FIELD_QUAL_GLOB_OUT_LIF_2,
    DNX_FIELD_QUAL_GLOB_OUT_LIF_3,
    DNX_FIELD_QUAL_GLOB_VOQ_AGG_ADDR,
    DNX_FIELD_QUAL_IEEE1588_COMMAND,
    DNX_FIELD_QUAL_IEEE1588_COMPENSATE_TIME_STAMP,
    DNX_FIELD_QUAL_IEEE1588_ENCAPSULATION,
    DNX_FIELD_QUAL_IEEE1588_HEADER_OFFSET,
    DNX_FIELD_QUAL_INCOMING_TAG_STRUCTURE,
    DNX_FIELD_QUAL_INGRESS_LEARN_ENABLE,
    DNX_FIELD_QUAL_INGRESS_PROTOCOL_TRAP_IN_LIF_PROFILE,
    DNX_FIELD_QUAL_IN_LIF_PROFILE_0,
    DNX_FIELD_QUAL_PPH_IN_LIF_PROFILE_0,
    DNX_FIELD_QUAL_IN_LIF_PROFILE_1,
    DNX_FIELD_QUAL_IN_LIF_UNKNOWN_DA_PROFILE,
    DNX_FIELD_QUAL_IN_PORT,
    DNX_FIELD_QUAL_IN_PORT_KEY_GEN_VAR,
    DNX_FIELD_QUAL_IN_PORT_MAPPED_PP_PORT,
    DNX_FIELD_QUAL_IN_TTL,
    DNX_FIELD_QUAL_IPV4_CHECKSUM_ERROR,
    DNX_FIELD_QUAL_IPV4_DIP_ZERO_ERROR,
    DNX_FIELD_QUAL_IPV4_HEADER_LENGTH_ERROR,
    DNX_FIELD_QUAL_IPV4_OPTIONS_ERROR,
    DNX_FIELD_QUAL_IPV4_SIP_EQUAL_DIP_ERROR,
    DNX_FIELD_QUAL_IPV4_SIP_IS_MC_ERROR,
    DNX_FIELD_QUAL_IPV4_TOTAL_LENGTH_ERROR,
    DNX_FIELD_QUAL_IPV4_VERSION_ERROR,
    DNX_FIELD_QUAL_IP_MC_ELIGIBLE,
    DNX_FIELD_QUAL_IP_MC_SHOULD_BE_BRIDGED,
    DNX_FIELD_QUAL_IP_TUNNEL_IN_LIF_WIDE_DATA,
    DNX_FIELD_QUAL_IS_IN_LIF_VALID_FOR_LM,
    DNX_FIELD_QUAL_IS_TDM,
    DNX_FIELD_QUAL_ITPP_DELTA,
    DNX_FIELD_QUAL_IVE_BYTES_TO_ADD,
    DNX_FIELD_QUAL_IVE_BYTES_TO_REMOVE,
    DNX_FIELD_QUAL_KEY_F_INITIAL,
    DNX_FIELD_QUAL_KEY_G_INITIAL,
    DNX_FIELD_QUAL_KEY_H_INITIAL,
    DNX_FIELD_QUAL_KEY_I_INITIAL,
    DNX_FIELD_QUAL_KEY_J_INITIAL,
    DNX_FIELD_QUAL_L4OPS,
    DNX_FIELD_QUAL_L4_PORT_IN_RANGE,
    DNX_FIELD_QUAL_LAG_LB_KEY,
    DNX_FIELD_QUAL_LATENCY_FLOW_ID,
    DNX_FIELD_QUAL_LATENCY_FLOW_ID_VALID,
    DNX_FIELD_QUAL_LB_KEY,
    DNX_FIELD_QUAL_LEARN_DATA,
    DNX_FIELD_QUAL_LEARN_EXPECTED_WON,
    DNX_FIELD_QUAL_LEARN_EXT,
    DNX_FIELD_QUAL_LEARN_EXT_DATA,
    DNX_FIELD_QUAL_LEARN_EXT_SRC_MAC,
    DNX_FIELD_QUAL_LEARN_EXT_VLAN,
    DNX_FIELD_QUAL_LEARN_EXT_VSI,
    DNX_FIELD_QUAL_LEARN_FOUND,
    DNX_FIELD_QUAL_LEARN_INFO,
    DNX_FIELD_QUAL_LEARN_MATCH,
    DNX_FIELD_QUAL_LEARN_SRC_MAC,
    DNX_FIELD_QUAL_LEARN_STATION_MOVE,
    DNX_FIELD_QUAL_LEARN_VALID,
    DNX_FIELD_QUAL_LEARN_VLAN,
    DNX_FIELD_QUAL_LEARN_VSI,
    DNX_FIELD_QUAL_LFSR_1,
    DNX_FIELD_QUAL_LFSR_2,
    DNX_FIELD_QUAL_LIF_EXT,
    DNX_FIELD_QUAL_LIF_OAM_TRAP_PROFILE,
    DNX_FIELD_QUAL_LPM_A1_FOUND,
    DNX_FIELD_QUAL_LPM_A1_LENGTH,
    DNX_FIELD_QUAL_LPM_A2_FOUND,
    DNX_FIELD_QUAL_LPM_A2_LENGTH,
    DNX_FIELD_QUAL_LOCAL_OUT_LIF,
    DNX_FIELD_QUAL_MACT_ENTRY_GROUPING,
    DNX_FIELD_QUAL_MDL,
    DNX_FIELD_QUAL_MEM_SOFT_ERR,
    DNX_FIELD_QUAL_MIRROR_CODE,
    DNX_FIELD_QUAL_MIRROR_QUALIFIER,
    DNX_FIELD_QUAL_MKX_OPCODE,
    DNX_FIELD_QUAL_MP_PROFILE_SEL,
    DNX_FIELD_QUAL_MY_CFM_MAC,
    DNX_FIELD_QUAL_NASID,
    DNX_FIELD_QUAL_NATIVE_AC_IN_LIF_WIDE_DATA,
    DNX_FIELD_QUAL_NAUID,
    DNX_FIELD_QUAL_NOF_VALID_LM_LIFS,
    DNX_FIELD_QUAL_NOF_VALID_PACKET_BYTES,
    DNX_FIELD_QUAL_NWK_KEY,
    DNX_FIELD_QUAL_NWK_LB_KEY,
    DNX_FIELD_QUAL_NWK_QOS,
    DNX_FIELD_QUAL_OAM_ID,
    DNX_FIELD_QUAL_OAM_METER_DISABLE,
    DNX_FIELD_QUAL_OAM_OFFSET,
    DNX_FIELD_QUAL_OAM_OPCODE,
    DNX_FIELD_QUAL_OAM_STAMP_OFFSET,
    DNX_FIELD_QUAL_OAM_STATISTICS_OBJ_0,
    DNX_FIELD_QUAL_OAM_STATISTICS_OBJ_1,
    DNX_FIELD_QUAL_OAM_STATISTICS_OBJ_2,
    DNX_FIELD_QUAL_OAM_SUB_TYPE,
    DNX_FIELD_QUAL_OAM_UP_MEP,
    DNX_FIELD_QUAL_OAM_YOUR_DISCR,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_0,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_1,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_2,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_3,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_LFSR_1_IN_RANGE,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_LFSR_2_IN_RANGE,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_PMF_QUAL_0,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_PMF_QUAL_1,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_PMF_QUAL_2,
    DNX_FIELD_QUAL_OUT_LIF_PROFILE_PMF_QUAL_3,
    DNX_FIELD_QUAL_OUT_PP_PORT,
    DNX_FIELD_QUAL_OUT_PP_PORT_LFSR_1_IN_RANGE,
    DNX_FIELD_QUAL_OUT_PP_PORT_LFSR_2_IN_RANGE,
    DNX_FIELD_QUAL_OUT_TM_PORT,
    DNX_FIELD_QUAL_PACKET_HEADER_SIZE,
    DNX_FIELD_QUAL_PACKET_HEADER_SIZE_RANGE,
    DNX_FIELD_QUAL_PACKET_IS_APPLET,
    DNX_FIELD_QUAL_PACKET_IS_BFD,
    DNX_FIELD_QUAL_PACKET_IS_BIER,
    DNX_FIELD_QUAL_PACKET_IS_COMPATIBLE_MC,
    DNX_FIELD_QUAL_PACKET_IS_IEEE1588,
    DNX_FIELD_QUAL_PACKET_IS_OAM,
    DNX_FIELD_QUAL_PER_PORT_TABLE_DATA,
    DNX_FIELD_QUAL_PMF1_DIRECT_ACTION,
    DNX_FIELD_QUAL_PMF1_EXEM_ACTION,
    DNX_FIELD_QUAL_PMF1_TCAM_ACTION_0,
    DNX_FIELD_QUAL_PMF1_TCAM_ACTION_1,
    DNX_FIELD_QUAL_PMF1_TCAM_ACTION_2,
    DNX_FIELD_QUAL_PMF1_TCAM_ACTION_3,
    DNX_FIELD_QUAL_PMF_ETH_RIF_PROFILE,
    DNX_FIELD_QUAL_PPH_END_OF_PACKET_EDITING,
    DNX_FIELD_QUAL_PPH_FHEI_SIZE,
    DNX_FIELD_QUAL_PPH_FWD_DOMAIN,
    DNX_FIELD_QUAL_PPH_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_QUAL_PPH_FWD_LAYER_INDEX,
    DNX_FIELD_QUAL_PPH_FWD_STRENGTH,
    DNX_FIELD_QUAL_PPH_IN_LIF,
    DNX_FIELD_QUAL_PPH_IN_LIF_PROFILE,
    DNX_FIELD_QUAL_PPH_LEARN_EXT_PRESENT,
    DNX_FIELD_QUAL_PPH_LIF_EXT_TYPE,
    DNX_FIELD_QUAL_PPH_NWK_QOS,
    DNX_FIELD_QUAL_PPH_PARSING_START_OFFSET,
    DNX_FIELD_QUAL_PPH_PARSING_START_TYPE,
    DNX_FIELD_QUAL_PPH_RESERVED,
    DNX_FIELD_QUAL_PPH_TTL,
    DNX_FIELD_QUAL_PPH_TYPE,
    DNX_FIELD_QUAL_PPH_VALUE1,
    DNX_FIELD_QUAL_PPH_VALUE2,
    DNX_FIELD_QUAL_PPH_VRF_VALUE,
    DNX_FIELD_QUAL_PP_DSP,
    DNX_FIELD_QUAL_PP_PORT,
    DNX_FIELD_QUAL_PP_PORT_PMF_GENERAL_DATA,
    DNX_FIELD_QUAL_PP_PORT_PMF_PROFILE,
    DNX_FIELD_QUAL_PROGRAM_INDEX,
    DNX_FIELD_QUAL_PRT_QUALIFIER,
    DNX_FIELD_QUAL_PTC,
    DNX_FIELD_QUAL_PTC_KEY_GEN_VAR,
    DNX_FIELD_QUAL_PWE_IN_LIF_WIDE_DATA,
    DNX_FIELD_QUAL_RPF_DEFAULT_ROUTE_FOUND,
    DNX_FIELD_QUAL_RPF_DST,
    DNX_FIELD_QUAL_RPF_DST_VALID,
    DNX_FIELD_QUAL_RPF_ECMP_GROUP,
    DNX_FIELD_QUAL_RPF_ECMP_MODE,
    DNX_FIELD_QUAL_RPF_OPAQUE_FIELD,
    DNX_FIELD_QUAL_RPF_OUT_LIF,
    DNX_FIELD_QUAL_RPF_ROUTE_VALID,
    DNX_FIELD_QUAL_SAVED_CONTEXT_PROFILE,
    DNX_FIELD_QUAL_SLB_KEY,
    DNX_FIELD_QUAL_SLB_LEARN_NEEDED,
    DNX_FIELD_QUAL_SLB_PAYLOAD,
    DNX_FIELD_QUAL_SLLB_MEMBER_REFERENCE,
    DNX_FIELD_QUAL_SNOOP_ACTION_PROFILE_INDEX,
    DNX_FIELD_QUAL_SNOOP_CODE,
    DNX_FIELD_QUAL_SNOOP_QUALIFIER,
    DNX_FIELD_QUAL_SNOOP_STRENGTH,
    DNX_FIELD_QUAL_SOCST,
    DNX_FIELD_QUAL_SONST,
    DNX_FIELD_QUAL_SRC_SYS_PORT,
    DNX_FIELD_QUAL_STACKING_EXT,
    DNX_FIELD_QUAL_STACKING_ROUTE_HISTORY_BITMAP,
    DNX_FIELD_QUAL_STATE_TABLE_ADDRESS,
    DNX_FIELD_QUAL_STATE_TABLE_DATA,
    DNX_FIELD_QUAL_STATE_TABLE_DATA_WRITE,
    DNX_FIELD_QUAL_STATISTICAL_SAMPLING_CODE,
    DNX_FIELD_QUAL_STATISTICAL_SAMPLING_QUALIFIER,
    DNX_FIELD_QUAL_STATISTICS_ATR_0,
    DNX_FIELD_QUAL_STATISTICS_ATR_1,
    DNX_FIELD_QUAL_STATISTICS_ATR_2,
    DNX_FIELD_QUAL_STATISTICS_ATR_3,
    DNX_FIELD_QUAL_STATISTICS_ATR_4,
    DNX_FIELD_QUAL_STATISTICS_ATR_5,
    DNX_FIELD_QUAL_STATISTICS_ATR_6,
    DNX_FIELD_QUAL_STATISTICS_ATR_7,
    DNX_FIELD_QUAL_STATISTICS_ATR_8,
    DNX_FIELD_QUAL_STATISTICS_ATR_9,
    DNX_FIELD_QUAL_STATISTICS_ATR_10,
    DNX_FIELD_QUAL_STATISTICS_ATR_11,
    DNX_FIELD_QUAL_STATISTICS_ID_0,
    DNX_FIELD_QUAL_STATISTICS_ID_1,
    DNX_FIELD_QUAL_STATISTICS_ID_2,
    DNX_FIELD_QUAL_STATISTICS_ID_3,
    DNX_FIELD_QUAL_STATISTICS_ID_4,
    DNX_FIELD_QUAL_STATISTICS_ID_5,
    DNX_FIELD_QUAL_STATISTICS_ID_6,
    DNX_FIELD_QUAL_STATISTICS_ID_7,
    DNX_FIELD_QUAL_STATISTICS_ID_8,
    DNX_FIELD_QUAL_STATISTICS_ID_9,
    DNX_FIELD_QUAL_STATISTICS_ID_10,
    DNX_FIELD_QUAL_STATISTICS_ID_11,
    DNX_FIELD_QUAL_STATISTICS_META_DATA,
    DNX_FIELD_QUAL_STATISTICS_OBJECT10,
    DNX_FIELD_QUAL_STATISTICS_OBJ_0,
    DNX_FIELD_QUAL_STATISTICS_OBJ_1,
    DNX_FIELD_QUAL_STATISTICS_OBJ_2,
    DNX_FIELD_QUAL_STATISTICS_OBJ_3,
    DNX_FIELD_QUAL_STATISTICS_OBJ_4,
    DNX_FIELD_QUAL_STATISTICS_OBJ_5,
    DNX_FIELD_QUAL_STATISTICS_OBJ_6,
    DNX_FIELD_QUAL_STATISTICS_OBJ_7,
    DNX_FIELD_QUAL_STATISTICS_OBJ_8,
    DNX_FIELD_QUAL_STATISTICS_OBJ_9,
    DNX_FIELD_QUAL_STATISTICS_OBJ_10,
    DNX_FIELD_QUAL_STATISTICS_OBJ_11,
    DNX_FIELD_QUAL_STATISTICS_OBJ_12,
    DNX_FIELD_QUAL_STAT_OBJ_LM_READ_INDEX,
    DNX_FIELD_QUAL_ST_VSQ_PTR,
    DNX_FIELD_QUAL_SYSTEM_HEADERS_SIZE,
    DNX_FIELD_QUAL_SYSTEM_HEADER_PROFILE_INDEX,
    DNX_FIELD_QUAL_TC,
    DNX_FIELD_QUAL_TC_MAP_PROFILE,
    DNX_FIELD_QUAL_TM_DESTINATION_EXT,
    DNX_FIELD_QUAL_TM_FLOW_ATR,
    DNX_FIELD_QUAL_TM_FLOW_ID,
    DNX_FIELD_QUAL_TM_PORT_PMF_PROFILE,
    DNX_FIELD_QUAL_TM_PROFILE,
    DNX_FIELD_QUAL_TRACE_PACKET,
    DNX_FIELD_QUAL_TRJ_HASH,
    DNX_FIELD_QUAL_TSH_EXT,
    DNX_FIELD_QUAL_UDH_BASE_ENTRY_PUSH_PROFILE,
    DNX_FIELD_QUAL_UDH_BASE_PRP_CS_VAR,
    DNX_FIELD_QUAL_UNKNOWN_ADDRESS,
    DNX_FIELD_QUAL_UPDATED_TPIDS_PACKET_DATA,
    DNX_FIELD_QUAL_USER_HEADERS_TYPE,
    DNX_FIELD_QUAL_USER_HEADER_1,
    DNX_FIELD_QUAL_USER_HEADER_1_TYPE,
    DNX_FIELD_QUAL_USER_HEADER_2,
    DNX_FIELD_QUAL_USER_HEADER_2_TYPE,
    DNX_FIELD_QUAL_USER_HEADER_3,
    DNX_FIELD_QUAL_USER_HEADER_3_TYPE,
    DNX_FIELD_QUAL_USER_HEADER_4,
    DNX_FIELD_QUAL_USER_HEADER_4_TYPE,
    DNX_FIELD_QUAL_VID_VALID,
    DNX_FIELD_QUAL_VISIBILITY,
    DNX_FIELD_QUAL_VISIBILITY_CLEAR,
    DNX_FIELD_QUAL_VLAN_EDIT_CMD,       /* Data contains VID1(12), VID2(12), PCP_DEI1(4), PCP_DEI2(4), CMD(7) */
    DNX_FIELD_QUAL_VLAN_EDIT_CMD_INDEX,
    DNX_FIELD_QUAL_VLAN_EDIT_DEI_1,
    DNX_FIELD_QUAL_VLAN_EDIT_DEI_2,
    DNX_FIELD_QUAL_VLAN_EDIT_PCP_1,
    DNX_FIELD_QUAL_VLAN_EDIT_PCP_2,
    DNX_FIELD_QUAL_VLAN_EDIT_PCP_DEI_1,
    DNX_FIELD_QUAL_VLAN_EDIT_PCP_DEI_2,
    DNX_FIELD_QUAL_VLAN_EDIT_VID_1,
    DNX_FIELD_QUAL_VLAN_EDIT_VID_2,
    DNX_FIELD_QUAL_VRF_VALUE,
    DNX_FIELD_QUAL_VSI_UNKNOWN_DA_DESTINATION,
    DNX_FIELD_QUAL_VTT_OAM_LIF_0,
    DNX_FIELD_QUAL_VTT_OAM_LIF_0_VALID,
    DNX_FIELD_QUAL_VTT_OAM_LIF_1,
    DNX_FIELD_QUAL_VTT_OAM_LIF_1_VALID,
    DNX_FIELD_QUAL_VTT_OAM_LIF_2,
    DNX_FIELD_QUAL_VTT_OAM_LIF_2_VALID,
    DNX_FIELD_QUAL_VTT_OAM_PCP_0,
    DNX_FIELD_QUAL_VTT_OAM_PCP_1,
    DNX_FIELD_QUAL_VTT_OAM_PCP_2,
    DNX_FIELD_QUAL_VW_MEMBER_REFERENCE,
    DNX_FIELD_QUAL_VW_PCC_HIT,
    DNX_FIELD_QUAL_VW_VIP_ID,
    DNX_FIELD_QUAL_VW_VIP_VALID,
    DNX_FIELD_QUAL_WEAK_TM_PROFILE,
    DNX_FIELD_QUAL_WEAK_TM_VALID,
    DNX_FIELD_QUAL_WEXEM_KEY_0,
    DNX_FIELD_QUAL_WEXEM_KEY_1,
    DNX_FIELD_QUAL_WEXEM_KEY_2,
    DNX_FIELD_QUAL_WEXEM_KEY_3,
    DNX_FIELD_QUAL_WEXEM_KEY_4,
    DNX_FIELD_QUAL_WEXEM_KEY_J,
    DNX_FIELD_QUAL_WEXEM_LEARN_APPDB,
    DNX_FIELD_QUAL_WEXEM_LEARN_NEEDED,
    DNX_FIELD_QUAL_WEXEM_PAYLOAD_1,
    DNX_FIELD_QUAL_WEXEM_PAYLOAD_2,
    DNX_FIELD_QUAL_WEXEM_RESULT,
    DNX_FIELD_QUAL_FER_STATISTICS_OBJ_ID_0,
    DNX_FIELD_QUAL_FER_STATISTICS_OBJ_ID_1,
    DNX_FIELD_QUAL_FER_STATISTICS_OBJ_ID_2,
    DNX_FIELD_QUAL_L3SRCBIND_HIT,
    DNX_FIELD_QUAL_SRV6_GSID_NEXT_SI,
    DNX_FIELD_QUAL_SRV6_GSID_NEXT_GSID,
    DNX_FIELD_QUAL_NOF
} dnx_field_metadata_qual_e;

typedef enum
{
    /*
     * Invalid action must be 0 - since if bcm to dnx mapping is not set, 0 is the default value
     */
    DNX_FIELD_ACTION_ID_INVALID = 0,
    DNX_FIELD_ACTION_FIRST,
    DNX_FIELD_ACTION_ACL_CONTEXT = DNX_FIELD_ACTION_FIRST,
    DNX_FIELD_ACTION_ADMT_PROFILE,
    DNX_FIELD_ACTION_BIER_STR_OFFSET,
    DNX_FIELD_ACTION_BIER_STR_SIZE,
    DNX_FIELD_ACTION_BYTES_TO_REMOVE,
    DNX_FIELD_ACTION_CONGESTION_INFO,
    DNX_FIELD_ACTION_COS_PROFILE,
    DNX_FIELD_ACTION_CUD_OUTLIF_OR_MCDB_PTR,
    DNX_FIELD_ACTION_DISCARD,
    DNX_FIELD_ACTION_DP,
    DNX_FIELD_ACTION_DP_METER_COMMAND,
    DNX_FIELD_ACTION_DST_DATA,
    DNX_FIELD_ACTION_DUAL_QUEUE,
    DNX_FIELD_ACTION_EEI,
    DNX_FIELD_ACTION_EGRESS_LEARN_ENABLE,
    DNX_FIELD_ACTION_EGRESS_PARSING_INDEX,
    DNX_FIELD_ACTION_ELEPHANT_PAYLOAD,
    DNX_FIELD_ACTION_END_OF_PACKET_EDITING,
    DNX_FIELD_ACTION_EVENTOR,
    DNX_FIELD_ACTION_EXT_STATISTICS_0,
    DNX_FIELD_ACTION_EXT_STATISTICS_1,
    DNX_FIELD_ACTION_EXT_STATISTICS_2,
    DNX_FIELD_ACTION_EXT_STATISTICS_3,
    DNX_FIELD_ACTION_TRAP,
    DNX_FIELD_ACTION_FTMH_PP_DSP,
    DNX_FIELD_ACTION_FWD_CONTEXT,
    DNX_FIELD_ACTION_FWD_DOMAIN,
    DNX_FIELD_ACTION_FWD_DOMAIN_WITH_PROFILE,
    DNX_FIELD_ACTION_FWD_LAYER_ADDITIONAL_INFO,
    DNX_FIELD_ACTION_FWD_LAYER_INDEX,
    DNX_FIELD_ACTION_FWD_STRENGTH,
    DNX_FIELD_ACTION_GLOB_IN_LIF_0,
    DNX_FIELD_ACTION_GLOB_IN_LIF_1,
    DNX_FIELD_ACTION_GLOB_OUT_LIF_0,
    DNX_FIELD_ACTION_GLOB_OUT_LIF_1,
    DNX_FIELD_ACTION_GLOB_OUT_LIF_2,
    DNX_FIELD_ACTION_GLOB_OUT_LIF_3,
    DNX_FIELD_ACTION_IEEE1588_DATA,
    DNX_FIELD_ACTION_IN_LIF_PROFILE_0,
    DNX_FIELD_ACTION_IN_LIF_PROFILE_1,
    DNX_FIELD_ACTION_IN_TTL,
    DNX_FIELD_ACTION_INGRESS_LEARN_ENABLE,
    DNX_FIELD_ACTION_INGRESS_TIME_STAMP,
    DNX_FIELD_ACTION_INGRESS_TIME_STAMP_OVERRIDE,
    DNX_FIELD_ACTION_INT_DATA,
    DNX_FIELD_ACTION_IS_APPLET,
    DNX_FIELD_ACTION_ITPP_DELTA_AND_VALID,
    DNX_FIELD_ACTION_LAG_LB_KEY,
    DNX_FIELD_ACTION_LATENCY_FLOW,
    DNX_FIELD_ACTION_LEARN_INFO_0,
    DNX_FIELD_ACTION_LEARN_INFO_1,
    DNX_FIELD_ACTION_LEARN_INFO_2,
    DNX_FIELD_ACTION_LEARN_INFO_3,
    DNX_FIELD_ACTION_LEARN_INFO_4,
    DNX_FIELD_ACTION_LEARN_OR_TRANSPLANT,
    DNX_FIELD_ACTION_MIRROR_DATA,
    DNX_FIELD_ACTION_MIRROR_PROFILE,
    DNX_FIELD_ACTION_NWK_HEADER_APPEND_SIZE,
    DNX_FIELD_ACTION_NWK_LB_KEY,
    DNX_FIELD_ACTION_NWK_QOS,
    DNX_FIELD_ACTION_OAM_DATA,
    DNX_FIELD_ACTION_OUT_LIF_PUSH,
    DNX_FIELD_ACTION_PACKET_IS_BIER,
    DNX_FIELD_ACTION_PACKET_IS_COMPATIBLE_MC,
    DNX_FIELD_ACTION_PARSING_START_OFFSET,
    DNX_FIELD_ACTION_PARSING_START_TYPE,
    DNX_FIELD_ACTION_PEM_GENERAL_DATA_CBTS,
    DNX_FIELD_ACTION_GENERAL_DATA0,
    DNX_FIELD_ACTION_GENERAL_DATA1,
    DNX_FIELD_ACTION_GENERAL_DATA2,
    DNX_FIELD_ACTION_GENERAL_DATA3,
    DNX_FIELD_ACTION_GENERAL_DATA4_CONTAINER0_0_31,
    DNX_FIELD_ACTION_PMF_COUNTER_0_PROFILE,
    DNX_FIELD_ACTION_PMF_COUNTER_0_PTR,
    DNX_FIELD_ACTION_PMF_COUNTER_1_PROFILE,
    DNX_FIELD_ACTION_PMF_COUNTER_1_PTR,
    DNX_FIELD_ACTION_PMF_FWD_OVERRIDE_ENABLE,
    DNX_FIELD_ACTION_PMF_FWD_STRENGTH,
    DNX_FIELD_ACTION_PMF_OAM_ID,
    DNX_FIELD_ACTION_PMF_PROFILE,
    DNX_FIELD_ACTION_PMF_SNOOP_OVERRIDE_ENABLE,
    DNX_FIELD_ACTION_PMF_SNOOP_STRENGTH,
    DNX_FIELD_ACTION_PP_DSP,
    DNX_FIELD_ACTION_PP_PORT,
    DNX_FIELD_ACTION_PPH_RESERVED,
    DNX_FIELD_ACTION_PPH_TYPE,
    DNX_FIELD_ACTION_PTC,
    DNX_FIELD_ACTION_PUSH_OUT_LIF,
    DNX_FIELD_ACTION_RPF_DST,
    DNX_FIELD_ACTION_RPF_DST_VALID,
    DNX_FIELD_ACTION_RPF_OUT_LIF,
    DNX_FIELD_ACTION_SLB_FOUND,
    DNX_FIELD_ACTION_SLB_KEY0,
    DNX_FIELD_ACTION_SLB_KEY1,
    DNX_FIELD_ACTION_SLB_KEY2,
    DNX_FIELD_ACTION_SLB_PAYLOAD0,
    DNX_FIELD_ACTION_SLB_PAYLOAD1,
    DNX_FIELD_ACTION_SNOOP,
    DNX_FIELD_ACTION_SNOOP_STRENGTH,
    DNX_FIELD_ACTION_SRC_SYS_PORT,
    DNX_FIELD_ACTION_ST_VSQ_PTR,
    DNX_FIELD_ACTION_STACKING_ROUTE_HISTORY_BITMAP,
    DNX_FIELD_ACTION_STAT_OBJ_LM_READ_INDEX,
    DNX_FIELD_ACTION_STATE_ADDRESS_DATA,
    DNX_FIELD_ACTION_STATE_DATA,
    DNX_FIELD_ACTION_STATISTICAL_SAMPLING,
    DNX_FIELD_ACTION_STATISTICS_ATR_0,
    DNX_FIELD_ACTION_STATISTICS_ATR_1,
    DNX_FIELD_ACTION_STATISTICS_ATR_2,
    DNX_FIELD_ACTION_STATISTICS_ATR_3,
    DNX_FIELD_ACTION_STATISTICS_ATR_4,
    DNX_FIELD_ACTION_STATISTICS_ATR_5,
    DNX_FIELD_ACTION_STATISTICS_ATR_6,
    DNX_FIELD_ACTION_STATISTICS_ATR_7,
    DNX_FIELD_ACTION_STATISTICS_ATR_8,
    DNX_FIELD_ACTION_STATISTICS_ATR_9,
    DNX_FIELD_ACTION_STATISTICS_ATR_10,
    DNX_FIELD_ACTION_STATISTICS_ATR_11,
    DNX_FIELD_ACTION_STATISTICS_ID_0,
    DNX_FIELD_ACTION_STATISTICS_ID_1,
    DNX_FIELD_ACTION_STATISTICS_ID_2,
    DNX_FIELD_ACTION_STATISTICS_ID_3,
    DNX_FIELD_ACTION_STATISTICS_ID_4,
    DNX_FIELD_ACTION_STATISTICS_ID_5,
    DNX_FIELD_ACTION_STATISTICS_ID_6,
    DNX_FIELD_ACTION_STATISTICS_ID_7,
    DNX_FIELD_ACTION_STATISTICS_ID_8,
    DNX_FIELD_ACTION_STATISTICS_ID_9,
    DNX_FIELD_ACTION_STATISTICS_ID_10,
    DNX_FIELD_ACTION_STATISTICS_ID_11,
    DNX_FIELD_ACTION_STATISTICS_META_DATA,
    DNX_FIELD_ACTION_STATISTICS_OBJECT_10,
    DNX_FIELD_ACTION_SYSTEM_HEADER_PROFILE_INDEX,
    DNX_FIELD_ACTION_SYSTEM_HEADER_SIZE_ADJUST,
    DNX_FIELD_ACTION_TC,
    DNX_FIELD_ACTION_TC_MAP_PROFILE,
    DNX_FIELD_ACTION_TM_PROFILE,
    DNX_FIELD_ACTION_TUNNEL_PRIORITY,
    DNX_FIELD_ACTION_TRACE_PACKET_ACT,
    DNX_FIELD_ACTION_USER_HEADER_1,
    DNX_FIELD_ACTION_USER_HEADER_1_EXT,
    DNX_FIELD_ACTION_USER_HEADER_1_TYPE,
    DNX_FIELD_ACTION_USER_HEADER_2,
    DNX_FIELD_ACTION_USER_HEADER_2_EXT,
    DNX_FIELD_ACTION_USER_HEADER_2_TYPE,
    DNX_FIELD_ACTION_USER_HEADER_3,
    DNX_FIELD_ACTION_USER_HEADER_3_TYPE,
    DNX_FIELD_ACTION_USER_HEADER_4,
    DNX_FIELD_ACTION_USER_HEADER_4_TYPE,
    DNX_FIELD_ACTION_USER_HEADERS_TYPE,
    DNX_FIELD_ACTION_VISIBILITY,
    DNX_FIELD_ACTION_VISIBILITY_CLEAR,
    DNX_FIELD_ACTION_VLAN_EDIT_CMD_INDEX,
    DNX_FIELD_ACTION_VLAN_EDIT_PCP_DEI_1,
    DNX_FIELD_ACTION_VLAN_EDIT_PCP_DEI_2,
    DNX_FIELD_ACTION_VLAN_EDIT_VID_1,
    DNX_FIELD_ACTION_VLAN_EDIT_VID_2,
    DNX_FIELD_ACTION_TM_ACTION_TYPE,
    DNX_FIELD_ACTION_CNI,
    DNX_FIELD_ACTION_ECN_ENABLE,
    DNX_FIELD_ACTION_PPH_VALUE1,
    DNX_FIELD_ACTION_PPH_VALUE2,
    DNX_FIELD_ACTION_FHEI_EXT31TO00,
    DNX_FIELD_ACTION_FHEI_EXT63TO32,
    DNX_FIELD_ACTION_PPH_TTL,
    DNX_FIELD_ACTION_PPH_IN_LIF_PROFILE,
    DNX_FIELD_ACTION_OUT_LIF0_CUD_OUT_LIF0VALID,
    DNX_FIELD_ACTION_OUT_LIF1_CUD_OUT_LIF1VALID,
    DNX_FIELD_ACTION_OUT_LIF2_CUD_OUT_LIF2VALID,
    DNX_FIELD_ACTION_OUT_LIF3_CUD_OUT_LIF3VALID,
    DNX_FIELD_ACTION_PPH_APPLICATION_SPECIFIC_EXT_31TO00,
    DNX_FIELD_ACTION_PPH_APPLICATION_SPECIFIC_EXT_47TO32,
    DNX_FIELD_ACTION_SNIFF_PROFILE,
    DNX_FIELD_ACTION_ACE_CONTEXT_VALUE,
    DNX_FIELD_ACTION_ACE_STAMP_VALUE,
    DNX_FIELD_ACTION_ACE_STAT_METER_OBJ_CMD_ID,
    DNX_FIELD_ACTION_ACE_STAT_OBJ_CMD_ID_VALID,
    DNX_FIELD_ACTION_PPH_IN_LIF,
    DNX_FIELD_ACTION_PRT_QUALIFIER,
    DNX_FIELD_ACTION_LEARN_INFO_KEY_0,
    DNX_FIELD_ACTION_LEARN_INFO_KEY_1,
    DNX_FIELD_ACTION_LEARN_INFO_KEY_2_APP_DB_INDEX,
    DNX_FIELD_ACTION_LEARN_INFO_PAYLOAD_0,
    DNX_FIELD_ACTION_LEARN_INFO_PAYLOAD_1,
    DNX_FIELD_ACTION_LEARN_INFO_FORMAT_INDEX,
    DNX_FIELD_ACTION_EBTR_EOP_DELTA,
    DNX_FIELD_ACTION_EBTA_EOP_DELTA,
    DNX_FIELD_ACTION_EBTA_SOP_DELTA,
    DNX_FIELD_ACTION_EBTR_SOP_DELTA,
    DNX_FIELD_ACTION_WEXEM_PAYLOAD_0_31,
    DNX_FIELD_ACTION_WEXEM_PAYLOAD_32_59,
    DNX_FIELD_ACTION_WEXEM_KEY_0_31,
    DNX_FIELD_ACTION_WEXEM_KEY_32_63,
    DNX_FIELD_ACTION_WEXEM_KEY_64_95,
    DNX_FIELD_ACTION_WEXEM_KEY_96_127,
    DNX_FIELD_ACTION_WEXEM_KEY_128_159,
    DNX_FIELD_ACTION_WEXEM_LEARN_NEEDED,
    DNX_FIELD_ACTION_WEXEM_LEARN_APP_DB_ID,
    DNX_FIELD_ACTION_OAM_TS_DATA,
    DNX_FIELD_ACTION_OUT_PP_PORT,
    DNX_FIELD_ACTION_OUT_TM_PORT,
    DNX_FIELD_ACTION_DSPA,
    DNX_FIELD_ACTION_EGR_TRAP_OVERWRITE,
    DNX_FIELD_ACTION_EGR_SNOOP_OVERWRITE,
    DNX_FIELD_ACTION_ACE_STAT0_COUNTER,
    DNX_FIELD_ACTION_ACE_STAT1_COUNTER,
    DNX_FIELD_ACTION_FTMH_AQM_PROFILE,
    DNX_FIELD_ACTION_FHEI_EXT_31_00,
    DNX_FIELD_ACTION_FHEI_EXT_63_32,
    DNX_FIELD_ACTION_FTMH_ASE_31_00,
    DNX_FIELD_ACTION_FTMH_ASE_47_32,
    DNX_FIELD_ACTION_ACE_STAT_METER,
    DNX_FIELD_ACTION_ACE_STAT_LM_ENTRY,
    DNX_FIELD_ACTION_ACE_STAT_STATE_ENTRY,
    DNX_FIELD_ACTION_ACE_STAT_STATE_SOIDA,
    DNX_FIELD_ACTION_INEX_QOS,
    DNX_FIELD_ACTION_NWK_QOS_PLUS1,
    DNX_FIELD_ACTION_PORT_RATE_ADDRESS,
    DNX_FIELD_ACTION_GLOBAL_VOQ_AGG_ADDRESS,
    DNX_FIELD_ACTION_FWD_PLUS1_REMARK_PROFILE,
    DNX_FIELD_ACTION_FAI_DO_NOT_DECREMENT_TTL,
    DNX_FIELD_ACTION_TYPE_FWD_REMARK_OR_KEEP,
    DNX_FIELD_ACTION_EES_ENTRY_TYPE,
    DNX_FIELD_ACTION_EES_ENTRY_119_90,
    DNX_FIELD_ACTION_EES_ENTRY_89_60,
    DNX_FIELD_ACTION_EES_ENTRY_59_30,
    DNX_FIELD_ACTION_EES_ENTRY_29_0,
    DNX_FIELD_ACTION_EES_ENTRY_PUSH_PROFILE,
    DNX_FIELD_ACTION_BTC_OFFSET_IN_BYTES_FROM_SOP,
    DNX_FIELD_ACTION_BTK_OFFSET_IN_BYTES_FROM_SOP,
    DNX_FIELD_ACTION_NWK_HEADER_TRUNCATE_SIZE,
    DNX_FIELD_ACTION_FORWARD_CODE,
    DNX_FIELD_ACTION_ECL_VALID,
    DNX_FIELD_ACTION_OUTLIF_TO_STAMP,
    DNX_FIELD_ACTION_INVALIDATE_NEXT,
    DNX_FIELD_ACTION_NOF
} dnx_field_action_e;

#define BCM_FIELD_HEADER_TYPE_STRINGS   \
{                                       \
    "Ethernet",                         \
    "Inner Ethernet",                   \
    "VALN",                             \
    "MPLS",                             \
    "IPv4",                             \
    "Inner IPv4",                       \
    "IPv6",                             \
    "Inner IPv6",                       \
    "UDP",                              \
    "Invalid"                           \
}

typedef enum
{
    DNX_FIELD_HEADER_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_HEADER_QUAL_FIRST = 1,
    /*
     * Ethernet Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_MAC_DST = DNX_FIELD_HEADER_QUAL_FIRST,
    DNX_FIELD_HEADER_QUAL_MAC_SRC,
    DNX_FIELD_HEADER_QUAL_ETHERTYPE,
    /*
     * VLAN Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_VLAN_TPID,
    DNX_FIELD_HEADER_QUAL_VLAN_ID,
    DNX_FIELD_HEADER_QUAL_VLAN_PRI,
    DNX_FIELD_HEADER_QUAL_VLAN_CFI,
    DNX_FIELD_HEADER_QUAL_VLAN_PRI_CFI,
    DNX_FIELD_HEADER_QUAL_VLAN_TCI,
    /*
     * MPLS Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_MPLS_LABEL,   /* Shim Layer header */
    DNX_FIELD_HEADER_QUAL_MPLS_LABEL_ID,
    DNX_FIELD_HEADER_QUAL_MPLS_TC,
    DNX_FIELD_HEADER_QUAL_MPLS_BOS,
    DNX_FIELD_HEADER_QUAL_MPLS_TTL,
    /*
     * ARP Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_ARP_OPCODE,
    DNX_FIELD_HEADER_QUAL_ARP_SENDER_IP,
    DNX_FIELD_HEADER_QUAL_ARP_TARGET_IP,
    /*
     * IPv4 Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_IPV4_TOS,
    DNX_FIELD_HEADER_QUAL_IPV4_DSCP,
    DNX_FIELD_HEADER_QUAL_IPV4_ECN,
    DNX_FIELD_HEADER_QUAL_IPV4_FLAGS,
    DNX_FIELD_HEADER_QUAL_IPV4_TTL,
    DNX_FIELD_HEADER_QUAL_IPV4_PROTOCOL,
    DNX_FIELD_HEADER_QUAL_IPV4_SRC,
    DNX_FIELD_HEADER_QUAL_IPV4_DST,
    /*
     * IPv6 Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_IPV6_SIP,
    DNX_FIELD_HEADER_QUAL_IPV6_DIP,
    DNX_FIELD_HEADER_QUAL_IPV6_SIP_LOW,
    DNX_FIELD_HEADER_QUAL_IPV6_SIP_HIGH,
    DNX_FIELD_HEADER_QUAL_IPV6_DIP_LOW,
    DNX_FIELD_HEADER_QUAL_IPV6_DIP_HIGH,
    DNX_FIELD_HEADER_QUAL_IPV6_TC,
    DNX_FIELD_HEADER_QUAL_IPV6_FLOW_LABEL,
    DNX_FIELD_HEADER_QUAL_IPV6_NEXT_HEADER,
    DNX_FIELD_HEADER_QUAL_IPV6_HOP_LIMIT,
    DNX_FIELD_HEADER_QUAL_IPV6_1ST_EXTENSION_NEXT_HEADER,
    /*
     * TCP/UDP Common Fields
     */
    DNX_FIELD_HEADER_QUAL_L4_SRC_PORT,
    DNX_FIELD_HEADER_QUAL_L4_DST_PORT,
    /*
     * TCP Requested Fields
     */
    DNX_FIELD_HEADER_QUAL_TCP_CTL,
    /*
     * RCH Header Qualifiers
     */
    DNX_FIELD_HEADER_QUAL_RCH_TIME_STAMP,
    DNX_FIELD_HEADER_QUAL_RCH_FORWARDING_ADDITIONAL_INFO,
    DNX_FIELD_HEADER_QUAL_RCH_TYPE,
    DNX_FIELD_HEADER_QUAL_RCH_VISIBILITY,
    /*
     *  Number of types in dnx_field_header_qual_e
     */
    DNX_FIELD_HEADER_QUAL_NOF
} dnx_field_header_qual_e;

typedef enum
{
    DNX_FIELD_CS_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_CS_QUAL_FIRST,
    DNX_FIELD_CS_QUAL_CURRENT_ACL_CONTEXT_PROFILE = DNX_FIELD_CS_QUAL_FIRST,
    DNX_FIELD_CS_QUAL_ACL_CONTEXT_PROFILE,
    DNX_FIELD_CS_QUAL_APP_SPECIFIC_EXTENSION_LSB,
    DNX_FIELD_CS_QUAL_APP_SPECIFIC_EXTENSION_PRESENT,
    DNX_FIELD_CS_QUAL_BIER_BFR_EXTENSION_PRESENT,
    DNX_FIELD_CS_QUAL_CMP_OUTPUT_PAIR_1,
    DNX_FIELD_CS_QUAL_CMP_OUTPUT_PAIR_2,
    DNX_FIELD_CS_QUAL_AC_IN_LIF_WIDE_DATA,
    DNX_FIELD_CS_QUAL_COUNTER_PROFILE_MAP_0,
    DNX_FIELD_CS_QUAL_COUNTER_PROFILE_MAP_1,
    DNX_FIELD_CS_QUAL_COUNTER_PROFILE_MAP_2,
    DNX_FIELD_CS_QUAL_CPU_TRAP_CODE,
    DNX_FIELD_CS_QUAL_CS_DESTINATION,
    DNX_FIELD_CS_QUAL_DUMMY_EGW_STATUS,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_0,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_1,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_2,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_3,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_4,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_5,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_6,
    DNX_FIELD_CS_QUAL_ELK_FOUND_RESULT_7,
    DNX_FIELD_CS_QUAL_ALGO_LPM_RESULT_1,
    DNX_FIELD_CS_QUAL_ALGO_LPM_RESULT_2,
    DNX_FIELD_CS_QUAL_MEM_SOFT_ERROR,
    DNX_FIELD_CS_QUAL_OUT_OF_BOUND_BITMAP,
    DNX_FIELD_CS_QUAL_ELK_OPCODE,
    DNX_FIELD_CS_QUAL_ELK_RESULT_BITS_120_127,
    DNX_FIELD_CS_QUAL_FABRIC_OR_EGRESS_MC,
    DNX_FIELD_CS_QUAL_FHEI_EXTENSION_LSB,
    DNX_FIELD_CS_QUAL_FHEI_SIZE,
    DNX_FIELD_CS_QUAL_FLPA_PD_FWD_HIT,
    DNX_FIELD_CS_QUAL_FLPA_PD_RPF_HIT,
    DNX_FIELD_CS_QUAL_FWD_CONTEXT_PROFILE,
    DNX_FIELD_CS_QUAL_FWD_DOMAIN_PROFILE,
    DNX_FIELD_CS_QUAL_FWD_LAYER_INDEX,
    DNX_FIELD_CS_QUAL_FWD_LAYER_QUAL_0,
    DNX_FIELD_CS_QUAL_FWD_LAYER_QUAL_1,
    DNX_FIELD_CS_QUAL_FWD_LAYER_QUAL_2,
    DNX_FIELD_CS_QUAL_FWD_LAYER_QUAL_MINUS_1,
    DNX_FIELD_CS_QUAL_FWD_LAYER_QUALIFIER,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_0,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_1,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_2,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_3,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_4,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_5,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_6,
    DNX_FIELD_CS_QUAL_FWD_LAYER_TYPE_MINUS_1,
    DNX_FIELD_CS_QUAL_FWD_STRENGTH,
    DNX_FIELD_CS_QUAL_FWD2_CONTEXT_ID,
    DNX_FIELD_CS_QUAL_IN_LIF_PROFILE_0,
    DNX_FIELD_CS_QUAL_IN_LIF_PROFILE_MAP_0,
    DNX_FIELD_CS_QUAL_IN_LIF_PROFILE_MAP_1,
    DNX_FIELD_CS_QUAL_IN_PORT_CS_PROFILE,
    DNX_FIELD_CS_QUAL_INGRESS_TRAP_CODE,
    DNX_FIELD_CS_QUAL_IS_COMPATIBLE_MULTICAST,
    DNX_FIELD_CS_QUAL_LAST_LIF_CS_PROFILE,
    DNX_FIELD_CS_QUAL_LAYER_QUALIFIER_CURRENT_LAYER,
    DNX_FIELD_CS_QUAL_LAYER_QUALIFIER_NEXT_LAYER,
    DNX_FIELD_CS_QUAL_LAYER_QUALIFIER_PREVIOUS_LAYER,
    DNX_FIELD_CS_QUAL_LAYER_TYPE_CURRENT_LAYER,
    DNX_FIELD_CS_QUAL_LAYER_TYPE_NEXT_LAYER,
    DNX_FIELD_CS_QUAL_LAYER_TYPE_PREVIOUS_LAYER,
    DNX_FIELD_CS_QUAL_LEARN_EXTENSION_PRESENT,
    DNX_FIELD_CS_QUAL_LIF_EXTENSION_TYPE,
    DNX_FIELD_CS_QUAL_LIF_SERVICE_TYPE,
    DNX_FIELD_CS_QUAL_OAM_CS_PROFILE,
    DNX_FIELD_CS_QUAL_OUT_LIF_RANGE_0,
    DNX_FIELD_CS_QUAL_OUT_LIF_RANGE_1,
    DNX_FIELD_CS_QUAL_OUT_LIF_RANGE_2,
    DNX_FIELD_CS_QUAL_OUT_LIF_RANGE_3,
    DNX_FIELD_CS_QUAL_PP_PORT_PMF_CS_PROFILE,
    DNX_FIELD_CS_QUAL_PMF_OUT_LIF_PROFILE,
    DNX_FIELD_CS_QUAL_PMF_OUT_LIF_1_PROFILE,
    DNX_FIELD_CS_QUAL_PMF_OUT_LIF_2_PROFILE,
    DNX_FIELD_CS_QUAL_PMF_OUT_LIF_3_PROFILE,
    DNX_FIELD_CS_QUAL_PMF_OUTERMOST_OUT_LIF_PROFILE,
    DNX_FIELD_CS_QUAL_PMF_OUT_RIF_PROFILE,
    DNX_FIELD_CS_QUAL_PMF_TAG_STRUCTURE,
    DNX_FIELD_CS_QUAL_PMF1_DIRECT_PAYLOAD_MSB,
    DNX_FIELD_CS_QUAL_PMF1_EXEM_PAYLOAD_MSB,
    DNX_FIELD_CS_QUAL_PMF1_PROGRAM_SELECTION_PROFILE,
    DNX_FIELD_CS_QUAL_PMF1_TCAM_ACTION_0_MSB,
    DNX_FIELD_CS_QUAL_PMF1_TCAM_ACTION_1_MSB,
    DNX_FIELD_CS_QUAL_PMF1_TCAM_ACTION_2_MSB,
    DNX_FIELD_CS_QUAL_PMF1_TCAM_ACTION_3_MSB,
    DNX_FIELD_CS_QUAL_PORT_TERMINATION_PTC_PROFILE,
    DNX_FIELD_CS_QUAL_PP_PORT_PROFILE,
    DNX_FIELD_CS_QUAL_PPH_PRESENT,
    DNX_FIELD_CS_QUAL_PPH_VALUE_1,
    DNX_FIELD_CS_QUAL_PPH_VALUE_2_LSB,
    DNX_FIELD_CS_QUAL_PREVIOUS_LIF_CS_PROFILE,
    DNX_FIELD_CS_QUAL_PRT_QUALIFIER_RAW,
    DNX_FIELD_CS_QUAL_PTC_CS_PROFILE,
    DNX_FIELD_CS_QUAL_RESERVED_0,
    DNX_FIELD_CS_QUAL_RESERVED_OUT_LIF_PROFILE,
    DNX_FIELD_CS_QUAL_RPF_DST_IS_ECMP,
    DNX_FIELD_CS_QUAL_RPF_ECMP_MODE,
    DNX_FIELD_CS_QUAL_RPF_MC_MODE,
    DNX_FIELD_CS_QUAL_SAVED_CONTEXT_PROFILE,
    DNX_FIELD_CS_QUAL_STATE_TABLE_DATA_MSB_PAD_FIRST,
    DNX_FIELD_CS_QUAL_STATE_TABLE_DATA_MSB_PAD_SECOND,
    DNX_FIELD_CS_QUAL_STATE_TABLE_DATA_READ,
    DNX_FIELD_CS_QUAL_STATE_TABLE_DATA_WRITE,
    DNX_FIELD_CS_QUAL_STATISTICS_MAPPING_REQUIRED,
    DNX_FIELD_CS_QUAL_TM_DESTINATION_EXTENSION_PRESENT,
    DNX_FIELD_CS_QUAL_TRACE_PACKET,
    DNX_FIELD_CS_QUAL_TRAP_CODE_PROFILE,
    DNX_FIELD_CS_QUAL_TSH_EXTENISON_PRESENT,
    DNX_FIELD_CS_QUAL_UDH_BASE_0,
    DNX_FIELD_CS_QUAL_UDH_BASE_1,
    DNX_FIELD_CS_QUAL_UDH_BASE_2,
    DNX_FIELD_CS_QUAL_UDH_BASE_3,
    DNX_FIELD_CS_QUAL_VT2_PEM_CS_VAR_PART_0,
    DNX_FIELD_CS_QUAL_VT2_PEM_CS_VAR_PART_1,
    DNX_FIELD_CS_QUAL_WEAK_TM_VALID,
    DNX_FIELD_CS_QUAL_LAYER_QUALIFIER_PLUS_2_LAYER,
    DNX_FIELD_CS_QUAL_LAYER_TYPE_PLUS_2_LAYER,
    DNX_FIELD_CS_QUAL_ACL_IN_LIF_PROFILE_0,
    DNX_FIELD_CS_QUAL_ACL_IN_LIF_PROFILE_1,
    DNX_FIELD_CS_QUAL_MIRROR_CODE,
    DNX_FIELD_CS_QUAL_OAM_LIF_VALID,
    DNX_FIELD_CS_QUAL_FWD1_CONTEXT_ID,
    DNX_FIELD_CS_QUAL_ACL_PEM_CS_VAR,
    DNX_FIELD_CS_QUAL_FWD_OPAQUE_FIELD_CS,
    DNX_FIELD_CS_QUAL_RPF_OPAQUE_FIELD_CS,
    DNX_FIELD_CS_QUAL_SONST_8_MSB,
    DNX_FIELD_CS_QUAL_SOCST_8_MSB,
    DNX_FIELD_CS_QUAL_FLOW_ID_PRESENT,
    DNX_FIELD_CS_QUAL_OUTLIF_0_PROFILE_PMF_CS_VAR,
    DNX_FIELD_CS_QUAL_OUTLIF_1_PROFILE_PMF_CS_VAR,
    DNX_FIELD_CS_QUAL_OUTLIF_2_PROFILE_PMF_CS_VAR,
    DNX_FIELD_CS_QUAL_OUTLIF_3_PROFILE_PMF_CS_VAR,
    DNX_FIELD_CS_QUAL_OUTERMOST_OUTLIF_PROFILE_PMF_CS_VAR,
    DNX_FIELD_CS_QUAL_FWD_LAYER_VISIBLE,
    DNX_FIELD_CS_QUAL_FWD_P1_LAYER_VISIBLE,
    DNX_FIELD_CS_QUAL_FWD_P2_LAYER_VISIBLE,
    DNX_FIELD_CS_QUAL_FWD_ACTION_PROFILE,
    DNX_FIELD_CS_QUAL_INLIF_0_PROFILE_PMF_CS_VAR,
    DNX_FIELD_CS_QUAL_UDH_BASE_PMF_CS_VAR,
    DNX_FIELD_CS_QUAL_OUT_PP_PORT_LFSR1_IN_RANGE,
    DNX_FIELD_CS_QUAL_OUTLIF_0_PROFILE_LFSR1_IN_RANGE,
    DNX_FIELD_CS_QUAL_TM_PORT_PMF_CS_PROFILE,
    DNX_FIELD_CS_QUAL_DISCARD,
    DNX_FIELD_CS_QUAL_FWD_CODE,
    DNX_FIELD_CS_QUAL_PEM_SCRATCH_PAD,
    DNX_FIELD_CS_QUAL_NOF,
} dnx_field_cs_qual_e;

typedef enum
{
    DNX_FIELD_LR_QUAL_INVALID = DNX_FIELD_QUAL_ID_INVALID,
    DNX_FIELD_LR_QUAL_FIRST = 1,
    /*
     * Basic Layer Header Qualifiers
     */
    DNX_FIELD_LR_QUAL_OFFSET = DNX_FIELD_LR_QUAL_FIRST,
    DNX_FIELD_LR_QUAL_PROTOCOL,
    DNX_FIELD_LR_QUAL_QUALIFIER,
    /*
     * Specific fields in relevant Layer Record Qualifiers
     */
    DNX_FIELD_LR_QUAL_ETH_IS_DA_MC,
    DNX_FIELD_LR_QUAL_ETH_IS_DA_BC,
    DNX_FIELD_LR_QUAL_ETH_1ST_TPID_EXIST,
    DNX_FIELD_LR_QUAL_ETH_1ST_TPID_INDEX,
    DNX_FIELD_LR_QUAL_ETH_2ND_TPID_EXIST,
    DNX_FIELD_LR_QUAL_ETH_2ND_TPID_INDEX,
    DNX_FIELD_LR_QUAL_ETH_3RD_TPID_EXIST,
    DNX_FIELD_LR_QUAL_ETH_3RD_TPID_INDEX,
    DNX_FIELD_LR_QUAL_ETH_FRAME_TYPE,
    DNX_FIELD_LR_QUAL_IPV4_IS_MC,
    DNX_FIELD_LR_QUAL_IPV4_HAS_OPTION,
    DNX_FIELD_LR_QUAL_IPV4_IS_FRAGMENTED,
    DNX_FIELD_LR_QUAL_IPV4_IS_1ST_FRAGMENT,
    DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER_EXIST,
    DNX_FIELD_LR_QUAL_IPV4_1ST_ADD_HEADER,
    DNX_FIELD_LR_QUAL_IPV4_2ND_ADD_HEADER_EXISTS,
    DNX_FIELD_LR_QUAL_IPV4_TUNNEL_TYPE,
    DNX_FIELD_LR_QUAL_IPV4_TUNNEL_TYPE_RAW,
    DNX_FIELD_LR_QUAL_IPV4_FRAGMENTED_NON_FIRST,
    DNX_FIELD_LR_QUAL_IPV4_FIRST_FRAG_OR_NON_FRAG,
    DNX_FIELD_LR_QUAL_IPV6_IS_MC,
    DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER_EXIST,
    DNX_FIELD_LR_QUAL_IPV6_1ST_ADD_HEADER,
    DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER_EXISTS,
    DNX_FIELD_LR_QUAL_IPV6_2ND_ADD_HEADER,
    DNX_FIELD_LR_QUAL_IPV6_3RD_ADD_HEADER_EXISTS,
    DNX_FIELD_LR_QUAL_IPV6_FRAGMENTED_NON_FIRST,
    DNX_FIELD_LR_QUAL_SRV6_EP_SEGMENT_LEFT_MINUS_ONE,
    DNX_FIELD_LR_QUAL_MPLS_NOF_LABELS,
    DNX_FIELD_LR_QUAL_BIER_BITSTRINGLENGTH,
    DNX_FIELD_LR_QUAL_FCOE_IS_FIP,
    DNX_FIELD_LR_QUAL_FCOE_IS_ENCAP,
    DNX_FIELD_LR_QUAL_FCOE_VFT_EXIST,
    DNX_FIELD_LR_QUAL_ITMH_PPH_TYPE,
/*
     *  Number of types in dnx_field_layer_record_qual_e
     */
    DNX_FIELD_LR_QUAL_NOF
} dnx_field_layer_record_qual_e;

typedef enum
{
    DNX_FIELD_SW_QUAL_INVALID = 0,
    DNX_FIELD_SW_QUAL_FIRST = 1,
    DNX_FIELD_SW_QUAL_ALL_ZERO = DNX_FIELD_SW_QUAL_FIRST,
    /*
     *  Number of types in dnx_field_sw_qual_e
     */
    DNX_FIELD_SW_QUAL_NOF
} dnx_field_sw_qual_e;

typedef enum
{
    DNX_FIELD_SW_ACTION_INVALID = 0,
    DNX_FIELD_SW_ACTION_FIRST = 1,
    DNX_FIELD_SW_ACTION_VOID = DNX_FIELD_SW_ACTION_FIRST,
    /*
     *  Number of types in dnx_field_sw_action_e
     */
    DNX_FIELD_SW_ACTION_NOF
} dnx_field_sw_action_e;

/**
 * Enum for FFC types, one of the four HW options for each FFC. not every FFC type is available to all FFCs.
 */
typedef enum
{
    DNX_FIELD_FFC_TYPE_INVALID = -1,
    /**
     * Takes information from the header according to a layer relative to the forwarding layer.
     */
    DNX_FIELD_FFC_RELATIVE_HEADER = 0,
    /**
     * Takes information from the header according to a given layer (disregarding the forwarding layer)
     */
    DNX_FIELD_FFC_ABSOLUTE_HEADER = 1,
    /**
     * Takes information from a given offset anywhere in the PBUS. Used to take data from the metadata or
     * layer records, when we don't take which layer is the forwarding layer into account.
     */
    DNX_FIELD_FFC_LITERALLY = 2,
    /**
     * Takes information from the layer record, which is information given by the parser about different layers in the
     * header, from a layer relative to the forwarding layer.
     */
    DNX_FIELD_FFC_LAYER_RECORD = 3,
    /**
     * Number of enum valid values for FFC types */
    DNX_FIELD_FFC_NOF
} dnx_field_ffc_type_e;

#define DNX_FIELD_FFC_TYPE_VERIFY(type)                                                 \
    if((type < 0) || (type >= DNX_FIELD_FFC_NOF))                                       \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "FFC type:%d is out of range\n", type);              \
    }

typedef struct
{
    dbal_fields_e field_id;
    uint32 value;
} dnx_field_dbal_pair_t;

/**
 * \brief - Structure provided to facilitate context parameter setting
 */
typedef struct
{
    dbal_tables_e table_id;
    dnx_field_dbal_pair_t key_dbal_pair[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
    dnx_field_dbal_pair_t res_dbal_pair[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
} dnx_field_dbal_entry_t;

/**
 * \brief - Structure provided to facilitate field range setting
 */
typedef struct
{
    dbal_tables_e table_id;
    dbal_fields_e range_id_dbal_field;
    dbal_fields_e range_min_dbal_field;
    dbal_fields_e range_max_dbal_field;
    uint8 id_not_bitmap;
} dnx_field_map_range_type_info_t;

struct dnx_field_context_param_e;
/**
 * \brief Typedef for context param conversion routine
 * \param [in] unit unit id
 * \param [in] bcm_data pointer to bcm param data, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 * \param [in] dnx_data pointer to dnx param data, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 * \return
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 * \remark automatically frees the list
 */
typedef shr_error_e(
    *context_param_conversion_cb) (
    int unit,
    dnx_field_stage_e stage,
    dnx_field_context_t field_context_id,
    uint32 param_value,
    const struct dnx_field_context_param_e * context_param,
    dnx_field_dbal_entry_t * field_dbal_entry);

/**
 * \brief - Static mapping for context param set
 */
typedef struct dnx_field_context_param_e
{
    dbal_tables_e table_id;
    dbal_fields_e key_field_id[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
    dbal_fields_e res_field_id[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_DBAL_PAIRS];
    context_param_conversion_cb conversion_cb;
} dnx_field_context_param_t;

/**
 * \brief - Static mapping for range set
 */
typedef struct dnx_field_range_map_e
{
    /** The name of the range type.*/
    char *name;
    /** The DBAL table for setting the range.*/
    dbal_tables_e table_id;
    /** The DBAL field of the range ID.*/
    dbal_fields_e range_id_dbal_field;
    /** The DBAL field of the minimum value of the range.*/
    dbal_fields_e range_min_dbal_field;
    /** The DBAL field of the maximum value of the range.*/
    dbal_fields_e range_max_dbal_field;
    /** Indicates if the HW provides the first ID that was hit, or a bitmap of the range IDs and whether they were hit.*/
    uint8 id_not_bitmap;
} dnx_field_range_map_t;

/**
 * \brief Typedef for qualifier/action value conversion routine
 * \par DIRECT INPUT:
 *     \param [in] unit unit id
 *     \param [in] flags
 *           First flag is marking bare metal support
 *     \param [in] core - Identifier of core.
 *     \param [in] bcm_data pointer to bcm qualifier/action value, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 *     \param [in] dnx_data pointer to dnx qualifier/action value, which is BCM_FIELD_QUAL_WIDTH_IN_WORDS long
 * \par DIRECT OUTPUT:
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 * \remark automatically frees the list
 */
typedef shr_error_e(
    *field_data_conversion_cb) (
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
 * \brief Typedef for CS qualifier type conversion routine from BCM to DNX.
 * \par DIRECT INPUT:
 *     \param [in] unit           unit id
 *     \param [in] cs_qual_index  The index given by the user for the CS qualifier.
 *     \param [in] context_id     The context ID that uses the qualifier.
 *     \param [in] bcm_qual       The BCM qualifier.
 *     \param [out] cs_dnx_qual_p The DNX qualifier.
 * \par DIRECT OUTPUT:
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 */
typedef shr_error_e(
    *cs_qual_type_bcm_to_dnx_conversion_cb) (
    int unit,
    uint32 cs_qual_index,
    dnx_field_context_t context_id,
    bcm_field_qualify_t bcm_qual,
    dnx_field_cs_qual_e * cs_dnx_qual_p);

/**
 * \brief Typedef for CS qualifier type conversion routine from DNX to BCM.
 * \par DIRECT INPUT:
 *     \param [in] unit             unit id
 *     \param [in] context_id       The context ID that uses the qualifier.
 *     \param [in] cs_dnx_qual      The DNX qualifier.
 *     \param [out] bcm_qual_p      The BCM qualifier.
 *     \param [out] cs_qual_index_p The index given by the user for the CS qualifier.
 * \par DIRECT OUTPUT:
 *     \retval _SHR_E_NONE for success
 *     \retval _SHR_E_PARAM problem with input parameters, usage should be printed
 *     \retval other errors for other failure type
 */
typedef shr_error_e(
    *cs_qual_type_dnx_to_bcm_conversion_cb) (
    int unit,
    dnx_field_context_t context_id,
    dnx_field_cs_qual_e cs_dnx_qual,
    bcm_field_qualify_t * bcm_qual_p,
    uint32 *cs_qual_index_p);

/**
 * \brief Structure used to map bcm qualifier to context selection field ID
 *        map may be regular - 1 bcm qual to 1 dnx quals
 *        or indexed - 1  qualifier to array of dnx qualifier fields according to index, which is provided along bcm qual
 */
typedef struct
{
    /**
     * Number of dbal_fields per bcm qualifier
     * 0 - Invalid - bcm qualifier not supported in context selection
     * 1 - means regular
     *
     */
    int nof;
    /**
     * In case of (nof == 1) and (qual_type_conversion_cb == NULL) qualifier is used
     */
    dnx_field_cs_qual_e dnx_qual;
    /**
     * First flag is marking basic bcm qualifier - the one that will be chosen for dnx to bcm mapping
     */
    uint32 flags;
    /**
     * Pointer to array of dnx_quals for specific bcm qual
     */
    dnx_field_cs_qual_e *dnx_qual_array;
    /**
     * Increase index of qual_arg for certain qualifiers (currently only ForwardingType)
     */
    int index_shift;
    /*
     * Routine that will translate the bcm qualifier to a dnx qualifier for cases when using
     * field_id_array is not enough.
     */
    cs_qual_type_bcm_to_dnx_conversion_cb qual_type_bcm_to_dnx_conversion_cb;
    /*
     * Routine that will translate the dnx qualifier back to a bcm qualifier for cases when using
     * field_id_array is not enough.
     */
    cs_qual_type_dnx_to_bcm_conversion_cb qual_type_dnx_to_bcm_conversion_cb;
    /*
     * Routine that will translate the qualifier's bcm value into its corresponding dnx value
     */
    field_data_conversion_cb conversion_cb;
} dnx_field_cs_qual_map_t;

/**
 * \brief Structure describing input type based information for dnx qualifiers
 */
typedef struct
{
    /*
     * Valid flag serves to mark initialized input types, by default is FALSE(0)
     */
    int valid;
    /**
     * Bitmap that represents for each input type which FFC ranges to use
     */
    uint8 ranges;
} dnx_field_qual_input_type_info_t;

/**
 * \brief Structure used to store information per SW qualifier
 */
typedef struct
{
    /**
     * Field ID associated with this qualifier, to be used while configuring TCAM entries
     */
    dbal_fields_e field_id;
    int size;

} dnx_field_sw_qual_info_t;

/**
 * \brief Structure used to store signal information per qualifier
 */
typedef struct
{
    /*
     * Name of stage signal comes from, If null any from
     * stages will be searched for match.
     */
    char *from;
    /*
     * Name of stage signal goes to, if null any to stage
     * will be searched for match.
     */
    char *to;
    /*
     * Name of the signal, which is corresponding to the qualifier.
     */
    char *name;
} dnx_field_map_qual_signal_info_t;

/**
 * \brief Structure used to store information per virtual wire qualifier
 */
typedef struct
{
    /**
     * Field ID associated with this qualifier, to be used while configuring TCAM entries
     */
    dbal_fields_e field_id;
    /**
     * The stages the VW is available for.
     */
    uint32 stage_bmp;
} dnx_field_vw_qual_info_t;

/**
 * \brief Structure used to store information per virtual wire action
 */
typedef struct
{
    /**
     * Field ID associated with this action, to be used while configuring TCAM entries
     * The first field_id has the name of the virtual wire.
     */
    dbal_fields_e field_id[DNX_FIELD_ACTION_MAX_ACTION_PER_VM];
    /**
     * The number of actions in field_id and action size for each stage
     */
    uint8 nof_actions_per_stage[DNX_FIELD_STAGE_NOF];
    /**
     * The static action upon which the action is based on for each stage.
     */
    dnx_field_action_t base_dnx_action_per_stage[DNX_FIELD_ACTION_MAX_ACTION_PER_VM][DNX_FIELD_STAGE_NOF];
} dnx_field_per_vw_action_info_t;

/**
 * \brief Structure used to store information per virtual wire action
 */
typedef struct
{
    /**
     * The index in dnx_per_vw_action_info of the VW using this action.
     */
    int vw_index;
    /**
     * The index of the action in the VW info in dnx_per_vw_action_info.
     */
    int action_index_within_vw;
} dnx_field_vw_action_info_t;

/**
 * \brief Structure used to store information per packet header qualifiers
 */
typedef struct
{
    /*
     * Name that may be parsed using signal facility
     * If the name was not found, use statically defined size and offset (see below)
     * If size is 0 and name not found - qualifier will be invalid
     * If size is not 0 and field was found, found parameters takes precedence over static with info message
     */
    char *name;
    /**
     * Field ID associated with this qualifier, to be used while configuring TCAM entries
     * If field_id is 0, it will be obtained dynamically from DBAL
     */
    dbal_fields_e field_id;
    /*
     * Qualifier Size in bits, if 0 should be filled via name resolution
     * Used when qualifier name is not present in NetworkStructures.xml
     * On the fly we can decide to overwrite size and offset by XML
     */
    int size;
    /**
     * For packet header - Offset from base - type of base depends on FCC type (in bits), filled together with size
     */
    int offset;

} dnx_field_header_qual_info_t;

/**
 * \brief Structure used to store information per packet layer record qualifiers
 */
typedef struct
{
    /**
     * DBAL Field ID associated with this qualifier, to be used while configuring TCAM entries
     */
    dbal_fields_e dbal_field_id;
} dnx_field_layer_record_qual_info_t;

/** Structure to hold the in parameters of dnx_field_qualifier_create()*/
typedef struct
{
    /**
     * Size of the created qualifier
     */
    int size;
    /**
     * Name of the qualifier.
     */
    char name[DBAL_MAX_STRING_LENGTH];

} dnx_field_qualifier_in_info_t;

/** Flags for BCM to DNX qualifiers/action map
 * Means qualifier / action should not be used fro DNX_To_BCM Mapping
 * */
#define BCM_TO_DNX_ADDITIONAL_OBJ      0x01
#define BCM_TO_DNX_IS_BAISC_OBJ(flags)  ((flags & BCM_TO_DNX_ADDITIONAL_OBJ) == 0)

/**
 * \brief
 *      Structure to hold miscellaneous parameters for bcm to dnx mapping process
 */
typedef struct
{
    /**
     * Encoded dnx qualifier to which bcm one is mapped
     */
    dnx_field_qual_t dnx_qual;
    /**
     * Flags please see BCM_TO_DNX_ADDITIONAL_OBJ
     */
    uint32 flags;
    /*
     * Routine that will translate the qualifier's bcm value into its corresponding dnx value
     */
    field_data_conversion_cb conversion_cb;

} dnx_field_qual_map_t;

typedef struct
{
    /**
     * Encoded dnx action to which bcm one is mapped
     */
    dnx_field_action_t dnx_action;
    /**
     * Flags please see BCM_TO_DNX_ADDITIONAL_OBJ
     */
    uint32 flags;
    /*
     * Routine that will translate the action's bcm value into its corresponding dnx value
     */
    field_data_conversion_cb conversion_cb;
} dnx_field_action_map_t;

/**
 * Information assigned to each static 'dnx action'
 */
typedef struct
{
    /**
     * Field ID associated with this action, to be used while configuring TCAM entries
     */
    dbal_fields_e field_id;
    /**
     * Number of bits assigned to this action (1 - 32)
     * To serve only SW action - for others size should be obtained dynamically from DBAL
     */
    uint32 size_sw;
} dnx_field_base_action_info_t;

/** Structure to hold the in parameters of dnx_field_action_create()
* Action create does not actually create new action just set a different size for existing action
* Hence this struct must indicate what is the base action and the new size
*/
typedef struct
{
    /** Field stage the action was created for*/
    dnx_field_stage_e stage;

    /** BCM action type we use to configure the action */
    bcm_field_action_t bcm_action;
    /**
     * Size of the created action
     * Cannot exceed the size of the base action.
     */
    unsigned int size;

    /**
     * A constant value that is apended to the MSB each action value that will be given to the action.
     * The prefix is not found in the TCAM/MDB payload (or key in direct extraction) and does not waste space there.
     * However, we implement it using FES action masks, which are a limited resource.
     */
    uint32 prefix;

    /**
     * The size in bit of the prefix. the sum of 'size'+'prefix_size' cannot exceed the size of the base action.
     * If the 'prefix_size' lsb bits of 'prefix' are all zeros, the prefix size will be zero.
     * As a safetly measurement, to make sure the user is cognisant of the base action size, the prefix size must fill
     * the remaining space in the base action, that is size+prefix_size=base_action_size.
     */
    unsigned int prefix_size;
    /**
     * Name of the action.
     */
    char name[DBAL_MAX_STRING_LENGTH];

} dnx_field_action_in_info_t;

/**
 * \brief Structure to keep all stage related pointers and other information
 */
typedef struct
{
    /*
     * Temporary adding PP_STAGE to be able to reach dnx data
     * Once FIELD_STAGE will be replaced by PP_STAGE it wont be needed
     */
    dnx_pp_stage_e pp_stage;
    /**
     * Associated BCM Stage
     */
    bcm_field_stage_t bcm_stage;
    /**
     * Next 3 parameters are to provide information on context selection qualifiers per stage
     */
    /**
     * DBAL table id for cs qualifiers
     */
    dbal_tables_e cs_table_id;
    /**
     * DBAL table id for cs hit indication
     */
    dbal_tables_e cs_hit_indication_table_id;
    /*
     * array of ffc type dbal field ids
     */
    dbal_fields_e ffc_type_field_a[DNX_FIELD_FFC_NOF];
    dbal_fields_e ffc_instruction;
    dbal_fields_e ctx_id;
    dbal_fields_e key_field;
    dbal_tables_e ffc_table;
    /**
     * Next 3 parameters are to provide information on action per stage
     */
    /**
     * DBAL field id for action
     */
    dbal_fields_e action_field_id;
    /**
     * Pointer to array of info per dnx action
     */
    const dnx_field_base_action_info_t *static_action_info;
    /*
     * BCM to DNX maps
     */
    const dnx_field_cs_qual_map_t *cs_qual_map;
    const dnx_field_qual_map_t *meta_qual_map;
    const dnx_field_action_map_t *static_action_id_map;
} dnx_field_map_stage_info_t;

/**
 * \brief Structure to keep AppType to OPCODE mapping.
 */
typedef struct
{
    /*
     * The OPCODE_ID to which the static apptype is mapped. 0 means invalid.
     */
    dbal_enum_value_field_forward_app_types_e opcode_id;
} dnx_field_static_apptype_map_t;

/**
 * Enum for indicating the port profile type, whether it refers to port or LIF or a RIF.
 */
typedef enum
{
    DNX_FIELD_PORT_PROFILE_TYPE_INVALID = 0,
    DNX_FIELD_PORT_PROFILE_TYPE_FIRST = 1,
    /**
     * The profile of a port, whether is be in port or out port, PP port or TM port.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_PORT = DNX_FIELD_PORT_PROFILE_TYPE_FIRST,
    /**
     * An extra profile of a port, whether is be in port or out port, PP port or TM port.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_PORT_GENERAL_DATA,
    /**
     * An extra profile of a port, beyond the first 32 bits, whether is be in port or out port, PP port or TM port.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_PORT_GENERAL_DATA_HIGH,
    /**
     * The profile of an in LIF in the ingress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_IN_LIF_INGRESS,
    /**
     * The profile of an in RIF in the the ingress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_IN_ETH_RIF_INGRESS,
    /**
     * The profile of an out LIF in the egress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_OUT_LIF_INGRESS,
    /**
     * The profile of an out RIF in the the egress.
     */
    DNX_FIELD_PORT_PROFILE_TYPE_OUT_ETH_RIF_EGRESS,
    /**
     * Number of enum valid values for port profile types */
    DNX_FIELD_PORT_PROFILE_TYPE_NOF
} dnx_field_port_porfile_type_e;

/**
 * \brief Structure that maps port profile properties
 * See dnx_field_port_profile_port_set.
 * See dnx_field_port_profile_port_get.
 * See dnx_field_map_port_profile_port_info_get.
 */
typedef struct
{
    /**
     * Whether the port profile refers to a port of a LIF.
     */
    dnx_field_port_porfile_type_e port_profile_type;
    /** The following attributes are only relevant for profile that are used for PP/TM ports.*/
    /**
     * The DBAL table where the port profile is found, relevant only for port profile of type port.
     */
    dbal_tables_e dbal_table_id;
    /*
     * The key field used by the DBAL table, relevant only for port profile of type port.
     */
    dbal_fields_e dbal_key_field;
    /*
     * The result field used by the DBAL table, relevant only for port profile of type port.
     */
    dbal_fields_e dbal_result_field;
} dnx_field_map_port_profile_info_t;

/*
 * }
 */
/*
 * Globals
 *    Used by MACROs available for any FP users
 * {
 */
extern const dnx_field_map_stage_info_t dnx_field_map_stage_info[DNX_FIELD_STAGE_NOF];
/*
 * }
 */

/*
 * Macros
 * {
 */

#define DNX_FIELD_IS_LAYER_RECORDS_QUALS_SUPPORTED(_stage)  \
        (dnx_data_field.stage.stage_info_get(unit, _stage)->nof_layer_records != 0)

#define DNX_FIELD_STAGE_ITERATOR(stage)                                                 \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(dnx_field_map_stage_info[stage].pp_stage != DNX_PP_STAGE_INVALID)

#define DNX_FIELD_STAGE_CS_QUAL_ITERATOR(stage)                                         \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(dnx_field_map_stage_info[stage].cs_qual_map != NULL)

#define DNX_FIELD_STAGE_QUAL_ITERATOR(stage)                      \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(dnx_field_map_stage_info[stage].meta_qual_map != NULL)

#define DNX_FIELD_STAGE_LAYER_QUAL_ITERATOR(stage)                \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(DNX_FIELD_IS_LAYER_RECORDS_QUALS_SUPPORTED(stage))

#define DNX_FIELD_STAGE_ACTION_ITERATOR(stage, field_map_stage_info)                    \
        for(stage = DNX_FIELD_STAGE_FIRST; stage < DNX_FIELD_STAGE_NOF; stage++)        \
            if(field_map_stage_info[stage].static_action_id_map != NULL)

    /**
     * \brief Return if an Apptype is within the user defined range
     * \param [in] unit            - Device ID
     * \param [in] _tested_apptype - The apptype
     * \return
     *      True if the apptype is within the predefiend range
     * \remark
     */
#define DNX_FIELD_APPTYPE_IS_USER_DEF(unit, _tested_apptype)  \
        ((_tested_apptype >= dnx_data_field.external_tcam.apptype_user_1st_get(unit)) && \
         (_tested_apptype < dnx_data_field.external_tcam.apptype_user_1st_get(unit) + \
                            dnx_data_field.external_tcam.apptype_user_nof_get(unit)))

#define DNX_FIELD_HEADER_QUAL_VERIFY(qual_id)                                               \
    if((qual_id < DNX_FIELD_HEADER_QUAL_FIRST) || (qual_id >= DNX_FIELD_HEADER_QUAL_NOF))   \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Header qual id:%d is out of range\n", qual_id);         \
    }

#define DNX_FIELD_SW_QUAL_VERIFY(qual_id)                                                   \
    if((qual_id < DNX_FIELD_SW_QUAL_FIRST) || (qual_id >= DNX_FIELD_SW_QUAL_NOF))           \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "SW qual id:%d is out of range\n", qual_id);             \
    }

#define DNX_FIELD_SW_ACTION_VERIFY(action_id)                                               \
    if((action_id < DNX_FIELD_SW_ACTION_FIRST) || (action_id >= DNX_FIELD_SW_ACTION_NOF))   \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "SW action id:%d is out of range\n", action_id);         \
    }

#define DNX_FIELD_VW_QUAL_VERIFY(qual_id)                                                   \
    if((qual_id < 0) || (qual_id >= DNX_FIELD_MAP_MAX_VW_QUAL))                             \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Virtual wire qual id:%d is out of range\n", qual_id);   \
    }

#define DNX_FIELD_VW_ACTION_VERIFY(action_id)                                               \
    if((action_id < 0) || (action_id >= DNX_FIELD_MAP_MAX_VW_ACTION))                       \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Virtual wire action id:%d is out of range\n", action_id);\
    }

#define DNX_FIELD_OPCODE_VERIFY(opcode_id)                                                  \
    if((opcode_id < 0) || (opcode_id >= DNX_FIELD_EXTERNAL_MAX_STATIC_OPCODES_NOF))         \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Opcode (%d) is out of range\r\n", opcode_id);           \
    }

#define DNX_FIELD_META_QUAL_VERIFY(qual_id)                                                \
{ \
    if((qual_id < DNX_FIELD_QUAL_ID_FIRST) || (qual_id >= DNX_FIELD_QUAL_NOF))             \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_INTERNAL, "meta qual id:%d is out of range\n", qual_id);       \
    }                                                                                       \
}

#define DNX_FIELD_LAYER_QUAL_VERIFY(stage, qual_id)                                         \
    if((qual_id < DNX_FIELD_LR_QUAL_FIRST) || (qual_id >= DNX_FIELD_LR_QUAL_NOF))           \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "layer record qual id:%d is out of range for stage:%s\n",\
                                               qual_id, dnx_field_stage_text(unit,stage));  \
    }

#define DNX_FIELD_LAYER_INDEX_VERIFY(stage, layer_id)                                       \
{ \
    if(DNX_FIELD_IS_LAYER_RECORDS_QUALS_SUPPORTED(stage) == FALSE)                          \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Stage:%s does not support layer record qualifiers\n",   \
                                                        dnx_field_stage_text(unit,stage));  \
    }                                                                                       \
    if((layer_id < 0 ) ||                                                                   \
       (layer_id >= dnx_data_field.stage.stage_info_get(unit, stage)->nof_layer_records))   \
    {                                                                                       \
        SHR_ERR_EXIT(_SHR_E_PARAM, "Layer Index:%d is invalid for stage: %s. "              \
                     "Number of layers available to stage is %d.\n",                        \
                     layer_id, dnx_field_stage_text(unit,stage),                            \
                     dnx_data_field.stage.stage_info_get(unit, stage)->nof_layer_records);  \
    }                                                                                       \
}

#define DNX_FIELD_BCM_QUAL_VERIFY(bcm_qual)                                             \
    if((bcm_qual < 0) || (bcm_qual >= bcmFieldQualifyCount))                            \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "BCM qualifier:%d is out of range\n", bcm_qual);     \
    }

#define DNX_FIELD_BCM_ACTION_VERIFY(bcm_action)                                         \
    if((bcm_action < 0) || (bcm_action >= bcmFieldActionCount))                         \
    {                                                                                   \
        SHR_ERR_EXIT(_SHR_E_PARAM, "BCM action:%d is out of range\n", bcm_action);      \
    }

#define DNX_FIELD_NCM_PORT_CLASS_VERIFY(bcm_port_class)                                    \
{                                                                                          \
    if((bcm_port_class < 0) || (bcm_port_class > bcmPortClassCount))                       \
    {                                                                                      \
        SHR_ERR_EXIT(_SHR_E_PARAM, "BCM port class:%d is out of range\n", bcm_port_class); \
    }                                                                                      \
}

/*
 * }
 */

/**
* \brief
*  Init the Sw state of Field Map module
* \param [in] unit  - Device id
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_sw_state_init(
    int unit);

/**
 * \brief  Return name of bcm qualifier
 * \param [in] unit     - Identifier of HW platform.
 * \param [in] bcm_qual - bcm qualifier ID
 * \return
 *   \retval bcmQualifierName      - On success
 *   \retval NULL                  - ON Failure
 * \remark
 */
CONST char *dnx_field_bcm_qual_text(
    int unit,
    bcm_field_qualify_t bcm_qual);

/**
 * \brief  Return name of bcm action
 * \param [in] unit       - Identifier of HW platform.
 * \param [in] bcm_action - bcm action ID
 * \return
 *   \retval bcmActionName              - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
CONST char *dnx_field_bcm_action_text(
    int unit,
    bcm_field_action_t bcm_action);

/**
 * \brief  Return name of pipeline stage
 * \param [in] unit  - Identifier of HW platform.
 * \param [in] stage - stage ID
 * \return
 *   \retval bcmStageName               - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
char *dnx_field_stage_text(
    int unit,
    dnx_field_stage_e stage);

/**
 * \brief  Return name of BCM stage
 * \param [in] bcm_stage - BCM stage ID
 * \return
 *   \retval bcmStageName               - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
char *dnx_field_bcm_stage_text(
    bcm_field_stage_t bcm_stage);

/**
 * \brief  Return name of BCM Layer Type
 * \param [in] bcm_layer_type - BCM Layer Type ID
 * \return
 *   \retval bcmLayerTypeName           - On success
 *   \retval NULL                       - On Failure
 * \remark
 */
char *dnx_field_bcm_layer_type_text(
    bcm_field_layer_type_t bcm_layer_type);

/**
 * \brief  Return name of dnx qualifier class
 * \param [in] qual_class - dnx qualifier class
 * \return
 *   \retval class name       - On success
 *   \retval "Invalid Class"  - If invalid class provided
 *   \retval "Unnamed Class"  - If for valid class name was not assigned
 * \remark
 */
char *dnx_field_qual_class_text(
    dnx_field_qual_class_e qual_class);

/**
 * \brief  Return name of dnx input type
 * \param [in] input_type - qual input type
 * \return
 *   \retval input_type name        - On success
 *   \retval "Invalid Input Type"   - If invalid input type provided
 *   \retval "Unnamed Input Type"   - If for valid input type, name was not assigned
 * \remark
 */
char *dnx_field_input_type_text(
    dnx_field_input_type_e input_type);

/**
 * \brief  Return name of bcm input type
 * \param [in] bcm_input_type - BCM qual input type
 * \return
 *   \retval input_type name        - On success
 *   \retval "Invalid Input Type"   - If invalid input type provided
 * \remark
 */
char *dnx_field_bcm_input_type_text(
    bcm_field_input_types_t bcm_input_type);

/**
 * \brief  Return name of bcm packet remove layer
 * \param [in] bcm_packet_remove_layer - BCM packet remove layer
 * \return
 *   \retval packet_remove_layer name  - On success
 *   \retval "Invalid Packet Remove Layer"   - If invalid Packet Remove Layer provided
 * \remark
 */
char *dnx_field_bcm_packet_remove_layer_text(
    bcm_field_packet_remove_layers_t bcm_packet_remove_layer);

/**
 * \brief  Return name of bcm tcam bank allocation mode
 * \param [in] bcm_tcam_bank_allocation_mode - BCM tcam bank allocation mode
 * \return
 *   \retval input_type name        - On success
 *   \retval "Invalid Tcam Bank Allocation Mode"   - If invalid TCAM bank allocation mode
 * \remark
 */
char *dnx_field_bcm_tcam_bank_allocation_mode_text(
    bcm_field_tcam_bank_allocation_mode_t bcm_tcam_bank_allocation_mode);

/**
 * \brief  Return name of bcm Apptype
 * \param [in] unit        - Device ID
 * \param [in] bcm_apptype - BCM Apptype
 * \return
 *   \retval Apptype name        - On success
 *   \retval "Invalid Apptype"   - If invalid Apptype provided
 * \remark
 */
CONST char *dnx_field_bcm_apptype_text(
    int unit,
    bcm_field_AppType_t bcm_apptype);

/**
 * \brief  Return name of bcm RangeType
 * \param [in] bcm_rangetype - BCM RangeType
 * \return
 *   \retval RangeType name        - On success
 *   \retval "Invalid RangeType"   - If invalid RangeType provided
 * \remark
 */
char *dnx_field_bcm_range_type_text(
    bcm_field_range_type_t bcm_rangetype);

/**
 * \brief  Return name of bcm RangeResultMap
 * \param [in] bcm_rangeresultmap - BCM RangeResultMap
 * \return
 *   \retval RangeResultMap name        - On success
 *   \retval "Invalid RangeResultMap"   - If invalid RangeResultMap provided
 * \remark
 */
char *dnx_field_bcm_range_result_map_text(
    bcm_switch_range_result_map_t bcm_rangeresultmap);

/**
 * \brief  Return name of bcm RangeOperator
 * \param [in] bcm_rangeoperator - BCM RangeOperator
 * \return
 *   \retval RangeOperator name        - On success
 *   \retval "Invalid RangeOperator"   - If invalid RangeOperator provided
 * \remark
 */
char *dnx_field_bcm_range_operator_text(
    bcm_switch_range_operator_t bcm_rangeoperator);

/**
 * \brief  Return name of bcm RangeOperator
 * \param [in] pp_app - BCM APP DB
 * \return
 *   \retval APP DDB name        - On success
 *   \retval "Invalid APP DB"    - If invalid RangeOperator provided
 * \remark
 */
char *dnx_field_bcm_app_db_text(
    bcm_field_app_db_t pp_app);

/**
 * \brief  Return name of dnx action class
 * \param [in] action_class - dnx action class
 * \return
 *   \retval class name       - On success
 *   \retval "Invalid Class"  - If invalid class provided
 *   \retval "Unnamed Class"  - If for valid class name was not assigned
 * \remark
 */
char *dnx_field_action_class_text(
    dnx_field_action_class_e action_class);

/**
 * \brief  Return Name of DNX Action
 * \param [in] unit       - Identifier of HW platform.
 * \param [in] dnx_action - Encoded DNX Action
 * \return
 *   \retval dbal field name    - On success
 *   \retval Invalid DNX Action - When DNX Action is not valid
 * \remark
 *  Name is actually DBAL field name
 */
CONST char *dnx_field_dnx_action_text(
    int unit,
    dnx_field_action_t dnx_action);

/**
 * \brief  Return Name of DNX Qualifier
 * \param [in] unit       - Identifier of HW platform.
 * \param [in] dnx_qual   - Encoded DNX Qualifier
 * \return
 *   \retval dbal field name       - On success
 *   \retval Invalid DNX Qualifier - When DNX Qualifier is not valid
 * \remark
 *  Name is actually DBAL field name
 */
CONST char *dnx_field_dnx_qual_text(
    int unit,
    dnx_field_qual_t dnx_qual);

/**
* \brief
*  Gets the actions and offsets that write to aspecific VW mapping.
* \param [in] unit - Device ID.
* \param [in] stage - Stage
* \param [in] mapping_info_p - The mapping of VM to a signal.
* \param [out] nof_actions_p - Number of actions mapped to the signal by the VM.
* \param [out] dnx_actions- The list of action ids used by the signal.
* \param [out] offsets- The offsets on the signal of the actions
* \param [out] action_sizes- The sizes of the actions.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_vw_single_mapping_actions_offsets(
    int unit,
    dnx_field_stage_e stage,
    VirtualWireMappingInfo * mapping_info_p,
    int *nof_actions_p,
    dnx_field_action_t dnx_actions[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF],
    int offsets[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF],
    int action_sizes[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF]);

shr_error_e dnx_field_map_vw_qual_action_init(
    int unit);

shr_error_e dnx_field_map_action_init(
    int unit);

shr_error_e dnx_field_map_qual_init(
    int unit);

shr_error_e dnx_field_map_cs_qual_init(
    int unit);

shr_error_e dnx_field_map_init(
    int unit);

shr_error_e dnx_field_map_deinit(
    int unit);

/**
 * \brief  Indicade if any mapping exists for a qualifier in the the context selection of a specific stage.
 *  Does not include global layer record qualifer qualifiers.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_qual - BCM qualifier id
 * \param [out] mapping_exists_p - Indicates if the mapping exists
 * \param [out] mapping_potentially_exists_for_device_p - Indicates if at least some DBAL fields are supported on device.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_cs_qual_bcm_mapping_exists(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_qualify_t bcm_qual,
    uint8 *mapping_exists_p,
    uint8 *mapping_potentially_exists_for_device_p);

/**
 * \brief  Map DNx enum of CS qualifer to dbal field, and if special qualifier size and offset within the dbal field.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] field_stage - Stage identifier
 * \param [in] dnx_qual - DNX qualifier id
 * \param [out] is_supported_p - If conversion supported for device.
 * \param [out] dbal_field_id_p - If is_supported_p, the dbal field.
 * \param [out] is_special_p - If is_supported_p, if the qualifer is a secial qualifer.
 * \param [out] size_p - If is_supported_p and is_special_p, the number of bits used.
 * \param [out] offset_p - If is_supported_p and is_special_p, the offset within the dbal_field.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_cs_qual_dnx_to_dbal(
    int unit,
    dnx_field_stage_e field_stage,
    dnx_field_cs_qual_e dnx_qual,
    int *is_supported_p,
    dbal_fields_e * dbal_field_id_p,
    int *is_special_p,
    int *size_p,
    int *offset_p);

/**
 * \brief  Translate bcm qualifier into CS qualifier, this is one2one conversion
 * \param [in] unit - Identifier of HW platform.
 * \param [in] core - Identifier of core.
 * \param [in] stage  - Stage identifier
 * \param [in] context_id - Context ID of the preselection quals
 * \param [in] bcm_cs_qual_info - BCM presel qualifier info, source of information here
 * \param [in] dnx_cs_qual_info - DNX presel qualifier info, destination here
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier in CS
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_cs_qual_info_bcm_to_dnx(
    int unit,
    bcm_core_t core,
    dnx_field_stage_e stage,
    dnx_field_context_t context_id,
    bcm_field_presel_qualify_data_t * bcm_cs_qual_info,
    dnx_field_presel_qual_data_t * dnx_cs_qual_info);

/**
 * \brief  Translate CS DNX qualifier into BCM qualifier, this
 *         is one2one conversion
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] context_id - Context ID of the preselection quals
 * \param [in] dnx_cs_qual_dbal_field - DNX qualifier id - DBAL Field ID
 * \param [out] bcm_qual_p - pointer to BCM qualifier
 * \param [out] cs_qual_index_p - pointer to CS qual index (0 for non-arrayed qualifiers)
 * \param [out] is_special_general_data_p - If true no conversion is done.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier in CS
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *   If is_special_general_data_p is true, use dnx_field_map_cs_qual_special_meta_data_qual_to_bcm().
 */
shr_error_e dnx_field_map_cs_qual_dnx_dbal_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_context_t context_id,
    dbal_fields_e dnx_cs_qual_dbal_field,
    bcm_field_qualify_t * bcm_qual_p,
    uint32 *cs_qual_index_p,
    int *is_special_general_data_p);

/**
 * \brief  Translate PEM scratch pad into multiple BCM qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] context_id - Context ID of the preselection quals
 * \param [in] dnx_cs_qual_dbal_field - DBAL Field ID, must be the PEM scratch pad
 * \param [in] dnx_value - HW value of the PEM scratch pad
 * \param [in] dnx_mask - HW value of the PEM scratch pad mask
 * \param [out] nof_bcm_quals_p - How many BCM qualifers.
 * \param [out] bcm_quals - Array of BCM qualifers.
 * \param [out] cs_qual_indices - Array of input arguments for each BCM qualifer.
 * \param [out] bcm_values - Array of values for each BCM qualifer.
 * \param [out] bcm_masks - Array of masks for each BCM qualifer.
 * \return
 *   shr_error_e - Error Type
 * \remark
 *
 */
shr_error_e dnx_field_map_cs_qual_special_qual_dbal_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_context_t context_id,
    dbal_fields_e dnx_cs_qual_dbal_field,
    uint32 dnx_value[DNX_DATA_MAX_FIELD_PRESELECTOR_NOF_UINT32_IN_CS_QUAL_HW],
    uint32 dnx_mask[DNX_DATA_MAX_FIELD_PRESELECTOR_NOF_UINT32_IN_CS_QUAL_HW],
    int *nof_bcm_quals_p,
    bcm_field_qualify_t bcm_quals[BCM_FIELD_MAX_NOF_CS_QUALIFIERS],
    uint32 cs_qual_indices[BCM_FIELD_MAX_NOF_CS_QUALIFIERS],
    uint32 bcm_values[BCM_FIELD_MAX_NOF_CS_QUALIFIERS],
    uint32 bcm_masks[BCM_FIELD_MAX_NOF_CS_QUALIFIERS]);

/**
 * \brief  Get CS qualifier size
 * \param [in] unit - Identifier of HW platform.
 * \param [in] dnx_stage - Stage identifier
 * \param [in] dnx_qual_dbal_field - DBAL field, DNX value of the qualifier
 * \param [out] size - dnx cs qualifier size - DBAL Field ID
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier in CS
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_cs_qual_size_get(
    int unit,
    dnx_field_stage_e dnx_stage,
    dbal_fields_e dnx_qual_dbal_field,
    int *size);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [out] cs_table_id_p - pointer to Context Selection qualifiers DBAL table id
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_cs_qual_table_id(
    int unit,
    dnx_field_stage_e stage,
    dbal_tables_e * cs_table_id_p);

/**
* \brief
*  Verify input parameters for preselection ID
* \param [in] unit           - Device ID
* \param [in] stage      - dnx stage identifier
* \param [in,out] cs_nof_lines_p - pointer to number of cs lines to be assigned in the routine
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_cs_qual_nof_lines(
    int unit,
    dnx_field_stage_e stage,
    uint32 *cs_nof_lines_p);

/**
* \brief
* This function decrement the number fo group reference to that specific qualifier id
* of groups referenced by
* \param [in] unit   - Device Id
* \param [in] qual  -  Dnx Qualifier
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_ref_dec(
    int unit,
    dnx_field_qual_t qual);

/**
* \brief
* This function increment the number fo group reference to that specific qualifier id
* increments the number of groups referenced by
* \param [in] unit - Device Id
* \param [in] qual  - Dnx Qualifier
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_ref_inc(
    int unit,
    dnx_field_qual_t qual);

/**
* \brief
*  Clear the dnx_field_qualifier_in_info_t, set it to preferred init values
* \param [in] unit              - Device ID
* \param [in] qual_info_in_p    - Pointer to input structure of qual_info_in_p that needs to be initiated
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_in_info_init(
    int unit,
    dnx_field_qualifier_in_info_t * qual_info_in_p);

/**
* \brief
*  Create User qualifier
* \param [in] unit           - Device ID
* \param [in] flags          - Flags to create the qualifier with
* \param [in] qual_info_p    - Qualifier information for creation.
* \param [in,out] bcm_qual_p - For the case with_id bcm_qual will be input, otherwise output
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_create(
    int unit,
    dnx_field_qual_flags_e flags,
    dnx_field_qualifier_in_info_t * qual_info_p,
    bcm_field_qualify_t * bcm_qual_p);

/**
* \brief
*  Destroy User created qualifier
* \param [in] unit      - Device ID
* \param [in] bcm_qual  - BCM Qualifier to destroy
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_destroy(
    int unit,
    bcm_field_qualify_t bcm_qual);

/**
* \brief
*  Gets the info for the qualifier which is relevant to the end user.
*  It fills it in qual_in_info_p.
* \param [in] unit              - Device ID.
* \param [in] bcm_qual          - BCM Qualifier ID.
* \param [out] qual_info_p      - holds all relevant info for the action, size, stage and name.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_qual_get(
    int unit,
    bcm_field_qualify_t bcm_qual,
    dnx_field_qualifier_in_info_t * qual_info_p);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] print_errors - Bool to decide whether to display the errors
 * \param [in] bcm_qual - BCM qualifier id
 * \param [in,out] dnx_qual_p - pointer to dnx qualifier array
 * \param [out] qual_map_entry_pp - place to assign pointer of bcm qual entry
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is illegal or out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_bcm_to_dnx_int(
    int unit,
    dnx_field_stage_e stage,
    uint32 print_errors,
    bcm_field_qualify_t bcm_qual,
    dnx_field_qual_t * dnx_qual_p,
    const dnx_field_qual_map_t ** qual_map_entry_pp);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_qual - BCM qualifier id
 * \param [in,out] dnx_qual_p - pointer to dnx qualifier array
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is illegal or out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_bcm_to_dnx(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_qualify_t bcm_qual,
    dnx_field_qual_t * dnx_qual_p);

/**
 * \brief  Translate bcm qualifier into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] core - Identifier of core.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_qual_info - pointer to BCM qualifier info
 * \param [out] dnx_qual_info - pointer to DNX qualifier array
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_info_bcm_to_dnx(
    int unit,
    bcm_core_t core,
    dnx_field_stage_e stage,
    bcm_field_entry_qual_t * bcm_qual_info,
    dnx_field_entry_qual_t * dnx_qual_info);

/**
 * \brief  Indicates if the mapping of a qaulifier includes value conversion.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] bcm_stage - Stage identifier
 * \param [in] bcm_qual - The mapped qualifier
 * \param [out] has_conversion_p - Indicates if there is a value conversion.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm qualifier
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_has_conversion(
    int unit,
    bcm_field_stage_t bcm_stage,
    bcm_field_qualify_t bcm_qual,
    int *has_conversion_p);

/**
 * \brief  Translate dnx qualifier into BCM one, but don't failed if couldn't find one.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] dnx_qual - DNX qualifier
 * \param [in] bcm_qual_p - Pointer where BCM qualifier id should be placed
 * \param [in] found_p - Returns if BCM qualifier was found.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_dnx_to_bcm_int(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    bcm_field_qualify_t * bcm_qual_p,
    uint8 *found_p);

/**
 * \brief  Translate dnx qualifier into BCM one
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] dnx_qual - dnx qualifier
 * \param [in] bcm_qual_p - pointer where BCM qualifier id should be placed
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_dnx_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    bcm_field_qualify_t * bcm_qual_p);

/**
 * \brief  Create the list of all available dnx qualifiers per stage
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in,out] dnx_qual_list_p - pointer to the list of dnx qualifiers
 * \param [in,out] dnx_qual_num_p - pointer to the number dnx qualifier
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_list(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t ** dnx_qual_list_p,
    int *dnx_qual_num_p);

/**
 * \brief  Fetch the FFC range associated with a specific class.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] input_type - The input type given in attach info.
 * \param [in] offset - The offset given in attach info. Relevant only for Metadata.
 * \param [in,out] ranges_p - Pointer to the a bitmap indicating legitimate ranges for iPMF1 FFCs
 *                            (or 0 if stage isn't iPMF1 or iPMF2 with non-naive qualifiers).
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - For class out of range or class without FFC mapping info (if the stage is iPMF1,
 *                              or non native qualifiers for iPMF2).
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_input_type_to_ranges(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_input_type_e input_type,
    int offset,
    uint8 *ranges_p);

/**
 * \brief  Fetch the FFC range associated with a specific key.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] key_id - The key to use the FFC in
 * \param [in,out] ranges_p - Pointer to the a bitmap indicating legitimate ranges for iPMF1 FFCs
 *                            (or all ones if stage isn't iPMF1).
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_qual_key_to_ranges(
    int unit,
    dnx_field_stage_e stage,
    dbal_enum_value_field_field_key_e key_id,
    uint8 *ranges_p);

/**
 * \brief  Convert a negative layer index to a positive one (given that layer indices are translated as modulo,
 *         that would have the same effect).
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier. If iPMF2, assumes that the data is taken from iPMF1.
 * \param [in] layer_index_in - absolute number of layer record, which offset is requested
 * \param [in,out] layer_index_out - pointer to be filled with positive layer index.
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - For layer index out of range or stage without layer record support
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *   At the moment this function doesn't perform modulo, just negative to positive conversion.
 *   This function is used for relative layer indices (input type FWD).
 */
shr_error_e dnx_field_map_layer_index_modulo(
    int unit,
    dnx_field_stage_e stage,
    int layer_index_in,
    int *layer_index_out);

/**
 * \brief  Fetch the pbus absolute offset of chosen layer record
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier. If iPMF2, assumes that the data is taken from iPMF1.
 * \param [in] layer_index - absolute number of layer record, which offset is requested
 * \param [in,out] offset_p - pointer to the offset from pbus start
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - For layer index out of range or stage without layer record support
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_layer_record_offset(
    int unit,
    dnx_field_stage_e stage,
    int layer_index,
    int *offset_p);

/**
* \brief
* This function decrement the number fo group reference to that specific action
* of groups referenced by
* \param [in] unit   - Device Id
* \param [in] action  -  Dnx Action
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_ref_dec(
    int unit,
    dnx_field_action_t action);

/**
* \brief
* This function increment the number fo group reference to that specific action
* increments the number of groups referenced by
* \param [in] unit - Device Id
* \param [in] action  - Dnx Action
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_ref_inc(
    int unit,
    dnx_field_action_t action);

/**
* \brief
*  Clear the dnx_field_action_in_info_t, set it to preferred init values
* \param [in] unit              - Device ID
* \param [in] action_info_in_p  - Pointer to input structure of action_info_in_p that needs to be init
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_in_info_t_init(
    int unit,
    dnx_field_action_in_info_t * action_info_in_p);

/**
* \brief
*  Creates user action based on existing action, i.e. set new size.
* \param [in] unit              - Device ID
* \param [in] flags             - as per dnx_field_action_flags_e
* \param [in] action_in_info_p  - holds all relevant info for the action set-up(creation), size, stage, action and name.
* \param [in,out] bcm_action_p  - for with_id, bcm_action is input inside this ptr, otherwise, output created by routine
*                                 must be always provided, NULL will result in ERROR
* \param [in,out] dnx_action_p  - created action ID, encoded class is USER
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_create(
    int unit,
    dnx_field_action_flags_e flags,
    dnx_field_action_in_info_t * action_in_info_p,
    bcm_field_action_t * bcm_action_p,
    dnx_field_action_t * dnx_action_p);

/**
* \brief
*  Destroys an existing user action based .
* \param [in] unit           - Device ID
* \param [out] bcm_action    - BCM action to be destroyed
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_action_destroy(
    int unit,
    bcm_field_action_t bcm_action);

/**
 * \brief  Translate bcm action into the set of DNX action
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] print_errors - Bool to decide whether to display the errors
 * \param [in] bcm_action - BCM action id
 * \param [in,out] dnx_action_p - pointer to dnx action
 * \param [out] action_map_entry_pp - action map entry should be returned
 * \return *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm action
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_action_bcm_to_dnx_int(
    int unit,
    dnx_field_stage_e stage,
    uint32 print_errors,
    bcm_field_action_t bcm_action,
    dnx_field_action_t * dnx_action_p,
    const dnx_field_action_map_t ** action_map_entry_pp);

/**
 * \brief  Translate bcm action into the set of DNX action
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_action - BCM action id
 * \param [in,out] dnx_action_p - pointer to dnx action
 * \return *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm action
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_action_bcm_to_dnx(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_action_t bcm_action,
    dnx_field_action_t * dnx_action_p);

/**
 * \brief  Translate bcm action into the set of DNX qualifiers
 * \param [in] unit - Identifier of HW platform.
 * \param [in] core - Identifier of core.
 * \param [in] stage - Stage identifier
 * \param [in] bcm_action_info - pointer to BCM qualifier info
 * \param [out] dnx_action_info - pointer to DNX action info
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_NOT_FOUND - When there is no support for such bcm action
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_action_info_bcm_to_dnx(
    int unit,
    bcm_core_t core,
    dnx_field_stage_e stage,
    bcm_field_entry_action_t * bcm_action_info,
    dnx_field_entry_action_t * dnx_action_info);

/**
 * \brief  Translate dnx action into BCM one, but do not fail if not found.
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] dnx_action - DNX action
 * \param [in] bcm_action_p - A pointer where BCM action id should be placed
 * \param [in] found_p - Indication if the BCM action was found.
 * \return
 *   shr_error_e - Error Type
 * \remark
 *
 */
shr_error_e dnx_field_map_action_dnx_to_bcm_int(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    bcm_field_action_t * bcm_action_p,
    uint8 *found_p);

/**
 * \brief  Translate dnx action into BCM one
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in] dnx_action - dnx action
 * \param [in] bcm_action_p - pointer where BCM action id should be placed
 * \return
 *   shr_error_e - Error Type
 * \remark
 *
 */
shr_error_e dnx_field_map_action_dnx_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    bcm_field_action_t * bcm_action_p);

/**
 * \brief  Create list of all available dnx actions per stage
 * \param [in] unit - Identifier of HW platform.
 * \param [in] stage - Stage identifier
 * \param [in,out] dnx_action_list_p - pointer to the array of dnx actions
 * \param [in,out] dnx_action_nof_p - pointer to the number of dnx actions
 * \return
 *   \retval _SHR_E_NONE      - On success
 *   \retval _SHR_E_PARAM     - One of input params is out of range
 *   \retval Other - Other errors as per shr_error_e
 * \remark
 *
 */
shr_error_e dnx_field_map_action_list(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t ** dnx_action_list_p,
    int *dnx_action_nof_p);

/**
* \brief
*  Gets all relevant action info that the end user might need and fills it in action_info_in_p.
* \param [in] unit              - Device ID
* \param [in] bcm_action        - BCM Action ID
* \param [out] action_info_p    - holds all relevant info for the action, size, stage, action and name.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_user_action_get(
    int unit,
    bcm_field_action_t bcm_action,
    dnx_field_action_in_info_t * action_info_p);

shr_error_e dnx_field_user_action_stage_get(
    int unit,
    bcm_field_action_t bcm_action,
    dnx_field_stage_e * dnx_stage_p);

/**
* \brief
*  Maps the DNX qualifier to DBAL field
* \param [in] unit          - Device ID
* \param [in] stage   - Stage identifier
* \param [in] dnx_qual      - DNX qualifier
* \param [out] dbal_field_p - DBAL field
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_to_dbal_qual(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    dbal_fields_e * dbal_field_p);

/**
* \brief
*  Maps DNX action to DBAL field
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] dbal_field_p  - DBAL field
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_to_dbal_action(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    dbal_fields_e * dbal_field_p);

/**
* \brief
*  Maps DNX action to action type
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] action_type_p  - action type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_to_action_type(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    dnx_field_action_type_t * action_type_p);

/**
* \brief
*  Retruns if the action is legal for the specific device.
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] action_is_legal_p  - if the action type is legal for the device
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_action_is_legal(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    int *action_is_legal_p);

/**
* \brief
*  Maps DNX action to action type
* \param [in] unit          - Device ID
* \param [in] dnx_stage     -Stage identifier
* \param [in] action_type   - action type, the value to be written to the DBAL ENUM for the action.
* \param [out] dnx_action_p - The static action that uses the action type.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_action_type_to_predef_dnx_action(
    int unit,
    dnx_field_stage_e dnx_stage,
    dnx_field_action_type_t action_type,
    dnx_field_action_t * dnx_action_p);

/**
* \brief
*  Maps the DNX qualifier to its size in bits
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_qual      - DNX qualifier
* \param [out] nof_mappings_p  - The number of different parts of qualifiers. If NULL, won't be returned.
* \param [out] qual_sizes  - Size of each part. Array of DNX_FIELD_QAUL_MAX_NOF_MAPPINGS. If NULL, won't be returned.
* \param [out] qual_size_total_p  - Total size of qualifer, including all parts.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_qual_size(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    int *nof_mappings_p,
    uint32 qual_sizes[DNX_FIELD_QAUL_MAX_NOF_MAPPINGS],
    uint32 *qual_size_total_p);

/**
* \brief
*  Maps DNX action to its size
* \param [in] unit          - Device ID
* \param [in] stage      -Stage identifier
* \param [in] dnx_action      - DNX action
* \param [out] action_size_p  - action size in bits
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_size(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    unsigned int *action_size_p);

/**
* \brief
*  Finds the prefix and prefix size of a user defined action.
* \param [in] unit                - Device ID
* \param [in] stage               - Stage identifier.
* \param [in] dnx_action          - The user defined action.
* \param [out] prefix_p           - The prefix of the user defined action.
* \param [out] prefix_size_p      - The size in bits of the prefix of the user defined action.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_prefix(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    uint32 *prefix_p,
    unsigned int *prefix_size_p);

/**
* \brief
*  Finds the base action of a user defined action, both as DNX actions.
* \param [in] unit                - Device ID
* \param [in] stage               - Stage identifier
* \param [in] dnx_action          - The user defined action.
* \param [out] base_dnx_action_p  - The base action of the user defined action.
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_base_action(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    dnx_field_action_t * base_dnx_action_p);

/**
* \brief
*  Finds the base action of a user defined action, both as BCM actions.
*  If action is not a user defined action, returns an invalid action.
* \param [in] unit                - Device ID
* \param [in] bcm_action          - The action.
* \param [out] base_bcm_action_p  - The base action of the user defined action or bcmFieldActionCount othereise.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_bcm_action_base_action(
    int unit,
    bcm_field_action_t bcm_action,
    bcm_field_action_t * base_bcm_action_p);

/**
* \brief
*  Check if the action is the predefined void action or a user defined action based on the predefined void action.
*  Void actions are used to write data to payload without automatically performing a FES action on that data.
* \param [in] unit               - Device ID
* \param [in] stage              - Stage identifier
* \param [in] dnx_action         - DNX action
* \param [out] action_is_void_p  - Whether the action is a void action.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_action_is_void(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_action_t dnx_action,
    int *action_is_void_p);

/**
* \brief
*  Get the FFC instructions table name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [in] ffc_type          - FFC type
* \param [out] ffc_type_field_p - output DBAL field of FFC type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_ffc_type_to_field(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_ffc_type_e ffc_type,
    dbal_fields_e * ffc_type_field_p);

/**
* \brief
*  Get the FFC instructions table name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] ffc_table_name_p - output ffc instruction table name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_to_ffc_table(
    int unit,
    dnx_field_stage_e stage,
    dbal_tables_e * ffc_table_name_p);

/**
* \brief
*  Get the FFC instructions name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] ffc_instruction_name_p - output ffc instruction name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_to_ffc_instruction(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e * ffc_instruction_name_p);
shr_error_e
/**
* \brief
*  Get the ctx_id dbal field name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] dbal_ctx_id      - output ctx_id dbal name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
    dnx_field_map_ctx_id_to_field(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e * dbal_ctx_id);

/**
* \brief
*  Get the key_field dbal field name for the required stage
* \param [in] unit              - Device ID
* \param [in] stage             - Stage identifier
* \param [out] dbal_key         - output key_field dbal name for current stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_key_to_field(
    int unit,
    dnx_field_stage_e stage,
    dbal_fields_e * dbal_key);

/**
* \brief
*  Returns the lookup_enabler DBAL table according to the given stage.
* \param [in] unit        - Device ID
* \param [in] stage - The stage of the table we want to get
* \param [out] has_lookup_enabler - True if the stage has lookup enabler.
* \param [out] table_id - Table ID for lookup enable DBAL table per given stage
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * dnx_field_key_lookup_change_state
*/
shr_error_e dnx_field_map_lookup_dbal_table_get(
    int unit,
    dnx_field_stage_e stage,
    int *has_lookup_enabler,
    dbal_tables_e * table_id);

/**
* \brief
*  Returns the invalid action type per given stage.
* \param [in] unit        - Device ID
* \param [in] dnx_stage - The stage of the table we want to get
* \param [out] action_type_p - pointer to action type invalid
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_get_invalid_action_type(
    int unit,
    dnx_field_stage_e dnx_stage,
    dnx_field_action_type_t * action_type_p);

/**
* \brief
*  Returns the invalidate next action type per given stage.
* \param [in] unit        - Device ID
* \param [in] dnx_stage - The stage of the table we want to get
* \param [out] action_type_p - pointer to action type invalidate next
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_get_invalidate_next_action_type(
    int unit,
    dnx_field_stage_e dnx_stage,
    dnx_field_action_type_t * action_type_p);

/**
* \brief
*  Get a BCM qualifier based on its name.
* \param [in] unit          - Device ID
* \param [in] name          - The qualifier's name. Number of elements DBAL_MAX_STRING_LENGTH.
* \param [out] bcm_qual_p   - pointer to BCM qualifier. Return bcmFieldQualifyCount if none found.
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_name_to_qual(
    int unit,
    const char name[DBAL_MAX_STRING_LENGTH],
    bcm_field_qualify_t * bcm_qual_p);

/**
* \brief
*  Get a BCM action based on its name.
* \param [in] unit          - Device ID
* \param [in] name          - The action's name. Number of elements DBAL_MAX_STRING_LENGTH.
* \param [in] nof_actions   - The number of actions returned for the name in bcm_action.
* \param [out] bcm_action   - Array with DNX_FIELD_ACTION_MAX_ACTION_PER_VM elements.
*                             List of DNX actions used for the name.
* \return
*   shr_error_e             - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_name_to_action(
    int unit,
    const char name[DBAL_MAX_STRING_LENGTH],
    int *nof_actions,
    bcm_field_action_t bcm_action[DNX_FIELD_ACTION_MAX_ACTION_PER_VM]);

/**
* \brief
*  Maps the DNX qualifier to its offset.
* \param [in] unit            - Device ID
* \param [in] stage           -Stage identifier
* \param [in] dnx_qual        - Qualifier type to check.
* \param [out] nof_mappings_p - The number of different offsets the qualifier has.
* \param [out] offsets        - Array of DNX_FIELD_QAUL_MAX_NOF_MAPPINGS offsets, first nof_mappings_p are valid.
* \return
*   shr_error_e - Error Type
* \remark
*   * User defined qulifiers don't have any offset. As we don't have a definition of an illegal offset, we return 0.
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_qual_offset(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    int *nof_mappings_p,
    int offsets[DNX_FIELD_QAUL_MAX_NOF_MAPPINGS]);

/**
* \brief
*  Maps the DNX LR qualifier to its offset within the LR qualifier.
* \param [in] unit            - Device ID
* \param [in] stage           - Stage identifier
* \param [in] dnx_qual        - LR qualifier to check.
* \param [out] offset_p       - Offset of LR qualifier within the LR qualifier qualifier
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_dnx_lr_qual_offset_in_lr_qual(
    int unit,
    dnx_field_stage_e stage,
    dnx_field_qual_t dnx_qual,
    int *offset_p);

/**
* \brief
*  Maps BCM field stage to DNX field Stage
* \param [in] unit           - Device Id
* \param [in] bcm_stage      - BCM field stage
* \param [out] field_stage_p  - The mapped DNX field stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_bcm_to_dnx(
    int unit,
    bcm_field_stage_t bcm_stage,
    dnx_field_stage_e * field_stage_p);

/**
* \brief
*  Maps DNX field stage to BCM field stage
* \param [in] unit         - Device Id
* \param [in] stage  - DNX field Stage
* \param [out] bcm_stage_p  - The mapped BCM field stage
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_stage_dnx_to_bcm(
    int unit,
    dnx_field_stage_e stage,
    bcm_field_stage_t * bcm_stage_p);

/**
* \brief
*  Maps BCM field group mode to DNX field group type
* \param [in] unit           - Device Id
* \param [in] bcm_fg_type      - BCM field group mode
* \param [out] dnx_fg_type_p  - The mapped DNX field group type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_group_add
* \see
*   * None
*/
shr_error_e dnx_field_map_group_type_bcm_to_dnx(
    int unit,
    bcm_field_group_type_t bcm_fg_type,
    dnx_field_group_type_e * dnx_fg_type_p);

/**
* \brief
*  Maps DNX field group type to BCM field group mode
* \param [in] unit           - Device Id
* \param [in] dnx_fg_type      - DNX field group type
* \param [out] bcm_fg_type_p   - The mapped BCM field group mode
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_group_info_get
* \see
*   * None
*/
shr_error_e dnx_field_map_group_type_dnx_to_bcm(
    int unit,
    dnx_field_group_type_e dnx_fg_type,
    bcm_field_group_type_t * bcm_fg_type_p);

/**
* \brief
*  Maps BCM tcam bank allocation mode to DNX bcm allocation mode
* \param [in] unit                      - Device Id
* \param [in] bcm_bank_allocation_mode  - BCM bank allocation mode
* \param [out] dnx_bank_allocation_mode - DNX bank allocation mode
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_bank_allocation_mode_bcm_to_dnx(
    int unit,
    bcm_field_tcam_bank_allocation_mode_t bcm_bank_allocation_mode,
    dnx_field_tcam_bank_allocation_mode_e * dnx_bank_allocation_mode);

/**
* \brief
*  Maps DNX tcam bank allocation mode to BCM bcm allocation mode
* \param [in] unit                      - Device Id
* \param [in] dnx_bank_allocation_mode  - DNX bank allocation mode
* \param [out] bcm_bank_allocation_mode_p - BCM bank allocation mode
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_bank_allocation_mode_dnx_to_bcm(
    int unit,
    dnx_field_tcam_bank_allocation_mode_e dnx_bank_allocation_mode,
    bcm_field_tcam_bank_allocation_mode_t * bcm_bank_allocation_mode_p);

/**
* \brief
*  Maps BCM cache mode to DNX cache mode
* \param [in] unit            - Device Id
* \param [in] bcm_cache_mode  - BCM cache mode
* \param [out] dnx_cache_mode - DNX cache mode
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_cache_mode_bcm_to_dnx(
    int unit,
    bcm_field_group_cache_mode_t bcm_cache_mode,
    dnx_field_group_cache_mode_e * dnx_cache_mode);

/**
* \brief
*  Maps BCM field context compare type to
*  DNX field context compare mode
* \param [in] unit -
*  Device Id
* \param [in] bcm_context_compare_type -
*  BCM field context compare type
* \param [out] dnx_context_compare_mode_p -
*  The mapped DNX field context compare mode
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_create
* \see
*   * None
*/
shr_error_e dnx_field_map_context_compare_type_bcm_to_dnx(
    int unit,
    bcm_field_context_compare_type_t bcm_context_compare_type,
    dnx_field_context_compare_mode_e * dnx_context_compare_mode_p);

/**
* \brief
*  Maps DNX field context compare mode to
*  BCM field context compare type
* \param [in] unit -
*  Device Id
* \param [in] dnx_context_compare_mode -
*  DNX field context compare mode
* \param [out] bcm_context_compare_type_p -
*  The mapped BCM field context compare type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_mode_get
* \see
*   * None
*/
shr_error_e dnx_field_map_context_compare_type_dnx_to_bcm(
    int unit,
    dnx_field_context_compare_mode_e dnx_context_compare_mode,
    bcm_field_context_compare_type_t * bcm_context_compare_type_p);

/**
* \brief
*  Maps BCM field state opcode to
*  DNX field state opcode type
* \param [in] unit -
*  Device Id
* \param [in] bcm_state_opcode_type -
*  BCM field state opcode
* \param [out] dnx_state_opcode_mode_p -
*  The mapped DNX field state opcode
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_state_table_create
* \see
*   * None
*/
shr_error_e dnx_field_map_context_state_opcode_bcm_to_dnx(
    int unit,
    bcm_field_state_opcode_t bcm_state_opcode_type,
    dnx_field_context_state_table_opcode_e * dnx_state_opcode_mode_p);

/**
* \brief
*  Maps DNX field state opcode to
*  BCM field state opcode type
* \param [in] unit -
*  Device Id
* \param [in] dnx_state_opcode_mode -
*  DNX field state opcode
* \param [out] bcm_state_opcode_type_p -
*  The mapped BCM field state opcode
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_state_table_create
* \see
*   * None
*/
shr_error_e dnx_field_map_context_state_opcode_dnx_to_bcm(
    int unit,
    dnx_field_context_state_table_opcode_e dnx_state_opcode_mode,
    bcm_field_state_opcode_t * bcm_state_opcode_type_p);

/**
* \brief
*  Maps BCM layer type to
*  DNX layer type and parsing start type. One can be NULL.
* \param [in] unit -
*  Device Id
* \param [in] bcm_layer_type -
*  BCM layer type
* \param [out] dnx_layer_type -
*  The mapped DNX layer type. If NULL not used.
* \param [out] parsing_start_type -
*  The mapped parsing start type. If NULL not used.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_layer_type_bcm_to_dnx(
    int unit,
    bcm_field_layer_type_t bcm_layer_type,
    dbal_enum_value_field_layer_types_e * dnx_layer_type,
    dbal_enum_value_field_parsing_start_type_encoding_e * parsing_start_type);

/**
* \brief
*  Maps BCM l2 format to
*  DNX l2 format
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM l2 format
* \param [out] dnx_data -
*  The mapped DNX l2 format
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_l2_format(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps BCM tunnel type to
*  DNX tunnel type
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM tunnel type
* \param [out] dnx_data -
*  The mapped DNX tunnel type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_tunnel_type(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps BCM additional header to
*  DNX additional header
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM additional header
* \param [out] dnx_data -
*  The mapped DNX additional header
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_ip6_additional_header(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps BCM rep copy type to
*  DNX rep copy type
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM rep copy type
* \param [out] dnx_data -
*  The mapped DNX rep copy type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_rep_copy_type(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps DNX layer type to
*  BCM layer type
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM layer type
* \param [out] dnx_data -
*  The mapped DNX layer type
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_forwarding_context(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps BCM ACE context value to
*  DNX ACE context value
* \param [in] unit -
*  Device Id
* \param [in] flags for conversion
* \param [in] core - Identifier of core.
* \param [in] bcm_data -
*  BCM ACE context value
* \param [out] dnx_data -
*  The mapped DNX ACE context value
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_convert_ace_context(
    int unit,
    uint32 flags,
    int core,
    uint32 *bcm_data,
    uint32 *dnx_data);

/**
* \brief
*  Maps BCM layer type to
*  DNX layer type
* \param [in] unit -
*  Device Id
* \param [in] dbal_layer_type -
*  DNX layer type, DBAL enum
* \param [out] bcm_layer_type_p -
*  The mapped BCM layer type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) dnx_field_presel_data_dnx_to_bcm_convert
* \see
*   * None
*/
shr_error_e dnx_field_map_layer_type_dnx_to_bcm(
    int unit,
    dbal_enum_value_field_layer_types_e dbal_layer_type,
    bcm_field_layer_type_t * bcm_layer_type_p);

/**
* \brief
*  Maps DNX Vlan format to
*  BCM vlan format
* \param [in] unit -
*  Device Id
* \param [in] dbal_vlan_format -
*  DNX vlan format, DBAL enum
* \param [out] bcm_vlan_format_p -
*  The mapped BCM vlan format
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) dnx_field_presel_data_dnx_to_bcm_convert
* \see
*   * None
*/
shr_error_e dnx_field_map_vlan_format_dnx_to_bcm(
    int unit,
    dbal_enum_value_field_incoming_tag_structure_e dbal_vlan_format,
    uint32 *bcm_vlan_format_p);

/**
* \brief
*  Maps BCM qual input type to
*  DNX qual input type
* \param [in] unit -
*  Device Id
* \param [in] dnx_input_type -
*  DNX qual input type
* \param [out] bcm_input_type_p -
*  The mapped BCM qual input type
* \return
*   shr_error_e - Error Type
* \see
*   * None
*/
shr_error_e dnx_field_map_qual_input_type_dnx_to_bcm(
    int unit,
    dnx_field_input_type_e dnx_input_type,
    bcm_field_input_types_t * bcm_input_type_p);

/**
 * \brief
 *  Maps BCM qualifier and attach info to DNX qualifier and attach info.
 * \param [in] unit - Device Id
 * \param [in] dnx_stage - Stage
 * \param [in] bcm_qual - The qualifier type.
 * \param [in] bcm_attach_info_p - BCM attach info
 * \param [out] dnx_qual_p - The mapped DNX qualifier
 * \param [out] dnx_attach_info_p - The mapped DNX attach info
 * \return
 *   shr_error_e - Error Type
 * \see
 *   * None
 */
shr_error_e dnx_field_map_qual_with_attach_info_bcm_to_dnx(
    int unit,
    dnx_field_stage_e dnx_stage,
    bcm_field_qualify_t bcm_qual,
    bcm_field_qualify_attach_info_t * bcm_attach_info_p,
    dnx_field_qual_t * dnx_qual_p,
    dnx_field_qual_attach_info_t * dnx_attach_info_p);

/**
 * \brief
 *  Maps DNX qualifier and attach info to BCM qualifier and attach info.
 * \param [in] unit - Device Id
 * \param [in] dnx_stage - Stage
 * \param [in] dnx_qual - DNX qualifier
 * \param [in] dnx_attach_info_p - DNX attach info
 * \param [out] bcm_qual_p - The mapped BCM qualifier.
 * \param [out] bcm_attach_info_p - The mapped BCM attach info
 * \return
 *   shr_error_e - Error Type
 * \see
 *   * None
 */
shr_error_e dnx_field_map_qual_with_attach_info_dnx_to_bcm(
    int unit,
    dnx_field_stage_e dnx_stage,
    dnx_field_qual_t dnx_qual,
    dnx_field_qual_attach_info_t * dnx_attach_info_p,
    bcm_field_qualify_t * bcm_qual_p,
    bcm_field_qualify_attach_info_t * bcm_attach_info_p);

/**
* \brief
*  Maps BCM compare id input type to
*  DNX compare ID type
* \param [in] unit -
*  Device Id
* \param [in] compare_id -
*  BCM compare ID
* \param [out] dnx_compare_id_p -
*  The mapped DNX compare Id
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_group_context_attach
* \see
*   * None
*/
shr_error_e dnx_field_map_compare_id_bcm_to_dnx(
    int unit,
    int compare_id,
    dnx_field_group_compare_id_e * dnx_compare_id_p);

/**
* \brief
*       Maps BCM context param set to dbal parameters
* \param [in] unit - Device Id
* \param [in] bcm_stage - bcm stage id
* \param [in] context_id - context id
  \param [in] bcm_context_param_set_p - pointer to structure containing all details for context parameter setting
  \param [out] field_dbal_entry_p - pointer to the structure that should be filled by the routine
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_context_param_set
* \see
*   * None
*/
shr_error_e dnx_field_map_context_param_bcm_to_dnx(
    int unit,
    bcm_field_stage_t bcm_stage,
    dnx_field_context_t context_id,
    bcm_field_context_param_info_t * bcm_context_param_set_p,
    dnx_field_dbal_entry_t * field_dbal_entry_p);

/**
* \brief
*  Maps BCM FEM extraction output source type to
*  DNX FEM bit format.
* \param [in] unit -
*  Device Id
* \param [in] bcm_fem_ext_output_src_type -
*  BCM FEM extraction output source type.
* \param [out] dnx_fem_bit_format_p -
*  The mapped DNX FEM bit format.
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_fem_action_add()
* \see
*   * None
*/
shr_error_e dnx_field_map_fem_ext_output_src_type_bcm_to_dnx(
    int unit,
    bcm_field_fem_extraction_output_source_type_t bcm_fem_ext_output_src_type,
    dnx_field_fem_bit_format_e * dnx_fem_bit_format_p);

/**
* \brief
*  Maps DNX FEM bit format to
*  BCM FEM extraction output source type.
* \param [in] unit -
*  Device Id
* \param [in] dnx_fem_bit_format -
*  DNX FEM bit format.
* \param [out] bcm_fem_ext_output_src_type_p -
*  The mapped BCM FEM extraction output source type.
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_fem_action_info_get()
* \see
*   * None
*/
shr_error_e dnx_field_map_fem_ext_output_src_type_dnx_to_bcm(
    int unit,
    dnx_field_fem_bit_format_e dnx_fem_bit_format,
    bcm_field_fem_extraction_output_source_type_t * bcm_fem_ext_output_src_type_p);

/**
* \brief
*  Maps BCM Hash Function to DBAL hash function ENUMS
* \param [in] unit              - Device Id.
* \param [in] bcm_hash_func     - BCM Hash Function Enum.
* \param [out] dbal_hash_func_p - DBAL Hash Function Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_func_bcm_to_dbal(
    int unit,
    bcm_field_context_hash_function_t bcm_hash_func,
    dbal_enum_value_field_context_hash_function_e * dbal_hash_func_p);

/**
* \brief
*  Maps DBAL Hash Function to BCM hash function ENUMS
* \param [in] unit              - Device Id.
* \param [in] dbal_hash_func - DBAL Hash Function Enum.
* \param [out] bcm_hash_func_p     - BCM Hash Function Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_func_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_context_hash_function_e dbal_hash_func,
    bcm_field_context_hash_function_t * bcm_hash_func_p);

/**
* \brief
*  Maps BCM Hahsing LB key to DBAL Hashing LB key ENUMS
* \param [in] unit                - Device Id.
* \param [in] bcm_hash_lb_key     - BCM Hashing LB key Enum.
* \param [out] dbal_hash_lb_key_p - DBAL Hashing LB key Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_lb_key_bcm_to_dbal(
    int unit,
    bcm_field_context_hash_action_key_t bcm_hash_lb_key,
    dbal_enum_value_field_field_hash_lb_key_e * dbal_hash_lb_key_p);

/**
* \brief
*  Maps DBAL Hahsing LB key to BCM Hashing LB key ENUMS
* \param [in] unit                - Device Id.
* \param [in] dbal_hash_lb_key - DBAL Hashing LB key Enum.
* \param [out] bcm_hash_lb_key_p     - BCM Hashing LB key Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_lb_key_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_field_hash_lb_key_e dbal_hash_lb_key,
    bcm_field_context_hash_action_key_t * bcm_hash_lb_key_p);

/**
* \brief
*  Maps BCM Hash Action to DNX Hash Action ENUMS
* \param [in] unit                 - Device Id.
* \param [in] bcm_hash_action      - BCM Hash Action Enum.
* \param [out] dbal_hash_action_p  - DBAL Hash Action Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_action_bcm_to_dbal(
    int unit,
    bcm_field_context_hash_action_value_t bcm_hash_action,
    dbal_enum_value_field_hash_action_e * dbal_hash_action_p);

/**
* \brief
*  Maps DBAL Hash Action to BCM Hash Action ENUMS
* \param [in] unit                - Device Id.
* \param [in] dbal_hash_action    - DBAL Hash Action Enum.
* \param [out] bcm_hash_action_p  - BCM Hash Action Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_action_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_hash_action_e dbal_hash_action,
    bcm_field_context_hash_action_value_t * bcm_hash_action_p);

/**
* \brief
*  Maps CRC Select Action to DBAL CRC Select ENUMS
* \param [in] unit                - Device Id.
* \param [in] bcm_crc_select      - BCM CRC Select Enum.
* \param [out] dbal_crc_select_p  - DBAL CRC Select Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_crc_select_bcm_to_dbal(
    int unit,
    bcm_field_crc_select_t bcm_crc_select,
    dbal_enum_value_field_crc_select_e * dbal_crc_select_p);

/**
* \brief
*  Maps DBAL CRC Select to BCM CRC Select ENUMS
* \param [in] unit                - Device Id.
* \param [in] dbal_crc_select     - DBAL CRC Select Enum.
* \param [out] bcm_crc_select_p   - BCM CRC Select Enum.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_crc_select_dbal_to_bcm(
    int unit,
    dbal_enum_value_field_crc_select_e dbal_crc_select,
    bcm_field_crc_select_t * bcm_crc_select_p);

/**
* \brief
*  Maps BCM range info to DNX range info without printing an error message if not found.
* \param [in] unit -
*  Device Id
* \param [in] bcm_range_type -
*  BCM range type
* \param [out] dnx_range_type_p -
*  The mapped DNX range type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_range_set
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_bcm_to_dnx_int(
    int unit,
    bcm_field_range_type_t bcm_range_type,
    dnx_field_range_type_e * dnx_range_type_p);

/**
* \brief
*  Maps BCM range info to
*  DNX range info
* \param [in] unit -
*  Device Id
* \param [in] bcm_range_type -
*  BCM range type
* \param [out] dnx_range_type_p -
*  The mapped DNX range type
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_range_set
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_bcm_to_dnx(
    int unit,
    bcm_field_range_type_t bcm_range_type,
    dnx_field_range_type_e * dnx_range_type_p);
/**
* \brief
*  Maps DNX range info to
*  BCM range info.
* \param [in] unit -
*  Device Id
* \param [in] dnx_range_type -
*  DNX range type
* \param [out] bcm_range_type_p -
*  The mapped BCM range tpe
* \return
*   shr_error_e - Error Type
* \remark
*   * Used by (for example) bcm_dnx_field_range_info_get
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_dnx_to_bcm(
    int unit,
    dnx_field_range_type_e dnx_range_type,
    bcm_field_range_type_t * bcm_range_type_p);

/**
* \brief
*  Provides mapped information about a range type for legacy range types
* \param [in] unit      - Device Id.
* \param [in] field_stage - The Field stage.
* \param [in] dnx_range_type    - The range type
* \param [out] range_type_info_p - The information about the range type.
* \return
*   shr_error_e - Error Type
* \see
*   * None
*/
shr_error_e dnx_field_map_range_type_info_legacy(
    int unit,
    dnx_field_stage_e field_stage,
    dnx_field_range_type_e dnx_range_type,
    dnx_field_map_range_type_info_t * range_type_info_p);

/**
* \brief
*  Maps Apptype (BCM ID) to OPCODE ID (DNX ID). Does not print an error if no such Apptype found,
*  just returns E_NOT_FOUND.
* \param [in] unit     - Device Id
* \param [in] app_type - AppType
* \param [out] opcode_id_p - KBP OPCODE ID
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_apptype_to_opcode_bcm_to_dnx_int(
    int unit,
    bcm_field_AppType_t app_type,
    uint32 *opcode_id_p);

/**
* \brief
*  Maps Apptype (BCM ID) to OPCODE ID (DNX ID)
* \param [in] unit     - Device Id
* \param [in] app_type - AppType
* \param [out] opcode_id_p - OPCODE ID
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_apptype_to_opcode_bcm_to_dnx(
    int unit,
    bcm_field_AppType_t app_type,
    uint32 *opcode_id_p);

/**
* \brief
*  Maps OPCODE ID (DNX ID) to Apptype (BCM ID).
* \param [in] unit     - Device Id
* \param [in] opcode_id - OPCODE ID
* \param [out] app_type_p - AppType
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_to_apptype_dnx_to_bcm(
    int unit,
    uint32 opcode_id,
    bcm_field_AppType_t * app_type_p);

/**
* \brief        Get the CS profile for a certain static (predefined) opcode.
* \param [in] unit     - Device Id
* \param [in] opcode_id - OPCODE ID
* \param [out] cs_profile_id_p - FWD context profile Id
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_static_opcode_to_profile_get(
    int unit,
    uint32 opcode_id,
    uint32 *cs_profile_id_p);

/**
* \brief        Get the CS profile for a certain Apptype.
* \param [in] unit     - Device Id
* \param [in] opcode_id - The opcode (of the apptype)
* \param [out] cs_profile_id_p - FWD context profile Id
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_to_profile_get(
    int unit,
    uint32 opcode_id,
    uint32 *cs_profile_id_p);

/**
* \brief        Get the Apptype that uses a certain CS profile
* \param [in] unit     - Device Id
* \param [in] cs_profile_id - FWD context profile Id
* \param [out] opcode_id_p - The opcode (of the apptype)
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_profile_to_opcode_get(
    int unit,
    uint32 cs_profile_id,
    uint32 *opcode_id_p);

/**
* \brief        Get the FWD contexts used by an Apptype for lookups
* \param [in] unit     - Device Id
* \param [in] opcode_id - The opcode (of the apptype)
* \param [out] nof_contexts_p - The number of FWD context used by the apptype.
* \param [out] lkp_fwd_contexts - The FWD contexts used by the apptype for lookup configuration.
*                                 An array with DNX_DATA_MAX_FIELD_EXTERNAL_TCAM_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE elements.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_to_lookup_fwd_contexts(
    int unit,
    uint32 opcode_id,
    int *nof_contexts_p,
    dnx_field_context_t lkp_fwd_contexts[DNX_DATA_MAX_FIELD_EXTERNAL_TCAM_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE]);

/**
* \brief        Get the FWD contexts used by an Apptype for context selection for ACL.
* \param [in] unit     - Device Id
* \param [in] opcode_id - The opcode (of the apptype)
* \param [out] nof_contexts_p - The number of FWD context used by the apptype.
* \param [out] cs_fwd_contexts - The FWD contexts used by the apptype for CS.
*                                An array with DNX_DATA_MAX_FIELD_EXTERNAL_TCAM_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE elements.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_to_cs_fwd_contexts(
    int unit,
    uint32 opcode_id,
    int *nof_contexts_p,
    dnx_field_context_t cs_fwd_contexts[DNX_DATA_MAX_FIELD_EXTERNAL_TCAM_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE]);

/**
* \brief        Get the ACL contexts used by an Apptype.
* \param [in] unit     - Device Id
* \param [in] opcode_id - The opcode (of the apptype)
* \param [in] is_fwd2 - If TRUE, the ACL contexts in iFWD2. If FALSE, the ACL contexts in iFWD1.
* \param [out] nof_contexts_p - The number of FWD context used by the apptype.
* \param [out] acl_contexts - The ACL contexts used by the apptype.
*                             An array with DNX_DATA_MAX_FIELD_EXTERNAL_TCAM_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE elements.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_to_acl_contexts(
    int unit,
    uint32 opcode_id,
    int is_fwd2,
    int *nof_contexts_p,
    dnx_field_context_t acl_contexts[DNX_DATA_MAX_FIELD_EXTERNAL_TCAM_MAX_FWD_CONTEXT_NUM_FOR_ONE_APPTYPE]);

/**
* \brief        Get whether device lock has already occurred.
* \param [in] unit - Device Id
* \param [in] opcode_id - The opcode (of the apptype)
* \param [out] is_user_defined_p - TRUE if the opcode is user defined and not predefined.
* \param [out] user_defined_apptype_relative_index_p - If is_user_defined_p is TRUE, the index in SW state of the user defined opcode/apptype.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_is_dynamic(
    int unit,
    uint32 opcode_id,
    uint8 *is_user_defined_p,
    uint8 *user_defined_apptype_relative_index_p);

/**
* \brief        Get the opocde based on the relative user defined index.
* \param [in] unit - Device Id
* \param [in] user_defined_apptype_relative_index - The opcode relative to the first dynamic opcode
*                                                   (or apptype relative to the first user defined apptype)
* \param [out] user_defined_opcode_p - The user defined opcode.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_opcode_dynamic_index_to_opcode(
    int unit,
    uint32 user_defined_apptype_relative_index,
    uint32 *user_defined_opcode_p);

/**
* \brief        Get whether device lock has already occurred.
* \param [in] unit     - Device Id
* \param [out] device_locked_p - If device lock happened.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_is_device_locked(
    int unit,
    int *device_locked_p);

/**
* \brief        Get whether external TCAM device is in use.
* \param [in] unit     - Device Id
* \param [out] external_tcam_exists_p - If external TCAM is in use.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_is_external_tcam_available(
    int unit,
    int *external_tcam_exists_p);

/**
* \brief        Get opcdoe id accrding to the contexts
* \param [in] unit            - Device ID
* \param [in] lkp_fwd_context - fwd_context
* \param [in] acl_context     - acl_context.
* \param [out] opcode_id_p    - opcode_id of the apptype.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_contexts_to_opcode_get(
    int unit,
    uint32 lkp_fwd_context,
    uint32 acl_context,
    uint32 *opcode_id_p);

/**
* \brief        Get the type of a port profile.
* \param [in] unit     - Device Id
* \param [in] bcm_port_class - The BCM class of port profile
* \param [out] port_profile_type_p - The DNX type of port profile class
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_port_profile_type_get(
    int unit,
    bcm_port_class_t bcm_port_class,
    dnx_field_port_porfile_type_e * port_profile_type_p);

/**
* \brief        Get the properties of a port profile. Only relevant to port types that relate to a TM/PP port.
* \param [in] unit     - Device Id
* \param [in] bcm_port_class - The BCM class of port profile
* \param [out] port_profile_info_p - Information regarding the port profile mapping.
* \return
*   shr_error_e - Error Type
* \remark
* \see
*   * None
*/
shr_error_e dnx_field_map_port_profile_info_get(
    int unit,
    bcm_port_class_t bcm_port_class,
    dnx_field_map_port_profile_info_t * port_profile_info_p);

/**
 * \brief  Get the placement of the state table key (or if is is being accressd by ACR).
 * \param [in] unit     - Device Id
 * \param [out] use_acr_p - If TRUE, state table is accress by the state table actions and not by any key.
 * \param [out] stage_p - If use_acr_p is FALSE, the stage from which the state tabke is accessed.
 * \param [out] key_id_p - If use_acr_p is FALSE, the key from which the state tabke is accessed.
 * \param [out] lsb_on_key_p - If use_acr_p is FALSE, the lsb on the key where the state table key is read from.
 * \param [out] size_bits_p - If use_acr_p is FALSE, the size in bits on the key where the state table key is read from.
 * \return
 *   shr_error_e - Error Type
 * \remark
 * \see
 *   * None
 */
shr_error_e dnx_field_map_state_table_source_get(
    int unit,
    int *use_acr_p,
    dnx_field_stage_e * stage_p,
    dbal_enum_value_field_field_key_e * key_id_p,
    int *lsb_on_key_p,
    int *size_bits_p);

/**
* \brief
*  Get the Key-Id for a given compare pair,
*  First pair gets F and G keys,
*  Second pair gets H and I keys
* \param [in] unit   - Device id
* \param [in] compare_pair  - First/Second Pair
* \param [out] key_id_1_p  - F or H according to First/Second pair
* \param [out] key_id_2_p  - G or I according to First/Second pair
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_compare_key_id_get(
    int unit,
    dnx_field_context_compare_mode_pair_e compare_pair,
    dnx_field_key_id_t *key_id_1_p,
    dnx_field_key_id_t *key_id_2_p);

/**
* \brief
*  Get the Key-Id used for Hash capability of a context.
* \param [in] unit       - Device id
* \param [out] key_id_p  - The key/keys used by Compare.
* \return
*   shr_error_e - Error Type
* \remark
*   * None
* \see
*   * None
*/
shr_error_e dnx_field_map_hash_key_id_get(
    int unit,
    dnx_field_key_id_t *key_id_p);

/**
* \brief
* Get field map vw qual info
*
* \param [in] unit               - Device id
* \param [in] qual_id            - Qual id
* \param [out] vw_qual_info_p    - Pointer to vw qual info.
*\return
*   shr_error_e - Error Type
*\see
*   bcm_error_e
*/
shr_error_e dnx_field_map_vw_qual_info_get(
    int unit,
    dnx_field_qual_id_t qual_id,
    dnx_field_vw_qual_info_t * vw_qual_info_p);

/**
* \brief
* Get field map vw action info
*
* \param [in] unit               - Device id
* \param [in] action_id          - Action id
* \param [out] vw_action_info_p  - Pointer to vw action info.
*\return
*   shr_error_e - Error Type
*\see
*   bcm_error_e
*/
shr_error_e dnx_field_map_vw_action_info_get(
    int unit,
    dnx_field_action_id_t action_id,
    dnx_field_vw_action_info_t * vw_action_info_p);

/**
* \brief
* Get field map per vw action info
*
* \param [in] unit               - Device id
* \param [in] action_id          - Action id
* \param [out] per_vw_action_info_p  - Pointer to per vw action info.
*\return
*   shr_error_e - Error Type
*\see
*   bcm_error_e
*/
shr_error_e dnx_field_map_per_vw_action_info_get(
    int unit,
    dnx_field_action_id_t action_id,
    dnx_field_per_vw_action_info_t * per_vw_action_info_p);

/**
 * \brief
 * opcode from a predefined apptype. For default image only.
 *
 * \param [in] unit                   - Device id
 * \param [in] apptype                - Pre defined apptype.
 * \param [out] static_opcode_id_p    - The opcode mapped to the predefined apptype.
 *\return
 *   shr_error_e - Error Type
 *\see
 *   bcm_error_e
 */
shr_error_e dnx_field_map_standard_1_predefined_apptype_to_opcode_get(
    int unit,
    bcm_field_AppType_t apptype,
    uint32 *static_opcode_id_p);

/* } */

#endif
