/** \file jr2_a0_data_sch.c
 * 
 * DEVICE DATA - SCH
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_COSQ
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_sch.h>
#include <bcm_int/dnx/cosq/scheduler/scheduler.h>
#include <bcm_int/dnx/algo/sch/sch_alloc_mngr.h>
#include <shared/utilex/utilex_integer_arithmetic.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_fabric.h>
/*
 * }
 */

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: general
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_lag_scheduler_supported_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int feature_index = dnx_data_sch_general_lag_scheduler_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_fsm_modes_config_supported_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int feature_index = dnx_data_sch_general_fsm_modes_config_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define nof_slow_profiles
 * define info:
 * Number of slow profiles
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_nof_slow_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int define_index = dnx_data_sch_general_define_nof_slow_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_slow_levels
 * define info:
 * Number of slow levels
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_nof_slow_levels_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int define_index = dnx_data_sch_general_define_nof_slow_levels;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cycles_per_credit_token
 * define info:
 * Number of of cycles between credit tokens of the same flow
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_cycles_per_credit_token_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int define_index = dnx_data_sch_general_define_cycles_per_credit_token;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 12;

    /* Set value */
    define->data = 12;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_fmq_class
 * define info:
 * Number of FMQ class
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_nof_fmq_class_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int define_index = dnx_data_sch_general_define_nof_fmq_class;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric port_priority_propagation_version
 * numeric info:
 * Port priority propagation version
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_port_priority_propagation_version_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int define_index = dnx_data_sch_general_define_port_priority_propagation_version;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = DNX_SCHEDULER_PORT_PRIORITY_PROPAGATION_V1;

    /* Set value */
    define->data = DNX_SCHEDULER_PORT_PRIORITY_PROPAGATION_V1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric port_priority_propagation_enable
 * numeric info:
 * Enable ports to be created with port priority propagation
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_port_priority_propagation_enable_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int define_index = dnx_data_sch_general_define_port_priority_propagation_enable;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_PORT_SCH_PRIORITY_PROPAGATION_ENABLE;
    define->property.doc = 
        "\n"
        "Enable port priority propagation functionality.\n"
        "Default: 0 (disabled)\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_enable;
    define->property.method_str = "enable";

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which map key to table indexlow_rate_factor_to_dbal_enum
 * Module - 'sch', Submodule - 'general', table - 'low_rate_factor_to_dbal_enum'
 * Mapping keys to indices - relevant in table map mode
 * 
 * \param [in] unit - Unit #
 * \param [in] key0_val - first key value - if exist
 * \param [in] key1_val - second key value - if exist
 * \param [out] key0_index - first key index- if exist
 * \param [out] key1_index - second key index - if exist
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_low_rate_factor_to_dbal_enum_key_map(
    int unit,
    int key0_val,
    int key1_val,
    int *key0_index,
    int *key1_index)
{
    SHR_FUNC_INIT_VARS(unit);

    switch (key0_val)
    {
        case 64:
            *key0_index = 0;
            break;
        case 32:
            *key0_index = 1;
            break;
        default:
            *key0_index = -1;
            break;
    }

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which maps table index to key low_rate_factor_to_dbal_enum
 * Module - 'sch', Submodule - 'general', table - 'low_rate_factor_to_dbal_enum'
 * Mapping indices to keys - relevant in table map mode
 * 
 * \param [in] unit - Unit #
 * \param [in] key0_index - first key index - if exist
 * \param [in] key1_index - second key index - if exist
 * \param [out] key0_val - first key value- if exist
 * \param [out] key1_val - second key value - if exist
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_low_rate_factor_to_dbal_enum_key_reverse_map(
    int unit,
    int key0_index,
    int key1_index,
    int *key0_val,
    int *key1_val)
{
    SHR_FUNC_INIT_VARS(unit);

    switch (key0_index)
    {
        case 0:
            *key0_val = 64;
            break;
        case 1:
            *key0_val = 32;
            break;
        default:
            *key0_val = -1;
            break;
    }

    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table low_rate_factor_to_dbal_enum
 * Module - 'sch', Submodule - 'general', table - 'low_rate_factor_to_dbal_enum'
 * mapping low rate factor to dbal enum
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_low_rate_factor_to_dbal_enum_set(
    int unit)
{
    int low_rate_factor_index;
    dnx_data_sch_general_low_rate_factor_to_dbal_enum_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int table_index = dnx_data_sch_general_table_low_rate_factor_to_dbal_enum;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "-1";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_general_low_rate_factor_to_dbal_enum_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_sch_general_table_low_rate_factor_to_dbal_enum");

    /* Store Default Values */
    default_data = (dnx_data_sch_general_low_rate_factor_to_dbal_enum_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->dbal_enum = -1;
    default_data->valid = 0;
    /* Set Default Values */
    for (low_rate_factor_index = 0; low_rate_factor_index < table->keys[0].size; low_rate_factor_index++)
    {
        data = (dnx_data_sch_general_low_rate_factor_to_dbal_enum_t *) dnxc_data_mgmt_table_data_get(unit, table, low_rate_factor_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    table->key_map = jr2_a0_dnx_data_sch_general_low_rate_factor_to_dbal_enum_key_map;
    table->key_map_reverse = jr2_a0_dnx_data_sch_general_low_rate_factor_to_dbal_enum_key_reverse_map;
    /*
     * Set Values - Entries
     */
    data = (dnx_data_sch_general_low_rate_factor_to_dbal_enum_t *) dnxc_data_mgmt_table_data_get(unit, table, 32, 0);
    data->dbal_enum = DBAL_ENUM_FVAL_LOW_RATE_FACTOR_LOW_RATE_FACTOR_32;
    data->valid = 1;
    data = (dnx_data_sch_general_low_rate_factor_to_dbal_enum_t *) dnxc_data_mgmt_table_data_get(unit, table, 64, 0);
    data->dbal_enum = DBAL_ENUM_FVAL_LOW_RATE_FACTOR_LOW_RATE_FACTOR_64;
    data->valid = 1;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table dbal_enum_to_low_rate_factor
 * Module - 'sch', Submodule - 'general', table - 'dbal_enum_to_low_rate_factor'
 * mapping dbal enum to low rate factor
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_dbal_enum_to_low_rate_factor_set(
    int unit)
{
    int dbal_enum_index;
    dnx_data_sch_general_dbal_enum_to_low_rate_factor_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int table_index = dnx_data_sch_general_table_dbal_enum_to_low_rate_factor;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DBAL_NOF_ENUM_LOW_RATE_FACTOR_VALUES;
    table->info_get.key_size[0] = DBAL_NOF_ENUM_LOW_RATE_FACTOR_VALUES;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_general_dbal_enum_to_low_rate_factor_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_sch_general_table_dbal_enum_to_low_rate_factor");

    /* Store Default Values */
    default_data = (dnx_data_sch_general_dbal_enum_to_low_rate_factor_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->low_rate_factor = 0;
    /* Set Default Values */
    for (dbal_enum_index = 0; dbal_enum_index < table->keys[0].size; dbal_enum_index++)
    {
        data = (dnx_data_sch_general_dbal_enum_to_low_rate_factor_t *) dnxc_data_mgmt_table_data_get(unit, table, dbal_enum_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DBAL_ENUM_FVAL_LOW_RATE_FACTOR_LOW_RATE_FACTOR_32 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_dbal_enum_to_low_rate_factor_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LOW_RATE_FACTOR_LOW_RATE_FACTOR_32, 0);
        data->low_rate_factor = 32;
    }
    if (DBAL_ENUM_FVAL_LOW_RATE_FACTOR_LOW_RATE_FACTOR_64 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_dbal_enum_to_low_rate_factor_t *) dnxc_data_mgmt_table_data_get(unit, table, DBAL_ENUM_FVAL_LOW_RATE_FACTOR_LOW_RATE_FACTOR_64, 0);
        data->low_rate_factor = 64;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table slow_rate_max_bucket
 * Module - 'sch', Submodule - 'general', table - 'slow_rate_max_bucket'
 * Max token bucket values per slow rate
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_general_slow_rate_max_bucket_set(
    int unit)
{
    int idx_index;
    dnx_data_sch_general_slow_rate_max_bucket_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_general;
    int table_index = dnx_data_sch_general_table_slow_rate_max_bucket;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 7;
    table->info_get.key_size[0] = 7;

    /* Info - default values */
    table->values[0].default_val = "-1";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_general_slow_rate_max_bucket_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_sch_general_table_slow_rate_max_bucket");

    /* Store Default Values */
    default_data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->rate = -1;
    default_data->max_bucket = 0;
    /* Set Default Values */
    for (idx_index = 0; idx_index < table->keys[0].size; idx_index++)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, idx_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->rate = 0;
        data->max_bucket = 1;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->rate = 9781;
        data->max_bucket = 2;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->rate = 18386;
        data->max_bucket = 3;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->rate = 33271;
        data->max_bucket = 4;
    }
    if (4 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
        data->rate = 57806;
        data->max_bucket = 5;
    }
    if (5 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
        data->rate = 95507;
        data->max_bucket = 6;
    }
    if (6 < table->keys[0].size)
    {
        data = (dnx_data_sch_general_slow_rate_max_bucket_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
        data->rate = 146926;
        data->max_bucket = 7;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: ps
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define min_priority_for_tcg
 * define info:
 * Minimal port priority supporting tcg
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_ps_min_priority_for_tcg_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_ps;
    int define_index = dnx_data_sch_ps_define_min_priority_for_tcg;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_nof_tcg
 * define info:
 * Maximal number of TCGs in a port scheduler
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_ps_max_nof_tcg_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_ps;
    int define_index = dnx_data_sch_ps_define_max_nof_tcg;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_hrs_in_ps
 * define info:
 * Number of HRs in port scheduler
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_ps_nof_hrs_in_ps_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_ps;
    int define_index = dnx_data_sch_ps_define_nof_hrs_in_ps;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_tcg_weight
 * define info:
 * Maximal TCG EIR weight
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_ps_max_tcg_weight_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_ps;
    int define_index = dnx_data_sch_ps_define_max_tcg_weight;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1023;

    /* Set value */
    define->data = 1023;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tc_tcg_calendar_access_period
 * define info:
 * Access period of TC/TCG calendars
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_ps_tc_tcg_calendar_access_period_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_ps;
    int define_index = dnx_data_sch_ps_define_tc_tcg_calendar_access_period;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_port_rate_mbps
 * numeric info:
 * maximal rate an port can drive (in MBits/sec)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_ps_max_port_rate_mbps_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_ps;
    int define_index = dnx_data_sch_ps_define_max_port_rate_mbps;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 600000;

    /* Set value */
    define->data = 600000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_MAXIMAL_PORT_BANDWIDTH;
    define->property.doc = 
        "\n"
        "Maximal bandwidth of a single port in Mega-bits-per-second.\n"
        "Used to improve granularity of SCH port-TC and port-TCG shapers.\n"
        "Default: 600000 (600G)\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_range;
    define->property.method_str = "range";
    define->property.range_min = 0;
    define->property.range_max = dnx_data_sch.interface.max_if_rate_mbps_get(unit);

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_burst
 * numeric info:
 * Maximal burst of TC/TCG port shapers
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_ps_max_burst_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_ps;
    int define_index = dnx_data_sch_ps_define_max_burst;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = utilex_power_of_2(dnx_data_sch.dbal.ps_shaper_max_burst_bits_get(unit)) - 1;

    /* Set value */
    define->data = utilex_power_of_2(dnx_data_sch.dbal.ps_shaper_max_burst_bits_get(unit)) - 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: flow
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_interdigitated_supported_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int feature_index = dnx_data_sch_flow_interdigitated_supported;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define nof_hr
 * define info:
 * Number of HR elements per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_hr_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_hr;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 512;

    /* Set value */
    define->data = 512;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_cl
 * define info:
 * Number of CL elements per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_cl_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_cl;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8*1024;

    /* Set value */
    define->data = 8*1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_se
 * define info:
 * Number of scheduling elements per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_se_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_se;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32*1024;

    /* Set value */
    define->data = 32*1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_flows
 * define info:
 * Number of flows per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_flows_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_flows;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 96*1024;

    /* Set value */
    define->data = 96*1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define region_size
 * define info:
 * Number of flows in a region
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_region_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_region_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1024;

    /* Set value */
    define->data = 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_regions
 * define info:
 * Number of regions in a core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_regions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_regions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_flows_get(unit) / dnx_data_sch.flow.region_size_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_flows_get(unit) / dnx_data_sch.flow.region_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_hr_regions
 * define info:
 * Number of hr regions in a core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_hr_regions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_hr_regions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_hr_get(unit) / 256;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_hr_get(unit) / 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_connectors_only_regions
 * define info:
 * Number of connectors-only regions per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_connectors_only_regions_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_connectors_only_regions;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (dnx_data_sch.flow.nof_flows_get(unit) - dnx_data_sch.flow.nof_se_get(unit)) / dnx_data_sch.flow.region_size_get(unit);

    /* Set value */
    define->data = (dnx_data_sch.flow.nof_flows_get(unit) - dnx_data_sch.flow.nof_se_get(unit)) / dnx_data_sch.flow.region_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define flow_in_region_mask
 * define info:
 * mask for flows in region
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_flow_in_region_mask_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_flow_in_region_mask;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x3ff;

    /* Set value */
    define->data = 0x3ff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define min_connector_bundle_size
 * define info:
 * minimal number of connectors in bundle
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_min_connector_bundle_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_min_connector_bundle_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define conn_idx_interdig_flow
 * define info:
 * first connector index in an interdigitated flow
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_conn_idx_interdig_flow_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_conn_idx_interdig_flow;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define shaper_flipflops_nof
 * define info:
 * number of Flip-Flops in flow shaper implementation in HW.                     if exp greater than (shaper_flipflops_nof - nof_manthissa_bits)) then mantissa[exp-(shaper_flipflops_nof-nof_mantissa_bits)-1: 0] == 0
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_shaper_flipflops_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_shaper_flipflops_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_flows_in_quartet_order_group
 * define info:
 * Number of flows in a quartet order group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_flows_in_quartet_order_group_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_flows_in_quartet_order_group;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_flows_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_flows_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_regions_in_quartet_order_group
 * define info:
 * Number of regions in a quartet order group
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_regions_in_quartet_order_group_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_regions_in_quartet_order_group;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_flows_in_quartet_order_group_get(unit)/dnx_data_sch.flow.region_size_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_flows_in_quartet_order_group_get(unit)/dnx_data_sch.flow.region_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_quartet_order_groups
 * define info:
 * Number of quartet order groups in a core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_quartet_order_groups_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_nof_quartet_order_groups;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_flows_get(unit)/dnx_data_sch.flow.nof_flows_in_quartet_order_group_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_flows_get(unit)/dnx_data_sch.flow.nof_flows_in_quartet_order_group_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric erp_hr
 * numeric info:
 * HR id of first ERP HR
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_erp_hr_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_erp_hr;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_hr_get(unit)-8;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_hr_get(unit)-8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric reserved_hr
 * numeric info:
 * reserved HR allocated for returned credits in LAG scheduling
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_reserved_hr_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_reserved_hr;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.erp_hr_get(unit)-1;

    /* Set value */
    define->data = dnx_data_sch.flow.erp_hr_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_se
 * numeric info:
 * Maximal Scheduling element id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_max_se_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_max_se;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_se_get(unit)-1;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_se_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_flow
 * numeric info:
 * Maximal flow id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_max_flow_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_max_flow;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_flows_get(unit)-1;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_flows_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric first_hr_region
 * numeric info:
 * First HR region
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_first_hr_region_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_first_hr_region;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_regions_get(unit) - dnx_data_sch.flow.nof_hr_regions_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_regions_get(unit) - dnx_data_sch.flow.nof_hr_regions_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric first_se_flow_id
 * numeric info:
 * Flow ID of first scheduling element
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_first_se_flow_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_first_se_flow_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_connectors_only_regions_get(unit) * dnx_data_sch.flow.region_size_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_connectors_only_regions_get(unit) * dnx_data_sch.flow.region_size_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric hr_se_id_min
 * numeric info:
 * min hr se id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_hr_se_id_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_hr_se_id_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_se_get(unit)/2 - dnx_data_sch.flow.nof_hr_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_se_get(unit)/2 - dnx_data_sch.flow.nof_hr_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric hr_se_id_max
 * numeric info:
 * max hr se id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_hr_se_id_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_hr_se_id_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_se_get(unit)/2-1;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_se_get(unit)/2-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric default_credit_source_se_id
 * numeric info:
 * SE ID of default credit source. used to mark unattached flow
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_default_credit_source_se_id_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_default_credit_source_se_id;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_se_get(unit) / 4 * 3 +                      (dnx_data_sch.flow.nof_regions_get(unit) - dnx_data_sch.flow.nof_connectors_only_regions_get(unit) -dnx_data_sch.flow.nof_hr_regions_get(unit)) * dnx_data_sch.flow.region_size_get(unit)/4;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_se_get(unit) / 4 * 3 +                      (dnx_data_sch.flow.nof_regions_get(unit) - dnx_data_sch.flow.nof_connectors_only_regions_get(unit) -dnx_data_sch.flow.nof_hr_regions_get(unit)) * dnx_data_sch.flow.region_size_get(unit)/4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric runtime_performance_optimize_enable_sched_allocation
 * numeric info:
 * enable flow properties access optimization
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_runtime_performance_optimize_enable_sched_allocation_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int define_index = dnx_data_sch_flow_define_runtime_performance_optimize_enable_sched_allocation;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1;

    /* Set value */
    define->data = 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_RUNTIME_PERFORMANCE_OPTIMIZE_ENABLE;
    define->property.doc = 
        "\n"
        "Enable flow property access runtime optimization\n"
        "In Jericho2 optimization must be enabled\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_range;
    define->property.method_str = "range";
    define->property.range_min = 1;
    define->property.range_max = 1;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table region_type
 * Module - 'sch', Submodule - 'flow', table - 'region_type'
 * flow region type
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_region_type_set(
    int unit)
{
    int core_index;
    int region_index;
    dnx_data_sch_flow_region_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int table_index = dnx_data_sch_flow_table_region_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_device.general.nof_cores_get(unit);
    table->info_get.key_size[0] = dnx_data_device.general.nof_cores_get(unit);
    table->keys[1].size = dnx_data_sch.flow.nof_regions_get(unit);
    table->info_get.key_size[1] = dnx_data_sch.flow.nof_regions_get(unit);

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_flow_region_type_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_flow_table_region_type");

    /* Store Default Values */
    default_data = (dnx_data_sch_flow_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->type = 0;
    default_data->propagation_direction = 0;
    /* Set Default Values */
    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        for (region_index = 0; region_index < table->keys[1].size; region_index++)
        {
            data = (dnx_data_sch_flow_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, region_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Property
     */
    table->property.name = "dtm_flow_mapping_mode_region";
    table->property.doc =
        "\n"
        "Configure region mode per region id:\n"
        "0: connectors only\n"
        "1: interdigitated odd\n"
        "2: interdigitated even\n"
        "3: SE only, propagation direction 0\n"
        "7: SE only, propagation direction 1\n"
        "Default: 0\n"
        "\n"
    ;
    table->property.method = dnxc_data_property_method_custom;
    table->property.method_str = "custom";

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));

    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        for (region_index = 0; region_index < table->keys[1].size; region_index++)
        {
            data = (dnx_data_sch_flow_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, region_index);
            SHR_IF_ERR_EXIT(dnx_data_property_sch_flow_region_type_read(unit, core_index, region_index, data));
        }
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table nof_remote_cores
 * Module - 'sch', Submodule - 'flow', table - 'nof_remote_cores'
 * flow region type
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_nof_remote_cores_set(
    int unit)
{
    int core_index;
    int region_index;
    dnx_data_sch_flow_nof_remote_cores_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int table_index = dnx_data_sch_flow_table_nof_remote_cores;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_device.general.nof_cores_get(unit);
    table->info_get.key_size[0] = dnx_data_device.general.nof_cores_get(unit);
    table->keys[1].size = dnx_data_sch.flow.nof_regions_get(unit);
    table->info_get.key_size[1] = dnx_data_sch.flow.nof_regions_get(unit);

    /* Info - default values */
    table->values[0].default_val = "1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_flow_nof_remote_cores_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_flow_table_nof_remote_cores");

    /* Store Default Values */
    default_data = (dnx_data_sch_flow_nof_remote_cores_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->val = 1;
    /* Set Default Values */
    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        for (region_index = 0; region_index < table->keys[1].size; region_index++)
        {
            data = (dnx_data_sch_flow_nof_remote_cores_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, region_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Property
     */
    table->property.name = "dtm_flow_nof_remote_cores_region";
    table->property.doc =
        "\n"
        "Configure region nof remote cores:\n"
        "1: one core\n"
        "2: two cores\n"
        "Default: 1\n"
        "\n"
    ;
    table->property.method = dnxc_data_property_method_custom;
    table->property.method_str = "custom";

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));

    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        for (region_index = 0; region_index < table->keys[1].size; region_index++)
        {
            data = (dnx_data_sch_flow_nof_remote_cores_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, region_index);
            SHR_IF_ERR_EXIT(dnx_data_property_sch_flow_nof_remote_cores_read(unit, core_index, region_index, data));
        }
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table quartet_type
 * Module - 'sch', Submodule - 'flow', table - 'quartet_type'
 * quartet type per group
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_quartet_type_set(
    int unit)
{
    int core_index;
    int group_index;
    dnx_data_sch_flow_quartet_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int table_index = dnx_data_sch_flow_table_quartet_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_device.general.nof_cores_get(unit);
    table->info_get.key_size[0] = dnx_data_device.general.nof_cores_get(unit);
    table->keys[1].size = dnx_data_sch.flow.nof_quartet_order_groups_get(unit);
    table->info_get.key_size[1] = dnx_data_sch.flow.nof_quartet_order_groups_get(unit);

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_flow_quartet_type_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_flow_table_quartet_type");

    /* Store Default Values */
    default_data = (dnx_data_sch_flow_quartet_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->type = 0;
    /* Set Default Values */
    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        for (group_index = 0; group_index < table->keys[1].size; group_index++)
        {
            data = (dnx_data_sch_flow_quartet_type_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, group_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Property
     */
    table->property.name = "flow_quartet_order";
    table->property.doc =
        "\n"
        "Configure the CL-FQ order of flow quartet per quartet type group\n"
        "\n"
    ;
    table->property.method = dnxc_data_property_method_custom;
    table->property.method_str = "custom";

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));

    for (core_index = 0; core_index < table->keys[0].size; core_index++)
    {
        for (group_index = 0; group_index < table->keys[1].size; group_index++)
        {
            data = (dnx_data_sch_flow_quartet_type_t *) dnxc_data_mgmt_table_data_get(unit, table, core_index, group_index);
            SHR_IF_ERR_EXIT(dnx_data_property_sch_flow_quartet_type_read(unit, core_index, group_index, data));
        }
    }
    /* Set data flags as property */
    table->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table quartet_index_conversion
 * Module - 'sch', Submodule - 'flow', table - 'quartet_index_conversion'
 * conversion of quartet index
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_flow_quartet_index_conversion_set(
    int unit)
{
    int quartet_type_index;
    dnx_data_sch_flow_quartet_index_conversion_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_flow;
    int table_index = dnx_data_sch_flow_table_quartet_index_conversion;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_SCH_FLOW_QUARTET_TYPE_NOF;
    table->info_get.key_size[0] = DNX_SCH_FLOW_QUARTET_TYPE_NOF;

    /* Info - default values */
    table->values[0].default_val = "0,1,2,3";
    table->values[1].default_val = "0,1,2,3";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_flow_quartet_index_conversion_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_sch_flow_table_quartet_index_conversion");

    /* Store Default Values */
    default_data = (dnx_data_sch_flow_quartet_index_conversion_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->flow_to_se[0] = 0;
    default_data->flow_to_se[1] = 1;
    default_data->flow_to_se[2] = 2;
    default_data->flow_to_se[3] = 3;
    default_data->se_to_flow[0] = 0;
    default_data->se_to_flow[1] = 1;
    default_data->se_to_flow[2] = 2;
    default_data->se_to_flow[3] = 3;
    /* Set Default Values */
    for (quartet_type_index = 0; quartet_type_index < table->keys[0].size; quartet_type_index++)
    {
        data = (dnx_data_sch_flow_quartet_index_conversion_t *) dnxc_data_mgmt_table_data_get(unit, table, quartet_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ < table->keys[0].size)
    {
        data = (dnx_data_sch_flow_quartet_index_conversion_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ, 0);
        data->flow_to_se[0] = 0;
        data->flow_to_se[1] = 2;
        data->flow_to_se[2] = 1;
        data->flow_to_se[3] = 3;
        data->se_to_flow[0] = 0;
        data->se_to_flow[1] = 2;
        data->se_to_flow[2] = 1;
        data->se_to_flow[3] = 3;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL < table->keys[0].size)
    {
        data = (dnx_data_sch_flow_quartet_index_conversion_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL, 0);
        data->flow_to_se[0] = 0;
        data->flow_to_se[1] = 1;
        data->flow_to_se[2] = 3;
        data->flow_to_se[3] = 2;
        data->se_to_flow[0] = 0;
        data->se_to_flow[1] = 1;
        data->se_to_flow[2] = 3;
        data->se_to_flow[3] = 2;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL < table->keys[0].size)
    {
        data = (dnx_data_sch_flow_quartet_index_conversion_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL, 0);
        data->flow_to_se[0] = 1;
        data->flow_to_se[1] = 0;
        data->flow_to_se[2] = 3;
        data->flow_to_se[3] = 2;
        data->se_to_flow[0] = 1;
        data->se_to_flow[1] = 0;
        data->se_to_flow[2] = 3;
        data->se_to_flow[3] = 2;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL < table->keys[0].size)
    {
        data = (dnx_data_sch_flow_quartet_index_conversion_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL, 0);
        data->flow_to_se[0] = 1;
        data->flow_to_se[1] = 3;
        data->flow_to_se[2] = 0;
        data->flow_to_se[3] = 2;
        data->se_to_flow[0] = 2;
        data->se_to_flow[1] = 0;
        data->se_to_flow[2] = 3;
        data->se_to_flow[3] = 1;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ < table->keys[0].size)
    {
        data = (dnx_data_sch_flow_quartet_index_conversion_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ, 0);
        data->flow_to_se[0] = 1;
        data->flow_to_se[1] = 0;
        data->flow_to_se[2] = 2;
        data->flow_to_se[3] = 3;
        data->se_to_flow[0] = 1;
        data->se_to_flow[1] = 0;
        data->se_to_flow[2] = 2;
        data->se_to_flow[3] = 3;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: se
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define default_cos
 * define info:
 * default parameter of credit source COS. Used for FQ
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_se_default_cos_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_se;
    int define_index = dnx_data_sch_se_define_default_cos;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0xfc;

    /* Set value */
    define->data = 0xfc;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_color_group
 * define info:
 * number of colors (groups)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_se_nof_color_group_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_se;
    int define_index = dnx_data_sch_se_define_nof_color_group;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_hr_weight
 * define info:
 * maximal weight in HR WFQ
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_se_max_hr_weight_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_se;
    int define_index = dnx_data_sch_se_define_max_hr_weight;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4*1024;

    /* Set value */
    define->data = 4*1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cl_class_profile_nof
 * define info:
 * number of profiles for CL class
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_se_cl_class_profile_nof_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_se;
    int define_index = dnx_data_sch_se_define_cl_class_profile_nof;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 256;

    /* Set value */
    define->data = 256;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table quartet_offset_to_cl_num
 * Module - 'sch', Submodule - 'se', table - 'quartet_offset_to_cl_num'
 * mapping quartet index to CL number
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_se_quartet_offset_to_cl_num_set(
    int unit)
{
    int quartet_offset_index;
    dnx_data_sch_se_quartet_offset_to_cl_num_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_se;
    int table_index = dnx_data_sch_se_table_quartet_offset_to_cl_num;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 4;
    table->info_get.key_size[0] = 4;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_se_quartet_offset_to_cl_num_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_sch_se_table_quartet_offset_to_cl_num");

    /* Store Default Values */
    default_data = (dnx_data_sch_se_quartet_offset_to_cl_num_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->cl_num = -1;
    /* Set Default Values */
    for (quartet_offset_index = 0; quartet_offset_index < table->keys[0].size; quartet_offset_index++)
    {
        data = (dnx_data_sch_se_quartet_offset_to_cl_num_t *) dnxc_data_mgmt_table_data_get(unit, table, quartet_offset_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_sch_se_quartet_offset_to_cl_num_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->cl_num = 0;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: interface
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define nof_big_calendars
 * define info:
 * Number of big calendars per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_nof_big_calendars_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int define_index = dnx_data_sch_interface_define_nof_big_calendars;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_channelized_calendars
 * define info:
 * Number of channelized calendars per core (both big and regular)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_nof_channelized_calendars_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int define_index = dnx_data_sch_interface_define_nof_channelized_calendars;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define big_calendar_size
 * define info:
 * Size of big calendar
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_big_calendar_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int define_index = dnx_data_sch_interface_define_big_calendar_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1024;

    /* Set value */
    define->data = 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_sch_interfaces
 * define info:
 * Number of sch interfaces per core
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_nof_sch_interfaces_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int define_index = dnx_data_sch_interface_define_nof_sch_interfaces;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64;

    /* Set value */
    define->data = 64;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cal_speed_resolution
 * define info:
 * Resolution of interface calendar processing speed
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_cal_speed_resolution_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int define_index = dnx_data_sch_interface_define_cal_speed_resolution;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define reserved
 * define info:
 * Reserved SCH interface to disable interface level FC in case of LAG scheduling
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_reserved_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int define_index = dnx_data_sch_interface_define_reserved;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.interface.nof_sch_interfaces_get(unit)-1;

    /* Set value */
    define->data = dnx_data_sch.interface.nof_sch_interfaces_get(unit)-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric max_if_rate_mbps
 * numeric info:
 * maximal rate an interface can drive (in MBits/sec)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_max_if_rate_mbps_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int define_index = dnx_data_sch_interface_define_max_if_rate_mbps;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_device.general.maximal_core_bandwidth_mbps_get(unit);

    /* Set value */
    define->data = dnx_data_device.general.maximal_core_bandwidth_mbps_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table shaper_resolution
 * Module - 'sch', Submodule - 'interface', table - 'shaper_resolution'
 * shaper resolution for channelized/non channelized interface
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_interface_shaper_resolution_set(
    int unit)
{
    int channelized_index;
    dnx_data_sch_interface_shaper_resolution_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_interface;
    int table_index = dnx_data_sch_interface_table_shaper_resolution;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_interface_shaper_resolution_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_sch_interface_table_shaper_resolution");

    /* Store Default Values */
    default_data = (dnx_data_sch_interface_shaper_resolution_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->resolution = 0;
    /* Set Default Values */
    for (channelized_index = 0; channelized_index < table->keys[0].size; channelized_index++)
    {
        data = (dnx_data_sch_interface_shaper_resolution_t *) dnxc_data_mgmt_table_data_get(unit, table, channelized_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_sch_interface_shaper_resolution_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->resolution = 4;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: device
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_device_shared_drm_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_device;
    int feature_index = dnx_data_sch_device_shared_drm;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define drm_resolution
 * define info:
 * resolution of DRM rate
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_device_drm_resolution_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_device;
    int define_index = dnx_data_sch_device_define_drm_resolution;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: sch_alloc
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define tag_aggregate_se_2
 * define info:
 * 2 SE aggregate tag
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_tag_aggregate_se_2_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_tag_aggregate_se_2;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tag_aggregate_se_4
 * define info:
 * 4 SE aggregate tag
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_tag_aggregate_se_4_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_tag_aggregate_se_4;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tag_aggregate_se_8
 * define info:
 * 8 SE aggregate tag
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_tag_aggregate_se_8_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_tag_aggregate_se_8;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define shared_shaper_max_tag_value
 * define info:
 * max tag value for shared shaper
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_shared_shaper_max_tag_value_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_shared_shaper_max_tag_value;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.sch_alloc.tag_aggregate_se_8_get(unit);

    /* Set value */
    define->data = dnx_data_sch.sch_alloc.tag_aggregate_se_8_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tag_size_aggregate_se
 * define info:
 * tag size for SE aggregate
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_tag_size_aggregate_se_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_tag_size_aggregate_se;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define tag_size_con
 * define info:
 * tag size for connectors - modid
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_tag_size_con_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_tag_size_con;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define type_con_reg_start
 * define info:
 * start of the connectors only region
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_type_con_reg_start_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_type_con_reg_start;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define alloc_invalid_flow
 * define info:
 * invalid flow define
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_alloc_invalid_flow_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_alloc_invalid_flow;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = -1;

    /* Set value */
    define->data = -1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define dealloc_flow_ids
 * define info:
 * max number of flows to deallocate
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_dealloc_flow_ids_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_dealloc_flow_ids;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric type_con_reg_end
 * numeric info:
 * end of the connectors only region
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_type_con_reg_end_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_type_con_reg_end;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_connectors_only_regions_get(unit) - 1;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_connectors_only_regions_get(unit) - 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric type_hr_reg_start
 * numeric info:
 * searching start of the HR region
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_type_hr_reg_start_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int define_index = dnx_data_sch_sch_alloc_define_type_hr_reg_start;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_regions_get(unit) - dnx_data_sch.flow.nof_hr_regions_get(unit);

    /* Set value */
    define->data = dnx_data_sch.flow.nof_regions_get(unit) - dnx_data_sch.flow.nof_hr_regions_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table region
 * Module - 'sch', Submodule - 'sch_alloc', table - 'region'
 * content of quartet in each region type
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_region_set(
    int unit)
{
    int quartet_type_index;
    int region_type_index;
    dnx_data_sch_sch_alloc_region_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int table_index = dnx_data_sch_sch_alloc_table_region;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_SCH_FLOW_QUARTET_TYPE_NOF;
    table->info_get.key_size[0] = DNX_SCH_FLOW_QUARTET_TYPE_NOF;
    table->keys[1].size = DNX_SCH_REGION_TYPE_NOF;
    table->info_get.key_size[1] = DNX_SCH_REGION_TYPE_NOF;

    /* Info - default values */
    table->values[0].default_val = "DNX_SCH_ELEMENT_SE_TYPE_NONE";
    table->values[1].default_val = "DNX_SCHEDULER_REGION_EVEN";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_sch_alloc_region_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_sch_alloc_table_region");

    /* Store Default Values */
    default_data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
    default_data->odd_even_mode = DNX_SCHEDULER_REGION_EVEN;
    default_data->cl_half_pattern = 0;
    default_data->fq_half_pattern = 0;
    default_data->enhanced_cl_compact = 1;
    /* Set Default Values */
    for (quartet_type_index = 0; quartet_type_index < table->keys[0].size; quartet_type_index++)
    {
        for (region_type_index = 0; region_type_index < table->keys[1].size; region_type_index++)
        {
            data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, quartet_type_index, region_type_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_CON < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ, DNX_SCH_REGION_TYPE_CON);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_INTERDIG_1 < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ, DNX_SCH_REGION_TYPE_INTERDIG_1);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ, DNX_SCH_REGION_TYPE_SE);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_FQ, DNX_SCH_REGION_TYPE_SE_HR);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_HR;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_EVEN;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_CON < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ, DNX_SCH_REGION_TYPE_CON);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_INTERDIG_1 < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ, DNX_SCH_REGION_TYPE_INTERDIG_1);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ, DNX_SCH_REGION_TYPE_SE);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
        data->cl_half_pattern = 1;
        data->fq_half_pattern = 1;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_CL_FQ, DNX_SCH_REGION_TYPE_SE_HR);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_HR;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_EVEN;
        data->cl_half_pattern = 1;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_CON < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ, DNX_SCH_REGION_TYPE_CON);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ, DNX_SCH_REGION_TYPE_SE);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_EVEN;
        data->enhanced_cl_compact = 0;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_CL_FQ_FQ, DNX_SCH_REGION_TYPE_SE_HR);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_HR;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
        data->enhanced_cl_compact = 0;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_CON < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL, DNX_SCH_REGION_TYPE_CON);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL, DNX_SCH_REGION_TYPE_SE);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_CL_FQ_FQ_CL, DNX_SCH_REGION_TYPE_SE_HR);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_HR;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->odd_even_mode = DNX_SCHEDULER_REGION_EVEN;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_CON < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL, DNX_SCH_REGION_TYPE_CON);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL, DNX_SCH_REGION_TYPE_SE);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->odd_even_mode = DNX_SCHEDULER_REGION_EVEN;
        data->cl_half_pattern = 1;
        data->fq_half_pattern = 1;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_FQ_CL, DNX_SCH_REGION_TYPE_SE_HR);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_HR;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->odd_even_mode = DNX_SCHEDULER_REGION_EVEN;
        data->cl_half_pattern = 1;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_CON < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL, DNX_SCH_REGION_TYPE_CON);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL, DNX_SCH_REGION_TYPE_SE);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
        data->enhanced_cl_compact = 0;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_FQ_CL_CL, DNX_SCH_REGION_TYPE_SE_HR);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_HR;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
        data->enhanced_cl_compact = 0;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_CON < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ, DNX_SCH_REGION_TYPE_CON);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_NONE;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ, DNX_SCH_REGION_TYPE_SE);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }
    if (DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_region_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_FLOW_QUARTET_TYPE_FQ_CL_CL_FQ, DNX_SCH_REGION_TYPE_SE_HR);
        data->flow_type[0] = DNX_SCH_ELEMENT_SE_TYPE_HR;
        data->flow_type[1] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[2] = DNX_SCH_ELEMENT_SE_TYPE_CL;
        data->flow_type[3] = DNX_SCH_ELEMENT_SE_TYPE_FQ;
        data->odd_even_mode = DNX_SCHEDULER_REGION_ODD;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table connector
 * Module - 'sch', Submodule - 'sch_alloc', table - 'connector'
 * allocation info for VOQ connectors
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_connector_set(
    int unit)
{
    int composite_index;
    int interdigitated_index;
    dnx_data_sch_sch_alloc_connector_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int table_index = dnx_data_sch_sch_alloc_table_connector;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 2;
    table->info_get.key_size[0] = 2;
    table->keys[1].size = 2;
    table->info_get.key_size[1] = 2;

    /* Info - default values */
    table->values[0].default_val = "4";
    table->values[1].default_val = "1";
    table->values[2].default_val = "1";
    table->values[3].default_val = "1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_sch_alloc_connector_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_sch_alloc_table_connector");

    /* Store Default Values */
    default_data = (dnx_data_sch_sch_alloc_connector_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->alignment = 4;
    default_data->pattern = 1;
    default_data->pattern_size = 1;
    default_data->nof_in_pattern = 1;
    /* Set Default Values */
    for (composite_index = 0; composite_index < table->keys[0].size; composite_index++)
    {
        for (interdigitated_index = 0; interdigitated_index < table->keys[1].size; interdigitated_index++)
        {
            data = (dnx_data_sch_sch_alloc_connector_t *) dnxc_data_mgmt_table_data_get(unit, table, composite_index, interdigitated_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size && 0 < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_connector_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->alignment = 4;
        data->pattern = 0x1;
        data->pattern_size = 1;
    }
    if (1 < table->keys[0].size && 0 < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_connector_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->alignment = 8;
        data->pattern = 0x3;
        data->pattern_size = 2;
    }
    if (0 < table->keys[0].size && 1 < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_connector_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 1);
        data->alignment = 8;
        data->pattern = 0xc;
        data->pattern_size = 4;
        data->nof_in_pattern = 2;
    }
    if (1 < table->keys[0].size && 1 < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_connector_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 1);
        data->alignment = 16;
        data->pattern = 0xc;
        data->pattern_size = 4;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table se_per_region_type
 * Module - 'sch', Submodule - 'sch_alloc', table - 'se_per_region_type'
 * allocation info for scheduling elements per region type
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_se_per_region_type_set(
    int unit)
{
    int flow_type_index;
    int region_type_index;
    dnx_data_sch_sch_alloc_se_per_region_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int table_index = dnx_data_sch_sch_alloc_table_se_per_region_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_SCH_ALLOC_FLOW_TYPE_NOF;
    table->info_get.key_size[0] = DNX_SCH_ALLOC_FLOW_TYPE_NOF;
    table->keys[1].size = DNX_SCH_REGION_TYPE_NOF;
    table->info_get.key_size[1] = DNX_SCH_REGION_TYPE_NOF;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "4";
    table->values[2].default_val = "1";
    table->values[3].default_val = "4";
    table->values[4].default_val = "1";
    table->values[5].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_sch_alloc_se_per_region_type_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_sch_alloc_table_se_per_region_type");

    /* Store Default Values */
    default_data = (dnx_data_sch_sch_alloc_se_per_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->valid = 0;
    default_data->alignment = 4;
    default_data->pattern = 1;
    default_data->pattern_size = 4;
    default_data->nof_offsets = 1;
    default_data->offset[0] = 0;
    /* Set Default Values */
    for (flow_type_index = 0; flow_type_index < table->keys[0].size; flow_type_index++)
    {
        for (region_type_index = 0; region_type_index < table->keys[1].size; region_type_index++)
        {
            data = (dnx_data_sch_sch_alloc_se_per_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, flow_type_index, region_type_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (DNX_SCH_ALLOC_FLOW_TYPE_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_INTERDIG_1 < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_se_per_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_FQ, DNX_SCH_REGION_TYPE_INTERDIG_1);
        data->valid = 1;
        data->pattern = 0x2;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_se_per_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_FQ, DNX_SCH_REGION_TYPE_SE);
        data->valid = 1;
        data->pattern = 0x1;
        data->nof_offsets = 3;
        data->offset[0] = 1;
        data->offset[1] = 2;
        data->offset[2] = 3;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_FQ < table->keys[0].size && DNX_SCH_REGION_TYPE_SE_HR < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_se_per_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_FQ, DNX_SCH_REGION_TYPE_SE_HR);
        data->valid = 1;
        data->pattern = 0x1;
        data->nof_offsets = 2;
        data->offset[0] = 2;
        data->offset[1] = 3;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table se
 * Module - 'sch', Submodule - 'sch_alloc', table - 'se'
 * allocation info for scheduling elements
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_se_set(
    int unit)
{
    int flow_type_index;
    dnx_data_sch_sch_alloc_se_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int table_index = dnx_data_sch_sch_alloc_table_se;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_SCH_ALLOC_FLOW_TYPE_NOF;
    table->info_get.key_size[0] = DNX_SCH_ALLOC_FLOW_TYPE_NOF;

    /* Info - default values */
    table->values[0].default_val = "4";
    table->values[1].default_val = "1";
    table->values[2].default_val = "4";
    table->values[3].default_val = "1";
    table->values[4].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_sch_alloc_se_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_sch_sch_alloc_table_se");

    /* Store Default Values */
    default_data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->alignment = 4;
    default_data->pattern = 1;
    default_data->pattern_size = 4;
    default_data->nof_offsets = 1;
    default_data->offset[0] = 0;
    /* Set Default Values */
    for (flow_type_index = 0; flow_type_index < table->keys[0].size; flow_type_index++)
    {
        data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, flow_type_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (DNX_SCH_ALLOC_FLOW_TYPE_CL < table->keys[0].size)
    {
        data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_CL, 0);
        data->pattern = 0x1;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_ENHANCED_CL < table->keys[0].size)
    {
        data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_ENHANCED_CL, 0);
        data->pattern = 0x3;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_HR < table->keys[0].size)
    {
        data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_HR, 0);
        data->pattern = 0x2;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_SHARED_SE_2 < table->keys[0].size)
    {
        data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_SHARED_SE_2, 0);
        data->pattern = 0x3;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_SHARED_SE_4 < table->keys[0].size)
    {
        data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_SHARED_SE_4, 0);
        data->pattern = 0xf;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_SHARED_SE_8 < table->keys[0].size)
    {
        data = (dnx_data_sch_sch_alloc_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_SHARED_SE_8, 0);
        data->alignment = 8;
        data->pattern = 0xff;
        data->pattern_size = 8;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table composite_se_per_region_type
 * Module - 'sch', Submodule - 'sch_alloc', table - 'composite_se_per_region_type'
 * allocation info for composite scheduling elements per region type
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_composite_se_per_region_type_set(
    int unit)
{
    int flow_type_index;
    int region_type_index;
    dnx_data_sch_sch_alloc_composite_se_per_region_type_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int table_index = dnx_data_sch_sch_alloc_table_composite_se_per_region_type;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_SCH_ALLOC_FLOW_TYPE_NOF;
    table->info_get.key_size[0] = DNX_SCH_ALLOC_FLOW_TYPE_NOF;
    table->keys[1].size = DNX_SCH_REGION_TYPE_NOF;
    table->info_get.key_size[1] = DNX_SCH_REGION_TYPE_NOF;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "4";
    table->values[2].default_val = "1";
    table->values[3].default_val = "4";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_sch_alloc_composite_se_per_region_type_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_sch_alloc_table_composite_se_per_region_type");

    /* Store Default Values */
    default_data = (dnx_data_sch_sch_alloc_composite_se_per_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->valid = 0;
    default_data->alignment = 4;
    default_data->pattern = 1;
    default_data->pattern_size = 4;
    /* Set Default Values */
    for (flow_type_index = 0; flow_type_index < table->keys[0].size; flow_type_index++)
    {
        for (region_type_index = 0; region_type_index < table->keys[1].size; region_type_index++)
        {
            data = (dnx_data_sch_sch_alloc_composite_se_per_region_type_t *) dnxc_data_mgmt_table_data_get(unit, table, flow_type_index, region_type_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table composite_se
 * Module - 'sch', Submodule - 'sch_alloc', table - 'composite_se'
 * allocation info for composite scheduling elements
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_sch_alloc_composite_se_set(
    int unit)
{
    int flow_type_index;
    int odd_even_mode_index;
    dnx_data_sch_sch_alloc_composite_se_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_sch_alloc;
    int table_index = dnx_data_sch_sch_alloc_table_composite_se;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = DNX_SCH_ALLOC_FLOW_TYPE_NOF;
    table->info_get.key_size[0] = DNX_SCH_ALLOC_FLOW_TYPE_NOF;
    table->keys[1].size = DNX_SCHEDULER_REGION_ODD_EVEN_MODE_NOF;
    table->info_get.key_size[1] = DNX_SCHEDULER_REGION_ODD_EVEN_MODE_NOF;

    /* Info - default values */
    table->values[0].default_val = "4";
    table->values[1].default_val = "1";
    table->values[2].default_val = "4";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_sch_sch_alloc_composite_se_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_sch_sch_alloc_table_composite_se");

    /* Store Default Values */
    default_data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->alignment = 4;
    default_data->pattern = 1;
    default_data->pattern_size = 4;
    /* Set Default Values */
    for (flow_type_index = 0; flow_type_index < table->keys[0].size; flow_type_index++)
    {
        for (odd_even_mode_index = 0; odd_even_mode_index < table->keys[1].size; odd_even_mode_index++)
        {
            data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, flow_type_index, odd_even_mode_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (DNX_SCH_ALLOC_FLOW_TYPE_COMP_CL < table->keys[0].size && DNX_SCHEDULER_REGION_EVEN < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_COMP_CL, DNX_SCHEDULER_REGION_EVEN);
        data->pattern = 0x5;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_COMP_CL < table->keys[0].size && DNX_SCHEDULER_REGION_ODD < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_COMP_CL, DNX_SCHEDULER_REGION_ODD);
        data->pattern = 0x3;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_COMP_HR < table->keys[0].size && DNX_SCHEDULER_REGION_EVEN < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_COMP_HR, DNX_SCHEDULER_REGION_EVEN);
        data->pattern = 0xa;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_COMP_HR < table->keys[0].size && DNX_SCHEDULER_REGION_ODD < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_COMP_HR, DNX_SCHEDULER_REGION_ODD);
        data->pattern = 0x0;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_COMP_FQ < table->keys[0].size && DNX_SCHEDULER_REGION_EVEN < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_COMP_FQ, DNX_SCHEDULER_REGION_EVEN);
        data->pattern = 0xa;
    }
    if (DNX_SCH_ALLOC_FLOW_TYPE_COMP_FQ < table->keys[0].size && DNX_SCHEDULER_REGION_ODD < table->keys[1].size)
    {
        data = (dnx_data_sch_sch_alloc_composite_se_t *) dnxc_data_mgmt_table_data_get(unit, table, DNX_SCH_ALLOC_FLOW_TYPE_COMP_FQ, DNX_SCHEDULER_REGION_ODD);
        data->pattern = 0xc;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: dbal
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define scheduler_enable_grouping_factor
 * define info:
 * size of group of sched elements sharing the same HW field 
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_scheduler_enable_grouping_factor_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_scheduler_enable_grouping_factor;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define scheduler_enable_dbal_mult_factor
 * define info:
 * DBAL multiplication factor
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_scheduler_enable_dbal_mult_factor_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_scheduler_enable_dbal_mult_factor;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = (1 << dnx_data_sch.dbal.scheduler_enable_grouping_factor_get(unit))-1;

    /* Set value */
    define->data = (1 << dnx_data_sch.dbal.scheduler_enable_grouping_factor_get(unit))-1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define flow_bits
 * define info:
 * Number of bits in flow id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_flow_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_flow_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 17;

    /* Set value */
    define->data = 17;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define se_bits
 * define info:
 * Number of bits in Scheduling element id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_se_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_se_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 15;

    /* Set value */
    define->data = 15;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define cl_bits
 * define info:
 * Number of bits in CL id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_cl_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_cl_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 13;

    /* Set value */
    define->data = 13;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define hr_bits
 * define info:
 * Number of bits in HR id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_hr_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_hr_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 9;

    /* Set value */
    define->data = 9;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define interface_bits
 * define info:
 * Number of bits in interface id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_interface_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_interface_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define calendar_bits
 * define info:
 * Number of bits in calendar id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_calendar_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_calendar_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define flow_shaper_mant_bits
 * define info:
 * Number of bits in flow shaper mantissa
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_flow_shaper_mant_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_flow_shaper_mant_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 6;

    /* Set value */
    define->data = 6;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ps_shaper_quanta_bits
 * define info:
 * number of bits in PS shaper quanta
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_ps_shaper_quanta_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_ps_shaper_quanta_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 11;

    /* Set value */
    define->data = 11;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define ps_shaper_max_burst_bits
 * define info:
 * number of bits in PS shaper max burst
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_ps_shaper_max_burst_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_ps_shaper_max_burst_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 15;

    /* Set value */
    define->data = 15;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define drm_nof_links_max
 * define info:
 * maximal value of number of links for DRM table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_drm_nof_links_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_drm_nof_links_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_fabric.links.nof_links_get(unit);

    /* Set value */
    define->data = dnx_data_fabric.links.nof_links_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define token_count_default
 * define info:
 * default value of token count
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_token_count_default_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_token_count_default;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric scheduler_enable_key_size
 * numeric info:
 * size in bits of key in scheduler enable DBAL table
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_scheduler_enable_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_scheduler_enable_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.dbal.se_bits_get(unit) - 3;

    /* Set value */
    define->data = dnx_data_sch.dbal.se_bits_get(unit) - 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric flow_id_pair_key_size
 * numeric info:
 * size in bits of half flow id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_flow_id_pair_key_size_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_flow_id_pair_key_size;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.dbal.flow_bits_get(unit) - 1;

    /* Set value */
    define->data = dnx_data_sch.dbal.flow_bits_get(unit) - 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric flow_id_pair_max
 * numeric info:
 * max value of half flow id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_flow_id_pair_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_flow_id_pair_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.flow.nof_flows_get(unit)/2 - 1;

    /* Set value */
    define->data = dnx_data_sch.flow.nof_flows_get(unit)/2 - 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric ps_bits
 * numeric info:
 * Number of bits in PS id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_ps_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_ps_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.dbal.hr_bits_get(unit) - 3;

    /* Set value */
    define->data = dnx_data_sch.dbal.hr_bits_get(unit) - 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric flow_shaper_descr_bits
 * numeric info:
 * Number of bits in flow shaper descriptor for one flow
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_flow_shaper_descr_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_flow_shaper_descr_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.dbal.flow_shaper_mant_bits_get(unit) + 4 + 9 + 1;

    /* Set value */
    define->data = dnx_data_sch.dbal.flow_shaper_mant_bits_get(unit) + 4 + 9 + 1;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric ps_shaper_bits
 * numeric info:
 * number of bits in PS shaper
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_ps_shaper_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_ps_shaper_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_sch.dbal.ps_shaper_quanta_bits_get(unit) +dnx_data_sch.dbal.ps_shaper_max_burst_bits_get(unit);

    /* Set value */
    define->data = dnx_data_sch.dbal.ps_shaper_quanta_bits_get(unit) +dnx_data_sch.dbal.ps_shaper_max_burst_bits_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric cl_profile_bits
 * numeric info:
 * number of bits in CL profile id
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_dbal_cl_profile_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_dbal;
    int define_index = dnx_data_sch_dbal_define_cl_profile_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = utilex_log2_round_up(dnx_data_sch.se.cl_class_profile_nof_get(unit));

    /* Set value */
    define->data = utilex_log2_round_up(dnx_data_sch.se.cl_class_profile_nof_get(unit));

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: features
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_sch_features_dlm_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_sch;
    int submodule_index = dnx_data_sch_submodule_features;
    int feature_index = dnx_data_sch_features_dlm;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jr2_a0_data_sch_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_sch;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: general
     */
    submodule_index = dnx_data_sch_submodule_general;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_general_define_nof_slow_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_general_nof_slow_profiles_set;
    data_index = dnx_data_sch_general_define_nof_slow_levels;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_general_nof_slow_levels_set;
    data_index = dnx_data_sch_general_define_cycles_per_credit_token;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_general_cycles_per_credit_token_set;
    data_index = dnx_data_sch_general_define_nof_fmq_class;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_general_nof_fmq_class_set;
    data_index = dnx_data_sch_general_define_port_priority_propagation_version;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_general_port_priority_propagation_version_set;
    data_index = dnx_data_sch_general_define_port_priority_propagation_enable;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_general_port_priority_propagation_enable_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_sch_general_lag_scheduler_supported;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_sch_general_lag_scheduler_supported_set;
    data_index = dnx_data_sch_general_fsm_modes_config_supported;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_sch_general_fsm_modes_config_supported_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_sch_general_table_low_rate_factor_to_dbal_enum;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_general_low_rate_factor_to_dbal_enum_set;
    data_index = dnx_data_sch_general_table_dbal_enum_to_low_rate_factor;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_general_dbal_enum_to_low_rate_factor_set;
    data_index = dnx_data_sch_general_table_slow_rate_max_bucket;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_general_slow_rate_max_bucket_set;
    /*
     * Attach submodule: ps
     */
    submodule_index = dnx_data_sch_submodule_ps;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_ps_define_min_priority_for_tcg;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_ps_min_priority_for_tcg_set;
    data_index = dnx_data_sch_ps_define_max_nof_tcg;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_ps_max_nof_tcg_set;
    data_index = dnx_data_sch_ps_define_nof_hrs_in_ps;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_ps_nof_hrs_in_ps_set;
    data_index = dnx_data_sch_ps_define_max_tcg_weight;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_ps_max_tcg_weight_set;
    data_index = dnx_data_sch_ps_define_tc_tcg_calendar_access_period;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_ps_tc_tcg_calendar_access_period_set;
    data_index = dnx_data_sch_ps_define_max_port_rate_mbps;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_ps_max_port_rate_mbps_set;
    data_index = dnx_data_sch_ps_define_max_burst;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_ps_max_burst_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: flow
     */
    submodule_index = dnx_data_sch_submodule_flow;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_flow_define_nof_hr;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_hr_set;
    data_index = dnx_data_sch_flow_define_nof_cl;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_cl_set;
    data_index = dnx_data_sch_flow_define_nof_se;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_se_set;
    data_index = dnx_data_sch_flow_define_nof_flows;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_flows_set;
    data_index = dnx_data_sch_flow_define_region_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_region_size_set;
    data_index = dnx_data_sch_flow_define_nof_regions;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_regions_set;
    data_index = dnx_data_sch_flow_define_nof_hr_regions;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_hr_regions_set;
    data_index = dnx_data_sch_flow_define_nof_connectors_only_regions;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_connectors_only_regions_set;
    data_index = dnx_data_sch_flow_define_flow_in_region_mask;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_flow_in_region_mask_set;
    data_index = dnx_data_sch_flow_define_min_connector_bundle_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_min_connector_bundle_size_set;
    data_index = dnx_data_sch_flow_define_conn_idx_interdig_flow;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_conn_idx_interdig_flow_set;
    data_index = dnx_data_sch_flow_define_shaper_flipflops_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_shaper_flipflops_nof_set;
    data_index = dnx_data_sch_flow_define_nof_flows_in_quartet_order_group;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_flows_in_quartet_order_group_set;
    data_index = dnx_data_sch_flow_define_nof_regions_in_quartet_order_group;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_regions_in_quartet_order_group_set;
    data_index = dnx_data_sch_flow_define_nof_quartet_order_groups;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_nof_quartet_order_groups_set;
    data_index = dnx_data_sch_flow_define_erp_hr;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_erp_hr_set;
    data_index = dnx_data_sch_flow_define_reserved_hr;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_reserved_hr_set;
    data_index = dnx_data_sch_flow_define_max_se;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_max_se_set;
    data_index = dnx_data_sch_flow_define_max_flow;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_max_flow_set;
    data_index = dnx_data_sch_flow_define_first_hr_region;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_first_hr_region_set;
    data_index = dnx_data_sch_flow_define_first_se_flow_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_first_se_flow_id_set;
    data_index = dnx_data_sch_flow_define_hr_se_id_min;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_hr_se_id_min_set;
    data_index = dnx_data_sch_flow_define_hr_se_id_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_hr_se_id_max_set;
    data_index = dnx_data_sch_flow_define_default_credit_source_se_id;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_default_credit_source_se_id_set;
    data_index = dnx_data_sch_flow_define_runtime_performance_optimize_enable_sched_allocation;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_flow_runtime_performance_optimize_enable_sched_allocation_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_sch_flow_interdigitated_supported;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_sch_flow_interdigitated_supported_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_sch_flow_table_region_type;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_flow_region_type_set;
    data_index = dnx_data_sch_flow_table_nof_remote_cores;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_flow_nof_remote_cores_set;
    data_index = dnx_data_sch_flow_table_quartet_type;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_flow_quartet_type_set;
    data_index = dnx_data_sch_flow_table_quartet_index_conversion;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_flow_quartet_index_conversion_set;
    /*
     * Attach submodule: se
     */
    submodule_index = dnx_data_sch_submodule_se;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_se_define_default_cos;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_se_default_cos_set;
    data_index = dnx_data_sch_se_define_nof_color_group;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_se_nof_color_group_set;
    data_index = dnx_data_sch_se_define_max_hr_weight;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_se_max_hr_weight_set;
    data_index = dnx_data_sch_se_define_cl_class_profile_nof;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_se_cl_class_profile_nof_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_sch_se_table_quartet_offset_to_cl_num;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_se_quartet_offset_to_cl_num_set;
    /*
     * Attach submodule: interface
     */
    submodule_index = dnx_data_sch_submodule_interface;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_interface_define_nof_big_calendars;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_interface_nof_big_calendars_set;
    data_index = dnx_data_sch_interface_define_nof_channelized_calendars;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_interface_nof_channelized_calendars_set;
    data_index = dnx_data_sch_interface_define_big_calendar_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_interface_big_calendar_size_set;
    data_index = dnx_data_sch_interface_define_nof_sch_interfaces;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_interface_nof_sch_interfaces_set;
    data_index = dnx_data_sch_interface_define_cal_speed_resolution;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_interface_cal_speed_resolution_set;
    data_index = dnx_data_sch_interface_define_reserved;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_interface_reserved_set;
    data_index = dnx_data_sch_interface_define_max_if_rate_mbps;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_interface_max_if_rate_mbps_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_sch_interface_table_shaper_resolution;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_interface_shaper_resolution_set;
    /*
     * Attach submodule: device
     */
    submodule_index = dnx_data_sch_submodule_device;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_device_define_drm_resolution;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_device_drm_resolution_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_sch_device_shared_drm;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_sch_device_shared_drm_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: sch_alloc
     */
    submodule_index = dnx_data_sch_submodule_sch_alloc;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_sch_alloc_define_tag_aggregate_se_2;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_tag_aggregate_se_2_set;
    data_index = dnx_data_sch_sch_alloc_define_tag_aggregate_se_4;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_tag_aggregate_se_4_set;
    data_index = dnx_data_sch_sch_alloc_define_tag_aggregate_se_8;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_tag_aggregate_se_8_set;
    data_index = dnx_data_sch_sch_alloc_define_shared_shaper_max_tag_value;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_shared_shaper_max_tag_value_set;
    data_index = dnx_data_sch_sch_alloc_define_tag_size_aggregate_se;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_tag_size_aggregate_se_set;
    data_index = dnx_data_sch_sch_alloc_define_tag_size_con;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_tag_size_con_set;
    data_index = dnx_data_sch_sch_alloc_define_type_con_reg_start;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_type_con_reg_start_set;
    data_index = dnx_data_sch_sch_alloc_define_alloc_invalid_flow;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_alloc_invalid_flow_set;
    data_index = dnx_data_sch_sch_alloc_define_dealloc_flow_ids;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_dealloc_flow_ids_set;
    data_index = dnx_data_sch_sch_alloc_define_type_con_reg_end;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_type_con_reg_end_set;
    data_index = dnx_data_sch_sch_alloc_define_type_hr_reg_start;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_sch_alloc_type_hr_reg_start_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    data_index = dnx_data_sch_sch_alloc_table_region;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_sch_alloc_region_set;
    data_index = dnx_data_sch_sch_alloc_table_connector;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_sch_alloc_connector_set;
    data_index = dnx_data_sch_sch_alloc_table_se_per_region_type;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_sch_alloc_se_per_region_type_set;
    data_index = dnx_data_sch_sch_alloc_table_se;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_sch_alloc_se_set;
    data_index = dnx_data_sch_sch_alloc_table_composite_se_per_region_type;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_sch_alloc_composite_se_per_region_type_set;
    data_index = dnx_data_sch_sch_alloc_table_composite_se;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_sch_sch_alloc_composite_se_set;
    /*
     * Attach submodule: dbal
     */
    submodule_index = dnx_data_sch_submodule_dbal;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_sch_dbal_define_scheduler_enable_grouping_factor;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_scheduler_enable_grouping_factor_set;
    data_index = dnx_data_sch_dbal_define_scheduler_enable_dbal_mult_factor;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_scheduler_enable_dbal_mult_factor_set;
    data_index = dnx_data_sch_dbal_define_flow_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_flow_bits_set;
    data_index = dnx_data_sch_dbal_define_se_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_se_bits_set;
    data_index = dnx_data_sch_dbal_define_cl_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_cl_bits_set;
    data_index = dnx_data_sch_dbal_define_hr_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_hr_bits_set;
    data_index = dnx_data_sch_dbal_define_interface_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_interface_bits_set;
    data_index = dnx_data_sch_dbal_define_calendar_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_calendar_bits_set;
    data_index = dnx_data_sch_dbal_define_flow_shaper_mant_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_flow_shaper_mant_bits_set;
    data_index = dnx_data_sch_dbal_define_ps_shaper_quanta_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_ps_shaper_quanta_bits_set;
    data_index = dnx_data_sch_dbal_define_ps_shaper_max_burst_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_ps_shaper_max_burst_bits_set;
    data_index = dnx_data_sch_dbal_define_drm_nof_links_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_drm_nof_links_max_set;
    data_index = dnx_data_sch_dbal_define_token_count_default;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_token_count_default_set;
    data_index = dnx_data_sch_dbal_define_scheduler_enable_key_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_scheduler_enable_key_size_set;
    data_index = dnx_data_sch_dbal_define_flow_id_pair_key_size;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_flow_id_pair_key_size_set;
    data_index = dnx_data_sch_dbal_define_flow_id_pair_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_flow_id_pair_max_set;
    data_index = dnx_data_sch_dbal_define_ps_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_ps_bits_set;
    data_index = dnx_data_sch_dbal_define_flow_shaper_descr_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_flow_shaper_descr_bits_set;
    data_index = dnx_data_sch_dbal_define_ps_shaper_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_ps_shaper_bits_set;
    data_index = dnx_data_sch_dbal_define_cl_profile_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_sch_dbal_cl_profile_bits_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: features
     */
    submodule_index = dnx_data_sch_submodule_features;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */

    /*
     * Attach features: 
     */
    data_index = dnx_data_sch_features_dlm;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_sch_features_dlm_set;

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
#undef BSL_LOG_MODULE
/* *INDENT-ON* */
