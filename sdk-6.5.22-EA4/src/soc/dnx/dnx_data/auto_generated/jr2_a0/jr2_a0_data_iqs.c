/** \file jr2_a0_data_iqs.c
 * 
 * DEVICE DATA - IQS
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifdef BSL_LOG_MODULE
#error "BSL_LOG_MODULE redefined"
#endif
#define BSL_LOG_MODULE BSL_LS_BCMDNX_COSQ
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal_iqs.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_device.h>
/*
 * }
 */

/*
 * FUNCTIONS:
 * {
 */
/*
 * Submodule: credit
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_watchdog_fixed_period_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int feature_index = dnx_data_iqs_credit_watchdog_fixed_period;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    feature->property.name = spn_CUSTOM_FEATURE;
    feature->property.doc = 
        "\n"
        "custom_feature_watchdog_fixed_period='0' or '1'\n"
        "if 1 watchdog has a fixed value, otherwise can be controlled by the user\n"
        "Default - '1'\n"
        "\n"
    ;
    feature->property.method = dnxc_data_property_method_suffix_enable;
    feature->property.method_str = "suffix_enable";
    feature->property.suffix = "watchdog_fixed_period";
    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &feature->property, -1, &feature->data));
    /* Set data flags as property */
    feature->flags |= (DNXC_DATA_F_PROPERTY);


    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_shp_zero_rate_allowed_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int feature_index = dnx_data_iqs_credit_fmq_shp_zero_rate_allowed;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_credit_balance_support_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int feature_index = dnx_data_iqs_credit_credit_balance_support;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 1;

    /* Set value */
    feature->data = 1;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define nof_profiles
 * define info:
 * Number of supported profiles
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_nof_profiles_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_nof_profiles;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 32;

    /* Set value */
    define->data = 32;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_credit_balance_threshold
 * define info:
 * max value for thresholds in credit balance resolution units
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_max_credit_balance_threshold_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_max_credit_balance_threshold;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1ffff;

    /* Set value */
    define->data = 0x1ffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_worth
 * define info:
 * max credit worth
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_max_worth_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_max_worth;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8191;

    /* Set value */
    define->data = 8191;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define satisified_back_min
 * define info:
 * min value for satisified back thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_satisified_back_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_satisified_back_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0;

    /* Set value */
    define->data = 0;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define satisified_back_max
 * define info:
 * max value for satisified back thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_satisified_back_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_satisified_back_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x3ffff;

    /* Set value */
    define->data = 0x3ffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define satisified_empty_min
 * define info:
 * min value for satisified empty thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_satisified_empty_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_satisified_empty_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = -1 * 0x1ffff;

    /* Set value */
    define->data = -1 * 0x1ffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define satisified_empty_max
 * define info:
 * max value for satisified empty thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_satisified_empty_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_satisified_empty_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1ffff;

    /* Set value */
    define->data = 0x1ffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define hungry_min
 * define info:
 * min value for hungry thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_hungry_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_hungry_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = -1 * 0x3ffff;

    /* Set value */
    define->data = -1 * 0x3ffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define hungry_max
 * define info:
 * max value for hungry thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_hungry_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_hungry_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x3ffff;

    /* Set value */
    define->data = 0x3ffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define hungry_mult_min
 * define info:
 * min value for hungry multiply thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_hungry_mult_min_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_hungry_mult_min;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define hungry_mult_max
 * define info:
 * max value for hungry multiply thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_hungry_mult_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_hungry_mult_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_bw_levels
 * define info:
 * number of supported bandwidth levels
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_nof_bw_levels_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_nof_bw_levels;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4;

    /* Set value */
    define->data = 4;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_credit_fc_on_th
 * define info:
 * default thershold value for FMQ credit FC on
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_credit_fc_on_th_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_credit_fc_on_th;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 30;

    /* Set value */
    define->data = 30;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_credit_fc_off_th
 * define info:
 * default thershold value for FMQ credit FC off
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_credit_fc_off_th_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_credit_fc_off_th;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 20;

    /* Set value */
    define->data = 20;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_byte_fc_on_th
 * define info:
 * default thershold value for FMQ byte FC on
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_byte_fc_on_th_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_byte_fc_on_th;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 1000;

    /* Set value */
    define->data = 1000;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_byte_fc_off_th
 * define info:
 * default thershold value for FMQ byte FC off
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_byte_fc_off_th_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_byte_fc_off_th;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 800;

    /* Set value */
    define->data = 800;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_eir_credit_fc_th
 * define info:
 * default thershold value for all credit EIR FMQ FC thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_eir_credit_fc_th_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_eir_credit_fc_th;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1fff;

    /* Set value */
    define->data = 0x1fff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_eir_byte_fc_th
 * define info:
 * default thershold value for all byte EIR FMQ FC thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_eir_byte_fc_th_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_eir_byte_fc_th;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x1fffff;

    /* Set value */
    define->data = 0x1fffff;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_nof_be_classes
 * define info:
 * nof best-effort FMQ classes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_nof_be_classes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_nof_be_classes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 3;

    /* Set value */
    define->data = 3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_max_be_weight
 * define info:
 * max weight for best-effort FMQ classes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_max_be_weight_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_max_be_weight;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 31;

    /* Set value */
    define->data = 31;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_max_burst_max
 * define info:
 * FMQ max burst maximum value
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_max_burst_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_max_burst_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 63;

    /* Set value */
    define->data = 63;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_shp_crdt_rate_mltp
 * define info:
 * multiplier for clock resolution of the FMQ shapers credit rate
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_shp_crdt_rate_mltp_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_shp_crdt_rate_mltp;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 8;

    /* Set value */
    define->data = 8;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define fmq_shp_crdt_rate_delta
 * define info:
 * numeric correction used in FMQ shapers rate calculation
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_shp_crdt_rate_delta_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_shp_crdt_rate_delta;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 7;

    /* Set value */
    define->data = 7;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define max_rate_profile_preset_gbps
 * define info:
 * maximal rate for credit request profile preset get (Gpbs)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_max_rate_profile_preset_gbps_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_max_rate_profile_preset_gbps;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric worth
 * numeric info:
 * credit worth in bytes
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_worth_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_worth;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4096;

    /* Set value */
    define->data = 4096;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;
    /* Property */
    define->property.name = spn_CREDIT_SIZE;
    define->property.doc = 
        "\n"
        "Set local credit worth. Recommended value is 4096 Bytes.\n"
        "Credit worth has significant implications on the scheduled traffic.\n"
        "Consult with Broadcom applications engineer before changing the credit size value.\n"
        "Supported range [1-8191]\n"
        "Syntax:\n"
        "credit_size=#credit size in bytes#\n"
        "Default:\n"
        "4096\n"
        "\n"
    ;
    define->property.method = dnxc_data_property_method_range;
    define->property.method_str = "range";
    define->property.range_min = 1;
    define->property.range_max = dnx_data_iqs.credit.max_worth_get(unit);

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));

    SHR_IF_ERR_EXIT(dnxc_data_mgmt_property_read(unit, &define->property, -1, &define->data));
    /* Set data flags as property */
    define->flags |= (DNXC_DATA_F_PROPERTY);

exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set numeric fmq_shp_rate_max
 * numeric info:
 * max value for FMQ shaper rate in Mbps
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_credit_fmq_shp_rate_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_credit;
    int define_index = dnx_data_iqs_credit_define_fmq_shp_rate_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = dnx_data_device.general.maximal_core_bandwidth_mbps_get(unit);

    /* Set value */
    define->data = dnx_data_device.general.maximal_core_bandwidth_mbps_get(unit);

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: deq_default
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_dqcq_fc_to_dram_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int feature_index = dnx_data_iqs_deq_default_dqcq_fc_to_dram;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define low_delay_deq_bytes
 * define info:
 * dequeue low delay thresholds
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_low_delay_deq_bytes_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int define_index = dnx_data_iqs_deq_default_define_low_delay_deq_bytes;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define credit_balance_max
 * define info:
 * max credit balance
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_credit_balance_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int define_index = dnx_data_iqs_deq_default_define_credit_balance_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128 * 1024;

    /* Set value */
    define->data = 128 * 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define credit_balance_resolution
 * define info:
 * credit balance resolution for dequeue parameters configuration
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_credit_balance_resolution_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int define_index = dnx_data_iqs_deq_default_define_credit_balance_resolution;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 4 * 1024;

    /* Set value */
    define->data = 4 * 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define s2d_credit_balance_max
 * define info:
 * max credit balance in sram to dram context
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_s2d_credit_balance_max_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int define_index = dnx_data_iqs_deq_default_define_s2d_credit_balance_max;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2 * 1024 * 1024;

    /* Set value */
    define->data = 2 * 1024 * 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define s2d_credit_balance_resolution
 * define info:
 * credit balance resolution for dequeue parameters configuration in sram to dram context
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_s2d_credit_balance_resolution_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int define_index = dnx_data_iqs_deq_default_define_s2d_credit_balance_resolution;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 64 * 1024;

    /* Set value */
    define->data = 64 * 1024;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define sram_to_fabric_credit_lfsr_thr
 * define info:
 * default lfsr threshold on credits for deq from sram to fabric
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_sram_to_fabric_credit_lfsr_thr_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int define_index = dnx_data_iqs_deq_default_define_sram_to_fabric_credit_lfsr_thr;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x70;

    /* Set value */
    define->data = 0x70;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define sram_to_fabric_credit_lfsr_mask
 * define info:
 * default lfsr mask on credits for deq from sram to fabric
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_sram_to_fabric_credit_lfsr_mask_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int define_index = dnx_data_iqs_deq_default_define_sram_to_fabric_credit_lfsr_mask;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 0x3;

    /* Set value */
    define->data = 0x3;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/**
 * \brief device level function which set values for table sqm_read_weight_profiles
 * Module - 'iqs', Submodule - 'deq_default', table - 'sqm_read_weight_profiles'
 * stores the SQM read weight profiles that should configured to HW
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_sqm_read_weight_profiles_set(
    int unit)
{
    int profile_id_index;
    dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int table_index = dnx_data_iqs_deq_default_table_sqm_read_weight_profiles;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 8;
    table->info_get.key_size[0] = 8;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_iqs_deq_default_sqm_read_weight_profiles_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_iqs_deq_default_table_sqm_read_weight_profiles");

    /* Store Default Values */
    default_data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->weight = -1;
    /* Set Default Values */
    for (profile_id_index = 0; profile_id_index < table->keys[0].size; profile_id_index++)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, profile_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->weight = 0;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->weight = 0;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->weight = 1;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->weight = 1;
    }
    if (4 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
        data->weight = 3;
    }
    if (5 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
        data->weight = 6;
    }
    if (6 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
        data->weight = 7;
    }
    if (7 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_sqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
        data->weight = 10;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table dqm_read_weight_profiles
 * Module - 'iqs', Submodule - 'deq_default', table - 'dqm_read_weight_profiles'
 * stores the DQM read weight profiles that should configured to HW
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_dqm_read_weight_profiles_set(
    int unit)
{
    int profile_id_index;
    dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int table_index = dnx_data_iqs_deq_default_table_dqm_read_weight_profiles;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 8;
    table->info_get.key_size[0] = 8;

    /* Info - default values */
    table->values[0].default_val = "-1";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_iqs_deq_default_dqm_read_weight_profiles_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_iqs_deq_default_table_dqm_read_weight_profiles");

    /* Store Default Values */
    default_data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->weight = -1;
    /* Set Default Values */
    for (profile_id_index = 0; profile_id_index < table->keys[0].size; profile_id_index++)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, profile_id_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->weight = 0;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->weight = 0;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->weight = 0;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->weight = 0;
    }
    if (4 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
        data->weight = 1;
    }
    if (5 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
        data->weight = 2;
    }
    if (6 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
        data->weight = 2;
    }
    if (7 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dqm_read_weight_profiles_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
        data->weight = 3;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table params
 * Module - 'iqs', Submodule - 'deq_default', table - 'params'
 * stores the read weight profiles that should configured to HW for SRAM and S2D
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_params_set(
    int unit)
{
    int bw_level_index;
    dnx_data_iqs_deq_default_params_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int table_index = dnx_data_iqs_deq_default_table_params;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_iqs.credit.nof_bw_levels_get(unit);
    table->info_get.key_size[0] = dnx_data_iqs.credit.nof_bw_levels_get(unit);

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    table->values[2].default_val = "0";
    table->values[3].default_val = "0";
    table->values[4].default_val = "0";
    table->values[5].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_iqs_deq_default_params_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_iqs_deq_default_table_params");

    /* Store Default Values */
    default_data = (dnx_data_iqs_deq_default_params_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->sram_read_weight_profile_val[0] = 0;
    default_data->s2d_read_weight_profile_val[0] = 0;
    default_data->sram_extra_credits_val[0] = 0;
    default_data->s2d_extra_credits_val[0] = 0;
    default_data->sram_extra_credits_lfsr_val[0] = 0;
    default_data->s2d_extra_credits_lfsr_val[0] = 0;
    /* Set Default Values */
    for (bw_level_index = 0; bw_level_index < table->keys[0].size; bw_level_index++)
    {
        data = (dnx_data_iqs_deq_default_params_t *) dnxc_data_mgmt_table_data_get(unit, table, bw_level_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_read_weight_profile_val[0] = 0;
        data->sram_read_weight_profile_val[1] = 2;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_read_weight_profile_val[0] = 0;
        data->s2d_read_weight_profile_val[1] = 2;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_val[0] = 0;
        data->sram_extra_credits_val[1] = 4;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_val[0] = 0;
        data->s2d_extra_credits_val[1] = 4;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_lfsr_val[0] = 0;
        data->sram_extra_credits_lfsr_val[1] = 1;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_lfsr_val[0] = 0;
        data->s2d_extra_credits_lfsr_val[1] = 1;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_read_weight_profile_val[0] = 0;
        data->sram_read_weight_profile_val[1] = 3;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_read_weight_profile_val[0] = 0;
        data->s2d_read_weight_profile_val[1] = 3;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_val[0] = 0;
        data->sram_extra_credits_val[1] = 4;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_val[0] = 0;
        data->s2d_extra_credits_val[1] = 4;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_lfsr_val[0] = 0;
        data->sram_extra_credits_lfsr_val[1] = 1;
        SHR_RANGE_VERIFY(2, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_lfsr_val[0] = 0;
        data->s2d_extra_credits_lfsr_val[1] = 1;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_read_weight_profile_val[0] = 0;
        data->sram_read_weight_profile_val[1] = 2;
        data->sram_read_weight_profile_val[2] = 7;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_read_weight_profile_val[0] = 0;
        data->s2d_read_weight_profile_val[1] = 2;
        data->s2d_read_weight_profile_val[2] = 7;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_val[0] = 0;
        data->sram_extra_credits_val[1] = 12;
        data->sram_extra_credits_val[2] = 12;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_val[0] = 0;
        data->s2d_extra_credits_val[1] = 12;
        data->s2d_extra_credits_val[2] = 12;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_lfsr_val[0] = 0;
        data->sram_extra_credits_lfsr_val[1] = 0;
        data->sram_extra_credits_lfsr_val[2] = 0;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_lfsr_val[0] = 0;
        data->s2d_extra_credits_lfsr_val[1] = 0;
        data->s2d_extra_credits_lfsr_val[2] = 0;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_read_weight_profile_val[0] = 0;
        data->sram_read_weight_profile_val[1] = 2;
        data->sram_read_weight_profile_val[2] = 7;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_read_weight_profile_val[0] = 0;
        data->s2d_read_weight_profile_val[1] = 2;
        data->s2d_read_weight_profile_val[2] = 7;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_val[0] = 0;
        data->sram_extra_credits_val[1] = 12;
        data->sram_extra_credits_val[2] = 12;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_val[0] = 0;
        data->s2d_extra_credits_val[1] = 1;
        data->s2d_extra_credits_val[2] = 12;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->sram_extra_credits_lfsr_val[0] = 0;
        data->sram_extra_credits_lfsr_val[1] = 1;
        data->sram_extra_credits_lfsr_val[2] = 1;
        SHR_RANGE_VERIFY(3, 0, DNX_IQS_DEQ_PARAM_TYPE_NOF, _SHR_E_INTERNAL, "out of bound access to array")
        data->s2d_extra_credits_lfsr_val[0] = 0;
        data->s2d_extra_credits_lfsr_val[1] = 1;
        data->s2d_extra_credits_lfsr_val[2] = 1;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table dram_params
 * Module - 'iqs', Submodule - 'deq_default', table - 'dram_params'
 * stores the read weight profiles that should configured to HW for DRAM
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_dram_params_set(
    int unit)
{
    int index_index;
    dnx_data_iqs_deq_default_dram_params_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int table_index = dnx_data_iqs_deq_default_table_dram_params;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = 8;
    table->info_get.key_size[0] = 8;

    /* Info - default values */
    table->values[0].default_val = "0";
    table->values[1].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_iqs_deq_default_dram_params_t, (1 * (table->keys[0].size) + 1 /* to store default value */ ), "data of dnx_data_iqs_deq_default_table_dram_params");

    /* Store Default Values */
    default_data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->read_weight_profile_val = 0;
    default_data->read_weight_profile_th = 0;
    /* Set Default Values */
    for (index_index = 0; index_index < table->keys[0].size; index_index++)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, index_index, 0);
        sal_memcpy(data, default_data, table->size_of_values);
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, 0);
        data->read_weight_profile_val = 0;
        data->read_weight_profile_th = 8 * 1024;
    }
    if (1 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, 0);
        data->read_weight_profile_val = 0;
        data->read_weight_profile_th = 16 * 1024;
    }
    if (2 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, 0);
        data->read_weight_profile_val = 1;
        data->read_weight_profile_th = 24 * 1024;
    }
    if (3 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, 0);
        data->read_weight_profile_val = 2;
        data->read_weight_profile_th = 32 * 1024;
    }
    if (4 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 4, 0);
        data->read_weight_profile_val = 2;
        data->read_weight_profile_th = 50 * 1024;
    }
    if (5 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 5, 0);
        data->read_weight_profile_val = 2;
        data->read_weight_profile_th = 75 * 1024;
    }
    if (6 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 6, 0);
        data->read_weight_profile_val = 3;
        data->read_weight_profile_th = 100 * 1024;
    }
    if (7 < table->keys[0].size)
    {
        data = (dnx_data_iqs_deq_default_dram_params_t *) dnxc_data_mgmt_table_data_get(unit, table, 7, 0);
        data->read_weight_profile_val = 4;
        data->read_weight_profile_th = 128 * 1024;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table max_deq_cmd
 * Module - 'iqs', Submodule - 'deq_default', table - 'max_deq_cmd'
 * stores the read weight profiles that should configured to HW (sram/dram to fabric)
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_max_deq_cmd_set(
    int unit)
{
    int bw_level_index;
    int nof_active_queues_index;
    dnx_data_iqs_deq_default_max_deq_cmd_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int table_index = dnx_data_iqs_deq_default_table_max_deq_cmd;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_iqs.credit.nof_bw_levels_get(unit);
    table->info_get.key_size[0] = dnx_data_iqs.credit.nof_bw_levels_get(unit);
    table->keys[1].size = DBAL_NOF_ENUM_IQS_ACTIVE_QUEUES_VALUES;
    table->info_get.key_size[1] = DBAL_NOF_ENUM_IQS_ACTIVE_QUEUES_VALUES;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_iqs_deq_default_max_deq_cmd_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_iqs_deq_default_table_max_deq_cmd");

    /* Store Default Values */
    default_data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->value = 0;
    /* Set Default Values */
    for (bw_level_index = 0; bw_level_index < table->keys[0].size; bw_level_index++)
    {
        for (nof_active_queues_index = 0; nof_active_queues_index < table->keys[1].size; nof_active_queues_index++)
        {
            data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, bw_level_index, nof_active_queues_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 8*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 30*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 50*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 127*1024/256;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 8*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 30*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 50*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 127*1024/256;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 8*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 30*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 50*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 127*1024/256;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 4*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 15*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 25*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 64*1024/256;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set values for table s2d_max_deq_cmd
 * Module - 'iqs', Submodule - 'deq_default', table - 's2d_max_deq_cmd'
 * stores the read weight profiles that should configured to HW (sram t0 dram)
 * The function set relevant table structure in _dnx_data
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_deq_default_s2d_max_deq_cmd_set(
    int unit)
{
    int bw_level_index;
    int nof_active_queues_index;
    dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *data, *default_data;
    dnxc_data_table_t *table;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_deq_default;
    int table_index = dnx_data_iqs_deq_default_table_s2d_max_deq_cmd;
    SHR_FUNC_INIT_VARS(unit);

    table = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].tables[table_index];
    /* Set data flags as supported */
    table->flags |= DNXC_DATA_F_SUPPORTED;

    /*
     * Set key sizes
     */
    table->keys[0].size = dnx_data_iqs.credit.nof_bw_levels_get(unit);
    table->info_get.key_size[0] = dnx_data_iqs.credit.nof_bw_levels_get(unit);
    table->keys[1].size = DBAL_NOF_ENUM_IQS_ACTIVE_QUEUES_VALUES;
    table->info_get.key_size[1] = DBAL_NOF_ENUM_IQS_ACTIVE_QUEUES_VALUES;

    /* Info - default values */
    table->values[0].default_val = "0";
    /* Exit the function if the table size is zero */
    if (table->keys[0].size == 0 || table->info_get.key_size[0] == 0)
    {
        SHR_EXIT();
    }
    if (table->keys[1].size == 0 || table->info_get.key_size[1] == 0)
    {
        SHR_EXIT();
    }

    /* Allocate data buffer */
    DNXC_DATA_ALLOC(table->data, dnx_data_iqs_deq_default_s2d_max_deq_cmd_t, (1 * (table->keys[0].size) * (table->keys[1].size) + 1 /* to store default value */ ), "data of dnx_data_iqs_deq_default_table_s2d_max_deq_cmd");

    /* Store Default Values */
    default_data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, -1, -1);
    default_data->value = 0;
    /* Set Default Values */
    for (bw_level_index = 0; bw_level_index < table->keys[0].size; bw_level_index++)
    {
        for (nof_active_queues_index = 0; nof_active_queues_index < table->keys[1].size; nof_active_queues_index++)
        {
            data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, bw_level_index, nof_active_queues_index);
            sal_memcpy(data, default_data, table->size_of_values);
        }
    }
    /*
     * Set Values - Entries
     */
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 8*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 30*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 50*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_ONE);
        data->value = 127*1024/256;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 8*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 30*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 50*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_THREE);
        data->value = 127*1024/256;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 8*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 30*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 50*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_UP_TO_SEVEN);
        data->value = 127*1024/256;
    }
    if (0 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 0, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 4*1024/256;
    }
    if (1 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 1, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 15*1024/256;
    }
    if (2 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 2, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 25*1024/256;
    }
    if (3 < table->keys[0].size && DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST < table->keys[1].size)
    {
        data = (dnx_data_iqs_deq_default_s2d_max_deq_cmd_t *) dnxc_data_mgmt_table_data_get(unit, table, 3, DBAL_ENUM_FVAL_IQS_ACTIVE_QUEUES_REST);
        data->value = 64*1024/256;
    }

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_table_value_set(unit, table));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Submodule: dqcq
 */

/*
 * Features
 */
/**
 * \brief Pointer to function (per device) which set values for feature
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_dqcq_8_priorities_set(
    int unit)
{
    dnxc_data_feature_t *feature;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_dqcq;
    int feature_index = dnx_data_iqs_dqcq_8_priorities;
    SHR_FUNC_INIT_VARS(unit);

    feature = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].features[feature_index];
    /* Set default value */
    feature->default_data = 0;

    /* Set value */
    feature->data = 0;

    /* Set data flags as supported */
    feature->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_feature_value_set(unit, feature));

exit:
    SHR_FUNC_EXIT;
}

/*
 * Defines
 */
/**
 * \brief device level function which set define max_nof_contexts
 * define info:
 * max number of DQCQ contexts
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_dqcq_max_nof_contexts_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_dqcq;
    int define_index = dnx_data_iqs_dqcq_define_max_nof_contexts;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 5;

    /* Set value */
    define->data = 5;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/**
 * \brief device level function which set define nof_priorities
 * define info:
 * number of DQCQ priorities
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_dqcq_nof_priorities_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_dqcq;
    int define_index = dnx_data_iqs_dqcq_define_nof_priorities;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 2;

    /* Set value */
    define->data = 2;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: dbal
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define ipt_counters_nof_bits
 * define info:
 * nof bits in IPT counters from IPS/GCM
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_dbal_ipt_counters_nof_bits_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_dbal;
    int define_index = dnx_data_iqs_dbal_define_ipt_counters_nof_bits;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 16;

    /* Set value */
    define->data = 16;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Submodule: flush
 */

/*
 * Features
 */
/*
 * Defines
 */
/**
 * \brief device level function which set define bytes_units_to_send
 * define info:
 * Number of bytes to send from the queue in flush process (64B units)
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - see shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
static shr_error_e
jr2_a0_dnx_data_iqs_flush_bytes_units_to_send_set(
    int unit)
{
    dnxc_data_define_t *define;
    int module_index = dnx_data_module_iqs;
    int submodule_index = dnx_data_iqs_submodule_flush;
    int define_index = dnx_data_iqs_flush_define_bytes_units_to_send;
    SHR_FUNC_INIT_VARS(unit);

    define = &_dnxc_data[unit].modules[module_index].submodules[submodule_index].defines[define_index];
    /* Set default value */
    define->default_data = 128;

    /* Set value */
    define->data = 128;

    /* Set data flags as supported */
    define->flags |= DNXC_DATA_F_SUPPORTED;

    /* Override data with dynamic data (if required) */
    SHR_IF_ERR_EXIT(dnxc_data_dyn_loader_define_value_set(unit, define));


exit:
    SHR_FUNC_EXIT;
}

/*
 * Tables
 */
/*
 * Device attach func
 */
/**
 * \brief Attach device to module - attach set function to data structure
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     err - 
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e
jr2_a0_data_iqs_attach(
    int unit)
{
    dnxc_data_module_t *module = NULL;
    dnxc_data_submodule_t *submodule = NULL;
    dnxc_data_define_t *define = NULL;
    dnxc_data_feature_t *feature = NULL;
    dnxc_data_table_t *table = NULL;
    int module_index = dnx_data_module_iqs;
    int submodule_index = -1, data_index = -1;
    SHR_FUNC_INIT_VARS(unit);

    COMPILER_REFERENCE(define);
    COMPILER_REFERENCE(feature);
    COMPILER_REFERENCE(table);
    COMPILER_REFERENCE(submodule);
    COMPILER_REFERENCE(data_index);
    COMPILER_REFERENCE(submodule_index);
    module = &_dnxc_data[unit].modules[module_index];
    /*
     * Attach submodule: credit
     */
    submodule_index = dnx_data_iqs_submodule_credit;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_iqs_credit_define_nof_profiles;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_nof_profiles_set;
    data_index = dnx_data_iqs_credit_define_max_credit_balance_threshold;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_max_credit_balance_threshold_set;
    data_index = dnx_data_iqs_credit_define_max_worth;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_max_worth_set;
    data_index = dnx_data_iqs_credit_define_satisified_back_min;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_satisified_back_min_set;
    data_index = dnx_data_iqs_credit_define_satisified_back_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_satisified_back_max_set;
    data_index = dnx_data_iqs_credit_define_satisified_empty_min;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_satisified_empty_min_set;
    data_index = dnx_data_iqs_credit_define_satisified_empty_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_satisified_empty_max_set;
    data_index = dnx_data_iqs_credit_define_hungry_min;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_hungry_min_set;
    data_index = dnx_data_iqs_credit_define_hungry_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_hungry_max_set;
    data_index = dnx_data_iqs_credit_define_hungry_mult_min;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_hungry_mult_min_set;
    data_index = dnx_data_iqs_credit_define_hungry_mult_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_hungry_mult_max_set;
    data_index = dnx_data_iqs_credit_define_nof_bw_levels;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_nof_bw_levels_set;
    data_index = dnx_data_iqs_credit_define_fmq_credit_fc_on_th;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_credit_fc_on_th_set;
    data_index = dnx_data_iqs_credit_define_fmq_credit_fc_off_th;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_credit_fc_off_th_set;
    data_index = dnx_data_iqs_credit_define_fmq_byte_fc_on_th;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_byte_fc_on_th_set;
    data_index = dnx_data_iqs_credit_define_fmq_byte_fc_off_th;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_byte_fc_off_th_set;
    data_index = dnx_data_iqs_credit_define_fmq_eir_credit_fc_th;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_eir_credit_fc_th_set;
    data_index = dnx_data_iqs_credit_define_fmq_eir_byte_fc_th;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_eir_byte_fc_th_set;
    data_index = dnx_data_iqs_credit_define_fmq_nof_be_classes;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_nof_be_classes_set;
    data_index = dnx_data_iqs_credit_define_fmq_max_be_weight;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_max_be_weight_set;
    data_index = dnx_data_iqs_credit_define_fmq_max_burst_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_max_burst_max_set;
    data_index = dnx_data_iqs_credit_define_fmq_shp_crdt_rate_mltp;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_shp_crdt_rate_mltp_set;
    data_index = dnx_data_iqs_credit_define_fmq_shp_crdt_rate_delta;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_shp_crdt_rate_delta_set;
    data_index = dnx_data_iqs_credit_define_max_rate_profile_preset_gbps;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_max_rate_profile_preset_gbps_set;
    data_index = dnx_data_iqs_credit_define_worth;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_worth_set;
    data_index = dnx_data_iqs_credit_define_fmq_shp_rate_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_credit_fmq_shp_rate_max_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_iqs_credit_watchdog_fixed_period;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_iqs_credit_watchdog_fixed_period_set;
    data_index = dnx_data_iqs_credit_fmq_shp_zero_rate_allowed;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_iqs_credit_fmq_shp_zero_rate_allowed_set;
    data_index = dnx_data_iqs_credit_credit_balance_support;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_iqs_credit_credit_balance_support_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: deq_default
     */
    submodule_index = dnx_data_iqs_submodule_deq_default;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_iqs_deq_default_define_low_delay_deq_bytes;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_deq_default_low_delay_deq_bytes_set;
    data_index = dnx_data_iqs_deq_default_define_credit_balance_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_deq_default_credit_balance_max_set;
    data_index = dnx_data_iqs_deq_default_define_credit_balance_resolution;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_deq_default_credit_balance_resolution_set;
    data_index = dnx_data_iqs_deq_default_define_s2d_credit_balance_max;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_deq_default_s2d_credit_balance_max_set;
    data_index = dnx_data_iqs_deq_default_define_s2d_credit_balance_resolution;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_deq_default_s2d_credit_balance_resolution_set;
    data_index = dnx_data_iqs_deq_default_define_sram_to_fabric_credit_lfsr_thr;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_deq_default_sram_to_fabric_credit_lfsr_thr_set;
    data_index = dnx_data_iqs_deq_default_define_sram_to_fabric_credit_lfsr_mask;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_deq_default_sram_to_fabric_credit_lfsr_mask_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_iqs_deq_default_dqcq_fc_to_dram;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_iqs_deq_default_dqcq_fc_to_dram_set;

    /*
     * Attach tables: 
     */
    data_index = dnx_data_iqs_deq_default_table_sqm_read_weight_profiles;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_iqs_deq_default_sqm_read_weight_profiles_set;
    data_index = dnx_data_iqs_deq_default_table_dqm_read_weight_profiles;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_iqs_deq_default_dqm_read_weight_profiles_set;
    data_index = dnx_data_iqs_deq_default_table_params;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_iqs_deq_default_params_set;
    data_index = dnx_data_iqs_deq_default_table_dram_params;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_iqs_deq_default_dram_params_set;
    data_index = dnx_data_iqs_deq_default_table_max_deq_cmd;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_iqs_deq_default_max_deq_cmd_set;
    data_index = dnx_data_iqs_deq_default_table_s2d_max_deq_cmd;
    table = &submodule->tables[data_index];
    table->set = jr2_a0_dnx_data_iqs_deq_default_s2d_max_deq_cmd_set;
    /*
     * Attach submodule: dqcq
     */
    submodule_index = dnx_data_iqs_submodule_dqcq;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_iqs_dqcq_define_max_nof_contexts;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_dqcq_max_nof_contexts_set;
    data_index = dnx_data_iqs_dqcq_define_nof_priorities;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_dqcq_nof_priorities_set;

    /*
     * Attach features: 
     */
    data_index = dnx_data_iqs_dqcq_8_priorities;
    feature = &submodule->features[data_index];
    feature->set = jr2_a0_dnx_data_iqs_dqcq_8_priorities_set;

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: dbal
     */
    submodule_index = dnx_data_iqs_submodule_dbal;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_iqs_dbal_define_ipt_counters_nof_bits;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_dbal_ipt_counters_nof_bits_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */
    /*
     * Attach submodule: flush
     */
    submodule_index = dnx_data_iqs_submodule_flush;
    submodule = &module->submodules[submodule_index];

    /*
     * Attach defines: 
     */
    data_index = dnx_data_iqs_flush_define_bytes_units_to_send;
    define = &submodule->defines[data_index];
    define->set = jr2_a0_dnx_data_iqs_flush_bytes_units_to_send_set;

    /*
     * Attach features: 
     */

    /*
     * Attach tables: 
     */

    SHR_FUNC_EXIT;
}
#undef BSL_LOG_MODULE
/* *INDENT-ON* */
