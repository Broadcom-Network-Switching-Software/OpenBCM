/** \file dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp.c
 * Logical DB enums \n 
 * DO NOT EDIT THIS FILE!\n 
 * This file is auto-generated.\n 
 * Edits to this file will be lost when it is regenerated.\n 
 * \n 
 */
/*
 * 
 This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 
 Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_header_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_HEADER;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_HEADER /* table id*/, is_valid /* is valid*/, "ITPP_HEADER" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_HEADER" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 0 + 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_HEADER /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY32 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 512;
            db_field.nof_instances = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_HEADER, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: HEADER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 1;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_HEADER_0r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RCVD_HDR_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 0;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_HEADER_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RCVD_HDR_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_HEADER, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_header_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_HEADER;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_HEADER /* table id*/, is_valid /* is valid*/, "ITPPD_HEADER" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_HEADER" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 0 + 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_HEADER /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY32 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 512;
            db_field.nof_instances = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_HEADER, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: HEADER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 1;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_HEADER_0r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RCVD_HDR_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 0;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_HEADER_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RCVD_HDR_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_HEADER, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_attributes_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_ATTRIBUTES;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_ATTRIBUTES /* table id*/, is_valid /* is valid*/, "ITPP_ATTRIBUTES" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_ATTRIBUTES" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 12);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PACKET_SIZE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 14;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DP /* field id*/, DBAL_FIELD_TYPE_DEF_DP /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CNI /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_ACTION_TYPE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PD_CUD /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 32;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PD_CUD_TYPE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 3;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PP_DSP /* field id*/, DBAL_FIELD_TYPE_DEF_DSP /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DEST_DEVICE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 11;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IS_FABRIC /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IS_DRAM /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_QNUM /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 18;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MAC_TS /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY8 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 48;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_ATTRIBUTES, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: PACKET_SIZE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PACKET_SIZE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PACKET_SIZEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DP + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_DPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CNI  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_CNI + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_CNIf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ACTION_TYPE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_ACTION_TYPE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_ACTION_TYPEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PD_CUD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PD_CUD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PD_CUDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PD_CUD_TYPE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PD_CUD_TYPE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PD_CUD_TYPEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PP_DSP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PP_DSP + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PP_DSPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DEST_DEVICE_ID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DEST_DEVICE_ID + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_DEST_DEVICE_IDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_FABRIC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IS_FABRIC + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_IS_FABRICf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_DRAM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IS_DRAM + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_IS_IS_DRAMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: QNUM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_QNUM + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_QNUMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MAC_TS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MAC_TS + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_MAC_TSf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_ATTRIBUTES, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_attributes_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_ATTRIBUTES;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_ATTRIBUTES /* table id*/, is_valid /* is valid*/, "ITPPD_ATTRIBUTES" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_ATTRIBUTES" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 12);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PACKET_SIZE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 14;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DP /* field id*/, DBAL_FIELD_TYPE_DEF_DP /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CNI /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_ACTION_TYPE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PD_CUD /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 32;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PD_CUD_TYPE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 3;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_PP_DSP /* field id*/, DBAL_FIELD_TYPE_DEF_DSP /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DEST_DEVICE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 11;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IS_FABRIC /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IS_DRAM /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_QNUM /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 18;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MAC_TS /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY8 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 48;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_ATTRIBUTES, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: PACKET_SIZE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PACKET_SIZE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PACKET_SIZEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DP + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_DPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CNI  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_CNI + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_CNIf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ACTION_TYPE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_ACTION_TYPE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_ACTION_TYPEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PD_CUD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PD_CUD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PD_CUDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PD_CUD_TYPE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PD_CUD_TYPE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PD_CUD_TYPEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: PP_DSP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_PP_DSP + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_PP_DSPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DEST_DEVICE_ID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DEST_DEVICE_ID + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_DEST_DEVICE_IDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_FABRIC  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IS_FABRIC + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_IS_FABRICf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IS_DRAM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IS_DRAM + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_IS_IS_DRAMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: QNUM  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_QNUM + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_QNUMf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: MAC_TS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MAC_TS + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_RECEIVED_ATTRIBUTESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_RVCD_MAC_TSf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_ATTRIBUTES, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_generated_values_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_GENERATED_VALUES;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_GENERATED_VALUES /* table id*/, is_valid /* is valid*/, "ITPP_GENERATED_VALUES" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_GENERATED_VALUES" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 4);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MEM_SOFT_ERR /* field id*/, DBAL_FIELD_TYPE_DEF_MEM_SOFT_ERR /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BYTES_TO_ADD /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 7;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BYTES_TO_REMOVE /* field id*/, DBAL_FIELD_TYPE_DEF_BYTES_TO_REMOVE /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DISCARD /* field id*/, DBAL_FIELD_TYPE_DEF_DISCARD /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_GENERATED_VALUES, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MEM_SOFT_ERR  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MEM_SOFT_ERR + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_MEM_SOFT_ERRf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BYTES_TO_ADD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BYTES_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_BYTES_TO_ADDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BYTES_TO_REMOVE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BYTES_TO_REMOVE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_BYTES_TO_REMOVEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DISCARD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DISCARD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_DISCARD_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_GENERATED_VALUES, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_generated_values_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_GENERATED_VALUES;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_GENERATED_VALUES /* table id*/, is_valid /* is valid*/, "ITPPD_GENERATED_VALUES" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_GENERATED_VALUES" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 4);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MEM_SOFT_ERR /* field id*/, DBAL_FIELD_TYPE_DEF_MEM_SOFT_ERR /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BYTES_TO_ADD /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 7;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BYTES_TO_REMOVE /* field id*/, DBAL_FIELD_TYPE_DEF_BYTES_TO_REMOVE /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DISCARD /* field id*/, DBAL_FIELD_TYPE_DEF_DISCARD /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_GENERATED_VALUES, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MEM_SOFT_ERR  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MEM_SOFT_ERR + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_MEM_SOFT_ERRf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BYTES_TO_ADD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BYTES_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_BYTES_TO_ADDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BYTES_TO_REMOVE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BYTES_TO_REMOVE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_BYTES_TO_REMOVEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DISCARD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DISCARD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_DISCARD_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_GENERATED_VALUES, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_generated_headder_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_GENERATED_HEADDER;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_GENERATED_HEADDER /* table id*/, is_valid /* is valid*/, "ITPP_GENERATED_HEADDER" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_GENERATED_HEADDER" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 0 + 3);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_HEADER_TO_ADD /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY32 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 256;
            db_field.nof_instances = 3;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_GENERATED_HEADDER, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: HEADER_TO_ADD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 0;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_GENERATED_HDRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_HEADER_TO_ADD_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 2;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_HEADER_TO_ADD_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 1;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_HEADER_TO_ADD_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__header_to_add = 0;
                        /** size of HEADER_TO_ADD field  */
                        result_size__header_to_add += 256;
                        access_params->data_offset.formula_int = result_size__header_to_add; 
                    }
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_GENERATED_HEADDER, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_generated_headder_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_GENERATED_HEADDER;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_GENERATED_HEADDER /* table id*/, is_valid /* is valid*/, "ITPPD_GENERATED_HEADDER" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_GENERATED_HEADDER" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 0 + 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_HEADER_TO_ADD /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY32 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 256;
            db_field.nof_instances = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_GENERATED_HEADDER, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: HEADER_TO_ADD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 0;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_GENERATED_HDRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_HEADER_TO_ADD_1f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 1;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_LAST_GENERATED_VALUESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_HEADER_TO_ADD_0f;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_GENERATED_HEADDER, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_max_latency_lat_pkt_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_MAX_LATENCY_LAT_PKT;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_MAX_LATENCY_LAT_PKT /* table id*/, is_valid /* is valid*/, "ITPP_MAX_LATENCY_LAT_PKT" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_MAX_LATENCY_LAT_PKT" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 5);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MAX_LATENCY_VALUE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 32;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CURRENT_TS_COUNT_VAL /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY8 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 48;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DEST_DEV_LAT_PKT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 11;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DEST_PORT_LAT_PKT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TRF_CLS_LAT_PKT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 3;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_MAX_LATENCY_LAT_PKT, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MAX_LATENCY_VALUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MAX_LATENCY_VALUE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MAX_LATENCY_VALUEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CURRENT_TS_COUNT_VAL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_CURRENT_TS_COUNT_VAL + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CURRENT_TS_COUNT_VALf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DEST_DEV_LAT_PKT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DEST_DEV_LAT_PKT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DEST_DEV_LAT_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DEST_PORT_LAT_PKT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DEST_PORT_LAT_PKT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DEST_PORT_LAT_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TRF_CLS_LAT_PKT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRF_CLS_LAT_PKT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = TRF_CLS_LAT_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_MAX_LATENCY_LAT_PKT, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_max_latency_lat_pkt_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_MAX_LATENCY_LAT_PKT;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_MAX_LATENCY_LAT_PKT /* table id*/, is_valid /* is valid*/, "ITPPD_MAX_LATENCY_LAT_PKT" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_MAX_LATENCY_LAT_PKT" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 5);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MAX_LATENCY_VALUE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 32;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CURRENT_TS_COUNT_VAL /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY8 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 48;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DEST_DEV_LAT_PKT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 11;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DEST_PORT_LAT_PKT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TRF_CLS_LAT_PKT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 3;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_MAX_LATENCY_LAT_PKT, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: MAX_LATENCY_VALUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MAX_LATENCY_VALUE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = MAX_LATENCY_VALUEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: CURRENT_TS_COUNT_VAL  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_CURRENT_TS_COUNT_VAL + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = CURRENT_TS_COUNT_VALf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DEST_DEV_LAT_PKT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DEST_DEV_LAT_PKT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DEST_DEV_LAT_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DEST_PORT_LAT_PKT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DEST_PORT_LAT_PKT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DEST_PORT_LAT_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TRF_CLS_LAT_PKT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TRF_CLS_LAT_PKT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCY_LAT_PKTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = TRF_CLS_LAT_PKTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_MAX_LATENCY_LAT_PKT, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_deleted_lat_pkts_cnt_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_DELETED_LAT_PKTS_CNT;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_DELETED_LAT_PKTS_CNT /* table id*/, is_valid /* is valid*/, "ITPP_DELETED_LAT_PKTS_CNT" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_DELETED_LAT_PKTS_CNT" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DELETED_LAT_PKTS_CNT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 31;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DELETED_LAT_PKTS_CNT_OVF /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_DELETED_LAT_PKTS_CNT, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: DELETED_LAT_PKTS_CNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DELETED_LAT_PKTS_CNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_DELETED_LAT_PKTS_CNTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DELETED_LAT_PKTS_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DELETED_LAT_PKTS_CNT_OVF  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DELETED_LAT_PKTS_CNT_OVF + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_DELETED_LAT_PKTS_CNTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DELETED_LAT_PKTS_CNT_OVFf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_DELETED_LAT_PKTS_CNT, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_deleted_lat_pkts_cnt_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_DELETED_LAT_PKTS_CNT;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_DELETED_LAT_PKTS_CNT /* table id*/, is_valid /* is valid*/, "ITPPD_DELETED_LAT_PKTS_CNT" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_DELETED_LAT_PKTS_CNT" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DELETED_LAT_PKTS_CNT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 31;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_DELETED_LAT_PKTS_CNT_OVF /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_DELETED_LAT_PKTS_CNT, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: DELETED_LAT_PKTS_CNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DELETED_LAT_PKTS_CNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_DELETED_LAT_PKTS_CNTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DELETED_LAT_PKTS_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: DELETED_LAT_PKTS_CNT_OVF  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_DELETED_LAT_PKTS_CNT_OVF + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_DELETED_LAT_PKTS_CNTr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = DELETED_LAT_PKTS_CNT_OVFf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_DELETED_LAT_PKTS_CNT, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_big_lat_cni_cntr_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_BIG_LAT_CNI_CNTR;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_BIG_LAT_CNI_CNTR /* table id*/, is_valid /* is valid*/, "ITPP_BIG_LAT_CNI_CNTR" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_BIG_LAT_CNI_CNTR" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BIG_LAT_CNI_CNT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 31;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BIG_LAT_CNI_CNT_OVF /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_BIG_LAT_CNI_CNTR, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: BIG_LAT_CNI_CNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BIG_LAT_CNI_CNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_BIG_LAT_CNI_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BIG_LAT_CNI_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BIG_LAT_CNI_CNT_OVF  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BIG_LAT_CNI_CNT_OVF + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_BIG_LAT_CNI_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BIG_LAT_CNI_CNT_OVFf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_BIG_LAT_CNI_CNTR, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_big_lat_cni_cntr_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_BIG_LAT_CNI_CNTR;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_BIG_LAT_CNI_CNTR /* table id*/, is_valid /* is valid*/, "ITPPD_BIG_LAT_CNI_CNTR" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_BIG_LAT_CNI_CNTR" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BIG_LAT_CNI_CNT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 31;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_BIG_LAT_CNI_CNT_OVF /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_BIG_LAT_CNI_CNTR, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: BIG_LAT_CNI_CNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BIG_LAT_CNI_CNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_BIG_LAT_CNI_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BIG_LAT_CNI_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: BIG_LAT_CNI_CNT_OVF  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_BIG_LAT_CNI_CNT_OVF + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_BIG_LAT_CNI_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = BIG_LAT_CNI_CNT_OVFf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_BIG_LAT_CNI_CNTR, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_incoming_packet_cntr_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_INCOMING_PACKET_CNTR;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_INCOMING_PACKET_CNTR /* table id*/, is_valid /* is valid*/, "ITPP_INCOMING_PACKET_CNTR" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_INCOMING_PACKET_CNTR" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_INCOMING_PACKET_CNT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 31;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_INCOMING_PACKET_CNT_OVF /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_INCOMING_PACKET_CNTR, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: INCOMING_PACKET_CNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_INCOMING_PACKET_CNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_INCOMING_PACKET_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INCOMING_PACKET_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: INCOMING_PACKET_CNT_OVF  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_INCOMING_PACKET_CNT_OVF + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_INCOMING_PACKET_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INCOMING_PACKET_CNT_OVFf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_INCOMING_PACKET_CNTR, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_incoming_packet_cntr_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_INCOMING_PACKET_CNTR;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_INCOMING_PACKET_CNTR /* table id*/, is_valid /* is valid*/, "ITPPD_INCOMING_PACKET_CNTR" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_INCOMING_PACKET_CNTR" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_INCOMING_PACKET_CNT /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 31;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_INCOMING_PACKET_CNT_OVF /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_INCOMING_PACKET_CNTR, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: INCOMING_PACKET_CNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_INCOMING_PACKET_CNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_INCOMING_PACKET_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INCOMING_PACKET_CNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: INCOMING_PACKET_CNT_OVF  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_INCOMING_PACKET_CNT_OVF + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_INCOMING_PACKET_CNTRr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INCOMING_PACKET_CNT_OVFf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_INCOMING_PACKET_CNTR, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_max_latency_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPP_MAX_LATENCY;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPP_MAX_LATENCY /* table id*/, is_valid /* is valid*/, "ITPP_MAX_LATENCY" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPP_MAX_LATENCY" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 7);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_VALUE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 32;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_POINTER /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 20;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_PKT_WAS_DROP /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_CURRENT_TS_COUNT /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY8 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 48;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_TRF_CLS /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 3;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_PORT_ID /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_DEST_DEV /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 11;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPP_MAX_LATENCY, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: LAT_VALUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_VALUE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_VALUEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_POINTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_POINTER + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_POINTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_PKT_WAS_DROP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_PKT_WAS_DROP + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_PKT_WAS_DROPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_CURRENT_TS_COUNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_CURRENT_TS_COUNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_CURRENT_TS_COUNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_TRF_CLS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_TRF_CLS + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_TRF_CLSf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_PORT_ID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_PORT_ID + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_PORT_IDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_DEST_DEV  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_DEST_DEV + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPP_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_DEST_DEVf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPP_MAX_LATENCY, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_max_latency_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_ITPPD_MAX_LATENCY;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_ITPPD_MAX_LATENCY /* table id*/, is_valid /* is valid*/, "ITPPD_MAX_LATENCY" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "ITPPD_MAX_LATENCY" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 7);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_VALUE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 32;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_POINTER /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 20;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_PKT_WAS_DROP /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_CURRENT_TS_COUNT /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY8 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 48;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_TRF_CLS /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 3;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_PORT_ID /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 8;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_LAT_DEST_DEV /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 11;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_ITPPD_MAX_LATENCY, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: LAT_VALUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_VALUE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_VALUEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_POINTER  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_POINTER + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_POINTERf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_PKT_WAS_DROP  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_PKT_WAS_DROP + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_PKT_WAS_DROPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_CURRENT_TS_COUNT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_CURRENT_TS_COUNT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_CURRENT_TS_COUNTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_TRF_CLS  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_TRF_CLS + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_TRF_CLSf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_PORT_ID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_PORT_ID + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_PORT_IDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: LAT_DEST_DEV  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, FALSE /* is register*/, TRUE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_LAT_DEST_DEV + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDm;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = ITPPD_MAX_LATENCYm;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAT_DEST_DEVf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDm /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_ITPPD_MAX_LATENCY, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_lbp_debug_signals_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_LBP_DEBUG_SIGNALS;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_LBP_DEBUG_SIGNALS /* table id*/, is_valid /* is valid*/, "LBP_DEBUG_SIGNALS" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "LBP_DEBUG_SIGNALS" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 3 + 2);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_SIG_BYTES_TO_ADD /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 7;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_SIG_BYTES_TO_REMOVE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 7;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_HEADER_DATA /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY32 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 512;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TM_CMD /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY32 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 512;
            db_field.nof_instances = 2;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_LBP_DEBUG_SIGNALS, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: SIG_BYTES_TO_REMOVE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SIG_BYTES_TO_REMOVE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_IHB_DEBUG_REGISTER_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = IHB_BYTES_TO_STRIPf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: SIG_BYTES_TO_ADD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_SIG_BYTES_TO_ADD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_IHB_DEBUG_REGISTER_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = IHB_BYTES_TO_PREPENDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: HEADER_DATA  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_HEADER_DATA + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_IHB_DEBUG_REGISTER_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = IHB_HEADER_DATAf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: TM_CMD  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 0;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TM_CMD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_IHB_TM_CMD_HALF_1r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        access_params->data_offset.formula_int = 0; 
                    }
                }
            }
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                instance_index = 1;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TM_CMD + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IRE_IHB_TM_CMD_HALF_2r;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        access_params->data_offset.formula_int = 0; 
                    }
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_LBP_DEBUG_SIGNALS, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_ipmf3_last_fes_debug_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_IPMF3_LAST_FES_DEBUG;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_IPMF3_LAST_FES_DEBUG /* table id*/, is_valid /* is valid*/, "IPMF3_LAST_FES_DEBUG" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_SYSTEM;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "IPMF3_LAST_FES_DEBUG" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 4);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CONTEXT /* field id*/, DBAL_FIELD_TYPE_DEF_ACL_CONTEXT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 6;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPMF3_ACTION /* field id*/, DBAL_FIELD_TYPE_DEF_IPMF3_ACTION /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 7;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_FES_ACTION_VALUE /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 32;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_FES_DATA_IN /* field id*/, DBAL_FIELD_TYPE_DEF_ARRAY32 /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 64;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_IPMF3_LAST_FES_DEBUG, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: CONTEXT  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_CONTEXT + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPD_DBG_LAST_FESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = LAST_CONTEXTf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: IPMF3_ACTION  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPMF3_ACTION + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPD_DBG_LAST_FESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OUT_ACTION_TYPEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: FES_ACTION_VALUE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_FES_ACTION_VALUE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPD_DBG_LAST_FESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = OUT_ACTION_VALUEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: FES_DATA_IN  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_FES_DATA_IN + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPD_DBG_LAST_FESr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = IN_KEYf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_IPMF3_LAST_FES_DEBUG, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_debug_flp_datapath_traps_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_DEBUG_FLP_DATAPATH_TRAPS;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_DEBUG_FLP_DATAPATH_TRAPS /* table id*/, is_valid /* is valid*/, "DEBUG_FLP_DATAPATH_TRAPS" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_DIAGNOSTICS;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "DEBUG_FLP_DATAPATH_TRAPS" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 37);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_RESERVED_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_ETHERNET_SA_MC_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_ETHERNET_SA_EQUAL_DA_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_VERSION_ERROR_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_CHECKSUM_ERROR_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_TOTAL_LENGTH_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_TTL0_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_HAS_OPTIONS_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_TTL1_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_SIP_EQUAL_DIP_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_DIP_ZERO_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV4_SIP_IS_MC_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_VERSION_ERROR_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_HOP_COUNT0_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_HOP_COUNT1_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_MULTICAST_SOURCE_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_NEXT_HEADER_NULL_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IPV6_MULTICAST_DESTINATION_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MPLS_TTL0_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_MPLS_TTL1_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TCP_SN_FLAGS_ZERO_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TCP_SYN_FUN_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TCP_EQUAL_PORTS_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TCP_FRAGMENT_INCOMPLETE_HEADER_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_TCP_FRAGMENT_OFFSET_LT8_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_UDP_EQUAL_PORTS_TRAP_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_FCOE_FABRIC_PROVIDED_SECURITY_ENABLE /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_DEBUG_FLP_DATAPATH_TRAPS, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: RESERVED_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_RESERVED_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: ETHERNET_SA_MC_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_ETHERNET_SA_MC_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: ETHERNET_SA_EQUAL_DA_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_ETHERNET_SA_EQUAL_DA_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_VERSION_ERROR_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_VERSION_ERROR_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_CHECKSUM_ERROR_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_CHECKSUM_ERROR_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_TOTAL_LENGTH_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_TOTAL_LENGTH_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_TTL0_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_TTL0_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_HAS_OPTIONS_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_HAS_OPTIONS_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_TTL1_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_TTL1_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_SIP_EQUAL_DIP_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_SIP_EQUAL_DIP_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_DIP_ZERO_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_DIP_ZERO_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV4_SIP_IS_MC_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV4_SIP_IS_MC_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_VERSION_ERROR_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_VERSION_ERROR_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_HOP_COUNT0_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_HOP_COUNT0_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_HOP_COUNT1_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_HOP_COUNT1_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_MULTICAST_SOURCE_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_MULTICAST_SOURCE_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_NEXT_HEADER_NULL_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_NEXT_HEADER_NULL_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: IPV6_MULTICAST_DESTINATION_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IPV6_MULTICAST_DESTINATION_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: MPLS_TTL0_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MPLS_TTL0_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: MPLS_TTL1_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_MPLS_TTL1_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: TCP_SN_FLAGS_ZERO_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TCP_SN_FLAGS_ZERO_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_flags_zero_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        /** size of TCP_SN_FLAGS_ZERO_TRAP_ENABLE field  */
                        result_size__tcp_sn_flags_zero_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable + result_size__tcp_sn_flags_zero_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: TCP_SYN_FUN_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TCP_SYN_FUN_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_flags_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_zero_flags_set_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        /** size of TCP_SN_FLAGS_ZERO_TRAP_ENABLE field  */
                        result_size__tcp_sn_flags_zero_trap_enable += 1;
                        /** size of TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE field  */
                        result_size__tcp_sn_zero_flags_set_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable + result_size__tcp_sn_flags_zero_trap_enable + result_size__tcp_sn_zero_flags_set_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: TCP_EQUAL_PORTS_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TCP_EQUAL_PORTS_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_flags_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_zero_flags_set_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_syn_fun_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        /** size of TCP_SN_FLAGS_ZERO_TRAP_ENABLE field  */
                        result_size__tcp_sn_flags_zero_trap_enable += 1;
                        /** size of TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE field  */
                        result_size__tcp_sn_zero_flags_set_trap_enable += 1;
                        /** size of TCP_SYN_FUN_TRAP_ENABLE field  */
                        result_size__tcp_syn_fun_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable + result_size__tcp_sn_flags_zero_trap_enable + result_size__tcp_sn_zero_flags_set_trap_enable + result_size__tcp_syn_fun_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: TCP_FRAGMENT_INCOMPLETE_HEADER_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TCP_FRAGMENT_INCOMPLETE_HEADER_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_flags_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_zero_flags_set_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_syn_fun_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_equal_ports_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        /** size of TCP_SN_FLAGS_ZERO_TRAP_ENABLE field  */
                        result_size__tcp_sn_flags_zero_trap_enable += 1;
                        /** size of TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE field  */
                        result_size__tcp_sn_zero_flags_set_trap_enable += 1;
                        /** size of TCP_SYN_FUN_TRAP_ENABLE field  */
                        result_size__tcp_syn_fun_trap_enable += 1;
                        /** size of TCP_EQUAL_PORTS_TRAP_ENABLE field  */
                        result_size__tcp_equal_ports_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable + result_size__tcp_sn_flags_zero_trap_enable + result_size__tcp_sn_zero_flags_set_trap_enable + result_size__tcp_syn_fun_trap_enable + result_size__tcp_equal_ports_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: TCP_FRAGMENT_OFFSET_LT8_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_TCP_FRAGMENT_OFFSET_LT8_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_flags_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_zero_flags_set_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_syn_fun_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_equal_ports_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_fragment_incomplete_header_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        /** size of TCP_SN_FLAGS_ZERO_TRAP_ENABLE field  */
                        result_size__tcp_sn_flags_zero_trap_enable += 1;
                        /** size of TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE field  */
                        result_size__tcp_sn_zero_flags_set_trap_enable += 1;
                        /** size of TCP_SYN_FUN_TRAP_ENABLE field  */
                        result_size__tcp_syn_fun_trap_enable += 1;
                        /** size of TCP_EQUAL_PORTS_TRAP_ENABLE field  */
                        result_size__tcp_equal_ports_trap_enable += 1;
                        /** size of TCP_FRAGMENT_INCOMPLETE_HEADER_TRAP_ENABLE field  */
                        result_size__tcp_fragment_incomplete_header_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable + result_size__tcp_sn_flags_zero_trap_enable + result_size__tcp_sn_zero_flags_set_trap_enable + result_size__tcp_syn_fun_trap_enable + result_size__tcp_equal_ports_trap_enable + result_size__tcp_fragment_incomplete_header_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: UDP_EQUAL_PORTS_TRAP_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_UDP_EQUAL_PORTS_TRAP_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_flags_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_zero_flags_set_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_syn_fun_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_equal_ports_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_fragment_incomplete_header_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_fragment_offset_lt8_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        /** size of TCP_SN_FLAGS_ZERO_TRAP_ENABLE field  */
                        result_size__tcp_sn_flags_zero_trap_enable += 1;
                        /** size of TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE field  */
                        result_size__tcp_sn_zero_flags_set_trap_enable += 1;
                        /** size of TCP_SYN_FUN_TRAP_ENABLE field  */
                        result_size__tcp_syn_fun_trap_enable += 1;
                        /** size of TCP_EQUAL_PORTS_TRAP_ENABLE field  */
                        result_size__tcp_equal_ports_trap_enable += 1;
                        /** size of TCP_FRAGMENT_INCOMPLETE_HEADER_TRAP_ENABLE field  */
                        result_size__tcp_fragment_incomplete_header_trap_enable += 1;
                        /** size of TCP_FRAGMENT_OFFSET_LT8_TRAP_ENABLE field  */
                        result_size__tcp_fragment_offset_lt8_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable + result_size__tcp_sn_flags_zero_trap_enable + result_size__tcp_sn_zero_flags_set_trap_enable + result_size__tcp_syn_fun_trap_enable + result_size__tcp_equal_ports_trap_enable + result_size__tcp_fragment_incomplete_header_trap_enable + result_size__tcp_fragment_offset_lt8_trap_enable; 
                    }
                }
            }
        }
        /** set (hl direct) accesses for field: FCOE_FABRIC_PROVIDED_SECURITY_ENABLE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_FCOE_FABRIC_PROVIDED_SECURITY_ENABLE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPB_DBG_FLP_DATA_PATH_TRAPr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALIDf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                    {
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__reserved_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ethernet_sa_equal_da_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_checksum_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_total_length_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_has_options_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_equal_dip_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_dip_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv4_sip_is_mc_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_version_error_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_hop_count1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_loopback_address_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_next_header_null_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_unspecified_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_link_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_site_local_source_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_compatible_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_ipv4_mapped_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__ipv6_multicast_destination_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl0_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__mpls_ttl1_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_flags_zero_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_sn_zero_flags_set_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_syn_fun_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_equal_ports_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_fragment_incomplete_header_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__tcp_fragment_offset_lt8_trap_enable = 0;
                        /** size is calculated by the Autocoder  */
                        uint32 result_size__udp_equal_ports_trap_enable = 0;
                        /** size of RESERVED_TRAP_ENABLE field  */
                        result_size__reserved_trap_enable += 1;
                        /** size of ETHERNET_SA_MC_TRAP_ENABLE field  */
                        result_size__ethernet_sa_mc_trap_enable += 1;
                        /** size of ETHERNET_SA_EQUAL_DA_TRAP_ENABLE field  */
                        result_size__ethernet_sa_equal_da_trap_enable += 1;
                        /** size of IPV4_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_version_error_trap_enable += 1;
                        /** size of IPV4_CHECKSUM_ERROR_TRAP_ENABLE field  */
                        result_size__ipv4_checksum_error_trap_enable += 1;
                        /** size of IPV4_TOTAL_LENGTH_TRAP_ENABLE field  */
                        result_size__ipv4_total_length_trap_enable += 1;
                        /** size of IPV4_TTL0_TRAP_ENABLE field  */
                        result_size__ipv4_ttl0_trap_enable += 1;
                        /** size of IPV4_HAS_OPTIONS_TRAP_ENABLE field  */
                        result_size__ipv4_has_options_trap_enable += 1;
                        /** size of IPV4_TTL1_TRAP_ENABLE field  */
                        result_size__ipv4_ttl1_trap_enable += 1;
                        /** size of IPV4_SIP_EQUAL_DIP_TRAP_ENABLE field  */
                        result_size__ipv4_sip_equal_dip_trap_enable += 1;
                        /** size of IPV4_DIP_ZERO_TRAP_ENABLE field  */
                        result_size__ipv4_dip_zero_trap_enable += 1;
                        /** size of IPV4_SIP_IS_MC_TRAP_ENABLE field  */
                        result_size__ipv4_sip_is_mc_trap_enable += 1;
                        /** size of IPV6_VERSION_ERROR_TRAP_ENABLE field  */
                        result_size__ipv6_version_error_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT0_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count0_trap_enable += 1;
                        /** size of IPV6_HOP_COUNT1_TRAP_ENABLE field  */
                        result_size__ipv6_hop_count1_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_destination_trap_enable += 1;
                        /** size of IPV6_LOOPBACK_ADDRESS_TRAP_ENABLE field  */
                        result_size__ipv6_loopback_address_trap_enable += 1;
                        /** size of IPV6_MULTICAST_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_source_trap_enable += 1;
                        /** size of IPV6_NEXT_HEADER_NULL_TRAP_ENABLE field  */
                        result_size__ipv6_next_header_null_trap_enable += 1;
                        /** size of IPV6_UNSPECIFIED_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_unspecified_source_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_destination_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_destination_trap_enable += 1;
                        /** size of IPV6_LINK_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_link_local_source_trap_enable += 1;
                        /** size of IPV6_SITE_LOCAL_SOURCE_TRAP_ENABLE field  */
                        result_size__ipv6_site_local_source_trap_enable += 1;
                        /** size of IPV6_IPV4_COMPATIBLE_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_compatible_destination_trap_enable += 1;
                        /** size of IPV6_IPV4_MAPPED_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_ipv4_mapped_destination_trap_enable += 1;
                        /** size of IPV6_MULTICAST_DESTINATION_TRAP_ENABLE field  */
                        result_size__ipv6_multicast_destination_trap_enable += 1;
                        /** size of MPLS_TTL0_TRAP_ENABLE field  */
                        result_size__mpls_ttl0_trap_enable += 1;
                        /** size of MPLS_TTL1_TRAP_ENABLE field  */
                        result_size__mpls_ttl1_trap_enable += 1;
                        /** size of TCP_SN_FLAGS_ZERO_TRAP_ENABLE field  */
                        result_size__tcp_sn_flags_zero_trap_enable += 1;
                        /** size of TCP_SN_ZERO_FLAGS_SET_TRAP_ENABLE field  */
                        result_size__tcp_sn_zero_flags_set_trap_enable += 1;
                        /** size of TCP_SYN_FUN_TRAP_ENABLE field  */
                        result_size__tcp_syn_fun_trap_enable += 1;
                        /** size of TCP_EQUAL_PORTS_TRAP_ENABLE field  */
                        result_size__tcp_equal_ports_trap_enable += 1;
                        /** size of TCP_FRAGMENT_INCOMPLETE_HEADER_TRAP_ENABLE field  */
                        result_size__tcp_fragment_incomplete_header_trap_enable += 1;
                        /** size of TCP_FRAGMENT_OFFSET_LT8_TRAP_ENABLE field  */
                        result_size__tcp_fragment_offset_lt8_trap_enable += 1;
                        /** size of UDP_EQUAL_PORTS_TRAP_ENABLE field  */
                        result_size__udp_equal_ports_trap_enable += 1;
                        access_params->data_offset.formula_int = result_size__reserved_trap_enable + result_size__ethernet_sa_mc_trap_enable + result_size__ethernet_sa_equal_da_trap_enable + result_size__ipv4_version_error_trap_enable + result_size__ipv4_checksum_error_trap_enable + result_size__ipv4_total_length_trap_enable + result_size__ipv4_ttl0_trap_enable + result_size__ipv4_has_options_trap_enable + result_size__ipv4_ttl1_trap_enable + result_size__ipv4_sip_equal_dip_trap_enable + result_size__ipv4_dip_zero_trap_enable + result_size__ipv4_sip_is_mc_trap_enable + result_size__ipv6_version_error_trap_enable + result_size__ipv6_hop_count0_trap_enable + result_size__ipv6_hop_count1_trap_enable + result_size__ipv6_unspecified_destination_trap_enable + result_size__ipv6_loopback_address_trap_enable + result_size__ipv6_multicast_source_trap_enable + result_size__ipv6_next_header_null_trap_enable + result_size__ipv6_unspecified_source_trap_enable + result_size__ipv6_link_local_destination_trap_enable + result_size__ipv6_site_local_destination_trap_enable + result_size__ipv6_link_local_source_trap_enable + result_size__ipv6_site_local_source_trap_enable + result_size__ipv6_ipv4_compatible_destination_trap_enable + result_size__ipv6_ipv4_mapped_destination_trap_enable + result_size__ipv6_multicast_destination_trap_enable + result_size__mpls_ttl0_trap_enable + result_size__mpls_ttl1_trap_enable + result_size__tcp_sn_flags_zero_trap_enable + result_size__tcp_sn_zero_flags_set_trap_enable + result_size__tcp_syn_fun_trap_enable + result_size__tcp_equal_ports_trap_enable + result_size__tcp_fragment_incomplete_header_trap_enable + result_size__tcp_fragment_offset_lt8_trap_enable + result_size__udp_equal_ports_trap_enable; 
                    }
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_DEBUG_FLP_DATAPATH_TRAPS, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_invalid_destination_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    dbal_logical_table_t * table_entry = table_info + DBAL_TABLE_INVALID_DESTINATION;
    int is_valid = TRUE;
    SHR_FUNC_INIT_VARS(unit);
    dbal_init_table_db_struct_clear(cur_table_param);
    SHR_IF_ERR_EXIT(dbal_db_init_general_info_set(unit, table_entry, DBAL_TABLE_INVALID_DESTINATION /* table id*/, is_valid /* is valid*/, "INVALID_DESTINATION" /* table name*/, DBAL_ACCESS_METHOD_HARD_LOGIC /* access method*/));
    /** maturity level  */
    /** default maturity level  */
    table_entry->maturity_level = DBAL_MATURITY_HIGH;
    /** *************  */
    /** set interface  */
    /** *************  */
    /** set type  */
    table_entry->table_type = DBAL_TABLE_TYPE_DIRECT;
    /** set labels  */
    /** nof labels  */
    table_entry->nof_labels = 1;
    SHR_ALLOC_SET_ZERO(table_entry->table_labels, table_entry->nof_labels * sizeof(dbal_labels_e), "table labels allocation", "%s%s%s\r\n", table_entry->table_name, EMPTY, EMPTY);
    table_entry->table_labels[0] = DBAL_LABEL_SYSTEM;
    /** interface keys  */
    {
        int field_index = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        SHR_ALLOC_SET_ZERO(table_entry->keys_info, 1 * sizeof(dbal_table_field_info_t), "key fields info allocation", "%s%s%s\r\n", "INVALID_DESTINATION" /* table name*/, EMPTY, EMPTY);
        /** interface key fields init  */
        {
            dbal_db_field = &table_entry->keys_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_CORE_ID /* field id*/, DBAL_FIELD_TYPE_DEF_CORE_ID /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, TRUE));
            field_index += dbal_db_field->nof_instances;
        }
        table_entry->nof_key_fields = field_index;
        dbal_db_init_table_calculate_key_size(table_entry);
    }
    /** interface results  */
    {
        int field_index = 0;
        int result_type_counter = 0;
        dbal_table_field_info_t * dbal_db_field;
        table_db_field_params_struct_t db_field;
        DBAL_DB_INIT_TABLE_NOF_RESULT_TYPES_SET(table_entry, 1);
        SHR_IF_ERR_EXIT(dbal_db_init_table_db_interface_results_alloc(unit, table_entry));
        /** interface single result  */
        DBAL_DB_INIT_TABLE_NOF_RESULT_FIELDS_SET(table_entry, (table_entry->multi_res_info[result_type_counter]), 3);
        DBAL_DB_INIT_TABLE_INTERFACE_RESULT_FIELDS_ALLOC(table_entry, table_entry->multi_res_info[result_type_counter]);
        /** interface result fields init  */
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_IS_DESTINATION_INVALID /* field id*/, DBAL_FIELD_TYPE_DEF_BOOL /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_INVALID_DESTINATION /* field id*/, DBAL_FIELD_TYPE_DEF_UINT /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.size = 19;
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
        {
            dbal_db_field = &table_entry->multi_res_info[result_type_counter].results_info[field_index];
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_mandatory_values(unit, DBAL_FIELD_INVALID_DESTINATION_SOURCE /* field id*/, DBAL_FIELD_TYPE_DEF_INVALID_DESTINATION_SOURCE /* Type*/, dbal_db_field));
            dbal_db_init_table_field_params_init(&db_field);
            db_field.permission = DBAL_PERMISSION_READONLY;
            SHR_IF_ERR_EXIT(dbal_db_init_table_field_set_optional_or_default_values(unit, table_entry, dbal_db_field, &db_field, FALSE));
            field_index += dbal_db_field->nof_instances;
        }
    }
    /** *************  */
    /** app to phy db  */
    /** *************  */
    /** clear access section  */
    dbal_db_init_table_db_struct_access_clear(cur_table_param, table_entry);
    /** image infos  */
    {
        /** is_standard_1_table is set by Autocoder  */
        uint8 is_standard_1 = FALSE;
        /** is_compatible_with_all_images is set by Autocoder  */
        uint8 is_compatible_with_all_images = TRUE;
        DBAL_DB_INIT_TABLE_IMAGE_SPECIFIC_TABLE_INDICATION_SET(table_entry, is_standard_1, is_compatible_with_all_images);
        SHR_IF_ERR_EXIT(dbal_db_init_table_set_table_incompatible_image_sw_state_indication(unit, DBAL_TABLE_INVALID_DESTINATION, is_standard_1, is_compatible_with_all_images));
    }
    /** set app to phy db general information  */
    /** core mode  */
    table_entry->core_mode = DBAL_CORE_MODE_DPC;
    /** result type hw value by index  */
    dbal_db_init_table_add_result_type_physical_values_by_result_type_index(table_entry);
    /** build access hl direct  */
    {
        int map_idx = 0;
        int access_counter;
        map_idx = 0;
        access_counter = 0;
        sal_strncpy(cur_table_param->hl_access[map_idx].mapping_result_name, EMPTY /* result type*/, sizeof(cur_table_param->hl_access[map_idx].mapping_result_name));
        /** set (hl direct) accesses for field: IS_DESTINATION_INVALID  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_IS_DESTINATION_INVALID + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPD_INVALID_DESTINATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALID_DESTINATION_INDICATORf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: INVALID_DESTINATION  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_INVALID_DESTINATION + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPD_INVALID_DESTINATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALID_DESTINATION_DESTINATIONf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set (hl direct) accesses for field: INVALID_DESTINATION_SOURCE  */
        {
            table_db_access_params_struct_t * access_params;
            /** set access  */
            {
                int instance_index = 0;
                access_params = &cur_table_param->hl_access[map_idx].access[access_counter];
                dbal_db_init_table_db_struct_hl_access_params_clear(access_params);
                access_counter++;
                /** set hard logic access type  */
                SHR_IF_ERR_EXIT(dbal_db_init_hard_logic_direct_set_access_type(unit, access_params, TRUE /* is register*/, FALSE /* is memory*/););
                /** set access information  */
                /** set access field id  */
                access_params->access_field_id = DBAL_FIELD_INVALID_DESTINATION_SOURCE + instance_index;
                SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_field(unit, access_params, 0 /* field size*/, 0 /* field offset*/, DBAL_VALUE_FIELD_ENCODE_NONE /* encode type*/, 0 /* encode value*/));
                /** set register/memory information for current access  */
                {
                    int regMemHwEntityId = INVALIDr;
                    int fieldHwEntityId = INVALIDf;
                    /** set reg/mem hw Entity id  */
                    regMemHwEntityId = IPPD_INVALID_DESTINATIONr;
                    /** set field hw Entity id  */
                    fieldHwEntityId = INVALID_DESTINATION_SOURCEf;
                    SHR_IF_ERR_EXIT(dbal_db_init_table_set_access_register_memory(unit, access_params, DBAL_HW_ENTITY_GROUP_EMPTY /* group id*/, regMemHwEntityId /* reg/mem hw entity id*/, fieldHwEntityId /* field hw entity id*/, INVALIDr /* alias hw entity id*/));
                }
            }
        }
        /** set nof access for field mapping  */
        cur_table_param->hl_access[map_idx].nof_access = access_counter;
    }
    SHR_IF_ERR_EXIT(dbal_db_init_table_add(unit, cur_table_param, DBAL_TABLE_INVALID_DESTINATION, table_info));
exit:
    SHR_FUNC_EXIT;
}

shr_error_e
dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_init(
int unit,
table_db_struct_t * cur_table_param,
dbal_logical_table_t * table_info)
{
    SHR_FUNC_INIT_VARS(unit);
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_header_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_header_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_attributes_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_attributes_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_generated_values_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_generated_values_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_generated_headder_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_generated_headder_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_max_latency_lat_pkt_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_max_latency_lat_pkt_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_deleted_lat_pkts_cnt_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_deleted_lat_pkts_cnt_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_big_lat_cni_cntr_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_big_lat_cni_cntr_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_incoming_packet_cntr_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_incoming_packet_cntr_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itpp_max_latency_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_itppd_max_latency_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_lbp_debug_signals_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_ipmf3_last_fes_debug_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_debug_flp_datapath_traps_init(unit, cur_table_param, table_info));
    SHR_IF_ERR_EXIT(_dbal_init_tables_hard_logic_pp_global_hl_pp_debug_ipp_invalid_destination_init(unit, cur_table_param, table_info));
exit:
    SHR_FUNC_EXIT;
}
