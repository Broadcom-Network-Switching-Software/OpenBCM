/** \file dnx_data_internal_l3.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_INTERNAL_L3_H_
/*{*/
#define _DNX_DATA_INTERNAL_L3_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_l3.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_l3_submodule_egr_pointed,
    dnx_data_l3_submodule_fec,
    dnx_data_l3_submodule_source_address,
    dnx_data_l3_submodule_vrf,
    dnx_data_l3_submodule_routing_enablers,
    dnx_data_l3_submodule_rif,
    dnx_data_l3_submodule_fwd,
    dnx_data_l3_submodule_ecmp,
    dnx_data_l3_submodule_vip_ecmp,
    dnx_data_l3_submodule_source_address_ethernet,
    dnx_data_l3_submodule_vrrp,
    dnx_data_l3_submodule_feature,

    /**
     * Must be last one!
     */
    _dnx_data_l3_submodule_nof
} dnx_data_l3_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE EGR_POINTED:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_egr_pointed_feature_get(
    int unit,
    dnx_data_l3_egr_pointed_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_egr_pointed_define_first_egr_pointed_id,
    dnx_data_l3_egr_pointed_define_nof_egr_pointed_ids,
    dnx_data_l3_egr_pointed_define_nof_bits_in_egr_pointed_id,

    /**
     * Must be last one!
     */
    _dnx_data_l3_egr_pointed_define_nof
} dnx_data_l3_egr_pointed_define_e;

/* Get Data */
/**
 * \brief returns define data of first_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'first_egr_pointed_id'
 * Identifier of very first virtual egress pointed object.                            Range is from 'first_egr_pointed_id' to 'nof_egr_pointed_ids - 1'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_egr_pointed_first_egr_pointed_id_get(
    int unit);

/**
 * \brief returns numeric data of nof_egr_pointed_ids
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_egr_pointed_ids'
 * Number of virtual egress pointed object ids
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_pointed_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_egr_pointed_nof_egr_pointed_ids_get(
    int unit);

/**
 * \brief returns numeric data of nof_bits_in_egr_pointed_id
 * Module - 'l3', Submodule - 'egr_pointed', data - 'nof_bits_in_egr_pointed_id'
 * Number of bits representing one virtual egress pointed object id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_pointed_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_egr_pointed_nof_bits_in_egr_pointed_id_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_egr_pointed_table_nof
} dnx_data_l3_egr_pointed_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FEC:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_fec_feature_get(
    int unit,
    dnx_data_l3_fec_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_fec_define_nof_fecs,
    dnx_data_l3_fec_define_first_valid_fec_ecmp_id,
    dnx_data_l3_fec_define_max_fec_id_for_single_dhb_cluster_pair_granularity,
    dnx_data_l3_fec_define_max_fec_id_for_double_dhb_cluster_pair_granularity,
    dnx_data_l3_fec_define_max_default_fec,
    dnx_data_l3_fec_define_bank_size,
    dnx_data_l3_fec_define_bank_size_round_up,
    dnx_data_l3_fec_define_max_nof_super_fecs_per_bank,
    dnx_data_l3_fec_define_nof_physical_fecs_per_bank,
    dnx_data_l3_fec_define_super_fec_size,
    dnx_data_l3_fec_define_max_nof_banks,
    dnx_data_l3_fec_define_first_bank_without_id_alloc,
    dnx_data_l3_fec_define_max_super_fec_id,
    dnx_data_l3_fec_define_fer_mdb_granularity_ratio,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fec_define_nof
} dnx_data_l3_fec_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_fecs
 * Module - 'l3', Submodule - 'fec', data - 'nof_fecs'
 * The maximal number of FECs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fecs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_fecs_get(
    int unit);

/**
 * \brief returns define data of first_valid_fec_ecmp_id
 * Module - 'l3', Submodule - 'fec', data - 'first_valid_fec_ecmp_id'
 * The ID of the first valid FEC/ECMP group which can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_valid_fec_ecmp_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_first_valid_fec_ecmp_id_get(
    int unit);

/**
 * \brief returns define data of max_fec_id_for_single_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_single_dhb_cluster_pair_granularity'
 * The maximal FEC ID that support a single DHB cluasters pair.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_single_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_fec_id_for_single_dhb_cluster_pair_granularity_get(
    int unit);

/**
 * \brief returns define data of max_fec_id_for_double_dhb_cluster_pair_granularity
 * Module - 'l3', Submodule - 'fec', data - 'max_fec_id_for_double_dhb_cluster_pair_granularity'
 * The maximal FEC ID that requiere an even number of DHB clusters pairs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fec_id_for_double_dhb_cluster_pair_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_fec_id_for_double_dhb_cluster_pair_granularity_get(
    int unit);

/**
 * \brief returns define data of max_default_fec
 * Module - 'l3', Submodule - 'fec', data - 'max_default_fec'
 * The maximal FEC id that can be used for default route.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_default_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_default_fec_get(
    int unit);

/**
 * \brief returns define data of bank_size
 * Module - 'l3', Submodule - 'fec', data - 'bank_size'
 * The smallest number of FECs which belong to the same hierarchy
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_bank_size_get(
    int unit);

/**
 * \brief returns define data of bank_size_round_up
 * Module - 'l3', Submodule - 'fec', data - 'bank_size_round_up'
 * In some cases FEC bank size contains extra FECs due to round up which results from physical to logical translation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bank_size_round_up - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_bank_size_round_up_get(
    int unit);

/**
 * \brief returns define data of max_nof_super_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_super_fecs_per_bank'
 * The max NOF SUPER FEC IDs per resource manager bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_super_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_nof_super_fecs_per_bank_get(
    int unit);

/**
 * \brief returns define data of nof_physical_fecs_per_bank
 * Module - 'l3', Submodule - 'fec', data - 'nof_physical_fecs_per_bank'
 * The number of physical FEC IDs per bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_physical_fecs_per_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_nof_physical_fecs_per_bank_get(
    int unit);

/**
 * \brief returns define data of super_fec_size
 * Module - 'l3', Submodule - 'fec', data - 'super_fec_size'
 * The number of bits of a single super FEC in the MDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     super_fec_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_super_fec_size_get(
    int unit);

/**
 * \brief returns define data of max_nof_banks
 * Module - 'l3', Submodule - 'fec', data - 'max_nof_banks'
 * The maximal NOF possible banks in the device (not MDB profile dependent).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_nof_banks_get(
    int unit);

/**
 * \brief returns define data of first_bank_without_id_alloc
 * Module - 'l3', Submodule - 'fec', data - 'first_bank_without_id_alloc'
 * the first fec allocation bank that can be used for allocating FECs without an ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_bank_without_id_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_first_bank_without_id_alloc_get(
    int unit);

/**
 * \brief returns define data of max_super_fec_id
 * Module - 'l3', Submodule - 'fec', data - 'max_super_fec_id'
 * The max ID of the super FEC
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_super_fec_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_max_super_fec_id_get(
    int unit);

/**
 * \brief returns define data of fer_mdb_granularity_ratio
 * Module - 'l3', Submodule - 'fec', data - 'fer_mdb_granularity_ratio'
 * This value indicate the ratio between the FER FEC granularity relative to the MDB
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fer_mdb_granularity_ratio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fec_fer_mdb_granularity_ratio_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_fec_table_nof
} dnx_data_l3_fec_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SOURCE_ADDRESS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_source_address_feature_get(
    int unit,
    dnx_data_l3_source_address_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_source_address_define_source_address_table_size,
    dnx_data_l3_source_address_define_custom_sa_use_dual_homing,

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_define_nof
} dnx_data_l3_source_address_define_e;

/* Get Data */
/**
 * \brief returns define data of source_address_table_size
 * Module - 'l3', Submodule - 'source_address', data - 'source_address_table_size'
 * The number of entries in the source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_address_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_source_address_source_address_table_size_get(
    int unit);

/**
 * \brief returns define data of custom_sa_use_dual_homing
 * Module - 'l3', Submodule - 'source_address', data - 'custom_sa_use_dual_homing'
 * Indication whether ARP custom sa feature is using EEDB dual homing field or full mac address from source address table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     custom_sa_use_dual_homing - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_source_address_custom_sa_use_dual_homing_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_table_nof
} dnx_data_l3_source_address_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE VRF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_vrf_feature_get(
    int unit,
    dnx_data_l3_vrf_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_vrf_define_nof_vrf,
    dnx_data_l3_vrf_define_nof_vrf_ipv6,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrf_define_nof
} dnx_data_l3_vrf_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_vrf
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf'
 * The maximal number of VRFs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrf_nof_vrf_get(
    int unit);

/**
 * \brief returns define data of nof_vrf_ipv6
 * Module - 'l3', Submodule - 'vrf', data - 'nof_vrf_ipv6'
 * The maximal number of VRFs supported by the device for an IPv6 MC table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vrf_ipv6 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrf_nof_vrf_ipv6_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrf_table_nof
} dnx_data_l3_vrf_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ROUTING_ENABLERS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_routing_enablers_feature_get(
    int unit,
    dnx_data_l3_routing_enablers_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_routing_enablers_define_nof_routing_enablers_profiles,

    /**
     * Must be last one!
     */
    _dnx_data_l3_routing_enablers_define_nof
} dnx_data_l3_routing_enablers_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_routing_enablers_profiles
 * Module - 'l3', Submodule - 'routing_enablers', data - 'nof_routing_enablers_profiles'
 * The maximal number of references for a routing enablers vector.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_routing_enablers_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_routing_enablers_nof_routing_enablers_profiles_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_routing_enablers_table_nof
} dnx_data_l3_routing_enablers_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE RIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_rif_feature_get(
    int unit,
    dnx_data_l3_rif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_rif_define_max_nof_rifs,
    dnx_data_l3_rif_define_nof_rifs,

    /**
     * Must be last one!
     */
    _dnx_data_l3_rif_define_nof
} dnx_data_l3_rif_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'max_nof_rifs'
 * Maximum number of rifs supported by the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_rif_max_nof_rifs_get(
    int unit);

/**
 * \brief returns numeric data of nof_rifs
 * Module - 'l3', Submodule - 'rif', data - 'nof_rifs'
 * Number of rifs available in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_rif_nof_rifs_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_rif_table_nof
} dnx_data_l3_rif_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FWD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_fwd_feature_get(
    int unit,
    dnx_data_l3_fwd_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_fwd_define_flp_fragment_support,
    dnx_data_l3_fwd_define_max_mc_group_lpm,
    dnx_data_l3_fwd_define_max_mc_group_em,
    dnx_data_l3_fwd_define_nof_my_mac_prefixes,
    dnx_data_l3_fwd_define_compressed_sip_svl_size,
    dnx_data_l3_fwd_define_nof_compressed_svl_sip,
    dnx_data_l3_fwd_define_lpm_strength_profile_support,
    dnx_data_l3_fwd_define_nof_lpm_profiles,
    dnx_data_l3_fwd_define_nof_prefix_ranges,
    dnx_data_l3_fwd_define_compressed_sip_ivl_size,
    dnx_data_l3_fwd_define_nof_compressed_ivl_sip,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fwd_define_nof
} dnx_data_l3_fwd_define_e;

/* Get Data */
/**
 * \brief returns define data of flp_fragment_support
 * Module - 'l3', Submodule - 'fwd', data - 'flp_fragment_support'
 * Indicate whether the LB fragmentation is handled by the FLP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flp_fragment_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_flp_fragment_support_get(
    int unit);

/**
 * \brief returns define data of max_mc_group_lpm
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_lpm'
 * The maximum number of MC group ID for IPMC route entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_lpm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_max_mc_group_lpm_get(
    int unit);

/**
 * \brief returns define data of max_mc_group_em
 * Module - 'l3', Submodule - 'fwd', data - 'max_mc_group_em'
 * The maximum number of MC group ID for IPMC host entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mc_group_em - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_max_mc_group_em_get(
    int unit);

/**
 * \brief returns define data of nof_my_mac_prefixes
 * Module - 'l3', Submodule - 'fwd', data - 'nof_my_mac_prefixes'
 * The number of my MACs prefixes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_my_mac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_my_mac_prefixes_get(
    int unit);

/**
 * \brief returns define data of compressed_sip_svl_size
 * Module - 'l3', Submodule - 'fwd', data - 'compressed_sip_svl_size'
 * The size in bits of the IPMC IP6 compressed SIP for SVL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compressed_sip_svl_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_compressed_sip_svl_size_get(
    int unit);

/**
 * \brief returns define data of nof_compressed_svl_sip
 * Module - 'l3', Submodule - 'fwd', data - 'nof_compressed_svl_sip'
 * Number of supported IPMC compressed SIPs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compressed_svl_sip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_compressed_svl_sip_get(
    int unit);

/**
 * \brief returns define data of lpm_strength_profile_support
 * Module - 'l3', Submodule - 'fwd', data - 'lpm_strength_profile_support'
 * Indicates whether the KAPS strength mapping is different per LPM profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_strength_profile_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_lpm_strength_profile_support_get(
    int unit);

/**
 * \brief returns define data of nof_lpm_profiles
 * Module - 'l3', Submodule - 'fwd', data - 'nof_lpm_profiles'
 * The number of LPM profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lpm_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_lpm_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_prefix_ranges
 * Module - 'l3', Submodule - 'fwd', data - 'nof_prefix_ranges'
 * The number of KAPS prefix ranges.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prefix_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_prefix_ranges_get(
    int unit);

/**
 * \brief returns define data of compressed_sip_ivl_size
 * Module - 'l3', Submodule - 'fwd', data - 'compressed_sip_ivl_size'
 * The size in bits of the IPMC IP6 compressed SIP for IVL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compressed_sip_ivl_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_compressed_sip_ivl_size_get(
    int unit);

/**
 * \brief returns define data of nof_compressed_ivl_sip
 * Module - 'l3', Submodule - 'fwd', data - 'nof_compressed_ivl_sip'
 * Number of supported IPMC compressed SIPs for IVL table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compressed_ivl_sip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_fwd_nof_compressed_ivl_sip_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_fwd_table_lpm_profile_to_entry_strength,

    /**
     * Must be last one!
     */
    _dnx_data_l3_fwd_table_nof
} dnx_data_l3_fwd_table_e;

/* Get Data */
/**
 * \brief get table lpm_profile_to_entry_strength entry 
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - unit #
 * \param [in] lpm_profile - LPM profile.
 * \param [in] kaps_intf - KAPS interface.
 * 
 * \return
 *     lpm_profile_to_entry_strength - returns the relevant entry values grouped in struct - see dnx_data_l3_fwd_lpm_profile_to_entry_strength_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_fwd_lpm_profile_to_entry_strength_t * dnx_data_l3_fwd_lpm_profile_to_entry_strength_get(
    int unit,
    int lpm_profile,
    int kaps_intf);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'fwd', table - 'lpm_profile_to_entry_strength'
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_fwd_lpm_profile_to_entry_strength_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)lpm_profile_to_entry_strength info
 * LPM profile to entry strength mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpm_profile_to_entry_strength - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_fwd_lpm_profile_to_entry_strength_info_get(
    int unit);

/*
 * SUBMODULE ECMP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_ecmp_feature_get(
    int unit,
    dnx_data_l3_ecmp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_ecmp_define_group_size_multiply_and_divide_nof_bits,
    dnx_data_l3_ecmp_define_group_size_consistent_nof_bits,
    dnx_data_l3_ecmp_define_group_size_nof_bits,
    dnx_data_l3_ecmp_define_max_group_size,
    dnx_data_l3_ecmp_define_nof_ecmp_per_bank_of_low_ecmps,
    dnx_data_l3_ecmp_define_nof_ecmp_basic_mode,
    dnx_data_l3_ecmp_define_total_nof_ecmp,
    dnx_data_l3_ecmp_define_max_ecmp_basic_mode,
    dnx_data_l3_ecmp_define_max_ecmp_extended_mode,
    dnx_data_l3_ecmp_define_nof_ecmp_per_bank_of_extended_ecmps,
    dnx_data_l3_ecmp_define_nof_fec_banks_per_extended_ecmp_bank,
    dnx_data_l3_ecmp_define_nof_group_profiles_per_hierarchy,
    dnx_data_l3_ecmp_define_member_table_nof_rows_size_in_bits,
    dnx_data_l3_ecmp_define_member_table_address_size_in_bits,
    dnx_data_l3_ecmp_define_ecmp_stage_map_size,
    dnx_data_l3_ecmp_define_nof_ecmp_banks_basic,
    dnx_data_l3_ecmp_define_nof_ecmp_banks_extended,
    dnx_data_l3_ecmp_define_nof_ecmp,
    dnx_data_l3_ecmp_define_profile_id_size,
    dnx_data_l3_ecmp_define_profile_id_offset,
    dnx_data_l3_ecmp_define_member_table_row_width,
    dnx_data_l3_ecmp_define_tunnel_priority_support,
    dnx_data_l3_ecmp_define_nof_tunnel_priority_map_profiles,
    dnx_data_l3_ecmp_define_tunnel_priority_field_width,
    dnx_data_l3_ecmp_define_tunnel_priority_index_field_width,
    dnx_data_l3_ecmp_define_consistent_mem_row_size_in_bits,
    dnx_data_l3_ecmp_define_consistent_bank_size_in_bits,

    /**
     * Must be last one!
     */
    _dnx_data_l3_ecmp_define_nof
} dnx_data_l3_ecmp_define_e;

/* Get Data */
/**
 * \brief returns define data of group_size_multiply_and_divide_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_multiply_and_divide_nof_bits'
 * The NOF bit of the multiply and division group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_multiply_and_divide_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_group_size_multiply_and_divide_nof_bits_get(
    int unit);

/**
 * \brief returns define data of group_size_consistent_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_consistent_nof_bits'
 * The NOF bit of the consistent group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_consistent_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_group_size_consistent_nof_bits_get(
    int unit);

/**
 * \brief returns define data of group_size_nof_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'group_size_nof_bits'
 * The max NOF bit of the ECMP group size field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     group_size_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_group_size_nof_bits_get(
    int unit);

/**
 * \brief returns define data of max_group_size
 * Module - 'l3', Submodule - 'ecmp', data - 'max_group_size'
 * The maximal size of an ECMP group.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_group_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_max_group_size_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_per_bank_of_low_ecmps
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_per_bank_of_low_ecmps'
 * The low 32k ECMP are placed in a memory of 16 banks, each bank holds 2k ECMPS.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_per_bank_of_low_ecmps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_per_bank_of_low_ecmps_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_basic_mode'
 * Number of ECMP groups that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_basic_mode_get(
    int unit);

/**
 * \brief returns define data of total_nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'total_nof_ecmp'
 * The total number of IDs that are considered to be in the ECMP range.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     total_nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_total_nof_ecmp_get(
    int unit);

/**
 * \brief returns define data of max_ecmp_basic_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_basic_mode'
 * Maximum ECMP group ID that can be created in basic mode as opposed to extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_basic_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_max_ecmp_basic_mode_get(
    int unit);

/**
 * \brief returns define data of max_ecmp_extended_mode
 * Module - 'l3', Submodule - 'ecmp', data - 'max_ecmp_extended_mode'
 * Maximum ECMP group ID that can be created in extended mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ecmp_extended_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_max_ecmp_extended_mode_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_per_bank_of_extended_ecmps
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_per_bank_of_extended_ecmps'
 * The upper 8k ECMP (from 32k to 40k) are placed in a memory of 16 banks, each bank holds 512 ECMPS.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_per_bank_of_extended_ecmps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_per_bank_of_extended_ecmps_get(
    int unit);

/**
 * \brief returns define data of nof_fec_banks_per_extended_ecmp_bank
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_fec_banks_per_extended_ecmp_bank'
 * nof fec protection banks to be used for 1 ecmp extended bank
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fec_banks_per_extended_ecmp_bank - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_fec_banks_per_extended_ecmp_bank_get(
    int unit);

/**
 * \brief returns define data of nof_group_profiles_per_hierarchy
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_group_profiles_per_hierarchy'
 * Number of profiles that are available for each ECMP hierarchy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_group_profiles_per_hierarchy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_group_profiles_per_hierarchy_get(
    int unit);

/**
 * \brief returns define data of member_table_nof_rows_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_nof_rows_size_in_bits'
 * The NOF bits required to represent the NOF rows in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_nof_rows_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_member_table_nof_rows_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of member_table_address_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_address_size_in_bits'
 * The member table address size in bits when it used by the ECMP profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_address_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_member_table_address_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of ecmp_stage_map_size
 * Module - 'l3', Submodule - 'ecmp', data - 'ecmp_stage_map_size'
 * The smallest number of consecutive ECMP groups which belong to the same hierarchy
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecmp_stage_map_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_ecmp_stage_map_size_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_basic
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_basic'
 * The number of ECMP banks in the basic range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_basic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_banks_basic_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp_banks_extended
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp_banks_extended'
 * The number of ECMP banks in the extended range of IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp_banks_extended - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_banks_extended_get(
    int unit);

/**
 * \brief returns define data of nof_ecmp
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_ecmp'
 * Number of ECMPs in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_ecmp_get(
    int unit);

/**
 * \brief returns define data of profile_id_size
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_size'
 * The size of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_profile_id_size_get(
    int unit);

/**
 * \brief returns define data of profile_id_offset
 * Module - 'l3', Submodule - 'ecmp', data - 'profile_id_offset'
 * The offset of the profile ID field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     profile_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_profile_id_offset_get(
    int unit);

/**
 * \brief returns define data of member_table_row_width
 * Module - 'l3', Submodule - 'ecmp', data - 'member_table_row_width'
 * The width in bits of a row in the ECMP member table.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     member_table_row_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_member_table_row_width_get(
    int unit);

/**
 * \brief returns define data of tunnel_priority_support
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_support'
 * Device has tunnel priority support.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_tunnel_priority_support_get(
    int unit);

/**
 * \brief returns define data of nof_tunnel_priority_map_profiles
 * Module - 'l3', Submodule - 'ecmp', data - 'nof_tunnel_priority_map_profiles'
 * The NOF tunnle priority map profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tunnel_priority_map_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_nof_tunnel_priority_map_profiles_get(
    int unit);

/**
 * \brief returns define data of tunnel_priority_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_field_width'
 * The width in bits of the tunnel priority field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_tunnel_priority_field_width_get(
    int unit);

/**
 * \brief returns define data of tunnel_priority_index_field_width
 * Module - 'l3', Submodule - 'ecmp', data - 'tunnel_priority_index_field_width'
 * The size of the possible TP indexes field.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tunnel_priority_index_field_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_tunnel_priority_index_field_width_get(
    int unit);

/**
 * \brief returns define data of consistent_mem_row_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'consistent_mem_row_size_in_bits'
 * The size in bits of a row in the consistent members memory.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_mem_row_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_consistent_mem_row_size_in_bits_get(
    int unit);

/**
 * \brief returns define data of consistent_bank_size_in_bits
 * Module - 'l3', Submodule - 'ecmp', data - 'consistent_bank_size_in_bits'
 * The size of a single bank used for the consistent hashing members tables.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_bank_size_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_ecmp_consistent_bank_size_in_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_l3_ecmp_table_consistent_tables_info,

    /**
     * Must be last one!
     */
    _dnx_data_l3_ecmp_table_nof
} dnx_data_l3_ecmp_table_e;

/* Get Data */
/**
 * \brief get table consistent_tables_info entry 
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - unit #
 * \param [in] table_type - The table type.
 * 
 * \return
 *     consistent_tables_info - returns the relevant entry values grouped in struct - see dnx_data_l3_ecmp_consistent_tables_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_l3_ecmp_consistent_tables_info_t * dnx_data_l3_ecmp_consistent_tables_info_get(
    int unit,
    int table_type);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'l3', Submodule - 'ecmp', table - 'consistent_tables_info'
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_ecmp_consistent_tables_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)consistent_tables_info info
 * information on the different consistent tables sizes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     consistent_tables_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_l3_ecmp_consistent_tables_info_info_get(
    int unit);

/*
 * SUBMODULE VIP_ECMP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_vip_ecmp_feature_get(
    int unit,
    dnx_data_l3_vip_ecmp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_vip_ecmp_define_nof_vip_ecmp,
    dnx_data_l3_vip_ecmp_define_max_vip_ecmp_table_size,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vip_ecmp_define_nof
} dnx_data_l3_vip_ecmp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_vip_ecmp
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'nof_vip_ecmp'
 * Number of VIP ECMP groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vip_ecmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vip_ecmp_nof_vip_ecmp_get(
    int unit);

/**
 * \brief returns define data of max_vip_ecmp_table_size
 * Module - 'l3', Submodule - 'vip_ecmp', data - 'max_vip_ecmp_table_size'
 * Maximum number entries per VIP ECMP group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_vip_ecmp_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vip_ecmp_max_vip_ecmp_table_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vip_ecmp_table_nof
} dnx_data_l3_vip_ecmp_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SOURCE_ADDRESS_ETHERNET:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_source_address_ethernet_feature_get(
    int unit,
    dnx_data_l3_source_address_ethernet_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_source_address_ethernet_define_nof_mymac_prefixes,

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_ethernet_define_nof
} dnx_data_l3_source_address_ethernet_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_mymac_prefixes
 * Module - 'l3', Submodule - 'source_address_ethernet', data - 'nof_mymac_prefixes'
 * Number of mymac prefixes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mymac_prefixes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_source_address_ethernet_nof_mymac_prefixes_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_source_address_ethernet_table_nof
} dnx_data_l3_source_address_ethernet_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE VRRP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_vrrp_feature_get(
    int unit,
    dnx_data_l3_vrrp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_l3_vrrp_define_nof_protocol_groups,
    dnx_data_l3_vrrp_define_nof_tcam_entries,
    dnx_data_l3_vrrp_define_nof_vsi_tcam_entries,
    dnx_data_l3_vrrp_define_exem_vrid_ipv4_tcam_index,
    dnx_data_l3_vrrp_define_exem_vrid_ipv6_tcam_index,
    dnx_data_l3_vrrp_define_exem_default_tcam_index,
    dnx_data_l3_vrrp_define_exem_default_tcam_index_msb,
    dnx_data_l3_vrrp_define_vrrp_default_num_entries,

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrrp_define_nof
} dnx_data_l3_vrrp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_protocol_groups
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_protocol_groups'
 * Number of L3 protocol groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_protocol_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_protocol_groups_get(
    int unit);

/**
 * \brief returns define data of nof_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_tcam_entries'
 * Size of VRRP TCAM table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_tcam_entries_get(
    int unit);

/**
 * \brief returns define data of nof_vsi_tcam_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'nof_vsi_tcam_entries'
 * Number of enries in VRRP TCAM table that can be used by VSI table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_tcam_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_nof_vsi_tcam_entries_get(
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv4_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv4_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv4 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv4_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_vrid_ipv4_tcam_index_get(
    int unit);

/**
 * \brief returns define data of exem_vrid_ipv6_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_vrid_ipv6_tcam_index'
 * TCAM index for EXEM VRRP VRID IPv6 protocol
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vrid_ipv6_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_vrid_ipv6_tcam_index_get(
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index'
 * TCAM index for EXEM VSI LSB or SOURCE-PORT multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_default_tcam_index_get(
    int unit);

/**
 * \brief returns define data of exem_default_tcam_index_msb
 * Module - 'l3', Submodule - 'vrrp', data - 'exem_default_tcam_index_msb'
 * TCAM index for EXEM VSI MSB multiple my mac
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_default_tcam_index_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_exem_default_tcam_index_msb_get(
    int unit);

/**
 * \brief returns define data of vrrp_default_num_entries
 * Module - 'l3', Submodule - 'vrrp', data - 'vrrp_default_num_entries'
 * Number of default VRRP entries in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vrrp_default_num_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_l3_vrrp_vrrp_default_num_entries_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_vrrp_table_nof
} dnx_data_l3_vrrp_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FEATURE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_l3_feature_feature_get(
    int unit,
    dnx_data_l3_feature_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_feature_define_nof
} dnx_data_l3_feature_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l3_feature_table_nof
} dnx_data_l3_feature_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_l3_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_L3_H_*/
/* *INDENT-ON* */
