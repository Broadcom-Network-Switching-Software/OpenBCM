/** \file dnx_data_sch.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_SCH_H_
/*{*/
#define _DNX_DATA_SCH_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm_int/dnx/cosq/scheduler/scheduler.h>
#include <soc/dnx/dbal/dbal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_sch.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_sch
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_sch_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL:
 * e2e scheduler general information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule general table low_rate_factor_to_dbal_enum
 * Table info:
 * mapping low rate factor to dbal enum
 */
typedef struct
{
    /**
     * low rate factor dbal enum
     */
    dbal_enum_value_field_low_rate_factor_e dbal_enum;
    /**
     * is factor valid
     */
    int valid;
} dnx_data_sch_general_low_rate_factor_to_dbal_enum_t;

/**
 * \brief Holds values of submodule general table dbal_enum_to_low_rate_factor
 * Table info:
 * mapping dbal enum to low rate factor
 */
typedef struct
{
    /**
     * low rate factor
     */
    int low_rate_factor;
} dnx_data_sch_general_dbal_enum_to_low_rate_factor_t;

/**
 * \brief Holds values of submodule general table slow_rate_max_bucket
 * Table info:
 * Max token bucket values per slow rate
 */
typedef struct
{
    /**
     * Slow rate [Mbps]
     */
    int rate;
    /**
     * Max token bucket
     */
    uint32 max_bucket;
} dnx_data_sch_general_slow_rate_max_bucket_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is LAG scheduler supported
     */
    dnx_data_sch_general_lag_scheduler_supported,
    /**
     * Flow Status Message modes configuration supported
     */
    dnx_data_sch_general_fsm_modes_config_supported,
    /**
     * Calrx and rxi blocks enable/disable is supported
     */
    dnx_data_sch_general_calrx_rxi_enable_supported,

    /**
     * Must be last one!
     */
    _dnx_data_sch_general_feature_nof
} dnx_data_sch_general_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_general_feature_get_f) (
    int unit,
    dnx_data_sch_general_feature_e feature);

/**
 * \brief returns define data of nof_slow_profiles
 * Module - 'sch', Submodule - 'general', data - 'nof_slow_profiles'
 * Number of slow profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_slow_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_general_nof_slow_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_slow_levels
 * Module - 'sch', Submodule - 'general', data - 'nof_slow_levels'
 * Number of slow levels
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_slow_levels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_general_nof_slow_levels_get_f) (
    int unit);

/**
 * \brief returns define data of cycles_per_credit_token
 * Module - 'sch', Submodule - 'general', data - 'cycles_per_credit_token'
 * Number of of cycles between credit tokens of the same flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cycles_per_credit_token - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_general_cycles_per_credit_token_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fmq_class
 * Module - 'sch', Submodule - 'general', data - 'nof_fmq_class'
 * Number of FMQ class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fmq_class - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_general_nof_fmq_class_get_f) (
    int unit);

/**
 * \brief returns numeric data of port_priority_propagation_version
 * Module - 'sch', Submodule - 'general', data - 'port_priority_propagation_version'
 * Port priority propagation version
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_priority_propagation_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_general_port_priority_propagation_version_get_f) (
    int unit);

/**
 * \brief returns numeric data of port_priority_propagation_enable
 * Module - 'sch', Submodule - 'general', data - 'port_priority_propagation_enable'
 * Enable ports to be created with port priority propagation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_priority_propagation_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_general_port_priority_propagation_enable_get_f) (
    int unit);

/**
 * \brief get table low_rate_factor_to_dbal_enum entry 
 * mapping low rate factor to dbal enum
 * 
 * \param [in] unit - unit #
 * \param [in] low_rate_factor - low rate factor
 * 
 * \return
 *     low_rate_factor_to_dbal_enum - returns the relevant entry values grouped in struct - see dnx_data_sch_general_low_rate_factor_to_dbal_enum_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_general_low_rate_factor_to_dbal_enum_t *(
    *dnx_data_sch_general_low_rate_factor_to_dbal_enum_get_f) (
    int unit,
    int low_rate_factor);

/**
 * \brief get table dbal_enum_to_low_rate_factor entry 
 * mapping dbal enum to low rate factor
 * 
 * \param [in] unit - unit #
 * \param [in] dbal_enum - low rate factor dbal enum
 * 
 * \return
 *     dbal_enum_to_low_rate_factor - returns the relevant entry values grouped in struct - see dnx_data_sch_general_dbal_enum_to_low_rate_factor_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_general_dbal_enum_to_low_rate_factor_t *(
    *dnx_data_sch_general_dbal_enum_to_low_rate_factor_get_f) (
    int unit,
    int dbal_enum);

/**
 * \brief get table slow_rate_max_bucket entry 
 * Max token bucket values per slow rate
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * 
 * \return
 *     slow_rate_max_bucket - returns the relevant entry values grouped in struct - see dnx_data_sch_general_slow_rate_max_bucket_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_general_slow_rate_max_bucket_t *(
    *dnx_data_sch_general_slow_rate_max_bucket_get_f) (
    int unit,
    int idx);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - GENERAL:
 * {
 */
/**
 * \brief Interface for sch general data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_general_feature_get_f feature_get;
    /**
     * returns define data of nof_slow_profiles
     */
    dnx_data_sch_general_nof_slow_profiles_get_f nof_slow_profiles_get;
    /**
     * returns define data of nof_slow_levels
     */
    dnx_data_sch_general_nof_slow_levels_get_f nof_slow_levels_get;
    /**
     * returns define data of cycles_per_credit_token
     */
    dnx_data_sch_general_cycles_per_credit_token_get_f cycles_per_credit_token_get;
    /**
     * returns define data of nof_fmq_class
     */
    dnx_data_sch_general_nof_fmq_class_get_f nof_fmq_class_get;
    /**
     * returns numeric data of port_priority_propagation_version
     */
    dnx_data_sch_general_port_priority_propagation_version_get_f port_priority_propagation_version_get;
    /**
     * returns numeric data of port_priority_propagation_enable
     */
    dnx_data_sch_general_port_priority_propagation_enable_get_f port_priority_propagation_enable_get;
    /**
     * get table low_rate_factor_to_dbal_enum entry 
     */
    dnx_data_sch_general_low_rate_factor_to_dbal_enum_get_f low_rate_factor_to_dbal_enum_get;
    /**
     * get general info table about table (for example key size)low_rate_factor_to_dbal_enum info
     */
    dnxc_data_table_info_get_f low_rate_factor_to_dbal_enum_info_get;
    /**
     * get table dbal_enum_to_low_rate_factor entry 
     */
    dnx_data_sch_general_dbal_enum_to_low_rate_factor_get_f dbal_enum_to_low_rate_factor_get;
    /**
     * get general info table about table (for example key size)dbal_enum_to_low_rate_factor info
     */
    dnxc_data_table_info_get_f dbal_enum_to_low_rate_factor_info_get;
    /**
     * get table slow_rate_max_bucket entry 
     */
    dnx_data_sch_general_slow_rate_max_bucket_get_f slow_rate_max_bucket_get;
    /**
     * get general info table about table (for example key size)slow_rate_max_bucket info
     */
    dnxc_data_table_info_get_f slow_rate_max_bucket_info_get;
} dnx_data_if_sch_general_t;

/*
 * }
 */

/*
 * SUBMODULE  - PS:
 * e2e port scheduler (PS) information
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_ps_feature_nof
} dnx_data_sch_ps_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_ps_feature_get_f) (
    int unit,
    dnx_data_sch_ps_feature_e feature);

/**
 * \brief returns define data of min_priority_for_tcg
 * Module - 'sch', Submodule - 'ps', data - 'min_priority_for_tcg'
 * Minimal port priority supporting tcg
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_priority_for_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_ps_min_priority_for_tcg_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_tcg
 * Module - 'sch', Submodule - 'ps', data - 'max_nof_tcg'
 * Maximal number of TCGs in a port scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_ps_max_nof_tcg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_hrs_in_ps
 * Module - 'sch', Submodule - 'ps', data - 'nof_hrs_in_ps'
 * Number of HRs in port scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hrs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_ps_nof_hrs_in_ps_get_f) (
    int unit);

/**
 * \brief returns define data of max_tcg_weight
 * Module - 'sch', Submodule - 'ps', data - 'max_tcg_weight'
 * Maximal TCG EIR weight
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tcg_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_ps_max_tcg_weight_get_f) (
    int unit);

/**
 * \brief returns define data of tc_tcg_calendar_access_period
 * Module - 'sch', Submodule - 'ps', data - 'tc_tcg_calendar_access_period'
 * Access period of TC/TCG calendars
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tc_tcg_calendar_access_period - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_ps_tc_tcg_calendar_access_period_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_port_rate_mbps
 * Module - 'sch', Submodule - 'ps', data - 'max_port_rate_mbps'
 * maximal rate an port can drive (in MBits/sec)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_port_rate_mbps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_ps_max_port_rate_mbps_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_burst
 * Module - 'sch', Submodule - 'ps', data - 'max_burst'
 * Maximal burst of TC/TCG port shapers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_burst - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_ps_max_burst_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - PS:
 * {
 */
/**
 * \brief Interface for sch ps data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_ps_feature_get_f feature_get;
    /**
     * returns define data of min_priority_for_tcg
     */
    dnx_data_sch_ps_min_priority_for_tcg_get_f min_priority_for_tcg_get;
    /**
     * returns define data of max_nof_tcg
     */
    dnx_data_sch_ps_max_nof_tcg_get_f max_nof_tcg_get;
    /**
     * returns define data of nof_hrs_in_ps
     */
    dnx_data_sch_ps_nof_hrs_in_ps_get_f nof_hrs_in_ps_get;
    /**
     * returns define data of max_tcg_weight
     */
    dnx_data_sch_ps_max_tcg_weight_get_f max_tcg_weight_get;
    /**
     * returns define data of tc_tcg_calendar_access_period
     */
    dnx_data_sch_ps_tc_tcg_calendar_access_period_get_f tc_tcg_calendar_access_period_get;
    /**
     * returns numeric data of max_port_rate_mbps
     */
    dnx_data_sch_ps_max_port_rate_mbps_get_f max_port_rate_mbps_get;
    /**
     * returns numeric data of max_burst
     */
    dnx_data_sch_ps_max_burst_get_f max_burst_get;
} dnx_data_if_sch_ps_t;

/*
 * }
 */

/*
 * SUBMODULE  - FLOW:
 * e2e scheduler information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule flow table region_type
 * Table info:
 * flow region type
 */
typedef struct
{
    /**
     * see table doc
     */
    uint32 type;
    /**
     * see table doc
     */
    uint32 propagation_direction;
} dnx_data_sch_flow_region_type_t;

/**
 * \brief Holds values of submodule flow table nof_remote_cores
 * Table info:
 * flow region type
 */
typedef struct
{
    /**
     * see table doc
     */
    uint32 val;
} dnx_data_sch_flow_nof_remote_cores_t;

/**
 * \brief Holds values of submodule flow table quartet_type
 * Table info:
 * quartet type per group
 */
typedef struct
{
    /**
     * see table doc
     */
    uint32 type;
} dnx_data_sch_flow_quartet_type_t;

/**
 * \brief Holds values of submodule flow table quartet_index_conversion
 * Table info:
 * conversion of quartet index
 */
typedef struct
{
    /**
     * quartet index conversion vector flow to SE
     */
    uint32 flow_to_se[4];
    /**
     * quartet index conversion vector SE to flow
     */
    uint32 se_to_flow[4];
} dnx_data_sch_flow_quartet_index_conversion_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is Cl-FQ-Cl-FQ quartet supported
     */
    dnx_data_sch_flow_cl_fq_cl_fq_quartet,
    /**
     * Is flexible Cl-FQ quartet supported
     */
    dnx_data_sch_flow_flex_quartet_supported,
    /**
     * Interdigitated mode is supported
     */
    dnx_data_sch_flow_interdigitated_supported,

    /**
     * Must be last one!
     */
    _dnx_data_sch_flow_feature_nof
} dnx_data_sch_flow_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_flow_feature_get_f) (
    int unit,
    dnx_data_sch_flow_feature_e feature);

/**
 * \brief returns define data of nof_hr
 * Module - 'sch', Submodule - 'flow', data - 'nof_hr'
 * Number of HR elements per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hr - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_hr_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cl
 * Module - 'sch', Submodule - 'flow', data - 'nof_cl'
 * Number of CL elements per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cl - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_cl_get_f) (
    int unit);

/**
 * \brief returns define data of nof_se
 * Module - 'sch', Submodule - 'flow', data - 'nof_se'
 * Number of scheduling elements per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_se - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_se_get_f) (
    int unit);

/**
 * \brief returns define data of nof_flows
 * Module - 'sch', Submodule - 'flow', data - 'nof_flows'
 * Number of flows per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_flows - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_flows_get_f) (
    int unit);

/**
 * \brief returns define data of region_size
 * Module - 'sch', Submodule - 'flow', data - 'region_size'
 * Number of flows in a region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     region_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_region_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_regions
 * Module - 'sch', Submodule - 'flow', data - 'nof_regions'
 * Number of regions in a core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_regions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_regions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_hr_regions
 * Module - 'sch', Submodule - 'flow', data - 'nof_hr_regions'
 * Number of hr regions in a core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hr_regions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_hr_regions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_connectors_only_regions
 * Module - 'sch', Submodule - 'flow', data - 'nof_connectors_only_regions'
 * Number of connectors-only regions per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_connectors_only_regions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_connectors_only_regions_get_f) (
    int unit);

/**
 * \brief returns define data of flow_in_region_mask
 * Module - 'sch', Submodule - 'flow', data - 'flow_in_region_mask'
 * mask for flows in region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_in_region_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_flow_in_region_mask_get_f) (
    int unit);

/**
 * \brief returns define data of min_connector_bundle_size
 * Module - 'sch', Submodule - 'flow', data - 'min_connector_bundle_size'
 * minimal number of connectors in bundle
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_connector_bundle_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_min_connector_bundle_size_get_f) (
    int unit);

/**
 * \brief returns define data of conn_idx_interdig_flow
 * Module - 'sch', Submodule - 'flow', data - 'conn_idx_interdig_flow'
 * first connector index in an interdigitated flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     conn_idx_interdig_flow - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_conn_idx_interdig_flow_get_f) (
    int unit);

/**
 * \brief returns define data of shaper_flipflops_nof
 * Module - 'sch', Submodule - 'flow', data - 'shaper_flipflops_nof'
 * number of Flip-Flops in flow shaper implementation in HW.                     if exp greater than (shaper_flipflops_nof - nof_manthissa_bits)) then mantissa[exp-(shaper_flipflops_nof-nof_mantissa_bits)-1: 0] == 0
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shaper_flipflops_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_shaper_flipflops_nof_get_f) (
    int unit);

/**
 * \brief returns define data of nof_flows_in_quartet_order_group
 * Module - 'sch', Submodule - 'flow', data - 'nof_flows_in_quartet_order_group'
 * Number of flows in a quartet order group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_flows_in_quartet_order_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_flows_in_quartet_order_group_get_f) (
    int unit);

/**
 * \brief returns define data of nof_regions_in_quartet_order_group
 * Module - 'sch', Submodule - 'flow', data - 'nof_regions_in_quartet_order_group'
 * Number of regions in a quartet order group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_regions_in_quartet_order_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_regions_in_quartet_order_group_get_f) (
    int unit);

/**
 * \brief returns define data of nof_quartet_order_groups
 * Module - 'sch', Submodule - 'flow', data - 'nof_quartet_order_groups'
 * Number of quartet order groups in a core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_quartet_order_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_nof_quartet_order_groups_get_f) (
    int unit);

/**
 * \brief returns numeric data of erp_hr
 * Module - 'sch', Submodule - 'flow', data - 'erp_hr'
 * HR id of first ERP HR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     erp_hr - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_erp_hr_get_f) (
    int unit);

/**
 * \brief returns numeric data of reserved_hr
 * Module - 'sch', Submodule - 'flow', data - 'reserved_hr'
 * reserved HR allocated for returned credits in LAG scheduling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved_hr - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_reserved_hr_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_se
 * Module - 'sch', Submodule - 'flow', data - 'max_se'
 * Maximal Scheduling element id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_se - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_max_se_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_flow
 * Module - 'sch', Submodule - 'flow', data - 'max_flow'
 * Maximal flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_flow - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_max_flow_get_f) (
    int unit);

/**
 * \brief returns numeric data of first_hr_region
 * Module - 'sch', Submodule - 'flow', data - 'first_hr_region'
 * First HR region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_hr_region - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_first_hr_region_get_f) (
    int unit);

/**
 * \brief returns numeric data of first_se_flow_id
 * Module - 'sch', Submodule - 'flow', data - 'first_se_flow_id'
 * Flow ID of first scheduling element
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_se_flow_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_first_se_flow_id_get_f) (
    int unit);

/**
 * \brief returns numeric data of hr_se_id_min
 * Module - 'sch', Submodule - 'flow', data - 'hr_se_id_min'
 * min hr se id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hr_se_id_min - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_hr_se_id_min_get_f) (
    int unit);

/**
 * \brief returns numeric data of hr_se_id_max
 * Module - 'sch', Submodule - 'flow', data - 'hr_se_id_max'
 * max hr se id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hr_se_id_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_hr_se_id_max_get_f) (
    int unit);

/**
 * \brief returns numeric data of default_credit_source_se_id
 * Module - 'sch', Submodule - 'flow', data - 'default_credit_source_se_id'
 * SE ID of default credit source. used to mark unattached flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_credit_source_se_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_default_credit_source_se_id_get_f) (
    int unit);

/**
 * \brief returns numeric data of runtime_performance_optimize_enable_sched_allocation
 * Module - 'sch', Submodule - 'flow', data - 'runtime_performance_optimize_enable_sched_allocation'
 * enable flow properties access optimization
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     runtime_performance_optimize_enable_sched_allocation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_flow_runtime_performance_optimize_enable_sched_allocation_get_f) (
    int unit);

/**
 * \brief get table region_type entry 
 * flow region type
 * 
 * \param [in] unit - unit #
 * \param [in] core - see table doc
 * \param [in] region - see table doc
 * 
 * \return
 *     region_type - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_region_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_flow_region_type_t *(
    *dnx_data_sch_flow_region_type_get_f) (
    int unit,
    int core,
    int region);

/**
 * \brief get table nof_remote_cores entry 
 * flow region type
 * 
 * \param [in] unit - unit #
 * \param [in] core - see table doc
 * \param [in] region - see table doc
 * 
 * \return
 *     nof_remote_cores - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_nof_remote_cores_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_flow_nof_remote_cores_t *(
    *dnx_data_sch_flow_nof_remote_cores_get_f) (
    int unit,
    int core,
    int region);

/**
 * \brief get table quartet_type entry 
 * quartet type per group
 * 
 * \param [in] unit - unit #
 * \param [in] core - see table doc
 * \param [in] group - see table doc
 * 
 * \return
 *     quartet_type - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_quartet_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_flow_quartet_type_t *(
    *dnx_data_sch_flow_quartet_type_get_f) (
    int unit,
    int core,
    int group);

/**
 * \brief get table quartet_index_conversion entry 
 * conversion of quartet index
 * 
 * \param [in] unit - unit #
 * \param [in] quartet_type - quartet type
 * 
 * \return
 *     quartet_index_conversion - returns the relevant entry values grouped in struct - see dnx_data_sch_flow_quartet_index_conversion_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_flow_quartet_index_conversion_t *(
    *dnx_data_sch_flow_quartet_index_conversion_get_f) (
    int unit,
    int quartet_type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - FLOW:
 * {
 */
/**
 * \brief Interface for sch flow data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_flow_feature_get_f feature_get;
    /**
     * returns define data of nof_hr
     */
    dnx_data_sch_flow_nof_hr_get_f nof_hr_get;
    /**
     * returns define data of nof_cl
     */
    dnx_data_sch_flow_nof_cl_get_f nof_cl_get;
    /**
     * returns define data of nof_se
     */
    dnx_data_sch_flow_nof_se_get_f nof_se_get;
    /**
     * returns define data of nof_flows
     */
    dnx_data_sch_flow_nof_flows_get_f nof_flows_get;
    /**
     * returns define data of region_size
     */
    dnx_data_sch_flow_region_size_get_f region_size_get;
    /**
     * returns define data of nof_regions
     */
    dnx_data_sch_flow_nof_regions_get_f nof_regions_get;
    /**
     * returns define data of nof_hr_regions
     */
    dnx_data_sch_flow_nof_hr_regions_get_f nof_hr_regions_get;
    /**
     * returns define data of nof_connectors_only_regions
     */
    dnx_data_sch_flow_nof_connectors_only_regions_get_f nof_connectors_only_regions_get;
    /**
     * returns define data of flow_in_region_mask
     */
    dnx_data_sch_flow_flow_in_region_mask_get_f flow_in_region_mask_get;
    /**
     * returns define data of min_connector_bundle_size
     */
    dnx_data_sch_flow_min_connector_bundle_size_get_f min_connector_bundle_size_get;
    /**
     * returns define data of conn_idx_interdig_flow
     */
    dnx_data_sch_flow_conn_idx_interdig_flow_get_f conn_idx_interdig_flow_get;
    /**
     * returns define data of shaper_flipflops_nof
     */
    dnx_data_sch_flow_shaper_flipflops_nof_get_f shaper_flipflops_nof_get;
    /**
     * returns define data of nof_flows_in_quartet_order_group
     */
    dnx_data_sch_flow_nof_flows_in_quartet_order_group_get_f nof_flows_in_quartet_order_group_get;
    /**
     * returns define data of nof_regions_in_quartet_order_group
     */
    dnx_data_sch_flow_nof_regions_in_quartet_order_group_get_f nof_regions_in_quartet_order_group_get;
    /**
     * returns define data of nof_quartet_order_groups
     */
    dnx_data_sch_flow_nof_quartet_order_groups_get_f nof_quartet_order_groups_get;
    /**
     * returns numeric data of erp_hr
     */
    dnx_data_sch_flow_erp_hr_get_f erp_hr_get;
    /**
     * returns numeric data of reserved_hr
     */
    dnx_data_sch_flow_reserved_hr_get_f reserved_hr_get;
    /**
     * returns numeric data of max_se
     */
    dnx_data_sch_flow_max_se_get_f max_se_get;
    /**
     * returns numeric data of max_flow
     */
    dnx_data_sch_flow_max_flow_get_f max_flow_get;
    /**
     * returns numeric data of first_hr_region
     */
    dnx_data_sch_flow_first_hr_region_get_f first_hr_region_get;
    /**
     * returns numeric data of first_se_flow_id
     */
    dnx_data_sch_flow_first_se_flow_id_get_f first_se_flow_id_get;
    /**
     * returns numeric data of hr_se_id_min
     */
    dnx_data_sch_flow_hr_se_id_min_get_f hr_se_id_min_get;
    /**
     * returns numeric data of hr_se_id_max
     */
    dnx_data_sch_flow_hr_se_id_max_get_f hr_se_id_max_get;
    /**
     * returns numeric data of default_credit_source_se_id
     */
    dnx_data_sch_flow_default_credit_source_se_id_get_f default_credit_source_se_id_get;
    /**
     * returns numeric data of runtime_performance_optimize_enable_sched_allocation
     */
    dnx_data_sch_flow_runtime_performance_optimize_enable_sched_allocation_get_f runtime_performance_optimize_enable_sched_allocation_get;
    /**
     * get table region_type entry 
     */
    dnx_data_sch_flow_region_type_get_f region_type_get;
    /**
     * get general info table about table (for example key size)region_type info
     */
    dnxc_data_table_info_get_f region_type_info_get;
    /**
     * get table nof_remote_cores entry 
     */
    dnx_data_sch_flow_nof_remote_cores_get_f nof_remote_cores_get;
    /**
     * get general info table about table (for example key size)nof_remote_cores info
     */
    dnxc_data_table_info_get_f nof_remote_cores_info_get;
    /**
     * get table quartet_type entry 
     */
    dnx_data_sch_flow_quartet_type_get_f quartet_type_get;
    /**
     * get general info table about table (for example key size)quartet_type info
     */
    dnxc_data_table_info_get_f quartet_type_info_get;
    /**
     * get table quartet_index_conversion entry 
     */
    dnx_data_sch_flow_quartet_index_conversion_get_f quartet_index_conversion_get;
    /**
     * get general info table about table (for example key size)quartet_index_conversion info
     */
    dnxc_data_table_info_get_f quartet_index_conversion_info_get;
} dnx_data_if_sch_flow_t;

/*
 * }
 */

/*
 * SUBMODULE  - SE:
 * scheduler elements information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule se table quartet_offset_to_cl_num
 * Table info:
 * mapping quartet index to CL number
 */
typedef struct
{
    /**
     * number of CL in the quartet
     */
    int cl_num;
} dnx_data_sch_se_quartet_offset_to_cl_num_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_se_feature_nof
} dnx_data_sch_se_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_se_feature_get_f) (
    int unit,
    dnx_data_sch_se_feature_e feature);

/**
 * \brief returns define data of default_cos
 * Module - 'sch', Submodule - 'se', data - 'default_cos'
 * default parameter of credit source COS. Used for FQ
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_cos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_se_default_cos_get_f) (
    int unit);

/**
 * \brief returns define data of nof_color_group
 * Module - 'sch', Submodule - 'se', data - 'nof_color_group'
 * number of colors (groups)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_color_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_se_nof_color_group_get_f) (
    int unit);

/**
 * \brief returns define data of max_hr_weight
 * Module - 'sch', Submodule - 'se', data - 'max_hr_weight'
 * maximal weight in HR WFQ
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_hr_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_se_max_hr_weight_get_f) (
    int unit);

/**
 * \brief returns define data of cl_class_profile_nof
 * Module - 'sch', Submodule - 'se', data - 'cl_class_profile_nof'
 * number of profiles for CL class
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cl_class_profile_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_se_cl_class_profile_nof_get_f) (
    int unit);

/**
 * \brief get table quartet_offset_to_cl_num entry 
 * mapping quartet index to CL number
 * 
 * \param [in] unit - unit #
 * \param [in] quartet_offset - quartet offset
 * 
 * \return
 *     quartet_offset_to_cl_num - returns the relevant entry values grouped in struct - see dnx_data_sch_se_quartet_offset_to_cl_num_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_se_quartet_offset_to_cl_num_t *(
    *dnx_data_sch_se_quartet_offset_to_cl_num_get_f) (
    int unit,
    int quartet_offset);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - SE:
 * {
 */
/**
 * \brief Interface for sch se data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_se_feature_get_f feature_get;
    /**
     * returns define data of default_cos
     */
    dnx_data_sch_se_default_cos_get_f default_cos_get;
    /**
     * returns define data of nof_color_group
     */
    dnx_data_sch_se_nof_color_group_get_f nof_color_group_get;
    /**
     * returns define data of max_hr_weight
     */
    dnx_data_sch_se_max_hr_weight_get_f max_hr_weight_get;
    /**
     * returns define data of cl_class_profile_nof
     */
    dnx_data_sch_se_cl_class_profile_nof_get_f cl_class_profile_nof_get;
    /**
     * get table quartet_offset_to_cl_num entry 
     */
    dnx_data_sch_se_quartet_offset_to_cl_num_get_f quartet_offset_to_cl_num_get;
    /**
     * get general info table about table (for example key size)quartet_offset_to_cl_num info
     */
    dnxc_data_table_info_get_f quartet_offset_to_cl_num_info_get;
} dnx_data_if_sch_se_t;

/*
 * }
 */

/*
 * SUBMODULE  - INTERFACE:
 * e2e interface information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule interface table shaper_resolution
 * Table info:
 * shaper resolution for channelized/non channelized interface
 */
typedef struct
{
    /**
     * Resolution of interface shaper
     */
    uint32 resolution;
} dnx_data_sch_interface_shaper_resolution_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is not channelized calender supported
     */
    dnx_data_sch_interface_non_channelized_calendar,

    /**
     * Must be last one!
     */
    _dnx_data_sch_interface_feature_nof
} dnx_data_sch_interface_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_interface_feature_get_f) (
    int unit,
    dnx_data_sch_interface_feature_e feature);

/**
 * \brief returns define data of nof_big_calendars
 * Module - 'sch', Submodule - 'interface', data - 'nof_big_calendars'
 * Number of big calendars per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_interface_nof_big_calendars_get_f) (
    int unit);

/**
 * \brief returns define data of nof_channelized_calendars
 * Module - 'sch', Submodule - 'interface', data - 'nof_channelized_calendars'
 * Number of channelized calendars per core (both big and regular)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channelized_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_interface_nof_channelized_calendars_get_f) (
    int unit);

/**
 * \brief returns define data of big_calendar_size
 * Module - 'sch', Submodule - 'interface', data - 'big_calendar_size'
 * Size of big calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     big_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_interface_big_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_sch_interfaces
 * Module - 'sch', Submodule - 'interface', data - 'nof_sch_interfaces'
 * Number of sch interfaces per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_sch_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_interface_nof_sch_interfaces_get_f) (
    int unit);

/**
 * \brief returns define data of cal_speed_resolution
 * Module - 'sch', Submodule - 'interface', data - 'cal_speed_resolution'
 * Resolution of interface calendar processing speed
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_speed_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_interface_cal_speed_resolution_get_f) (
    int unit);

/**
 * \brief returns define data of reserved
 * Module - 'sch', Submodule - 'interface', data - 'reserved'
 * Reserved SCH interface to disable interface level FC in case of LAG scheduling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_interface_reserved_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_if_rate_mbps
 * Module - 'sch', Submodule - 'interface', data - 'max_if_rate_mbps'
 * maximal rate an interface can drive (in MBits/sec)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_if_rate_mbps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_interface_max_if_rate_mbps_get_f) (
    int unit);

/**
 * \brief get table shaper_resolution entry 
 * shaper resolution for channelized/non channelized interface
 * 
 * \param [in] unit - unit #
 * \param [in] channelized - is interface channelized
 * 
 * \return
 *     shaper_resolution - returns the relevant entry values grouped in struct - see dnx_data_sch_interface_shaper_resolution_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_interface_shaper_resolution_t *(
    *dnx_data_sch_interface_shaper_resolution_get_f) (
    int unit,
    int channelized);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - INTERFACE:
 * {
 */
/**
 * \brief Interface for sch interface data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_interface_feature_get_f feature_get;
    /**
     * returns define data of nof_big_calendars
     */
    dnx_data_sch_interface_nof_big_calendars_get_f nof_big_calendars_get;
    /**
     * returns define data of nof_channelized_calendars
     */
    dnx_data_sch_interface_nof_channelized_calendars_get_f nof_channelized_calendars_get;
    /**
     * returns define data of big_calendar_size
     */
    dnx_data_sch_interface_big_calendar_size_get_f big_calendar_size_get;
    /**
     * returns define data of nof_sch_interfaces
     */
    dnx_data_sch_interface_nof_sch_interfaces_get_f nof_sch_interfaces_get;
    /**
     * returns define data of cal_speed_resolution
     */
    dnx_data_sch_interface_cal_speed_resolution_get_f cal_speed_resolution_get;
    /**
     * returns define data of reserved
     */
    dnx_data_sch_interface_reserved_get_f reserved_get;
    /**
     * returns numeric data of max_if_rate_mbps
     */
    dnx_data_sch_interface_max_if_rate_mbps_get_f max_if_rate_mbps_get;
    /**
     * get table shaper_resolution entry 
     */
    dnx_data_sch_interface_shaper_resolution_get_f shaper_resolution_get;
    /**
     * get general info table about table (for example key size)shaper_resolution info
     */
    dnxc_data_table_info_get_f shaper_resolution_info_get;
} dnx_data_if_sch_interface_t;

/*
 * }
 */

/*
 * SUBMODULE  - DEVICE:
 * DRM information
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * is shared DRM supported
     */
    dnx_data_sch_device_shared_drm,

    /**
     * Must be last one!
     */
    _dnx_data_sch_device_feature_nof
} dnx_data_sch_device_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_device_feature_get_f) (
    int unit,
    dnx_data_sch_device_feature_e feature);

/**
 * \brief returns define data of drm_resolution
 * Module - 'sch', Submodule - 'device', data - 'drm_resolution'
 * resolution of DRM rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     drm_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_device_drm_resolution_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - DEVICE:
 * {
 */
/**
 * \brief Interface for sch device data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_device_feature_get_f feature_get;
    /**
     * returns define data of drm_resolution
     */
    dnx_data_sch_device_drm_resolution_get_f drm_resolution_get;
} dnx_data_if_sch_device_t;

/*
 * }
 */

/*
 * SUBMODULE  - SCH_ALLOC:
 * e2e scheduler allocation defines
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule sch_alloc table region
 * Table info:
 * content of quartet in each region type
 */
typedef struct
{
    /**
     * list of elements in quartet
     */
    dnx_sch_element_se_type_e flow_type[4];
    /**
     * Odd/even mode
     */
    dnx_scheduler_region_odd_even_mode_t odd_even_mode;
    /**
     * [Boolean] CL can be searched on half of the quratet
     */
    uint32 cl_half_pattern;
    /**
     * [Boolean] FQ can be searched on half of the quratet
     */
    uint32 fq_half_pattern;
    /**
     * [Boolean] CL and FQ of an enhanced CL share borders
     */
    uint32 enhanced_cl_compact;
} dnx_data_sch_sch_alloc_region_t;

/**
 * \brief Holds values of submodule sch_alloc table connector
 * Table info:
 * allocation info for VOQ connectors
 */
typedef struct
{
    /**
     * alignment requirement
     */
    uint32 alignment;
    /**
     * allocation pattern
     */
    uint32 pattern;
    /**
     * size of allocation pattern
     */
    uint32 pattern_size;
    /**
     * number of elements in allocation pattern
     */
    uint32 nof_in_pattern;
} dnx_data_sch_sch_alloc_connector_t;

/**
 * \brief Holds values of submodule sch_alloc table se_per_region_type
 * Table info:
 * allocation info for scheduling elements per region type
 */
typedef struct
{
    /**
     * is the entry valid. In case the entry is not valid, the data is taken from se table
     */
    uint32 valid;
    /**
     * alignment requirement
     */
    uint32 alignment;
    /**
     * allocation pattern
     */
    uint32 pattern;
    /**
     * size of allocation pattern
     */
    uint32 pattern_size;
    /**
     * size offset array
     */
    uint32 nof_offsets;
    /**
     * list of offsets
     */
    uint32 offset[4];
} dnx_data_sch_sch_alloc_se_per_region_type_t;

/**
 * \brief Holds values of submodule sch_alloc table se
 * Table info:
 * allocation info for scheduling elements
 */
typedef struct
{
    /**
     * alignment requirement
     */
    uint32 alignment;
    /**
     * allocation pattern
     */
    uint32 pattern;
    /**
     * size of allocation pattern
     */
    uint32 pattern_size;
    /**
     * size offset array
     */
    uint32 nof_offsets;
    /**
     * list of offsets
     */
    uint32 offset[4];
} dnx_data_sch_sch_alloc_se_t;

/**
 * \brief Holds values of submodule sch_alloc table composite_se_per_region_type
 * Table info:
 * allocation info for composite scheduling elements per region type
 */
typedef struct
{
    /**
     * is the entry valid. In case the entry is not valid, the data is taken from composite_se table
     */
    uint32 valid;
    /**
     * alignment requirement
     */
    uint32 alignment;
    /**
     * allocation pattern
     */
    uint32 pattern;
    /**
     * size of allocation pattern
     */
    uint32 pattern_size;
} dnx_data_sch_sch_alloc_composite_se_per_region_type_t;

/**
 * \brief Holds values of submodule sch_alloc table composite_se
 * Table info:
 * allocation info for composite scheduling elements
 */
typedef struct
{
    /**
     * alignment requirement
     */
    uint32 alignment;
    /**
     * allocation pattern
     */
    uint32 pattern;
    /**
     * size of allocation pattern
     */
    uint32 pattern_size;
} dnx_data_sch_sch_alloc_composite_se_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_sch_alloc_feature_nof
} dnx_data_sch_sch_alloc_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_sch_alloc_feature_get_f) (
    int unit,
    dnx_data_sch_sch_alloc_feature_e feature);

/**
 * \brief returns define data of tag_aggregate_se_2
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_aggregate_se_2'
 * 2 SE aggregate tag
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_aggregate_se_2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_tag_aggregate_se_2_get_f) (
    int unit);

/**
 * \brief returns define data of tag_aggregate_se_4
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_aggregate_se_4'
 * 4 SE aggregate tag
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_aggregate_se_4 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_tag_aggregate_se_4_get_f) (
    int unit);

/**
 * \brief returns define data of tag_aggregate_se_8
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_aggregate_se_8'
 * 8 SE aggregate tag
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_aggregate_se_8 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_tag_aggregate_se_8_get_f) (
    int unit);

/**
 * \brief returns define data of shared_shaper_max_tag_value
 * Module - 'sch', Submodule - 'sch_alloc', data - 'shared_shaper_max_tag_value'
 * max tag value for shared shaper
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     shared_shaper_max_tag_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_shared_shaper_max_tag_value_get_f) (
    int unit);

/**
 * \brief returns define data of tag_size_aggregate_se
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_size_aggregate_se'
 * tag size for SE aggregate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_size_aggregate_se - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_tag_size_aggregate_se_get_f) (
    int unit);

/**
 * \brief returns define data of tag_size_con
 * Module - 'sch', Submodule - 'sch_alloc', data - 'tag_size_con'
 * tag size for connectors - modid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tag_size_con - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_tag_size_con_get_f) (
    int unit);

/**
 * \brief returns define data of type_con_reg_start
 * Module - 'sch', Submodule - 'sch_alloc', data - 'type_con_reg_start'
 * start of the connectors only region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_con_reg_start - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_type_con_reg_start_get_f) (
    int unit);

/**
 * \brief returns define data of alloc_invalid_flow
 * Module - 'sch', Submodule - 'sch_alloc', data - 'alloc_invalid_flow'
 * invalid flow define
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     alloc_invalid_flow - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_alloc_invalid_flow_get_f) (
    int unit);

/**
 * \brief returns define data of dealloc_flow_ids
 * Module - 'sch', Submodule - 'sch_alloc', data - 'dealloc_flow_ids'
 * max number of flows to deallocate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dealloc_flow_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_dealloc_flow_ids_get_f) (
    int unit);

/**
 * \brief returns numeric data of type_con_reg_end
 * Module - 'sch', Submodule - 'sch_alloc', data - 'type_con_reg_end'
 * end of the connectors only region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_con_reg_end - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_type_con_reg_end_get_f) (
    int unit);

/**
 * \brief returns numeric data of type_hr_reg_start
 * Module - 'sch', Submodule - 'sch_alloc', data - 'type_hr_reg_start'
 * searching start of the HR region
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_hr_reg_start - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_sch_alloc_type_hr_reg_start_get_f) (
    int unit);

/**
 * \brief get table region entry 
 * content of quartet in each region type
 * 
 * \param [in] unit - unit #
 * \param [in] quartet_type - quartet type
 * \param [in] region_type - region type
 * 
 * \return
 *     region - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_region_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_sch_alloc_region_t *(
    *dnx_data_sch_sch_alloc_region_get_f) (
    int unit,
    int quartet_type,
    int region_type);

/**
 * \brief get table connector entry 
 * allocation info for VOQ connectors
 * 
 * \param [in] unit - unit #
 * \param [in] composite - is composite connector
 * \param [in] interdigitated - is interdigitated
 * 
 * \return
 *     connector - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_connector_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_sch_alloc_connector_t *(
    *dnx_data_sch_sch_alloc_connector_get_f) (
    int unit,
    int composite,
    int interdigitated);

/**
 * \brief get table se_per_region_type entry 
 * allocation info for scheduling elements per region type
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * \param [in] region_type - type of region
 * 
 * \return
 *     se_per_region_type - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_se_per_region_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_sch_alloc_se_per_region_type_t *(
    *dnx_data_sch_sch_alloc_se_per_region_type_get_f) (
    int unit,
    int flow_type,
    int region_type);

/**
 * \brief get table se entry 
 * allocation info for scheduling elements
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * 
 * \return
 *     se - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_se_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_sch_alloc_se_t *(
    *dnx_data_sch_sch_alloc_se_get_f) (
    int unit,
    int flow_type);

/**
 * \brief get table composite_se_per_region_type entry 
 * allocation info for composite scheduling elements per region type
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * \param [in] region_type - type of region
 * 
 * \return
 *     composite_se_per_region_type - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_composite_se_per_region_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_sch_alloc_composite_se_per_region_type_t *(
    *dnx_data_sch_sch_alloc_composite_se_per_region_type_get_f) (
    int unit,
    int flow_type,
    int region_type);

/**
 * \brief get table composite_se entry 
 * allocation info for composite scheduling elements
 * 
 * \param [in] unit - unit #
 * \param [in] flow_type - type of element
 * \param [in] odd_even_mode - odd or even region
 * 
 * \return
 *     composite_se - returns the relevant entry values grouped in struct - see dnx_data_sch_sch_alloc_composite_se_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_sch_sch_alloc_composite_se_t *(
    *dnx_data_sch_sch_alloc_composite_se_get_f) (
    int unit,
    int flow_type,
    int odd_even_mode);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - SCH_ALLOC:
 * {
 */
/**
 * \brief Interface for sch sch_alloc data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_sch_alloc_feature_get_f feature_get;
    /**
     * returns define data of tag_aggregate_se_2
     */
    dnx_data_sch_sch_alloc_tag_aggregate_se_2_get_f tag_aggregate_se_2_get;
    /**
     * returns define data of tag_aggregate_se_4
     */
    dnx_data_sch_sch_alloc_tag_aggregate_se_4_get_f tag_aggregate_se_4_get;
    /**
     * returns define data of tag_aggregate_se_8
     */
    dnx_data_sch_sch_alloc_tag_aggregate_se_8_get_f tag_aggregate_se_8_get;
    /**
     * returns define data of shared_shaper_max_tag_value
     */
    dnx_data_sch_sch_alloc_shared_shaper_max_tag_value_get_f shared_shaper_max_tag_value_get;
    /**
     * returns define data of tag_size_aggregate_se
     */
    dnx_data_sch_sch_alloc_tag_size_aggregate_se_get_f tag_size_aggregate_se_get;
    /**
     * returns define data of tag_size_con
     */
    dnx_data_sch_sch_alloc_tag_size_con_get_f tag_size_con_get;
    /**
     * returns define data of type_con_reg_start
     */
    dnx_data_sch_sch_alloc_type_con_reg_start_get_f type_con_reg_start_get;
    /**
     * returns define data of alloc_invalid_flow
     */
    dnx_data_sch_sch_alloc_alloc_invalid_flow_get_f alloc_invalid_flow_get;
    /**
     * returns define data of dealloc_flow_ids
     */
    dnx_data_sch_sch_alloc_dealloc_flow_ids_get_f dealloc_flow_ids_get;
    /**
     * returns numeric data of type_con_reg_end
     */
    dnx_data_sch_sch_alloc_type_con_reg_end_get_f type_con_reg_end_get;
    /**
     * returns numeric data of type_hr_reg_start
     */
    dnx_data_sch_sch_alloc_type_hr_reg_start_get_f type_hr_reg_start_get;
    /**
     * get table region entry 
     */
    dnx_data_sch_sch_alloc_region_get_f region_get;
    /**
     * get general info table about table (for example key size)region info
     */
    dnxc_data_table_info_get_f region_info_get;
    /**
     * get table connector entry 
     */
    dnx_data_sch_sch_alloc_connector_get_f connector_get;
    /**
     * get general info table about table (for example key size)connector info
     */
    dnxc_data_table_info_get_f connector_info_get;
    /**
     * get table se_per_region_type entry 
     */
    dnx_data_sch_sch_alloc_se_per_region_type_get_f se_per_region_type_get;
    /**
     * get general info table about table (for example key size)se_per_region_type info
     */
    dnxc_data_table_info_get_f se_per_region_type_info_get;
    /**
     * get table se entry 
     */
    dnx_data_sch_sch_alloc_se_get_f se_get;
    /**
     * get general info table about table (for example key size)se info
     */
    dnxc_data_table_info_get_f se_info_get;
    /**
     * get table composite_se_per_region_type entry 
     */
    dnx_data_sch_sch_alloc_composite_se_per_region_type_get_f composite_se_per_region_type_get;
    /**
     * get general info table about table (for example key size)composite_se_per_region_type info
     */
    dnxc_data_table_info_get_f composite_se_per_region_type_info_get;
    /**
     * get table composite_se entry 
     */
    dnx_data_sch_sch_alloc_composite_se_get_f composite_se_get;
    /**
     * get general info table about table (for example key size)composite_se info
     */
    dnxc_data_table_info_get_f composite_se_info_get;
} dnx_data_if_sch_sch_alloc_t;

/*
 * }
 */

/*
 * SUBMODULE  - DBAL:
 * e2e scheduler dbal defines
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_sch_dbal_feature_nof
} dnx_data_sch_dbal_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_dbal_feature_get_f) (
    int unit,
    dnx_data_sch_dbal_feature_e feature);

/**
 * \brief returns define data of scheduler_enable_grouping_factor
 * Module - 'sch', Submodule - 'dbal', data - 'scheduler_enable_grouping_factor'
 * size of group of sched elements sharing the same HW field 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     scheduler_enable_grouping_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_scheduler_enable_grouping_factor_get_f) (
    int unit);

/**
 * \brief returns define data of scheduler_enable_dbal_mult_factor
 * Module - 'sch', Submodule - 'dbal', data - 'scheduler_enable_dbal_mult_factor'
 * DBAL multiplication factor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     scheduler_enable_dbal_mult_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_scheduler_enable_dbal_mult_factor_get_f) (
    int unit);

/**
 * \brief returns define data of flow_bits
 * Module - 'sch', Submodule - 'dbal', data - 'flow_bits'
 * Number of bits in flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_flow_bits_get_f) (
    int unit);

/**
 * \brief returns define data of se_bits
 * Module - 'sch', Submodule - 'dbal', data - 'se_bits'
 * Number of bits in Scheduling element id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     se_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_se_bits_get_f) (
    int unit);

/**
 * \brief returns define data of cl_bits
 * Module - 'sch', Submodule - 'dbal', data - 'cl_bits'
 * Number of bits in CL id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cl_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_cl_bits_get_f) (
    int unit);

/**
 * \brief returns define data of hr_bits
 * Module - 'sch', Submodule - 'dbal', data - 'hr_bits'
 * Number of bits in HR id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hr_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_hr_bits_get_f) (
    int unit);

/**
 * \brief returns define data of interface_bits
 * Module - 'sch', Submodule - 'dbal', data - 'interface_bits'
 * Number of bits in interface id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     interface_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_interface_bits_get_f) (
    int unit);

/**
 * \brief returns define data of calendar_bits
 * Module - 'sch', Submodule - 'dbal', data - 'calendar_bits'
 * Number of bits in calendar id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     calendar_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_calendar_bits_get_f) (
    int unit);

/**
 * \brief returns define data of flow_shaper_mant_bits
 * Module - 'sch', Submodule - 'dbal', data - 'flow_shaper_mant_bits'
 * Number of bits in flow shaper mantissa
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_shaper_mant_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_flow_shaper_mant_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ps_shaper_quanta_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_shaper_quanta_bits'
 * number of bits in PS shaper quanta
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_shaper_quanta_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_ps_shaper_quanta_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ps_shaper_max_burst_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_shaper_max_burst_bits'
 * number of bits in PS shaper max burst
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_shaper_max_burst_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_ps_shaper_max_burst_bits_get_f) (
    int unit);

/**
 * \brief returns define data of drm_nof_links_max
 * Module - 'sch', Submodule - 'dbal', data - 'drm_nof_links_max'
 * maximal value of number of links for DRM table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     drm_nof_links_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_drm_nof_links_max_get_f) (
    int unit);

/**
 * \brief returns define data of token_count_default
 * Module - 'sch', Submodule - 'dbal', data - 'token_count_default'
 * default value of token count
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     token_count_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_token_count_default_get_f) (
    int unit);

/**
 * \brief returns numeric data of scheduler_enable_key_size
 * Module - 'sch', Submodule - 'dbal', data - 'scheduler_enable_key_size'
 * size in bits of key in scheduler enable DBAL table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     scheduler_enable_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_scheduler_enable_key_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of flow_id_pair_key_size
 * Module - 'sch', Submodule - 'dbal', data - 'flow_id_pair_key_size'
 * size in bits of half flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_id_pair_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_flow_id_pair_key_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of flow_id_pair_max
 * Module - 'sch', Submodule - 'dbal', data - 'flow_id_pair_max'
 * max value of half flow id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_id_pair_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_flow_id_pair_max_get_f) (
    int unit);

/**
 * \brief returns numeric data of ps_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_bits'
 * Number of bits in PS id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_ps_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of flow_shaper_descr_bits
 * Module - 'sch', Submodule - 'dbal', data - 'flow_shaper_descr_bits'
 * Number of bits in flow shaper descriptor for one flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flow_shaper_descr_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_flow_shaper_descr_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of ps_shaper_bits
 * Module - 'sch', Submodule - 'dbal', data - 'ps_shaper_bits'
 * number of bits in PS shaper
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ps_shaper_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_ps_shaper_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of cl_profile_bits
 * Module - 'sch', Submodule - 'dbal', data - 'cl_profile_bits'
 * number of bits in CL profile id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cl_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_sch_dbal_cl_profile_bits_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - DBAL:
 * {
 */
/**
 * \brief Interface for sch dbal data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_dbal_feature_get_f feature_get;
    /**
     * returns define data of scheduler_enable_grouping_factor
     */
    dnx_data_sch_dbal_scheduler_enable_grouping_factor_get_f scheduler_enable_grouping_factor_get;
    /**
     * returns define data of scheduler_enable_dbal_mult_factor
     */
    dnx_data_sch_dbal_scheduler_enable_dbal_mult_factor_get_f scheduler_enable_dbal_mult_factor_get;
    /**
     * returns define data of flow_bits
     */
    dnx_data_sch_dbal_flow_bits_get_f flow_bits_get;
    /**
     * returns define data of se_bits
     */
    dnx_data_sch_dbal_se_bits_get_f se_bits_get;
    /**
     * returns define data of cl_bits
     */
    dnx_data_sch_dbal_cl_bits_get_f cl_bits_get;
    /**
     * returns define data of hr_bits
     */
    dnx_data_sch_dbal_hr_bits_get_f hr_bits_get;
    /**
     * returns define data of interface_bits
     */
    dnx_data_sch_dbal_interface_bits_get_f interface_bits_get;
    /**
     * returns define data of calendar_bits
     */
    dnx_data_sch_dbal_calendar_bits_get_f calendar_bits_get;
    /**
     * returns define data of flow_shaper_mant_bits
     */
    dnx_data_sch_dbal_flow_shaper_mant_bits_get_f flow_shaper_mant_bits_get;
    /**
     * returns define data of ps_shaper_quanta_bits
     */
    dnx_data_sch_dbal_ps_shaper_quanta_bits_get_f ps_shaper_quanta_bits_get;
    /**
     * returns define data of ps_shaper_max_burst_bits
     */
    dnx_data_sch_dbal_ps_shaper_max_burst_bits_get_f ps_shaper_max_burst_bits_get;
    /**
     * returns define data of drm_nof_links_max
     */
    dnx_data_sch_dbal_drm_nof_links_max_get_f drm_nof_links_max_get;
    /**
     * returns define data of token_count_default
     */
    dnx_data_sch_dbal_token_count_default_get_f token_count_default_get;
    /**
     * returns numeric data of scheduler_enable_key_size
     */
    dnx_data_sch_dbal_scheduler_enable_key_size_get_f scheduler_enable_key_size_get;
    /**
     * returns numeric data of flow_id_pair_key_size
     */
    dnx_data_sch_dbal_flow_id_pair_key_size_get_f flow_id_pair_key_size_get;
    /**
     * returns numeric data of flow_id_pair_max
     */
    dnx_data_sch_dbal_flow_id_pair_max_get_f flow_id_pair_max_get;
    /**
     * returns numeric data of ps_bits
     */
    dnx_data_sch_dbal_ps_bits_get_f ps_bits_get;
    /**
     * returns numeric data of flow_shaper_descr_bits
     */
    dnx_data_sch_dbal_flow_shaper_descr_bits_get_f flow_shaper_descr_bits_get;
    /**
     * returns numeric data of ps_shaper_bits
     */
    dnx_data_sch_dbal_ps_shaper_bits_get_f ps_shaper_bits_get;
    /**
     * returns numeric data of cl_profile_bits
     */
    dnx_data_sch_dbal_cl_profile_bits_get_f cl_profile_bits_get;
} dnx_data_if_sch_dbal_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURES:
 * Per devices features
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    dnx_data_sch_features_dlm,

    /**
     * Must be last one!
     */
    _dnx_data_sch_features_feature_nof
} dnx_data_sch_features_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_sch_features_feature_get_f) (
    int unit,
    dnx_data_sch_features_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_SCH - FEATURES:
 * {
 */
/**
 * \brief Interface for sch features data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_sch_features_feature_get_f feature_get;
} dnx_data_if_sch_features_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_SCH:
 * {
 */
/**
 * \brief Interface for sch data
 */
typedef struct
{
    /**
     * Interface for sch general data
     */
    dnx_data_if_sch_general_t general;
    /**
     * Interface for sch ps data
     */
    dnx_data_if_sch_ps_t ps;
    /**
     * Interface for sch flow data
     */
    dnx_data_if_sch_flow_t flow;
    /**
     * Interface for sch se data
     */
    dnx_data_if_sch_se_t se;
    /**
     * Interface for sch interface data
     */
    dnx_data_if_sch_interface_t interface;
    /**
     * Interface for sch device data
     */
    dnx_data_if_sch_device_t device;
    /**
     * Interface for sch sch_alloc data
     */
    dnx_data_if_sch_sch_alloc_t sch_alloc;
    /**
     * Interface for sch dbal data
     */
    dnx_data_if_sch_dbal_t dbal;
    /**
     * Interface for sch features data
     */
    dnx_data_if_sch_features_t features;
} dnx_data_if_sch_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_sch_t dnx_data_sch;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_SCH_H_*/
/* *INDENT-ON* */
