/** \file dnx_data_port.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_PORT_H_
/*{*/
#define _DNX_DATA_PORT_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm/port.h>
#include <bcm_int/dnx/algo/port/algo_port_mgmt.h>
#include <soc/dnxc/dnxc_port.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_port.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_port_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - STATIC_ADD:
 * adding port statically
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule static_add table ucode_port
 * Table info:
 * static port configuration
 */
typedef struct
{
    /**
     * port interface
     */
    bcm_port_if_t interface;
    /**
     * port number of lanes
     */
    int nof_lanes;
    /**
     * interface offset
     */
    int interface_offset;
    /**
     * core id
     */
    bcm_core_t core;
    /**
     * tm port
     */
    int tm_port;
    /**
     * out tm port
     */
    int out_tm_port;
    /**
     * channel id
     */
    int channel;
    /**
     * true if it is statistic interface port
     */
    int is_stif;
    /**
     * true if it is statistic interface and data port (mix)
     */
    int is_stif_data;
    /**
     * true if it is kbp port
     */
    int is_kbp;
    /**
     * true if it is cross connect port
     */
    int is_cross_connect;
    /**
     * true if it is FlexE physical port
     */
    int is_flexe_phy;
    /**
     * is interface interleaved in ingress
     */
    int is_ingress_interleave;
    /**
     * is port contain egress interleaving
     */
    int is_egress_interleave;
    /**
     * is TDM port
     */
    int is_tdm;
    /**
     * is interface includes TDM ports only
     */
    int is_if_tdm_only;
    /**
     * is interface includes both TDM ports anf non TDM ports
     */
    int is_if_tdm_hybrid;
    /**
     * is sch priority propagation enabled on this port
     */
    int sch_priority_propagation_en;
    /**
     * number of port priorities
     */
    int num_priorities;
    /**
     * should be used just in case the user need to exlictly pick the base queue pair
     */
    int base_q_pair;
    /**
     * number of sch port priorities
     */
    int num_sch_priorities;
    /**
     * should be used just in case the user need to exlictly pick the base HR
     */
    int base_hr;
} dnx_data_port_static_add_ucode_port_t;

/**
 * \brief Holds values of submodule static_add table speed
 * Table info:
 * per port speed
 */
typedef struct
{
    /**
     * speed value in mbps
     */
    int val;
} dnx_data_port_static_add_speed_t;

/**
 * \brief Holds values of submodule static_add table ext_stat_speed
 * Table info:
 * per external kbp stat port speed
 */
typedef struct
{
    /**
     * speed value in mbps
     */
    int speed;
    /**
     * port number of lanes
     */
    int nof_lanes;
} dnx_data_port_static_add_ext_stat_speed_t;

/**
 * \brief Holds values of submodule static_add table eth_padding
 * Table info:
 * eth ports padding
 */
typedef struct
{
    /**
     * packets smaller than min size value are padded with this value
     */
    int pad_size;
} dnx_data_port_static_add_eth_padding_t;

/**
 * \brief Holds values of submodule static_add table link_training
 * Table info:
 * per port link training (CL72)
 */
typedef struct
{
    /**
     * Is CL72 is enabled
     */
    int val;
} dnx_data_port_static_add_link_training_t;

/**
 * \brief Holds values of submodule static_add table ext_stat_link_training
 * Table info:
 * per external kbp stat port link training (CL72)
 */
typedef struct
{
    /**
     * Is CL72 is enabled
     */
    int val;
} dnx_data_port_static_add_ext_stat_link_training_t;

/**
 * \brief Holds values of submodule static_add table fec_type
 * Table info:
 * per port FEC type
 */
typedef struct
{
    /**
     * FEC type
     */
    bcm_port_phy_fec_t val;
} dnx_data_port_static_add_fec_type_t;

/**
 * \brief Holds values of submodule static_add table serdes_lane_config
 * Table info:
 * serdes lane configurations, related to firmware
 */
typedef struct
{
    /**
     * dfe filter
     */
    soc_dnxc_port_dfe_mode_t dfe;
    /**
     * media type
     */
    int media_type;
    /**
     * unreliable los
     */
    int unreliable_los;
    /**
     * cl72 auto polarity
     */
    int cl72_auto_polarity_enable;
    /**
     * cl72 restart timeout
     */
    int cl72_restart_timeout_enable;
    /**
     * force nr or force er
     */
    soc_dnxc_port_channel_mode_t channel_mode;
} dnx_data_port_static_add_serdes_lane_config_t;

/**
 * \brief Holds values of submodule static_add table serdes_tx_taps
 * Table info:
 * PHY TX tap configuration
 */
typedef struct
{
    /**
     * Tx fir pre tap
     */
    int pre;
    /**
     * Tx fir main tap
     */
    int main;
    /**
     * Tx fir post tap
     */
    int post;
    /**
     * Tx fir pre2 tap
     */
    int pre2;
    /**
     * Tx fir post2 tap
     */
    int post2;
    /**
     * Tx fir post3 tap
     */
    int post3;
    /**
     * Tx fir tap mode
     */
    bcm_port_phy_tx_tap_mode_t tx_tap_mode;
    /**
     * Signalling Mode, NRZ or PAM4
     */
    bcm_port_phy_signalling_mode_t signalling_mode;
} dnx_data_port_static_add_serdes_tx_taps_t;

/**
 * \brief Holds values of submodule static_add table ext_stat_global_serdes_tx_taps
 * Table info:
 * PHY TX tap configuration
 */
typedef struct
{
    /**
     * Tx fir pre tap
     */
    int pre;
    /**
     * Tx fir main tap
     */
    int main;
    /**
     * Tx fir post tap
     */
    int post;
    /**
     * Tx fir pre2 tap
     */
    int pre2;
    /**
     * Tx fir post2 tap
     */
    int post2;
    /**
     * Tx fir post3 tap
     */
    int post3;
    /**
     * TXFIR Tap Enable Enum
     */
    int txfir_tap_enable;
} dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_t;

/**
 * \brief Holds values of submodule static_add table ext_stat_lane_serdes_tx_taps
 * Table info:
 * PHY TX tap configuration
 */
typedef struct
{
    /**
     * Tx fir pre tap
     */
    int pre;
    /**
     * Tx fir main tap
     */
    int main;
    /**
     * Tx fir post tap
     */
    int post;
    /**
     * Tx fir pre2 tap
     */
    int pre2;
    /**
     * Tx fir post2 tap
     */
    int post2;
    /**
     * Tx fir post3 tap
     */
    int post3;
    /**
     * TXFIR Tap Enable Enum
     */
    int txfir_tap_enable;
} dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_t;

/**
 * \brief Holds values of submodule static_add table tx_pam4_precoder
 * Table info:
 * is the precoding enabled on TX side
 */
typedef struct
{
    /**
     * TX PAM4 Precoder
     */
    uint32 val;
} dnx_data_port_static_add_tx_pam4_precoder_t;

/**
 * \brief Holds values of submodule static_add table lp_tx_precoder
 * Table info:
 * has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.
 */
typedef struct
{
    /**
     * Link Partner TX Precoder
     */
    uint32 val;
} dnx_data_port_static_add_lp_tx_precoder_t;

/**
 * \brief Holds values of submodule static_add table fabric_quad_info
 * Table info:
 * General fabric quad info
 */
typedef struct
{
    /**
     * Is the quad enabled
     */
    int quad_enable;
} dnx_data_port_static_add_fabric_quad_info_t;

/**
 * \brief Holds values of submodule static_add table header_type
 * Table info:
 * header type information
 */
typedef struct
{
    /**
     * header type per incoming port
     */
    int header_type_in;
    /**
     * header type per outgoing port
     */
    int header_type_out;
    /**
     * header type per incoming/outgoing port
     */
    int header_type;
} dnx_data_port_static_add_header_type_t;

/**
 * \brief Holds values of submodule static_add table erp_exist
 * Table info:
 * Is ERP port defined in config file for the core
 */
typedef struct
{
    /**
     * does epr exist on this core
     */
    int exist;
} dnx_data_port_static_add_erp_exist_t;

/**
 * \brief Holds values of submodule static_add table base_flexe_instance
 * Table info:
 * base flexe instance
 */
typedef struct
{
    /**
     * base flexe instance
     */
    int val;
} dnx_data_port_static_add_base_flexe_instance_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_port_static_add_feature_nof
} dnx_data_port_static_add_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_port_static_add_feature_get_f) (
    int unit,
    dnx_data_port_static_add_feature_e feature);

/**
 * \brief returns define data of default_speed_for_special_if
 * Module - 'port', Submodule - 'static_add', data - 'default_speed_for_special_if'
 * default speed in kbps for special interfaces (tm ports excluding NIF)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_speed_for_special_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_static_add_default_speed_for_special_if_get_f) (
    int unit);

/**
 * \brief returns numeric data of fabric_fw_load_method
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_load_method'
 * Method of the Fabric firmware load
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_fw_load_method - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_static_add_fabric_fw_load_method_get_f) (
    int unit);

/**
 * \brief returns numeric data of fabric_fw_crc_check
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_crc_check'
 * Enable fabric firmware CRC check.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_fw_crc_check - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_static_add_fabric_fw_crc_check_get_f) (
    int unit);

/**
 * \brief returns numeric data of fabric_fw_load_verify
 * Module - 'port', Submodule - 'static_add', data - 'fabric_fw_load_verify'
 * Enable fabric firmware load verification.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_fw_load_verify - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_static_add_fabric_fw_load_verify_get_f) (
    int unit);

/**
 * \brief returns numeric data of nif_fw_load_method
 * Module - 'port', Submodule - 'static_add', data - 'nif_fw_load_method'
 * Method of the Nif firmware load
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_fw_load_method - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_static_add_nif_fw_load_method_get_f) (
    int unit);

/**
 * \brief returns numeric data of nif_fw_crc_check
 * Module - 'port', Submodule - 'static_add', data - 'nif_fw_crc_check'
 * Enable NIF firmware CRC check.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_fw_crc_check - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_static_add_nif_fw_crc_check_get_f) (
    int unit);

/**
 * \brief returns numeric data of nif_fw_load_verify
 * Module - 'port', Submodule - 'static_add', data - 'nif_fw_load_verify'
 * Enable NIF firmware load verification.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_fw_load_verify - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_static_add_nif_fw_load_verify_get_f) (
    int unit);

/**
 * \brief get table ucode_port entry 
 * static port configuration
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port
 * 
 * \return
 *     ucode_port - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ucode_port_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_ucode_port_t *(
    *dnx_data_port_static_add_ucode_port_get_f) (
    int unit,
    int port);

/**
 * \brief get table speed entry 
 * per port speed
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     speed - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_speed_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_speed_t *(
    *dnx_data_port_static_add_speed_get_f) (
    int unit,
    int port);

/**
 * \brief get table ext_stat_speed entry 
 * per external kbp stat port speed
 * 
 * \param [in] unit - unit #
 * \param [in] ext_stat_port - external device (kbp) statistics port number
 * 
 * \return
 *     ext_stat_speed - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_speed_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_ext_stat_speed_t *(
    *dnx_data_port_static_add_ext_stat_speed_get_f) (
    int unit,
    int ext_stat_port);

/**
 * \brief get table eth_padding entry 
 * eth ports padding
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     eth_padding - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_eth_padding_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_eth_padding_t *(
    *dnx_data_port_static_add_eth_padding_get_f) (
    int unit,
    int port);

/**
 * \brief get table link_training entry 
 * per port link training (CL72)
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     link_training - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_link_training_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_link_training_t *(
    *dnx_data_port_static_add_link_training_get_f) (
    int unit,
    int port);

/**
 * \brief get table ext_stat_link_training entry 
 * per external kbp stat port link training (CL72)
 * 
 * \param [in] unit - unit #
 * \param [in] ext_stat_port - external device (kbp) statistics port number
 * 
 * \return
 *     ext_stat_link_training - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_link_training_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_ext_stat_link_training_t *(
    *dnx_data_port_static_add_ext_stat_link_training_get_f) (
    int unit,
    int ext_stat_port);

/**
 * \brief get table fec_type entry 
 * per port FEC type
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     fec_type - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_fec_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_fec_type_t *(
    *dnx_data_port_static_add_fec_type_get_f) (
    int unit,
    int port);

/**
 * \brief get table serdes_lane_config entry 
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     serdes_lane_config - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_serdes_lane_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_serdes_lane_config_t *(
    *dnx_data_port_static_add_serdes_lane_config_get_f) (
    int unit,
    int port);

/**
 * \brief get table serdes_tx_taps entry 
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     serdes_tx_taps - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_serdes_tx_taps_t *(
    *dnx_data_port_static_add_serdes_tx_taps_get_f) (
    int unit,
    int port);

/**
 * \brief get table ext_stat_global_serdes_tx_taps entry 
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ext_stat_global_serdes_tx_taps - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_t *(
    *dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_get_f) (
    int unit);

/**
 * \brief get table ext_stat_lane_serdes_tx_taps entry 
 * PHY TX tap configuration
 * 
 * \param [in] unit - unit #
 * \param [in] lane - physical lane id
 * 
 * \return
 *     ext_stat_lane_serdes_tx_taps - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_t *(
    *dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_get_f) (
    int unit,
    int lane);

/**
 * \brief get table tx_pam4_precoder entry 
 * is the precoding enabled on TX side
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     tx_pam4_precoder - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_tx_pam4_precoder_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_tx_pam4_precoder_t *(
    *dnx_data_port_static_add_tx_pam4_precoder_get_f) (
    int unit,
    int port);

/**
 * \brief get table lp_tx_precoder entry 
 * has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     lp_tx_precoder - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_lp_tx_precoder_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_lp_tx_precoder_t *(
    *dnx_data_port_static_add_lp_tx_precoder_get_f) (
    int unit,
    int port);

/**
 * \brief get table fabric_quad_info entry 
 * General fabric quad info
 * 
 * \param [in] unit - unit #
 * \param [in] quad - Quad ID
 * 
 * \return
 *     fabric_quad_info - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_fabric_quad_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_fabric_quad_info_t *(
    *dnx_data_port_static_add_fabric_quad_info_get_f) (
    int unit,
    int quad);

/**
 * \brief get table header_type entry 
 * header type information
 * 
 * \param [in] unit - unit #
 * \param [in] port - port
 * 
 * \return
 *     header_type - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_header_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_header_type_t *(
    *dnx_data_port_static_add_header_type_get_f) (
    int unit,
    int port);

/**
 * \brief get table erp_exist entry 
 * Is ERP port defined in config file for the core
 * 
 * \param [in] unit - unit #
 * \param [in] core - core
 * 
 * \return
 *     erp_exist - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_erp_exist_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_erp_exist_t *(
    *dnx_data_port_static_add_erp_exist_get_f) (
    int unit,
    int core);

/**
 * \brief get table base_flexe_instance entry 
 * base flexe instance
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port number
 * 
 * \return
 *     base_flexe_instance - returns the relevant entry values grouped in struct - see dnx_data_port_static_add_base_flexe_instance_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_static_add_base_flexe_instance_t *(
    *dnx_data_port_static_add_base_flexe_instance_get_f) (
    int unit,
    int port);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_PORT - STATIC_ADD:
 * {
 */
/**
 * \brief Interface for port static_add data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_port_static_add_feature_get_f feature_get;
    /**
     * returns define data of default_speed_for_special_if
     */
    dnx_data_port_static_add_default_speed_for_special_if_get_f default_speed_for_special_if_get;
    /**
     * returns numeric data of fabric_fw_load_method
     */
    dnx_data_port_static_add_fabric_fw_load_method_get_f fabric_fw_load_method_get;
    /**
     * returns numeric data of fabric_fw_crc_check
     */
    dnx_data_port_static_add_fabric_fw_crc_check_get_f fabric_fw_crc_check_get;
    /**
     * returns numeric data of fabric_fw_load_verify
     */
    dnx_data_port_static_add_fabric_fw_load_verify_get_f fabric_fw_load_verify_get;
    /**
     * returns numeric data of nif_fw_load_method
     */
    dnx_data_port_static_add_nif_fw_load_method_get_f nif_fw_load_method_get;
    /**
     * returns numeric data of nif_fw_crc_check
     */
    dnx_data_port_static_add_nif_fw_crc_check_get_f nif_fw_crc_check_get;
    /**
     * returns numeric data of nif_fw_load_verify
     */
    dnx_data_port_static_add_nif_fw_load_verify_get_f nif_fw_load_verify_get;
    /**
     * get table ucode_port entry 
     */
    dnx_data_port_static_add_ucode_port_get_f ucode_port_get;
    /**
     * get general info table about table (for example key size)ucode_port info
     */
    dnxc_data_table_info_get_f ucode_port_info_get;
    /**
     * get table speed entry 
     */
    dnx_data_port_static_add_speed_get_f speed_get;
    /**
     * get general info table about table (for example key size)speed info
     */
    dnxc_data_table_info_get_f speed_info_get;
    /**
     * get table ext_stat_speed entry 
     */
    dnx_data_port_static_add_ext_stat_speed_get_f ext_stat_speed_get;
    /**
     * get general info table about table (for example key size)ext_stat_speed info
     */
    dnxc_data_table_info_get_f ext_stat_speed_info_get;
    /**
     * get table eth_padding entry 
     */
    dnx_data_port_static_add_eth_padding_get_f eth_padding_get;
    /**
     * get general info table about table (for example key size)eth_padding info
     */
    dnxc_data_table_info_get_f eth_padding_info_get;
    /**
     * get table link_training entry 
     */
    dnx_data_port_static_add_link_training_get_f link_training_get;
    /**
     * get general info table about table (for example key size)link_training info
     */
    dnxc_data_table_info_get_f link_training_info_get;
    /**
     * get table ext_stat_link_training entry 
     */
    dnx_data_port_static_add_ext_stat_link_training_get_f ext_stat_link_training_get;
    /**
     * get general info table about table (for example key size)ext_stat_link_training info
     */
    dnxc_data_table_info_get_f ext_stat_link_training_info_get;
    /**
     * get table fec_type entry 
     */
    dnx_data_port_static_add_fec_type_get_f fec_type_get;
    /**
     * get general info table about table (for example key size)fec_type info
     */
    dnxc_data_table_info_get_f fec_type_info_get;
    /**
     * get table serdes_lane_config entry 
     */
    dnx_data_port_static_add_serdes_lane_config_get_f serdes_lane_config_get;
    /**
     * get general info table about table (for example key size)serdes_lane_config info
     */
    dnxc_data_table_info_get_f serdes_lane_config_info_get;
    /**
     * get table serdes_tx_taps entry 
     */
    dnx_data_port_static_add_serdes_tx_taps_get_f serdes_tx_taps_get;
    /**
     * get general info table about table (for example key size)serdes_tx_taps info
     */
    dnxc_data_table_info_get_f serdes_tx_taps_info_get;
    /**
     * get table ext_stat_global_serdes_tx_taps entry 
     */
    dnx_data_port_static_add_ext_stat_global_serdes_tx_taps_get_f ext_stat_global_serdes_tx_taps_get;
    /**
     * get general info table about table (for example key size)ext_stat_global_serdes_tx_taps info
     */
    dnxc_data_table_info_get_f ext_stat_global_serdes_tx_taps_info_get;
    /**
     * get table ext_stat_lane_serdes_tx_taps entry 
     */
    dnx_data_port_static_add_ext_stat_lane_serdes_tx_taps_get_f ext_stat_lane_serdes_tx_taps_get;
    /**
     * get general info table about table (for example key size)ext_stat_lane_serdes_tx_taps info
     */
    dnxc_data_table_info_get_f ext_stat_lane_serdes_tx_taps_info_get;
    /**
     * get table tx_pam4_precoder entry 
     */
    dnx_data_port_static_add_tx_pam4_precoder_get_f tx_pam4_precoder_get;
    /**
     * get general info table about table (for example key size)tx_pam4_precoder info
     */
    dnxc_data_table_info_get_f tx_pam4_precoder_info_get;
    /**
     * get table lp_tx_precoder entry 
     */
    dnx_data_port_static_add_lp_tx_precoder_get_f lp_tx_precoder_get;
    /**
     * get general info table about table (for example key size)lp_tx_precoder info
     */
    dnxc_data_table_info_get_f lp_tx_precoder_info_get;
    /**
     * get table fabric_quad_info entry 
     */
    dnx_data_port_static_add_fabric_quad_info_get_f fabric_quad_info_get;
    /**
     * get general info table about table (for example key size)fabric_quad_info info
     */
    dnxc_data_table_info_get_f fabric_quad_info_info_get;
    /**
     * get table header_type entry 
     */
    dnx_data_port_static_add_header_type_get_f header_type_get;
    /**
     * get general info table about table (for example key size)header_type info
     */
    dnxc_data_table_info_get_f header_type_info_get;
    /**
     * get table erp_exist entry 
     */
    dnx_data_port_static_add_erp_exist_get_f erp_exist_get;
    /**
     * get general info table about table (for example key size)erp_exist info
     */
    dnxc_data_table_info_get_f erp_exist_info_get;
    /**
     * get table base_flexe_instance entry 
     */
    dnx_data_port_static_add_base_flexe_instance_get_f base_flexe_instance_get;
    /**
     * get general info table about table (for example key size)base_flexe_instance info
     */
    dnxc_data_table_info_get_f base_flexe_instance_info_get;
} dnx_data_if_port_static_add_t;

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL:
 * general ports data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule general table prt_configuration
 * Table info:
 * prt configuration information
 */
typedef struct
{
    /**
     * prt recycle profile
     */
    int prt_recycle_profile;
    /**
     * port termination ptc profile
     */
    int port_termination_ptc_profile;
    /**
     * prt qual mode
     */
    int prt_qual_mode;
    /**
     * prt layer offset
     */
    int layer_offset;
    /**
     * prt context select
     */
    int context_select;
    /**
     * prt kbr valid bitmap 4
     */
    int kbr_valid_bitmap_4;
    /**
     * prt kbr valid bitmap 3
     */
    int kbr_valid_bitmap_3;
    /**
     * prt kbr valid bitmap 2
     */
    int kbr_valid_bitmap_2;
    /**
     * prt kbr valid bitmap 1
     */
    int kbr_valid_bitmap_1;
    /**
     * prt kbr valid bitmap 0
     */
    int kbr_valid_bitmap_0;
    /**
     * prt ffc 5 offset
     */
    int ffc_5_offset;
    /**
     * prt ffc 5 width
     */
    int ffc_5_width;
    /**
     * prt ffc 5 input offset
     */
    int ffc_5_input_offset;
    /**
     * prt ffc 4 offset
     */
    int ffc_4_offset;
    /**
     * prt ffc 4 width
     */
    int ffc_4_width;
    /**
     * prt ffc 4 input offset
     */
    int ffc_4_input_offset;
    /**
     * prt ffc 3 offset
     */
    int ffc_3_offset;
    /**
     * prt ffc 3 width
     */
    int ffc_3_width;
    /**
     * prt ffc 3 input offset
     */
    int ffc_3_input_offset;
    /**
     * prt ffc 2 offset
     */
    int ffc_2_offset;
    /**
     * prt ffc 2 width
     */
    int ffc_2_width;
    /**
     * prt ffc 2 input offset
     */
    int ffc_2_input_offset;
    /**
     * prt ffc 1 offset
     */
    int ffc_1_offset;
    /**
     * prt ffc 1 width
     */
    int ffc_1_width;
    /**
     * prt ffc 1 input offset
     */
    int ffc_1_input_offset;
    /**
     * prt ffc 0 offset
     */
    int ffc_0_offset;
    /**
     * prt ffc 0 width
     */
    int ffc_0_width;
    /**
     * prt ffc 0 input offset
     */
    int ffc_0_input_offset;
    /**
     * src system port prt mode
     */
    int src_sys_port_prt_mode;
    /**
     * pp port enable
     */
    int pp_port_en;
    /**
     * tcam mode full enable
     */
    int tcam_mode_full_en;
} dnx_data_port_general_prt_configuration_t;

/**
 * \brief Holds values of submodule general table first_header_size
 * Table info:
 * size of the first header that should be skipped
 */
typedef struct
{
    /**
     * size of the first header that should be skipped
     */
    int first_header_size;
} dnx_data_port_general_first_header_size_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * should pormod PLL restriction be honored
     */
    dnx_data_port_general_unrestricted_portmod_pll,
    /**
     * can portmod speed be used when port is not enabled
     */
    dnx_data_port_general_use_portmod_speed_when_not_enabled,

    /**
     * Must be last one!
     */
    _dnx_data_port_general_feature_nof
} dnx_data_port_general_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_port_general_feature_get_f) (
    int unit,
    dnx_data_port_general_feature_e feature);

/**
 * \brief returns define data of erp_pp_dsp
 * Module - 'port', Submodule - 'general', data - 'erp_pp_dsp'
 * pp dsp reserved for ERP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     erp_pp_dsp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_erp_pp_dsp_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_channels
 * Module - 'port', Submodule - 'general', data - 'max_nof_channels'
 * max nof channel in an interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_max_nof_channels_get_f) (
    int unit);

/**
 * \brief returns define data of fabric_phys_offset
 * Module - 'port', Submodule - 'general', data - 'fabric_phys_offset'
 * Offset for physical fabric ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_phys_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_fabric_phys_offset_get_f) (
    int unit);

/**
 * \brief returns define data of pp_dsp_size
 * Module - 'port', Submodule - 'general', data - 'pp_dsp_size'
 * define the size of the pp dsp (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pp_dsp_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_pp_dsp_size_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_vlan_domain_size
 * Module - 'port', Submodule - 'general', data - 'ingress_vlan_domain_size'
 * define the size of the ingress vlan domain (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_vlan_domain_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_ingress_vlan_domain_size_get_f) (
    int unit);

/**
 * \brief returns define data of vlan_domain_size
 * Module - 'port', Submodule - 'general', data - 'vlan_domain_size'
 * define the max size of vlan domain (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vlan_domain_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_vlan_domain_size_get_f) (
    int unit);

/**
 * \brief returns define data of ffc_instruction_size
 * Module - 'port', Submodule - 'general', data - 'ffc_instruction_size'
 * define the size of the ffc instruction (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ffc_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_ffc_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_first_header_size_to_skip
 * Module - 'port', Submodule - 'general', data - 'max_first_header_size_to_skip'
 * max number of bytes that can be skipped
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_first_header_size_to_skip - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_max_first_header_size_to_skip_get_f) (
    int unit);

/**
 * \brief returns define data of prt_ffc_width_start_offset
 * Module - 'port', Submodule - 'general', data - 'prt_ffc_width_start_offset'
 * The offset of ffc width in the PRT FFC builder
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_ffc_width_start_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_prt_ffc_width_start_offset_get_f) (
    int unit);

/**
 * \brief returns define data of prt_ffc_start_input_offset
 * Module - 'port', Submodule - 'general', data - 'prt_ffc_start_input_offset'
 * The offset of ffc input offset in the PRT FFC builder
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_ffc_start_input_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_prt_ffc_start_input_offset_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_pp_dsp_per_fap_id
 * Module - 'port', Submodule - 'general', data - 'nof_pp_dsp_per_fap_id'
 * nof pp dsp per fap id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pp_dsp_per_fap_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_nof_pp_dsp_per_fap_id_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_ptc
 * Module - 'port', Submodule - 'general', data - 'nof_ptc'
 * nof port termination contexts (PTC) per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ptc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_nof_ptc_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_out_tm_ports
 * Module - 'port', Submodule - 'general', data - 'nof_out_tm_ports'
 * nof out tm ports per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_tm_ports - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_nof_out_tm_ports_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_pp_dsp
 * Module - 'port', Submodule - 'general', data - 'nof_pp_dsp'
 * nof pp dsp per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pp_dsp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_nof_pp_dsp_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_pp_ports
 * Module - 'port', Submodule - 'general', data - 'nof_pp_ports'
 * nof pp ports per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pp_ports - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_nof_pp_ports_get_f) (
    int unit);

/**
 * \brief returns numeric data of reserved_pp_dsp
 * Module - 'port', Submodule - 'general', data - 'reserved_pp_dsp'
 * PP DSP reserved for redirection of returned credits in LAG SCH
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved_pp_dsp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_reserved_pp_dsp_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_vlan_membership_if
 * Module - 'port', Submodule - 'general', data - 'nof_vlan_membership_if'
 * number of vlan_membership_if
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vlan_membership_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_nof_vlan_membership_if_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_vlan_membership_if
 * Module - 'port', Submodule - 'general', data - 'max_vlan_membership_if'
 * max value of vlan_membership_if
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_vlan_membership_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_max_vlan_membership_if_get_f) (
    int unit);

/**
 * \brief returns numeric data of fabric_port_base
 * Module - 'port', Submodule - 'general', data - 'fabric_port_base'
 * first fabric logical port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_port_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_fabric_port_base_get_f) (
    int unit);

/**
 * \brief returns numeric data of pp_port_bits_size
 * Module - 'port', Submodule - 'general', data - 'pp_port_bits_size'
 * pp port size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pp_port_bits_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_pp_port_bits_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_port_bits_in_pp_bus
 * Module - 'port', Submodule - 'general', data - 'nof_port_bits_in_pp_bus'
 * nof port bits in PP bus
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_bits_in_pp_bus - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_nof_port_bits_in_pp_bus_get_f) (
    int unit);

/**
 * \brief returns numeric data of prt_configuration_ptch2_default_index
 * Module - 'port', Submodule - 'general', data - 'prt_configuration_ptch2_default_index'
 * index of ptch2 default configuration in prt_configuration table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_configuration_ptch2_default_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_prt_configuration_ptch2_default_index_get_f) (
    int unit);

/**
 * \brief returns numeric data of prt_configuration_ptch1_default_index
 * Module - 'port', Submodule - 'general', data - 'prt_configuration_ptch1_default_index'
 * index of ptch1 default configuration in prt_configuration table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_configuration_ptch1_default_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_prt_configuration_ptch1_default_index_get_f) (
    int unit);

/**
 * \brief returns numeric data of prt_configuration_eth_default_index
 * Module - 'port', Submodule - 'general', data - 'prt_configuration_eth_default_index'
 * index of eth default configuration in prt_configuration table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     prt_configuration_eth_default_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_general_prt_configuration_eth_default_index_get_f) (
    int unit);

/**
 * \brief get table prt_configuration entry 
 * prt configuration information
 * 
 * \param [in] unit - unit #
 * \param [in] index - arbitrary index
 * 
 * \return
 *     prt_configuration - returns the relevant entry values grouped in struct - see dnx_data_port_general_prt_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_general_prt_configuration_t *(
    *dnx_data_port_general_prt_configuration_get_f) (
    int unit,
    int index);

/**
 * \brief get table first_header_size entry 
 * size of the first header that should be skipped
 * 
 * \param [in] unit - unit #
 * \param [in] port - logical port
 * 
 * \return
 *     first_header_size - returns the relevant entry values grouped in struct - see dnx_data_port_general_first_header_size_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_general_first_header_size_t *(
    *dnx_data_port_general_first_header_size_get_f) (
    int unit,
    int port);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_PORT - GENERAL:
 * {
 */
/**
 * \brief Interface for port general data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_port_general_feature_get_f feature_get;
    /**
     * returns define data of erp_pp_dsp
     */
    dnx_data_port_general_erp_pp_dsp_get_f erp_pp_dsp_get;
    /**
     * returns define data of max_nof_channels
     */
    dnx_data_port_general_max_nof_channels_get_f max_nof_channels_get;
    /**
     * returns define data of fabric_phys_offset
     */
    dnx_data_port_general_fabric_phys_offset_get_f fabric_phys_offset_get;
    /**
     * returns define data of pp_dsp_size
     */
    dnx_data_port_general_pp_dsp_size_get_f pp_dsp_size_get;
    /**
     * returns define data of ingress_vlan_domain_size
     */
    dnx_data_port_general_ingress_vlan_domain_size_get_f ingress_vlan_domain_size_get;
    /**
     * returns define data of vlan_domain_size
     */
    dnx_data_port_general_vlan_domain_size_get_f vlan_domain_size_get;
    /**
     * returns define data of ffc_instruction_size
     */
    dnx_data_port_general_ffc_instruction_size_get_f ffc_instruction_size_get;
    /**
     * returns define data of max_first_header_size_to_skip
     */
    dnx_data_port_general_max_first_header_size_to_skip_get_f max_first_header_size_to_skip_get;
    /**
     * returns define data of prt_ffc_width_start_offset
     */
    dnx_data_port_general_prt_ffc_width_start_offset_get_f prt_ffc_width_start_offset_get;
    /**
     * returns define data of prt_ffc_start_input_offset
     */
    dnx_data_port_general_prt_ffc_start_input_offset_get_f prt_ffc_start_input_offset_get;
    /**
     * returns numeric data of nof_pp_dsp_per_fap_id
     */
    dnx_data_port_general_nof_pp_dsp_per_fap_id_get_f nof_pp_dsp_per_fap_id_get;
    /**
     * returns numeric data of nof_ptc
     */
    dnx_data_port_general_nof_ptc_get_f nof_ptc_get;
    /**
     * returns numeric data of nof_out_tm_ports
     */
    dnx_data_port_general_nof_out_tm_ports_get_f nof_out_tm_ports_get;
    /**
     * returns numeric data of nof_pp_dsp
     */
    dnx_data_port_general_nof_pp_dsp_get_f nof_pp_dsp_get;
    /**
     * returns numeric data of nof_pp_ports
     */
    dnx_data_port_general_nof_pp_ports_get_f nof_pp_ports_get;
    /**
     * returns numeric data of reserved_pp_dsp
     */
    dnx_data_port_general_reserved_pp_dsp_get_f reserved_pp_dsp_get;
    /**
     * returns numeric data of nof_vlan_membership_if
     */
    dnx_data_port_general_nof_vlan_membership_if_get_f nof_vlan_membership_if_get;
    /**
     * returns numeric data of max_vlan_membership_if
     */
    dnx_data_port_general_max_vlan_membership_if_get_f max_vlan_membership_if_get;
    /**
     * returns numeric data of fabric_port_base
     */
    dnx_data_port_general_fabric_port_base_get_f fabric_port_base_get;
    /**
     * returns numeric data of pp_port_bits_size
     */
    dnx_data_port_general_pp_port_bits_size_get_f pp_port_bits_size_get;
    /**
     * returns numeric data of nof_port_bits_in_pp_bus
     */
    dnx_data_port_general_nof_port_bits_in_pp_bus_get_f nof_port_bits_in_pp_bus_get;
    /**
     * returns numeric data of prt_configuration_ptch2_default_index
     */
    dnx_data_port_general_prt_configuration_ptch2_default_index_get_f prt_configuration_ptch2_default_index_get;
    /**
     * returns numeric data of prt_configuration_ptch1_default_index
     */
    dnx_data_port_general_prt_configuration_ptch1_default_index_get_f prt_configuration_ptch1_default_index_get;
    /**
     * returns numeric data of prt_configuration_eth_default_index
     */
    dnx_data_port_general_prt_configuration_eth_default_index_get_f prt_configuration_eth_default_index_get;
    /**
     * get table prt_configuration entry 
     */
    dnx_data_port_general_prt_configuration_get_f prt_configuration_get;
    /**
     * get general info table about table (for example key size)prt_configuration info
     */
    dnxc_data_table_info_get_f prt_configuration_info_get;
    /**
     * get table first_header_size entry 
     */
    dnx_data_port_general_first_header_size_get_f first_header_size_get;
    /**
     * get general info table about table (for example key size)first_header_size info
     */
    dnxc_data_table_info_get_f first_header_size_info_get;
} dnx_data_if_port_general_t;

/*
 * }
 */

/*
 * SUBMODULE  - EGRESS:
 * egress related data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_port_egress_feature_nof
} dnx_data_port_egress_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_port_egress_feature_get_f) (
    int unit,
    dnx_data_port_egress_feature_e feature);

/**
 * \brief returns define data of nof_ifs
 * Module - 'port', Submodule - 'egress', data - 'nof_ifs'
 * nof egress intrfaces per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_port_egress_nof_ifs_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_PORT - EGRESS:
 * {
 */
/**
 * \brief Interface for port egress data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_port_egress_feature_get_f feature_get;
    /**
     * returns define data of nof_ifs
     */
    dnx_data_port_egress_nof_ifs_get_f nof_ifs_get;
} dnx_data_if_port_egress_t;

/*
 * }
 */

/*
 * SUBMODULE  - IMB:
 * IMB related data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule imb table imb_type_info
 * Table info:
 * Information per IMB type
 */
typedef struct
{
    /**
     * Number of PMs in IMB type
     */
    uint32 nof_pms;
    /**
     * Number of lanes in IMB type
     */
    uint32 nof_lanes;
    /**
     * Number of lanes in PM in IMB type
     */
    uint32 nof_lanes_in_pm;
    /**
     * Number of memory entries in IMB type
     */
    uint32 nof_memory_entries;
    /**
     * Rate per RMC weight bit in IMB type
     */
    uint32 rate_per_rmc_bit;
} dnx_data_port_imb_imb_type_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_port_imb_feature_nof
} dnx_data_port_imb_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_port_imb_feature_get_f) (
    int unit,
    dnx_data_port_imb_feature_e feature);

/**
 * \brief get table imb_type_info entry 
 * Information per IMB type
 * 
 * \param [in] unit - unit #
 * \param [in] type - IMB type
 * 
 * \return
 *     imb_type_info - returns the relevant entry values grouped in struct - see dnx_data_port_imb_imb_type_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_port_imb_imb_type_info_t *(
    *dnx_data_port_imb_imb_type_info_get_f) (
    int unit,
    int type);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_PORT - IMB:
 * {
 */
/**
 * \brief Interface for port imb data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_port_imb_feature_get_f feature_get;
    /**
     * get table imb_type_info entry 
     */
    dnx_data_port_imb_imb_type_info_get_f imb_type_info_get;
    /**
     * get general info table about table (for example key size)imb_type_info info
     */
    dnxc_data_table_info_get_f imb_type_info_info_get;
} dnx_data_if_port_imb_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_PORT:
 * {
 */
/**
 * \brief Interface for port data
 */
typedef struct
{
    /**
     * Interface for port static_add data
     */
    dnx_data_if_port_static_add_t static_add;
    /**
     * Interface for port general data
     */
    dnx_data_if_port_general_t general;
    /**
     * Interface for port egress data
     */
    dnx_data_if_port_egress_t egress;
    /**
     * Interface for port imb data
     */
    dnx_data_if_port_imb_t imb;
} dnx_data_if_port_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_port_t dnx_data_port;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_PORT_H_*/
/* *INDENT-ON* */
