/** \file dnx_data_internal_lif.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_INTERNAL_LIF_H_
/*{*/
#define _DNX_DATA_INTERNAL_LIF_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_lif.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_lif_submodule_global_lif,
    dnx_data_lif_submodule_in_lif,
    dnx_data_lif_submodule_out_lif,
    dnx_data_lif_submodule_lif_table_manager,
    dnx_data_lif_submodule_feature,

    /**
     * Must be last one!
     */
    _dnx_data_lif_submodule_nof
} dnx_data_lif_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GLOBAL_LIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_global_lif_feature_get(
    int unit,
    dnx_data_lif_global_lif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_global_lif_define_use_mdb_size,
    dnx_data_lif_global_lif_define_glem_rif_optimization_enabled,
    dnx_data_lif_global_lif_define_null_lif,
    dnx_data_lif_global_lif_define_nof_global_in_lifs,
    dnx_data_lif_global_lif_define_nof_global_out_lifs,
    dnx_data_lif_global_lif_define_egress_in_lif_null_value,
    dnx_data_lif_global_lif_define_egress_out_lif_null_value,
    dnx_data_lif_global_lif_define_nof_global_l2_gport_lifs,
    dnx_data_lif_global_lif_define_global_lif_bta_max_val,
    dnx_data_lif_global_lif_define_global_lif_grain_size,

    /**
     * Must be last one!
     */
    _dnx_data_lif_global_lif_define_nof
} dnx_data_lif_global_lif_define_e;

/* Get Data */
/**
 * \brief returns define data of use_mdb_size
 * Module - 'lif', Submodule - 'global_lif', data - 'use_mdb_size'
 * Some lif sizes are not taken from dnx data, but from the mdb. Use this flag to indicate if it should be used, or just use default minimal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     use_mdb_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_use_mdb_size_get(
    int unit);

/**
 * \brief returns define data of glem_rif_optimization_enabled
 * Module - 'lif', Submodule - 'global_lif', data - 'glem_rif_optimization_enabled'
 * Amount of out RIFs one GLEM entry can hold for optimized GLEM usage is 4.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_rif_optimization_enabled - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_glem_rif_optimization_enabled_get(
    int unit);

/**
 * \brief returns define data of null_lif
 * Module - 'lif', Submodule - 'global_lif', data - 'null_lif'
 * ERPP GLEM trap requires NULL LIF to be added to GLEM by default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     null_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_null_lif_get(
    int unit);

/**
 * \brief returns numeric data of nof_global_in_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_in_lifs'
 * Number of in global lifs in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_in_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_nof_global_in_lifs_get(
    int unit);

/**
 * \brief returns numeric data of nof_global_out_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_out_lifs'
 * Number of out global lifs in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_out_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_nof_global_out_lifs_get(
    int unit);

/**
 * \brief returns numeric data of egress_in_lif_null_value
 * Module - 'lif', Submodule - 'global_lif', data - 'egress_in_lif_null_value'
 * IN_LIF null value in egress stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_in_lif_null_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_egress_in_lif_null_value_get(
    int unit);

/**
 * \brief returns numeric data of egress_out_lif_null_value
 * Module - 'lif', Submodule - 'global_lif', data - 'egress_out_lif_null_value'
 * OUT_LIF null value in egress stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_out_lif_null_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_egress_out_lif_null_value_get(
    int unit);

/**
 * \brief returns numeric data of nof_global_l2_gport_lifs
 * Module - 'lif', Submodule - 'global_lif', data - 'nof_global_l2_gport_lifs'
 * The mpls and vlan ports don't have enough bits to support the full global lif address. Their number is limited by this value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_global_l2_gport_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_nof_global_l2_gport_lifs_get(
    int unit);

/**
 * \brief returns numeric data of global_lif_bta_max_val
 * Module - 'lif', Submodule - 'global_lif', data - 'global_lif_bta_max_val'
 * esitmated byte to remove per global LIF, if 0 means that device is not supporting bta
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_lif_bta_max_val - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_global_lif_bta_max_val_get(
    int unit);

/**
 * \brief returns numeric data of global_lif_grain_size
 * Module - 'lif', Submodule - 'global_lif', data - 'global_lif_grain_size'
 * Bank size, all global lifs are divided to banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_lif_grain_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_global_lif_global_lif_grain_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_global_lif_table_nof
} dnx_data_lif_global_lif_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE IN_LIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_in_lif_feature_get(
    int unit,
    dnx_data_lif_in_lif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_in_lif_define_inlif_index_bit_size,
    dnx_data_lif_in_lif_define_inlif_minimum_index_size,
    dnx_data_lif_in_lif_define_inlif_resource_tag_size,
    dnx_data_lif_in_lif_define_nof_in_lif_profiles,
    dnx_data_lif_in_lif_define_nof_used_in_lif_profile_bits,
    dnx_data_lif_in_lif_define_nof_used_eth_rif_profile_bits,
    dnx_data_lif_in_lif_define_nof_in_lif_incoming_orientation,
    dnx_data_lif_in_lif_define_nof_eth_rif_profiles,
    dnx_data_lif_in_lif_define_nof_da_not_found_destination_profiles,
    dnx_data_lif_in_lif_define_default_da_not_found_destination_profile,
    dnx_data_lif_in_lif_define_drop_in_lif,
    dnx_data_lif_in_lif_define_mc_bridge_fallback_per_lif_profile,
    dnx_data_lif_in_lif_define_max_number_of_orientation_bits_iop_mode,
    dnx_data_lif_in_lif_define_max_number_of_egress_lif_profile_bits_iop_mode,
    dnx_data_lif_in_lif_define_in_lif_profile_pmf_reserved_start_bit,
    dnx_data_lif_in_lif_define_eth_rif_profile_pmf_reserved_start_bit,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_indexed_mode,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_orientation,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_inner_dp,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_policer_outer_dp,
    dnx_data_lif_in_lif_define_in_lif_profile_allocate_same_interface_mode,

    /**
     * Must be last one!
     */
    _dnx_data_lif_in_lif_define_nof
} dnx_data_lif_in_lif_define_e;

/* Get Data */
/**
 * \brief returns define data of inlif_index_bit_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_index_bit_size'
 * This is the size of a single index in the inlif table. Divide the entry bit size by this to get its size in indexes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_index_bit_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_inlif_index_bit_size_get(
    int unit);

/**
 * \brief returns define data of inlif_minimum_index_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_minimum_index_size'
 * The minimum size in indexes of an inlif entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_minimum_index_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_inlif_minimum_index_size_get(
    int unit);

/**
 * \brief returns define data of inlif_resource_tag_size
 * Module - 'lif', Submodule - 'in_lif', data - 'inlif_resource_tag_size'
 * The size of the inlif resource's n-packs. The packs are used to prevent fragmentation by assigning each pack a fixed entry size. The pack should be the least common denominator of every possible entry side. See the SDD for full description.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     inlif_resource_tag_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_inlif_resource_tag_size_get(
    int unit);

/**
 * \brief returns define data of nof_in_lif_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_in_lif_profiles'
 * Number of possible in_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_in_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_in_lif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_used_in_lif_profile_bits
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_used_in_lif_profile_bits'
 * Number of used in_lif_profile bits out of 8.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_used_in_lif_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_used_in_lif_profile_bits_get(
    int unit);

/**
 * \brief returns define data of nof_used_eth_rif_profile_bits
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_used_eth_rif_profile_bits'
 * Number of used eth_rif_profile bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_used_eth_rif_profile_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_used_eth_rif_profile_bits_get(
    int unit);

/**
 * \brief returns define data of nof_in_lif_incoming_orientation
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_in_lif_incoming_orientation'
 * Number of possible in_lif profile incoming orientation groups.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_in_lif_incoming_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_in_lif_incoming_orientation_get(
    int unit);

/**
 * \brief returns define data of nof_eth_rif_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_eth_rif_profiles'
 * Number of possible eth_rif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_eth_rif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_eth_rif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_da_not_found_destination_profiles
 * Module - 'lif', Submodule - 'in_lif', data - 'nof_da_not_found_destination_profiles'
 * Number of da_not_found_destination profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_da_not_found_destination_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_nof_da_not_found_destination_profiles_get(
    int unit);

/**
 * \brief returns define data of default_da_not_found_destination_profile
 * Module - 'lif', Submodule - 'in_lif', data - 'default_da_not_found_destination_profile'
 * Default da_not_found_destination profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_da_not_found_destination_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_default_da_not_found_destination_profile_get(
    int unit);

/**
 * \brief returns define data of drop_in_lif
 * Module - 'lif', Submodule - 'in_lif', data - 'drop_in_lif'
 * local in_lif id performing trap with drop action.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     drop_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_drop_in_lif_get(
    int unit);

/**
 * \brief returns define data of mc_bridge_fallback_per_lif_profile
 * Module - 'lif', Submodule - 'in_lif', data - 'mc_bridge_fallback_per_lif_profile'
 * Enable/Disable the MC bridge fallback functionality based on LIF profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mc_bridge_fallback_per_lif_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_mc_bridge_fallback_per_lif_profile_get(
    int unit);

/**
 * \brief returns define data of max_number_of_orientation_bits_iop_mode
 * Module - 'lif', Submodule - 'in_lif', data - 'max_number_of_orientation_bits_iop_mode'
 * Max number of orientation bits in IOP mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_number_of_orientation_bits_iop_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_max_number_of_orientation_bits_iop_mode_get(
    int unit);

/**
 * \brief returns define data of max_number_of_egress_lif_profile_bits_iop_mode
 * Module - 'lif', Submodule - 'in_lif', data - 'max_number_of_egress_lif_profile_bits_iop_mode'
 * Max number of egress lif_profile bits in IOP mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_number_of_egress_lif_profile_bits_iop_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_max_number_of_egress_lif_profile_bits_iop_mode_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_pmf_reserved_start_bit
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_pmf_reserved_start_bit'
 * The first bit of the PMF reserved part of the in lif profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_pmf_reserved_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_pmf_reserved_start_bit_get(
    int unit);

/**
 * \brief returns numeric data of eth_rif_profile_pmf_reserved_start_bit
 * Module - 'lif', Submodule - 'in_lif', data - 'eth_rif_profile_pmf_reserved_start_bit'
 * The first bit of the PMF reserved part of the ETH RIF profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     eth_rif_profile_pmf_reserved_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_eth_rif_profile_pmf_reserved_start_bit_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_indexed_mode
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_indexed_mode'
 * number of values needed for property indexed_mode in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_indexed_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_indexed_mode_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_orientation
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_orientation'
 * number of values needed for egress property in_lif_orientation in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_orientation_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_policer_inner_dp
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_policer_inner_dp'
 * number of values needed for egress property ive_inner_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_policer_inner_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_policer_inner_dp_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_policer_outer_dp
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_policer_outer_dp'
 * number of values needed for egress property ive_outer_qos_dp_profile in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_policer_outer_dp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_policer_outer_dp_get(
    int unit);

/**
 * \brief returns numeric data of in_lif_profile_allocate_same_interface_mode
 * Module - 'lif', Submodule - 'in_lif', data - 'in_lif_profile_allocate_same_interface_mode'
 * number of values needed for egress property in_lif_profile_allocate_same_interface_mode in in_lif_profile.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_lif_profile_allocate_same_interface_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_in_lif_in_lif_profile_allocate_same_interface_mode_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_in_lif_table_nof
} dnx_data_lif_in_lif_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE OUT_LIF:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_out_lif_feature_get(
    int unit,
    dnx_data_lif_out_lif_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_out_lif_define_nof_out_lif_profiles,
    dnx_data_lif_out_lif_define_nof_erpp_out_lif_profiles,
    dnx_data_lif_out_lif_define_nof_out_lif_outgoing_orientation,
    dnx_data_lif_out_lif_define_outrif_profile_width,
    dnx_data_lif_out_lif_define_glem_result,
    dnx_data_lif_out_lif_define_physical_bank_pointer_size,
    dnx_data_lif_out_lif_define_outlif_eedb_banks_pointer_size,
    dnx_data_lif_out_lif_define_global_outlif_bta_sop_resolution,
    dnx_data_lif_out_lif_define_pmf_outlif_profile_width,
    dnx_data_lif_out_lif_define_pmf_outrif_profile_width,
    dnx_data_lif_out_lif_define_outlif_pointer_size,
    dnx_data_lif_out_lif_define_allocation_bank_size,
    dnx_data_lif_out_lif_define_local_outlif_width,
    dnx_data_lif_out_lif_define_outlif_profile_width,
    dnx_data_lif_out_lif_define_nof_local_out_lifs,
    dnx_data_lif_out_lif_define_physical_bank_size,
    dnx_data_lif_out_lif_define_global_ipv6_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_vxlan_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_mpls_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_srv6_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_sflow_extended_gateway_two_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_sflow_extended_gateway_one_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_sflow_header_sampling_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_sflow_dp_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_gtp_concat_ip_outlif_bta_sop,
    dnx_data_lif_out_lif_define_global_lif_allocation_estimated_encap_size_enable,

    /**
     * Must be last one!
     */
    _dnx_data_lif_out_lif_define_nof
} dnx_data_lif_out_lif_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_out_lif_profiles
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_out_lif_profiles'
 * Number of possible out_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_nof_out_lif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_erpp_out_lif_profiles
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_erpp_out_lif_profiles'
 * Number of possible erpp_out_lif profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_erpp_out_lif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_nof_erpp_out_lif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_out_lif_outgoing_orientation
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_out_lif_outgoing_orientation'
 * Number of possible out_lif profile outgoing orientation groups.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_outgoing_orientation - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_nof_out_lif_outgoing_orientation_get(
    int unit);

/**
 * \brief returns define data of outrif_profile_width
 * Module - 'lif', Submodule - 'out_lif', data - 'outrif_profile_width'
 * The number of bits in the outrif profile from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outrif_profile_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_outrif_profile_width_get(
    int unit);

/**
 * \brief returns define data of glem_result
 * Module - 'lif', Submodule - 'out_lif', data - 'glem_result'
 * The number of bits in GLEM result.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     glem_result - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_glem_result_get(
    int unit);

/**
 * \brief returns define data of physical_bank_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'physical_bank_pointer_size'
 * How many bits from the outlif pointer are used to indicate the physical bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_bank_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_physical_bank_pointer_size_get(
    int unit);

/**
 * \brief returns define data of outlif_eedb_banks_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_eedb_banks_pointer_size'
 * pointer size used to access eedb banks.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_eedb_banks_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_outlif_eedb_banks_pointer_size_get(
    int unit);

/**
 * \brief returns define data of global_outlif_bta_sop_resolution
 * Module - 'lif', Submodule - 'out_lif', data - 'global_outlif_bta_sop_resolution'
 * global out lif msb bits (by the given resolution), used as key to bytes to add sop table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_outlif_bta_sop_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_outlif_bta_sop_resolution_get(
    int unit);

/**
 * \brief returns define data of pmf_outlif_profile_width
 * Module - 'lif', Submodule - 'out_lif', data - 'pmf_outlif_profile_width'
 * The number of bits in the pmf outlif profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_outlif_profile_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_pmf_outlif_profile_width_get(
    int unit);

/**
 * \brief returns define data of pmf_outrif_profile_width
 * Module - 'lif', Submodule - 'out_lif', data - 'pmf_outrif_profile_width'
 * The number of bits in the pmf outrif profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_outrif_profile_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_pmf_outrif_profile_width_get(
    int unit);

/**
 * \brief returns numeric data of outlif_pointer_size
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_pointer_size'
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_pointer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_outlif_pointer_size_get(
    int unit);

/**
 * \brief returns numeric data of allocation_bank_size
 * Module - 'lif', Submodule - 'out_lif', data - 'allocation_bank_size'
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allocation_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_allocation_bank_size_get(
    int unit);

/**
 * \brief returns numeric data of local_outlif_width
 * Module - 'lif', Submodule - 'out_lif', data - 'local_outlif_width'
 * Size of the outlif bank used by the outlif allocation algorithm.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     local_outlif_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_local_outlif_width_get(
    int unit);

/**
 * \brief returns numeric data of outlif_profile_width
 * Module - 'lif', Submodule - 'out_lif', data - 'outlif_profile_width'
 * The number of bits in the outlif profile from GLEM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_profile_width - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_outlif_profile_width_get(
    int unit);

/**
 * \brief returns numeric data of nof_local_out_lifs
 * Module - 'lif', Submodule - 'out_lif', data - 'nof_local_out_lifs'
 * Number of potential local outlifs in the device. Derived from the pointer size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_local_out_lifs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_nof_local_out_lifs_get(
    int unit);

/**
 * \brief returns numeric data of physical_bank_size
 * Module - 'lif', Submodule - 'out_lif', data - 'physical_bank_size'
 * Size of the outlif bank used by the phase map and mags. Derived from the outlif pointer size and the physical bank pointer size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_physical_bank_size_get(
    int unit);

/**
 * \brief returns numeric data of global_ipv6_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_ipv6_outlif_bta_sop'
 * ipv6 out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_ipv6_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_ipv6_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_vxlan_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_vxlan_outlif_bta_sop'
 * vxlan out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_vxlan_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_vxlan_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_mpls_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_mpls_outlif_bta_sop'
 * mpls out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_mpls_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_mpls_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_srv6_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_srv6_outlif_bta_sop'
 * srv6 out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_srv6_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_srv6_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_sflow_extended_gateway_two_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_sflow_extended_gateway_two_outlif_bta_sop'
 * sflow extended gateway 2 (second pass) out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_sflow_extended_gateway_two_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_sflow_extended_gateway_two_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_sflow_extended_gateway_one_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_sflow_extended_gateway_one_outlif_bta_sop'
 * sflow extended gateway 1 ()first pass) out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_sflow_extended_gateway_one_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_sflow_extended_gateway_one_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_sflow_header_sampling_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_sflow_header_sampling_outlif_bta_sop'
 * sflow header sampling out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_sflow_header_sampling_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_sflow_header_sampling_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_sflow_dp_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_sflow_dp_outlif_bta_sop'
 * sflow DP out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_sflow_dp_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_sflow_dp_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_gtp_concat_ip_outlif_bta_sop
 * Module - 'lif', Submodule - 'out_lif', data - 'global_gtp_concat_ip_outlif_bta_sop'
 * IP+UDP concatenated to GTP. out lif bta sop value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_gtp_concat_ip_outlif_bta_sop - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_gtp_concat_ip_outlif_bta_sop_get(
    int unit);

/**
 * \brief returns numeric data of global_lif_allocation_estimated_encap_size_enable
 * Module - 'lif', Submodule - 'out_lif', data - 'global_lif_allocation_estimated_encap_size_enable'
 * allocated global lif, considering encapsulation bta estimation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     global_lif_allocation_estimated_encap_size_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_out_lif_global_lif_allocation_estimated_encap_size_enable_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnx_data_lif_out_lif_table_logical_to_physical_phase_map,

    /**
     * Must be last one!
     */
    _dnx_data_lif_out_lif_table_nof
} dnx_data_lif_out_lif_table_e;

/* Get Data */
/**
 * \brief get table logical_to_physical_phase_map entry 
 * Map outlif logical phase to physical phase. The reverse mapping is implied from this.
 * 
 * \param [in] unit - unit #
 * \param [in] logical_phase - Logical phase to map.
 * 
 * \return
 *     logical_to_physical_phase_map - returns the relevant entry values grouped in struct - see dnx_data_lif_out_lif_logical_to_physical_phase_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnx_data_lif_out_lif_logical_to_physical_phase_map_t * dnx_data_lif_out_lif_logical_to_physical_phase_map_get(
    int unit,
    int logical_phase);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'lif', Submodule - 'out_lif', table - 'logical_to_physical_phase_map'
 * Map outlif logical phase to physical phase. The reverse mapping is implied from this.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_lif_out_lif_logical_to_physical_phase_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)logical_to_physical_phase_map info
 * Map outlif logical phase to physical phase. The reverse mapping is implied from this.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     logical_to_physical_phase_map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnx_data_lif_out_lif_logical_to_physical_phase_map_info_get(
    int unit);

/*
 * SUBMODULE LIF_TABLE_MANAGER:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_lif_table_manager_feature_get(
    int unit,
    dnx_data_lif_lif_table_manager_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_lif_lif_table_manager_define_max_nof_lif_tables,
    dnx_data_lif_lif_table_manager_define_max_nof_result_types,
    dnx_data_lif_lif_table_manager_define_max_fields_per_result_type,
    dnx_data_lif_lif_table_manager_define_max_fields_per_table,

    /**
     * Must be last one!
     */
    _dnx_data_lif_lif_table_manager_define_nof
} dnx_data_lif_lif_table_manager_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_lif_tables
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_nof_lif_tables'
 * Maximal number of logical lif tables (inlif + outlif)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_lif_tables - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_lif_table_manager_max_nof_lif_tables_get(
    int unit);

/**
 * \brief returns define data of max_nof_result_types
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_nof_result_types'
 * Maximal number of result types in lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_result_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_lif_table_manager_max_nof_result_types_get(
    int unit);

/**
 * \brief returns define data of max_fields_per_result_type
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_fields_per_result_type'
 * Maximal number of fields for one result types in lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fields_per_result_type - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_lif_table_manager_max_fields_per_result_type_get(
    int unit);

/**
 * \brief returns define data of max_fields_per_table
 * Module - 'lif', Submodule - 'lif_table_manager', data - 'max_fields_per_table'
 * Maximal number of fields in a lif table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fields_per_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_lif_lif_table_manager_max_fields_per_table_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_lif_table_manager_table_nof
} dnx_data_lif_lif_table_manager_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FEATURE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_lif_feature_feature_get(
    int unit,
    dnx_data_lif_feature_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_feature_define_nof
} dnx_data_lif_feature_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_lif_feature_table_nof
} dnx_data_lif_feature_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_lif_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_LIF_H_*/
/* *INDENT-ON* */
