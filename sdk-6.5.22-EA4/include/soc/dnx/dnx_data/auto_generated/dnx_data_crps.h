/** \file dnx_data_crps.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_CRPS_H_
/*{*/
#define _DNX_DATA_CRPS_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm/stat.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_crps.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_crps
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_crps_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - ENGINE:
 * counters engine data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule engine table engines_info
 * Table info:
 * size of each counter engine and indication if it is shared with meter
 */
typedef struct
{
    /**
     * number of counters per engine
     */
    int nof_counters;
    /**
     * is engine is memory shared with meter
     */
    int meter_shared;
} dnx_data_crps_engine_engines_info_t;

/**
 * \brief Holds values of submodule engine table source_base
 * Table info:
 * defines the base value for the source which is connected to the engine
 */
typedef struct
{
    /**
     * the base value for the input source, in order to configure CRPS_ENGINE_SOURCE_SELECT field
     */
    int base_val;
} dnx_data_crps_engine_source_base_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is correct address admission supported for both double mode and not double mode?
     */
    dnx_data_crps_engine_valid_address_admission_is_supported,
    /**
     * Is diagnostic presenting last input command towards crps supported?
     */
    dnx_data_crps_engine_last_input_command_is_supported,
    /**
     * Is slim counters format supported
     */
    dnx_data_crps_engine_slim_counters_is_supported,

    /**
     * Must be last one!
     */
    _dnx_data_crps_engine_feature_nof
} dnx_data_crps_engine_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_engine_feature_get_f) (
    int unit,
    dnx_data_crps_engine_feature_e feature);

/**
 * \brief returns define data of nof_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_engines'
 * Number of counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_mid_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_mid_engines'
 * Number of mid counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mid_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_mid_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_engines
 * Module - 'crps', Submodule - 'engine', data - 'nof_big_engines'
 * Number of big counter engines per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_engines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_big_engines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_databases
 * Module - 'crps', Submodule - 'engine', data - 'nof_databases'
 * Number of counter databases per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_databases - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_nof_databases_get_f) (
    int unit);

/**
 * \brief returns define data of data_mapping_table_size
 * Module - 'crps', Submodule - 'engine', data - 'data_mapping_table_size'
 * Number of entries in data mappnig table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_mapping_table_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_data_mapping_table_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_counter_set_size
 * Module - 'crps', Submodule - 'engine', data - 'max_counter_set_size'
 * max size of the counter set
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_counter_set_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_max_counter_set_size_get_f) (
    int unit);

/**
 * \brief returns define data of oam_counter_set_size
 * Module - 'crps', Submodule - 'engine', data - 'oam_counter_set_size'
 * size of the counter set for OAM sources
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_counter_set_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_oam_counter_set_size_get_f) (
    int unit);

/**
 * \brief returns define data of last_address_nof_bits
 * Module - 'crps', Submodule - 'engine', data - 'last_address_nof_bits'
 * number of bits of last address admitted per engine
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     last_address_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_last_address_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of counter_format_nof_bits
 * Module - 'crps', Submodule - 'engine', data - 'counter_format_nof_bits'
 * number of bits to describe the engine counter format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counter_format_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_engine_counter_format_nof_bits_get_f) (
    int unit);

/**
 * \brief get table engines_info entry 
 * size of each counter engine and indication if it is shared with meter
 * 
 * \param [in] unit - unit #
 * \param [in] engine_id - engine id {0..(nof_counter_engines-1)}
 * 
 * \return
 *     engines_info - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_engines_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_engine_engines_info_t *(
    *dnx_data_crps_engine_engines_info_get_f) (
    int unit,
    int engine_id);

/**
 * \brief get table source_base entry 
 * defines the base value for the source which is connected to the engine
 * 
 * \param [in] unit - unit #
 * \param [in] source - source id {according to API enum}
 * 
 * \return
 *     source_base - returns the relevant entry values grouped in struct - see dnx_data_crps_engine_source_base_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_engine_source_base_t *(
    *dnx_data_crps_engine_source_base_get_f) (
    int unit,
    int source);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - ENGINE:
 * {
 */
/**
 * \brief Interface for crps engine data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_engine_feature_get_f feature_get;
    /**
     * returns define data of nof_engines
     */
    dnx_data_crps_engine_nof_engines_get_f nof_engines_get;
    /**
     * returns define data of nof_mid_engines
     */
    dnx_data_crps_engine_nof_mid_engines_get_f nof_mid_engines_get;
    /**
     * returns define data of nof_big_engines
     */
    dnx_data_crps_engine_nof_big_engines_get_f nof_big_engines_get;
    /**
     * returns define data of nof_databases
     */
    dnx_data_crps_engine_nof_databases_get_f nof_databases_get;
    /**
     * returns define data of data_mapping_table_size
     */
    dnx_data_crps_engine_data_mapping_table_size_get_f data_mapping_table_size_get;
    /**
     * returns define data of max_counter_set_size
     */
    dnx_data_crps_engine_max_counter_set_size_get_f max_counter_set_size_get;
    /**
     * returns define data of oam_counter_set_size
     */
    dnx_data_crps_engine_oam_counter_set_size_get_f oam_counter_set_size_get;
    /**
     * returns define data of last_address_nof_bits
     */
    dnx_data_crps_engine_last_address_nof_bits_get_f last_address_nof_bits_get;
    /**
     * returns define data of counter_format_nof_bits
     */
    dnx_data_crps_engine_counter_format_nof_bits_get_f counter_format_nof_bits_get;
    /**
     * get table engines_info entry 
     */
    dnx_data_crps_engine_engines_info_get_f engines_info_get;
    /**
     * get general info table about table (for example key size)engines_info info
     */
    dnxc_data_table_info_get_f engines_info_info_get;
    /**
     * get table source_base entry 
     */
    dnx_data_crps_engine_source_base_get_f source_base_get;
    /**
     * get general info table about table (for example key size)source_base info
     */
    dnxc_data_table_info_get_f source_base_info_get;
} dnx_data_if_crps_engine_t;

/*
 * }
 */

/*
 * SUBMODULE  - EVICTION:
 * counters eviction parameters
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule eviction table phy_record_format
 * Table info:
 * holds the format of the physical record that is copied by the DMA from CRPS FIFO
 */
typedef struct
{
    /**
     * size 'obj_type' field base on its size
     */
    uint32 obj_type_size;
    /**
     * offset in the record for obj_type field
     */
    uint32 obj_type_offset;
    /**
     * size 'reserved0' field base on its size
     */
    uint32 reserved0_size;
    /**
     * offset in the record for 'reserved0' field
     */
    uint32 reserved0_offset;
    /**
     * 'opcode' type field base on its size
     */
    uint32 opcode_size;
    /**
     * offset in the record for 'opcode' field
     */
    uint32 opcode_offset;
    /**
     * size 'error indication' field base on its size
     */
    uint32 err_ind_size;
    /**
     * offset in the record for 'error indication' field
     */
    uint32 err_ind_offset;
    /**
     * size 'reserved1' field base on its size
     */
    uint32 reserved1_size;
    /**
     * offset in the record for 'reserved1' field
     */
    uint32 reserved1_offset;
    /**
     * size 'core id' field base on its size
     */
    uint32 core_id_size;
    /**
     * offset in the record for 'core id' field
     */
    uint32 core_id_offset;
    /**
     * size 'engine id' field base on its size
     */
    uint32 engine_id_size;
    /**
     * offset in the record for 'engine id' field
     */
    uint32 engine_id_offset;
    /**
     * size 'local counter id' field base on its size
     */
    uint32 local_ctr_id_size;
    /**
     * offset in the record for 'local counter id' field
     */
    uint32 local_ctr_id_offset;
    /**
     * size 'counter value' field base on its size
     */
    uint32 ctr_value_size;
    /**
     * offset in the record for 'counter value' field
     */
    uint32 ctr_value_offset;
} dnx_data_crps_eviction_phy_record_format_t;

/**
 * \brief Holds values of submodule eviction table condional_action_valid
 * Table info:
 * holds which action is valid
 */
typedef struct
{
    /**
     * condional action valid
     */
    uint32 valid;
} dnx_data_crps_eviction_condional_action_valid_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is algorithmic scan mode supported?
     */
    dnx_data_crps_eviction_algorithmic_is_supported,
    /**
     * Is probabilistic scan mode supported?
     */
    dnx_data_crps_eviction_probabilistic_is_supported,
    /**
     * Is conditional action scan is supported
     */
    dnx_data_crps_eviction_conditional_action_is_supported,

    /**
     * Must be last one!
     */
    _dnx_data_crps_eviction_feature_nof
} dnx_data_crps_eviction_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_eviction_feature_get_f) (
    int unit,
    dnx_data_crps_eviction_feature_e feature);

/**
 * \brief returns define data of counters_fifo_depth
 * Module - 'crps', Submodule - 'eviction', data - 'counters_fifo_depth'
 * Indicates the FIFO depth in the host
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     counters_fifo_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_counters_fifo_depth_get_f) (
    int unit);

/**
 * \brief returns define data of nof_counters_fifo
 * Module - 'crps', Submodule - 'eviction', data - 'nof_counters_fifo'
 * Indicates the number of FIFOs available for CRPS (for each core)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_counters_fifo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_nof_counters_fifo_get_f) (
    int unit);

/**
 * \brief returns define data of dma_record_entry_nof_bits
 * Module - 'crps', Submodule - 'eviction', data - 'dma_record_entry_nof_bits'
 * size (in bits) of one record that is copied by the DMA-FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dma_record_entry_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_dma_record_entry_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of packet_and_bytes_packet_size
 * Module - 'crps', Submodule - 'eviction', data - 'packet_and_bytes_packet_size'
 * size (in bits) of the packets, if format is packet and bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     packet_and_bytes_packet_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_packet_and_bytes_packet_size_get_f) (
    int unit);

/**
 * \brief returns define data of bubble_before_request_timeout
 * Module - 'crps', Submodule - 'eviction', data - 'bubble_before_request_timeout'
 * The waiting period in clocks until requesting bubble, if EnginenScanBubbleRequestEnable=1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bubble_before_request_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_bubble_before_request_timeout_get_f) (
    int unit);

/**
 * \brief returns define data of bubble_after_request_timeout
 * Module - 'crps', Submodule - 'eviction', data - 'bubble_after_request_timeout'
 * The waiting period, after bubble reuest before forcing bubble (if force enable)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bubble_after_request_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_bubble_after_request_timeout_get_f) (
    int unit);

/**
 * \brief returns define data of seq_address_nof_bits
 * Module - 'crps', Submodule - 'eviction', data - 'seq_address_nof_bits'
 * nof bit for sequential address (start/end)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     seq_address_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_seq_address_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_crps_network_channels
 * Module - 'crps', Submodule - 'eviction', data - 'nof_crps_network_channels'
 * number of channels from CRPS to the IRE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_crps_network_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_nof_crps_network_channels_get_f) (
    int unit);

/**
 * \brief returns numeric data of bg_thread_enable
 * Module - 'crps', Submodule - 'eviction', data - 'bg_thread_enable'
 * enable/disable counters bg thread operation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bg_thread_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_eviction_bg_thread_enable_get_f) (
    int unit);

/**
 * \brief get table phy_record_format entry 
 * holds the format of the physical record that is copied by the DMA from CRPS FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_record_format - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_phy_record_format_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_eviction_phy_record_format_t *(
    *dnx_data_crps_eviction_phy_record_format_get_f) (
    int unit);

/**
 * \brief get table condional_action_valid entry 
 * holds which action is valid
 * 
 * \param [in] unit - unit #
 * \param [in] action_idx - action idx flag {according to API flags}
 * 
 * \return
 *     condional_action_valid - returns the relevant entry values grouped in struct - see dnx_data_crps_eviction_condional_action_valid_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_eviction_condional_action_valid_t *(
    *dnx_data_crps_eviction_condional_action_valid_get_f) (
    int unit,
    int action_idx);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - EVICTION:
 * {
 */
/**
 * \brief Interface for crps eviction data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_eviction_feature_get_f feature_get;
    /**
     * returns define data of counters_fifo_depth
     */
    dnx_data_crps_eviction_counters_fifo_depth_get_f counters_fifo_depth_get;
    /**
     * returns define data of nof_counters_fifo
     */
    dnx_data_crps_eviction_nof_counters_fifo_get_f nof_counters_fifo_get;
    /**
     * returns define data of dma_record_entry_nof_bits
     */
    dnx_data_crps_eviction_dma_record_entry_nof_bits_get_f dma_record_entry_nof_bits_get;
    /**
     * returns define data of packet_and_bytes_packet_size
     */
    dnx_data_crps_eviction_packet_and_bytes_packet_size_get_f packet_and_bytes_packet_size_get;
    /**
     * returns define data of bubble_before_request_timeout
     */
    dnx_data_crps_eviction_bubble_before_request_timeout_get_f bubble_before_request_timeout_get;
    /**
     * returns define data of bubble_after_request_timeout
     */
    dnx_data_crps_eviction_bubble_after_request_timeout_get_f bubble_after_request_timeout_get;
    /**
     * returns define data of seq_address_nof_bits
     */
    dnx_data_crps_eviction_seq_address_nof_bits_get_f seq_address_nof_bits_get;
    /**
     * returns define data of nof_crps_network_channels
     */
    dnx_data_crps_eviction_nof_crps_network_channels_get_f nof_crps_network_channels_get;
    /**
     * returns numeric data of bg_thread_enable
     */
    dnx_data_crps_eviction_bg_thread_enable_get_f bg_thread_enable_get;
    /**
     * get table phy_record_format entry 
     */
    dnx_data_crps_eviction_phy_record_format_get_f phy_record_format_get;
    /**
     * get general info table about table (for example key size)phy_record_format info
     */
    dnxc_data_table_info_get_f phy_record_format_info_get;
    /**
     * get table condional_action_valid entry 
     */
    dnx_data_crps_eviction_condional_action_valid_get_f condional_action_valid_get;
    /**
     * get general info table about table (for example key size)condional_action_valid info
     */
    dnxc_data_table_info_get_f condional_action_valid_info_get;
} dnx_data_if_crps_eviction_t;

/*
 * }
 */

/*
 * SUBMODULE  - EXPANSION:
 * counters expansion parameters
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule expansion table irpp_types
 * Table info:
 * gather all the field types that construct the irpp metadata
 */
typedef struct
{
    /**
     * valid field types that construct the irpp metadata
     */
    bcm_stat_expansion_types_t valid_types[12];
    /**
     * total size of bits for all fields
     */
    uint32 total_nof_bits;
    /**
     * field offset in the data sent from the source
     */
    uint32 drop_reason_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 disposition_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tc_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp0_valid_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp0_value_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp1_valid_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp1_value_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp2_valid_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp2_value_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 final_dp_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 reject_all_copies_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 metadata_offset;
} dnx_data_crps_expansion_irpp_types_t;

/**
 * \brief Holds values of submodule expansion table itm_types
 * Table info:
 * gather all the field types that construct the itm metadata
 */
typedef struct
{
    /**
     * valid field types that construct the itm metadata
     */
    bcm_stat_expansion_types_t valid_types[6];
    /**
     * total size of bits for all fields
     */
    uint32 total_nof_bits;
    /**
     * field offset in the data sent from the source
     */
    uint32 drop_reason_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 disposition_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tc_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 final_dp_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 last_copy_offset;
} dnx_data_crps_expansion_itm_types_t;

/**
 * \brief Holds values of submodule expansion table itpp_types
 * Table info:
 * gather all the field types that construct the itpp metadata
 */
typedef struct
{
    /**
     * valid field types that construct the itpp metadata
     */
    bcm_stat_expansion_types_t valid_types[6];
    /**
     * total size of bits for all fields
     */
    uint32 total_nof_bits;
    /**
     * field offset in the data sent from the source
     */
    uint32 latency_bin_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tc_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 latency_profile_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 mc_offset;
} dnx_data_crps_expansion_itpp_types_t;

/**
 * \brief Holds values of submodule expansion table erpp_types
 * Table info:
 * gather all the field types that construct the erpp metadata
 */
typedef struct
{
    /**
     * valid field types that construct the erpp metadata
     */
    bcm_stat_expansion_types_t valid_types[9];
    /**
     * total size of bits for all fields
     */
    uint32 total_nof_bits;
    /**
     * field offset in the data sent from the source
     */
    uint32 metadata_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tc_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 mc_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tm_action_type_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 pp_drop_reason_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 pp_discard_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tm_discard_offset;
} dnx_data_crps_expansion_erpp_types_t;

/**
 * \brief Holds values of submodule expansion table etm_types
 * Table info:
 * gather all the field types that construct the etm metadata
 */
typedef struct
{
    /**
     * valid field types that construct the etm metadata
     */
    bcm_stat_expansion_types_t valid_types[7];
    /**
     * total size of bits for all fields
     */
    uint32 total_nof_bits;
    /**
     * field offset in the data sent from the source
     */
    uint32 drop_reason_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tm_discard_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 pp_discard_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 tc_offset;
    /**
     * field offset in the data sent from the source
     */
    uint32 dp_offset;
} dnx_data_crps_expansion_etm_types_t;

/**
 * \brief Holds values of submodule expansion table etpp_types
 * Table info:
 * gather all the field types that construct the etpp metadata
 */
typedef struct
{
    /**
     * valid field types that construct the etpp metadata
     */
    bcm_stat_expansion_types_t valid_types[8];
    /**
     * total size of bits for all fields
     */
    uint32 total_nof_bits;
} dnx_data_crps_expansion_etpp_types_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_crps_expansion_feature_nof
} dnx_data_crps_expansion_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_expansion_feature_get_f) (
    int unit,
    dnx_data_crps_expansion_feature_e feature);

/**
 * \brief returns define data of expansion_size
 * Module - 'crps', Submodule - 'expansion', data - 'expansion_size'
 * define the size of the expansion (in bits)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     expansion_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_expansion_expansion_size_get_f) (
    int unit);

/**
 * \brief get table irpp_types entry 
 * gather all the field types that construct the irpp metadata
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     irpp_types - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_irpp_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_expansion_irpp_types_t *(
    *dnx_data_crps_expansion_irpp_types_get_f) (
    int unit);

/**
 * \brief get table itm_types entry 
 * gather all the field types that construct the itm metadata
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     itm_types - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_itm_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_expansion_itm_types_t *(
    *dnx_data_crps_expansion_itm_types_get_f) (
    int unit);

/**
 * \brief get table itpp_types entry 
 * gather all the field types that construct the itpp metadata
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     itpp_types - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_itpp_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_expansion_itpp_types_t *(
    *dnx_data_crps_expansion_itpp_types_get_f) (
    int unit);

/**
 * \brief get table erpp_types entry 
 * gather all the field types that construct the erpp metadata
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     erpp_types - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_erpp_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_expansion_erpp_types_t *(
    *dnx_data_crps_expansion_erpp_types_get_f) (
    int unit);

/**
 * \brief get table etm_types entry 
 * gather all the field types that construct the etm metadata
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etm_types - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_etm_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_expansion_etm_types_t *(
    *dnx_data_crps_expansion_etm_types_get_f) (
    int unit);

/**
 * \brief get table etpp_types entry 
 * gather all the field types that construct the etpp metadata
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etpp_types - returns the relevant entry values grouped in struct - see dnx_data_crps_expansion_etpp_types_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_expansion_etpp_types_t *(
    *dnx_data_crps_expansion_etpp_types_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - EXPANSION:
 * {
 */
/**
 * \brief Interface for crps expansion data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_expansion_feature_get_f feature_get;
    /**
     * returns define data of expansion_size
     */
    dnx_data_crps_expansion_expansion_size_get_f expansion_size_get;
    /**
     * get table irpp_types entry 
     */
    dnx_data_crps_expansion_irpp_types_get_f irpp_types_get;
    /**
     * get general info table about table (for example key size)irpp_types info
     */
    dnxc_data_table_info_get_f irpp_types_info_get;
    /**
     * get table itm_types entry 
     */
    dnx_data_crps_expansion_itm_types_get_f itm_types_get;
    /**
     * get general info table about table (for example key size)itm_types info
     */
    dnxc_data_table_info_get_f itm_types_info_get;
    /**
     * get table itpp_types entry 
     */
    dnx_data_crps_expansion_itpp_types_get_f itpp_types_get;
    /**
     * get general info table about table (for example key size)itpp_types info
     */
    dnxc_data_table_info_get_f itpp_types_info_get;
    /**
     * get table erpp_types entry 
     */
    dnx_data_crps_expansion_erpp_types_get_f erpp_types_get;
    /**
     * get general info table about table (for example key size)erpp_types info
     */
    dnxc_data_table_info_get_f erpp_types_info_get;
    /**
     * get table etm_types entry 
     */
    dnx_data_crps_expansion_etm_types_get_f etm_types_get;
    /**
     * get general info table about table (for example key size)etm_types info
     */
    dnxc_data_table_info_get_f etm_types_info_get;
    /**
     * get table etpp_types entry 
     */
    dnx_data_crps_expansion_etpp_types_get_f etpp_types_get;
    /**
     * get general info table about table (for example key size)etpp_types info
     */
    dnxc_data_table_info_get_f etpp_types_info_get;
} dnx_data_if_crps_expansion_t;

/*
 * }
 */

/*
 * SUBMODULE  - SRC_INTERFACE:
 * source interface
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule src_interface table command_id
 * Table info:
 * command_id data - possible values per source
 */
typedef struct
{
    /**
     * maximum possible value for command_id for this source
     */
    uint32 size;
    /**
     * the base value - minimum value of the command_id
     */
    uint32 base;
} dnx_data_crps_src_interface_command_id_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_crps_src_interface_feature_nof
} dnx_data_crps_src_interface_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_src_interface_feature_get_f) (
    int unit,
    dnx_data_crps_src_interface_feature_e feature);

/**
 * \brief get table command_id entry 
 * command_id data - possible values per source
 * 
 * \param [in] unit - unit #
 * \param [in] source - interface source
 * 
 * \return
 *     command_id - returns the relevant entry values grouped in struct - see dnx_data_crps_src_interface_command_id_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_crps_src_interface_command_id_t *(
    *dnx_data_crps_src_interface_command_id_get_f) (
    int unit,
    int source);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - SRC_INTERFACE:
 * {
 */
/**
 * \brief Interface for crps src_interface data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_src_interface_feature_get_f feature_get;
    /**
     * get table command_id entry 
     */
    dnx_data_crps_src_interface_command_id_get_f command_id_get;
    /**
     * get general info table about table (for example key size)command_id info
     */
    dnxc_data_table_info_get_f command_id_info_get;
} dnx_data_if_crps_src_interface_t;

/*
 * }
 */

/*
 * SUBMODULE  - LATENCY:
 * latency stat id definitions
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * can latency be measured per pp flow profile
     */
    dnx_data_crps_latency_valid_flow_profile,
    /**
     * can end to end aqm profile be created 
     */
    dnx_data_crps_latency_valid_end_to_end_aqm_profile,
    /**
     * is the probibalistic mark cni/drop mechanism supported (ingress deqeue latency marking)
     */
    dnx_data_crps_latency_probabilistic_drop_mechanism_support,

    /**
     * Must be last one!
     */
    _dnx_data_crps_latency_feature_nof
} dnx_data_crps_latency_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_crps_latency_feature_get_f) (
    int unit,
    dnx_data_crps_latency_feature_e feature);

/**
 * \brief returns define data of etpp_command_id
 * Module - 'crps', Submodule - 'latency', data - 'etpp_command_id'
 * etpp command id that can be used for latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     etpp_command_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_etpp_command_id_get_f) (
    int unit);

/**
 * \brief returns define data of stat_id_port_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_port_offset'
 * offset of the port in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_port_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_stat_id_port_offset_get_f) (
    int unit);

/**
 * \brief returns define data of stat_id_tc_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_tc_offset'
 * offset of the traffic class in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_tc_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_stat_id_tc_offset_get_f) (
    int unit);

/**
 * \brief returns define data of stat_id_multicast_offset
 * Module - 'crps', Submodule - 'latency', data - 'stat_id_multicast_offset'
 * offset of the multicast in the latency stat (flow) id  encoding
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stat_id_multicast_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_crps_latency_stat_id_multicast_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_CRPS - LATENCY:
 * {
 */
/**
 * \brief Interface for crps latency data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_crps_latency_feature_get_f feature_get;
    /**
     * returns define data of etpp_command_id
     */
    dnx_data_crps_latency_etpp_command_id_get_f etpp_command_id_get;
    /**
     * returns define data of stat_id_port_offset
     */
    dnx_data_crps_latency_stat_id_port_offset_get_f stat_id_port_offset_get;
    /**
     * returns define data of stat_id_tc_offset
     */
    dnx_data_crps_latency_stat_id_tc_offset_get_f stat_id_tc_offset_get;
    /**
     * returns define data of stat_id_multicast_offset
     */
    dnx_data_crps_latency_stat_id_multicast_offset_get_f stat_id_multicast_offset_get;
} dnx_data_if_crps_latency_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_CRPS:
 * {
 */
/**
 * \brief Interface for crps data
 */
typedef struct
{
    /**
     * Interface for crps engine data
     */
    dnx_data_if_crps_engine_t engine;
    /**
     * Interface for crps eviction data
     */
    dnx_data_if_crps_eviction_t eviction;
    /**
     * Interface for crps expansion data
     */
    dnx_data_if_crps_expansion_t expansion;
    /**
     * Interface for crps src_interface data
     */
    dnx_data_if_crps_src_interface_t src_interface;
    /**
     * Interface for crps latency data
     */
    dnx_data_if_crps_latency_t latency;
} dnx_data_if_crps_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_crps_t dnx_data_crps;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_CRPS_H_*/
/* *INDENT-ON* */
