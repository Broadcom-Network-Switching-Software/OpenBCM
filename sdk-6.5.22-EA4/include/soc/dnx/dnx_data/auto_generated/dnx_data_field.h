/** \file dnx_data_field.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_FIELD_H_
/*{*/
#define _DNX_DATA_FIELD_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_field.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_field
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_field_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IPMF1:
 * Ingress PMF_1 data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf1_feature_nof
} dnx_data_field_base_ipmf1_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ipmf1_feature_get_f) (
    int unit,
    dnx_data_field_base_ipmf1_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_keys_alloc_for_mdb_dt_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of cs_container_5_selected_bits_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'cs_container_5_selected_bits_size'
 * Number of bits taken from general data for context selection.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cs_container_5_selected_bits_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_cs_container_5_selected_bits_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_contexts'
 * Number of Ingress PMF_A programs (contexts). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_link_profiles
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_link_profiles'
 * Number of profiles assigned to iPMF1 contexts in order to create links between iPMF1 and iPMF2 contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_link_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_link_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of fes_key_select_resolution_in_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_key_select_resolution_in_bits'
 * Number of bits in the 'step' from one 'key select' to the following for EFES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_resolution_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_key_select_resolution_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of fem_condition_ms_bit_min_value
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_condition_ms_bit_min_value'
 * The minumum legal value to be set in bit select for a FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_condition_ms_bit_min_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_programs
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_programs'
 * Total number FEM programs available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_programs_get_f) (
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_key_select'
 * Log2 of number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_key_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_key_select'
 * Number of bits on one 'chunk' of input to FEM. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of fem_key_select_resolution_in_bits
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fem_key_select_resolution_in_bits'
 * Number of bits in the 'step' from one 'key select' to the following for FEM. See dbal_enum_value_field_field_pmf_a_fem_key_select_e. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_key_select_resolution_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of log_nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'log_nof_bits_in_fem_map_data_field'
 * Log2 of number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     log_nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_map_data_field
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_map_data_field'
 * Number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_map_data_field - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_2_15
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_2_15'
 * Number of bits on action value in IPPC_FEM_*_24B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_2_15 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action_fems_0_1
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action_fems_0_1'
 * Number of bits on action value in IPPC_FEM_*_4B_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action_fems_0_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_bits_in_fem_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_condition_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_map_index_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_id
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id'
 * Total number 'FEM id's available. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_id_get_f) (
    int unit);

/**
 * \brief returns define data of num_fems_with_short_action
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_fems_with_short_action'
 * Number of FEMs, starting from 'fem_id=0', which have only 4 bits on action value. The rest have 24 bits on action value. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_fems_with_short_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_num_fems_with_short_action_get_f) (
    int unit);

/**
 * \brief returns define data of num_bits_in_fem_field_select
 * Module - 'field', Submodule - 'base_ipmf1', data - 'num_bits_in_fem_field_select'
 * Number of bits on each of the HW field marked FIELD_SELECT_MAP_*. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_bits_in_fem_field_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_id_per_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_id_per_array'
 * Number FEMes in each FEM array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_array
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_fem_array'
 * Number FEM arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_fem_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_get_f) (
    int unit);

/**
 * \brief returns define data of compare_key_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'compare_key_size'
 * Size of the compare key in the system. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     compare_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_compare_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_l4_ops_ranges_legacy'
 * Number of ranges for L4 Ops legacy. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_l4_ops_ranges_legacy_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ext_l4_ops_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_ext_l4_ops_ranges'
 * Number of ranges for External L4 Ops. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_l4_ops_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_ext_l4_ops_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_pkt_hdr_ranges'
 * Number of ranges for PKT HDR. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf1', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_nof_out_lif_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf1', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_uses_large_exem_get_f) (
    int unit);

/**
 * \brief returns define data of cmp_selection
 * Module - 'field', Submodule - 'base_ipmf1', data - 'cmp_selection'
 * Compare selection for both keys of 2nd compare, See the CMP_SELECTION field in IPPC_PMF_GENERAL register for additional information. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cmp_selection - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_cmp_selection_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to IPPC_PMF_FES_PROGRAMm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_pgm_id_offset_get_f) (
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_ipmf1', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_dir_ext_single_key_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf1', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IPMF1:
 * {
 */
/**
 * \brief Interface for field base_ipmf1 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ipmf1_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ipmf1_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ipmf1_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_keys_alloc_for_mdb_dt
     */
    dnx_data_field_base_ipmf1_nof_keys_alloc_for_mdb_dt_get_f nof_keys_alloc_for_mdb_dt_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_ipmf1_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_ipmf1_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_ipmf1_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_ipmf1_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_base_ipmf1_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_base_ipmf1_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of cs_container_5_selected_bits_size
     */
    dnx_data_field_base_ipmf1_cs_container_5_selected_bits_size_get_f cs_container_5_selected_bits_size_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ipmf1_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_link_profiles
     */
    dnx_data_field_base_ipmf1_nof_link_profiles_get_f nof_link_profiles_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ipmf1_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_base_ipmf1_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_ipmf1_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of fes_key_select_resolution_in_bits
     */
    dnx_data_field_base_ipmf1_fes_key_select_resolution_in_bits_get_f fes_key_select_resolution_in_bits_get;
    /**
     * returns define data of fem_condition_ms_bit_min_value
     */
    dnx_data_field_base_ipmf1_fem_condition_ms_bit_min_value_get_f fem_condition_ms_bit_min_value_get;
    /**
     * returns define data of nof_fem_programs
     */
    dnx_data_field_base_ipmf1_nof_fem_programs_get_f nof_fem_programs_get;
    /**
     * returns define data of log_nof_bits_in_fem_key_select
     */
    dnx_data_field_base_ipmf1_log_nof_bits_in_fem_key_select_get_f log_nof_bits_in_fem_key_select_get;
    /**
     * returns define data of nof_bits_in_fem_key_select
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_key_select_get_f nof_bits_in_fem_key_select_get;
    /**
     * returns define data of fem_key_select_resolution_in_bits
     */
    dnx_data_field_base_ipmf1_fem_key_select_resolution_in_bits_get_f fem_key_select_resolution_in_bits_get;
    /**
     * returns define data of log_nof_bits_in_fem_map_data_field
     */
    dnx_data_field_base_ipmf1_log_nof_bits_in_fem_map_data_field_get_f log_nof_bits_in_fem_map_data_field_get;
    /**
     * returns define data of nof_bits_in_fem_map_data_field
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_map_data_field_get_f nof_bits_in_fem_map_data_field_get;
    /**
     * returns define data of nof_bits_in_fem_action_fems_2_15
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_2_15_get_f nof_bits_in_fem_action_fems_2_15_get;
    /**
     * returns define data of nof_bits_in_fem_action_fems_0_1
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_action_fems_0_1_get_f nof_bits_in_fem_action_fems_0_1_get;
    /**
     * returns define data of nof_bits_in_fem_action
     */
    dnx_data_field_base_ipmf1_nof_bits_in_fem_action_get_f nof_bits_in_fem_action_get;
    /**
     * returns define data of nof_fem_condition
     */
    dnx_data_field_base_ipmf1_nof_fem_condition_get_f nof_fem_condition_get;
    /**
     * returns define data of nof_fem_map_index
     */
    dnx_data_field_base_ipmf1_nof_fem_map_index_get_f nof_fem_map_index_get;
    /**
     * returns define data of nof_fem_id
     */
    dnx_data_field_base_ipmf1_nof_fem_id_get_f nof_fem_id_get;
    /**
     * returns define data of num_fems_with_short_action
     */
    dnx_data_field_base_ipmf1_num_fems_with_short_action_get_f num_fems_with_short_action_get;
    /**
     * returns define data of num_bits_in_fem_field_select
     */
    dnx_data_field_base_ipmf1_num_bits_in_fem_field_select_get_f num_bits_in_fem_field_select_get;
    /**
     * returns define data of nof_fem_id_per_array
     */
    dnx_data_field_base_ipmf1_nof_fem_id_per_array_get_f nof_fem_id_per_array_get;
    /**
     * returns define data of nof_fem_array
     */
    dnx_data_field_base_ipmf1_nof_fem_array_get_f nof_fem_array_get;
    /**
     * returns define data of nof_compare_pairs_in_compare_mode
     */
    dnx_data_field_base_ipmf1_nof_compare_pairs_in_compare_mode_get_f nof_compare_pairs_in_compare_mode_get;
    /**
     * returns define data of compare_key_size
     */
    dnx_data_field_base_ipmf1_compare_key_size_get_f compare_key_size_get;
    /**
     * returns define data of nof_l4_ops_ranges_legacy
     */
    dnx_data_field_base_ipmf1_nof_l4_ops_ranges_legacy_get_f nof_l4_ops_ranges_legacy_get;
    /**
     * returns define data of nof_ext_l4_ops_ranges
     */
    dnx_data_field_base_ipmf1_nof_ext_l4_ops_ranges_get_f nof_ext_l4_ops_ranges_get;
    /**
     * returns define data of nof_pkt_hdr_ranges
     */
    dnx_data_field_base_ipmf1_nof_pkt_hdr_ranges_get_f nof_pkt_hdr_ranges_get;
    /**
     * returns define data of nof_out_lif_ranges
     */
    dnx_data_field_base_ipmf1_nof_out_lif_ranges_get_f nof_out_lif_ranges_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_ipmf1_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_ipmf1_uses_large_exem_get_f uses_large_exem_get;
    /**
     * returns define data of cmp_selection
     */
    dnx_data_field_base_ipmf1_cmp_selection_get_f cmp_selection_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_base_ipmf1_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_pgm_id_offset
     */
    dnx_data_field_base_ipmf1_fes_pgm_id_offset_get_f fes_pgm_id_offset_get;
    /**
     * returns define data of dir_ext_single_key_size
     */
    dnx_data_field_base_ipmf1_dir_ext_single_key_size_get_f dir_ext_single_key_size_get;
    /**
     * returns numeric data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_ipmf1_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns numeric data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_ipmf1_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
} dnx_data_if_field_base_ipmf1_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IPMF2:
 * Ingress PMF_2 data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf2_feature_nof
} dnx_data_field_base_ipmf2_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ipmf2_feature_get_f) (
    int unit,
    dnx_data_field_base_ipmf2_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_ffc'
 * Number of FFC's per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_keys_alloc_for_mdb_dt_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_contexts'
 * Number of contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf2', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf2', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_uses_large_exem_get_f) (
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_ipmf2', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_dir_ext_single_key_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf2', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IPMF2:
 * {
 */
/**
 * \brief Interface for field base_ipmf2 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ipmf2_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ipmf2_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ipmf2_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_keys_alloc_for_dir_ext
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_dir_ext_get_f nof_keys_alloc_for_dir_ext_get;
    /**
     * returns define data of nof_keys_alloc_for_mdb_dt
     */
    dnx_data_field_base_ipmf2_nof_keys_alloc_for_mdb_dt_get_f nof_keys_alloc_for_mdb_dt_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_ipmf2_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_ipmf2_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_ipmf2_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_ipmf2_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ipmf2_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ipmf2_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_ipmf2_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_ipmf2_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_ipmf2_uses_large_exem_get_f uses_large_exem_get;
    /**
     * returns define data of dir_ext_single_key_size
     */
    dnx_data_field_base_ipmf2_dir_ext_single_key_size_get_f dir_ext_single_key_size_get;
    /**
     * returns numeric data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_ipmf2_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns numeric data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_ipmf2_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
} dnx_data_if_field_base_ipmf2_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IPMF3:
 * Ingress PMF_3 (PMF_B) data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ipmf3_feature_nof
} dnx_data_field_base_ipmf3_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ipmf3_feature_get_f) (
    int unit,
    dnx_data_field_base_ipmf3_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_mdb_dt
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_keys_alloc_for_mdb_dt'
 * Number of keys available for allocation for use by this specific PMF stage for MDB_DT access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_mdb_dt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_keys_alloc_for_mdb_dt_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of cs_scratch_pad_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'cs_scratch_pad_size'
 * Number of bits taken from general data for context selection.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cs_scratch_pad_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_cs_scratch_pad_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_contexts'
 * Number of Ingress PMF_B programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of fes_key_select_resolution_in_bits
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_key_select_resolution_in_bits'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_resolution_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_key_select_resolution_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_out_lif_ranges'
 * Number of ranges for Out Lif. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_out_lif_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_ipmf3', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_uses_large_exem_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to IPPD_PMF_FES_PROGRAMm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_pgm_id_offset_get_f) (
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_ipmf3', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_dir_ext_single_key_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_fes_used_by_sdk
 * Module - 'field', Submodule - 'base_ipmf3', data - 'nof_fes_used_by_sdk'
 * nof fe used by sdk in ipmf3 can be changed per system header soc property
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_used_by_sdk - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_nof_fes_used_by_sdk_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_ipmf3', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IPMF3:
 * {
 */
/**
 * \brief Interface for field base_ipmf3 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ipmf3_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ipmf3_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ipmf3_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_keys_alloc_for_dir_ext
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_dir_ext_get_f nof_keys_alloc_for_dir_ext_get;
    /**
     * returns define data of nof_keys_alloc_for_mdb_dt
     */
    dnx_data_field_base_ipmf3_nof_keys_alloc_for_mdb_dt_get_f nof_keys_alloc_for_mdb_dt_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_ipmf3_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_ipmf3_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_ipmf3_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_ipmf3_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_base_ipmf3_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_base_ipmf3_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of cs_scratch_pad_size
     */
    dnx_data_field_base_ipmf3_cs_scratch_pad_size_get_f cs_scratch_pad_size_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ipmf3_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ipmf3_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_base_ipmf3_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_ipmf3_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_base_ipmf3_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_base_ipmf3_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of fes_key_select_resolution_in_bits
     */
    dnx_data_field_base_ipmf3_fes_key_select_resolution_in_bits_get_f fes_key_select_resolution_in_bits_get;
    /**
     * returns define data of nof_out_lif_ranges
     */
    dnx_data_field_base_ipmf3_nof_out_lif_ranges_get_f nof_out_lif_ranges_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_ipmf3_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_ipmf3_uses_large_exem_get_f uses_large_exem_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_base_ipmf3_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_pgm_id_offset
     */
    dnx_data_field_base_ipmf3_fes_pgm_id_offset_get_f fes_pgm_id_offset_get;
    /**
     * returns define data of dir_ext_single_key_size
     */
    dnx_data_field_base_ipmf3_dir_ext_single_key_size_get_f dir_ext_single_key_size_get;
    /**
     * returns numeric data of nof_fes_used_by_sdk
     */
    dnx_data_field_base_ipmf3_nof_fes_used_by_sdk_get_f nof_fes_used_by_sdk_get;
    /**
     * returns numeric data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_ipmf3_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns numeric data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_ipmf3_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
} dnx_data_if_field_base_ipmf3_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_EPMF:
 * Egress PMF data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_epmf_feature_nof
} dnx_data_field_base_epmf_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_epmf_feature_get_f) (
    int unit,
    dnx_data_field_base_epmf_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_ffc'
 * Number of FFC's. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys'
 * Number of keys for the this PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc'
 * Number of keys available for allocation for use by this specific PMF stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_alloc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_tcam
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_tcam'
 * Number of keys available for allocation for use by this specific PMF stage for TCAM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_tcam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_exem'
 * Number of keys available for allocation for use by this specific PMF stage for EXEM access. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_alloc_for_exem_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_alloc_for_dir_ext
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_keys_alloc_for_dir_ext'
 * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_alloc_for_dir_ext - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_keys_alloc_for_dir_ext_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_masks_per_fes'
 * Number of masks per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_array'
 * Number FES arrays. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_fes_programs'
 * Number of FES programs. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_contexts'
 * Number of Egress contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_actions'
 * Number of actions. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_qualifiers'
 * Number of qualifiers. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of fes_key_select_resolution_in_bits
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_key_select_resolution_in_bits'
 * Number of bits on input to FES. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_resolution_in_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_key_select_resolution_in_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'base_epmf', data - 'nof_l4_ops_ranges_legacy'
 * Number of ranges for L4 Ops legacy. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_nof_l4_ops_ranges_legacy_get_f) (
    int unit);

/**
 * \brief returns define data of uses_small_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_small_exem'
 * Indicated if the stage can perform a SEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_small_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_uses_small_exem_get_f) (
    int unit);

/**
 * \brief returns define data of uses_large_exem
 * Module - 'field', Submodule - 'base_epmf', data - 'uses_large_exem'
 * Indicated if the stage can perform a LEXEM lookup. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     uses_large_exem - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_uses_large_exem_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_pgm_id_offset
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_pgm_id_offset'
 * FES Program ID offset pointing to ERPP_PMF_FES_PROGRAMmm->FES_2ND_INSTRUCTION_LSB_ADDRESSf.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_pgm_id_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_pgm_id_offset_get_f) (
    int unit);

/**
 * \brief returns define data of dir_ext_single_key_size
 * Module - 'field', Submodule - 'base_epmf', data - 'dir_ext_single_key_size'
 * Single key size used for Direct Extraction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_dir_ext_single_key_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_key_select_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_key_select_for_zero_bit'
 * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_key_select_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_key_select_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns numeric data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'base_epmf', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit). For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_epmf_fes_shift_for_zero_bit_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_EPMF:
 * {
 */
/**
 * \brief Interface for field base_epmf data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_epmf_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_epmf_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_epmf_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_keys_alloc
     */
    dnx_data_field_base_epmf_nof_keys_alloc_get_f nof_keys_alloc_get;
    /**
     * returns define data of nof_keys_alloc_for_tcam
     */
    dnx_data_field_base_epmf_nof_keys_alloc_for_tcam_get_f nof_keys_alloc_for_tcam_get;
    /**
     * returns define data of nof_keys_alloc_for_exem
     */
    dnx_data_field_base_epmf_nof_keys_alloc_for_exem_get_f nof_keys_alloc_for_exem_get;
    /**
     * returns define data of nof_keys_alloc_for_dir_ext
     */
    dnx_data_field_base_epmf_nof_keys_alloc_for_dir_ext_get_f nof_keys_alloc_for_dir_ext_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_base_epmf_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_base_epmf_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_base_epmf_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_base_epmf_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_base_epmf_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_base_epmf_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_epmf_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_epmf_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_base_epmf_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_base_epmf_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_base_epmf_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_base_epmf_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of fes_key_select_resolution_in_bits
     */
    dnx_data_field_base_epmf_fes_key_select_resolution_in_bits_get_f fes_key_select_resolution_in_bits_get;
    /**
     * returns define data of nof_l4_ops_ranges_legacy
     */
    dnx_data_field_base_epmf_nof_l4_ops_ranges_legacy_get_f nof_l4_ops_ranges_legacy_get;
    /**
     * returns define data of uses_small_exem
     */
    dnx_data_field_base_epmf_uses_small_exem_get_f uses_small_exem_get;
    /**
     * returns define data of uses_large_exem
     */
    dnx_data_field_base_epmf_uses_large_exem_get_f uses_large_exem_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_base_epmf_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_pgm_id_offset
     */
    dnx_data_field_base_epmf_fes_pgm_id_offset_get_f fes_pgm_id_offset_get;
    /**
     * returns define data of dir_ext_single_key_size
     */
    dnx_data_field_base_epmf_dir_ext_single_key_size_get_f dir_ext_single_key_size_get;
    /**
     * returns numeric data of fes_key_select_for_zero_bit
     */
    dnx_data_field_base_epmf_fes_key_select_for_zero_bit_get_f fes_key_select_for_zero_bit_get;
    /**
     * returns numeric data of fes_shift_for_zero_bit
     */
    dnx_data_field_base_epmf_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
} dnx_data_if_field_base_epmf_t;

/*
 * }
 */

/*
 * SUBMODULE  - BASE_IFWD2:
 * IFWD2 data. For internal DNX DATA use only. Use stage submodule instead.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_base_ifwd2_feature_nof
} dnx_data_field_base_ifwd2_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_base_ifwd2_feature_get_f) (
    int unit,
    dnx_data_field_base_ifwd2_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_ffc'
 * Number of FFC's in this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_keys'
 * Number of keys available for allocation for use by this specific IFWD2 stage. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_contexts'
 * Number of KBP ACL contexts. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'base_ifwd2', data - 'nof_cs_lines'
 * Number of program selection lines. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_base_ifwd2_nof_cs_lines_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - BASE_IFWD2:
 * {
 */
/**
 * \brief Interface for field base_ifwd2 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_base_ifwd2_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_base_ifwd2_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_base_ifwd2_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_base_ifwd2_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_base_ifwd2_nof_cs_lines_get_f nof_cs_lines_get;
} dnx_data_if_field_base_ifwd2_t;

/*
 * }
 */

/*
 * SUBMODULE  - STAGE:
 * Data regarding the field stages
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule stage table stage_info
 * Table info:
 * Per stage information
 */
typedef struct
{
    /**
     * Whether the field_stage is supported on the device
     */
    int valid;
    /**
     * Number of FFC's per context
     */
    int nof_ffc;
    /**
     * Number of keys for the this PMF stage
     */
    int nof_keys;
    /**
     * Number of keys available for allocation for use by this specific PMF stage
     */
    int nof_keys_alloc;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for TCAM access
     */
    int nof_keys_alloc_for_tcam;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for EXEM access
     */
    int nof_keys_alloc_for_exem;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for DIRECT EXTRACTION
     */
    int nof_keys_alloc_for_dir_ext;
    /**
     * Number of keys available for allocation for use by this specific PMF stage for Direct Table MDB access
     */
    int nof_keys_alloc_for_mdb_dt;
    /**
     * Number of masks per FES
     */
    int nof_masks_per_fes;
    /**
     * Number FESes in each FES array
     */
    int nof_fes_id_per_array;
    /**
     * Number of FES arrays
     */
    int nof_fes_array;
    /**
     * Number of FES INSTRUCTIONs per context
     */
    int nof_fes_instruction_per_context;
    /**
     * Number of FES programs
     */
    int nof_fes_programs;
    /**
     * Number of MS bits instruction programs per FES
     */
    int nof_prog_per_fes;
    /**
     * Number of bits taken from general data for context selection.
     */
    int cs_scratch_pad_size;
    /**
     * Number of bits taken from general data for context selection.
     */
    int cs_container_5_selected_bits_size;
    /**
     * Number of Ingress PMF_A programs (contexts)
     */
    int nof_contexts;
    /**
     * Number of profiles assigned to iPMF1 contexts in order to create links between iPMF1 and iPMF2 contexts
     */
    int nof_link_profiles;
    /**
     * Number of program selection lines
     */
    int nof_cs_lines;
    /**
     * Number of actions
     */
    int nof_actions;
    /**
     * Number of qualifiers
     */
    int nof_qualifiers;
    /**
     * Number of bits on the output of a FES.
     */
    int nof_bits_in_fes_action;
    /**
     * Number of bits on input to FES.
     */
    int nof_bits_in_fes_key_select;
    /**
     * Number of bits on input to FES.
     */
    int fes_key_select_resolution_in_bits;
    /**
     * The minumum legal value to be set in bit select for a FEM.
     */
    int fem_condition_ms_bit_min_value;
    /**
     * Total number FEM programs available.
     */
    int nof_fem_programs;
    /**
     * Log2 of number of bits on one 'chunk' of input to FEM.
     */
    int log_nof_bits_in_fem_key_select;
    /**
     * Number of bits on one 'chunk' of input to FEM.
     */
    int nof_bits_in_fem_key_select;
    /**
     * Number of bits in the 'step' from one 'key select' to the following. See dbal_enum_value_field_field_pmf_a_fem_key_select_e.
     */
    int fem_key_select_resolution_in_bits;
    /**
     * Log2 of number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table).
     */
    int log_nof_bits_in_fem_map_data_field;
    /**
     * Number of bits on MAP_DATA field in IPPC_FEM_MAP_INDEX_TABLE (See FIELD_PMF_A_FEM_MAP_INDEX dbal table).
     */
    int nof_bits_in_fem_map_data_field;
    /**
     * Number of bits on action value in IPPC_FEM_*_24B_MAP_TABLE.
     */
    int nof_bits_in_fem_action_fems_2_15;
    /**
     * Number of bits on action value in IPPC_FEM_*_4B_MAP_TABLE.
     */
    int nof_bits_in_fem_action_fems_0_1;
    /**
     * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE.
     */
    int nof_bits_in_fem_action;
    /**
     * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination.
     */
    int nof_fem_condition;
    /**
     * Total number fem map indices. This represents the number of actions that may be assigned to each condition.
     */
    int nof_fem_map_index;
    /**
     * Total number 'FEM id's available.
     */
    int nof_fem_id;
    /**
     * Number of FEMs, starting from 'fem_id=0', which have only 4 bits on action value. The rest have 24 bits on action value
     */
    int num_fems_with_short_action;
    /**
     * Number of bits on each of the HW field marked FIELD_SELECT_MAP_*
     */
    int num_bits_in_fem_field_select;
    /**
     * Number of FEMs in each FEM array
     */
    int nof_fem_id_per_array;
    /**
     * Number of FEM arrays
     */
    int nof_fem_array;
    /**
     * Number of bits reserved in Ingress PBUS for header
     */
    int pbus_header_length;
    /**
     * Number of layer records taken from the parser.
     */
    int nof_layer_records;
    /**
     * Number of bits in each layer record.
     */
    int layer_record_size;
    /**
     * Number compare pairs in compare mode
     */
    int nof_compare_pairs_in_compare_mode;
    /**
     * Size of the compare key in the system
     */
    int compare_key_size;
    /**
     * Number of ranges for L4 Ops legacy
     */
    int nof_l4_ops_ranges_legacy;
    /**
     * Number of ranges for Extended L4 Ops
     */
    int nof_ext_l4_ops_ranges;
    /**
     * Number of ranges for PKT HDR
     */
    int nof_pkt_hdr_ranges;
    /**
     * Number of ranges for Out Lif
     */
    int nof_out_lif_ranges;
    /**
     * The key select used for obtaining an always zero bit for input to FES (for example, using a zero padded bit).
     */
    int fes_key_select_for_zero_bit;
    /**
     * The shift used for obtaining an always zero bit for input to FES (for example, using a zero padded bit).
     */
    int fes_shift_for_zero_bit;
    /**
     * Indicated if the stage can perform a SEXEM lookup.
     */
    int uses_small_exem;
    /**
     * Indicated if the stage can perform a LEXEM lookup.
     */
    int uses_large_exem;
    /**
     * Compare selection for both keys of 2nd compare, See the CMP_SELECTION field in IPPC_PMF_GENERAL register for additional information
     */
    int cmp_selection;
    /**
     * Number of bits in the main PBUS of the stage (the one used by METADATA qualifiers). Only iPMF2 uses the iPMF1 PBUs as it's main PBUS.
     */
    int nof_bits_main_pbus;
    /**
     * Number of bits in the native PBUS of the stage, if it is different from the main PBUS. Only iPMF2 has a separate native PBUS.
     */
    int nof_bits_native_pbus;
    /**
     * Single key size used for Direct Extraction.
     */
    int dir_ext_single_key_size;
} dnx_data_field_stage_stage_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_stage_feature_nof
} dnx_data_field_stage_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_stage_feature_get_f) (
    int unit,
    dnx_data_field_stage_feature_e feature);

/**
 * \brief get table stage_info entry 
 * Per stage information
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * 
 * \return
 *     stage_info - returns the relevant entry values grouped in struct - see dnx_data_field_stage_stage_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_stage_stage_info_t *(
    *dnx_data_field_stage_stage_info_get_f) (
    int unit,
    int stage);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - STAGE:
 * {
 */
/**
 * \brief Interface for field stage data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_stage_feature_get_f feature_get;
    /**
     * get table stage_info entry 
     */
    dnx_data_field_stage_stage_info_get_f stage_info_get;
    /**
     * get general info table about table (for example key size)stage_info info
     */
    dnxc_data_table_info_get_f stage_info_info_get;
} dnx_data_if_field_stage_t;

/*
 * }
 */

/*
 * SUBMODULE  - KBP:
 * KBP data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule kbp table ffc_to_quad_and_group_map
 * Table info:
 * Mapping of the ffc id to its quad anad group
 */
typedef struct
{
    /**
     * Id of the relevant quad for the given ffc id
     */
    uint32 quad_id;
    /**
     * Id of the relevant group for the given ffc id
     */
    uint32 group_id;
} dnx_data_field_kbp_ffc_to_quad_and_group_map_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_kbp_feature_nof
} dnx_data_field_kbp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_kbp_feature_get_f) (
    int unit,
    dnx_data_field_kbp_feature_e feature);

/**
 * \brief returns define data of max_single_key_size
 * Module - 'field', Submodule - 'kbp', data - 'max_single_key_size'
 * Maximum single key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_single_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_acl_keys_master_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_master_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_master_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_nof_acl_keys_master_max_get_f) (
    int unit);

/**
 * \brief returns define data of nof_acl_keys_fg_max
 * Module - 'field', Submodule - 'kbp', data - 'nof_acl_keys_fg_max'
 * The maximum number of keys that can be used by ACL (not FWD) in KBP for a single field group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_acl_keys_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_nof_acl_keys_fg_max_get_f) (
    int unit);

/**
 * \brief returns define data of min_acl_nof_ffc
 * Module - 'field', Submodule - 'kbp', data - 'min_acl_nof_ffc'
 * Minimum number of FFC's that should be allocated for each context for ACL purposes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_acl_nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_min_acl_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of max_fwd_context_num_for_one_apptype
 * Module - 'field', Submodule - 'kbp', data - 'max_fwd_context_num_for_one_apptype'
 * Maximum number of fwd contexts that could be mapped to an apptype 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_fwd_context_num_for_one_apptype - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_get_f) (
    int unit);

/**
 * \brief returns define data of max_acl_context_num
 * Module - 'field', Submodule - 'kbp', data - 'max_acl_context_num'
 * Maximum number of ACL contexts in the KBP 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_acl_context_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_acl_context_num_get_f) (
    int unit);

/**
 * \brief returns define data of size_apptype_profile_id
 * Module - 'field', Submodule - 'kbp', data - 'size_apptype_profile_id'
 * Size in bits of the apptype profile ID (based on iFED2 ACL context)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     size_apptype_profile_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_size_apptype_profile_id_get_f) (
    int unit);

/**
 * \brief returns define data of key_bmp
 * Module - 'field', Submodule - 'kbp', data - 'key_bmp'
 * bitmap of the key IDs used by the KBP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_bmp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_key_bmp_get_f) (
    int unit);

/**
 * \brief returns define data of apptype_user_1st
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_1st'
 * First User defined Apptype id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_apptype_user_1st_get_f) (
    int unit);

/**
 * \brief returns define data of apptype_user_nof
 * Module - 'field', Submodule - 'kbp', data - 'apptype_user_nof'
 * Number of user Defined apptypes that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     apptype_user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_apptype_user_nof_get_f) (
    int unit);

/**
 * \brief returns define data of max_payload_size_per_opcode
 * Module - 'field', Submodule - 'kbp', data - 'max_payload_size_per_opcode'
 * The total payload size of the KBP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_payload_size_per_opcode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_kbp_max_payload_size_per_opcode_get_f) (
    int unit);

/**
 * \brief get table ffc_to_quad_and_group_map entry 
 * Mapping of the ffc id to its quad anad group
 * 
 * \param [in] unit - unit #
 * \param [in] ffc_id - Id of the required ffc
 * 
 * \return
 *     ffc_to_quad_and_group_map - returns the relevant entry values grouped in struct - see dnx_data_field_kbp_ffc_to_quad_and_group_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_kbp_ffc_to_quad_and_group_map_t *(
    *dnx_data_field_kbp_ffc_to_quad_and_group_map_get_f) (
    int unit,
    int ffc_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - KBP:
 * {
 */
/**
 * \brief Interface for field kbp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_kbp_feature_get_f feature_get;
    /**
     * returns define data of max_single_key_size
     */
    dnx_data_field_kbp_max_single_key_size_get_f max_single_key_size_get;
    /**
     * returns define data of nof_acl_keys_master_max
     */
    dnx_data_field_kbp_nof_acl_keys_master_max_get_f nof_acl_keys_master_max_get;
    /**
     * returns define data of nof_acl_keys_fg_max
     */
    dnx_data_field_kbp_nof_acl_keys_fg_max_get_f nof_acl_keys_fg_max_get;
    /**
     * returns define data of min_acl_nof_ffc
     */
    dnx_data_field_kbp_min_acl_nof_ffc_get_f min_acl_nof_ffc_get;
    /**
     * returns define data of max_fwd_context_num_for_one_apptype
     */
    dnx_data_field_kbp_max_fwd_context_num_for_one_apptype_get_f max_fwd_context_num_for_one_apptype_get;
    /**
     * returns define data of max_acl_context_num
     */
    dnx_data_field_kbp_max_acl_context_num_get_f max_acl_context_num_get;
    /**
     * returns define data of size_apptype_profile_id
     */
    dnx_data_field_kbp_size_apptype_profile_id_get_f size_apptype_profile_id_get;
    /**
     * returns define data of key_bmp
     */
    dnx_data_field_kbp_key_bmp_get_f key_bmp_get;
    /**
     * returns define data of apptype_user_1st
     */
    dnx_data_field_kbp_apptype_user_1st_get_f apptype_user_1st_get;
    /**
     * returns define data of apptype_user_nof
     */
    dnx_data_field_kbp_apptype_user_nof_get_f apptype_user_nof_get;
    /**
     * returns define data of max_payload_size_per_opcode
     */
    dnx_data_field_kbp_max_payload_size_per_opcode_get_f max_payload_size_per_opcode_get;
    /**
     * get table ffc_to_quad_and_group_map entry 
     */
    dnx_data_field_kbp_ffc_to_quad_and_group_map_get_f ffc_to_quad_and_group_map_get;
    /**
     * get general info table about table (for example key size)ffc_to_quad_and_group_map info
     */
    dnxc_data_table_info_get_f ffc_to_quad_and_group_map_info_get;
} dnx_data_if_field_kbp_t;

/*
 * }
 */

/*
 * SUBMODULE  - TCAM:
 * TCAM data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicate if tcam 320b is supported
     */
    dnx_data_field_tcam_tcam_320b_support,

    /**
     * Must be last one!
     */
    _dnx_data_field_tcam_feature_nof
} dnx_data_field_tcam_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_tcam_feature_get_f) (
    int unit,
    dnx_data_field_tcam_feature_e feature);

/**
 * \brief returns define data of key_size_half
 * Module - 'field', Submodule - 'tcam', data - 'key_size_half'
 * Half TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_size_half_get_f) (
    int unit);

/**
 * \brief returns define data of key_size_single
 * Module - 'field', Submodule - 'tcam', data - 'key_size_single'
 * Single TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_size_single_get_f) (
    int unit);

/**
 * \brief returns define data of key_size_double
 * Module - 'field', Submodule - 'tcam', data - 'key_size_double'
 * Double TCAM key size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_size_double_get_f) (
    int unit);

/**
 * \brief returns define data of dt_max_key_size
 * Module - 'field', Submodule - 'tcam', data - 'dt_max_key_size'
 * Maximum key size for TCAM DT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dt_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_dt_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_half
 * Module - 'field', Submodule - 'tcam', data - 'action_size_half'
 * When the key size is half key (80b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_half - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_size_half_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_single
 * Module - 'field', Submodule - 'tcam', data - 'action_size_single'
 * When the key size is single key (160b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_single - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_size_single_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_double
 * Module - 'field', Submodule - 'tcam', data - 'action_size_double'
 * When the key size is double key (320b), this holds the action width payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_double - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_size_double_get_f) (
    int unit);

/**
 * \brief returns define data of key_mode_size
 * Module - 'field', Submodule - 'tcam', data - 'key_mode_size'
 * Number of bits representing the entry size for each half entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_mode_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_key_mode_size_get_f) (
    int unit);

/**
 * \brief returns define data of entry_size_single_key_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_key_hw'
 * The full key size in HW, includingd entry size field, not including payload and valid bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_key_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_entry_size_single_key_hw_get_f) (
    int unit);

/**
 * \brief returns define data of entry_size_single_key_shadow
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_key_shadow'
 * Shadow entry size, including mode bits and valid bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_key_shadow - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_entry_size_single_key_shadow_get_f) (
    int unit);

/**
 * \brief returns define data of entry_size_single_valid_bits_hw
 * Module - 'field', Submodule - 'tcam', data - 'entry_size_single_valid_bits_hw'
 * The size of the valid bits in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_size_single_valid_bits_hw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_entry_size_single_valid_bits_hw_get_f) (
    int unit);

/**
 * \brief returns define data of hw_bank_size
 * Module - 'field', Submodule - 'tcam', data - 'hw_bank_size'
 * Size of a TCAM bank in HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hw_bank_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_hw_bank_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_bank_lines'
 * Number of TCAM big bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_big_bank_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_small_bank_lines
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_bank_lines'
 * Number of TCAM small bank lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bank_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_small_bank_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_banks'
 * Number of TCAM big banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_big_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_small_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_banks'
 * Number of TCAM small banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_small_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_banks
 * Module - 'field', Submodule - 'tcam', data - 'nof_banks'
 * Number of TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_banks_get_f) (
    int unit);

/**
 * \brief returns define data of nof_payload_tables
 * Module - 'field', Submodule - 'tcam', data - 'nof_payload_tables'
 * Number of action tables
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_payload_tables - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_payload_tables_get_f) (
    int unit);

/**
 * \brief returns define data of nof_access_profiles
 * Module - 'field', Submodule - 'tcam', data - 'nof_access_profiles'
 * Number of TCAM access profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_access_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_access_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of action_width_selector_size
 * Module - 'field', Submodule - 'tcam', data - 'action_width_selector_size'
 * The action width selector size for each bank in each access profile, each bit represents the corresponding 32 bit in the action table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_width_selector_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_action_width_selector_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_entries_160_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_160_bits'
 * Number of 160 bits TCAM entries; Value: (nof_big_banks*nof_big_bank_lines)+(nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_160_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_entries_160_bits_get_f) (
    int unit);

/**
 * \brief returns define data of nof_entries_80_bits
 * Module - 'field', Submodule - 'tcam', data - 'nof_entries_80_bits'
 * Number of 80 bits TCAM entries; Value: (2*nof_big_banks*nof_big_bank_lines)+(2*nof_small_banks*nof_small_bank_lines)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_80_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_entries_80_bits_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_banks_size
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_size'
 * The size of TCAM_TCAM_BANK which is equal to (nof_big_banks + nof_small_banks) * nof_big_bank_lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_tcam_banks_size_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_banks_last_index
 * Module - 'field', Submodule - 'tcam', data - 'tcam_banks_last_index'
 * Last index available in TCAM banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_banks_last_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_tcam_banks_last_index_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcam_handlers
 * Module - 'field', Submodule - 'tcam', data - 'nof_tcam_handlers'
 * Number of TCAM handlers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcam_handlers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_tcam_handlers_get_f) (
    int unit);

/**
 * \brief returns define data of max_prefix_size
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_size'
 * Maximum prefix size in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_max_prefix_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_prefix_value
 * Module - 'field', Submodule - 'tcam', data - 'max_prefix_value'
 * Maximum prefix value in TCAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_prefix_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_max_prefix_value_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_max
 * Module - 'field', Submodule - 'tcam', data - 'nof_keys_max'
 * Number of 160'b key's in one search lookup
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_keys_max_get_f) (
    int unit);

/**
 * \brief returns define data of access_profile_half_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_half_key_mode'
 * Half key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_half_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_access_profile_half_key_mode_get_f) (
    int unit);

/**
 * \brief returns define data of access_profile_single_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_single_key_mode'
 * Single key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_single_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_access_profile_single_key_mode_get_f) (
    int unit);

/**
 * \brief returns define data of access_profile_double_key_mode
 * Module - 'field', Submodule - 'tcam', data - 'access_profile_double_key_mode'
 * Double key mode in access profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     access_profile_double_key_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_access_profile_double_key_mode_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_entries_per_hit_indication_entry
 * Module - 'field', Submodule - 'tcam', data - 'tcam_entries_per_hit_indication_entry'
 * Number of entries in TCAM and CS TCAM HIT indication memories line (8b bmp).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_entries_per_hit_indication_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_tcam_entries_per_hit_indication_entry_get_f) (
    int unit);

/**
 * \brief returns define data of max_tcam_priority
 * Module - 'field', Submodule - 'tcam', data - 'max_tcam_priority'
 * The biggest valid value for the priority of a TCAM entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tcam_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_max_tcam_priority_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_banks_srams
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_banks_srams'
 * Number of SRAMs for big banks.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_banks_srams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_big_banks_srams_get_f) (
    int unit);

/**
 * \brief returns define data of nof_small_banks_srams
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_banks_srams'
 * Number of SRAMs for small banks.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_banks_srams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_small_banks_srams_get_f) (
    int unit);

/**
 * \brief returns define data of nof_big_bank_lines_per_sram
 * Module - 'field', Submodule - 'tcam', data - 'nof_big_bank_lines_per_sram'
 * Number of big bank lines per SRAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_big_bank_lines_per_sram - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_big_bank_lines_per_sram_get_f) (
    int unit);

/**
 * \brief returns define data of nof_small_bank_lines_per_sram
 * Module - 'field', Submodule - 'tcam', data - 'nof_small_bank_lines_per_sram'
 * Number of small bank lines per SRAM.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_small_bank_lines_per_sram - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_nof_small_bank_lines_per_sram_get_f) (
    int unit);

/**
 * \brief returns define data of app_db_id_size
 * Module - 'field', Submodule - 'tcam', data - 'app_db_id_size'
 * Size in bits of the app_db_id.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tcam_app_db_id_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - TCAM:
 * {
 */
/**
 * \brief Interface for field tcam data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_tcam_feature_get_f feature_get;
    /**
     * returns define data of key_size_half
     */
    dnx_data_field_tcam_key_size_half_get_f key_size_half_get;
    /**
     * returns define data of key_size_single
     */
    dnx_data_field_tcam_key_size_single_get_f key_size_single_get;
    /**
     * returns define data of key_size_double
     */
    dnx_data_field_tcam_key_size_double_get_f key_size_double_get;
    /**
     * returns define data of dt_max_key_size
     */
    dnx_data_field_tcam_dt_max_key_size_get_f dt_max_key_size_get;
    /**
     * returns define data of action_size_half
     */
    dnx_data_field_tcam_action_size_half_get_f action_size_half_get;
    /**
     * returns define data of action_size_single
     */
    dnx_data_field_tcam_action_size_single_get_f action_size_single_get;
    /**
     * returns define data of action_size_double
     */
    dnx_data_field_tcam_action_size_double_get_f action_size_double_get;
    /**
     * returns define data of key_mode_size
     */
    dnx_data_field_tcam_key_mode_size_get_f key_mode_size_get;
    /**
     * returns define data of entry_size_single_key_hw
     */
    dnx_data_field_tcam_entry_size_single_key_hw_get_f entry_size_single_key_hw_get;
    /**
     * returns define data of entry_size_single_key_shadow
     */
    dnx_data_field_tcam_entry_size_single_key_shadow_get_f entry_size_single_key_shadow_get;
    /**
     * returns define data of entry_size_single_valid_bits_hw
     */
    dnx_data_field_tcam_entry_size_single_valid_bits_hw_get_f entry_size_single_valid_bits_hw_get;
    /**
     * returns define data of hw_bank_size
     */
    dnx_data_field_tcam_hw_bank_size_get_f hw_bank_size_get;
    /**
     * returns define data of nof_big_bank_lines
     */
    dnx_data_field_tcam_nof_big_bank_lines_get_f nof_big_bank_lines_get;
    /**
     * returns define data of nof_small_bank_lines
     */
    dnx_data_field_tcam_nof_small_bank_lines_get_f nof_small_bank_lines_get;
    /**
     * returns define data of nof_big_banks
     */
    dnx_data_field_tcam_nof_big_banks_get_f nof_big_banks_get;
    /**
     * returns define data of nof_small_banks
     */
    dnx_data_field_tcam_nof_small_banks_get_f nof_small_banks_get;
    /**
     * returns define data of nof_banks
     */
    dnx_data_field_tcam_nof_banks_get_f nof_banks_get;
    /**
     * returns define data of nof_payload_tables
     */
    dnx_data_field_tcam_nof_payload_tables_get_f nof_payload_tables_get;
    /**
     * returns define data of nof_access_profiles
     */
    dnx_data_field_tcam_nof_access_profiles_get_f nof_access_profiles_get;
    /**
     * returns define data of action_width_selector_size
     */
    dnx_data_field_tcam_action_width_selector_size_get_f action_width_selector_size_get;
    /**
     * returns define data of nof_entries_160_bits
     */
    dnx_data_field_tcam_nof_entries_160_bits_get_f nof_entries_160_bits_get;
    /**
     * returns define data of nof_entries_80_bits
     */
    dnx_data_field_tcam_nof_entries_80_bits_get_f nof_entries_80_bits_get;
    /**
     * returns define data of tcam_banks_size
     */
    dnx_data_field_tcam_tcam_banks_size_get_f tcam_banks_size_get;
    /**
     * returns define data of tcam_banks_last_index
     */
    dnx_data_field_tcam_tcam_banks_last_index_get_f tcam_banks_last_index_get;
    /**
     * returns define data of nof_tcam_handlers
     */
    dnx_data_field_tcam_nof_tcam_handlers_get_f nof_tcam_handlers_get;
    /**
     * returns define data of max_prefix_size
     */
    dnx_data_field_tcam_max_prefix_size_get_f max_prefix_size_get;
    /**
     * returns define data of max_prefix_value
     */
    dnx_data_field_tcam_max_prefix_value_get_f max_prefix_value_get;
    /**
     * returns define data of nof_keys_max
     */
    dnx_data_field_tcam_nof_keys_max_get_f nof_keys_max_get;
    /**
     * returns define data of access_profile_half_key_mode
     */
    dnx_data_field_tcam_access_profile_half_key_mode_get_f access_profile_half_key_mode_get;
    /**
     * returns define data of access_profile_single_key_mode
     */
    dnx_data_field_tcam_access_profile_single_key_mode_get_f access_profile_single_key_mode_get;
    /**
     * returns define data of access_profile_double_key_mode
     */
    dnx_data_field_tcam_access_profile_double_key_mode_get_f access_profile_double_key_mode_get;
    /**
     * returns define data of tcam_entries_per_hit_indication_entry
     */
    dnx_data_field_tcam_tcam_entries_per_hit_indication_entry_get_f tcam_entries_per_hit_indication_entry_get;
    /**
     * returns define data of max_tcam_priority
     */
    dnx_data_field_tcam_max_tcam_priority_get_f max_tcam_priority_get;
    /**
     * returns define data of nof_big_banks_srams
     */
    dnx_data_field_tcam_nof_big_banks_srams_get_f nof_big_banks_srams_get;
    /**
     * returns define data of nof_small_banks_srams
     */
    dnx_data_field_tcam_nof_small_banks_srams_get_f nof_small_banks_srams_get;
    /**
     * returns define data of nof_big_bank_lines_per_sram
     */
    dnx_data_field_tcam_nof_big_bank_lines_per_sram_get_f nof_big_bank_lines_per_sram_get;
    /**
     * returns define data of nof_small_bank_lines_per_sram
     */
    dnx_data_field_tcam_nof_small_bank_lines_per_sram_get_f nof_small_bank_lines_per_sram_get;
    /**
     * returns define data of app_db_id_size
     */
    dnx_data_field_tcam_app_db_id_size_get_f app_db_id_size_get;
} dnx_data_if_field_tcam_t;

/*
 * }
 */

/*
 * SUBMODULE  - GROUP:
 * Field Group
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_group_feature_nof
} dnx_data_field_group_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_group_feature_get_f) (
    int unit,
    dnx_data_field_group_feature_e feature);

/**
 * \brief returns define data of nof_fgs
 * Module - 'field', Submodule - 'group', data - 'nof_fgs'
 * Number of Field Groups
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fgs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_fgs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_action_per_fg'
 * Number of action per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_action_per_fg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_quals_per_fg
 * Module - 'field', Submodule - 'group', data - 'nof_quals_per_fg'
 * Number of qualifiers per Field Group
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_quals_per_fg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_quals_per_fg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys_per_fg_max
 * Module - 'field', Submodule - 'group', data - 'nof_keys_per_fg_max'
 * Maximum number of keys (KBRs) a field group can have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys_per_fg_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_nof_keys_per_fg_max_get_f) (
    int unit);

/**
 * \brief returns define data of id_fec
 * Module - 'field', Submodule - 'group', data - 'id_fec'
 * FEC is being used in more then one context, hence must be created with_id so that other applications can re-use the FG
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     id_fec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_id_fec_get_f) (
    int unit);

/**
 * \brief returns define data of payload_max_size
 * Module - 'field', Submodule - 'group', data - 'payload_max_size'
 * Maximum Payload size a field group can have.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     payload_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_group_payload_max_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - GROUP:
 * {
 */
/**
 * \brief Interface for field group data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_group_feature_get_f feature_get;
    /**
     * returns define data of nof_fgs
     */
    dnx_data_field_group_nof_fgs_get_f nof_fgs_get;
    /**
     * returns define data of nof_action_per_fg
     */
    dnx_data_field_group_nof_action_per_fg_get_f nof_action_per_fg_get;
    /**
     * returns define data of nof_quals_per_fg
     */
    dnx_data_field_group_nof_quals_per_fg_get_f nof_quals_per_fg_get;
    /**
     * returns define data of nof_keys_per_fg_max
     */
    dnx_data_field_group_nof_keys_per_fg_max_get_f nof_keys_per_fg_max_get;
    /**
     * returns define data of id_fec
     */
    dnx_data_field_group_id_fec_get_f id_fec_get;
    /**
     * returns define data of payload_max_size
     */
    dnx_data_field_group_payload_max_size_get_f payload_max_size_get;
} dnx_data_if_field_group_t;

/*
 * }
 */

/*
 * SUBMODULE  - EFES:
 * EFES data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule efes table key_select_properties
 * Table info:
 * The properties of the different key select options
 */
typedef struct
{
    /**
     * Represents the DBAL key select enums of the different stages
     */
    uint8 key_select[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * Number of bits on key select for field IO. If zero than entry is invalid.
     */
    uint8 num_bits[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The offset on the field IO of the key select
     */
    uint16 lsb[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The number of LS bits on key select not on the field IO
     */
    uint8 num_bits_not_on_key[DNX_DATA_MAX_FIELD_EFES_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
} dnx_data_field_efes_key_select_properties_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_efes_feature_nof
} dnx_data_field_efes_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_efes_feature_get_f) (
    int unit,
    dnx_data_field_efes_feature_e feature);

/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'efes', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_efes_max_nof_key_selects_per_field_io_get_f) (
    int unit);

/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] stage - Field stage enum
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_efes_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_efes_key_select_properties_t *(
    *dnx_data_field_efes_key_select_properties_get_f) (
    int unit,
    int stage,
    int field_io);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - EFES:
 * {
 */
/**
 * \brief Interface for field efes data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_efes_feature_get_f feature_get;
    /**
     * returns define data of max_nof_key_selects_per_field_io
     */
    dnx_data_field_efes_max_nof_key_selects_per_field_io_get_f max_nof_key_selects_per_field_io_get;
    /**
     * get table key_select_properties entry 
     */
    dnx_data_field_efes_key_select_properties_get_f key_select_properties_get;
    /**
     * get general info table about table (for example key size)key_select_properties info
     */
    dnxc_data_table_info_get_f key_select_properties_info_get;
} dnx_data_if_field_efes_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEM:
 * FEM data
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule fem table key_select_properties
 * Table info:
 * The properties of the different key select options
 */
typedef struct
{
    /**
     * Represents the DBAL key select enums of the different stages
     */
    uint8 key_select[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * Number of bits on key select for field IO. If zero than entry is invalid.
     */
    uint8 num_bits[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The offset on the field IO of the key select
     */
    uint16 lsb[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
    /**
     * The number of LS bits on key select not on the field IO
     */
    uint8 num_bits_not_on_key[DNX_DATA_MAX_FIELD_FEM_MAX_NOF_KEY_SELECTS_PER_FIELD_IO];
} dnx_data_field_fem_key_select_properties_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_fem_feature_nof
} dnx_data_field_fem_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_fem_feature_get_f) (
    int unit,
    dnx_data_field_fem_feature_e feature);

/**
 * \brief returns define data of max_nof_key_selects_per_field_io
 * Module - 'field', Submodule - 'fem', data - 'max_nof_key_selects_per_field_io'
 * Number of key selects in table for each field IO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_key_selects_per_field_io - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_fem_max_nof_key_selects_per_field_io_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_condition_bits
 * Module - 'field', Submodule - 'fem', data - 'nof_condition_bits'
 * Number of condition bits in FEM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_condition_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_fem_nof_condition_bits_get_f) (
    int unit);

/**
 * \brief get table key_select_properties entry 
 * The properties of the different key select options
 * 
 * \param [in] unit - unit #
 * \param [in] field_io - Identifies the source of the information
 * 
 * \return
 *     key_select_properties - returns the relevant entry values grouped in struct - see dnx_data_field_fem_key_select_properties_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_fem_key_select_properties_t *(
    *dnx_data_field_fem_key_select_properties_get_f) (
    int unit,
    int field_io);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - FEM:
 * {
 */
/**
 * \brief Interface for field fem data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_fem_feature_get_f feature_get;
    /**
     * returns define data of max_nof_key_selects_per_field_io
     */
    dnx_data_field_fem_max_nof_key_selects_per_field_io_get_f max_nof_key_selects_per_field_io_get;
    /**
     * returns numeric data of nof_condition_bits
     */
    dnx_data_field_fem_nof_condition_bits_get_f nof_condition_bits_get;
    /**
     * get table key_select_properties entry 
     */
    dnx_data_field_fem_key_select_properties_get_f key_select_properties_get;
    /**
     * get general info table about table (for example key size)key_select_properties info
     */
    dnxc_data_table_info_get_f key_select_properties_info_get;
} dnx_data_if_field_fem_t;

/*
 * }
 */

/*
 * SUBMODULE  - CONTEXT:
 * Field Context
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_context_feature_nof
} dnx_data_field_context_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_context_feature_get_f) (
    int unit,
    dnx_data_field_context_feature_e feature);

/**
 * \brief returns define data of default_context
 * Module - 'field', Submodule - 'context', data - 'default_context'
 * Default Context Id (used for Ethernet Packets)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_context'
 * Default Context Id for ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_itmh_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_pph_context'
 * Default Context Id for ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_itmh_pph_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_ipmf2_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_pph_ipmf2_context'
 * IPMF2 Context Id for ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_ipmf2_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_itmh_pph_ipmf2_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_1588_tsh_context
 * Module - 'field', Submodule - 'context', data - 'default_itmh_1588_tsh_context'
 * Default Context Id for ITMH_1588v2_TSH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_1588_tsh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_itmh_1588_tsh_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_context'
 * Default Context Id for J1 ITMH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_j1_itmh_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_itmh_pph_context'
 * Default Context Id for J1 ITMH_PPH Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_j1_itmh_pph_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_context'
 * Default Context Id for OAM Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_oam_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_reflector_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_reflector_context'
 * Default Context Id for OAM downmep reflector Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_reflector_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_oam_reflector_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_upmep_context
 * Module - 'field', Submodule - 'context', data - 'default_oam_upmep_context'
 * Default Context Id for OAM upmep Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_upmep_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_oam_upmep_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_learning_2ndpass_context
 * Module - 'field', Submodule - 'context', data - 'default_j1_learning_2ndpass_context'
 * Default Context Id for 2nd pass of J1 Learning flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learning_2ndpass_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_j1_learning_2ndpass_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_rch_remove_context
 * Module - 'field', Submodule - 'context', data - 'default_rch_remove_context'
 * Default Context Id for packets with RCH header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_rch_remove_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_rch_remove_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_rch_extended_encap_context
 * Module - 'field', Submodule - 'context', data - 'default_rch_extended_encap_context'
 * Default Context Id for packets of RCH extended encapsulation application
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_rch_extended_encap_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_rch_extended_encap_context_get_f) (
    int unit);

/**
 * \brief returns define data of default_nat_context
 * Module - 'field', Submodule - 'context', data - 'default_nat_context'
 * Default Context Id for NAT packets.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_nat_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_default_nat_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_hash_keys
 * Module - 'field', Submodule - 'context', data - 'nof_hash_keys'
 * Number of action keys per Hash Context.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hash_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_context_nof_hash_keys_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - CONTEXT:
 * {
 */
/**
 * \brief Interface for field context data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_context_feature_get_f feature_get;
    /**
     * returns define data of default_context
     */
    dnx_data_field_context_default_context_get_f default_context_get;
    /**
     * returns define data of default_itmh_context
     */
    dnx_data_field_context_default_itmh_context_get_f default_itmh_context_get;
    /**
     * returns define data of default_itmh_pph_context
     */
    dnx_data_field_context_default_itmh_pph_context_get_f default_itmh_pph_context_get;
    /**
     * returns define data of default_itmh_pph_ipmf2_context
     */
    dnx_data_field_context_default_itmh_pph_ipmf2_context_get_f default_itmh_pph_ipmf2_context_get;
    /**
     * returns define data of default_itmh_1588_tsh_context
     */
    dnx_data_field_context_default_itmh_1588_tsh_context_get_f default_itmh_1588_tsh_context_get;
    /**
     * returns define data of default_j1_itmh_context
     */
    dnx_data_field_context_default_j1_itmh_context_get_f default_j1_itmh_context_get;
    /**
     * returns define data of default_j1_itmh_pph_context
     */
    dnx_data_field_context_default_j1_itmh_pph_context_get_f default_j1_itmh_pph_context_get;
    /**
     * returns define data of default_oam_context
     */
    dnx_data_field_context_default_oam_context_get_f default_oam_context_get;
    /**
     * returns define data of default_oam_reflector_context
     */
    dnx_data_field_context_default_oam_reflector_context_get_f default_oam_reflector_context_get;
    /**
     * returns define data of default_oam_upmep_context
     */
    dnx_data_field_context_default_oam_upmep_context_get_f default_oam_upmep_context_get;
    /**
     * returns define data of default_j1_learning_2ndpass_context
     */
    dnx_data_field_context_default_j1_learning_2ndpass_context_get_f default_j1_learning_2ndpass_context_get;
    /**
     * returns define data of default_rch_remove_context
     */
    dnx_data_field_context_default_rch_remove_context_get_f default_rch_remove_context_get;
    /**
     * returns define data of default_rch_extended_encap_context
     */
    dnx_data_field_context_default_rch_extended_encap_context_get_f default_rch_extended_encap_context_get;
    /**
     * returns define data of default_nat_context
     */
    dnx_data_field_context_default_nat_context_get_f default_nat_context_get;
    /**
     * returns define data of nof_hash_keys
     */
    dnx_data_field_context_nof_hash_keys_get_f nof_hash_keys_get;
} dnx_data_if_field_context_t;

/*
 * }
 */

/*
 * SUBMODULE  - PRESELECTOR:
 * Field Presel
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_preselector_feature_nof
} dnx_data_field_preselector_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_preselector_feature_get_f) (
    int unit,
    dnx_data_field_preselector_feature_e feature);

/**
 * \brief returns define data of default_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf2
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf2'
 * Default Presel Id in iPMF2 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf2_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_1588_tsh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_1588_tsh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMHoASE-1588v2oTSH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_1588_tsh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_1588_tsh_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_oamp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_oamp_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J2oPPH_J2 injected Packets from OAMP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_oamp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_pph_oamp_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_oamp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_oamp_presel_id_ipmf1'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets from OAMP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_oamp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_pph_oamp_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_learn_presel_id_1st_pass_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_learn_presel_id_1st_pass_ipmf1'
 * Default Presel in iPMF1 Learn 1st Pass
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learn_presel_id_1st_pass_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_learn_presel_id_1st_pass_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_learn_presel_id_2nd_pass_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_learn_presel_id_2nd_pass_ipmf1'
 * Default Presel in iPMF1 Learn 2nd Pass
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_learn_presel_id_2nd_pass_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_learn_presel_id_2nd_pass_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_nat_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'default_nat_presel_id_ipmf1'
 * Default Presel in iPMF1 NAT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_nat_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_nat_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_beyond_minus_fwd_layer_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_beyond_minus_fwd_layer_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for srv6 beyond_minus_fwd_layer
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_beyond_minus_fwd_layer_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_beyond_minus_fwd_layer_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_beyond_minus_2_with_mpls_fwd_layer_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_beyond_minus_2_with_mpls_fwd_layer_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for srv6 beyond_minus_2_with_mpls_fwd_layer
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_beyond_minus_2_with_mpls_fwd_layer_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_beyond_minus_2_with_mpls_fwd_layer_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_psp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_psp_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for endpoint_psp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_psp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_psp_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_psp_extended_cut_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_psp_extended_cut_presel_id_ipmf1'
 * Default Presel Id in iPMF1 Id for endpoint_psp_extended
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_psp_extended_cut_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_psp_extended_cut_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_usp_extended_cut_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_usp_extended_cut_presel_id_ipmf1'
 * Default Presel Id in iPMF1 Id for egress_usp_extended
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_usp_extended_cut_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_usp_extended_cut_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_usp_udp_extended_cut_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_usp_udp_extended_cut_presel_id_ipmf1'
 * Default Presel Id in iPMF1 Id for egress_usp_extended
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_usp_udp_extended_cut_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_usp_udp_extended_cut_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_classic_endpoint_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_classic_endpoint_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for classic_endpoint
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_classic_endpoint_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_classic_endpoint_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_egress_usp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_egress_usp_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for egress_usp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_egress_usp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_egress_usp_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_egress_usp_udp_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_egress_usp_udp_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for egress_usp udp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_egress_usp_udp_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_egress_usp_udp_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_usid_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_usid_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for endpoint_usid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_usid_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_usid_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_gsid_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_gsid_presel_id_ipmf1'
 * Default Presel in iPMF1 Id for endpoint_gsid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_gsid_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_gsid_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_egress_usd_presel_id_ipmf1
 * Module - 'field', Submodule - 'preselector', data - 'srv6_egress_usd_presel_id_ipmf1'
 * Default Presel Id in iPMF1 Id for egress usd
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_egress_usd_presel_id_ipmf1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_egress_usd_presel_id_ipmf1_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_ipmf3'
 * Default Presel Id in iPMF1 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_itmh_pph_presel_id_2nd_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_itmh_pph_presel_id_2nd_ipmf3'
 * Default 2nd Presel Id in iPMF1 for ITMHoPPH injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_itmh_pph_presel_id_2nd_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_itmh_pph_presel_id_2nd_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_itmh_pph_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_itmh_pph_presel_id_ipmf3'
 * Default Presel Id in iPMF1 for ITMH_J1oPPH_J1 injected Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_itmh_pph_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_roo_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_roo_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 with ROO Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_roo_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_roo_ipv4_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_roo_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_roo_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 with ROO Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_roo_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_roo_ipv6_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 without ROO Packets no RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 without ROO Packets no RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 without ROO Packets with RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 without ROO Packets with RIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_ipv4_mc_in_lif_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_ipv4_mc_in_lif_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv4 MC Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_ipv4_mc_in_lif_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_ipv4_mc_in_lif_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_ipv6_mc_in_lif_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_ipv6_mc_in_lif_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for IPv6 MC Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_ipv6_mc_in_lif_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_ipv6_mc_in_lif_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_rch_remove_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_rch_remove_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for packets with RCH header
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_rch_remove_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_rch_remove_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_rch_extended_encap_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_rch_extended_encap_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for RCH extended encapsulation application
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_rch_extended_encap_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_rch_extended_encap_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_php_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_php_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for MPLS PHP Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_php_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_php_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_swap_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_swap_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for MPLS SWAP Packets
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_swap_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_swap_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_partial_fwd_layer_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_partial_fwd_layer_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for partial_fwd_layer
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_partial_fwd_layer_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_partial_fwd_layer_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_usid_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_usid_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for endpoint_usid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_usid_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_usid_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_gsid_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_gsid_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for endpoint_gsid
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_gsid_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_gsid_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_psp_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_psp_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for endpoint_psp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_psp_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_psp_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_egress_usp_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_egress_usp_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for egress_usp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_egress_usp_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_egress_usp_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_classic_endpoint_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_classic_endpoint_presel_id_ipmf3'
 * Default Presel in iPMF3 Id for classic_endpoint
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_classic_endpoint_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_classic_endpoint_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_psp_extended_cut_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_psp_extended_cut_presel_id_ipmf3'
 * Default Presel Id in iPMF3 Id for endpoint_psp_extended
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_psp_extended_cut_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_psp_extended_cut_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_usp_extended_cut_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_usp_extended_cut_presel_id_ipmf3'
 * Default Presel Id in iPMF3 Id for endpoint_psp_extended
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_usp_extended_cut_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_usp_extended_cut_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_egress_usd_presel_id_ipmf3
 * Module - 'field', Submodule - 'preselector', data - 'srv6_egress_usd_presel_id_ipmf3'
 * Default Presel Id in iPMF3 Id for egress usd
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_egress_usd_presel_id_ipmf3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_egress_usd_presel_id_ipmf3_get_f) (
    int unit);

/**
 * \brief returns define data of ebtr_const_fwd_layer_eth_epmf
 * Module - 'field', Submodule - 'preselector', data - 'ebtr_const_fwd_layer_eth_epmf'
 * estimated btr value for fwd layer ethernet prsel in ePMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ebtr_const_fwd_layer_eth_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_ebtr_const_fwd_layer_eth_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_ext_termination_btr_epmf
 * Module - 'field', Submodule - 'preselector', data - 'srv6_ext_termination_btr_epmf'
 * estimated btr value for srv6 extended termination in ePMF, using UDH input
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_ext_termination_btr_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_ext_termination_btr_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of default_j1_same_port_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'default_j1_same_port_presel_id_epmf'
 * Default Presel in ePMF Same port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_j1_same_port_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_j1_same_port_presel_id_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of default_learn_limit_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'default_learn_limit_presel_id_epmf'
 * Default Presel in ePMF Learn
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_learn_limit_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_learn_limit_presel_id_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of srv6_endpoint_psp_bta_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'srv6_endpoint_psp_bta_presel_id_epmf'
 * Default Presel in iPMF3 Id for endpoint_psp_bta
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     srv6_endpoint_psp_bta_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_srv6_endpoint_psp_bta_presel_id_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of default_mpls_8b_fhei_presel_id_epmf
 * Module - 'field', Submodule - 'preselector', data - 'default_mpls_8b_fhei_presel_id_epmf'
 * Default Presel in ePMF Id for MPLS 8B FHEI
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_mpls_8b_fhei_presel_id_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_default_mpls_8b_fhei_presel_id_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of num_cs_inlif_profile_entries
 * Module - 'field', Submodule - 'preselector', data - 'num_cs_inlif_profile_entries'
 * The number of CS entries which are used for inlif profile mapping
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     num_cs_inlif_profile_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_preselector_num_cs_inlif_profile_entries_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - PRESELECTOR:
 * {
 */
/**
 * \brief Interface for field preselector data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_preselector_feature_get_f feature_get;
    /**
     * returns define data of default_itmh_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_itmh_presel_id_ipmf1_get_f default_itmh_presel_id_ipmf1_get;
    /**
     * returns define data of default_itmh_pph_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf1_get_f default_itmh_pph_presel_id_ipmf1_get;
    /**
     * returns define data of default_itmh_pph_presel_id_ipmf2
     */
    dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf2_get_f default_itmh_pph_presel_id_ipmf2_get;
    /**
     * returns define data of default_itmh_1588_tsh_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_itmh_1588_tsh_presel_id_ipmf1_get_f default_itmh_1588_tsh_presel_id_ipmf1_get;
    /**
     * returns define data of default_itmh_pph_oamp_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_itmh_pph_oamp_presel_id_ipmf1_get_f default_itmh_pph_oamp_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_itmh_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_j1_itmh_presel_id_ipmf1_get_f default_j1_itmh_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_itmh_pph_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf1_get_f default_j1_itmh_pph_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_itmh_pph_oamp_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_j1_itmh_pph_oamp_presel_id_ipmf1_get_f default_j1_itmh_pph_oamp_presel_id_ipmf1_get;
    /**
     * returns define data of default_j1_learn_presel_id_1st_pass_ipmf1
     */
    dnx_data_field_preselector_default_j1_learn_presel_id_1st_pass_ipmf1_get_f default_j1_learn_presel_id_1st_pass_ipmf1_get;
    /**
     * returns define data of default_j1_learn_presel_id_2nd_pass_ipmf1
     */
    dnx_data_field_preselector_default_j1_learn_presel_id_2nd_pass_ipmf1_get_f default_j1_learn_presel_id_2nd_pass_ipmf1_get;
    /**
     * returns define data of default_nat_presel_id_ipmf1
     */
    dnx_data_field_preselector_default_nat_presel_id_ipmf1_get_f default_nat_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_beyond_minus_fwd_layer_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_beyond_minus_fwd_layer_presel_id_ipmf1_get_f srv6_beyond_minus_fwd_layer_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_beyond_minus_2_with_mpls_fwd_layer_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_beyond_minus_2_with_mpls_fwd_layer_presel_id_ipmf1_get_f srv6_beyond_minus_2_with_mpls_fwd_layer_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_endpoint_psp_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_endpoint_psp_presel_id_ipmf1_get_f srv6_endpoint_psp_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_endpoint_psp_extended_cut_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_endpoint_psp_extended_cut_presel_id_ipmf1_get_f srv6_endpoint_psp_extended_cut_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_endpoint_usp_extended_cut_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_endpoint_usp_extended_cut_presel_id_ipmf1_get_f srv6_endpoint_usp_extended_cut_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_endpoint_usp_udp_extended_cut_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_endpoint_usp_udp_extended_cut_presel_id_ipmf1_get_f srv6_endpoint_usp_udp_extended_cut_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_classic_endpoint_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_classic_endpoint_presel_id_ipmf1_get_f srv6_classic_endpoint_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_egress_usp_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_egress_usp_presel_id_ipmf1_get_f srv6_egress_usp_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_egress_usp_udp_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_egress_usp_udp_presel_id_ipmf1_get_f srv6_egress_usp_udp_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_endpoint_usid_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_endpoint_usid_presel_id_ipmf1_get_f srv6_endpoint_usid_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_endpoint_gsid_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_endpoint_gsid_presel_id_ipmf1_get_f srv6_endpoint_gsid_presel_id_ipmf1_get;
    /**
     * returns define data of srv6_egress_usd_presel_id_ipmf1
     */
    dnx_data_field_preselector_srv6_egress_usd_presel_id_ipmf1_get_f srv6_egress_usd_presel_id_ipmf1_get;
    /**
     * returns define data of default_itmh_pph_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_itmh_pph_presel_id_ipmf3_get_f default_itmh_pph_presel_id_ipmf3_get;
    /**
     * returns define data of default_itmh_pph_presel_id_2nd_ipmf3
     */
    dnx_data_field_preselector_default_itmh_pph_presel_id_2nd_ipmf3_get_f default_itmh_pph_presel_id_2nd_ipmf3_get;
    /**
     * returns define data of default_j1_itmh_pph_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_itmh_pph_presel_id_ipmf3_get_f default_j1_itmh_pph_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_roo_ipv4_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_roo_ipv4_presel_id_ipmf3_get_f default_oam_roo_ipv4_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_roo_ipv6_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_roo_ipv6_presel_id_ipmf3_get_f default_oam_roo_ipv6_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3_get_f default_oam_w_o_roo_no_rif_ipv4_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3_get_f default_oam_w_o_roo_no_rif_ipv6_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3_get_f default_oam_w_o_roo_with_rif_ipv4_presel_id_ipmf3_get;
    /**
     * returns define data of default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3_get_f default_oam_w_o_roo_with_rif_ipv6_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_ipv4_mc_in_lif_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_ipv4_mc_in_lif_presel_id_ipmf3_get_f default_j1_ipv4_mc_in_lif_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_ipv6_mc_in_lif_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_ipv6_mc_in_lif_presel_id_ipmf3_get_f default_j1_ipv6_mc_in_lif_presel_id_ipmf3_get;
    /**
     * returns define data of default_rch_remove_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_rch_remove_presel_id_ipmf3_get_f default_rch_remove_presel_id_ipmf3_get;
    /**
     * returns define data of default_rch_extended_encap_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_rch_extended_encap_presel_id_ipmf3_get_f default_rch_extended_encap_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_php_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_php_presel_id_ipmf3_get_f default_j1_php_presel_id_ipmf3_get;
    /**
     * returns define data of default_j1_swap_presel_id_ipmf3
     */
    dnx_data_field_preselector_default_j1_swap_presel_id_ipmf3_get_f default_j1_swap_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_partial_fwd_layer_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_partial_fwd_layer_presel_id_ipmf3_get_f srv6_partial_fwd_layer_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_endpoint_usid_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_endpoint_usid_presel_id_ipmf3_get_f srv6_endpoint_usid_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_endpoint_gsid_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_endpoint_gsid_presel_id_ipmf3_get_f srv6_endpoint_gsid_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_endpoint_psp_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_endpoint_psp_presel_id_ipmf3_get_f srv6_endpoint_psp_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_egress_usp_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_egress_usp_presel_id_ipmf3_get_f srv6_egress_usp_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_classic_endpoint_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_classic_endpoint_presel_id_ipmf3_get_f srv6_classic_endpoint_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_endpoint_psp_extended_cut_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_endpoint_psp_extended_cut_presel_id_ipmf3_get_f srv6_endpoint_psp_extended_cut_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_endpoint_usp_extended_cut_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_endpoint_usp_extended_cut_presel_id_ipmf3_get_f srv6_endpoint_usp_extended_cut_presel_id_ipmf3_get;
    /**
     * returns define data of srv6_egress_usd_presel_id_ipmf3
     */
    dnx_data_field_preselector_srv6_egress_usd_presel_id_ipmf3_get_f srv6_egress_usd_presel_id_ipmf3_get;
    /**
     * returns define data of ebtr_const_fwd_layer_eth_epmf
     */
    dnx_data_field_preselector_ebtr_const_fwd_layer_eth_epmf_get_f ebtr_const_fwd_layer_eth_epmf_get;
    /**
     * returns define data of srv6_ext_termination_btr_epmf
     */
    dnx_data_field_preselector_srv6_ext_termination_btr_epmf_get_f srv6_ext_termination_btr_epmf_get;
    /**
     * returns define data of default_j1_same_port_presel_id_epmf
     */
    dnx_data_field_preselector_default_j1_same_port_presel_id_epmf_get_f default_j1_same_port_presel_id_epmf_get;
    /**
     * returns define data of default_learn_limit_presel_id_epmf
     */
    dnx_data_field_preselector_default_learn_limit_presel_id_epmf_get_f default_learn_limit_presel_id_epmf_get;
    /**
     * returns define data of srv6_endpoint_psp_bta_presel_id_epmf
     */
    dnx_data_field_preselector_srv6_endpoint_psp_bta_presel_id_epmf_get_f srv6_endpoint_psp_bta_presel_id_epmf_get;
    /**
     * returns define data of default_mpls_8b_fhei_presel_id_epmf
     */
    dnx_data_field_preselector_default_mpls_8b_fhei_presel_id_epmf_get_f default_mpls_8b_fhei_presel_id_epmf_get;
    /**
     * returns define data of num_cs_inlif_profile_entries
     */
    dnx_data_field_preselector_num_cs_inlif_profile_entries_get_f num_cs_inlif_profile_entries_get;
} dnx_data_if_field_preselector_t;

/*
 * }
 */

/*
 * SUBMODULE  - QUAL:
 * User Defined Data Qualifiers
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule qual table params
 * Table info:
 * Per stage Per qualifier properties
 */
typedef struct
{
    /**
     * offset on PBUS
     */
    int offset;
    /**
     * signal representing specific qualifier on stage entry
     */
    char *signal;
} dnx_data_field_qual_params_t;

/**
 * \brief Holds values of submodule qual table layer_record_info_ingress
 * Table info:
 * Information about layer record qualifiers in the ingress
 */
typedef struct
{
    /**
     * Whether the layer record is supported on the device
     */
    int valid;
    /**
     * The size of the qualifier in bits
     */
    int size;
    /**
     * The lsb of the qualifier within the layer record
     */
    int offset;
} dnx_data_field_qual_layer_record_info_ingress_t;

/**
 * \brief Holds values of submodule qual table layer_record_info_egress
 * Table info:
 * Information about layer record qualifiers in the egress
 */
typedef struct
{
    /**
     * Whether the layer record is supported on the device
     */
    int valid;
    /**
     * The size of the qualifier in bits
     */
    int size;
    /**
     * The lsb of the qualifier within the layer record
     */
    int offset;
} dnx_data_field_qual_layer_record_info_egress_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_qual_feature_nof
} dnx_data_field_qual_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_qual_feature_get_f) (
    int unit,
    dnx_data_field_qual_feature_e feature);

/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'qual', data - 'user_1st'
 * First User qualifier id to avoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_user_1st_get_f) (
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'qual', data - 'user_nof'
 * Number of User Define Data qualifiers that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_user_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vw_1st
 * Module - 'field', Submodule - 'qual', data - 'vw_1st'
 * First VW qualifier id to avoid overlapping with static or user defined qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_vw_1st_get_f) (
    int unit);

/**
 * \brief returns define data of vw_nof
 * Module - 'field', Submodule - 'qual', data - 'vw_nof'
 * Number of VW qualifiers that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_vw_nof_get_f) (
    int unit);

/**
 * \brief returns define data of max_bits_in_qual
 * Module - 'field', Submodule - 'qual', data - 'max_bits_in_qual'
 * Maximum number of bits that any qualifier can have
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_bits_in_qual - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_max_bits_in_qual_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'ingress_pbus_header_length'
 * Number of bits reserved in ingress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ingress_pbus_header_length_get_f) (
    int unit);

/**
 * \brief returns define data of egress_pbus_header_length
 * Module - 'field', Submodule - 'qual', data - 'egress_pbus_header_length'
 * Number of bits reserved in egress PBUS for header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_pbus_header_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_egress_pbus_header_length_get_f) (
    int unit);

/**
 * \brief returns define data of ifwd2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ifwd2_pbus_size'
 * Number of bits in the PBUS of iFWD2
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ifwd2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ifwd2_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf1_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf1_pbus_size'
 * Number of bits in the PBUS of iPMF1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ipmf1_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf2_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf2_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf2_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ipmf2_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf3_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'ipmf3_pbus_size'
 * Number of bits in the PBUS of iPMF3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf3_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ipmf3_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of epmf_pbus_size
 * Module - 'field', Submodule - 'qual', data - 'epmf_pbus_size'
 * Number of bits in the PBUS of ePMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     epmf_pbus_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_epmf_pbus_size_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'ingress_nof_layer_records'
 * Number of layer records taken from the parser in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ingress_nof_layer_records_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'ingress_layer_record_size'
 * Number of bits in each layer record in ingress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_ingress_layer_record_size_get_f) (
    int unit);

/**
 * \brief returns define data of egress_nof_layer_records
 * Module - 'field', Submodule - 'qual', data - 'egress_nof_layer_records'
 * Number of layer records taken from the parser in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_egress_nof_layer_records_get_f) (
    int unit);

/**
 * \brief returns define data of egress_layer_record_size
 * Module - 'field', Submodule - 'qual', data - 'egress_layer_record_size'
 * Number of bits in each layer record in egress stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egress_layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_egress_layer_record_size_get_f) (
    int unit);

/**
 * \brief returns define data of kbp_extra_offset_after_layer_record_offset
 * Module - 'field', Submodule - 'qual', data - 'kbp_extra_offset_after_layer_record_offset'
 * Number of extra bits to add after layer record offset for KBP only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbp_extra_offset_after_layer_record_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_qual_kbp_extra_offset_after_layer_record_offset_get_f) (
    int unit);

/**
 * \brief get table params entry 
 * Per stage Per qualifier properties
 * 
 * \param [in] unit - unit #
 * \param [in] stage - stage enum
 * \param [in] qual - dnx qualifier
 * 
 * \return
 *     params - returns the relevant entry values grouped in struct - see dnx_data_field_qual_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_qual_params_t *(
    *dnx_data_field_qual_params_get_f) (
    int unit,
    int stage,
    int qual);

/**
 * \brief get table layer_record_info_ingress entry 
 * Information about layer record qualifiers in the ingress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_ingress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_ingress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_qual_layer_record_info_ingress_t *(
    *dnx_data_field_qual_layer_record_info_ingress_get_f) (
    int unit,
    int layer_record);

/**
 * \brief get table layer_record_info_egress entry 
 * Information about layer record qualifiers in the egress
 * 
 * \param [in] unit - unit #
 * \param [in] layer_record - layer record enum
 * 
 * \return
 *     layer_record_info_egress - returns the relevant entry values grouped in struct - see dnx_data_field_qual_layer_record_info_egress_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_qual_layer_record_info_egress_t *(
    *dnx_data_field_qual_layer_record_info_egress_get_f) (
    int unit,
    int layer_record);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - QUAL:
 * {
 */
/**
 * \brief Interface for field qual data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_qual_feature_get_f feature_get;
    /**
     * returns define data of user_1st
     */
    dnx_data_field_qual_user_1st_get_f user_1st_get;
    /**
     * returns define data of user_nof
     */
    dnx_data_field_qual_user_nof_get_f user_nof_get;
    /**
     * returns define data of vw_1st
     */
    dnx_data_field_qual_vw_1st_get_f vw_1st_get;
    /**
     * returns define data of vw_nof
     */
    dnx_data_field_qual_vw_nof_get_f vw_nof_get;
    /**
     * returns define data of max_bits_in_qual
     */
    dnx_data_field_qual_max_bits_in_qual_get_f max_bits_in_qual_get;
    /**
     * returns define data of ingress_pbus_header_length
     */
    dnx_data_field_qual_ingress_pbus_header_length_get_f ingress_pbus_header_length_get;
    /**
     * returns define data of egress_pbus_header_length
     */
    dnx_data_field_qual_egress_pbus_header_length_get_f egress_pbus_header_length_get;
    /**
     * returns define data of ifwd2_pbus_size
     */
    dnx_data_field_qual_ifwd2_pbus_size_get_f ifwd2_pbus_size_get;
    /**
     * returns define data of ipmf1_pbus_size
     */
    dnx_data_field_qual_ipmf1_pbus_size_get_f ipmf1_pbus_size_get;
    /**
     * returns define data of ipmf2_pbus_size
     */
    dnx_data_field_qual_ipmf2_pbus_size_get_f ipmf2_pbus_size_get;
    /**
     * returns define data of ipmf3_pbus_size
     */
    dnx_data_field_qual_ipmf3_pbus_size_get_f ipmf3_pbus_size_get;
    /**
     * returns define data of epmf_pbus_size
     */
    dnx_data_field_qual_epmf_pbus_size_get_f epmf_pbus_size_get;
    /**
     * returns define data of ingress_nof_layer_records
     */
    dnx_data_field_qual_ingress_nof_layer_records_get_f ingress_nof_layer_records_get;
    /**
     * returns define data of ingress_layer_record_size
     */
    dnx_data_field_qual_ingress_layer_record_size_get_f ingress_layer_record_size_get;
    /**
     * returns define data of egress_nof_layer_records
     */
    dnx_data_field_qual_egress_nof_layer_records_get_f egress_nof_layer_records_get;
    /**
     * returns define data of egress_layer_record_size
     */
    dnx_data_field_qual_egress_layer_record_size_get_f egress_layer_record_size_get;
    /**
     * returns define data of kbp_extra_offset_after_layer_record_offset
     */
    dnx_data_field_qual_kbp_extra_offset_after_layer_record_offset_get_f kbp_extra_offset_after_layer_record_offset_get;
    /**
     * get table params entry 
     */
    dnx_data_field_qual_params_get_f params_get;
    /**
     * get general info table about table (for example key size)params info
     */
    dnxc_data_table_info_get_f params_info_get;
    /**
     * get table layer_record_info_ingress entry 
     */
    dnx_data_field_qual_layer_record_info_ingress_get_f layer_record_info_ingress_get;
    /**
     * get general info table about table (for example key size)layer_record_info_ingress info
     */
    dnxc_data_table_info_get_f layer_record_info_ingress_info_get;
    /**
     * get table layer_record_info_egress entry 
     */
    dnx_data_field_qual_layer_record_info_egress_get_f layer_record_info_egress_get;
    /**
     * get general info table about table (for example key size)layer_record_info_egress info
     */
    dnxc_data_table_info_get_f layer_record_info_egress_info_get;
} dnx_data_if_field_qual_t;

/*
 * }
 */

/*
 * SUBMODULE  - ACTION:
 * User Define Data Actions
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_action_feature_nof
} dnx_data_field_action_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_action_feature_get_f) (
    int unit,
    dnx_data_field_action_feature_e feature);

/**
 * \brief returns define data of user_1st
 * Module - 'field', Submodule - 'action', data - 'user_1st'
 * First user action id to avaoid overlapping with static ones
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_user_1st_get_f) (
    int unit);

/**
 * \brief returns define data of user_nof
 * Module - 'field', Submodule - 'action', data - 'user_nof'
 * Number of User Define Data actions that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     user_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_user_nof_get_f) (
    int unit);

/**
 * \brief returns define data of vw_1st
 * Module - 'field', Submodule - 'action', data - 'vw_1st'
 * First VW action id to avoid overlapping with static or user defined qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_1st - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_vw_1st_get_f) (
    int unit);

/**
 * \brief returns define data of vw_nof
 * Module - 'field', Submodule - 'action', data - 'vw_nof'
 * Number of VW action that can be created
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_action_vw_nof_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ACTION:
 * {
 */
/**
 * \brief Interface for field action data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_action_feature_get_f feature_get;
    /**
     * returns define data of user_1st
     */
    dnx_data_field_action_user_1st_get_f user_1st_get;
    /**
     * returns define data of user_nof
     */
    dnx_data_field_action_user_nof_get_f user_nof_get;
    /**
     * returns define data of vw_1st
     */
    dnx_data_field_action_vw_1st_get_f vw_1st_get;
    /**
     * returns define data of vw_nof
     */
    dnx_data_field_action_vw_nof_get_f vw_nof_get;
} dnx_data_if_field_action_t;

/*
 * }
 */

/*
 * SUBMODULE  - VIRTUAL_WIRE:
 * virtual_wires
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule virtual_wire table signal_mapping
 * Table info:
 * Per stage per signal, how it maps to standard 1 qualifiers and actions
 */
typedef struct
{
    /**
     * Name of the signal.
     */
    char *signal_name;
    /**
     * Standard 1 qualifier that correlates to the signal
     */
    int mapped_qual;
    /**
     * Offset on from the start of the standard 1 qualifier
     */
    int offset_from_qual;
    /**
     * Standard 1 action that correlates to the signal
     */
    int mapped_action[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF];
    /**
     * Offset on from the start of the signal for the action
     */
    int action_offset[DNX_DATA_MAX_FIELD_VIRTUAL_WIRE_ACTIONS_PER_SIGNAL_NOF];
} dnx_data_field_virtual_wire_signal_mapping_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates if the In_LIF_AC_WIDE data is set on VW or container
     */
    dnx_data_field_virtual_wire_in_lif_ac_wide_is_vw,

    /**
     * Must be last one!
     */
    _dnx_data_field_virtual_wire_feature_nof
} dnx_data_field_virtual_wire_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_virtual_wire_feature_get_f) (
    int unit,
    dnx_data_field_virtual_wire_feature_e feature);

/**
 * \brief returns define data of signals_nof
 * Module - 'field', Submodule - 'virtual_wire', data - 'signals_nof'
 * Number of elements in the table vw_quals.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     signals_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_signals_nof_get_f) (
    int unit);

/**
 * \brief returns define data of actions_per_signal_nof
 * Module - 'field', Submodule - 'virtual_wire', data - 'actions_per_signal_nof'
 * Maximum number of actions that write to a signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actions_per_signal_nof - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_actions_per_signal_nof_get_f) (
    int unit);

/**
 * \brief returns define data of general_data_user_general_containers_size
 * Module - 'field', Submodule - 'virtual_wire', data - 'general_data_user_general_containers_size'
 * The size in bits of the user_general part of the general_data (before the comp_general_data part).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     general_data_user_general_containers_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_general_data_user_general_containers_size_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf1_general_data_index
 * Module - 'field', Submodule - 'virtual_wire', data - 'ipmf1_general_data_index'
 * The index in signal_qual_mapping table of the general data signal for iPMF1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_general_data_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_virtual_wire_ipmf1_general_data_index_get_f) (
    int unit);

/**
 * \brief get table signal_mapping entry 
 * Per stage per signal, how it maps to standard 1 qualifiers and actions
 * 
 * \param [in] unit - unit #
 * \param [in] stage - stage enum
 * \param [in] signal_id - A local index for the entry
 * 
 * \return
 *     signal_mapping - returns the relevant entry values grouped in struct - see dnx_data_field_virtual_wire_signal_mapping_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_virtual_wire_signal_mapping_t *(
    *dnx_data_field_virtual_wire_signal_mapping_get_f) (
    int unit,
    int stage,
    int signal_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - VIRTUAL_WIRE:
 * {
 */
/**
 * \brief Interface for field virtual_wire data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_virtual_wire_feature_get_f feature_get;
    /**
     * returns define data of signals_nof
     */
    dnx_data_field_virtual_wire_signals_nof_get_f signals_nof_get;
    /**
     * returns define data of actions_per_signal_nof
     */
    dnx_data_field_virtual_wire_actions_per_signal_nof_get_f actions_per_signal_nof_get;
    /**
     * returns define data of general_data_user_general_containers_size
     */
    dnx_data_field_virtual_wire_general_data_user_general_containers_size_get_f general_data_user_general_containers_size_get;
    /**
     * returns define data of ipmf1_general_data_index
     */
    dnx_data_field_virtual_wire_ipmf1_general_data_index_get_f ipmf1_general_data_index_get;
    /**
     * get table signal_mapping entry 
     */
    dnx_data_field_virtual_wire_signal_mapping_get_f signal_mapping_get;
    /**
     * get general info table about table (for example key size)signal_mapping info
     */
    dnxc_data_table_info_get_f signal_mapping_info_get;
} dnx_data_if_field_virtual_wire_t;

/*
 * }
 */

/*
 * SUBMODULE  - PROFILE_BITS:
 * PMF Dedicated bits in profiles
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_profile_bits_feature_nof
} dnx_data_field_profile_bits_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_profile_bits_feature_get_f) (
    int unit,
    dnx_data_field_profile_bits_feature_e feature);

/**
 * \brief returns define data of ingress_pp_port_key_gen_var_size
 * Module - 'field', Submodule - 'profile_bits', data - 'ingress_pp_port_key_gen_var_size'
 * Number of bits available on the key_ken_per per PP port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_pp_port_key_gen_var_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_get_f) (
    int unit);

/**
 * \brief returns define data of max_port_profile_size
 * Module - 'field', Submodule - 'profile_bits', data - 'max_port_profile_size'
 * The maximum number in bits of all port profiles hw memories possible
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_port_profile_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_max_port_profile_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_port_profile
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_port_profile'
 * The number of bits used by the PMF for port profiles. Note that the actual number may be lower in some stages.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_port_profile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_bits_in_port_profile_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_ingress_pp_port_general_data
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_bits_in_ingress_pp_port_general_data'
 * The number of bits used by the PMF for per PP port general data.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ingress_pp_port_general_data - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_ing_in_lif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_in_lif'
 * Number of reserved bits for Ingress FP in in_lif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_in_lif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_ing_in_lif_get_f) (
    int unit);

/**
 * \brief returns numeric data of nof_ing_eth_rif
 * Module - 'field', Submodule - 'profile_bits', data - 'nof_ing_eth_rif'
 * Number of reserved bits for Ingress FP in in_rif_profile
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ing_eth_rif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_profile_bits_nof_ing_eth_rif_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - PROFILE_BITS:
 * {
 */
/**
 * \brief Interface for field profile_bits data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_profile_bits_feature_get_f feature_get;
    /**
     * returns define data of ingress_pp_port_key_gen_var_size
     */
    dnx_data_field_profile_bits_ingress_pp_port_key_gen_var_size_get_f ingress_pp_port_key_gen_var_size_get;
    /**
     * returns define data of max_port_profile_size
     */
    dnx_data_field_profile_bits_max_port_profile_size_get_f max_port_profile_size_get;
    /**
     * returns define data of nof_bits_in_port_profile
     */
    dnx_data_field_profile_bits_nof_bits_in_port_profile_get_f nof_bits_in_port_profile_get;
    /**
     * returns define data of nof_bits_in_ingress_pp_port_general_data
     */
    dnx_data_field_profile_bits_nof_bits_in_ingress_pp_port_general_data_get_f nof_bits_in_ingress_pp_port_general_data_get;
    /**
     * returns numeric data of nof_ing_in_lif
     */
    dnx_data_field_profile_bits_nof_ing_in_lif_get_f nof_ing_in_lif_get;
    /**
     * returns numeric data of nof_ing_eth_rif
     */
    dnx_data_field_profile_bits_nof_ing_eth_rif_get_f nof_ing_eth_rif_get;
} dnx_data_if_field_profile_bits_t;

/*
 * }
 */

/*
 * SUBMODULE  - DIR_EXT:
 * Direct Extraction Data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_dir_ext_feature_nof
} dnx_data_field_dir_ext_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_dir_ext_feature_get_f) (
    int unit,
    dnx_data_field_dir_ext_feature_e feature);

/**
 * \brief returns define data of half_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'half_key_size'
 * Half key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     half_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_dir_ext_half_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of single_key_size
 * Module - 'field', Submodule - 'dir_ext', data - 'single_key_size'
 * Single key size of direct extraction
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     single_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_dir_ext_single_key_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - DIR_EXT:
 * {
 */
/**
 * \brief Interface for field dir_ext data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_dir_ext_feature_get_f feature_get;
    /**
     * returns define data of half_key_size
     */
    dnx_data_field_dir_ext_half_key_size_get_f half_key_size_get;
    /**
     * returns define data of single_key_size
     */
    dnx_data_field_dir_ext_single_key_size_get_f single_key_size_get;
} dnx_data_if_field_dir_ext_t;

/*
 * }
 */

/*
 * SUBMODULE  - STATE_TABLE:
 * State Table data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_state_table_feature_nof
} dnx_data_field_state_table_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_state_table_feature_get_f) (
    int unit,
    dnx_data_field_state_table_feature_e feature);

/**
 * \brief returns define data of address_size_entry_max
 * Module - 'field', Submodule - 'state_table', data - 'address_size_entry_max'
 * Size of the address field in State Table in bits, for the case where the maximum size entry was chosen. Number of entries in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_size_entry_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_address_size_entry_max_get_f) (
    int unit);

/**
 * \brief returns define data of data_size_entry_max
 * Module - 'field', Submodule - 'state_table', data - 'data_size_entry_max'
 * Size of the DATA/ARGUMENT field in State Table in bits, for the case where the maximum size entry was chosen. Number of bits on the paylaod of the entry in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_size_entry_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_data_size_entry_max_get_f) (
    int unit);

/**
 * \brief returns define data of address_max_entry_max
 * Module - 'field', Submodule - 'state_table', data - 'address_max_entry_max'
 * Max address for the state table, for the case where the maximum size entry was chosen. Number of entries in HW.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_max_entry_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_address_max_entry_max_get_f) (
    int unit);

/**
 * \brief returns define data of wr_bit_size_rw
 * Module - 'field', Submodule - 'state_table', data - 'wr_bit_size_rw'
 * Size of wr bit field in state table interface in bits. Relevant for separate read write operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wr_bit_size_rw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_wr_bit_size_rw_get_f) (
    int unit);

/**
 * \brief returns define data of opcode_size_rmw
 * Module - 'field', Submodule - 'state_table', data - 'opcode_size_rmw'
 * Size of opcode field in state table interface in bits. Relevant for atomic read modify write operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     opcode_size_rmw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_opcode_size_rmw_get_f) (
    int unit);

/**
 * \brief returns numeric data of data_size
 * Module - 'field', Submodule - 'state_table', data - 'data_size'
 * Size of the data field in State Table in bits. Determined by SOC property.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_data_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of state_table_stage_key
 * Module - 'field', Submodule - 'state_table', data - 'state_table_stage_key'
 * Indication of the source of the key for the state table lookup. Determined by SOC property.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_stage_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_state_table_stage_key_get_f) (
    int unit);

/**
 * \brief returns numeric data of address_size
 * Module - 'field', Submodule - 'state_table', data - 'address_size'
 * Size of the address field in State Table in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_address_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of address_max
 * Module - 'field', Submodule - 'state_table', data - 'address_max'
 * Max address for the state table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     address_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_address_max_get_f) (
    int unit);

/**
 * \brief returns numeric data of wr_bit_size
 * Module - 'field', Submodule - 'state_table', data - 'wr_bit_size'
 * Size of wr bit field in state table interface in bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wr_bit_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_wr_bit_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of key_size
 * Module - 'field', Submodule - 'state_table', data - 'key_size'
 * Size of the state table key in the system. Changes between RW or RMW according to device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_state_table_key_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - STATE_TABLE:
 * {
 */
/**
 * \brief Interface for field state_table data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_state_table_feature_get_f feature_get;
    /**
     * returns define data of address_size_entry_max
     */
    dnx_data_field_state_table_address_size_entry_max_get_f address_size_entry_max_get;
    /**
     * returns define data of data_size_entry_max
     */
    dnx_data_field_state_table_data_size_entry_max_get_f data_size_entry_max_get;
    /**
     * returns define data of address_max_entry_max
     */
    dnx_data_field_state_table_address_max_entry_max_get_f address_max_entry_max_get;
    /**
     * returns define data of wr_bit_size_rw
     */
    dnx_data_field_state_table_wr_bit_size_rw_get_f wr_bit_size_rw_get;
    /**
     * returns define data of opcode_size_rmw
     */
    dnx_data_field_state_table_opcode_size_rmw_get_f opcode_size_rmw_get;
    /**
     * returns numeric data of data_size
     */
    dnx_data_field_state_table_data_size_get_f data_size_get;
    /**
     * returns numeric data of state_table_stage_key
     */
    dnx_data_field_state_table_state_table_stage_key_get_f state_table_stage_key_get;
    /**
     * returns numeric data of address_size
     */
    dnx_data_field_state_table_address_size_get_f address_size_get;
    /**
     * returns numeric data of address_max
     */
    dnx_data_field_state_table_address_max_get_f address_max_get;
    /**
     * returns numeric data of wr_bit_size
     */
    dnx_data_field_state_table_wr_bit_size_get_f wr_bit_size_get;
    /**
     * returns numeric data of key_size
     */
    dnx_data_field_state_table_key_size_get_f key_size_get;
} dnx_data_if_field_state_table_t;

/*
 * }
 */

/*
 * SUBMODULE  - MAP:
 * MAP data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_map_feature_nof
} dnx_data_field_map_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_map_feature_get_f) (
    int unit,
    dnx_data_field_map_feature_e feature);

/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'map', data - 'key_size'
 * Size of the MAP key in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of action_size_large
 * Module - 'field', Submodule - 'map', data - 'action_size_large'
 * Size of the large MAP action in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     action_size_large - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_action_size_large_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf1_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf1_key_select'
 * The PMF key used for MAP lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf1_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_ipmf1_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf2_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf2_key_select'
 * The PMF key used for MAP lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf2_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_ipmf2_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of ipmf3_key_select
 * Module - 'field', Submodule - 'map', data - 'ipmf3_key_select'
 * The PMF key used for MAP lookup by iPMF3. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ipmf3_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_ipmf3_key_select_get_f) (
    int unit);

/**
 * \brief returns numeric data of pmf_map_stage
 * Module - 'field', Submodule - 'map', data - 'pmf_map_stage'
 * Determines using SOC property if we use MAP in iPMF1/iPMF2 or iPMF3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_map_stage - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_map_pmf_map_stage_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - MAP:
 * {
 */
/**
 * \brief Interface for field map data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_map_feature_get_f feature_get;
    /**
     * returns define data of key_size
     */
    dnx_data_field_map_key_size_get_f key_size_get;
    /**
     * returns define data of action_size_large
     */
    dnx_data_field_map_action_size_large_get_f action_size_large_get;
    /**
     * returns define data of ipmf1_key_select
     */
    dnx_data_field_map_ipmf1_key_select_get_f ipmf1_key_select_get;
    /**
     * returns define data of ipmf2_key_select
     */
    dnx_data_field_map_ipmf2_key_select_get_f ipmf2_key_select_get;
    /**
     * returns define data of ipmf3_key_select
     */
    dnx_data_field_map_ipmf3_key_select_get_f ipmf3_key_select_get;
    /**
     * returns numeric data of pmf_map_stage
     */
    dnx_data_field_map_pmf_map_stage_get_f pmf_map_stage_get;
} dnx_data_if_field_map_t;

/*
 * }
 */

/*
 * SUBMODULE  - HASH:
 * Hash (CRC) values
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_hash_feature_nof
} dnx_data_field_hash_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_hash_feature_get_f) (
    int unit,
    dnx_data_field_hash_feature_e feature);

/**
 * \brief returns define data of max_key_size
 * Module - 'field', Submodule - 'hash', data - 'max_key_size'
 * maximal key size Field Group type 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_hash_max_key_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - HASH:
 * {
 */
/**
 * \brief Interface for field hash data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_hash_feature_get_f feature_get;
    /**
     * returns define data of max_key_size
     */
    dnx_data_field_hash_max_key_size_get_f max_key_size_get;
} dnx_data_if_field_hash_t;

/*
 * }
 */

/*
 * SUBMODULE  - UDH:
 * User Defined Headers defines
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_udh_feature_nof
} dnx_data_field_udh_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_udh_feature_get_f) (
    int unit,
    dnx_data_field_udh_feature_e feature);

/**
 * \brief returns define data of type_count
 * Module - 'field', Submodule - 'udh', data - 'type_count'
 * UDH Type count
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_count - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_count_get_f) (
    int unit);

/**
 * \brief returns define data of type_0_length
 * Module - 'field', Submodule - 'udh', data - 'type_0_length'
 * UDH Type 0 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_0_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_0_length_get_f) (
    int unit);

/**
 * \brief returns define data of type_1_length
 * Module - 'field', Submodule - 'udh', data - 'type_1_length'
 * UDH Type 1 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_1_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_1_length_get_f) (
    int unit);

/**
 * \brief returns define data of type_2_length
 * Module - 'field', Submodule - 'udh', data - 'type_2_length'
 * UDH Type 2 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_2_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_2_length_get_f) (
    int unit);

/**
 * \brief returns define data of type_3_length
 * Module - 'field', Submodule - 'udh', data - 'type_3_length'
 * UDH Type 3 length in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     type_3_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_type_3_length_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_0
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_0'
 * J1 Mode UDH related size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_0 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_0_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_1
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_1'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_1_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_2
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_2'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_2_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_size_3
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_size_3'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_size_3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_size_3_get_f) (
    int unit);

/**
 * \brief returns numeric data of field_class_id_total_size
 * Module - 'field', Submodule - 'udh', data - 'field_class_id_total_size'
 * J1 Mode UDH retlated size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     field_class_id_total_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_udh_field_class_id_total_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - UDH:
 * {
 */
/**
 * \brief Interface for field udh data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_udh_feature_get_f feature_get;
    /**
     * returns define data of type_count
     */
    dnx_data_field_udh_type_count_get_f type_count_get;
    /**
     * returns define data of type_0_length
     */
    dnx_data_field_udh_type_0_length_get_f type_0_length_get;
    /**
     * returns define data of type_1_length
     */
    dnx_data_field_udh_type_1_length_get_f type_1_length_get;
    /**
     * returns define data of type_2_length
     */
    dnx_data_field_udh_type_2_length_get_f type_2_length_get;
    /**
     * returns define data of type_3_length
     */
    dnx_data_field_udh_type_3_length_get_f type_3_length_get;
    /**
     * returns numeric data of field_class_id_size_0
     */
    dnx_data_field_udh_field_class_id_size_0_get_f field_class_id_size_0_get;
    /**
     * returns numeric data of field_class_id_size_1
     */
    dnx_data_field_udh_field_class_id_size_1_get_f field_class_id_size_1_get;
    /**
     * returns numeric data of field_class_id_size_2
     */
    dnx_data_field_udh_field_class_id_size_2_get_f field_class_id_size_2_get;
    /**
     * returns numeric data of field_class_id_size_3
     */
    dnx_data_field_udh_field_class_id_size_3_get_f field_class_id_size_3_get;
    /**
     * returns numeric data of field_class_id_total_size
     */
    dnx_data_field_udh_field_class_id_total_size_get_f field_class_id_total_size_get;
} dnx_data_if_field_udh_t;

/*
 * }
 */

/*
 * SUBMODULE  - SYSTEM_HEADERS:
 * System headers definitions
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule system_headers table system_header_profiles
 * Table info:
 * Contains all system headers profiles defined in this device
 */
typedef struct
{
    /**
     * profile name
     */
    char *name;
    /**
     * Defines whether to build FTMH header or not
     */
    uint8 build_ftmh;
    /**
     * Defines whether to build TSH header or not
     */
    uint8 build_tsh;
    /**
     * Defines whether to build PPH header or not
     */
    uint8 build_pph;
    /**
     * Defines whether to build UDH header or not
     */
    uint8 build_udh;
    /**
     * Defines whether to never add PPH Learn Ext.
     */
    uint8 never_add_pph_learn_ext;
} dnx_data_field_system_headers_system_header_profiles_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_system_headers_feature_nof
} dnx_data_field_system_headers_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_system_headers_feature_get_f) (
    int unit,
    dnx_data_field_system_headers_feature_e feature);

/**
 * \brief returns define data of nof_profiles
 * Module - 'field', Submodule - 'system_headers', data - 'nof_profiles'
 * Number of system headers in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_system_headers_nof_profiles_get_f) (
    int unit);

/**
 * \brief returns numeric data of pph_learn_ext_disable
 * Module - 'field', Submodule - 'system_headers', data - 'pph_learn_ext_disable'
 * Never add learn_ext in system headers unlesee FP required. Used by default header_profile only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pph_learn_ext_disable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_system_headers_pph_learn_ext_disable_get_f) (
    int unit);

/**
 * \brief get table system_header_profiles entry 
 * Contains all system headers profiles defined in this device
 * 
 * \param [in] unit - unit #
 * \param [in] system_header_profile - System header profile number
 * 
 * \return
 *     system_header_profiles - returns the relevant entry values grouped in struct - see dnx_data_field_system_headers_system_header_profiles_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_system_headers_system_header_profiles_t *(
    *dnx_data_field_system_headers_system_header_profiles_get_f) (
    int unit,
    int system_header_profile);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - SYSTEM_HEADERS:
 * {
 */
/**
 * \brief Interface for field system_headers data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_system_headers_feature_get_f feature_get;
    /**
     * returns define data of nof_profiles
     */
    dnx_data_field_system_headers_nof_profiles_get_f nof_profiles_get;
    /**
     * returns numeric data of pph_learn_ext_disable
     */
    dnx_data_field_system_headers_pph_learn_ext_disable_get_f pph_learn_ext_disable_get;
    /**
     * get table system_header_profiles entry 
     */
    dnx_data_field_system_headers_system_header_profiles_get_f system_header_profiles_get;
    /**
     * get general info table about table (for example key size)system_header_profiles info
     */
    dnxc_data_table_info_get_f system_header_profiles_info_get;
} dnx_data_if_field_system_headers_t;

/*
 * }
 */

/*
 * SUBMODULE  - EXEM:
 * exem values
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_feature_nof
} dnx_data_field_exem_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_exem_feature_get_f) (
    int unit,
    dnx_data_field_exem_feature_e feature);

/**
 * \brief returns define data of small_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'small_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_app_db_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_app_db_id_size
 * Module - 'field', Submodule - 'exem', data - 'large_app_db_id_size'
 * Number of bits used application db
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_app_db_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_key_size'
 * Small EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_key_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_key_size'
 * Large EXEM key size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_result_size'
 * Small EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_result_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_result_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_result_size'
 * Large EXEM result (payload) size in bits, including VMV
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_result_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_result_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'small_max_container_size'
 * Large EXEM maximal container size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_container_size_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_container_size
 * Module - 'field', Submodule - 'exem', data - 'large_max_container_size'
 * Large EXEM result (payload) size in bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_container_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_container_size_get_f) (
    int unit);

/**
 * \brief returns define data of small_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_min_app_db_id_range'
 * Small EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_min_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of large_min_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_min_app_db_id_range'
 * Large EXEM first APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_min_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_min_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of small_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'small_max_app_db_id_range'
 * Small EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_max_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of large_max_app_db_id_range
 * Module - 'field', Submodule - 'exem', data - 'large_max_app_db_id_range'
 * Large EXEM last APP_DB_ID allocated to PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_max_app_db_id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_max_app_db_id_range_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key'
 * The PMF key used for EXEM lookup by iPMF2. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_part
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_part'
 * The PMF key part used for EXEM lookup by iPMF2. 0 means the LSB half, 1 the MSB half.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_part - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_part_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_value
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_value'
 * The HW value to provide for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_hw_value_get_f) (
    int unit);

/**
 * \brief returns define data of small_ipmf2_key_hw_bits
 * Module - 'field', Submodule - 'exem', data - 'small_ipmf2_key_hw_bits'
 * The number of bits used by the HW for selecting small_ipmf2_key and small_ipmf2_key_part.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_ipmf2_key_hw_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_ipmf2_key_hw_bits_get_f) (
    int unit);

/**
 * \brief returns define data of large_ipmf1_key_configurable
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key_configurable'
 * Whether or not the EXEM key for iPMF1 can be configured on a chip wide basis.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key_configurable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_ipmf1_key_configurable_get_f) (
    int unit);

/**
 * \brief returns define data of large_ipmf1_key
 * Module - 'field', Submodule - 'exem', data - 'large_ipmf1_key'
 * The PMF key used for EXEM lookup by iPMF1. The value is the offset from the first key in the stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     large_ipmf1_key - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_large_ipmf1_key_get_f) (
    int unit);

/**
 * \brief returns define data of small_nof_flush_profiles
 * Module - 'field', Submodule - 'exem', data - 'small_nof_flush_profiles'
 * Small EXEM - number of flush profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     small_nof_flush_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_small_nof_flush_profiles_get_f) (
    int unit);

/**
 * \brief returns numeric data of pmf_sexem3_stage
 * Module - 'field', Submodule - 'exem', data - 'pmf_sexem3_stage'
 * Determines using SOC property if we use SEXEM3 in iPMF2 or iPMF3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pmf_sexem3_stage - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_pmf_sexem3_stage_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - EXEM:
 * {
 */
/**
 * \brief Interface for field exem data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_exem_feature_get_f feature_get;
    /**
     * returns define data of small_app_db_id_size
     */
    dnx_data_field_exem_small_app_db_id_size_get_f small_app_db_id_size_get;
    /**
     * returns define data of large_app_db_id_size
     */
    dnx_data_field_exem_large_app_db_id_size_get_f large_app_db_id_size_get;
    /**
     * returns define data of small_max_key_size
     */
    dnx_data_field_exem_small_max_key_size_get_f small_max_key_size_get;
    /**
     * returns define data of large_max_key_size
     */
    dnx_data_field_exem_large_max_key_size_get_f large_max_key_size_get;
    /**
     * returns define data of small_max_result_size
     */
    dnx_data_field_exem_small_max_result_size_get_f small_max_result_size_get;
    /**
     * returns define data of large_max_result_size
     */
    dnx_data_field_exem_large_max_result_size_get_f large_max_result_size_get;
    /**
     * returns define data of small_max_container_size
     */
    dnx_data_field_exem_small_max_container_size_get_f small_max_container_size_get;
    /**
     * returns define data of large_max_container_size
     */
    dnx_data_field_exem_large_max_container_size_get_f large_max_container_size_get;
    /**
     * returns define data of small_min_app_db_id_range
     */
    dnx_data_field_exem_small_min_app_db_id_range_get_f small_min_app_db_id_range_get;
    /**
     * returns define data of large_min_app_db_id_range
     */
    dnx_data_field_exem_large_min_app_db_id_range_get_f large_min_app_db_id_range_get;
    /**
     * returns define data of small_max_app_db_id_range
     */
    dnx_data_field_exem_small_max_app_db_id_range_get_f small_max_app_db_id_range_get;
    /**
     * returns define data of large_max_app_db_id_range
     */
    dnx_data_field_exem_large_max_app_db_id_range_get_f large_max_app_db_id_range_get;
    /**
     * returns define data of small_ipmf2_key
     */
    dnx_data_field_exem_small_ipmf2_key_get_f small_ipmf2_key_get;
    /**
     * returns define data of small_ipmf2_key_part
     */
    dnx_data_field_exem_small_ipmf2_key_part_get_f small_ipmf2_key_part_get;
    /**
     * returns define data of small_ipmf2_key_hw_value
     */
    dnx_data_field_exem_small_ipmf2_key_hw_value_get_f small_ipmf2_key_hw_value_get;
    /**
     * returns define data of small_ipmf2_key_hw_bits
     */
    dnx_data_field_exem_small_ipmf2_key_hw_bits_get_f small_ipmf2_key_hw_bits_get;
    /**
     * returns define data of large_ipmf1_key_configurable
     */
    dnx_data_field_exem_large_ipmf1_key_configurable_get_f large_ipmf1_key_configurable_get;
    /**
     * returns define data of large_ipmf1_key
     */
    dnx_data_field_exem_large_ipmf1_key_get_f large_ipmf1_key_get;
    /**
     * returns define data of small_nof_flush_profiles
     */
    dnx_data_field_exem_small_nof_flush_profiles_get_f small_nof_flush_profiles_get;
    /**
     * returns numeric data of pmf_sexem3_stage
     */
    dnx_data_field_exem_pmf_sexem3_stage_get_f pmf_sexem3_stage_get;
} dnx_data_if_field_exem_t;

/*
 * }
 */

/*
 * SUBMODULE  - EXEM_LEARN_FLUSH_MACHINE:
 * Inforamtion about the flush machine used for EXEM learning feature.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule exem_learn_flush_machine table sexem_flush_tcam_tcam_memories
 * Table info:
 * Holds the memories of the flush TCAM for SEXEM3
 */
typedef struct
{
    /**
     * memory name
     */
    soc_mem_t table_name;
    /**
     * 1 means rule is valid and should be used. 0 rule should not be checked.
     */
    soc_field_t valid;
    /**
     * The key value for entry to be compared.
     */
    soc_field_t entry_data;
    /**
     * The mask value for entry to be compared.
     */
    soc_field_t entry_mask;
    /**
     * The key value for SRC bits {MRQ,PIPE,SCAN}.
     */
    soc_field_t src_data;
    /**
     * The mask value for SRC bits {MRQ,PIPE,SCAN}.
     */
    soc_field_t src_mask;
    /**
     * The key value for the app_db_id of the entry.
     */
    soc_field_t appdb_id_data;
    /**
     * The mask value for the app_db_id of the entry.
     */
    soc_field_t appdb_id_mask;
    /**
     * The key value for accessed.
     */
    soc_field_t accessed_data;
    /**
     * The mask value for accessed.
     */
    soc_field_t accessed_mask;
} dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_t;

/**
 * \brief Holds values of submodule exem_learn_flush_machine table lexem_flush_tcam_tcam_memories
 * Table info:
 * Holds the memories of the flush TCAM for LEXEM
 */
typedef struct
{
    /**
     * memory name
     */
    soc_mem_t table_name;
    /**
     * 1 means rule is valid and should be used. 0 rule should not be checked.
     */
    soc_field_t valid;
    /**
     * The key value for entry to be compared.
     */
    soc_field_t entry_data;
    /**
     * The mask value for entry to be compared.
     */
    soc_field_t entry_mask;
    /**
     * The key value for SRC bits {MRQ,PIPE,SCAN}.
     */
    soc_field_t src_data;
    /**
     * The mask value for SRC bits {MRQ,PIPE,SCAN}.
     */
    soc_field_t src_mask;
    /**
     * The key value for the app_db_id of the entry.
     */
    soc_field_t appdb_id_data;
    /**
     * The mask value for the app_db_id of the entry.
     */
    soc_field_t appdb_id_mask;
    /**
     * The key value for accessed.
     */
    soc_field_t accessed_data;
    /**
     * The mask value for accessed.
     */
    soc_field_t accessed_mask;
} dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_t;

/**
 * \brief Holds values of submodule exem_learn_flush_machine table sexem_flush_tcam_data_rules
 * Table info:
 * Holds the memories of the flush DATA for SEXEM3
 */
typedef struct
{
    /**
     * memory name
     */
    soc_mem_t table_name;
    /**
     * command type.
     */
    soc_field_t command;
    /**
     * Payload for transplant action.
     */
    soc_field_t payload;
    /**
     * Mask for the payload in transplant action.
     */
    soc_field_t payload_mask;
} dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_t;

/**
 * \brief Holds values of submodule exem_learn_flush_machine table lexem_flush_tcam_data_rules
 * Table info:
 * Holds the memories of the flush DATA for LEXEM
 */
typedef struct
{
    /**
     * memory name
     */
    soc_mem_t table_name;
    /**
     * command type.
     */
    soc_field_t command;
    /**
     * Payload for transplant action.
     */
    soc_field_t payload;
    /**
     * Mask for the payload in transplant action.
     */
    soc_field_t payload_mask;
} dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_exem_learn_flush_machine_feature_nof
} dnx_data_field_exem_learn_flush_machine_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_exem_learn_flush_machine_feature_get_f) (
    int unit,
    dnx_data_field_exem_learn_flush_machine_feature_e feature);

/**
 * \brief returns define data of flush_machine_nof_entries
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'flush_machine_nof_entries'
 * Number of entries in the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_machine_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_flush_machine_nof_entries_get_f) (
    int unit);

/**
 * \brief returns define data of entry_extra_bits_for_hash
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'entry_extra_bits_for_hash'
 * Number of bits added to the exem entry size to account for the hash bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     entry_extra_bits_for_hash - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_entry_extra_bits_for_hash_get_f) (
    int unit);

/**
 * \brief returns define data of sexem_entry_max_size
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'sexem_entry_max_size'
 * Number of bits in HW that represent the SEXEM entry in the TCAM of the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_entry_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_sexem_entry_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of lexem_entry_max_size
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'lexem_entry_max_size'
 * Number of bits in HW that represent the LEXEM entry in the TCAM of the flush machine.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_entry_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_lexem_entry_max_size_get_f) (
    int unit);

/**
 * \brief returns define data of command_bit_transplant
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'command_bit_transplant'
 * The bit on the command field of the flush entry paylaod to set to change the payload of the EXEM entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_bit_transplant - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_command_bit_transplant_get_f) (
    int unit);

/**
 * \brief returns define data of command_bit_delete
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'command_bit_delete'
 * The bit on the command field of the flush entry paylaod to set to delete the EXEM entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_bit_delete - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_command_bit_delete_get_f) (
    int unit);

/**
 * \brief returns define data of command_bit_clear_hit_bit
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'command_bit_clear_hit_bit'
 * The bit on the command field of the flush entry paylaod to set to clear the hit bit of the EXEM entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_bit_clear_hit_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_command_bit_clear_hit_bit_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_source
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'nof_bits_source'
 * Number of bits in HW that represent the source field in the flush machine key.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_source - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_nof_bits_source_get_f) (
    int unit);

/**
 * \brief returns define data of source_bit_for_scan
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'source_bit_for_scan'
 * The bit on source field to indicate that the flush was activated by scan.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_bit_for_scan - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_source_bit_for_scan_get_f) (
    int unit);

/**
 * \brief returns define data of source_bit_for_pipe
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'source_bit_for_pipe'
 * The bit on source field to indicate that the flush was activated by pipe.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_bit_for_pipe - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_source_bit_for_pipe_get_f) (
    int unit);

/**
 * \brief returns define data of source_bit_for_mrq
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'source_bit_for_mrq'
 * The bit on source field to indicate that the flush was activated by MRQ.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_bit_for_mrq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_source_bit_for_mrq_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_accessed
 * Module - 'field', Submodule - 'exem_learn_flush_machine', data - 'nof_bits_accessed'
 * Number of bits in HW that represent the accessed field in the flush machine key (hit bit).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_accessed - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_exem_learn_flush_machine_nof_bits_accessed_get_f) (
    int unit);

/**
 * \brief get table sexem_flush_tcam_tcam_memories entry 
 * Holds the memories of the flush TCAM for SEXEM3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_flush_tcam_tcam_memories - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_t *(
    *dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_get_f) (
    int unit);

/**
 * \brief get table lexem_flush_tcam_tcam_memories entry 
 * Holds the memories of the flush TCAM for LEXEM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_flush_tcam_tcam_memories - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_t *(
    *dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_get_f) (
    int unit);

/**
 * \brief get table sexem_flush_tcam_data_rules entry 
 * Holds the memories of the flush DATA for SEXEM3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sexem_flush_tcam_data_rules - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_t *(
    *dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_get_f) (
    int unit);

/**
 * \brief get table lexem_flush_tcam_data_rules entry 
 * Holds the memories of the flush DATA for LEXEM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lexem_flush_tcam_data_rules - returns the relevant entry values grouped in struct - see dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_t *(
    *dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - EXEM_LEARN_FLUSH_MACHINE:
 * {
 */
/**
 * \brief Interface for field exem_learn_flush_machine data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_exem_learn_flush_machine_feature_get_f feature_get;
    /**
     * returns define data of flush_machine_nof_entries
     */
    dnx_data_field_exem_learn_flush_machine_flush_machine_nof_entries_get_f flush_machine_nof_entries_get;
    /**
     * returns define data of entry_extra_bits_for_hash
     */
    dnx_data_field_exem_learn_flush_machine_entry_extra_bits_for_hash_get_f entry_extra_bits_for_hash_get;
    /**
     * returns define data of sexem_entry_max_size
     */
    dnx_data_field_exem_learn_flush_machine_sexem_entry_max_size_get_f sexem_entry_max_size_get;
    /**
     * returns define data of lexem_entry_max_size
     */
    dnx_data_field_exem_learn_flush_machine_lexem_entry_max_size_get_f lexem_entry_max_size_get;
    /**
     * returns define data of command_bit_transplant
     */
    dnx_data_field_exem_learn_flush_machine_command_bit_transplant_get_f command_bit_transplant_get;
    /**
     * returns define data of command_bit_delete
     */
    dnx_data_field_exem_learn_flush_machine_command_bit_delete_get_f command_bit_delete_get;
    /**
     * returns define data of command_bit_clear_hit_bit
     */
    dnx_data_field_exem_learn_flush_machine_command_bit_clear_hit_bit_get_f command_bit_clear_hit_bit_get;
    /**
     * returns define data of nof_bits_source
     */
    dnx_data_field_exem_learn_flush_machine_nof_bits_source_get_f nof_bits_source_get;
    /**
     * returns define data of source_bit_for_scan
     */
    dnx_data_field_exem_learn_flush_machine_source_bit_for_scan_get_f source_bit_for_scan_get;
    /**
     * returns define data of source_bit_for_pipe
     */
    dnx_data_field_exem_learn_flush_machine_source_bit_for_pipe_get_f source_bit_for_pipe_get;
    /**
     * returns define data of source_bit_for_mrq
     */
    dnx_data_field_exem_learn_flush_machine_source_bit_for_mrq_get_f source_bit_for_mrq_get;
    /**
     * returns define data of nof_bits_accessed
     */
    dnx_data_field_exem_learn_flush_machine_nof_bits_accessed_get_f nof_bits_accessed_get;
    /**
     * get table sexem_flush_tcam_tcam_memories entry 
     */
    dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_tcam_memories_get_f sexem_flush_tcam_tcam_memories_get;
    /**
     * get general info table about table (for example key size)sexem_flush_tcam_tcam_memories info
     */
    dnxc_data_table_info_get_f sexem_flush_tcam_tcam_memories_info_get;
    /**
     * get table lexem_flush_tcam_tcam_memories entry 
     */
    dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_tcam_memories_get_f lexem_flush_tcam_tcam_memories_get;
    /**
     * get general info table about table (for example key size)lexem_flush_tcam_tcam_memories info
     */
    dnxc_data_table_info_get_f lexem_flush_tcam_tcam_memories_info_get;
    /**
     * get table sexem_flush_tcam_data_rules entry 
     */
    dnx_data_field_exem_learn_flush_machine_sexem_flush_tcam_data_rules_get_f sexem_flush_tcam_data_rules_get;
    /**
     * get general info table about table (for example key size)sexem_flush_tcam_data_rules info
     */
    dnxc_data_table_info_get_f sexem_flush_tcam_data_rules_info_get;
    /**
     * get table lexem_flush_tcam_data_rules entry 
     */
    dnx_data_field_exem_learn_flush_machine_lexem_flush_tcam_data_rules_get_f lexem_flush_tcam_data_rules_get;
    /**
     * get general info table about table (for example key size)lexem_flush_tcam_data_rules info
     */
    dnxc_data_table_info_get_f lexem_flush_tcam_data_rules_info_get;
} dnx_data_if_field_exem_learn_flush_machine_t;

/*
 * }
 */

/*
 * SUBMODULE  - ACE:
 * ACE values, for ACE expansion done by the PPMC DB and ACE ACR, for both MC replication ID pointers and ACE pointers
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_ace_feature_nof
} dnx_data_field_ace_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_ace_feature_get_f) (
    int unit,
    dnx_data_field_ace_feature_e feature);

/**
 * \brief returns define data of ace_id_size
 * Module - 'field', Submodule - 'ace', data - 'ace_id_size'
 * Number of bits used for the ACE ID (result type), which serves as an ID for the ACE format and context ID for the ACE EFES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_ace_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of key_size
 * Module - 'field', Submodule - 'ace', data - 'key_size'
 * Number of bits in the key of the PPMC table, including the prefix that indicates the type to the entry
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_key_size_get_f) (
    int unit);

/**
 * \brief returns define data of app_db_id_size
 * Module - 'field', Submodule - 'ace', data - 'app_db_id_size'
 * Number of bits Used for the APP DB ID.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     app_db_id_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_app_db_id_size_get_f) (
    int unit);

/**
 * \brief returns define data of payload_size
 * Module - 'field', Submodule - 'ace', data - 'payload_size'
 * Number of bits used to encode the container size, including the result type
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_payload_size_get_f) (
    int unit);

/**
 * \brief returns define data of min_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'min_key_range_pmf'
 * The first entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_min_key_range_pmf_get_f) (
    int unit);

/**
 * \brief returns define data of max_key_range_pmf
 * Module - 'field', Submodule - 'ace', data - 'max_key_range_pmf'
 * The last entry in the range of ACE keys allocated to ACE pointers (but not to MC replication ID).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_key_range_pmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_max_key_range_pmf_get_f) (
    int unit);

/**
 * \brief returns define data of min_ace_id_dynamic_range
 * Module - 'field', Submodule - 'ace', data - 'min_ace_id_dynamic_range'
 * Minimal number of ACE ID that can be allocated dynamically.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_ace_id_dynamic_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_min_ace_id_dynamic_range_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ace_id
 * Module - 'field', Submodule - 'ace', data - 'nof_ace_id'
 * Number of ACE IDs.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ace_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_ace_id_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_per_ace_format
 * Module - 'field', Submodule - 'ace', data - 'nof_action_per_ace_format'
 * Number of action per ACE Format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_ace_format - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_action_per_ace_format_get_f) (
    int unit);

/**
 * \brief returns define data of row_size
 * Module - 'field', Submodule - 'ace', data - 'row_size'
 * Number of bits per raw, entry size is number row size times VMV encoding meaning, e.g. half row encoding VMV would mean 60 bits entry size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     row_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_row_size_get_f) (
    int unit);

/**
 * \brief returns define data of min_entry_size
 * Module - 'field', Submodule - 'ace', data - 'min_entry_size'
 * Minimum number of bits in entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_min_entry_size_get_f) (
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_first
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_first'
 * The first ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_first - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_ace_id_pmf_alloc_first_get_f) (
    int unit);

/**
 * \brief returns define data of ace_id_pmf_alloc_last
 * Module - 'field', Submodule - 'ace', data - 'ace_id_pmf_alloc_last'
 * The last ACE ID allocated to ACE, that is to ePMF extension.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_id_pmf_alloc_last - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_ace_id_pmf_alloc_last_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per ACE ID, also the number of FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'ace', data - 'nof_fes_programs'
 * Number of FES programs. For ACE the FES program is the same as ACE ID. Used here for compatibility with PMF FESes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'ace', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'ace', data - 'nof_bits_in_fes_action'
 * Number of bits on the output of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_for_zero_bit
 * Module - 'field', Submodule - 'ace', data - 'fes_shift_for_zero_bit'
 * The shift used for obtaining an always zero bit for input to FES. Uses the zero padding at the end of the payload, expected to work only if EFES field type=1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_for_zero_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_shift_for_zero_bit_get_f) (
    int unit);

/**
 * \brief returns define data of fes_instruction_size
 * Module - 'field', Submodule - 'ace', data - 'fes_instruction_size'
 * Number of bits in one fes instruction.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_instruction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_instruction_size_get_f) (
    int unit);

/**
 * \brief returns define data of fes_shift_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_shift_offset'
 * FES shift offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_shift_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_shift_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_invalid_bits_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_invalid_bits_offset'
 * FES invalid bits offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_invalid_bits_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_invalid_bits_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_type_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_type_offset'
 * FES type offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_type_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_type_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_ace_action_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_ace_action_offset'
 * FES ace action offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_ace_action_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_ace_action_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fes_chosen_mask_offset
 * Module - 'field', Submodule - 'ace', data - 'fes_chosen_mask_offset'
 * FES chosen mask offset in ETPPA_PRP_FES_PROGRAM_TABLEm->DATA_PER_FESf
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fes_chosen_mask_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_ace_fes_chosen_mask_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ACE:
 * {
 */
/**
 * \brief Interface for field ace data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_ace_feature_get_f feature_get;
    /**
     * returns define data of ace_id_size
     */
    dnx_data_field_ace_ace_id_size_get_f ace_id_size_get;
    /**
     * returns define data of key_size
     */
    dnx_data_field_ace_key_size_get_f key_size_get;
    /**
     * returns define data of app_db_id_size
     */
    dnx_data_field_ace_app_db_id_size_get_f app_db_id_size_get;
    /**
     * returns define data of payload_size
     */
    dnx_data_field_ace_payload_size_get_f payload_size_get;
    /**
     * returns define data of min_key_range_pmf
     */
    dnx_data_field_ace_min_key_range_pmf_get_f min_key_range_pmf_get;
    /**
     * returns define data of max_key_range_pmf
     */
    dnx_data_field_ace_max_key_range_pmf_get_f max_key_range_pmf_get;
    /**
     * returns define data of min_ace_id_dynamic_range
     */
    dnx_data_field_ace_min_ace_id_dynamic_range_get_f min_ace_id_dynamic_range_get;
    /**
     * returns define data of nof_ace_id
     */
    dnx_data_field_ace_nof_ace_id_get_f nof_ace_id_get;
    /**
     * returns define data of nof_action_per_ace_format
     */
    dnx_data_field_ace_nof_action_per_ace_format_get_f nof_action_per_ace_format_get;
    /**
     * returns define data of row_size
     */
    dnx_data_field_ace_row_size_get_f row_size_get;
    /**
     * returns define data of min_entry_size
     */
    dnx_data_field_ace_min_entry_size_get_f min_entry_size_get;
    /**
     * returns define data of ace_id_pmf_alloc_first
     */
    dnx_data_field_ace_ace_id_pmf_alloc_first_get_f ace_id_pmf_alloc_first_get;
    /**
     * returns define data of ace_id_pmf_alloc_last
     */
    dnx_data_field_ace_ace_id_pmf_alloc_last_get_f ace_id_pmf_alloc_last_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_ace_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_ace_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_ace_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_ace_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_ace_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_ace_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_ace_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of fes_shift_for_zero_bit
     */
    dnx_data_field_ace_fes_shift_for_zero_bit_get_f fes_shift_for_zero_bit_get;
    /**
     * returns define data of fes_instruction_size
     */
    dnx_data_field_ace_fes_instruction_size_get_f fes_instruction_size_get;
    /**
     * returns define data of fes_shift_offset
     */
    dnx_data_field_ace_fes_shift_offset_get_f fes_shift_offset_get;
    /**
     * returns define data of fes_invalid_bits_offset
     */
    dnx_data_field_ace_fes_invalid_bits_offset_get_f fes_invalid_bits_offset_get;
    /**
     * returns define data of fes_type_offset
     */
    dnx_data_field_ace_fes_type_offset_get_f fes_type_offset_get;
    /**
     * returns define data of fes_ace_action_offset
     */
    dnx_data_field_ace_fes_ace_action_offset_get_f fes_ace_action_offset_get;
    /**
     * returns define data of fes_chosen_mask_offset
     */
    dnx_data_field_ace_fes_chosen_mask_offset_get_f fes_chosen_mask_offset_get;
} dnx_data_if_field_ace_t;

/*
 * }
 */

/*
 * SUBMODULE  - ENTRY:
 * Entry data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_entry_feature_nof
} dnx_data_field_entry_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_entry_feature_get_f) (
    int unit,
    dnx_data_field_entry_feature_e feature);

/**
 * \brief returns define data of dir_ext_nof_fields
 * Module - 'field', Submodule - 'entry', data - 'dir_ext_nof_fields'
 * The maximum number of fields in a direct extraction request. \n                                                   (e.g. if we want the action to be composed of 3 bits of constant value, 5 bits from the key, \n                                                   5 bits of constant value and then 4 bits from the key we need at least 4 fields.)\n                                                   Used by dnx_field_dir_ext_action_t for the array size of the fields. \n                                                   Arbitrary value, can be increased.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_nof_fields - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_entry_dir_ext_nof_fields_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_action_params_per_entry'
 * Number of action parameters can be given for each action \n                                                             e.g. action values that are filled for TCAM action result
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_entry_nof_action_params_per_entry_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qual_params_per_entry
 * Module - 'field', Submodule - 'entry', data - 'nof_qual_params_per_entry'
 * Number of qualifiers parameters can be given for each qualifier type \n                                                             e.g. qualifier/key values that are filled for TCAM key
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qual_params_per_entry - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_entry_nof_qual_params_per_entry_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ENTRY:
 * {
 */
/**
 * \brief Interface for field entry data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_entry_feature_get_f feature_get;
    /**
     * returns define data of dir_ext_nof_fields
     */
    dnx_data_field_entry_dir_ext_nof_fields_get_f dir_ext_nof_fields_get;
    /**
     * returns define data of nof_action_params_per_entry
     */
    dnx_data_field_entry_nof_action_params_per_entry_get_f nof_action_params_per_entry_get;
    /**
     * returns define data of nof_qual_params_per_entry
     */
    dnx_data_field_entry_nof_qual_params_per_entry_get_f nof_qual_params_per_entry_get;
} dnx_data_if_field_entry_t;

/*
 * }
 */

/*
 * SUBMODULE  - L4_OPS:
 * L4 Ops data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_L4_Ops_feature_nof
} dnx_data_field_L4_Ops_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_L4_Ops_feature_get_f) (
    int unit,
    dnx_data_field_L4_Ops_feature_e feature);

/**
 * \brief returns define data of udp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'udp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     udp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_udp_position_get_f) (
    int unit);

/**
 * \brief returns define data of tcp_position
 * Module - 'field', Submodule - 'L4_Ops', data - 'tcp_position'
 * The position of the UDP protocol in the register
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcp_position - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_tcp_position_get_f) (
    int unit);

/**
 * \brief returns define data of nof_range_entries
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_range_entries'
 * number of range entries in L4 Ops
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_range_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_nof_range_entries_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ext_encoders
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_ext_encoders'
 * Number of range result encoders in extended L4 OPs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_encoders - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_nof_ext_encoders_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ext_types
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_ext_types'
 * Number of range types in extended L4 OPs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ext_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_nof_ext_types_get_f) (
    int unit);

/**
 * \brief returns define data of nof_configurable_ranges
 * Module - 'field', Submodule - 'L4_Ops', data - 'nof_configurable_ranges'
 * Number of configurable ranges
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_configurable_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_L4_Ops_nof_configurable_ranges_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - L4_OPS:
 * {
 */
/**
 * \brief Interface for field L4_Ops data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_L4_Ops_feature_get_f feature_get;
    /**
     * returns define data of udp_position
     */
    dnx_data_field_L4_Ops_udp_position_get_f udp_position_get;
    /**
     * returns define data of tcp_position
     */
    dnx_data_field_L4_Ops_tcp_position_get_f tcp_position_get;
    /**
     * returns define data of nof_range_entries
     */
    dnx_data_field_L4_Ops_nof_range_entries_get_f nof_range_entries_get;
    /**
     * returns define data of nof_ext_encoders
     */
    dnx_data_field_L4_Ops_nof_ext_encoders_get_f nof_ext_encoders_get;
    /**
     * returns define data of nof_ext_types
     */
    dnx_data_field_L4_Ops_nof_ext_types_get_f nof_ext_types_get;
    /**
     * returns define data of nof_configurable_ranges
     */
    dnx_data_field_L4_Ops_nof_configurable_ranges_get_f nof_configurable_ranges_get;
} dnx_data_if_field_L4_Ops_t;

/*
 * }
 */

/*
 * SUBMODULE  - ENCODED_QUAL_ACTIONS_OFFSET:
 * Encoded qualfiers and actions offsets
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_encoded_qual_actions_offset_feature_nof
} dnx_data_field_encoded_qual_actions_offset_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_encoded_qual_actions_offset_feature_get_f) (
    int unit,
    dnx_data_field_encoded_qual_actions_offset_feature_e feature);

/**
 * \brief returns define data of trap_strength_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_strength_offset'
 * The offset of the Trap Strength in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_strength_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_get_f) (
    int unit);

/**
 * \brief returns define data of trap_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'trap_qualifier_offset'
 * The offset of the Trap Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_get_f) (
    int unit);

/**
 * \brief returns define data of sniff_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'sniff_qualifier_offset'
 * The offset of the Snoop qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sniff_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_get_f) (
    int unit);

/**
 * \brief returns define data of mirror_qualifier_offset
 * Module - 'field', Submodule - 'encoded_qual_actions_offset', data - 'mirror_qualifier_offset'
 * The offset of the Mirror Qualifier in the action
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mirror_qualifier_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - ENCODED_QUAL_ACTIONS_OFFSET:
 * {
 */
/**
 * \brief Interface for field encoded_qual_actions_offset data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_encoded_qual_actions_offset_feature_get_f feature_get;
    /**
     * returns define data of trap_strength_offset
     */
    dnx_data_field_encoded_qual_actions_offset_trap_strength_offset_get_f trap_strength_offset_get;
    /**
     * returns define data of trap_qualifier_offset
     */
    dnx_data_field_encoded_qual_actions_offset_trap_qualifier_offset_get_f trap_qualifier_offset_get;
    /**
     * returns define data of sniff_qualifier_offset
     */
    dnx_data_field_encoded_qual_actions_offset_sniff_qualifier_offset_get_f sniff_qualifier_offset_get;
    /**
     * returns define data of mirror_qualifier_offset
     */
    dnx_data_field_encoded_qual_actions_offset_mirror_qualifier_offset_get_f mirror_qualifier_offset_get;
} dnx_data_if_field_encoded_qual_actions_offset_t;

/*
 * }
 */

/*
 * SUBMODULE  - COMPARE:
 * Compare feature
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_compare_feature_nof
} dnx_data_field_compare_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_compare_feature_get_f) (
    int unit,
    dnx_data_field_compare_feature_e feature);

/**
 * \brief returns define data of equal_offset
 * Module - 'field', Submodule - 'compare', data - 'equal_offset'
 * The position in the qual showing that the result of compare is equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     equal_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_equal_offset_get_f) (
    int unit);

/**
 * \brief returns define data of not_equal_offset
 * Module - 'field', Submodule - 'compare', data - 'not_equal_offset'
 * The position in the qual showing that the result of compare is not equal
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_equal_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_not_equal_offset_get_f) (
    int unit);

/**
 * \brief returns define data of smaller_offset
 * Module - 'field', Submodule - 'compare', data - 'smaller_offset'
 * The position in the qual showing that the first compare value is smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     smaller_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_smaller_offset_get_f) (
    int unit);

/**
 * \brief returns define data of not_smaller_offset
 * Module - 'field', Submodule - 'compare', data - 'not_smaller_offset'
 * The position in the qual showing that the first compare value is not smaller then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_smaller_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_not_smaller_offset_get_f) (
    int unit);

/**
 * \brief returns define data of bigger_offset
 * Module - 'field', Submodule - 'compare', data - 'bigger_offset'
 * The position in the qual showing that the first compare value is bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bigger_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_bigger_offset_get_f) (
    int unit);

/**
 * \brief returns define data of not_bigger_offset
 * Module - 'field', Submodule - 'compare', data - 'not_bigger_offset'
 * The position in the qual showing that the first compare value is not bigger then the second
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     not_bigger_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_not_bigger_offset_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'compare', data - 'nof_keys'
 * Nof keys in compare pair
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_pairs
 * Module - 'field', Submodule - 'compare', data - 'nof_compare_pairs'
 * Maximal number of pairs used for compare.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_compare_nof_compare_pairs_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - COMPARE:
 * {
 */
/**
 * \brief Interface for field compare data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_compare_feature_get_f feature_get;
    /**
     * returns define data of equal_offset
     */
    dnx_data_field_compare_equal_offset_get_f equal_offset_get;
    /**
     * returns define data of not_equal_offset
     */
    dnx_data_field_compare_not_equal_offset_get_f not_equal_offset_get;
    /**
     * returns define data of smaller_offset
     */
    dnx_data_field_compare_smaller_offset_get_f smaller_offset_get;
    /**
     * returns define data of not_smaller_offset
     */
    dnx_data_field_compare_not_smaller_offset_get_f not_smaller_offset_get;
    /**
     * returns define data of bigger_offset
     */
    dnx_data_field_compare_bigger_offset_get_f bigger_offset_get;
    /**
     * returns define data of not_bigger_offset
     */
    dnx_data_field_compare_not_bigger_offset_get_f not_bigger_offset_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_compare_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_compare_pairs
     */
    dnx_data_field_compare_nof_compare_pairs_get_f nof_compare_pairs_get;
} dnx_data_if_field_compare_t;

/*
 * }
 */

/*
 * SUBMODULE  - DIAG:
 * Field diagnostics related defines and features.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates if the TCAM Context Selection hit bit indication is supported.
     */
    dnx_data_field_diag_tcam_cs_hit_bit_support,

    /**
     * Must be last one!
     */
    _dnx_data_field_diag_feature_nof
} dnx_data_field_diag_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_diag_feature_get_f) (
    int unit,
    dnx_data_field_diag_feature_e feature);

/**
 * \brief returns define data of bytes_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'bytes_to_remove_mask'
 * Mask of bits, which are related to the value of bytes to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_bytes_to_remove_mask_get_f) (
    int unit);

/**
 * \brief returns define data of layers_to_remove_size_in_bit
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_size_in_bit'
 * Size of the layers to remove value in bits, to be used for shifting the signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_size_in_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_layers_to_remove_size_in_bit_get_f) (
    int unit);

/**
 * \brief returns define data of layers_to_remove_mask
 * Module - 'field', Submodule - 'diag', data - 'layers_to_remove_mask'
 * Mask of bits, which are related to the value of layers to remove, from the signal.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layers_to_remove_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_layers_to_remove_mask_get_f) (
    int unit);

/**
 * \brief returns define data of nof_signals_per_action
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_action'
 * Maximum number of signals per action.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_nof_signals_per_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_signals_per_qualifier
 * Module - 'field', Submodule - 'diag', data - 'nof_signals_per_qualifier'
 * Maximum number of signals per qualifier.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_signals_per_qualifier - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_nof_signals_per_qualifier_get_f) (
    int unit);

/**
 * \brief returns define data of key_signal_size_in_bytes
 * Module - 'field', Submodule - 'diag', data - 'key_signal_size_in_bytes'
 * Number of bytes to store KEY signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     key_signal_size_in_bytes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_key_signal_size_in_bytes_get_f) (
    int unit);

/**
 * \brief returns define data of result_signal_size_in_words
 * Module - 'field', Submodule - 'diag', data - 'result_signal_size_in_words'
 * Maximum number of words to store RESULT signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     result_signal_size_in_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_result_signal_size_in_words_get_f) (
    int unit);

/**
 * \brief returns define data of dt_result_signal_size_in_words
 * Module - 'field', Submodule - 'diag', data - 'dt_result_signal_size_in_words'
 * Maximum number of words to store DT RESULT signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dt_result_signal_size_in_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_dt_result_signal_size_in_words_get_f) (
    int unit);

/**
 * \brief returns define data of hit_signal_size_in_words
 * Module - 'field', Submodule - 'diag', data - 'hit_signal_size_in_words'
 * Maximum number of words to store HIT signal value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hit_signal_size_in_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_diag_hit_signal_size_in_words_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - DIAG:
 * {
 */
/**
 * \brief Interface for field diag data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_diag_feature_get_f feature_get;
    /**
     * returns define data of bytes_to_remove_mask
     */
    dnx_data_field_diag_bytes_to_remove_mask_get_f bytes_to_remove_mask_get;
    /**
     * returns define data of layers_to_remove_size_in_bit
     */
    dnx_data_field_diag_layers_to_remove_size_in_bit_get_f layers_to_remove_size_in_bit_get;
    /**
     * returns define data of layers_to_remove_mask
     */
    dnx_data_field_diag_layers_to_remove_mask_get_f layers_to_remove_mask_get;
    /**
     * returns define data of nof_signals_per_action
     */
    dnx_data_field_diag_nof_signals_per_action_get_f nof_signals_per_action_get;
    /**
     * returns define data of nof_signals_per_qualifier
     */
    dnx_data_field_diag_nof_signals_per_qualifier_get_f nof_signals_per_qualifier_get;
    /**
     * returns define data of key_signal_size_in_bytes
     */
    dnx_data_field_diag_key_signal_size_in_bytes_get_f key_signal_size_in_bytes_get;
    /**
     * returns define data of result_signal_size_in_words
     */
    dnx_data_field_diag_result_signal_size_in_words_get_f result_signal_size_in_words_get;
    /**
     * returns define data of dt_result_signal_size_in_words
     */
    dnx_data_field_diag_dt_result_signal_size_in_words_get_f dt_result_signal_size_in_words_get;
    /**
     * returns define data of hit_signal_size_in_words
     */
    dnx_data_field_diag_hit_signal_size_in_words_get_f hit_signal_size_in_words_get;
} dnx_data_if_field_diag_t;

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL_DATA_QUALIFIERS:
 * Size and locations on general data of qualifiers.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_general_data_qualifiers_feature_nof
} dnx_data_field_general_data_qualifiers_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_general_data_qualifiers_feature_get_f) (
    int unit,
    dnx_data_field_general_data_qualifiers_feature_e feature);

/**
 * \brief returns define data of ac_in_lif_wide_data_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'ac_in_lif_wide_data_start_bit'
 * First bit on general_data for DBAL_FIELD_AC_IN_LIF_WIDE_DATA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ac_in_lif_wide_data_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of ac_in_lif_wide_data_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'ac_in_lif_wide_data_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_AC_IN_LIF_WIDE_DATA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ac_in_lif_wide_data_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of pwe_in_lif_wide_data_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'pwe_in_lif_wide_data_start_bit'
 * First bit on general_data for DBAL_FIELD_PWE_IN_LIF_WIDE_DATA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pwe_in_lif_wide_data_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_pwe_in_lif_wide_data_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of pwe_in_lif_wide_data_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'pwe_in_lif_wide_data_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_PWE_IN_LIF_WIDE_DATA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pwe_in_lif_wide_data_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_pwe_in_lif_wide_data_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of native_ac_in_lif_wide_data_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'native_ac_in_lif_wide_data_start_bit'
 * First bit on general_data for DBAL_FIELD_NATIVE_AC_IN_LIF_WIDE_DATA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     native_ac_in_lif_wide_data_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_native_ac_in_lif_wide_data_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of native_ac_in_lif_wide_data_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'native_ac_in_lif_wide_data_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_NATIVE_AC_IN_LIF_WIDE_DATA
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     native_ac_in_lif_wide_data_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_native_ac_in_lif_wide_data_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of ac_in_lif_wide_data_extended_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'ac_in_lif_wide_data_extended_start_bit'
 * First bit on general_data for DBAL_FIELD_AC_IN_LIF_WIDE_DATA_EXTENDED
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ac_in_lif_wide_data_extended_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_extended_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of ac_in_lif_wide_data_extended_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'ac_in_lif_wide_data_extended_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_AC_IN_LIF_WIDE_DATA_EXTENDED
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ac_in_lif_wide_data_extended_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_extended_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of mact_entry_grouping_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'mact_entry_grouping_start_bit'
 * First bit on general_data for DBAL_FIELD_MACT_ENTRY_GROUPING
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_entry_grouping_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_mact_entry_grouping_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of mact_entry_grouping_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'mact_entry_grouping_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_MACT_ENTRY_GROUPING
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_entry_grouping_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_mact_entry_grouping_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of vw_vip_valid_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_vip_valid_start_bit'
 * First bit on general_data for DBAL_FIELD_VW_VIP_VALID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_vip_valid_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_vip_valid_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of vw_vip_valid_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_vip_valid_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_VW_VIP_VALID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_vip_valid_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_vip_valid_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of vw_vip_id_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_vip_id_start_bit'
 * First bit on general_data for DBAL_FIELD_VW_VIP_ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_vip_id_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_vip_id_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of vw_vip_id_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_vip_id_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_VW_VIP_ID
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_vip_id_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_vip_id_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of vw_member_reference_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_member_reference_start_bit'
 * First bit on general_data for DBAL_FIELD_VW_MEMBER_REFERENCE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_member_reference_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_member_reference_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of vw_member_reference_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_member_reference_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_VW_MEMBER_REFERENCE
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_member_reference_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_member_reference_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of vw_pcc_hit_start_bit
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_pcc_hit_start_bit'
 * First bit on general_data for DBAL_FIELD_VW_PCC_HIT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_pcc_hit_start_bit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_pcc_hit_start_bit_get_f) (
    int unit);

/**
 * \brief returns define data of vw_pcc_hit_nof_bits
 * Module - 'field', Submodule - 'general_data_qualifiers', data - 'vw_pcc_hit_nof_bits'
 * Number of bits on general_data for DBAL_FIELD_VW_PCC_HIT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vw_pcc_hit_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_general_data_qualifiers_vw_pcc_hit_nof_bits_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - GENERAL_DATA_QUALIFIERS:
 * {
 */
/**
 * \brief Interface for field general_data_qualifiers data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_general_data_qualifiers_feature_get_f feature_get;
    /**
     * returns define data of ac_in_lif_wide_data_start_bit
     */
    dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_start_bit_get_f ac_in_lif_wide_data_start_bit_get;
    /**
     * returns define data of ac_in_lif_wide_data_nof_bits
     */
    dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_nof_bits_get_f ac_in_lif_wide_data_nof_bits_get;
    /**
     * returns define data of pwe_in_lif_wide_data_start_bit
     */
    dnx_data_field_general_data_qualifiers_pwe_in_lif_wide_data_start_bit_get_f pwe_in_lif_wide_data_start_bit_get;
    /**
     * returns define data of pwe_in_lif_wide_data_nof_bits
     */
    dnx_data_field_general_data_qualifiers_pwe_in_lif_wide_data_nof_bits_get_f pwe_in_lif_wide_data_nof_bits_get;
    /**
     * returns define data of native_ac_in_lif_wide_data_start_bit
     */
    dnx_data_field_general_data_qualifiers_native_ac_in_lif_wide_data_start_bit_get_f native_ac_in_lif_wide_data_start_bit_get;
    /**
     * returns define data of native_ac_in_lif_wide_data_nof_bits
     */
    dnx_data_field_general_data_qualifiers_native_ac_in_lif_wide_data_nof_bits_get_f native_ac_in_lif_wide_data_nof_bits_get;
    /**
     * returns define data of ac_in_lif_wide_data_extended_start_bit
     */
    dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_extended_start_bit_get_f ac_in_lif_wide_data_extended_start_bit_get;
    /**
     * returns define data of ac_in_lif_wide_data_extended_nof_bits
     */
    dnx_data_field_general_data_qualifiers_ac_in_lif_wide_data_extended_nof_bits_get_f ac_in_lif_wide_data_extended_nof_bits_get;
    /**
     * returns define data of mact_entry_grouping_start_bit
     */
    dnx_data_field_general_data_qualifiers_mact_entry_grouping_start_bit_get_f mact_entry_grouping_start_bit_get;
    /**
     * returns define data of mact_entry_grouping_nof_bits
     */
    dnx_data_field_general_data_qualifiers_mact_entry_grouping_nof_bits_get_f mact_entry_grouping_nof_bits_get;
    /**
     * returns define data of vw_vip_valid_start_bit
     */
    dnx_data_field_general_data_qualifiers_vw_vip_valid_start_bit_get_f vw_vip_valid_start_bit_get;
    /**
     * returns define data of vw_vip_valid_nof_bits
     */
    dnx_data_field_general_data_qualifiers_vw_vip_valid_nof_bits_get_f vw_vip_valid_nof_bits_get;
    /**
     * returns define data of vw_vip_id_start_bit
     */
    dnx_data_field_general_data_qualifiers_vw_vip_id_start_bit_get_f vw_vip_id_start_bit_get;
    /**
     * returns define data of vw_vip_id_nof_bits
     */
    dnx_data_field_general_data_qualifiers_vw_vip_id_nof_bits_get_f vw_vip_id_nof_bits_get;
    /**
     * returns define data of vw_member_reference_start_bit
     */
    dnx_data_field_general_data_qualifiers_vw_member_reference_start_bit_get_f vw_member_reference_start_bit_get;
    /**
     * returns define data of vw_member_reference_nof_bits
     */
    dnx_data_field_general_data_qualifiers_vw_member_reference_nof_bits_get_f vw_member_reference_nof_bits_get;
    /**
     * returns define data of vw_pcc_hit_start_bit
     */
    dnx_data_field_general_data_qualifiers_vw_pcc_hit_start_bit_get_f vw_pcc_hit_start_bit_get;
    /**
     * returns define data of vw_pcc_hit_nof_bits
     */
    dnx_data_field_general_data_qualifiers_vw_pcc_hit_nof_bits_get_f vw_pcc_hit_nof_bits_get;
} dnx_data_if_field_general_data_qualifiers_t;

/*
 * }
 */

/*
 * SUBMODULE  - COMMON_MAX_VAL:
 * Common max values over all PMF stages (IPMF1/IPMF2/IPMF3/EPMF) or over all IO types (TCAM, EXAM, ...)
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule common_max_val table array_id_type
 * Table info:
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 */
typedef struct
{
    /**
     * Non-zero if 'array_id' is for FESes. Zero otherwise
     */
    int is_fes;
    /**
     * Non-zero if 'array_id' is for FEMs. Zero otherwise
     */
    int is_fem;
    /**
     * Converts 'array_id' to number of FES arrays so far. 'array_id' 0 converts to 0, 2 converts to 1
     */
    int fes_array_index;
    /**
     * Converts 'array_id' to number of FEM arrays so far. 'array_id' 1 converts to 0, 3 converts to 1
     */
    int fem_array_index;
} dnx_data_field_common_max_val_array_id_type_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_common_max_val_feature_nof
} dnx_data_field_common_max_val_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_common_max_val_feature_get_f) (
    int unit,
    dnx_data_field_common_max_val_feature_e feature);

/**
 * \brief returns define data of nof_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc'
 * Maximal number of FFC's in all stages
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_keys
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_keys'
 * Number of keys for the entire PMF module
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_keys - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_keys_get_f) (
    int unit);

/**
 * \brief returns define data of nof_masks_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_masks_per_fes'
 * Number of masks per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_masks_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_masks_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_id_per_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_id_per_array'
 * Number FESes in each FES array
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_id_per_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_id_per_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_array
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_array'
 * Number FES arrays
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_array - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_array_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_instruction_per_context
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_instruction_per_context'
 * Number of FES INSTRUCTIONs per context
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_instruction_per_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_instruction_per_context_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fes_programs
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fes_programs'
 * Number of FES programs
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fes_programs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fes_programs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_prog_per_fes
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_prog_per_fes'
 * Number of MS bits instruction programs per FES
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_prog_per_fes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_prog_per_fes_get_f) (
    int unit);

/**
 * \brief returns define data of nof_cs_lines
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_cs_lines'
 * Number of program selection lines
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cs_lines - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_cs_lines_get_f) (
    int unit);

/**
 * \brief returns define data of nof_contexts
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_contexts'
 * Number of contexts per PMF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_contexts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_contexts_get_f) (
    int unit);

/**
 * \brief returns define data of nof_actions
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_actions'
 * Number of actions
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_actions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_actions_get_f) (
    int unit);

/**
 * \brief returns define data of nof_qualifiers
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_qualifiers'
 * Number of qualifiers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_qualifiers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_qualifiers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_action'
 * Number of bits on the outpus of a FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_fes_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fes_key_select
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fes_key_select'
 * Number of bits on input to FES.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fes_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_fes_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_ffc
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_ffc'
 * Number of bits in ffc.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_ffc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_ffc_get_f) (
    int unit);

/**
 * \brief returns define data of nof_ffc_in_uint32
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_ffc_in_uint32'
 * Number of uint32 needed to hold bitmap for maximum number of FFC's.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ffc_in_uint32 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_ffc_in_uint32_get_f) (
    int unit);

/**
 * \brief returns define data of nof_action_per_group
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_action_per_group'
 * Maxmimal number of actions between both Field Group and ACE format. Used for arrays in functions that serve both.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_action_per_group - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_action_per_group_get_f) (
    int unit);

/**
 * \brief returns define data of nof_layer_records
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_layer_records'
 * Maximal number of layer records.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_layer_records - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_layer_records_get_f) (
    int unit);

/**
 * \brief returns define data of layer_record_size
 * Module - 'field', Submodule - 'common_max_val', data - 'layer_record_size'
 * Maximal size of layer records.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     layer_record_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_layer_record_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_l4_ops_ranges_legacy
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_l4_ops_ranges_legacy'
 * Maximal number of ranges for L4 Ops legacy.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_l4_ops_ranges_legacy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_l4_ops_ranges_legacy_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pkt_hdr_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_pkt_hdr_ranges'
 * Maximal number of ranges for packet header.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pkt_hdr_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_pkt_hdr_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of nof_out_lif_ranges
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_out_lif_ranges'
 * Maximal number of ranges for Out Lif.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_out_lif_ranges - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_out_lif_ranges_get_f) (
    int unit);

/**
 * \brief returns define data of kbr_size
 * Module - 'field', Submodule - 'common_max_val', data - 'kbr_size'
 * Maximal KBR size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbr_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_kbr_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_compare_pairs_in_compare_mode
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_compare_pairs_in_compare_mode'
 * Number compare pairs in compare mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_compare_pairs_in_compare_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_fem_action
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_bits_in_fem_action'
 * Maximal number of bits on action value in IPPC_FEM_*_*_MAP_TABLE.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_fem_action - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_bits_in_fem_action_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_condition
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_condition'
 * Total number of fem conditions. This is the number of conditions that may be assigned to each (fem_id,fem_program) combination.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_condition - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fem_condition_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_map_index
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_map_index'
 * Total number fem map indices. This represents the number of actions that may be assigned to each condition. For internal DNX_DATA use only.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_map_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fem_map_index_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fem_id
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_fem_id'
 * Total number 'FEM id's available.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fem_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_fem_id_get_f) (
    int unit);

/**
 * \brief returns define data of nof_array_ids
 * Module - 'field', Submodule - 'common_max_val', data - 'nof_array_ids'
 * Total number of 'array_is's which are used to identify a range of FESes or FEMs. See BCM_FIELD_ACTION_POSITION.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_array_ids - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_nof_array_ids_get_f) (
    int unit);

/**
 * \brief returns define data of dbal_pairs
 * Module - 'field', Submodule - 'common_max_val', data - 'dbal_pairs'
 * Maximum number of pairs which are used to identify the DBAL key/result field in dnx_field_dbal_entry_set function. 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbal_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_common_max_val_dbal_pairs_get_f) (
    int unit);

/**
 * \brief get table array_id_type entry 
 * Contains indications on whether a specific 'array_id' is for FESes or for FEMs
 * 
 * \param [in] unit - unit #
 * \param [in] array_id - Index identifier of 'array_id'
 * 
 * \return
 *     array_id_type - returns the relevant entry values grouped in struct - see dnx_data_field_common_max_val_array_id_type_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_field_common_max_val_array_id_type_t *(
    *dnx_data_field_common_max_val_array_id_type_get_f) (
    int unit,
    int array_id);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - COMMON_MAX_VAL:
 * {
 */
/**
 * \brief Interface for field common_max_val data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_common_max_val_feature_get_f feature_get;
    /**
     * returns define data of nof_ffc
     */
    dnx_data_field_common_max_val_nof_ffc_get_f nof_ffc_get;
    /**
     * returns define data of nof_keys
     */
    dnx_data_field_common_max_val_nof_keys_get_f nof_keys_get;
    /**
     * returns define data of nof_masks_per_fes
     */
    dnx_data_field_common_max_val_nof_masks_per_fes_get_f nof_masks_per_fes_get;
    /**
     * returns define data of nof_fes_id_per_array
     */
    dnx_data_field_common_max_val_nof_fes_id_per_array_get_f nof_fes_id_per_array_get;
    /**
     * returns define data of nof_fes_array
     */
    dnx_data_field_common_max_val_nof_fes_array_get_f nof_fes_array_get;
    /**
     * returns define data of nof_fes_instruction_per_context
     */
    dnx_data_field_common_max_val_nof_fes_instruction_per_context_get_f nof_fes_instruction_per_context_get;
    /**
     * returns define data of nof_fes_programs
     */
    dnx_data_field_common_max_val_nof_fes_programs_get_f nof_fes_programs_get;
    /**
     * returns define data of nof_prog_per_fes
     */
    dnx_data_field_common_max_val_nof_prog_per_fes_get_f nof_prog_per_fes_get;
    /**
     * returns define data of nof_cs_lines
     */
    dnx_data_field_common_max_val_nof_cs_lines_get_f nof_cs_lines_get;
    /**
     * returns define data of nof_contexts
     */
    dnx_data_field_common_max_val_nof_contexts_get_f nof_contexts_get;
    /**
     * returns define data of nof_actions
     */
    dnx_data_field_common_max_val_nof_actions_get_f nof_actions_get;
    /**
     * returns define data of nof_qualifiers
     */
    dnx_data_field_common_max_val_nof_qualifiers_get_f nof_qualifiers_get;
    /**
     * returns define data of nof_bits_in_fes_action
     */
    dnx_data_field_common_max_val_nof_bits_in_fes_action_get_f nof_bits_in_fes_action_get;
    /**
     * returns define data of nof_bits_in_fes_key_select
     */
    dnx_data_field_common_max_val_nof_bits_in_fes_key_select_get_f nof_bits_in_fes_key_select_get;
    /**
     * returns define data of nof_bits_in_ffc
     */
    dnx_data_field_common_max_val_nof_bits_in_ffc_get_f nof_bits_in_ffc_get;
    /**
     * returns define data of nof_ffc_in_uint32
     */
    dnx_data_field_common_max_val_nof_ffc_in_uint32_get_f nof_ffc_in_uint32_get;
    /**
     * returns define data of nof_action_per_group
     */
    dnx_data_field_common_max_val_nof_action_per_group_get_f nof_action_per_group_get;
    /**
     * returns define data of nof_layer_records
     */
    dnx_data_field_common_max_val_nof_layer_records_get_f nof_layer_records_get;
    /**
     * returns define data of layer_record_size
     */
    dnx_data_field_common_max_val_layer_record_size_get_f layer_record_size_get;
    /**
     * returns define data of nof_l4_ops_ranges_legacy
     */
    dnx_data_field_common_max_val_nof_l4_ops_ranges_legacy_get_f nof_l4_ops_ranges_legacy_get;
    /**
     * returns define data of nof_pkt_hdr_ranges
     */
    dnx_data_field_common_max_val_nof_pkt_hdr_ranges_get_f nof_pkt_hdr_ranges_get;
    /**
     * returns define data of nof_out_lif_ranges
     */
    dnx_data_field_common_max_val_nof_out_lif_ranges_get_f nof_out_lif_ranges_get;
    /**
     * returns define data of kbr_size
     */
    dnx_data_field_common_max_val_kbr_size_get_f kbr_size_get;
    /**
     * returns define data of nof_compare_pairs_in_compare_mode
     */
    dnx_data_field_common_max_val_nof_compare_pairs_in_compare_mode_get_f nof_compare_pairs_in_compare_mode_get;
    /**
     * returns define data of nof_bits_in_fem_action
     */
    dnx_data_field_common_max_val_nof_bits_in_fem_action_get_f nof_bits_in_fem_action_get;
    /**
     * returns define data of nof_fem_condition
     */
    dnx_data_field_common_max_val_nof_fem_condition_get_f nof_fem_condition_get;
    /**
     * returns define data of nof_fem_map_index
     */
    dnx_data_field_common_max_val_nof_fem_map_index_get_f nof_fem_map_index_get;
    /**
     * returns define data of nof_fem_id
     */
    dnx_data_field_common_max_val_nof_fem_id_get_f nof_fem_id_get;
    /**
     * returns define data of nof_array_ids
     */
    dnx_data_field_common_max_val_nof_array_ids_get_f nof_array_ids_get;
    /**
     * returns define data of dbal_pairs
     */
    dnx_data_field_common_max_val_dbal_pairs_get_f dbal_pairs_get;
    /**
     * get table array_id_type entry 
     */
    dnx_data_field_common_max_val_array_id_type_get_f array_id_type_get;
    /**
     * get general info table about table (for example key size)array_id_type info
     */
    dnxc_data_table_info_get_f array_id_type_info_get;
} dnx_data_if_field_common_max_val_t;

/*
 * }
 */

/*
 * SUBMODULE  - INIT:
 * Field defines and features related to init.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_init_feature_nof
} dnx_data_field_init_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_init_feature_get_f) (
    int unit,
    dnx_data_field_init_feature_e feature);

/**
 * \brief returns define data of fec_dest
 * Module - 'field', Submodule - 'init', data - 'fec_dest'
 * APP for fec destination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_dest - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_fec_dest_get_f) (
    int unit);

/**
 * \brief returns define data of l4_trap
 * Module - 'field', Submodule - 'init', data - 'l4_trap'
 * APP for L4 Trap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l4_trap - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_l4_trap_get_f) (
    int unit);

/**
 * \brief returns define data of oam_layer_index
 * Module - 'field', Submodule - 'init', data - 'oam_layer_index'
 * APP for OAM Layer Index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_layer_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_oam_layer_index_get_f) (
    int unit);

/**
 * \brief returns define data of oam_stat
 * Module - 'field', Submodule - 'init', data - 'oam_stat'
 * APP for OAM Statistics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     oam_stat - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_oam_stat_get_f) (
    int unit);

/**
 * \brief returns define data of roo
 * Module - 'field', Submodule - 'init', data - 'roo'
 * APP for Roo
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     roo - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_roo_get_f) (
    int unit);

/**
 * \brief returns define data of jr1_ipmc_inlif
 * Module - 'field', Submodule - 'init', data - 'jr1_ipmc_inlif'
 * APP for IPMC In LIF
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     jr1_ipmc_inlif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_jr1_ipmc_inlif_get_f) (
    int unit);

/**
 * \brief returns define data of j1_same_port
 * Module - 'field', Submodule - 'init', data - 'j1_same_port'
 * APP for J1 Same port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     j1_same_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_j1_same_port_get_f) (
    int unit);

/**
 * \brief returns define data of j1_learning
 * Module - 'field', Submodule - 'init', data - 'j1_learning'
 * APP for J1 Learning
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     j1_learning - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_j1_learning_get_f) (
    int unit);

/**
 * \brief returns define data of learn_limit
 * Module - 'field', Submodule - 'init', data - 'learn_limit'
 * APP for Learn Limit
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learn_limit - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_learn_limit_get_f) (
    int unit);

/**
 * \brief returns define data of j1_php
 * Module - 'field', Submodule - 'init', data - 'j1_php'
 * APP for J1 MPLS PHP
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     j1_php - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_init_j1_php_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - INIT:
 * {
 */
/**
 * \brief Interface for field init data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_init_feature_get_f feature_get;
    /**
     * returns define data of fec_dest
     */
    dnx_data_field_init_fec_dest_get_f fec_dest_get;
    /**
     * returns define data of l4_trap
     */
    dnx_data_field_init_l4_trap_get_f l4_trap_get;
    /**
     * returns define data of oam_layer_index
     */
    dnx_data_field_init_oam_layer_index_get_f oam_layer_index_get;
    /**
     * returns define data of oam_stat
     */
    dnx_data_field_init_oam_stat_get_f oam_stat_get;
    /**
     * returns define data of roo
     */
    dnx_data_field_init_roo_get_f roo_get;
    /**
     * returns define data of jr1_ipmc_inlif
     */
    dnx_data_field_init_jr1_ipmc_inlif_get_f jr1_ipmc_inlif_get;
    /**
     * returns define data of j1_same_port
     */
    dnx_data_field_init_j1_same_port_get_f j1_same_port_get;
    /**
     * returns define data of j1_learning
     */
    dnx_data_field_init_j1_learning_get_f j1_learning_get;
    /**
     * returns define data of learn_limit
     */
    dnx_data_field_init_learn_limit_get_f learn_limit_get;
    /**
     * returns define data of j1_php
     */
    dnx_data_field_init_j1_php_get_f j1_php_get;
} dnx_data_if_field_init_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURES:
 * All device specific features
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_features_feature_nof
} dnx_data_field_features_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_features_feature_get_f) (
    int unit,
    dnx_data_field_features_feature_e feature);

/**
 * \brief returns define data of ecc_enable
 * Module - 'field', Submodule - 'features', data - 'ecc_enable'
 * ECC is calculated per whole entry on each entry write, therefore, when writing half-entries\n                      need to get whole entry from the SW and update relevant half entry.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecc_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_ecc_enable_get_f) (
    int unit);

/**
 * \brief returns define data of switch_to_acl_context
 * Module - 'field', Submodule - 'features', data - 'switch_to_acl_context'
 * Allows to swap the acl_context and fwd_context signals after iPMF1/2 using IPPC_PMF_GENERAL.SWITCH_TO_ACL_CONTEXT.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     switch_to_acl_context - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_switch_to_acl_context_get_f) (
    int unit);

/**
 * \brief returns define data of per_pp_port_pmf_profile_cs_offset
 * Module - 'field', Submodule - 'features', data - 'per_pp_port_pmf_profile_cs_offset'
 * The placement of PMF_PROFILE field within ERPP_PER_PORT_TABLE. Used because DBAL mapping by device didn't work.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     per_pp_port_pmf_profile_cs_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_per_pp_port_pmf_profile_cs_offset_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_result_flip_eco
 * Module - 'field', Submodule - 'features', data - 'tcam_result_flip_eco'
 * The TCAM result flip ECO is about flippiing lsb and msb parts of the TCAM-result in order to support 80b result being parsed by ARR
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_result_flip_eco - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_tcam_result_flip_eco_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_result_half_payload_on_msb
 * Module - 'field', Submodule - 'features', data - 'tcam_result_half_payload_on_msb'
 * Indicates that for half payload lookup the result is on the MSB half, but not using the tcam_result_flip_eco.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_result_half_payload_on_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_tcam_result_half_payload_on_msb_get_f) (
    int unit);

/**
 * \brief returns define data of parsing_start_offset_msb_meaningless
 * Module - 'field', Submodule - 'features', data - 'parsing_start_offset_msb_meaningless'
 * In JR2, the parsing_start_offset signal is 8 bit in ingress but only 7 in egress, so we make the action smaller so as not to have a meaningles MSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parsing_start_offset_msb_meaningless - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_parsing_start_offset_msb_meaningless_get_f) (
    int unit);

/**
 * \brief returns define data of kbp_opcode_in_ipmf1_cs
 * Module - 'field', Submodule - 'features', data - 'kbp_opcode_in_ipmf1_cs'
 * Indicates whether the context selection of iPMF1 takes the KBP opcode into account.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbp_opcode_in_ipmf1_cs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_kbp_opcode_in_ipmf1_cs_get_f) (
    int unit);

/**
 * \brief returns define data of kbp_hitbits_correct_in_ipmf1_cs
 * Module - 'field', Submodule - 'features', data - 'kbp_hitbits_correct_in_ipmf1_cs'
 * Indicates whether the context selection of iPMF1 takes the KBP hitbits from the correct place of the elk payload. Assumed to be either 0 or 1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     kbp_hitbits_correct_in_ipmf1_cs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_kbp_hitbits_correct_in_ipmf1_cs_get_f) (
    int unit);

/**
 * \brief returns define data of exem_vmv_removable_from_payload
 * Module - 'field', Submodule - 'features', data - 'exem_vmv_removable_from_payload'
 * Indicates whether it is possible to configure a shift to remove the from the EXEM payload.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_vmv_removable_from_payload - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_exem_vmv_removable_from_payload_get_f) (
    int unit);

/**
 * \brief returns define data of multiple_dynamic_mem_enablers
 * Module - 'field', Submodule - 'features', data - 'multiple_dynamic_mem_enablers'
 * Indicates whether it is possible to configure dynamic memory enablers for ST, CS hit, TCAM entry protection etc.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     multiple_dynamic_mem_enablers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_multiple_dynamic_mem_enablers_get_f) (
    int unit);

/**
 * \brief returns define data of aacl_super_group_handler_enable
 * Module - 'field', Submodule - 'features', data - 'aacl_super_group_handler_enable'
 * Indicates whether it is possible to configure Super Group Handler for AACL
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aacl_super_group_handler_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_aacl_super_group_handler_enable_get_f) (
    int unit);

/**
 * \brief returns define data of aacl_tcam_swap_enable
 * Module - 'field', Submodule - 'features', data - 'aacl_tcam_swap_enable'
 * Indicates whether it is possible to configure TCAM swap for AACL
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aacl_tcam_swap_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_aacl_tcam_swap_enable_get_f) (
    int unit);

/**
 * \brief returns define data of extended_l4_ops
 * Module - 'field', Submodule - 'features', data - 'extended_l4_ops'
 * Whether extended L4 Ops is supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     extended_l4_ops - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_extended_l4_ops_get_f) (
    int unit);

/**
 * \brief returns define data of state_table_ipmf1_key_select
 * Module - 'field', Submodule - 'features', data - 'state_table_ipmf1_key_select'
 * Whether we can choose the key for state table in iPMF1.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_ipmf1_key_select - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_state_table_ipmf1_key_select_get_f) (
    int unit);

/**
 * \brief returns define data of state_table_acr_bus
 * Module - 'field', Submodule - 'features', data - 'state_table_acr_bus'
 * Whether the EFES/FEM can access the state table result.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_acr_bus - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_state_table_acr_bus_get_f) (
    int unit);

/**
 * \brief returns define data of state_table_atomic_rmw
 * Module - 'field', Submodule - 'features', data - 'state_table_atomic_rmw'
 * Whether state table uses atomic read modify write (rmw) instead of separate read and write (rw).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     state_table_atomic_rmw - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_state_table_atomic_rmw_get_f) (
    int unit);

/**
 * \brief returns define data of hitbit_volatile
 * Module - 'field', Submodule - 'features', data - 'hitbit_volatile'
 * Indicates on, which devices the HIT_INCDICATION memories have volatile values and therefore we add SW state to save them.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hitbit_volatile - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_hitbit_volatile_get_f) (
    int unit);

/**
 * \brief returns define data of fem_replace_msb_instead_lsb
 * Module - 'field', Submodule - 'features', data - 'fem_replace_msb_instead_lsb'
 * Starting from Q2A, the 16 MSB of the overriding TCAM are taken, instead of the 16 LSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fem_replace_msb_instead_lsb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_fem_replace_msb_instead_lsb_get_f) (
    int unit);

/**
 * \brief returns define data of no_parser_resources
 * Module - 'field', Submodule - 'features', data - 'no_parser_resources'
 * Not enough parser resources in device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     no_parser_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_no_parser_resources_get_f) (
    int unit);

/**
 * \brief returns define data of dir_ext_epmf
 * Module - 'field', Submodule - 'features', data - 'dir_ext_epmf'
 * Indicates whether Direct Extract is supported for EPMF stage.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dir_ext_epmf - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_dir_ext_epmf_get_f) (
    int unit);

/**
 * \brief returns define data of hashing_process_lsb_to_msb
 * Module - 'field', Submodule - 'features', data - 'hashing_process_lsb_to_msb'
 * Indicates whether the Hashing processes the bits from LSB to MSB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hashing_process_lsb_to_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_hashing_process_lsb_to_msb_get_f) (
    int unit);

/**
 * \brief returns define data of exem_age_flush_scan
 * Module - 'field', Submodule - 'features', data - 'exem_age_flush_scan'
 * Indicates whether EXEM age scan period or flush scan period works.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     exem_age_flush_scan - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_exem_age_flush_scan_get_f) (
    int unit);

/**
 * \brief returns define data of epmf_outlif_profile_map
 * Module - 'field', Submodule - 'features', data - 'epmf_outlif_profile_map'
 * Indicates whether ePMF CS outlif profile map table should be init
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     epmf_outlif_profile_map - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_epmf_outlif_profile_map_get_f) (
    int unit);

/**
 * \brief returns define data of tcam_full_key_half_payload_both_lsb_msb
 * Module - 'field', Submodule - 'features', data - 'tcam_full_key_half_payload_both_lsb_msb'
 * Indicates whether a TCAM field group with single size key and half size payload writes its output to both the LSB half and the MSB half.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcam_full_key_half_payload_both_lsb_msb - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_features_tcam_full_key_half_payload_both_lsb_msb_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - FEATURES:
 * {
 */
/**
 * \brief Interface for field features data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_features_feature_get_f feature_get;
    /**
     * returns define data of ecc_enable
     */
    dnx_data_field_features_ecc_enable_get_f ecc_enable_get;
    /**
     * returns define data of switch_to_acl_context
     */
    dnx_data_field_features_switch_to_acl_context_get_f switch_to_acl_context_get;
    /**
     * returns define data of per_pp_port_pmf_profile_cs_offset
     */
    dnx_data_field_features_per_pp_port_pmf_profile_cs_offset_get_f per_pp_port_pmf_profile_cs_offset_get;
    /**
     * returns define data of tcam_result_flip_eco
     */
    dnx_data_field_features_tcam_result_flip_eco_get_f tcam_result_flip_eco_get;
    /**
     * returns define data of tcam_result_half_payload_on_msb
     */
    dnx_data_field_features_tcam_result_half_payload_on_msb_get_f tcam_result_half_payload_on_msb_get;
    /**
     * returns define data of parsing_start_offset_msb_meaningless
     */
    dnx_data_field_features_parsing_start_offset_msb_meaningless_get_f parsing_start_offset_msb_meaningless_get;
    /**
     * returns define data of kbp_opcode_in_ipmf1_cs
     */
    dnx_data_field_features_kbp_opcode_in_ipmf1_cs_get_f kbp_opcode_in_ipmf1_cs_get;
    /**
     * returns define data of kbp_hitbits_correct_in_ipmf1_cs
     */
    dnx_data_field_features_kbp_hitbits_correct_in_ipmf1_cs_get_f kbp_hitbits_correct_in_ipmf1_cs_get;
    /**
     * returns define data of exem_vmv_removable_from_payload
     */
    dnx_data_field_features_exem_vmv_removable_from_payload_get_f exem_vmv_removable_from_payload_get;
    /**
     * returns define data of multiple_dynamic_mem_enablers
     */
    dnx_data_field_features_multiple_dynamic_mem_enablers_get_f multiple_dynamic_mem_enablers_get;
    /**
     * returns define data of aacl_super_group_handler_enable
     */
    dnx_data_field_features_aacl_super_group_handler_enable_get_f aacl_super_group_handler_enable_get;
    /**
     * returns define data of aacl_tcam_swap_enable
     */
    dnx_data_field_features_aacl_tcam_swap_enable_get_f aacl_tcam_swap_enable_get;
    /**
     * returns define data of extended_l4_ops
     */
    dnx_data_field_features_extended_l4_ops_get_f extended_l4_ops_get;
    /**
     * returns define data of state_table_ipmf1_key_select
     */
    dnx_data_field_features_state_table_ipmf1_key_select_get_f state_table_ipmf1_key_select_get;
    /**
     * returns define data of state_table_acr_bus
     */
    dnx_data_field_features_state_table_acr_bus_get_f state_table_acr_bus_get;
    /**
     * returns define data of state_table_atomic_rmw
     */
    dnx_data_field_features_state_table_atomic_rmw_get_f state_table_atomic_rmw_get;
    /**
     * returns define data of hitbit_volatile
     */
    dnx_data_field_features_hitbit_volatile_get_f hitbit_volatile_get;
    /**
     * returns define data of fem_replace_msb_instead_lsb
     */
    dnx_data_field_features_fem_replace_msb_instead_lsb_get_f fem_replace_msb_instead_lsb_get;
    /**
     * returns define data of no_parser_resources
     */
    dnx_data_field_features_no_parser_resources_get_f no_parser_resources_get;
    /**
     * returns define data of dir_ext_epmf
     */
    dnx_data_field_features_dir_ext_epmf_get_f dir_ext_epmf_get;
    /**
     * returns define data of hashing_process_lsb_to_msb
     */
    dnx_data_field_features_hashing_process_lsb_to_msb_get_f hashing_process_lsb_to_msb_get;
    /**
     * returns define data of exem_age_flush_scan
     */
    dnx_data_field_features_exem_age_flush_scan_get_f exem_age_flush_scan_get;
    /**
     * returns define data of epmf_outlif_profile_map
     */
    dnx_data_field_features_epmf_outlif_profile_map_get_f epmf_outlif_profile_map_get;
    /**
     * returns define data of tcam_full_key_half_payload_both_lsb_msb
     */
    dnx_data_field_features_tcam_full_key_half_payload_both_lsb_msb_get_f tcam_full_key_half_payload_both_lsb_msb_get;
} dnx_data_if_field_features_t;

/*
 * }
 */

/*
 * SUBMODULE  - SIGNAL_SIZES:
 * signal sizes that change by device, as needed for qualifier and action sizes.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_signal_sizes_feature_nof
} dnx_data_field_signal_sizes_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_signal_sizes_feature_get_f) (
    int unit,
    dnx_data_field_signal_sizes_feature_e feature);

/**
 * \brief returns define data of dual_queue_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'dual_queue_size'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dual_queue_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_dual_queue_size_get_f) (
    int unit);

/**
 * \brief returns define data of packet_header_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'packet_header_size'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     packet_header_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_packet_header_size_get_f) (
    int unit);

/**
 * \brief returns define data of ecn
 * Module - 'field', Submodule - 'signal_sizes', data - 'ecn'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ecn - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_ecn_get_f) (
    int unit);

/**
 * \brief returns define data of congestion_info
 * Module - 'field', Submodule - 'signal_sizes', data - 'congestion_info'
 * CONGESTION_INFO signal. Takes ECN by default, and changed with it.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     congestion_info - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_congestion_info_get_f) (
    int unit);

/**
 * \brief returns define data of parsing_start_offset_size
 * Module - 'field', Submodule - 'signal_sizes', data - 'parsing_start_offset_size'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parsing_start_offset_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_signal_sizes_parsing_start_offset_size_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - SIGNAL_SIZES:
 * {
 */
/**
 * \brief Interface for field signal_sizes data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_signal_sizes_feature_get_f feature_get;
    /**
     * returns define data of dual_queue_size
     */
    dnx_data_field_signal_sizes_dual_queue_size_get_f dual_queue_size_get;
    /**
     * returns define data of packet_header_size
     */
    dnx_data_field_signal_sizes_packet_header_size_get_f packet_header_size_get;
    /**
     * returns define data of ecn
     */
    dnx_data_field_signal_sizes_ecn_get_f ecn_get;
    /**
     * returns define data of congestion_info
     */
    dnx_data_field_signal_sizes_congestion_info_get_f congestion_info_get;
    /**
     * returns define data of parsing_start_offset_size
     */
    dnx_data_field_signal_sizes_parsing_start_offset_size_get_f parsing_start_offset_size_get;
} dnx_data_if_field_signal_sizes_t;

/*
 * }
 */

/*
 * SUBMODULE  - DNX_DATA_INTERNAL:
 * For internal DNX DATA usage only
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_dnx_data_internal_feature_nof
} dnx_data_field_dnx_data_internal_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_dnx_data_internal_feature_get_f) (
    int unit,
    dnx_data_field_dnx_data_internal_feature_e feature);

/**
 * \brief returns define data of lr_eth_is_da_mac_valid
 * Module - 'field', Submodule - 'dnx_data_internal', data - 'lr_eth_is_da_mac_valid'
 * Whether layer record ETH_IS_DA_MAC works on device (works on JR2_B0 but not on JR2_A0).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lr_eth_is_da_mac_valid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_dnx_data_internal_lr_eth_is_da_mac_valid_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - DNX_DATA_INTERNAL:
 * {
 */
/**
 * \brief Interface for field dnx_data_internal data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_dnx_data_internal_feature_get_f feature_get;
    /**
     * returns define data of lr_eth_is_da_mac_valid
     */
    dnx_data_field_dnx_data_internal_lr_eth_is_da_mac_valid_get_f lr_eth_is_da_mac_valid_get;
} dnx_data_if_field_dnx_data_internal_t;

/*
 * }
 */

/*
 * SUBMODULE  - TESTS:
 * Used for field tests, where special checks per device are needed.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_field_tests_feature_nof
} dnx_data_field_tests_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_field_tests_feature_get_f) (
    int unit,
    dnx_data_field_tests_feature_e feature);

/**
 * \brief returns define data of learn_info_actions_structure_change
 * Module - 'field', Submodule - 'tests', data - 'learn_info_actions_structure_change'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learn_info_actions_structure_change - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tests_learn_info_actions_structure_change_get_f) (
    int unit);

/**
 * \brief returns define data of ingress_time_stamp_increased
 * Module - 'field', Submodule - 'tests', data - 'ingress_time_stamp_increased'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ingress_time_stamp_increased - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tests_ingress_time_stamp_increased_get_f) (
    int unit);

/**
 * \brief returns define data of ace_debug_signals_exist
 * Module - 'field', Submodule - 'tests', data - 'ace_debug_signals_exist'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ace_debug_signals_exist - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tests_ace_debug_signals_exist_get_f) (
    int unit);

/**
 * \brief returns define data of epmf_debug_rely_on_tcam0
 * Module - 'field', Submodule - 'tests', data - 'epmf_debug_rely_on_tcam0'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     epmf_debug_rely_on_tcam0 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_field_tests_epmf_debug_rely_on_tcam0_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_FIELD - TESTS:
 * {
 */
/**
 * \brief Interface for field tests data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_field_tests_feature_get_f feature_get;
    /**
     * returns define data of learn_info_actions_structure_change
     */
    dnx_data_field_tests_learn_info_actions_structure_change_get_f learn_info_actions_structure_change_get;
    /**
     * returns define data of ingress_time_stamp_increased
     */
    dnx_data_field_tests_ingress_time_stamp_increased_get_f ingress_time_stamp_increased_get;
    /**
     * returns define data of ace_debug_signals_exist
     */
    dnx_data_field_tests_ace_debug_signals_exist_get_f ace_debug_signals_exist_get;
    /**
     * returns define data of epmf_debug_rely_on_tcam0
     */
    dnx_data_field_tests_epmf_debug_rely_on_tcam0_get_f epmf_debug_rely_on_tcam0_get;
} dnx_data_if_field_tests_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_FIELD:
 * {
 */
/**
 * \brief Interface for field data
 */
typedef struct
{
    /**
     * Interface for field base_ipmf1 data
     */
    dnx_data_if_field_base_ipmf1_t base_ipmf1;
    /**
     * Interface for field base_ipmf2 data
     */
    dnx_data_if_field_base_ipmf2_t base_ipmf2;
    /**
     * Interface for field base_ipmf3 data
     */
    dnx_data_if_field_base_ipmf3_t base_ipmf3;
    /**
     * Interface for field base_epmf data
     */
    dnx_data_if_field_base_epmf_t base_epmf;
    /**
     * Interface for field base_ifwd2 data
     */
    dnx_data_if_field_base_ifwd2_t base_ifwd2;
    /**
     * Interface for field stage data
     */
    dnx_data_if_field_stage_t stage;
    /**
     * Interface for field kbp data
     */
    dnx_data_if_field_kbp_t kbp;
    /**
     * Interface for field tcam data
     */
    dnx_data_if_field_tcam_t tcam;
    /**
     * Interface for field group data
     */
    dnx_data_if_field_group_t group;
    /**
     * Interface for field efes data
     */
    dnx_data_if_field_efes_t efes;
    /**
     * Interface for field fem data
     */
    dnx_data_if_field_fem_t fem;
    /**
     * Interface for field context data
     */
    dnx_data_if_field_context_t context;
    /**
     * Interface for field preselector data
     */
    dnx_data_if_field_preselector_t preselector;
    /**
     * Interface for field qual data
     */
    dnx_data_if_field_qual_t qual;
    /**
     * Interface for field action data
     */
    dnx_data_if_field_action_t action;
    /**
     * Interface for field virtual_wire data
     */
    dnx_data_if_field_virtual_wire_t virtual_wire;
    /**
     * Interface for field profile_bits data
     */
    dnx_data_if_field_profile_bits_t profile_bits;
    /**
     * Interface for field dir_ext data
     */
    dnx_data_if_field_dir_ext_t dir_ext;
    /**
     * Interface for field state_table data
     */
    dnx_data_if_field_state_table_t state_table;
    /**
     * Interface for field map data
     */
    dnx_data_if_field_map_t map;
    /**
     * Interface for field hash data
     */
    dnx_data_if_field_hash_t hash;
    /**
     * Interface for field udh data
     */
    dnx_data_if_field_udh_t udh;
    /**
     * Interface for field system_headers data
     */
    dnx_data_if_field_system_headers_t system_headers;
    /**
     * Interface for field exem data
     */
    dnx_data_if_field_exem_t exem;
    /**
     * Interface for field exem_learn_flush_machine data
     */
    dnx_data_if_field_exem_learn_flush_machine_t exem_learn_flush_machine;
    /**
     * Interface for field ace data
     */
    dnx_data_if_field_ace_t ace;
    /**
     * Interface for field entry data
     */
    dnx_data_if_field_entry_t entry;
    /**
     * Interface for field L4_Ops data
     */
    dnx_data_if_field_L4_Ops_t L4_Ops;
    /**
     * Interface for field encoded_qual_actions_offset data
     */
    dnx_data_if_field_encoded_qual_actions_offset_t encoded_qual_actions_offset;
    /**
     * Interface for field compare data
     */
    dnx_data_if_field_compare_t compare;
    /**
     * Interface for field diag data
     */
    dnx_data_if_field_diag_t diag;
    /**
     * Interface for field general_data_qualifiers data
     */
    dnx_data_if_field_general_data_qualifiers_t general_data_qualifiers;
    /**
     * Interface for field common_max_val data
     */
    dnx_data_if_field_common_max_val_t common_max_val;
    /**
     * Interface for field init data
     */
    dnx_data_if_field_init_t init;
    /**
     * Interface for field features data
     */
    dnx_data_if_field_features_t features;
    /**
     * Interface for field signal_sizes data
     */
    dnx_data_if_field_signal_sizes_t signal_sizes;
    /**
     * Interface for field dnx_data_internal data
     */
    dnx_data_if_field_dnx_data_internal_t dnx_data_internal;
    /**
     * Interface for field tests data
     */
    dnx_data_if_field_tests_t tests;
} dnx_data_if_field_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_field_t dnx_data_field;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_FIELD_H_*/
/* *INDENT-ON* */
