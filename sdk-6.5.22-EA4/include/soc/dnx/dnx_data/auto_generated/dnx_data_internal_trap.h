/** \file dnx_data_internal_trap.h
 * 
 * MODULE DEVICE DATA - DNX_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_INTERNAL_TRAP_H_
/*{*/
#define _DNX_DATA_INTERNAL_TRAP_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnx/dnx_data/auto_generated/dnx_data_internal.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_trap.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnx_data_trap_submodule_ingress,
    dnx_data_trap_submodule_erpp,
    dnx_data_trap_submodule_etpp,
    dnx_data_trap_submodule_strength,
    dnx_data_trap_submodule_register_name_changes,

    /**
     * Must be last one!
     */
    _dnx_data_trap_submodule_nof
} dnx_data_trap_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE INGRESS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_trap_ingress_feature_get(
    int unit,
    dnx_data_trap_ingress_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_trap_ingress_define_protocol_traps_init_mode,
    dnx_data_trap_ingress_define_protocol_traps_lif_profile_starting_offset,
    dnx_data_trap_ingress_define_nof_predefeind_traps,
    dnx_data_trap_ingress_define_nof_user_defined_traps,
    dnx_data_trap_ingress_define_nof_1588_traps,
    dnx_data_trap_ingress_define_nof_entries_action_table,
    dnx_data_trap_ingress_define_nof_protocol_trap_profiles,
    dnx_data_trap_ingress_define_nof_recycle_cmds,
    dnx_data_trap_ingress_define_nof_programmable_traps,
    dnx_data_trap_ingress_define_nof_lif_traps,
    dnx_data_trap_ingress_define_nof_icmp_compressed_types,
    dnx_data_trap_ingress_define_nof_stat_objs,
    dnx_data_trap_ingress_define_max_nof_stat_objs_to_overwrite,
    dnx_data_trap_ingress_define_nof_error_code_profiles,
    dnx_data_trap_ingress_define_nof_sci_profiles,
    dnx_data_trap_ingress_define_nof_error_codes,
    dnx_data_trap_ingress_define_nof_scis,

    /**
     * Must be last one!
     */
    _dnx_data_trap_ingress_define_nof
} dnx_data_trap_ingress_define_e;

/* Get Data */
/**
 * \brief returns numeric data of protocol_traps_init_mode
 * Module - 'trap', Submodule - 'ingress', data - 'protocol_traps_init_mode'
 * initialize protocol traps configuration mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     protocol_traps_init_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_protocol_traps_init_mode_get(
    int unit);

/**
 * \brief returns define data of protocol_traps_lif_profile_starting_offset
 * Module - 'trap', Submodule - 'ingress', data - 'protocol_traps_lif_profile_starting_offset'
 * The offset at which LIF profile entries start in protocol profiling table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     protocol_traps_lif_profile_starting_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_protocol_traps_lif_profile_starting_offset_get(
    int unit);

/**
 * \brief returns define data of nof_predefeind_traps
 * Module - 'trap', Submodule - 'ingress', data - 'nof_predefeind_traps'
 * Number of predefined traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_predefeind_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_predefeind_traps_get(
    int unit);

/**
 * \brief returns define data of nof_user_defined_traps
 * Module - 'trap', Submodule - 'ingress', data - 'nof_user_defined_traps'
 * Number of bcmRxTrapUserDefine traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_user_defined_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_user_defined_traps_get(
    int unit);

/**
 * \brief returns define data of nof_1588_traps
 * Module - 'trap', Submodule - 'ingress', data - 'nof_1588_traps'
 * Number of bcmRxTrap1588 traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_1588_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_1588_traps_get(
    int unit);

/**
 * \brief returns define data of nof_entries_action_table
 * Module - 'trap', Submodule - 'ingress', data - 'nof_entries_action_table'
 * Number of entries in action table of traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_entries_action_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_entries_action_table_get(
    int unit);

/**
 * \brief returns define data of nof_protocol_trap_profiles
 * Module - 'trap', Submodule - 'ingress', data - 'nof_protocol_trap_profiles'
 * Number of protocol trap profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_protocol_trap_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_protocol_trap_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_recycle_cmds
 * Module - 'trap', Submodule - 'ingress', data - 'nof_recycle_cmds'
 * Number of forward recycle commands
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_recycle_cmds - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_recycle_cmds_get(
    int unit);

/**
 * \brief returns define data of nof_programmable_traps
 * Module - 'trap', Submodule - 'ingress', data - 'nof_programmable_traps'
 * Number of programmable traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_programmable_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_programmable_traps_get(
    int unit);

/**
 * \brief returns define data of nof_lif_traps
 * Module - 'trap', Submodule - 'ingress', data - 'nof_lif_traps'
 * Number of LIF traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lif_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_lif_traps_get(
    int unit);

/**
 * \brief returns define data of nof_icmp_compressed_types
 * Module - 'trap', Submodule - 'ingress', data - 'nof_icmp_compressed_types'
 * Number of ICMP compressed types
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_icmp_compressed_types - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_icmp_compressed_types_get(
    int unit);

/**
 * \brief returns define data of nof_stat_objs
 * Module - 'trap', Submodule - 'ingress', data - 'nof_stat_objs'
 * Number of ingress statistical objects
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_stat_objs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_stat_objs_get(
    int unit);

/**
 * \brief returns define data of max_nof_stat_objs_to_overwrite
 * Module - 'trap', Submodule - 'ingress', data - 'max_nof_stat_objs_to_overwrite'
 * Max number of statistical objects to overwrite
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_stat_objs_to_overwrite - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_max_nof_stat_objs_to_overwrite_get(
    int unit);

/**
 * \brief returns define data of nof_error_code_profiles
 * Module - 'trap', Submodule - 'ingress', data - 'nof_error_code_profiles'
 * Number of Error Code profiles for MACSEC traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_error_code_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_error_code_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_sci_profiles
 * Module - 'trap', Submodule - 'ingress', data - 'nof_sci_profiles'
 * Number of SCI profiles for MACSEC traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_sci_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_sci_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_error_codes
 * Module - 'trap', Submodule - 'ingress', data - 'nof_error_codes'
 * Number of Error Codes for MACSEC traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_error_codes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_error_codes_get(
    int unit);

/**
 * \brief returns define data of nof_scis
 * Module - 'trap', Submodule - 'ingress', data - 'nof_scis'
 * Number of SCIs for MACSEC traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_scis - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_ingress_nof_scis_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_trap_ingress_table_nof
} dnx_data_trap_ingress_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ERPP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_trap_erpp_feature_get(
    int unit,
    dnx_data_trap_erpp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_trap_erpp_define_nof_erpp_app_traps,
    dnx_data_trap_erpp_define_nof_erpp_forward_profiles,
    dnx_data_trap_erpp_define_nof_erpp_user_configurable_profiles,
    dnx_data_trap_erpp_define_nof_erpp_snif_profiles,

    /**
     * Must be last one!
     */
    _dnx_data_trap_erpp_define_nof
} dnx_data_trap_erpp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_erpp_app_traps
 * Module - 'trap', Submodule - 'erpp', data - 'nof_erpp_app_traps'
 * Number of ERPP application traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_erpp_app_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_erpp_nof_erpp_app_traps_get(
    int unit);

/**
 * \brief returns define data of nof_erpp_forward_profiles
 * Module - 'trap', Submodule - 'erpp', data - 'nof_erpp_forward_profiles'
 * Number of ERPP forward profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_erpp_forward_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_erpp_nof_erpp_forward_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_erpp_user_configurable_profiles
 * Module - 'trap', Submodule - 'erpp', data - 'nof_erpp_user_configurable_profiles'
 * Number of user configurable profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_erpp_user_configurable_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_erpp_nof_erpp_user_configurable_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_erpp_snif_profiles
 * Module - 'trap', Submodule - 'erpp', data - 'nof_erpp_snif_profiles'
 * Number of ERPP snif profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_erpp_snif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_erpp_nof_erpp_snif_profiles_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_trap_erpp_table_nof
} dnx_data_trap_erpp_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ETPP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_trap_etpp_feature_get(
    int unit,
    dnx_data_trap_etpp_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_trap_etpp_define_nof_etpp_app_traps,
    dnx_data_trap_etpp_define_nof_etpp_user_configurable_profiles,
    dnx_data_trap_etpp_define_nof_etpp_trap_profiles,
    dnx_data_trap_etpp_define_nof_etpp_oam_traps,
    dnx_data_trap_etpp_define_nof_etpp_snif_profiles,
    dnx_data_trap_etpp_define_nof_mtu_profiles,
    dnx_data_trap_etpp_define_nof_etpp_lif_traps,
    dnx_data_trap_etpp_define_max_mtu_value,
    dnx_data_trap_etpp_define_trap_context_port_profile_4b,

    /**
     * Must be last one!
     */
    _dnx_data_trap_etpp_define_nof
} dnx_data_trap_etpp_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_etpp_app_traps
 * Module - 'trap', Submodule - 'etpp', data - 'nof_etpp_app_traps'
 * Number of ETPP application traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_etpp_app_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_nof_etpp_app_traps_get(
    int unit);

/**
 * \brief returns define data of nof_etpp_user_configurable_profiles
 * Module - 'trap', Submodule - 'etpp', data - 'nof_etpp_user_configurable_profiles'
 * Number of user configurable profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_etpp_user_configurable_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_nof_etpp_user_configurable_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_etpp_trap_profiles
 * Module - 'trap', Submodule - 'etpp', data - 'nof_etpp_trap_profiles'
 * Number of ETPP trap profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_etpp_trap_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_nof_etpp_trap_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_etpp_oam_traps
 * Module - 'trap', Submodule - 'etpp', data - 'nof_etpp_oam_traps'
 * Number of ETPP OAM traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_etpp_oam_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_nof_etpp_oam_traps_get(
    int unit);

/**
 * \brief returns define data of nof_etpp_snif_profiles
 * Module - 'trap', Submodule - 'etpp', data - 'nof_etpp_snif_profiles'
 * Number of ETPP snif profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_etpp_snif_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_nof_etpp_snif_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_mtu_profiles
 * Module - 'trap', Submodule - 'etpp', data - 'nof_mtu_profiles'
 * Number of MTU profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mtu_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_nof_mtu_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_etpp_lif_traps
 * Module - 'trap', Submodule - 'etpp', data - 'nof_etpp_lif_traps'
 * Number of ETPP LIF traps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_etpp_lif_traps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_nof_etpp_lif_traps_get(
    int unit);

/**
 * \brief returns define data of max_mtu_value
 * Module - 'trap', Submodule - 'etpp', data - 'max_mtu_value'
 * The maximum MTU value allowed.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_mtu_value - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_max_mtu_value_get(
    int unit);

/**
 * \brief returns define data of trap_context_port_profile_4b
 * Module - 'trap', Submodule - 'etpp', data - 'trap_context_port_profile_4b'
 * The context port profile 4b.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     trap_context_port_profile_4b - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_etpp_trap_context_port_profile_4b_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_trap_etpp_table_nof
} dnx_data_trap_etpp_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE STRENGTH:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_trap_strength_feature_get(
    int unit,
    dnx_data_trap_strength_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_trap_strength_define_max_strength,
    dnx_data_trap_strength_define_max_snp_strength,
    dnx_data_trap_strength_define_max_ingress_to_egress_compressed_strength,
    dnx_data_trap_strength_define_default_trap_strength,
    dnx_data_trap_strength_define_default_snoop_strength,

    /**
     * Must be last one!
     */
    _dnx_data_trap_strength_define_nof
} dnx_data_trap_strength_define_e;

/* Get Data */
/**
 * \brief returns define data of max_strength
 * Module - 'trap', Submodule - 'strength', data - 'max_strength'
 * Max value of strength (4b)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_strength_max_strength_get(
    int unit);

/**
 * \brief returns define data of max_snp_strength
 * Module - 'trap', Submodule - 'strength', data - 'max_snp_strength'
 * Max value of snoop strength (3b)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_snp_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_strength_max_snp_strength_get(
    int unit);

/**
 * \brief returns define data of max_ingress_to_egress_compressed_strength
 * Module - 'trap', Submodule - 'strength', data - 'max_ingress_to_egress_compressed_strength'
 * Max value of ingress compressed strength (3b) mapped to egress strength (4b)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_ingress_to_egress_compressed_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_strength_max_ingress_to_egress_compressed_strength_get(
    int unit);

/**
 * \brief returns numeric data of default_trap_strength
 * Module - 'trap', Submodule - 'strength', data - 'default_trap_strength'
 * Default trap strength used when drop / trap packets to CPU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_trap_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_strength_default_trap_strength_get(
    int unit);

/**
 * \brief returns numeric data of default_snoop_strength
 * Module - 'trap', Submodule - 'strength', data - 'default_snoop_strength'
 * Default snoop strength used when drop / trap packets to CPU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_snoop_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_strength_default_snoop_strength_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_trap_strength_table_nof
} dnx_data_trap_strength_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE REGISTER_NAME_CHANGES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnx_data_trap_register_name_changes_feature_get(
    int unit,
    dnx_data_trap_register_name_changes_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnx_data_trap_register_name_changes_define_out_lif_mcdb_ptr_signal,
    dnx_data_trap_register_name_changes_define_added_n,
    dnx_data_trap_register_name_changes_define_per_pp_port_change,
    dnx_data_trap_register_name_changes_define_visibility_signal_0,

    /**
     * Must be last one!
     */
    _dnx_data_trap_register_name_changes_define_nof
} dnx_data_trap_register_name_changes_define_e;

/* Get Data */
/**
 * \brief returns define data of out_lif_mcdb_ptr_signal
 * Module - 'trap', Submodule - 'register_name_changes', data - 'out_lif_mcdb_ptr_signal'
 * Out_LIF_or_MCDB_Ptr_ACE signal is shifted by bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     out_lif_mcdb_ptr_signal - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_register_name_changes_out_lif_mcdb_ptr_signal_get(
    int unit);

/**
 * \brief returns define data of added_n
 * Module - 'trap', Submodule - 'register_name_changes', data - 'added_n'
 * Register name changed to have an _N at the end.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     added_n - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_register_name_changes_added_n_get(
    int unit);

/**
 * \brief returns define data of per_pp_port_change
 * Module - 'trap', Submodule - 'register_name_changes', data - 'per_pp_port_change'
 * Register names changed to be per PP port.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     per_pp_port_change - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_register_name_changes_per_pp_port_change_get(
    int unit);

/**
 * \brief returns define data of visibility_signal_0
 * Module - 'trap', Submodule - 'register_name_changes', data - 'visibility_signal_0'
 * Visibility signal validation enabled
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     visibility_signal_0 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnx_data_trap_register_name_changes_visibility_signal_0_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_trap_register_name_changes_table_nof
} dnx_data_trap_register_name_changes_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_trap_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_INTERNAL_TRAP_H_*/
/* *INDENT-ON* */
