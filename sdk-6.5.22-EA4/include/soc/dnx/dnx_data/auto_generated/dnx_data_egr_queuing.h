/** \file dnx_data_egr_queuing.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_EGR_QUEUING_H_
/*{*/
#define _DNX_DATA_EGR_QUEUING_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_egr_queuing.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_egr_queuing
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_egr_queuing_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - PARAMS:
 * default values for egr_queuing module
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule params table if_speed_params
 * Table info:
 * per port speed thresholds
 */
typedef struct
{
    /**
     * port speed in GHz
     */
    int speed;
    /**
     * port egq interface ID
     */
    int if_id;
    /**
     * TXI credits
     */
    int crdt_size;
    /**
     * NRDY threshold
     */
    int irdy_thr;
    /**
     * TXQ max bytes threshold
     */
    int txq_max_bytes;
    /**
     * minimum gap between consecutive access to same interface if serving HP Q
     */
    int min_gap_hp;
    /**
     * fqp min gap
     */
    int fqp_min_gap;
} dnx_data_egr_queuing_params_if_speed_params_t;

/**
 * \brief Holds values of submodule params table emr_fifo
 * Table info:
 * emr fifo parameters
 */
typedef struct
{
    /**
     * depth configuration for each FIFO
     */
    int depth;
    /**
     * configuration of almost full threshold
     */
    int almost_full;
    /**
     * configuration of full threshold
     */
    int full;
} dnx_data_egr_queuing_params_emr_fifo_t;

/**
 * \brief Holds values of submodule params table if_speed_params_clk_th
 * Table info:
 * clock rate thresholds in Khz, used as input to if_speed_params
 */
typedef struct
{
    /**
     * clock rate thresholds in Khz
     */
    int max_clock_rate_th;
} dnx_data_egr_queuing_params_if_speed_params_clk_th_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates whether 'port_read_enable' is required before accessing OTM_CALENDAR_CRDT_TABLE (temporary HW issue)
     */
    dnx_data_egr_queuing_params_conditional_crdt_table_access,
    /**
     * Indicates whether counters, which are not supported by j2b0, are to be referenced. Set to 'invalid' for J2B0.
     */
    dnx_data_egr_queuing_params_non_j2b0_counters_are_valid,
    /**
     * Is egq interface attributes using profile
     */
    dnx_data_egr_queuing_params_if_attributes_profile_exist,
    /**
     * Indicates whether access to cos map is per pp port or per tm port
     */
    dnx_data_egr_queuing_params_cos_map_is_per_pp_port,
    /**
     * Indicates whether access to cos map can be arbitrate between per pp port to per tm port
     */
    dnx_data_egr_queuing_params_cos_map_per_pp_or_tm_selector,
    /**
     * support phantom queues feature
     */
    dnx_data_egr_queuing_params_phantom_queues,
    /**
     * support phantom queues probability threshold
     */
    dnx_data_egr_queuing_params_phantom_queues_prob_thresh,
    /**
     * support almost empty delay configuration
     */
    dnx_data_egr_queuing_params_almost_empty_delay,
    /**
     * is fqp_calender_set_select field exist in HW
     */
    dnx_data_egr_queuing_params_fqp_calender_set_select,
    /**
     * is sub calendar feature enable
     */
    dnx_data_egr_queuing_params_sub_calendar,
    /**
     * determine if parameter txq_tdm_irdy_sel exist
     */
    dnx_data_egr_queuing_params_txq_tdm_irdy_sel_exist,
    /**
     * determine if parameter total_shaper_max_burst exist
     */
    dnx_data_egr_queuing_params_total_shaper_max_burst_exist,
    /**
     * determine if traffic class groups to TC mapping is supported, if not assumption is usually 1 to 1 mapping
     */
    dnx_data_egr_queuing_params_tcg_mapping,

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_params_feature_nof
} dnx_data_egr_queuing_params_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_egr_queuing_params_feature_get_f) (
    int unit,
    dnx_data_egr_queuing_params_feature_e feature);

/**
 * \brief returns define data of nof_bits_in_tcg_weight
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_tcg_weight'
 * number of bits in 'weight' representation of a TCG. See EPS_DWM_8P
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_tcg_weight - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_tcg_weight_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_q_pairs_in_ps
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_q_pairs_in_ps'
 * number of bits in 'nof_q_pairs_in_ps' representation. Essentially, log2(nof_q_pairs_in_ps)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_q_pairs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_q_pairs_in_ps_get_f) (
    int unit);

/**
 * \brief returns define data of nof_q_pairs_in_ps
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_q_pairs_in_ps'
 * Number of qpairs per one port scheduler
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_q_pairs_in_ps - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_q_pairs_in_ps_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_q_pair
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_q_pair'
 * number of bits in 'queue pair' representation. Essentially, log2(nof_q_pairs)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_q_pair - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_q_pair_get_f) (
    int unit);

/**
 * \brief returns define data of nof_q_pairs
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_q_pairs'
 * Number of q_pairs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_q_pairs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_q_pairs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_port_schedulers
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_port_schedulers'
 * number of bits in 'nof_port_schedulers' representation. Essentially, log2(nof_port_schedulers)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_port_schedulers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_port_schedulers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_port_schedulers
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_port_schedulers'
 * Number of port schedulers per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_schedulers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_port_schedulers_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_chan_arb_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_chan_arb_calendar_size'
 * number of bits in 'num. of entries in chan_arb calendar' representation. Essentially, log2(chan_arb_calendar_size)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_chan_arb_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_chan_arb_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of chan_arb_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'chan_arb_calendar_size'
 * number of entries in calendar of 'channelized arbiter' (chan_arb)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     chan_arb_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_chan_arb_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_port_prio_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_port_prio_calendar_size'
 * number of bits in 'num. of entries in port_prio calendar' representation. Essentially, log2(port_prio_calendar_size)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_port_prio_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_port_prio_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of port_prio_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'port_prio_calendar_size'
 * number of entries in calendar of 'port priority' (also referred to as TC)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_prio_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_port_prio_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_tcg_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_tcg_calendar_size'
 * number of bits in 'num. of entries in tcg calendar' representation. Essentially, log2(port_prio_calendar_size)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_tcg_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_tcg_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of tcg_calendar_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'tcg_calendar_size'
 * number of entries in calendar of 'tcg' (group of TCs, group of port_prio entries)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcg_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_tcg_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_calendars
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_calendars'
 * number of bits in 'egr nof_calendars' representation. Essentially, log2(nof_calendars)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_calendars_get_f) (
    int unit);

/**
 * \brief returns define data of nof_calendars
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_calendars'
 * Number of calendar-pairs per core. Total number of calendars is twice this value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_calendars - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_calendars_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_egr_interface
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_egr_interface'
 * number of bits in 'egr interface' representation. Essentially, log2(nof_egr_interfaces)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_interface - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_egr_interface_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_mirror_prio
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_mirror_prio'
 * number of bits in mirror priority to check bandwidth
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_mirror_prio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_mirror_prio_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_egr_ch_interface
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_egr_ch_interface'
 * number of bits in 'egr ch interface' representation. Essentially, log2(nof_egr_ch_interfaces)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_egr_ch_interface - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_egr_ch_interface_get_f) (
    int unit);

/**
 * \brief returns define data of nof_egr_interfaces
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_interfaces'
 * Number of egr interfaces, per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_egr_interfaces_get_f) (
    int unit);

/**
 * \brief returns define data of first_lp_egr_interface
 * Module - 'egr_queuing', Submodule - 'params', data - 'first_lp_egr_interface'
 * ID of first Low Priority egr interface
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     first_lp_egr_interface - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_first_lp_egr_interface_get_f) (
    int unit);

/**
 * \brief returns define data of nof_egr_ch_interfaces
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_ch_interfaces'
 * Number of egr channelized interfaces, per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_ch_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_egr_ch_interfaces_get_f) (
    int unit);

/**
 * \brief returns define data of nof_egr_rcy_interfaces
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_rcy_interfaces'
 * Number of egr RCY interfaces, per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_rcy_interfaces - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_egr_rcy_interfaces_get_f) (
    int unit);

/**
 * \brief returns define data of reserved_if
 * Module - 'egr_queuing', Submodule - 'params', data - 'reserved_if'
 * reserved interface (used for dummy flow control mapping in LAG SCH)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     reserved_if - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_reserved_if_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_cpu
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_cpu'
 * cpu interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_cpu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_cpu_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_sat
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_sat'
 * sat interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_sat - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_sat_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_oam
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_oam'
 * oam interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_oam - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_oam_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_olp
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_olp'
 * olp interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_olp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_olp_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_rcy
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_rcy'
 * recycle interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_rcy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_rcy_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_txi_rcy
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_txi_rcy'
 * txi recycle interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_txi_rcy - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_txi_rcy_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_eventor
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_eventor'
 * eventor interface at egr
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_eventor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_eventor_get_f) (
    int unit);

/**
 * \brief returns define data of egr_if_nif_base
 * Module - 'egr_queuing', Submodule - 'params', data - 'egr_if_nif_base'
 * base egress interface for Nif ports
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     egr_if_nif_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_egr_if_nif_base_get_f) (
    int unit);

/**
 * \brief returns define data of cal_res
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_res'
 * Calendar resolution. Conversion coefficient from bits to credits for DATA mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_res - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_cal_res_get_f) (
    int unit);

/**
 * \brief returns define data of cal_res_packet_mode
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_res_packet_mode'
 * Calendar resolution. Conversion coefficient from bits to credits for PACKET mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_res_packet_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_cal_res_packet_mode_get_f) (
    int unit);

/**
 * \brief returns define data of cal_burst_res
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_burst_res'
 * Calendar resolution. Conversion coefficient from bytes to credits. Number of credits per byte. Used for burst size conversion.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_burst_res - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_cal_burst_res_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_cal_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_cal_cal_len'
 * Number of bits in representation of cal_cal_len (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_cal_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_cal_cal_len_get_f) (
    int unit);

/**
 * \brief returns define data of cal_cal_len
 * Module - 'egr_queuing', Submodule - 'params', data - 'cal_cal_len'
 * calcal calendar length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_cal_len - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_cal_cal_len_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nif_cal_len_pqp
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nif_cal_len_pqp'
 * Number of bits in representation of nif_cal_len (log2) for pqp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nif_cal_len_pqp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nif_cal_len_pqp_get_f) (
    int unit);

/**
 * \brief returns define data of nif_cal_len_pqp
 * Module - 'egr_queuing', Submodule - 'params', data - 'nif_cal_len_pqp'
 * nif calendar length for pqp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_cal_len_pqp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nif_cal_len_pqp_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nif_cal_len_fqp
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nif_cal_len_fqp'
 * Number of bits in representation of nif_cal_len (log2) for fqp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nif_cal_len_fqp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nif_cal_len_fqp_get_f) (
    int unit);

/**
 * \brief returns define data of nif_cal_len_fqp
 * Module - 'egr_queuing', Submodule - 'params', data - 'nif_cal_len_fqp'
 * nif calendar length for fqp
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nif_cal_len_fqp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nif_cal_len_fqp_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_tcg
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_tcg'
 * Number of bits in representation of nof_tcg (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_tcg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tcg
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_tcg'
 * Number of TC groups supported by this system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tcg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_tcg_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_in_nof_egr_q_prio
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_bits_in_nof_egr_q_prio'
 * Number of bits in representation of nof_egr_q_prio (log2)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_nof_egr_q_prio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_bits_in_nof_egr_q_prio_get_f) (
    int unit);

/**
 * \brief returns define data of nof_egr_q_prio
 * Module - 'egr_queuing', Submodule - 'params', data - 'nof_egr_q_prio'
 * Number of egress priorities for unscheduled traffic
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_egr_q_prio - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_nof_egr_q_prio_get_f) (
    int unit);

/**
 * \brief returns define data of tcg_min_priorities
 * Module - 'egr_queuing', Submodule - 'params', data - 'tcg_min_priorities'
 * minimum number of priorities supported by tcg
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tcg_min_priorities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_tcg_min_priorities_get_f) (
    int unit);

/**
 * \brief returns define data of max_credit_number
 * Module - 'egr_queuing', Submodule - 'params', data - 'max_credit_number'
 * the maximum number of credits supported
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_credit_number - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_max_credit_number_get_f) (
    int unit);

/**
 * \brief returns define data of max_gbps_rate_egq
 * Module - 'egr_queuing', Submodule - 'params', data - 'max_gbps_rate_egq'
 * EGQ Maximum Gb/s rate. This is the upper boundary, it can be lower depending on the credit size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_gbps_rate_egq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_max_gbps_rate_egq_get_f) (
    int unit);

/**
 * \brief returns define data of txq_iready_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_iready_th'
 * Define ready TXQ treshold in PDs for non TDM queues, when Q is above this treshold FQP block relevant interface in EPS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_iready_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_txq_iready_th_get_f) (
    int unit);

/**
 * \brief returns define data of txq_tdm_iready_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_tdm_iready_th'
 * Define ready TXQ treshold in PDs for TDM queues, when Q is above this treshold FQP block relevant interface in EPS
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_tdm_iready_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_txq_tdm_iready_th_get_f) (
    int unit);

/**
 * \brief returns define data of initial_packet_mode
 * Module - 'egr_queuing', Submodule - 'params', data - 'initial_packet_mode'
 * 'packet mode' value for a newly added port. See type 'bcmCosqControlShaperPacketMode' on bcm_dnx_cosq_control_set
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     initial_packet_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_initial_packet_mode_get_f) (
    int unit);

/**
 * \brief returns define data of sub_calendar_ifc
 * Module - 'egr_queuing', Submodule - 'params', data - 'sub_calendar_ifc'
 * special ifc id for the sub calendar
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sub_calendar_ifc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_sub_calendar_ifc_get_f) (
    int unit);

/**
 * \brief returns define data of txq_max_credits
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_max_credits'
 * Max amount of credits possible according to ESB capacity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_max_credits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_txq_max_credits_get_f) (
    int unit);

/**
 * \brief returns define data of txq_max_credits_reduce_factor
 * Module - 'egr_queuing', Submodule - 'params', data - 'txq_max_credits_reduce_factor'
 * Factor to calculate the max amount of credits allowed based on txq_max_credits and the number of ESB ports allocated
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     txq_max_credits_reduce_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_txq_max_credits_reduce_factor_get_f) (
    int unit);

/**
 * \brief returns define data of pqp_ifc_almost_empty_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'pqp_ifc_almost_empty_th'
 * pqp ifc almost empty threshold.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pqp_ifc_almost_empty_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_pqp_ifc_almost_empty_th_get_f) (
    int unit);

/**
 * \brief returns define data of pqp_port_almost_empty_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'pqp_port_almost_empty_th'
 * pqp port almost empty threshold.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pqp_port_almost_empty_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_pqp_port_almost_empty_th_get_f) (
    int unit);

/**
 * \brief returns define data of pqp_queue_almost_empty_th
 * Module - 'egr_queuing', Submodule - 'params', data - 'pqp_queue_almost_empty_th'
 * pqp queue almost empty threshold.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pqp_queue_almost_empty_th - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_pqp_queue_almost_empty_th_get_f) (
    int unit);

/**
 * \brief returns define data of if_min_gap_priority_size
 * Module - 'egr_queuing', Submodule - 'params', data - 'if_min_gap_priority_size'
 * size in bits of ifc min priority gap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     if_min_gap_priority_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_if_min_gap_priority_size_get_f) (
    int unit);

/**
 * \brief returns define data of fqp_dbf_additional_latency
 * Module - 'egr_queuing', Submodule - 'params', data - 'fqp_dbf_additional_latency'
 * Value to configure the transmit scheduler (FQP scheduler) additional latency for halting Data Buffers pipe to be longer than MCDB.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fqp_dbf_additional_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_fqp_dbf_additional_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of invalid_otm_port
 * Module - 'egr_queuing', Submodule - 'params', data - 'invalid_otm_port'
 * tm port that is marked as invalid (per core)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     invalid_otm_port - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_invalid_otm_port_get_f) (
    int unit);

/**
 * \brief returns numeric data of burst_size_below_mtu
 * Module - 'egr_queuing', Submodule - 'params', data - 'burst_size_below_mtu'
 * indicated whether burst size can be configured bellow MTU
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_size_below_mtu - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_params_burst_size_below_mtu_get_f) (
    int unit);

/**
 * \brief get table if_speed_params entry 
 * per port speed thresholds
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * \param [in] clock_rate_idx - index to table based on the clock rate
 * 
 * \return
 *     if_speed_params - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_if_speed_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_egr_queuing_params_if_speed_params_t *(
    *dnx_data_egr_queuing_params_if_speed_params_get_f) (
    int unit,
    int idx,
    int clock_rate_idx);

/**
 * \brief get table emr_fifo entry 
 * emr fifo parameters
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * \param [in] tdm - tdm exist in the system
 * 
 * \return
 *     emr_fifo - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_emr_fifo_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_egr_queuing_params_emr_fifo_t *(
    *dnx_data_egr_queuing_params_emr_fifo_get_f) (
    int unit,
    int idx,
    int tdm);

/**
 * \brief get table if_speed_params_clk_th entry 
 * clock rate thresholds in Khz, used as input to if_speed_params
 * 
 * \param [in] unit - unit #
 * \param [in] idx - table index
 * 
 * \return
 *     if_speed_params_clk_th - returns the relevant entry values grouped in struct - see dnx_data_egr_queuing_params_if_speed_params_clk_th_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_egr_queuing_params_if_speed_params_clk_th_t *(
    *dnx_data_egr_queuing_params_if_speed_params_clk_th_get_f) (
    int unit,
    int idx);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_EGR_QUEUING - PARAMS:
 * {
 */
/**
 * \brief Interface for egr_queuing params data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_egr_queuing_params_feature_get_f feature_get;
    /**
     * returns define data of nof_bits_in_tcg_weight
     */
    dnx_data_egr_queuing_params_nof_bits_in_tcg_weight_get_f nof_bits_in_tcg_weight_get;
    /**
     * returns define data of nof_bits_in_nof_q_pairs_in_ps
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_q_pairs_in_ps_get_f nof_bits_in_nof_q_pairs_in_ps_get;
    /**
     * returns define data of nof_q_pairs_in_ps
     */
    dnx_data_egr_queuing_params_nof_q_pairs_in_ps_get_f nof_q_pairs_in_ps_get;
    /**
     * returns define data of nof_bits_in_q_pair
     */
    dnx_data_egr_queuing_params_nof_bits_in_q_pair_get_f nof_bits_in_q_pair_get;
    /**
     * returns define data of nof_q_pairs
     */
    dnx_data_egr_queuing_params_nof_q_pairs_get_f nof_q_pairs_get;
    /**
     * returns define data of nof_bits_in_nof_port_schedulers
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_port_schedulers_get_f nof_bits_in_nof_port_schedulers_get;
    /**
     * returns define data of nof_port_schedulers
     */
    dnx_data_egr_queuing_params_nof_port_schedulers_get_f nof_port_schedulers_get;
    /**
     * returns define data of nof_bits_in_chan_arb_calendar_size
     */
    dnx_data_egr_queuing_params_nof_bits_in_chan_arb_calendar_size_get_f nof_bits_in_chan_arb_calendar_size_get;
    /**
     * returns define data of chan_arb_calendar_size
     */
    dnx_data_egr_queuing_params_chan_arb_calendar_size_get_f chan_arb_calendar_size_get;
    /**
     * returns define data of nof_bits_in_port_prio_calendar_size
     */
    dnx_data_egr_queuing_params_nof_bits_in_port_prio_calendar_size_get_f nof_bits_in_port_prio_calendar_size_get;
    /**
     * returns define data of port_prio_calendar_size
     */
    dnx_data_egr_queuing_params_port_prio_calendar_size_get_f port_prio_calendar_size_get;
    /**
     * returns define data of nof_bits_in_tcg_calendar_size
     */
    dnx_data_egr_queuing_params_nof_bits_in_tcg_calendar_size_get_f nof_bits_in_tcg_calendar_size_get;
    /**
     * returns define data of tcg_calendar_size
     */
    dnx_data_egr_queuing_params_tcg_calendar_size_get_f tcg_calendar_size_get;
    /**
     * returns define data of nof_bits_in_nof_calendars
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_calendars_get_f nof_bits_in_nof_calendars_get;
    /**
     * returns define data of nof_calendars
     */
    dnx_data_egr_queuing_params_nof_calendars_get_f nof_calendars_get;
    /**
     * returns define data of nof_bits_in_egr_interface
     */
    dnx_data_egr_queuing_params_nof_bits_in_egr_interface_get_f nof_bits_in_egr_interface_get;
    /**
     * returns define data of nof_bits_mirror_prio
     */
    dnx_data_egr_queuing_params_nof_bits_mirror_prio_get_f nof_bits_mirror_prio_get;
    /**
     * returns define data of nof_bits_in_egr_ch_interface
     */
    dnx_data_egr_queuing_params_nof_bits_in_egr_ch_interface_get_f nof_bits_in_egr_ch_interface_get;
    /**
     * returns define data of nof_egr_interfaces
     */
    dnx_data_egr_queuing_params_nof_egr_interfaces_get_f nof_egr_interfaces_get;
    /**
     * returns define data of first_lp_egr_interface
     */
    dnx_data_egr_queuing_params_first_lp_egr_interface_get_f first_lp_egr_interface_get;
    /**
     * returns define data of nof_egr_ch_interfaces
     */
    dnx_data_egr_queuing_params_nof_egr_ch_interfaces_get_f nof_egr_ch_interfaces_get;
    /**
     * returns define data of nof_egr_rcy_interfaces
     */
    dnx_data_egr_queuing_params_nof_egr_rcy_interfaces_get_f nof_egr_rcy_interfaces_get;
    /**
     * returns define data of reserved_if
     */
    dnx_data_egr_queuing_params_reserved_if_get_f reserved_if_get;
    /**
     * returns define data of egr_if_cpu
     */
    dnx_data_egr_queuing_params_egr_if_cpu_get_f egr_if_cpu_get;
    /**
     * returns define data of egr_if_sat
     */
    dnx_data_egr_queuing_params_egr_if_sat_get_f egr_if_sat_get;
    /**
     * returns define data of egr_if_oam
     */
    dnx_data_egr_queuing_params_egr_if_oam_get_f egr_if_oam_get;
    /**
     * returns define data of egr_if_olp
     */
    dnx_data_egr_queuing_params_egr_if_olp_get_f egr_if_olp_get;
    /**
     * returns define data of egr_if_rcy
     */
    dnx_data_egr_queuing_params_egr_if_rcy_get_f egr_if_rcy_get;
    /**
     * returns define data of egr_if_txi_rcy
     */
    dnx_data_egr_queuing_params_egr_if_txi_rcy_get_f egr_if_txi_rcy_get;
    /**
     * returns define data of egr_if_eventor
     */
    dnx_data_egr_queuing_params_egr_if_eventor_get_f egr_if_eventor_get;
    /**
     * returns define data of egr_if_nif_base
     */
    dnx_data_egr_queuing_params_egr_if_nif_base_get_f egr_if_nif_base_get;
    /**
     * returns define data of cal_res
     */
    dnx_data_egr_queuing_params_cal_res_get_f cal_res_get;
    /**
     * returns define data of cal_res_packet_mode
     */
    dnx_data_egr_queuing_params_cal_res_packet_mode_get_f cal_res_packet_mode_get;
    /**
     * returns define data of cal_burst_res
     */
    dnx_data_egr_queuing_params_cal_burst_res_get_f cal_burst_res_get;
    /**
     * returns define data of nof_bits_in_cal_cal_len
     */
    dnx_data_egr_queuing_params_nof_bits_in_cal_cal_len_get_f nof_bits_in_cal_cal_len_get;
    /**
     * returns define data of cal_cal_len
     */
    dnx_data_egr_queuing_params_cal_cal_len_get_f cal_cal_len_get;
    /**
     * returns define data of nof_bits_in_nif_cal_len_pqp
     */
    dnx_data_egr_queuing_params_nof_bits_in_nif_cal_len_pqp_get_f nof_bits_in_nif_cal_len_pqp_get;
    /**
     * returns define data of nif_cal_len_pqp
     */
    dnx_data_egr_queuing_params_nif_cal_len_pqp_get_f nif_cal_len_pqp_get;
    /**
     * returns define data of nof_bits_in_nif_cal_len_fqp
     */
    dnx_data_egr_queuing_params_nof_bits_in_nif_cal_len_fqp_get_f nof_bits_in_nif_cal_len_fqp_get;
    /**
     * returns define data of nif_cal_len_fqp
     */
    dnx_data_egr_queuing_params_nif_cal_len_fqp_get_f nif_cal_len_fqp_get;
    /**
     * returns define data of nof_bits_in_nof_tcg
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_tcg_get_f nof_bits_in_nof_tcg_get;
    /**
     * returns define data of nof_tcg
     */
    dnx_data_egr_queuing_params_nof_tcg_get_f nof_tcg_get;
    /**
     * returns define data of nof_bits_in_nof_egr_q_prio
     */
    dnx_data_egr_queuing_params_nof_bits_in_nof_egr_q_prio_get_f nof_bits_in_nof_egr_q_prio_get;
    /**
     * returns define data of nof_egr_q_prio
     */
    dnx_data_egr_queuing_params_nof_egr_q_prio_get_f nof_egr_q_prio_get;
    /**
     * returns define data of tcg_min_priorities
     */
    dnx_data_egr_queuing_params_tcg_min_priorities_get_f tcg_min_priorities_get;
    /**
     * returns define data of max_credit_number
     */
    dnx_data_egr_queuing_params_max_credit_number_get_f max_credit_number_get;
    /**
     * returns define data of max_gbps_rate_egq
     */
    dnx_data_egr_queuing_params_max_gbps_rate_egq_get_f max_gbps_rate_egq_get;
    /**
     * returns define data of txq_iready_th
     */
    dnx_data_egr_queuing_params_txq_iready_th_get_f txq_iready_th_get;
    /**
     * returns define data of txq_tdm_iready_th
     */
    dnx_data_egr_queuing_params_txq_tdm_iready_th_get_f txq_tdm_iready_th_get;
    /**
     * returns define data of initial_packet_mode
     */
    dnx_data_egr_queuing_params_initial_packet_mode_get_f initial_packet_mode_get;
    /**
     * returns define data of sub_calendar_ifc
     */
    dnx_data_egr_queuing_params_sub_calendar_ifc_get_f sub_calendar_ifc_get;
    /**
     * returns define data of txq_max_credits
     */
    dnx_data_egr_queuing_params_txq_max_credits_get_f txq_max_credits_get;
    /**
     * returns define data of txq_max_credits_reduce_factor
     */
    dnx_data_egr_queuing_params_txq_max_credits_reduce_factor_get_f txq_max_credits_reduce_factor_get;
    /**
     * returns define data of pqp_ifc_almost_empty_th
     */
    dnx_data_egr_queuing_params_pqp_ifc_almost_empty_th_get_f pqp_ifc_almost_empty_th_get;
    /**
     * returns define data of pqp_port_almost_empty_th
     */
    dnx_data_egr_queuing_params_pqp_port_almost_empty_th_get_f pqp_port_almost_empty_th_get;
    /**
     * returns define data of pqp_queue_almost_empty_th
     */
    dnx_data_egr_queuing_params_pqp_queue_almost_empty_th_get_f pqp_queue_almost_empty_th_get;
    /**
     * returns define data of if_min_gap_priority_size
     */
    dnx_data_egr_queuing_params_if_min_gap_priority_size_get_f if_min_gap_priority_size_get;
    /**
     * returns define data of fqp_dbf_additional_latency
     */
    dnx_data_egr_queuing_params_fqp_dbf_additional_latency_get_f fqp_dbf_additional_latency_get;
    /**
     * returns numeric data of invalid_otm_port
     */
    dnx_data_egr_queuing_params_invalid_otm_port_get_f invalid_otm_port_get;
    /**
     * returns numeric data of burst_size_below_mtu
     */
    dnx_data_egr_queuing_params_burst_size_below_mtu_get_f burst_size_below_mtu_get;
    /**
     * get table if_speed_params entry 
     */
    dnx_data_egr_queuing_params_if_speed_params_get_f if_speed_params_get;
    /**
     * get general info table about table (for example key size)if_speed_params info
     */
    dnxc_data_table_info_get_f if_speed_params_info_get;
    /**
     * get table emr_fifo entry 
     */
    dnx_data_egr_queuing_params_emr_fifo_get_f emr_fifo_get;
    /**
     * get general info table about table (for example key size)emr_fifo info
     */
    dnxc_data_table_info_get_f emr_fifo_info_get;
    /**
     * get table if_speed_params_clk_th entry 
     */
    dnx_data_egr_queuing_params_if_speed_params_clk_th_get_f if_speed_params_clk_th_get;
    /**
     * get general info table about table (for example key size)if_speed_params_clk_th info
     */
    dnxc_data_table_info_get_f if_speed_params_clk_th_info_get;
} dnx_data_if_egr_queuing_params_t;

/*
 * }
 */

/*
 * SUBMODULE  - COMMON_MAX_VAL:
 * Common max values over all calendar types
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_common_max_val_feature_nof
} dnx_data_egr_queuing_common_max_val_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_egr_queuing_common_max_val_feature_get_f) (
    int unit,
    dnx_data_egr_queuing_common_max_val_feature_e feature);

/**
 * \brief returns define data of nof_bits_in_calendar_size
 * Module - 'egr_queuing', Submodule - 'common_max_val', data - 'nof_bits_in_calendar_size'
 * Maximal number of bits representing any calendar size. Essentially, this is log2(calendar_size)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_in_calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_common_max_val_nof_bits_in_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of calendar_size
 * Module - 'egr_queuing', Submodule - 'common_max_val', data - 'calendar_size'
 * Maximal size over all calendar sizes. Essentially, this is 2^nof_bits_in_calendar_size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     calendar_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_common_max_val_calendar_size_get_f) (
    int unit);

/**
 * \brief returns define data of slow_port_speed
 * Module - 'egr_queuing', Submodule - 'common_max_val', data - 'slow_port_speed'
 * Maximal speed of ports that will be added to the sub calendar. units: Mbps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     slow_port_speed - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_common_max_val_slow_port_speed_get_f) (
    int unit);

/**
 * \brief returns define data of mux_calendar_resolution
 * Module - 'egr_queuing', Submodule - 'common_max_val', data - 'mux_calendar_resolution'
 * Resolution of the MUX calendars. units: Mbps
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mux_calendar_resolution - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_common_max_val_mux_calendar_resolution_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_EGR_QUEUING - COMMON_MAX_VAL:
 * {
 */
/**
 * \brief Interface for egr_queuing common_max_val data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_egr_queuing_common_max_val_feature_get_f feature_get;
    /**
     * returns define data of nof_bits_in_calendar_size
     */
    dnx_data_egr_queuing_common_max_val_nof_bits_in_calendar_size_get_f nof_bits_in_calendar_size_get;
    /**
     * returns define data of calendar_size
     */
    dnx_data_egr_queuing_common_max_val_calendar_size_get_f calendar_size_get;
    /**
     * returns define data of slow_port_speed
     */
    dnx_data_egr_queuing_common_max_val_slow_port_speed_get_f slow_port_speed_get;
    /**
     * returns define data of mux_calendar_resolution
     */
    dnx_data_egr_queuing_common_max_val_mux_calendar_resolution_get_f mux_calendar_resolution_get;
} dnx_data_if_egr_queuing_common_max_val_t;

/*
 * }
 */

/*
 * SUBMODULE  - RATE_MEASUREMENT:
 * egress rate measure mechanism. calculates egress rate per EGQ if for various uses
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * support egress rate measure mechanism
     */
    dnx_data_egr_queuing_rate_measurement_is_supported,

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_rate_measurement_feature_nof
} dnx_data_egr_queuing_rate_measurement_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_egr_queuing_rate_measurement_feature_get_f) (
    int unit,
    dnx_data_egr_queuing_rate_measurement_feature_e feature);

/**
 * \brief returns define data of max_interval
 * Module - 'egr_queuing', Submodule - 'rate_measurement', data - 'max_interval'
 * Max interval value for egress rate measure [usec]
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_rate_measurement_max_interval_get_f) (
    int unit);

/**
 * \brief returns define data of promile_factor
 * Module - 'egr_queuing', Submodule - 'rate_measurement', data - 'promile_factor'
 * promile calculation factor for egress rate measure
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     promile_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_rate_measurement_promile_factor_get_f) (
    int unit);

/**
 * \brief returns define data of max_granularity
 * Module - 'egr_queuing', Submodule - 'rate_measurement', data - 'max_granularity'
 * max granularity value
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_rate_measurement_max_granularity_get_f) (
    int unit);

/**
 * \brief returns define data of min_bytes_for_granularity
 * Module - 'egr_queuing', Submodule - 'rate_measurement', data - 'min_bytes_for_granularity'
 * represent the minimum number of bytes to update the rate counter in a single access. if the calculated promile is lower than this value, granularity should increase
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_bytes_for_granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_rate_measurement_min_bytes_for_granularity_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_EGR_QUEUING - RATE_MEASUREMENT:
 * {
 */
/**
 * \brief Interface for egr_queuing rate_measurement data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_egr_queuing_rate_measurement_feature_get_f feature_get;
    /**
     * returns define data of max_interval
     */
    dnx_data_egr_queuing_rate_measurement_max_interval_get_f max_interval_get;
    /**
     * returns define data of promile_factor
     */
    dnx_data_egr_queuing_rate_measurement_promile_factor_get_f promile_factor_get;
    /**
     * returns define data of max_granularity
     */
    dnx_data_egr_queuing_rate_measurement_max_granularity_get_f max_granularity_get;
    /**
     * returns define data of min_bytes_for_granularity
     */
    dnx_data_egr_queuing_rate_measurement_min_bytes_for_granularity_get_f min_bytes_for_granularity_get;
} dnx_data_if_egr_queuing_rate_measurement_t;

/*
 * }
 */

/*
 * SUBMODULE  - PHANTOM_QUEUES:
 * phantom queues feature related info. phantom queues use egr_rate so the info is only used in devices supporting egr_rate feature.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_phantom_queues_feature_nof
} dnx_data_egr_queuing_phantom_queues_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_egr_queuing_phantom_queues_feature_get_f) (
    int unit,
    dnx_data_egr_queuing_phantom_queues_feature_e feature);

/**
 * \brief returns define data of nof_threshold_profiles
 * Module - 'egr_queuing', Submodule - 'phantom_queues', data - 'nof_threshold_profiles'
 * number of phantom queues threshold profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_threshold_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_phantom_queues_nof_threshold_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of max_threshold
 * Module - 'egr_queuing', Submodule - 'phantom_queues', data - 'max_threshold'
 * max value for phantom queues threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_egr_queuing_phantom_queues_max_threshold_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_EGR_QUEUING - PHANTOM_QUEUES:
 * {
 */
/**
 * \brief Interface for egr_queuing phantom_queues data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_egr_queuing_phantom_queues_feature_get_f feature_get;
    /**
     * returns define data of nof_threshold_profiles
     */
    dnx_data_egr_queuing_phantom_queues_nof_threshold_profiles_get_f nof_threshold_profiles_get;
    /**
     * returns define data of max_threshold
     */
    dnx_data_egr_queuing_phantom_queues_max_threshold_get_f max_threshold_get;
} dnx_data_if_egr_queuing_phantom_queues_t;

/*
 * }
 */

/*
 * SUBMODULE  - REASSEMBLY:
 * egress reassembly
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * pairs reassembly stage is part of the pipe line
     */
    dnx_data_egr_queuing_reassembly_prs,

    /**
     * Must be last one!
     */
    _dnx_data_egr_queuing_reassembly_feature_nof
} dnx_data_egr_queuing_reassembly_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_egr_queuing_reassembly_feature_get_f) (
    int unit,
    dnx_data_egr_queuing_reassembly_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_EGR_QUEUING - REASSEMBLY:
 * {
 */
/**
 * \brief Interface for egr_queuing reassembly data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_egr_queuing_reassembly_feature_get_f feature_get;
} dnx_data_if_egr_queuing_reassembly_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_EGR_QUEUING:
 * {
 */
/**
 * \brief Interface for egr_queuing data
 */
typedef struct
{
    /**
     * Interface for egr_queuing params data
     */
    dnx_data_if_egr_queuing_params_t params;
    /**
     * Interface for egr_queuing common_max_val data
     */
    dnx_data_if_egr_queuing_common_max_val_t common_max_val;
    /**
     * Interface for egr_queuing rate_measurement data
     */
    dnx_data_if_egr_queuing_rate_measurement_t rate_measurement;
    /**
     * Interface for egr_queuing phantom_queues data
     */
    dnx_data_if_egr_queuing_phantom_queues_t phantom_queues;
    /**
     * Interface for egr_queuing reassembly data
     */
    dnx_data_if_egr_queuing_reassembly_t reassembly;
} dnx_data_if_egr_queuing_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_egr_queuing_t dnx_data_egr_queuing;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_EGR_QUEUING_H_*/
/* *INDENT-ON* */
