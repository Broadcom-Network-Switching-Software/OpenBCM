/** \file dnx_data_dram.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_DRAM_H_
/*{*/
#define _DNX_DATA_DRAM_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm_int/dnx/dram/hbmc/hbmc.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_dram.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_dram
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_dram_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - HBM:
 * HBM parameters and defines
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule hbm table channel_symmetric_regs
 * Table info:
 * per channel list of symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_not_symmetric_regs
 * Table info:
 * per channel list of not symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_not_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_symmetric_regs
 * Table info:
 * per controller list of symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_not_symmetric_regs
 * Table info:
 * per controller list of not symmetric registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_not_symmetric_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_interrupt_regs
 * Table info:
 * per channel list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_interrupt_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_interrupt_regs
 * Table info:
 * per controller list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_interrupt_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_debug_regs
 * Table info:
 * per channel list of debug registers - should be preented if value is not reset value
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * string to explain that this register's value is as expected (reset value)
     */
    char *reassuring_str;
} dnx_data_dram_hbm_channel_debug_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_counter_regs
 * Table info:
 * per channel list of counter registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_channel_counter_regs_t;

/**
 * \brief Holds values of submodule hbm table channel_type_regs
 * Table info:
 * per channel list of registers that require per type printing
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * printing type
     */
    dnx_hbmc_diag_registers_type_t type;
} dnx_data_dram_hbm_channel_type_regs_t;

/**
 * \brief Holds values of submodule hbm table controller_info_regs
 * Table info:
 * per contorller list of info registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_hbm_controller_info_regs_t;

/**
 * \brief Holds values of submodule hbm table bist
 * Table info:
 * BIST configuration
 */
typedef struct
{
    /**
     * The seed of the PRBS
     */
    uint32 prbs_seeds[HBMC_SHMOO_BIST_NOF_PRBS_DATA_SEEDS];
    /**
     * Number of commands to the same row (for each bank)
     */
    uint32 same_row_commands;
} dnx_data_dram_hbm_bist_t;

/**
 * \brief Holds values of submodule hbm table hbc_last_in_chain
 * Table info:
 * Mark the last HBC block in SBUS chain
 */
typedef struct
{
    /**
     * is last in chain
     */
    uint32 is_last_in_chain;
} dnx_data_dram_hbm_hbc_last_in_chain_t;

/**
 * \brief Holds values of submodule hbm table hbc_sbus_chain
 * Table info:
 * The order of FSRDs in the SBUS chain
 */
typedef struct
{
    /**
     * The index of SBUS chain
     */
    int sbus_chain;
} dnx_data_dram_hbm_hbc_sbus_chain_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * hbm supported indication
     */
    dnx_data_dram_hbm_is_supported,
    /**
     * indication if dword alignemnt check is required for this architecture
     */
    dnx_data_dram_hbm_dword_alignment_check,
    /**
     * Indicates whether there is a 'low-temperature' forbidden range for HBM
     */
    dnx_data_dram_hbm_low_temperature_dram_protction,
    /**
     * Deleting dram buffers (marking them as faulty) is possible during 'init sequence'
     */
    dnx_data_dram_hbm_is_delete_bdb_supported,
    /**
     * Indication whether cpu2tap access to the HBM is supported
     */
    dnx_data_dram_hbm_cpu2tap_access,
    /**
     * Indication whether seamless commands to same bank control is supported
     */
    dnx_data_dram_hbm_seamless_commands_to_same_bank_control,
    /**
     * Reading vendor info is not supported since it can cause cpu2tap problems
     */
    dnx_data_dram_hbm_vendor_info_disable,
    /**
     * The HBM PHY was provided by the APD group in Broadcom
     */
    dnx_data_dram_hbm_apd_phy,
    /**
     * The channels can be reached by the 'remote controller' mechanism (which includes HRC blocks and 'fake' TDU blocks)
     */
    dnx_data_dram_hbm_is_hrc_supported,
    /**
     * A threshold needs to be set upon the Write Data Source memory in order to prevent WDS overflow
     */
    dnx_data_dram_hbm_channel_wds_inflight_threshold,
    /**
     * Loading the device in freezing temperature is supported, and the DRAM initialization can be skipped in freezing temperature.
     */
    dnx_data_dram_hbm_is_freeze_boot_supported,

    /**
     * Must be last one!
     */
    _dnx_data_dram_hbm_feature_nof
} dnx_data_dram_hbm_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_hbm_feature_get_f) (
    int unit,
    dnx_data_dram_hbm_feature_e feature);

/**
 * \brief returns numeric data of burst_length
 * Module - 'dram', Submodule - 'hbm', data - 'burst_length'
 * burst length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     burst_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_burst_length_get_f) (
    int unit);

/**
 * \brief returns numeric data of stop_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_temp_threshold'
 * temperature threshold (C degrees) above which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_stop_traffic_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of stop_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'stop_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) below which the HBM should not recieve packets anymore
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     stop_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_stop_traffic_low_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of restore_traffic_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_temp_threshold'
 * temperature threshold (C degrees) below which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_restore_traffic_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of restore_traffic_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'restore_traffic_low_temp_threshold'
 * Low temperature threshold (C degrees) above which the HBM should be reassigned to usage in the traffic flow
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     restore_traffic_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_restore_traffic_low_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of usec_between_temp_samples
 * Module - 'dram', Submodule - 'hbm', data - 'usec_between_temp_samples'
 * time in usecs to wait between HBM temperature sampling
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     usec_between_temp_samples - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_usec_between_temp_samples_get_f) (
    int unit);

/**
 * \brief returns numeric data of power_down_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_temp_threshold'
 * temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_power_down_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of power_down_low_temp_threshold
 * Module - 'dram', Submodule - 'hbm', data - 'power_down_low_temp_threshold'
 * Low temperature threshold, for doing DRAM shut down
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     power_down_low_temp_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_power_down_low_temp_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of dram_temp_monitor_enable
 * Module - 'dram', Submodule - 'hbm', data - 'dram_temp_monitor_enable'
 * enable/disable driver temperature monitoring
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_temp_monitor_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_dram_temp_monitor_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of start_disabled
 * Module - 'dram', Submodule - 'hbm', data - 'start_disabled'
 * do not start DRAM during BCM init
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     start_disabled - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_start_disabled_get_f) (
    int unit);

/**
 * \brief returns numeric data of output_enable_length
 * Module - 'dram', Submodule - 'hbm', data - 'output_enable_length'
 * Output enable length pipeline param
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     output_enable_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_output_enable_length_get_f) (
    int unit);

/**
 * \brief returns numeric data of output_enable_delay
 * Module - 'dram', Submodule - 'hbm', data - 'output_enable_delay'
 * Output enable delay pipeline param
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     output_enable_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_output_enable_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of driver_strength
 * Module - 'dram', Submodule - 'hbm', data - 'driver_strength'
 * nominal driver strength
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     driver_strength - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_driver_strength_get_f) (
    int unit);

/**
 * \brief returns numeric data of t_rdlat_offset
 * Module - 'dram', Submodule - 'hbm', data - 't_rdlat_offset'
 * PHY FIFO read latency param
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     t_rdlat_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_t_rdlat_offset_get_f) (
    int unit);

/**
 * \brief returns define data of default_model_part_num
 * Module - 'dram', Submodule - 'hbm', data - 'default_model_part_num'
 * default model part number
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     default_model_part_num - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_default_model_part_num_get_f) (
    int unit);

/**
 * \brief returns define data of nof_channel_dwords
 * Module - 'dram', Submodule - 'hbm', data - 'nof_channel_dwords'
 * Number of DWORDs in a channel
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channel_dwords - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_nof_channel_dwords_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tdu_per_core
 * Module - 'dram', Submodule - 'hbm', data - 'nof_tdu_per_core'
 * Number of TDU blocks per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tdu_per_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_nof_tdu_per_core_get_f) (
    int unit);

/**
 * \brief returns define data of wds_size
 * Module - 'dram', Submodule - 'hbm', data - 'wds_size'
 * Size of the Write Data Source memory
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wds_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_hbm_wds_size_get_f) (
    int unit);

/**
 * \brief get table channel_symmetric_regs entry 
 * per channel list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_symmetric_regs_t *(
    *dnx_data_dram_hbm_channel_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_not_symmetric_regs entry 
 * per channel list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_not_symmetric_regs_t *(
    *dnx_data_dram_hbm_channel_not_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_symmetric_regs entry 
 * per controller list of symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_symmetric_regs_t *(
    *dnx_data_dram_hbm_controller_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_not_symmetric_regs entry 
 * per controller list of not symmetric registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_not_symmetric_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_not_symmetric_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_not_symmetric_regs_t *(
    *dnx_data_dram_hbm_controller_not_symmetric_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_interrupt_regs_t *(
    *dnx_data_dram_hbm_channel_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per controller list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_interrupt_regs_t *(
    *dnx_data_dram_hbm_controller_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_debug_regs_t *(
    *dnx_data_dram_hbm_channel_debug_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_counter_regs_t *(
    *dnx_data_dram_hbm_channel_counter_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_channel_type_regs_t *(
    *dnx_data_dram_hbm_channel_type_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_controller_info_regs_t *(
    *dnx_data_dram_hbm_controller_info_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table bist entry 
 * BIST configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_bist_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_bist_t *(
    *dnx_data_dram_hbm_bist_get_f) (
    int unit);

/**
 * \brief get table hbc_last_in_chain entry 
 * Mark the last HBC block in SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] dram_bitmap - active drams bitmap
 * \param [in] dram_index - dram index
 * 
 * \return
 *     hbc_last_in_chain - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_hbc_last_in_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_hbc_last_in_chain_t *(
    *dnx_data_dram_hbm_hbc_last_in_chain_get_f) (
    int unit,
    int dram_bitmap,
    int dram_index);

/**
 * \brief get table hbc_sbus_chain entry 
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] channel - hbc channel
 * 
 * \return
 *     hbc_sbus_chain - returns the relevant entry values grouped in struct - see dnx_data_dram_hbm_hbc_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_hbm_hbc_sbus_chain_t *(
    *dnx_data_dram_hbm_hbc_sbus_chain_get_f) (
    int unit,
    int channel);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - HBM:
 * {
 */
/**
 * \brief Interface for dram hbm data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_hbm_feature_get_f feature_get;
    /**
     * returns numeric data of burst_length
     */
    dnx_data_dram_hbm_burst_length_get_f burst_length_get;
    /**
     * returns numeric data of stop_traffic_temp_threshold
     */
    dnx_data_dram_hbm_stop_traffic_temp_threshold_get_f stop_traffic_temp_threshold_get;
    /**
     * returns numeric data of stop_traffic_low_temp_threshold
     */
    dnx_data_dram_hbm_stop_traffic_low_temp_threshold_get_f stop_traffic_low_temp_threshold_get;
    /**
     * returns numeric data of restore_traffic_temp_threshold
     */
    dnx_data_dram_hbm_restore_traffic_temp_threshold_get_f restore_traffic_temp_threshold_get;
    /**
     * returns numeric data of restore_traffic_low_temp_threshold
     */
    dnx_data_dram_hbm_restore_traffic_low_temp_threshold_get_f restore_traffic_low_temp_threshold_get;
    /**
     * returns numeric data of usec_between_temp_samples
     */
    dnx_data_dram_hbm_usec_between_temp_samples_get_f usec_between_temp_samples_get;
    /**
     * returns numeric data of power_down_temp_threshold
     */
    dnx_data_dram_hbm_power_down_temp_threshold_get_f power_down_temp_threshold_get;
    /**
     * returns numeric data of power_down_low_temp_threshold
     */
    dnx_data_dram_hbm_power_down_low_temp_threshold_get_f power_down_low_temp_threshold_get;
    /**
     * returns numeric data of dram_temp_monitor_enable
     */
    dnx_data_dram_hbm_dram_temp_monitor_enable_get_f dram_temp_monitor_enable_get;
    /**
     * returns numeric data of start_disabled
     */
    dnx_data_dram_hbm_start_disabled_get_f start_disabled_get;
    /**
     * returns numeric data of output_enable_length
     */
    dnx_data_dram_hbm_output_enable_length_get_f output_enable_length_get;
    /**
     * returns numeric data of output_enable_delay
     */
    dnx_data_dram_hbm_output_enable_delay_get_f output_enable_delay_get;
    /**
     * returns numeric data of driver_strength
     */
    dnx_data_dram_hbm_driver_strength_get_f driver_strength_get;
    /**
     * returns numeric data of t_rdlat_offset
     */
    dnx_data_dram_hbm_t_rdlat_offset_get_f t_rdlat_offset_get;
    /**
     * returns define data of default_model_part_num
     */
    dnx_data_dram_hbm_default_model_part_num_get_f default_model_part_num_get;
    /**
     * returns define data of nof_channel_dwords
     */
    dnx_data_dram_hbm_nof_channel_dwords_get_f nof_channel_dwords_get;
    /**
     * returns define data of nof_tdu_per_core
     */
    dnx_data_dram_hbm_nof_tdu_per_core_get_f nof_tdu_per_core_get;
    /**
     * returns define data of wds_size
     */
    dnx_data_dram_hbm_wds_size_get_f wds_size_get;
    /**
     * get table channel_symmetric_regs entry 
     */
    dnx_data_dram_hbm_channel_symmetric_regs_get_f channel_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)channel_symmetric_regs info
     */
    dnxc_data_table_info_get_f channel_symmetric_regs_info_get;
    /**
     * get table channel_not_symmetric_regs entry 
     */
    dnx_data_dram_hbm_channel_not_symmetric_regs_get_f channel_not_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)channel_not_symmetric_regs info
     */
    dnxc_data_table_info_get_f channel_not_symmetric_regs_info_get;
    /**
     * get table controller_symmetric_regs entry 
     */
    dnx_data_dram_hbm_controller_symmetric_regs_get_f controller_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)controller_symmetric_regs info
     */
    dnxc_data_table_info_get_f controller_symmetric_regs_info_get;
    /**
     * get table controller_not_symmetric_regs entry 
     */
    dnx_data_dram_hbm_controller_not_symmetric_regs_get_f controller_not_symmetric_regs_get;
    /**
     * get general info table about table (for example key size)controller_not_symmetric_regs info
     */
    dnxc_data_table_info_get_f controller_not_symmetric_regs_info_get;
    /**
     * get table channel_interrupt_regs entry 
     */
    dnx_data_dram_hbm_channel_interrupt_regs_get_f channel_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)channel_interrupt_regs info
     */
    dnxc_data_table_info_get_f channel_interrupt_regs_info_get;
    /**
     * get table controller_interrupt_regs entry 
     */
    dnx_data_dram_hbm_controller_interrupt_regs_get_f controller_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)controller_interrupt_regs info
     */
    dnxc_data_table_info_get_f controller_interrupt_regs_info_get;
    /**
     * get table channel_debug_regs entry 
     */
    dnx_data_dram_hbm_channel_debug_regs_get_f channel_debug_regs_get;
    /**
     * get general info table about table (for example key size)channel_debug_regs info
     */
    dnxc_data_table_info_get_f channel_debug_regs_info_get;
    /**
     * get table channel_counter_regs entry 
     */
    dnx_data_dram_hbm_channel_counter_regs_get_f channel_counter_regs_get;
    /**
     * get general info table about table (for example key size)channel_counter_regs info
     */
    dnxc_data_table_info_get_f channel_counter_regs_info_get;
    /**
     * get table channel_type_regs entry 
     */
    dnx_data_dram_hbm_channel_type_regs_get_f channel_type_regs_get;
    /**
     * get general info table about table (for example key size)channel_type_regs info
     */
    dnxc_data_table_info_get_f channel_type_regs_info_get;
    /**
     * get table controller_info_regs entry 
     */
    dnx_data_dram_hbm_controller_info_regs_get_f controller_info_regs_get;
    /**
     * get general info table about table (for example key size)controller_info_regs info
     */
    dnxc_data_table_info_get_f controller_info_regs_info_get;
    /**
     * get table bist entry 
     */
    dnx_data_dram_hbm_bist_get_f bist_get;
    /**
     * get general info table about table (for example key size)bist info
     */
    dnxc_data_table_info_get_f bist_info_get;
    /**
     * get table hbc_last_in_chain entry 
     */
    dnx_data_dram_hbm_hbc_last_in_chain_get_f hbc_last_in_chain_get;
    /**
     * get general info table about table (for example key size)hbc_last_in_chain info
     */
    dnxc_data_table_info_get_f hbc_last_in_chain_info_get;
    /**
     * get table hbc_sbus_chain entry 
     */
    dnx_data_dram_hbm_hbc_sbus_chain_get_f hbc_sbus_chain_get;
    /**
     * get general info table about table (for example key size)hbc_sbus_chain info
     */
    dnxc_data_table_info_get_f hbc_sbus_chain_info_get;
} dnx_data_if_dram_hbm_t;

/*
 * }
 */

/*
 * SUBMODULE  - GDDR6:
 * GDDR6 parameters and defines
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule gddr6 table refresh_intervals
 * Table info:
 * refresh intervals timing parameters
 */
typedef struct
{
    /**
     * trefiab timing parameters
     */
    uint32 trefiab;
    /**
     * trefiab_acc timing parameters
     */
    uint32 trefiab_acc;
    /**
     * trefisb timing parameters
     */
    uint32 trefisb;
} dnx_data_dram_gddr6_refresh_intervals_t;

/**
 * \brief Holds values of submodule gddr6 table dq_map
 * Table info:
 * DQ swap mapping on boards
 */
typedef struct
{
    /**
     * dq map
     */
    uint8 dq_map[8];
} dnx_data_dram_gddr6_dq_map_t;

/**
 * \brief Holds values of submodule gddr6 table dq_channel_swap
 * Table info:
 * DQ channel swap mapping on boards
 */
typedef struct
{
    /**
     * dq map
     */
    uint8 dq_channel_swap;
} dnx_data_dram_gddr6_dq_channel_swap_t;

/**
 * \brief Holds values of submodule gddr6 table dq_byte_map
 * Table info:
 * DQ bytes swap mapping on boards
 */
typedef struct
{
    /**
     * dq byte map
     */
    uint8 dq_byte_map;
} dnx_data_dram_gddr6_dq_byte_map_t;

/**
 * \brief Holds values of submodule gddr6 table ca_map
 * Table info:
 * command address bit swap mapping on boards
 */
typedef struct
{
    /**
     * ca map
     */
    uint8 ca_map[12];
} dnx_data_dram_gddr6_ca_map_t;

/**
 * \brief Holds values of submodule gddr6 table cadt_byte_map
 * Table info:
 * bytes swapping on boards
 */
typedef struct
{
    /**
     * cadt byte map
     */
    uint8 cadt_byte_map;
} dnx_data_dram_gddr6_cadt_byte_map_t;

/**
 * \brief Holds values of submodule gddr6 table channel_regs
 * Table info:
 * per channel list of registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_channel_regs_t;

/**
 * \brief Holds values of submodule gddr6 table controller_regs
 * Table info:
 * per phy controller list of registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_controller_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_interrupt_regs
 * Table info:
 * per channel list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_channel_interrupt_regs_t;

/**
 * \brief Holds values of submodule gddr6 table controller_interrupt_regs
 * Table info:
 * per phy list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_controller_interrupt_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_debug_regs
 * Table info:
 * per channel list of debug registers - should be preented if value is not reset value
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * string to explain that this register's value is as expected (reset value)
     */
    char *reassuring_str;
} dnx_data_dram_gddr6_channel_debug_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_counter_regs
 * Table info:
 * per channel list of counter registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_channel_counter_regs_t;

/**
 * \brief Holds values of submodule gddr6 table channel_type_regs
 * Table info:
 * per channel list of registers that require per type printing
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
    /**
     * printing type
     */
    dnx_hbmc_diag_registers_type_t type;
} dnx_data_dram_gddr6_channel_type_regs_t;

/**
 * \brief Holds values of submodule gddr6 table controller_info_regs
 * Table info:
 * per contorller list of info registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_gddr6_controller_info_regs_t;

/**
 * \brief Holds values of submodule gddr6 table master_phy
 * Table info:
 * The resistors for ZQ calibration are connected only to one of the drams, which we denote as master phy. The other dram is denoted as slave phy
 */
typedef struct
{
    /**
     * The index of the master dram
     */
    uint32 master_dram_index;
} dnx_data_dram_gddr6_master_phy_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * gddr supported indication
     */
    dnx_data_dram_gddr6_is_supported,
    /**
     * allow disabling read crc
     */
    dnx_data_dram_gddr6_allow_disable_read_crc,
    /**
     * allow per bank and all banks refresh to be interleaved
     */
    dnx_data_dram_gddr6_interleaved_refresh_cycles,
    /**
     * allow wait for Wr/Rd swith to perform AB refresh
     */
    dnx_data_dram_gddr6_refresh_pend_switch,
    /**
     * perform MRS to exit CADT mode at the end of CADT
     */
    dnx_data_dram_gddr6_cadt_exit_mode_when_done,
    /**
     * Periodic temperature readout
     */
    dnx_data_dram_gddr6_periodic_temp_readout,
    dnx_data_dram_gddr6_controller_coherency_handling_mode,

    /**
     * Must be last one!
     */
    _dnx_data_dram_gddr6_feature_nof
} dnx_data_dram_gddr6_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_gddr6_feature_get_f) (
    int unit,
    dnx_data_dram_gddr6_feature_e feature);

/**
 * \brief returns define data of nof_ca_bits
 * Module - 'dram', Submodule - 'gddr6', data - 'nof_ca_bits'
 * number of command address bits
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_ca_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_nof_ca_bits_get_f) (
    int unit);

/**
 * \brief returns define data of bytes_per_channel
 * Module - 'dram', Submodule - 'gddr6', data - 'bytes_per_channel'
 * bytes per channel in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bytes_per_channel - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_bytes_per_channel_get_f) (
    int unit);

/**
 * \brief returns define data of training_fifo_depth
 * Module - 'dram', Submodule - 'gddr6', data - 'training_fifo_depth'
 * the depth of the training fifo in GDDR6 dram
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     training_fifo_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_training_fifo_depth_get_f) (
    int unit);

/**
 * \brief returns define data of readout_to_readout_prd
 * Module - 'dram', Submodule - 'gddr6', data - 'readout_to_readout_prd'
 * Number of AB (all-banks) refresh to wait between consecutive temperature readout iterations
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     readout_to_readout_prd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_readout_to_readout_prd_get_f) (
    int unit);

/**
 * \brief returns define data of refresh_to_readout_prd
 * Module - 'dram', Submodule - 'gddr6', data - 'refresh_to_readout_prd'
 * Period between AB (all-banks) refresh to MRS command triggering the temperature readout
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_to_readout_prd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_refresh_to_readout_prd_get_f) (
    int unit);

/**
 * \brief returns define data of readout_done_to_done_prd
 * Module - 'dram', Submodule - 'gddr6', data - 'readout_done_to_done_prd'
 * Period between vendor_id engine done till readout engine done
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     readout_done_to_done_prd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_readout_done_to_done_prd_get_f) (
    int unit);

/**
 * \brief returns numeric data of refresh_mechanism_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'refresh_mechanism_enable'
 * TSM refresh mechanism enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_mechanism_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_refresh_mechanism_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'bist_enable'
 * DRAM bist enable
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_bist_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of dynamic_calibration_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'dynamic_calibration_enable'
 * Enable dynamic calibration on init
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_calibration_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_dynamic_calibration_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of cdr_enable
 * Module - 'dram', Submodule - 'gddr6', data - 'cdr_enable'
 * Enable CDR step when running dram tune on init
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cdr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_cdr_enable_get_f) (
    int unit);

/**
 * \brief returns numeric data of write_recovery
 * Module - 'dram', Submodule - 'gddr6', data - 'write_recovery'
 * write recovery
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_recovery - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_write_recovery_get_f) (
    int unit);

/**
 * \brief returns numeric data of cabi
 * Module - 'dram', Submodule - 'gddr6', data - 'cabi'
 * enable cabi
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cabi - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_cabi_get_f) (
    int unit);

/**
 * \brief returns numeric data of dram_mode
 * Module - 'dram', Submodule - 'gddr6', data - 'dram_mode'
 * dram mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_dram_mode_get_f) (
    int unit);

/**
 * \brief returns numeric data of cal_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cal_termination'
 * CAL Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cal_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_cal_termination_get_f) (
    int unit);

/**
 * \brief returns numeric data of cah_termination
 * Module - 'dram', Submodule - 'gddr6', data - 'cah_termination'
 * CAH Termination
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cah_termination - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_cah_termination_get_f) (
    int unit);

/**
 * \brief returns numeric data of command_pipe_extra_delay
 * Module - 'dram', Submodule - 'gddr6', data - 'command_pipe_extra_delay'
 * command pipe extra delay
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_pipe_extra_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_command_pipe_extra_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of use_11bits_ca
 * Module - 'dram', Submodule - 'gddr6', data - 'use_11bits_ca'
 * use 11bits for command address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     use_11bits_ca - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_use_11bits_ca_get_f) (
    int unit);

/**
 * \brief returns numeric data of ck_odt
 * Module - 'dram', Submodule - 'gddr6', data - 'ck_odt'
 * CK ODT
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     ck_odt - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_ck_odt_get_f) (
    int unit);

/**
 * \brief returns numeric data of dynamic_calibration_period
 * Module - 'dram', Submodule - 'gddr6', data - 'dynamic_calibration_period'
 * time between 2 iterations of dynamic calibration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dynamic_calibration_period - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_gddr6_dynamic_calibration_period_get_f) (
    int unit);

/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_refresh_intervals_t *(
    *dnx_data_dram_gddr6_refresh_intervals_get_f) (
    int unit);

/**
 * \brief get table dq_map entry 
 * DQ swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - bit on dram
 * 
 * \return
 *     dq_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_dq_map_t *(
    *dnx_data_dram_gddr6_dq_map_get_f) (
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table dq_channel_swap entry 
 * DQ channel swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * 
 * \return
 *     dq_channel_swap - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_channel_swap_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_dq_channel_swap_t *(
    *dnx_data_dram_gddr6_dq_channel_swap_get_f) (
    int unit,
    int dram_index);

/**
 * \brief get table dq_byte_map entry 
 * DQ bytes swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] byte - byte on dram
 * 
 * \return
 *     dq_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_dq_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_dq_byte_map_t *(
    *dnx_data_dram_gddr6_dq_byte_map_get_f) (
    int unit,
    int dram_index,
    int byte);

/**
 * \brief get table ca_map entry 
 * command address bit swap mapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - command address bit
 * 
 * \return
 *     ca_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_ca_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_ca_map_t *(
    *dnx_data_dram_gddr6_ca_map_get_f) (
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table cadt_byte_map entry 
 * bytes swapping on boards
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - dram index
 * \param [in] channel - dram controller channel
 * 
 * \return
 *     cadt_byte_map - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_cadt_byte_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_cadt_byte_map_t *(
    *dnx_data_dram_gddr6_cadt_byte_map_get_f) (
    int unit,
    int dram_index,
    int channel);

/**
 * \brief get table channel_regs entry 
 * per channel list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_regs_t *(
    *dnx_data_dram_gddr6_channel_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_regs entry 
 * per phy controller list of registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_controller_regs_t *(
    *dnx_data_dram_gddr6_controller_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_interrupt_regs entry 
 * per channel list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_interrupt_regs_t *(
    *dnx_data_dram_gddr6_channel_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_interrupt_regs entry 
 * per phy list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_controller_interrupt_regs_t *(
    *dnx_data_dram_gddr6_controller_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_debug_regs entry 
 * per channel list of debug registers - should be preented if value is not reset value
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_debug_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_debug_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_debug_regs_t *(
    *dnx_data_dram_gddr6_channel_debug_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_counter_regs entry 
 * per channel list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_counter_regs_t *(
    *dnx_data_dram_gddr6_channel_counter_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table channel_type_regs entry 
 * per channel list of registers that require per type printing
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     channel_type_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_channel_type_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_channel_type_regs_t *(
    *dnx_data_dram_gddr6_channel_type_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table controller_info_regs entry 
 * per contorller list of info registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     controller_info_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_controller_info_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_controller_info_regs_t *(
    *dnx_data_dram_gddr6_controller_info_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table master_phy entry 
 * The resistors for ZQ calibration are connected only to one of the drams, which we denote as master phy. The other dram is denoted as slave phy
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - index of dram
 * 
 * \return
 *     master_phy - returns the relevant entry values grouped in struct - see dnx_data_dram_gddr6_master_phy_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_gddr6_master_phy_t *(
    *dnx_data_dram_gddr6_master_phy_get_f) (
    int unit,
    int dram_index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - GDDR6:
 * {
 */
/**
 * \brief Interface for dram gddr6 data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_gddr6_feature_get_f feature_get;
    /**
     * returns define data of nof_ca_bits
     */
    dnx_data_dram_gddr6_nof_ca_bits_get_f nof_ca_bits_get;
    /**
     * returns define data of bytes_per_channel
     */
    dnx_data_dram_gddr6_bytes_per_channel_get_f bytes_per_channel_get;
    /**
     * returns define data of training_fifo_depth
     */
    dnx_data_dram_gddr6_training_fifo_depth_get_f training_fifo_depth_get;
    /**
     * returns define data of readout_to_readout_prd
     */
    dnx_data_dram_gddr6_readout_to_readout_prd_get_f readout_to_readout_prd_get;
    /**
     * returns define data of refresh_to_readout_prd
     */
    dnx_data_dram_gddr6_refresh_to_readout_prd_get_f refresh_to_readout_prd_get;
    /**
     * returns define data of readout_done_to_done_prd
     */
    dnx_data_dram_gddr6_readout_done_to_done_prd_get_f readout_done_to_done_prd_get;
    /**
     * returns numeric data of refresh_mechanism_enable
     */
    dnx_data_dram_gddr6_refresh_mechanism_enable_get_f refresh_mechanism_enable_get;
    /**
     * returns numeric data of bist_enable
     */
    dnx_data_dram_gddr6_bist_enable_get_f bist_enable_get;
    /**
     * returns numeric data of dynamic_calibration_enable
     */
    dnx_data_dram_gddr6_dynamic_calibration_enable_get_f dynamic_calibration_enable_get;
    /**
     * returns numeric data of cdr_enable
     */
    dnx_data_dram_gddr6_cdr_enable_get_f cdr_enable_get;
    /**
     * returns numeric data of write_recovery
     */
    dnx_data_dram_gddr6_write_recovery_get_f write_recovery_get;
    /**
     * returns numeric data of cabi
     */
    dnx_data_dram_gddr6_cabi_get_f cabi_get;
    /**
     * returns numeric data of dram_mode
     */
    dnx_data_dram_gddr6_dram_mode_get_f dram_mode_get;
    /**
     * returns numeric data of cal_termination
     */
    dnx_data_dram_gddr6_cal_termination_get_f cal_termination_get;
    /**
     * returns numeric data of cah_termination
     */
    dnx_data_dram_gddr6_cah_termination_get_f cah_termination_get;
    /**
     * returns numeric data of command_pipe_extra_delay
     */
    dnx_data_dram_gddr6_command_pipe_extra_delay_get_f command_pipe_extra_delay_get;
    /**
     * returns numeric data of use_11bits_ca
     */
    dnx_data_dram_gddr6_use_11bits_ca_get_f use_11bits_ca_get;
    /**
     * returns numeric data of ck_odt
     */
    dnx_data_dram_gddr6_ck_odt_get_f ck_odt_get;
    /**
     * returns numeric data of dynamic_calibration_period
     */
    dnx_data_dram_gddr6_dynamic_calibration_period_get_f dynamic_calibration_period_get;
    /**
     * get table refresh_intervals entry 
     */
    dnx_data_dram_gddr6_refresh_intervals_get_f refresh_intervals_get;
    /**
     * get general info table about table (for example key size)refresh_intervals info
     */
    dnxc_data_table_info_get_f refresh_intervals_info_get;
    /**
     * get table dq_map entry 
     */
    dnx_data_dram_gddr6_dq_map_get_f dq_map_get;
    /**
     * get general info table about table (for example key size)dq_map info
     */
    dnxc_data_table_info_get_f dq_map_info_get;
    /**
     * get table dq_channel_swap entry 
     */
    dnx_data_dram_gddr6_dq_channel_swap_get_f dq_channel_swap_get;
    /**
     * get general info table about table (for example key size)dq_channel_swap info
     */
    dnxc_data_table_info_get_f dq_channel_swap_info_get;
    /**
     * get table dq_byte_map entry 
     */
    dnx_data_dram_gddr6_dq_byte_map_get_f dq_byte_map_get;
    /**
     * get general info table about table (for example key size)dq_byte_map info
     */
    dnxc_data_table_info_get_f dq_byte_map_info_get;
    /**
     * get table ca_map entry 
     */
    dnx_data_dram_gddr6_ca_map_get_f ca_map_get;
    /**
     * get general info table about table (for example key size)ca_map info
     */
    dnxc_data_table_info_get_f ca_map_info_get;
    /**
     * get table cadt_byte_map entry 
     */
    dnx_data_dram_gddr6_cadt_byte_map_get_f cadt_byte_map_get;
    /**
     * get general info table about table (for example key size)cadt_byte_map info
     */
    dnxc_data_table_info_get_f cadt_byte_map_info_get;
    /**
     * get table channel_regs entry 
     */
    dnx_data_dram_gddr6_channel_regs_get_f channel_regs_get;
    /**
     * get general info table about table (for example key size)channel_regs info
     */
    dnxc_data_table_info_get_f channel_regs_info_get;
    /**
     * get table controller_regs entry 
     */
    dnx_data_dram_gddr6_controller_regs_get_f controller_regs_get;
    /**
     * get general info table about table (for example key size)controller_regs info
     */
    dnxc_data_table_info_get_f controller_regs_info_get;
    /**
     * get table channel_interrupt_regs entry 
     */
    dnx_data_dram_gddr6_channel_interrupt_regs_get_f channel_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)channel_interrupt_regs info
     */
    dnxc_data_table_info_get_f channel_interrupt_regs_info_get;
    /**
     * get table controller_interrupt_regs entry 
     */
    dnx_data_dram_gddr6_controller_interrupt_regs_get_f controller_interrupt_regs_get;
    /**
     * get general info table about table (for example key size)controller_interrupt_regs info
     */
    dnxc_data_table_info_get_f controller_interrupt_regs_info_get;
    /**
     * get table channel_debug_regs entry 
     */
    dnx_data_dram_gddr6_channel_debug_regs_get_f channel_debug_regs_get;
    /**
     * get general info table about table (for example key size)channel_debug_regs info
     */
    dnxc_data_table_info_get_f channel_debug_regs_info_get;
    /**
     * get table channel_counter_regs entry 
     */
    dnx_data_dram_gddr6_channel_counter_regs_get_f channel_counter_regs_get;
    /**
     * get general info table about table (for example key size)channel_counter_regs info
     */
    dnxc_data_table_info_get_f channel_counter_regs_info_get;
    /**
     * get table channel_type_regs entry 
     */
    dnx_data_dram_gddr6_channel_type_regs_get_f channel_type_regs_get;
    /**
     * get general info table about table (for example key size)channel_type_regs info
     */
    dnxc_data_table_info_get_f channel_type_regs_info_get;
    /**
     * get table controller_info_regs entry 
     */
    dnx_data_dram_gddr6_controller_info_regs_get_f controller_info_regs_get;
    /**
     * get general info table about table (for example key size)controller_info_regs info
     */
    dnxc_data_table_info_get_f controller_info_regs_info_get;
    /**
     * get table master_phy entry 
     */
    dnx_data_dram_gddr6_master_phy_get_f master_phy_get;
    /**
     * get general info table about table (for example key size)master_phy info
     */
    dnxc_data_table_info_get_f master_phy_info_get;
} dnx_data_if_dram_gddr6_t;

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL_INFO:
 * general info derived from defaults or soc properties which is relevant also for other types of drams, not only to HBM
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule general_info table mr_defaults
 * Table info:
 * mode registers default values
 */
typedef struct
{
    /**
     * default value for mode register
     */
    uint32 value;
} dnx_data_dram_general_info_mr_defaults_t;

/**
 * \brief Holds values of submodule general_info table dram_info
 * Table info:
 * general information regarding the dram in the system
 */
typedef struct
{
    /**
     * dram type as defined by tuning infrastructure
     */
    uint32 dram_type;
    /**
     * bitmap of currently available drams
     */
    uint32 dram_bitmap;
    /**
     * number of columns in the dram
     */
    uint32 nof_columns;
    /**
     * number of rows in the dram
     */
    uint32 nof_rows;
    /**
     * number of banks in the dram
     */
    uint32 nof_banks;
    /**
     * (in MHZ)data rate in mbps, in DDRs equal 2 * frequency
     */
    uint32 data_rate;
    /**
     * ref clock for the dram phy
     */
    uint32 ref_clock;
    /**
     * shmoo input - which actions to perform
     */
    uint32 ctl_type;
} dnx_data_dram_general_info_dram_info_t;

/**
 * \brief Holds values of submodule general_info table timing_params
 * Table info:
 * timing parameters
 */
typedef struct
{
    /**
     * twr timing parameter
     */
    uint32 twr;
    /**
     * trp timing parameter
     */
    uint32 trp;
    /**
     * trtps timing parameter
     */
    uint32 trtps;
    /**
     * trtpl timing parameter
     */
    uint32 trtpl;
    /**
     * trrds timing parameter
     */
    uint32 trrds;
    /**
     * trrdl timing parameter
     */
    uint32 trrdl;
    /**
     * tfaw timing parameter
     */
    uint32 tfaw;
    /**
     * trcdwr timing parameter
     */
    uint32 trcdwr;
    /**
     * trcdrd timing parameter
     */
    uint32 trcdrd;
    /**
     * tras timing parameter
     */
    uint32 tras;
    /**
     * trc timing parameter
     */
    uint32 trc;
    /**
     * twtrl timing parameter
     */
    uint32 twtrl;
    /**
     * twtrs timing parameter
     */
    uint32 twtrs;
    /**
     * trtw timing parameter
     */
    uint32 trtw;
    /**
     * tccdr timing parameter
     */
    uint32 tccdr;
    /**
     * tccds timing parameter
     */
    uint32 tccds;
    /**
     * tccdl timing parameter
     */
    uint32 tccdl;
    /**
     * trrefd timing parameter
     */
    uint32 trrefd;
    /**
     * trfcsb timing parameter
     */
    uint32 trfcsb;
    /**
     * trfc timing parameter
     */
    uint32 trfc;
    /**
     * tmrd timing parameter
     */
    uint32 tmrd;
    /**
     * tmod timing parameter
     */
    uint32 tmod;
    /**
     * twtrtr timing parameter
     */
    uint32 twtrtr;
    /**
     * twrwtr timing parameter
     */
    uint32 twrwtr;
    /**
     * treftr timing parameter
     */
    uint32 treftr;
    /**
     * trdtlt timing parameter
     */
    uint32 trdtlt;
    /**
     * trcdwtr timing parameter
     */
    uint32 trcdwtr;
    /**
     * trcdrtr timing parameter
     */
    uint32 trcdrtr;
    /**
     * trcdltr timing parameter
     */
    uint32 trcdltr;
    /**
     * tltrtr timing parameter
     */
    uint32 tltrtr;
    /**
     * tltltr timing parameter
     */
    uint32 tltltr;
} dnx_data_dram_general_info_timing_params_t;

/**
 * \brief Holds values of submodule general_info table refresh_intervals
 * Table info:
 * refresh intervals timing parameters
 */
typedef struct
{
    /**
     * trefi timing parameters
     */
    uint32 trefi;
    /**
     * trefisb timing parameters
     */
    uint32 trefisb;
} dnx_data_dram_general_info_refresh_intervals_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Is reading the dram temperature is supported
     */
    dnx_data_dram_general_info_is_temperature_reading_supported,

    /**
     * Must be last one!
     */
    _dnx_data_dram_general_info_feature_nof
} dnx_data_dram_general_info_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_general_info_feature_get_f) (
    int unit,
    dnx_data_dram_general_info_feature_e feature);

/**
 * \brief returns define data of otp_restore_version
 * Module - 'dram', Submodule - 'general_info', data - 'otp_restore_version'
 * when restoring from OTP the tune data, do it according to the given version format
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     otp_restore_version - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_otp_restore_version_get_f) (
    int unit);

/**
 * \brief returns define data of max_nof_drams
 * Module - 'dram', Submodule - 'general_info', data - 'max_nof_drams'
 * max number of drams supported for this device - in other words the size of the dram bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_drams - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_max_nof_drams_get_f) (
    int unit);

/**
 * \brief returns define data of nof_channels
 * Module - 'dram', Submodule - 'general_info', data - 'nof_channels'
 * max number of dram channels supported for this device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_nof_channels_get_f) (
    int unit);

/**
 * \brief returns define data of mr_mask
 * Module - 'dram', Submodule - 'general_info', data - 'mr_mask'
 * mode register bit mask
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mr_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_mr_mask_get_f) (
    int unit);

/**
 * \brief returns define data of nof_mrs
 * Module - 'dram', Submodule - 'general_info', data - 'nof_mrs'
 * number of mode registers
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_mrs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_nof_mrs_get_f) (
    int unit);

/**
 * \brief returns define data of phy_address_mask
 * Module - 'dram', Submodule - 'general_info', data - 'phy_address_mask'
 * bit mask to describe the relevant bits in phy register address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     phy_address_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_phy_address_mask_get_f) (
    int unit);

/**
 * \brief returns numeric data of max_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'max_dram_index'
 * max dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_max_dram_index_get_f) (
    int unit);

/**
 * \brief returns numeric data of min_dram_index
 * Module - 'dram', Submodule - 'general_info', data - 'min_dram_index'
 * min dram index from bitmap
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_dram_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_min_dram_index_get_f) (
    int unit);

/**
 * \brief returns numeric data of frequency
 * Module - 'dram', Submodule - 'general_info', data - 'frequency'
 * dram frequency (in MHZ), used to calculated data_rate
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     frequency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_frequency_get_f) (
    int unit);

/**
 * \brief returns numeric data of buffer_size
 * Module - 'dram', Submodule - 'general_info', data - 'buffer_size'
 * dram buffer size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_buffer_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of command_address_parity
 * Module - 'dram', Submodule - 'general_info', data - 'command_address_parity'
 * command address parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_address_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_command_address_parity_get_f) (
    int unit);

/**
 * \brief returns numeric data of dq_write_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_write_parity'
 * dq write parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_write_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dq_write_parity_get_f) (
    int unit);

/**
 * \brief returns numeric data of dq_read_parity
 * Module - 'dram', Submodule - 'general_info', data - 'dq_read_parity'
 * dq read parity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dq_read_parity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dq_read_parity_get_f) (
    int unit);

/**
 * \brief returns numeric data of dbi_read
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_read'
 * dbi read
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dbi_read_get_f) (
    int unit);

/**
 * \brief returns numeric data of dbi_write
 * Module - 'dram', Submodule - 'general_info', data - 'dbi_write'
 * dbi write
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dbi_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_dbi_write_get_f) (
    int unit);

/**
 * \brief returns numeric data of write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'write_latency'
 * write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_write_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'read_latency'
 * read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_read_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of read_data_enable_delay
 * Module - 'dram', Submodule - 'general_info', data - 'read_data_enable_delay'
 * read data enable delay
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_data_enable_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_read_data_enable_delay_get_f) (
    int unit);

/**
 * \brief returns numeric data of read_data_enable_length
 * Module - 'dram', Submodule - 'general_info', data - 'read_data_enable_length'
 * read data enable length
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     read_data_enable_length - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_read_data_enable_length_get_f) (
    int unit);

/**
 * \brief returns numeric data of parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'parity_latency'
 * parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_parity_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of actual_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'actual_parity_latency'
 * parity latency to be used after factoring in the effect of other numerics
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     actual_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_actual_parity_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of tune_mode_on_init
 * Module - 'dram', Submodule - 'general_info', data - 'tune_mode_on_init'
 * tune mode during init sequence
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tune_mode_on_init - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_tune_mode_on_init_get_f) (
    int unit);

/**
 * \brief returns numeric data of command_parity_latency
 * Module - 'dram', Submodule - 'general_info', data - 'command_parity_latency'
 * command parity latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     command_parity_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_command_parity_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_write_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write_latency'
 * crc write latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_write_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_read_latency
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read_latency'
 * crc read latency
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read_latency - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_read_latency_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_write
 * Module - 'dram', Submodule - 'general_info', data - 'crc_write'
 * write crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_write - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_write_get_f) (
    int unit);

/**
 * \brief returns numeric data of crc_read
 * Module - 'dram', Submodule - 'general_info', data - 'crc_read'
 * read crc
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     crc_read - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_crc_read_get_f) (
    int unit);

/**
 * \brief returns numeric data of device_size
 * Module - 'dram', Submodule - 'general_info', data - 'device_size'
 * device size for each dram die
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_general_info_device_size_get_f) (
    int unit);

/**
 * \brief get table mr_defaults entry 
 * mode registers default values
 * 
 * \param [in] unit - unit #
 * \param [in] index - mode register index
 * 
 * \return
 *     mr_defaults - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_mr_defaults_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_mr_defaults_t *(
    *dnx_data_dram_general_info_mr_defaults_get_f) (
    int unit,
    int index);

/**
 * \brief get table dram_info entry 
 * general information regarding the dram in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_info - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_dram_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_dram_info_t *(
    *dnx_data_dram_general_info_dram_info_get_f) (
    int unit);

/**
 * \brief get table timing_params entry 
 * timing parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     timing_params - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_timing_params_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_timing_params_t *(
    *dnx_data_dram_general_info_timing_params_get_f) (
    int unit);

/**
 * \brief get table refresh_intervals entry 
 * refresh intervals timing parameters
 * 
 * \param [in] unit - unit #
 * \param [in] temp_index - temperature index
 * 
 * \return
 *     refresh_intervals - returns the relevant entry values grouped in struct - see dnx_data_dram_general_info_refresh_intervals_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_general_info_refresh_intervals_t *(
    *dnx_data_dram_general_info_refresh_intervals_get_f) (
    int unit,
    int temp_index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - GENERAL_INFO:
 * {
 */
/**
 * \brief Interface for dram general_info data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_general_info_feature_get_f feature_get;
    /**
     * returns define data of otp_restore_version
     */
    dnx_data_dram_general_info_otp_restore_version_get_f otp_restore_version_get;
    /**
     * returns define data of max_nof_drams
     */
    dnx_data_dram_general_info_max_nof_drams_get_f max_nof_drams_get;
    /**
     * returns define data of nof_channels
     */
    dnx_data_dram_general_info_nof_channels_get_f nof_channels_get;
    /**
     * returns define data of mr_mask
     */
    dnx_data_dram_general_info_mr_mask_get_f mr_mask_get;
    /**
     * returns define data of nof_mrs
     */
    dnx_data_dram_general_info_nof_mrs_get_f nof_mrs_get;
    /**
     * returns define data of phy_address_mask
     */
    dnx_data_dram_general_info_phy_address_mask_get_f phy_address_mask_get;
    /**
     * returns numeric data of max_dram_index
     */
    dnx_data_dram_general_info_max_dram_index_get_f max_dram_index_get;
    /**
     * returns numeric data of min_dram_index
     */
    dnx_data_dram_general_info_min_dram_index_get_f min_dram_index_get;
    /**
     * returns numeric data of frequency
     */
    dnx_data_dram_general_info_frequency_get_f frequency_get;
    /**
     * returns numeric data of buffer_size
     */
    dnx_data_dram_general_info_buffer_size_get_f buffer_size_get;
    /**
     * returns numeric data of command_address_parity
     */
    dnx_data_dram_general_info_command_address_parity_get_f command_address_parity_get;
    /**
     * returns numeric data of dq_write_parity
     */
    dnx_data_dram_general_info_dq_write_parity_get_f dq_write_parity_get;
    /**
     * returns numeric data of dq_read_parity
     */
    dnx_data_dram_general_info_dq_read_parity_get_f dq_read_parity_get;
    /**
     * returns numeric data of dbi_read
     */
    dnx_data_dram_general_info_dbi_read_get_f dbi_read_get;
    /**
     * returns numeric data of dbi_write
     */
    dnx_data_dram_general_info_dbi_write_get_f dbi_write_get;
    /**
     * returns numeric data of write_latency
     */
    dnx_data_dram_general_info_write_latency_get_f write_latency_get;
    /**
     * returns numeric data of read_latency
     */
    dnx_data_dram_general_info_read_latency_get_f read_latency_get;
    /**
     * returns numeric data of read_data_enable_delay
     */
    dnx_data_dram_general_info_read_data_enable_delay_get_f read_data_enable_delay_get;
    /**
     * returns numeric data of read_data_enable_length
     */
    dnx_data_dram_general_info_read_data_enable_length_get_f read_data_enable_length_get;
    /**
     * returns numeric data of parity_latency
     */
    dnx_data_dram_general_info_parity_latency_get_f parity_latency_get;
    /**
     * returns numeric data of actual_parity_latency
     */
    dnx_data_dram_general_info_actual_parity_latency_get_f actual_parity_latency_get;
    /**
     * returns numeric data of tune_mode_on_init
     */
    dnx_data_dram_general_info_tune_mode_on_init_get_f tune_mode_on_init_get;
    /**
     * returns numeric data of command_parity_latency
     */
    dnx_data_dram_general_info_command_parity_latency_get_f command_parity_latency_get;
    /**
     * returns numeric data of crc_write_latency
     */
    dnx_data_dram_general_info_crc_write_latency_get_f crc_write_latency_get;
    /**
     * returns numeric data of crc_read_latency
     */
    dnx_data_dram_general_info_crc_read_latency_get_f crc_read_latency_get;
    /**
     * returns numeric data of crc_write
     */
    dnx_data_dram_general_info_crc_write_get_f crc_write_get;
    /**
     * returns numeric data of crc_read
     */
    dnx_data_dram_general_info_crc_read_get_f crc_read_get;
    /**
     * returns numeric data of device_size
     */
    dnx_data_dram_general_info_device_size_get_f device_size_get;
    /**
     * get table mr_defaults entry 
     */
    dnx_data_dram_general_info_mr_defaults_get_f mr_defaults_get;
    /**
     * get general info table about table (for example key size)mr_defaults info
     */
    dnxc_data_table_info_get_f mr_defaults_info_get;
    /**
     * get table dram_info entry 
     */
    dnx_data_dram_general_info_dram_info_get_f dram_info_get;
    /**
     * get general info table about table (for example key size)dram_info info
     */
    dnxc_data_table_info_get_f dram_info_info_get;
    /**
     * get table timing_params entry 
     */
    dnx_data_dram_general_info_timing_params_get_f timing_params_get;
    /**
     * get general info table about table (for example key size)timing_params info
     */
    dnxc_data_table_info_get_f timing_params_info_get;
    /**
     * get table refresh_intervals entry 
     */
    dnx_data_dram_general_info_refresh_intervals_get_f refresh_intervals_get;
    /**
     * get general info table about table (for example key size)refresh_intervals info
     */
    dnxc_data_table_info_get_f refresh_intervals_info_get;
} dnx_data_if_dram_general_info_t;

/*
 * }
 */

/*
 * SUBMODULE  - ADDRESS_TRANSLATION:
 * information regarding the address translation scheme between logical to physical buffer
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule address_translation table tdu_map
 * Table info:
 * Map between TDU and its data source
 */
typedef struct
{
    /**
     * The source (core) from which the packets arrive at the TDU
     */
    uint32 data_source_id;
} dnx_data_dram_address_translation_tdu_map_t;

/**
 * \brief Holds values of submodule address_translation table matrix_configuration
 * Table info:
 * address translation matrix(ATM) configuration options
 */
typedef struct
{
    /**
     * the values of the ATM
     */
    uint32 logical_to_physical[DNX_DATA_MAX_DRAM_ADDRESS_TRANSLATION_MATRIX_COLUMN_SIZE];
} dnx_data_dram_address_translation_matrix_configuration_t;

/**
 * \brief Holds values of submodule address_translation table interrupt_regs
 * Table info:
 * per address translation unit list of interrupt registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_address_translation_interrupt_regs_t;

/**
 * \brief Holds values of submodule address_translation table counter_regs
 * Table info:
 * per address translation unit list of counter registers
 */
typedef struct
{
    /**
     * register
     */
    soc_reg_t reg;
} dnx_data_dram_address_translation_counter_regs_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_address_translation_feature_nof
} dnx_data_dram_address_translation_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_address_translation_feature_get_f) (
    int unit,
    dnx_data_dram_address_translation_feature_e feature);

/**
 * \brief returns define data of matrix_column_size
 * Module - 'dram', Submodule - 'address_translation', data - 'matrix_column_size'
 * the number of rows in the ATM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     matrix_column_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_matrix_column_size_get_f) (
    int unit);

/**
 * \brief returns define data of physical_address_transaction_size
 * Module - 'dram', Submodule - 'address_translation', data - 'physical_address_transaction_size'
 * nof bytes in each read/write from/to physical address
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     physical_address_transaction_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_physical_address_transaction_size_get_f) (
    int unit);

/**
 * \brief returns define data of nof_atms
 * Module - 'dram', Submodule - 'address_translation', data - 'nof_atms'
 * number of address translation matrix
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_atms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_nof_atms_get_f) (
    int unit);

/**
 * \brief returns define data of nof_tdus_per_dram
 * Module - 'dram', Submodule - 'address_translation', data - 'nof_tdus_per_dram'
 * number of TDU blocks per DRAM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_tdus_per_dram - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_nof_tdus_per_dram_get_f) (
    int unit);

/**
 * \brief returns define data of max_tdu_index
 * Module - 'dram', Submodule - 'address_translation', data - 'max_tdu_index'
 * Maximum TDU index
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_tdu_index - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_address_translation_max_tdu_index_get_f) (
    int unit);

/**
 * \brief get table tdu_map entry 
 * Map between TDU and its data source
 * 
 * \param [in] unit - unit #
 * \param [in] dram_index - DRAM index
 * \param [in] tdu_index - TDU index
 * 
 * \return
 *     tdu_map - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_tdu_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_address_translation_tdu_map_t *(
    *dnx_data_dram_address_translation_tdu_map_get_f) (
    int unit,
    int dram_index,
    int tdu_index);

/**
 * \brief get table matrix_configuration entry 
 * address translation matrix(ATM) configuration options
 * 
 * \param [in] unit - unit #
 * \param [in] matrix_option - matrix selector
 * 
 * \return
 *     matrix_configuration - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_matrix_configuration_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_address_translation_matrix_configuration_t *(
    *dnx_data_dram_address_translation_matrix_configuration_get_f) (
    int unit,
    int matrix_option);

/**
 * \brief get table interrupt_regs entry 
 * per address translation unit list of interrupt registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     interrupt_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_interrupt_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_address_translation_interrupt_regs_t *(
    *dnx_data_dram_address_translation_interrupt_regs_get_f) (
    int unit,
    int index);

/**
 * \brief get table counter_regs entry 
 * per address translation unit list of counter registers
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     counter_regs - returns the relevant entry values grouped in struct - see dnx_data_dram_address_translation_counter_regs_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_address_translation_counter_regs_t *(
    *dnx_data_dram_address_translation_counter_regs_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - ADDRESS_TRANSLATION:
 * {
 */
/**
 * \brief Interface for dram address_translation data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_address_translation_feature_get_f feature_get;
    /**
     * returns define data of matrix_column_size
     */
    dnx_data_dram_address_translation_matrix_column_size_get_f matrix_column_size_get;
    /**
     * returns define data of physical_address_transaction_size
     */
    dnx_data_dram_address_translation_physical_address_transaction_size_get_f physical_address_transaction_size_get;
    /**
     * returns define data of nof_atms
     */
    dnx_data_dram_address_translation_nof_atms_get_f nof_atms_get;
    /**
     * returns define data of nof_tdus_per_dram
     */
    dnx_data_dram_address_translation_nof_tdus_per_dram_get_f nof_tdus_per_dram_get;
    /**
     * returns define data of max_tdu_index
     */
    dnx_data_dram_address_translation_max_tdu_index_get_f max_tdu_index_get;
    /**
     * get table tdu_map entry 
     */
    dnx_data_dram_address_translation_tdu_map_get_f tdu_map_get;
    /**
     * get general info table about table (for example key size)tdu_map info
     */
    dnxc_data_table_info_get_f tdu_map_info_get;
    /**
     * get table matrix_configuration entry 
     */
    dnx_data_dram_address_translation_matrix_configuration_get_f matrix_configuration_get;
    /**
     * get general info table about table (for example key size)matrix_configuration info
     */
    dnxc_data_table_info_get_f matrix_configuration_info_get;
    /**
     * get table interrupt_regs entry 
     */
    dnx_data_dram_address_translation_interrupt_regs_get_f interrupt_regs_get;
    /**
     * get general info table about table (for example key size)interrupt_regs info
     */
    dnxc_data_table_info_get_f interrupt_regs_info_get;
    /**
     * get table counter_regs entry 
     */
    dnx_data_dram_address_translation_counter_regs_get_f counter_regs_get;
    /**
     * get general info table about table (for example key size)counter_regs info
     */
    dnxc_data_table_info_get_f counter_regs_info_get;
} dnx_data_if_dram_address_translation_t;

/*
 * }
 */

/*
 * SUBMODULE  - BUFFERS:
 * information regarding BDs and BDBs
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule buffers table deleted_buffers_info
 * Table info:
 * deleted buffers info
 */
typedef struct
{
    /**
     * full path to file containing deleted buffers for this unit
     */
    char *deleted_buffers_file;
} dnx_data_dram_buffers_deleted_buffers_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * this feature represents sending buffers to quarantine after tdu corrected error event has happend
     */
    dnx_data_dram_buffers_quarantine_buffers_if_tdu_corrected_errors,
    /**
     * this feature represents sending buffers to quarantine after tdu error event has happend
     */
    dnx_data_dram_buffers_quarantine_buffers_if_tdu_errors,
    /**
     * The DDP stores a usage counter per BDB, and release the BDB only when the counter is 0
     */
    dnx_data_dram_buffers_bdb_release_mechanism_usage_counters,

    /**
     * Must be last one!
     */
    _dnx_data_dram_buffers_feature_nof
} dnx_data_dram_buffers_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_buffers_feature_get_f) (
    int unit,
    dnx_data_dram_buffers_feature_e feature);

/**
 * \brief returns numeric data of allowed_errors
 * Module - 'dram', Submodule - 'buffers', data - 'allowed_errors'
 * number of times a buffer is allowed into the quarantine FIFO before it is deleted instead of restored
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     allowed_errors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_buffers_allowed_errors_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bdbs
 * Module - 'dram', Submodule - 'buffers', data - 'nof_bdbs'
 * number of BDBs per core
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bdbs - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_buffers_nof_bdbs_get_f) (
    int unit);

/**
 * \brief returns define data of nof_fpc_banks
 * Module - 'dram', Submodule - 'buffers', data - 'nof_fpc_banks'
 * number of free pointer controler banks
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fpc_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_buffers_nof_fpc_banks_get_f) (
    int unit);

/**
 * \brief get table deleted_buffers_info entry 
 * deleted buffers info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     deleted_buffers_info - returns the relevant entry values grouped in struct - see dnx_data_dram_buffers_deleted_buffers_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_buffers_deleted_buffers_info_t *(
    *dnx_data_dram_buffers_deleted_buffers_info_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - BUFFERS:
 * {
 */
/**
 * \brief Interface for dram buffers data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_buffers_feature_get_f feature_get;
    /**
     * returns numeric data of allowed_errors
     */
    dnx_data_dram_buffers_allowed_errors_get_f allowed_errors_get;
    /**
     * returns define data of nof_bdbs
     */
    dnx_data_dram_buffers_nof_bdbs_get_f nof_bdbs_get;
    /**
     * returns define data of nof_fpc_banks
     */
    dnx_data_dram_buffers_nof_fpc_banks_get_f nof_fpc_banks_get;
    /**
     * get table deleted_buffers_info entry 
     */
    dnx_data_dram_buffers_deleted_buffers_info_get_f deleted_buffers_info_get;
    /**
     * get general info table about table (for example key size)deleted_buffers_info info
     */
    dnxc_data_table_info_get_f deleted_buffers_info_info_get;
} dnx_data_if_dram_buffers_t;

/*
 * }
 */

/*
 * SUBMODULE  - DRAM_BLOCK:
 * information regarding DRAM blocked state.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule dram_block table wpr_leaky_bucket_increment_th
 * Table info:
 * Write-plus-read leaky bucket increment thresholds
 */
typedef struct
{
    /**
     * Threshold value
     */
    uint32 threshold;
} dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_t;

/**
 * \brief Holds values of submodule dram_block table write_leaky_bucket_increment_th
 * Table info:
 * Write leaky bucket increment thresholds
 */
typedef struct
{
    /**
     * Threshold value
     */
    uint32 threshold;
} dnx_data_dram_dram_block_write_leaky_bucket_increment_th_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * indication whether the write minus read leaky bucket is supported
     */
    dnx_data_dram_dram_block_write_minus_read_leaky_bucket,
    /**
     * indication whether the write leaky bucket is supported
     */
    dnx_data_dram_dram_block_write_leaky_bucket,
    /**
     * indication whether disabling the write minus read leaky bucket is supported
     */
    dnx_data_dram_dram_block_write_minus_read_leaky_bucket_disable,
    /**
     * indication whether disabling the write plus read leaky bucket is supported
     */
    dnx_data_dram_dram_block_write_plus_read_leaky_bucket_disable,
    /**
     * indication whether average read inflights leaky bucket is supported
     */
    dnx_data_dram_dram_block_average_read_inflights_leaky_bucket,
    /**
     * average-read-inflight uses a separate log2 based window size
     */
    dnx_data_dram_dram_block_average_read_inflights_log2_window_size,

    /**
     * Must be last one!
     */
    _dnx_data_dram_dram_block_feature_nof
} dnx_data_dram_dram_block_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_dram_block_feature_get_f) (
    int unit,
    dnx_data_dram_dram_block_feature_e feature);

/**
 * \brief returns define data of leaky_bucket_window_size
 * Module - 'dram', Submodule - 'dram_block', data - 'leaky_bucket_window_size'
 * window size for DRAM block calculation
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     leaky_bucket_window_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_leaky_bucket_window_size_get_f) (
    int unit);

/**
 * \brief returns define data of wmr_reset_on_deassert
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_reset_on_deassert'
 * indication whether to reset on deassert of write-minus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_reset_on_deassert - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wmr_reset_on_deassert_get_f) (
    int unit);

/**
 * \brief returns define data of wmr_full_size
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_full_size'
 * write-minus-read leaky bucket full size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_full_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wmr_full_size_get_f) (
    int unit);

/**
 * \brief returns define data of average_read_inflights_assert_threshold
 * Module - 'dram', Submodule - 'dram_block', data - 'average_read_inflights_assert_threshold'
 * average-read-inflights leaky bucket assert threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_assert_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_average_read_inflights_assert_threshold_get_f) (
    int unit);

/**
 * \brief returns define data of average_read_inflights_full_size
 * Module - 'dram', Submodule - 'dram_block', data - 'average_read_inflights_full_size'
 * average-read-inflights leaky bucket full size
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_full_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_average_read_inflights_full_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of wmr_decrement_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wmr_decrement_thr_factor'
 * factor for calculating decrement threshold for write_minus_read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wmr_decrement_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wmr_decrement_thr_factor_get_f) (
    int unit);

/**
 * \brief returns numeric data of wpr_increment_thr_factor
 * Module - 'dram', Submodule - 'dram_block', data - 'wpr_increment_thr_factor'
 * factor for calculating increment threshold for write-plus-read leaky bucket
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wpr_increment_thr_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dram_block_wpr_increment_thr_factor_get_f) (
    int unit);

/**
 * \brief get table wpr_leaky_bucket_increment_th entry 
 * Write-plus-read leaky bucket increment thresholds
 * 
 * \param [in] unit - unit #
 * \param [in] index - threshold index
 * 
 * \return
 *     wpr_leaky_bucket_increment_th - returns the relevant entry values grouped in struct - see dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_t *(
    *dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_get_f) (
    int unit,
    int index);

/**
 * \brief get table write_leaky_bucket_increment_th entry 
 * Write leaky bucket increment thresholds
 * 
 * \param [in] unit - unit #
 * \param [in] index - threshold index
 * 
 * \return
 *     write_leaky_bucket_increment_th - returns the relevant entry values grouped in struct - see dnx_data_dram_dram_block_write_leaky_bucket_increment_th_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_dram_block_write_leaky_bucket_increment_th_t *(
    *dnx_data_dram_dram_block_write_leaky_bucket_increment_th_get_f) (
    int unit,
    int index);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - DRAM_BLOCK:
 * {
 */
/**
 * \brief Interface for dram dram_block data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_dram_block_feature_get_f feature_get;
    /**
     * returns define data of leaky_bucket_window_size
     */
    dnx_data_dram_dram_block_leaky_bucket_window_size_get_f leaky_bucket_window_size_get;
    /**
     * returns define data of wmr_reset_on_deassert
     */
    dnx_data_dram_dram_block_wmr_reset_on_deassert_get_f wmr_reset_on_deassert_get;
    /**
     * returns define data of wmr_full_size
     */
    dnx_data_dram_dram_block_wmr_full_size_get_f wmr_full_size_get;
    /**
     * returns define data of average_read_inflights_assert_threshold
     */
    dnx_data_dram_dram_block_average_read_inflights_assert_threshold_get_f average_read_inflights_assert_threshold_get;
    /**
     * returns define data of average_read_inflights_full_size
     */
    dnx_data_dram_dram_block_average_read_inflights_full_size_get_f average_read_inflights_full_size_get;
    /**
     * returns numeric data of wmr_decrement_thr_factor
     */
    dnx_data_dram_dram_block_wmr_decrement_thr_factor_get_f wmr_decrement_thr_factor_get;
    /**
     * returns numeric data of wpr_increment_thr_factor
     */
    dnx_data_dram_dram_block_wpr_increment_thr_factor_get_f wpr_increment_thr_factor_get;
    /**
     * get table wpr_leaky_bucket_increment_th entry 
     */
    dnx_data_dram_dram_block_wpr_leaky_bucket_increment_th_get_f wpr_leaky_bucket_increment_th_get;
    /**
     * get general info table about table (for example key size)wpr_leaky_bucket_increment_th info
     */
    dnxc_data_table_info_get_f wpr_leaky_bucket_increment_th_info_get;
    /**
     * get table write_leaky_bucket_increment_th entry 
     */
    dnx_data_dram_dram_block_write_leaky_bucket_increment_th_get_f write_leaky_bucket_increment_th_get;
    /**
     * get general info table about table (for example key size)write_leaky_bucket_increment_th info
     */
    dnxc_data_table_info_get_f write_leaky_bucket_increment_th_info_get;
} dnx_data_if_dram_dram_block_t;

/*
 * }
 */

/*
 * SUBMODULE  - DBAL:
 * information regarding DRAM dbal.
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_dbal_feature_nof
} dnx_data_dram_dbal_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_dbal_feature_get_f) (
    int unit,
    dnx_data_dram_dbal_feature_e feature);

/**
 * \brief returns define data of hbm_trc_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_trc_nof_bits'
 * Number of bits in HBM_TRC field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_trc_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbm_trc_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of wpr_increment_threshold_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'wpr_increment_threshold_nof_bits'
 * Number of bits in DRAM_BLOCKED_WRITE_PLUS_READ_LEAKY_BUCKET_INCREMENT_SIZE fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     wpr_increment_threshold_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_wpr_increment_threshold_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of average_read_inflights_increment_threshold_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'average_read_inflights_increment_threshold_nof_bits'
 * Number of bits in DRAM_BLOCKED_AVERAGE_READ_INFLIGHTS_LEAKY_BUCKET_INCREMENT_SIZE fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_increment_threshold_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_average_read_inflights_increment_threshold_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of average_read_inflights_decrement_threshold_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'average_read_inflights_decrement_threshold_nof_bits'
 * Number of bits in DRAM_BLOCKED_AVERAGE_READ_INFLIGHTS_LEAKY_BUCKET_DECREMENT_SIZE fields
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     average_read_inflights_decrement_threshold_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_average_read_inflights_decrement_threshold_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of hbm_pll_pdiv_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_pdiv_nof_bits'
 * Number of bits in HBM_PLL_PDIV field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_pdiv_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbm_pll_pdiv_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of hbm_pll_ch_mdiv_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_ch_mdiv_nof_bits'
 * Number of bits in HBM_PLL_CH_0_MDIV field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_ch_mdiv_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbm_pll_ch_mdiv_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of hbm_pll_frefeff_info_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_frefeff_info_nof_bits'
 * Number of bits in HBM_PLL_FREFEFF_INFO field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_frefeff_info_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbm_pll_frefeff_info_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of hbm_pll_aux_post_enableb_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_aux_post_enableb_nof_bits'
 * Number of bits in HBM_PLL_AUX_POST_ENABLEB field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_aux_post_enableb_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbm_pll_aux_post_enableb_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of hbm_pll_ch_enableb_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_ch_enableb_nof_bits'
 * Number of bits in HBM_PLL_CH_ENABLEB field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_ch_enableb_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbm_pll_ch_enableb_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of hbm_pll_aux_post_diffcmos_en_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbm_pll_aux_post_diffcmos_en_nof_bits'
 * Number of bits in HBM_PLL_AUX_POST_DIFFCMOS_EN field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbm_pll_aux_post_diffcmos_en_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbm_pll_aux_post_diffcmos_en_nof_bits_get_f) (
    int unit);

/**
 * \brief returns define data of dram_bist_mode_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'dram_bist_mode_nof_bits'
 * Number of bits in dram bist DATA_MODE field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     dram_bist_mode_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_dram_bist_mode_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of hbmc_index_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbmc_index_nof_bits'
 * The size (number of bits) of HBMC_INDEX dbal field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbmc_index_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbmc_index_nof_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of hbmc_tdu_index_nof_bits
 * Module - 'dram', Submodule - 'dbal', data - 'hbmc_tdu_index_nof_bits'
 * The size (number of bits) of HBMC_TDU_INDEX dbal field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hbmc_tdu_index_nof_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_dbal_hbmc_tdu_index_nof_bits_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - DBAL:
 * {
 */
/**
 * \brief Interface for dram dbal data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_dbal_feature_get_f feature_get;
    /**
     * returns define data of hbm_trc_nof_bits
     */
    dnx_data_dram_dbal_hbm_trc_nof_bits_get_f hbm_trc_nof_bits_get;
    /**
     * returns define data of wpr_increment_threshold_nof_bits
     */
    dnx_data_dram_dbal_wpr_increment_threshold_nof_bits_get_f wpr_increment_threshold_nof_bits_get;
    /**
     * returns define data of average_read_inflights_increment_threshold_nof_bits
     */
    dnx_data_dram_dbal_average_read_inflights_increment_threshold_nof_bits_get_f average_read_inflights_increment_threshold_nof_bits_get;
    /**
     * returns define data of average_read_inflights_decrement_threshold_nof_bits
     */
    dnx_data_dram_dbal_average_read_inflights_decrement_threshold_nof_bits_get_f average_read_inflights_decrement_threshold_nof_bits_get;
    /**
     * returns define data of hbm_pll_pdiv_nof_bits
     */
    dnx_data_dram_dbal_hbm_pll_pdiv_nof_bits_get_f hbm_pll_pdiv_nof_bits_get;
    /**
     * returns define data of hbm_pll_ch_mdiv_nof_bits
     */
    dnx_data_dram_dbal_hbm_pll_ch_mdiv_nof_bits_get_f hbm_pll_ch_mdiv_nof_bits_get;
    /**
     * returns define data of hbm_pll_frefeff_info_nof_bits
     */
    dnx_data_dram_dbal_hbm_pll_frefeff_info_nof_bits_get_f hbm_pll_frefeff_info_nof_bits_get;
    /**
     * returns define data of hbm_pll_aux_post_enableb_nof_bits
     */
    dnx_data_dram_dbal_hbm_pll_aux_post_enableb_nof_bits_get_f hbm_pll_aux_post_enableb_nof_bits_get;
    /**
     * returns define data of hbm_pll_ch_enableb_nof_bits
     */
    dnx_data_dram_dbal_hbm_pll_ch_enableb_nof_bits_get_f hbm_pll_ch_enableb_nof_bits_get;
    /**
     * returns define data of hbm_pll_aux_post_diffcmos_en_nof_bits
     */
    dnx_data_dram_dbal_hbm_pll_aux_post_diffcmos_en_nof_bits_get_f hbm_pll_aux_post_diffcmos_en_nof_bits_get;
    /**
     * returns define data of dram_bist_mode_nof_bits
     */
    dnx_data_dram_dbal_dram_bist_mode_nof_bits_get_f dram_bist_mode_nof_bits_get;
    /**
     * returns numeric data of hbmc_index_nof_bits
     */
    dnx_data_dram_dbal_hbmc_index_nof_bits_get_f hbmc_index_nof_bits_get;
    /**
     * returns numeric data of hbmc_tdu_index_nof_bits
     */
    dnx_data_dram_dbal_hbmc_tdu_index_nof_bits_get_f hbmc_tdu_index_nof_bits_get;
} dnx_data_if_dram_dbal_t;

/*
 * }
 */

/*
 * SUBMODULE  - FIRMWARE:
 * information regarding DRAM PHY firmware.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule firmware table rom
 * Table info:
 * Firmaware ROM info
 */
typedef struct
{
    /**
     * path to the HBM PHY Firmware ROM
     */
    char *filename;
} dnx_data_dram_firmware_rom_t;

/**
 * \brief Holds values of submodule firmware table operation_status
 * Table info:
 * Indications on the firmware operation status. The values are taken from the HBM PHY Firmware programming guide.
 */
typedef struct
{
    /**
     * operation done
     */
    uint32 done;
    /**
     * operation is still active
     */
    uint32 active;
    /**
     * operation resulted with an error
     */
    uint32 errors_detected;
} dnx_data_dram_firmware_operation_status_t;

/**
 * \brief Holds values of submodule firmware table operation_result_error_code
 * Table info:
 * Error codes that can be encountered when using the Get Operation Result interrupt code
 */
typedef struct
{
    /**
     * description of the error code
     */
    char *description;
} dnx_data_dram_firmware_operation_result_error_code_t;

/**
 * \brief Holds values of submodule firmware table operation_result_last_operation
 * Table info:
 * When operation resulted with an error, the operation is saved. This table shows the meaning of the failing operation code.
 */
typedef struct
{
    /**
     * description of the operation code
     */
    char *description;
} dnx_data_dram_firmware_operation_result_last_operation_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_firmware_feature_nof
} dnx_data_dram_firmware_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_firmware_feature_get_f) (
    int unit,
    dnx_data_dram_firmware_feature_e feature);

/**
 * \brief returns define data of nof_hbm_spare_data_results
 * Module - 'dram', Submodule - 'firmware', data - 'nof_hbm_spare_data_results'
 * Number of HBM spare data results
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_hbm_spare_data_results - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_firmware_nof_hbm_spare_data_results_get_f) (
    int unit);

/**
 * \brief returns define data of sbus_clock_divider
 * Module - 'dram', Submodule - 'firmware', data - 'sbus_clock_divider'
 * Divide sbus_ctrl_clk with this value to create the SBus clock. Max clock after division should be 200MHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_clock_divider - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_firmware_sbus_clock_divider_get_f) (
    int unit);

/**
 * \brief returns define data of snap_state_init_done
 * Module - 'dram', Submodule - 'firmware', data - 'snap_state_init_done'
 * The value which indicates that the SNaP initialization is done
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     snap_state_init_done - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_dram_firmware_snap_state_init_done_get_f) (
    int unit);

/**
 * \brief get table rom entry 
 * Firmaware ROM info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rom - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_rom_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_firmware_rom_t *(
    *dnx_data_dram_firmware_rom_get_f) (
    int unit);

/**
 * \brief get table operation_status entry 
 * Indications on the firmware operation status. The values are taken from the HBM PHY Firmware programming guide.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     operation_status - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_operation_status_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_firmware_operation_status_t *(
    *dnx_data_dram_firmware_operation_status_get_f) (
    int unit);

/**
 * \brief get table operation_result_error_code entry 
 * Error codes that can be encountered when using the Get Operation Result interrupt code
 * 
 * \param [in] unit - unit #
 * \param [in] error_code - the resulted error code
 * 
 * \return
 *     operation_result_error_code - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_operation_result_error_code_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_firmware_operation_result_error_code_t *(
    *dnx_data_dram_firmware_operation_result_error_code_get_f) (
    int unit,
    int error_code);

/**
 * \brief get table operation_result_last_operation entry 
 * When operation resulted with an error, the operation is saved. This table shows the meaning of the failing operation code.
 * 
 * \param [in] unit - unit #
 * \param [in] operation_code - the operation code
 * 
 * \return
 *     operation_result_last_operation - returns the relevant entry values grouped in struct - see dnx_data_dram_firmware_operation_result_last_operation_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_firmware_operation_result_last_operation_t *(
    *dnx_data_dram_firmware_operation_result_last_operation_get_f) (
    int unit,
    int operation_code);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - FIRMWARE:
 * {
 */
/**
 * \brief Interface for dram firmware data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_firmware_feature_get_f feature_get;
    /**
     * returns define data of nof_hbm_spare_data_results
     */
    dnx_data_dram_firmware_nof_hbm_spare_data_results_get_f nof_hbm_spare_data_results_get;
    /**
     * returns define data of sbus_clock_divider
     */
    dnx_data_dram_firmware_sbus_clock_divider_get_f sbus_clock_divider_get;
    /**
     * returns define data of snap_state_init_done
     */
    dnx_data_dram_firmware_snap_state_init_done_get_f snap_state_init_done_get;
    /**
     * get table rom entry 
     */
    dnx_data_dram_firmware_rom_get_f rom_get;
    /**
     * get general info table about table (for example key size)rom info
     */
    dnxc_data_table_info_get_f rom_info_get;
    /**
     * get table operation_status entry 
     */
    dnx_data_dram_firmware_operation_status_get_f operation_status_get;
    /**
     * get general info table about table (for example key size)operation_status info
     */
    dnxc_data_table_info_get_f operation_status_info_get;
    /**
     * get table operation_result_error_code entry 
     */
    dnx_data_dram_firmware_operation_result_error_code_get_f operation_result_error_code_get;
    /**
     * get general info table about table (for example key size)operation_result_error_code info
     */
    dnxc_data_table_info_get_f operation_result_error_code_info_get;
    /**
     * get table operation_result_last_operation entry 
     */
    dnx_data_dram_firmware_operation_result_last_operation_get_f operation_result_last_operation_get;
    /**
     * get general info table about table (for example key size)operation_result_last_operation info
     */
    dnxc_data_table_info_get_f operation_result_last_operation_info_get;
} dnx_data_if_dram_firmware_t;

/*
 * }
 */

/*
 * SUBMODULE  - APD_PHY:
 * Configurations for APD PHY
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule apd_phy table pll
 * Table info:
 * PLL parameters
 */
typedef struct
{
    /**
     * N divider of the PLL
     */
    uint32 ndiv_int;
    /**
     * M-divider for channel 1 of the PLL
     */
    uint32 ch1_mdiv;
} dnx_data_dram_apd_phy_pll_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_apd_phy_feature_nof
} dnx_data_dram_apd_phy_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_apd_phy_feature_get_f) (
    int unit,
    dnx_data_dram_apd_phy_feature_e feature);

/**
 * \brief get table pll entry 
 * PLL parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pll - returns the relevant entry values grouped in struct - see dnx_data_dram_apd_phy_pll_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_apd_phy_pll_t *(
    *dnx_data_dram_apd_phy_pll_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - APD_PHY:
 * {
 */
/**
 * \brief Interface for dram apd_phy data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_apd_phy_feature_get_f feature_get;
    /**
     * get table pll entry 
     */
    dnx_data_dram_apd_phy_pll_get_f pll_get;
    /**
     * get general info table about table (for example key size)pll info
     */
    dnxc_data_table_info_get_f pll_info_get;
} dnx_data_if_dram_apd_phy_t;

/*
 * }
 */

/*
 * SUBMODULE  - CTESTS:
 * parameters for dram ctests
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule ctests table rate
 * Table info:
 * parameters for rate ctest
 */
typedef struct
{
    /**
     * Type of ports in the snake
     */
    char *snake_ports_type;
    /**
     * Number of NIF lanes in the snake
     */
    uint32 nof_lanes_in_snake;
    /**
     * Expected measured rate in mbps
     */
    uint32 expected_rate_in_mbps;
    /**
     * Expected DRAM measured rate in mbps
     */
    uint32 expected_dram_rate_in_mbps;
} dnx_data_dram_ctests_rate_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_dram_ctests_feature_nof
} dnx_data_dram_ctests_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_dram_ctests_feature_get_f) (
    int unit,
    dnx_data_dram_ctests_feature_e feature);

/**
 * \brief get table rate entry 
 * parameters for rate ctest
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rate - returns the relevant entry values grouped in struct - see dnx_data_dram_ctests_rate_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_dram_ctests_rate_t *(
    *dnx_data_dram_ctests_rate_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_DRAM - CTESTS:
 * {
 */
/**
 * \brief Interface for dram ctests data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_dram_ctests_feature_get_f feature_get;
    /**
     * get table rate entry 
     */
    dnx_data_dram_ctests_rate_get_f rate_get;
    /**
     * get general info table about table (for example key size)rate info
     */
    dnxc_data_table_info_get_f rate_info_get;
} dnx_data_if_dram_ctests_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_DRAM:
 * {
 */
/**
 * \brief Interface for dram data
 */
typedef struct
{
    /**
     * Interface for dram hbm data
     */
    dnx_data_if_dram_hbm_t hbm;
    /**
     * Interface for dram gddr6 data
     */
    dnx_data_if_dram_gddr6_t gddr6;
    /**
     * Interface for dram general_info data
     */
    dnx_data_if_dram_general_info_t general_info;
    /**
     * Interface for dram address_translation data
     */
    dnx_data_if_dram_address_translation_t address_translation;
    /**
     * Interface for dram buffers data
     */
    dnx_data_if_dram_buffers_t buffers;
    /**
     * Interface for dram dram_block data
     */
    dnx_data_if_dram_dram_block_t dram_block;
    /**
     * Interface for dram dbal data
     */
    dnx_data_if_dram_dbal_t dbal;
    /**
     * Interface for dram firmware data
     */
    dnx_data_if_dram_firmware_t firmware;
    /**
     * Interface for dram apd_phy data
     */
    dnx_data_if_dram_apd_phy_t apd_phy;
    /**
     * Interface for dram ctests data
     */
    dnx_data_if_dram_ctests_t ctests;
} dnx_data_if_dram_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_dram_t dnx_data_dram;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_DRAM_H_*/
/* *INDENT-ON* */
