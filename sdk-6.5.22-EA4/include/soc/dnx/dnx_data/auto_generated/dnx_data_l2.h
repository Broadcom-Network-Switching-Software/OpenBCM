/** \file dnx_data_l2.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNX_DATA_L2_H_
/*{*/
#define _DNX_DATA_L2_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <sal/limits.h>
#include <soc/property.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <soc/dnx/dnx_data/auto_generated/dnx_data_max_l2.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNX_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnx_data_if_l2
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnx_data_if_l2_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL:
 * General L2 properties
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * If set, learn events to MACT will be generated with INSERT command
     */
    dnx_data_l2_general_learning_use_insert_cmd,
    /**
     * Indicate if flush machine is supported
     */
    dnx_data_l2_general_flush_machine_support,
    /**
     * Indicate if iterating over dynamic entries is supported
     */
    dnx_data_l2_general_dynamic_entries_iteration_support,
    /**
     * Indicate if l2 counters are supported
     */
    dnx_data_l2_general_counters_support,
    /**
     * Indicate if aging of l2 entries is supported
     */
    dnx_data_l2_general_aging_support,
    dnx_data_l2_general_transplant_over_stronger_support,
    /**
     * IVL is not supported due to VTT1 No PEM resource
     */
    dnx_data_l2_general_ivl_feature_support,
    /**
     * Indicates if DMA is supported
     */
    dnx_data_l2_general_dma_support,

    /**
     * Must be last one!
     */
    _dnx_data_l2_general_feature_nof
} dnx_data_l2_general_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_general_feature_get_f) (
    int unit,
    dnx_data_l2_general_feature_e feature);

/**
 * \brief returns define data of vsi_offset_shift
 * Module - 'l2', Submodule - 'general', data - 'vsi_offset_shift'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     vsi_offset_shift - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_vsi_offset_shift_get_f) (
    int unit);

/**
 * \brief returns define data of lif_offset_shift
 * Module - 'l2', Submodule - 'general', data - 'lif_offset_shift'
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lif_offset_shift - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_lif_offset_shift_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_learn_limit_mode
 * Module - 'l2', Submodule - 'general', data - 'l2_learn_limit_mode'
 * MACT learning limit mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_learn_limit_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_learn_limit_mode_get_f) (
    int unit);

/**
 * \brief returns numeric data of jr_mode_nof_fec_bits
 * Module - 'l2', Submodule - 'general', data - 'jr_mode_nof_fec_bits'
 * NOF FEC bits in Jericho DSP learning message
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     jr_mode_nof_fec_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_jr_mode_nof_fec_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of arad_plus_mode_nof_fec_bits
 * Module - 'l2', Submodule - 'general', data - 'arad_plus_mode_nof_fec_bits'
 * NOF FEC bits in Arad+ DSP learning message
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     arad_plus_mode_nof_fec_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_arad_plus_mode_nof_fec_bits_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_egress_max_extention_size_bytes
 * Module - 'l2', Submodule - 'general', data - 'l2_egress_max_extention_size_bytes'
 * Maximum size in bytes of RCH extensiuon. The limit comes from parser limitations
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_egress_max_extention_size_bytes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_egress_max_extention_size_bytes_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_egress_max_additional_termination_size_bytes
 * Module - 'l2', Submodule - 'general', data - 'l2_egress_max_additional_termination_size_bytes'
 * Maximum size in bytes of additional termination on Egress to Parsing Start Offset
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_egress_max_additional_termination_size_bytes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_l2_egress_max_additional_termination_size_bytes_get_f) (
    int unit);

/**
 * \brief returns numeric data of mact_mngmnt_fid_exceed_limit_int
 * Module - 'l2', Submodule - 'general', data - 'mact_mngmnt_fid_exceed_limit_int'
 * mact management fid exceed limit interrupt
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_mngmnt_fid_exceed_limit_int - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_mact_mngmnt_fid_exceed_limit_int_get_f) (
    int unit);

/**
 * \brief returns numeric data of mact_lela_fid_exceed_limit_int
 * Module - 'l2', Submodule - 'general', data - 'mact_lela_fid_exceed_limit_int'
 * mact lela fid exceed limit interrupt
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mact_lela_fid_exceed_limit_int - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_general_mact_lela_fid_exceed_limit_int_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - GENERAL:
 * {
 */
/**
 * \brief Interface for l2 general data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_general_feature_get_f feature_get;
    /**
     * returns define data of vsi_offset_shift
     */
    dnx_data_l2_general_vsi_offset_shift_get_f vsi_offset_shift_get;
    /**
     * returns define data of lif_offset_shift
     */
    dnx_data_l2_general_lif_offset_shift_get_f lif_offset_shift_get;
    /**
     * returns numeric data of l2_learn_limit_mode
     */
    dnx_data_l2_general_l2_learn_limit_mode_get_f l2_learn_limit_mode_get;
    /**
     * returns numeric data of jr_mode_nof_fec_bits
     */
    dnx_data_l2_general_jr_mode_nof_fec_bits_get_f jr_mode_nof_fec_bits_get;
    /**
     * returns numeric data of arad_plus_mode_nof_fec_bits
     */
    dnx_data_l2_general_arad_plus_mode_nof_fec_bits_get_f arad_plus_mode_nof_fec_bits_get;
    /**
     * returns numeric data of l2_egress_max_extention_size_bytes
     */
    dnx_data_l2_general_l2_egress_max_extention_size_bytes_get_f l2_egress_max_extention_size_bytes_get;
    /**
     * returns numeric data of l2_egress_max_additional_termination_size_bytes
     */
    dnx_data_l2_general_l2_egress_max_additional_termination_size_bytes_get_f l2_egress_max_additional_termination_size_bytes_get;
    /**
     * returns numeric data of mact_mngmnt_fid_exceed_limit_int
     */
    dnx_data_l2_general_mact_mngmnt_fid_exceed_limit_int_get_f mact_mngmnt_fid_exceed_limit_int_get;
    /**
     * returns numeric data of mact_lela_fid_exceed_limit_int
     */
    dnx_data_l2_general_mact_lela_fid_exceed_limit_int_get_f mact_lela_fid_exceed_limit_int_get;
} dnx_data_if_l2_general_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURE:
 * 
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Age out and refresh distribution is always taken from the default profile
     */
    dnx_data_l2_feature_age_out_and_refresh_profile_selection,
    /**
     * Age machine stops working after flush runs
     */
    dnx_data_l2_feature_age_machine_pause_after_flush,
    /**
     * Age state of l2 entries is not updated
     */
    dnx_data_l2_feature_age_state_not_updated,
    /**
     * AppDB ID is wrongly taken from the 4 MSBs like in Jericho
     */
    dnx_data_l2_feature_appdb_id_for_olp,
    /**
     * Parser Ethernet qualifier is_mc is set correctly
     */
    dnx_data_l2_feature_eth_qual_is_mc,
    dnx_data_l2_feature_bc_same_as_unknown_mc,
    dnx_data_l2_feature_fid_mgmt_ecc_error,
    /**
     * No interrupt is raised for fid limit cross
     */
    dnx_data_l2_feature_wrong_limit_interrupt_handling,
    /**
     * Transplant event is created instead of refresh event
     */
    dnx_data_l2_feature_transplant_instead_of_refresh,
    /**
     * Static mac entries age out and deleted
     */
    dnx_data_l2_feature_static_mac_age_out,
    /**
     * For limit check the vmv is taken from the wrong side of the mdb entry
     */
    dnx_data_l2_feature_vmv_for_limit_in_wrong_location,
    /**
     * L2 limit causes supression of events related to existing entries (eg transplant/refresh)
     */
    dnx_data_l2_feature_learn_limit,
    dnx_data_l2_feature_limit_per_lif_counters,
    dnx_data_l2_feature_learn_events_wrong_command,
    dnx_data_l2_feature_opportunistic_learning_always_transplant,
    dnx_data_l2_feature_exceed_limit_interrupt_by_insert_cmd,
    dnx_data_l2_feature_refresh_events_wrong_key_msbs,
    dnx_data_l2_feature_ignore_limit_check,
    dnx_data_l2_feature_no_trap_for_unknown_destination,
    dnx_data_l2_feature_mact_access_by_opportunistic_learning,
    dnx_data_l2_feature_opportunistic_rejected,
    dnx_data_l2_feature_flush_drop_stuck,
    dnx_data_l2_feature_lif_flood_profile_always_update,
    dnx_data_l2_feature_olp_always_enters_source_cpu,

    /**
     * Must be last one!
     */
    _dnx_data_l2_feature_feature_nof
} dnx_data_l2_feature_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_feature_feature_get_f) (
    int unit,
    dnx_data_l2_feature_feature_e feature);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - FEATURE:
 * {
 */
/**
 * \brief Interface for l2 feature data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_feature_feature_get_f feature_get;
} dnx_data_if_l2_feature_t;

/*
 * }
 */

/*
 * SUBMODULE  - VSI:
 * VSI data
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l2_vsi_feature_nof
} dnx_data_l2_vsi_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_vsi_feature_get_f) (
    int unit,
    dnx_data_l2_vsi_feature_e feature);

/**
 * \brief returns define data of nof_vsi_aging_profiles
 * Module - 'l2', Submodule - 'vsi', data - 'nof_vsi_aging_profiles'
 * Number of VSI aging profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_aging_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vsi_nof_vsi_aging_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_event_forwarding_profiles
 * Module - 'l2', Submodule - 'vsi', data - 'nof_event_forwarding_profiles'
 * Number of event forwarding profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_event_forwarding_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vsi_nof_event_forwarding_profiles_get_f) (
    int unit);

/**
 * \brief returns define data of nof_vsi_learning_profiles
 * Module - 'l2', Submodule - 'vsi', data - 'nof_vsi_learning_profiles'
 * Number of VSI learning profiles
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vsi_learning_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vsi_nof_vsi_learning_profiles_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - VSI:
 * {
 */
/**
 * \brief Interface for l2 vsi data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_vsi_feature_get_f feature_get;
    /**
     * returns define data of nof_vsi_aging_profiles
     */
    dnx_data_l2_vsi_nof_vsi_aging_profiles_get_f nof_vsi_aging_profiles_get;
    /**
     * returns define data of nof_event_forwarding_profiles
     */
    dnx_data_l2_vsi_nof_event_forwarding_profiles_get_f nof_event_forwarding_profiles_get;
    /**
     * returns define data of nof_vsi_learning_profiles
     */
    dnx_data_l2_vsi_nof_vsi_learning_profiles_get_f nof_vsi_learning_profiles_get;
} dnx_data_if_l2_vsi_t;

/*
 * }
 */

/*
 * SUBMODULE  - VLAN_DOMAIN:
 * vlan domain
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l2_vlan_domain_feature_nof
} dnx_data_l2_vlan_domain_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_vlan_domain_feature_get_f) (
    int unit,
    dnx_data_l2_vlan_domain_feature_e feature);

/**
 * \brief returns define data of nof_vlan_domains
 * Module - 'l2', Submodule - 'vlan_domain', data - 'nof_vlan_domains'
 * Number of supported vlan domains
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_vlan_domains - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vlan_domain_nof_vlan_domains_get_f) (
    int unit);

/**
 * \brief returns define data of nof_bits_next_layer_network_domain
 * Module - 'l2', Submodule - 'vlan_domain', data - 'nof_bits_next_layer_network_domain'
 * Number of bits for next layer network domain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_bits_next_layer_network_domain - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_vlan_domain_nof_bits_next_layer_network_domain_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - VLAN_DOMAIN:
 * {
 */
/**
 * \brief Interface for l2 vlan_domain data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_vlan_domain_feature_get_f feature_get;
    /**
     * returns define data of nof_vlan_domains
     */
    dnx_data_l2_vlan_domain_nof_vlan_domains_get_f nof_vlan_domains_get;
    /**
     * returns define data of nof_bits_next_layer_network_domain
     */
    dnx_data_l2_vlan_domain_nof_bits_next_layer_network_domain_get_f nof_bits_next_layer_network_domain_get;
} dnx_data_if_l2_vlan_domain_t;

/*
 * }
 */

/*
 * SUBMODULE  - DMA:
 * dma
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l2_dma_feature_nof
} dnx_data_l2_dma_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_dma_feature_get_f) (
    int unit,
    dnx_data_l2_dma_feature_e feature);

/**
 * \brief returns define data of flush_nof_dma_entries
 * Module - 'l2', Submodule - 'dma', data - 'flush_nof_dma_entries'
 * Number of flush DMA entries that the host can hold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_nof_dma_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_nof_dma_entries_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_nof_dma_rules
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_nof_dma_rules'
 * Number of flush DMA rules
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_nof_dma_rules - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_nof_dma_rules_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_nof_dma_rules_per_table
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_nof_dma_rules_per_table'
 * Number of flush DMA rules in a table
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_nof_dma_rules_per_table - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_nof_dma_rules_per_table_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_rule_size
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_rule_size'
 * Size in bytes of a flush DB rule
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_rule_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_rule_size_get_f) (
    int unit);

/**
 * \brief returns define data of flush_db_data_size
 * Module - 'l2', Submodule - 'dma', data - 'flush_db_data_size'
 * Size in bytes of a flush DB action data
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_db_data_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_db_data_size_get_f) (
    int unit);

/**
 * \brief returns define data of flush_group_size
 * Module - 'l2', Submodule - 'dma', data - 'flush_group_size'
 * the size of flush group field
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_group_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_flush_group_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of learning_fifo_dma_buffer_size
 * Module - 'l2', Submodule - 'dma', data - 'learning_fifo_dma_buffer_size'
 * learning fifo dma buffer size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learning_fifo_dma_buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_learning_fifo_dma_buffer_size_get_f) (
    int unit);

/**
 * \brief returns numeric data of learning_fifo_dma_timeout
 * Module - 'l2', Submodule - 'dma', data - 'learning_fifo_dma_timeout'
 * learning fifo dma timeout in microseconds
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learning_fifo_dma_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_learning_fifo_dma_timeout_get_f) (
    int unit);

/**
 * \brief returns numeric data of learning_fifo_dma_threshold
 * Module - 'l2', Submodule - 'dma', data - 'learning_fifo_dma_threshold'
 * learning fifo dma threshold
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     learning_fifo_dma_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_learning_fifo_dma_threshold_get_f) (
    int unit);

/**
 * \brief returns numeric data of l2_dma_cpu_learn_thread_priority
 * Module - 'l2', Submodule - 'dma', data - 'l2_dma_cpu_learn_thread_priority'
 * cpu learning thread priority
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     l2_dma_cpu_learn_thread_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_dma_l2_dma_cpu_learn_thread_priority_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - DMA:
 * {
 */
/**
 * \brief Interface for l2 dma data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_dma_feature_get_f feature_get;
    /**
     * returns define data of flush_nof_dma_entries
     */
    dnx_data_l2_dma_flush_nof_dma_entries_get_f flush_nof_dma_entries_get;
    /**
     * returns define data of flush_db_nof_dma_rules
     */
    dnx_data_l2_dma_flush_db_nof_dma_rules_get_f flush_db_nof_dma_rules_get;
    /**
     * returns define data of flush_db_nof_dma_rules_per_table
     */
    dnx_data_l2_dma_flush_db_nof_dma_rules_per_table_get_f flush_db_nof_dma_rules_per_table_get;
    /**
     * returns define data of flush_db_rule_size
     */
    dnx_data_l2_dma_flush_db_rule_size_get_f flush_db_rule_size_get;
    /**
     * returns define data of flush_db_data_size
     */
    dnx_data_l2_dma_flush_db_data_size_get_f flush_db_data_size_get;
    /**
     * returns define data of flush_group_size
     */
    dnx_data_l2_dma_flush_group_size_get_f flush_group_size_get;
    /**
     * returns numeric data of learning_fifo_dma_buffer_size
     */
    dnx_data_l2_dma_learning_fifo_dma_buffer_size_get_f learning_fifo_dma_buffer_size_get;
    /**
     * returns numeric data of learning_fifo_dma_timeout
     */
    dnx_data_l2_dma_learning_fifo_dma_timeout_get_f learning_fifo_dma_timeout_get;
    /**
     * returns numeric data of learning_fifo_dma_threshold
     */
    dnx_data_l2_dma_learning_fifo_dma_threshold_get_f learning_fifo_dma_threshold_get;
    /**
     * returns numeric data of l2_dma_cpu_learn_thread_priority
     */
    dnx_data_l2_dma_l2_dma_cpu_learn_thread_priority_get_f l2_dma_cpu_learn_thread_priority_get;
} dnx_data_if_l2_dma_t;

/*
 * }
 */

/*
 * SUBMODULE  - AGE_AND_FLUSH_MACHINE:
 * Scan machine used for flush and age operations.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule age_and_flush_machine table filter_rules
 * Table info:
 * Holds flush filter rules
 */
typedef struct
{
    /**
     * memory name
     */
    soc_mem_t table_name;
    /**
     * 1 means rule is valid and should be used. 0 rule should not be checked.
     */
    soc_field_t valid;
    /**
     * Filter rule for entry mask. 1 is don't care and 0 means compare.
     */
    soc_field_t entry_mask;
    /**
     * Filter rule for entry.
     */
    soc_field_t entry_filter;
    /**
     * Filter rule for src mask.
     */
    soc_field_t src_mask;
    /**
     * Filter rule for src.
     */
    soc_field_t src_filter;
    /**
     * Filter rule for appdb id mask.
     */
    soc_field_t appdb_id_mask;
    /**
     * Filter rule for appdb id.
     */
    soc_field_t appdb_id_filter;
    /**
     * Filter rule for accessed mask.
     */
    soc_field_t accessed_mask;
    /**
     * Filter rule for accessed bit.
     */
    soc_field_t accessed_filter;
} dnx_data_l2_age_and_flush_machine_filter_rules_t;

/**
 * \brief Holds values of submodule age_and_flush_machine table data_rules
 * Table info:
 * Holds flush data for updates
 */
typedef struct
{
    /**
     * memory name
     */
    soc_mem_t table_name;
    /**
     * command type. 0-clear hit, 1-get, 2-delete, 3-transplant
     */
    soc_field_t command;
    /**
     * Mask for the payload in transplant action.
     */
    soc_field_t payload_mask;
    /**
     * Payload for transplant action.
     */
    soc_field_t payload;
} dnx_data_l2_age_and_flush_machine_data_rules_t;

/**
 * \brief Holds values of submodule age_and_flush_machine table flush
 * Table info:
 * Flush machine related HW
 */
typedef struct
{
    /**
     * Pulse the flush machine to start scanning.
     */
    soc_reg_t flush_pulse;
    /**
     * L2 flush match traverse non-blocking thread priority.
     */
    uint32 traverse_thread_priority;
} dnx_data_l2_age_and_flush_machine_flush_t;

/**
 * \brief Holds values of submodule age_and_flush_machine table age
 * Table info:
 * Age machine related HW
 */
typedef struct
{
    /**
     * Age configuration register
     */
    soc_reg_t age_config;
    /**
     * Disable aging.
     */
    soc_field_t disable_aging;
    /**
     * Pulse the scan machine to start scanning.
     */
    soc_reg_t scan_pulse;
} dnx_data_l2_age_and_flush_machine_age_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnx_data_l2_age_and_flush_machine_feature_nof
} dnx_data_l2_age_and_flush_machine_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_age_and_flush_machine_feature_get_f) (
    int unit,
    dnx_data_l2_age_and_flush_machine_feature_e feature);

/**
 * \brief returns define data of max_age_states
 * Module - 'l2', Submodule - 'age_and_flush_machine', data - 'max_age_states'
 * The maximal NOF age states that an entry can have before aging out.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_age_states - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_age_and_flush_machine_max_age_states_get_f) (
    int unit);

/**
 * \brief returns numeric data of flush_buffer_nof_entries
 * Module - 'l2', Submodule - 'age_and_flush_machine', data - 'flush_buffer_nof_entries'
 * Size of flush buffer in number of entries.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush_buffer_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_age_and_flush_machine_flush_buffer_nof_entries_get_f) (
    int unit);

/**
 * \brief get table filter_rules entry 
 * Holds flush filter rules
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     filter_rules - returns the relevant entry values grouped in struct - see dnx_data_l2_age_and_flush_machine_filter_rules_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_age_and_flush_machine_filter_rules_t *(
    *dnx_data_l2_age_and_flush_machine_filter_rules_get_f) (
    int unit);

/**
 * \brief get table data_rules entry 
 * Holds flush data for updates
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     data_rules - returns the relevant entry values grouped in struct - see dnx_data_l2_age_and_flush_machine_data_rules_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_age_and_flush_machine_data_rules_t *(
    *dnx_data_l2_age_and_flush_machine_data_rules_get_f) (
    int unit);

/**
 * \brief get table flush entry 
 * Flush machine related HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     flush - returns the relevant entry values grouped in struct - see dnx_data_l2_age_and_flush_machine_flush_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_age_and_flush_machine_flush_t *(
    *dnx_data_l2_age_and_flush_machine_flush_get_f) (
    int unit);

/**
 * \brief get table age entry 
 * Age machine related HW
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     age - returns the relevant entry values grouped in struct - see dnx_data_l2_age_and_flush_machine_age_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnx_data_l2_age_and_flush_machine_age_t *(
    *dnx_data_l2_age_and_flush_machine_age_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - AGE_AND_FLUSH_MACHINE:
 * {
 */
/**
 * \brief Interface for l2 age_and_flush_machine data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_age_and_flush_machine_feature_get_f feature_get;
    /**
     * returns define data of max_age_states
     */
    dnx_data_l2_age_and_flush_machine_max_age_states_get_f max_age_states_get;
    /**
     * returns numeric data of flush_buffer_nof_entries
     */
    dnx_data_l2_age_and_flush_machine_flush_buffer_nof_entries_get_f flush_buffer_nof_entries_get;
    /**
     * get table filter_rules entry 
     */
    dnx_data_l2_age_and_flush_machine_filter_rules_get_f filter_rules_get;
    /**
     * get general info table about table (for example key size)filter_rules info
     */
    dnxc_data_table_info_get_f filter_rules_info_get;
    /**
     * get table data_rules entry 
     */
    dnx_data_l2_age_and_flush_machine_data_rules_get_f data_rules_get;
    /**
     * get general info table about table (for example key size)data_rules info
     */
    dnxc_data_table_info_get_f data_rules_info_get;
    /**
     * get table flush entry 
     */
    dnx_data_l2_age_and_flush_machine_flush_get_f flush_get;
    /**
     * get general info table about table (for example key size)flush info
     */
    dnxc_data_table_info_get_f flush_info_get;
    /**
     * get table age entry 
     */
    dnx_data_l2_age_and_flush_machine_age_get_f age_get;
    /**
     * get general info table about table (for example key size)age info
     */
    dnxc_data_table_info_get_f age_info_get;
} dnx_data_if_l2_age_and_flush_machine_t;

/*
 * }
 */

/*
 * SUBMODULE  - OLP:
 * Data for OLP configuration
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicate if refresh events are supported
     */
    dnx_data_l2_olp_refresh_events_support,
    /**
     * Indicate if olp learn payload initial value can be read from the register
     */
    dnx_data_l2_olp_olp_learn_payload_initial_value_supported,
    /**
     * Indicate if OLP can create DSP messages
     */
    dnx_data_l2_olp_dsp_messages_support,

    /**
     * Must be last one!
     */
    _dnx_data_l2_olp_feature_nof
} dnx_data_l2_olp_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnx_data_l2_olp_feature_get_f) (
    int unit,
    dnx_data_l2_olp_feature_e feature);

/**
 * \brief returns define data of lpkgv_shift
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_shift'
 * Learn_Payload_Key_Gen_Var shift in learn payload msb
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_shift - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_shift_get_f) (
    int unit);

/**
 * \brief returns define data of lpkgv_mask
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_mask'
 * Learn_Payload_Key_Gen_Var mask in learn payload msb
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_mask_get_f) (
    int unit);

/**
 * \brief returns define data of lpkgv_with_outlif
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_with_outlif'
 * Learn_Payload_Key_Gen_Var for outlif is valid in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_with_outlif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_with_outlif_get_f) (
    int unit);

/**
 * \brief returns define data of lpkgv_wo_outlif
 * Module - 'l2', Submodule - 'olp', data - 'lpkgv_wo_outlif'
 * Learn_Payload_Key_Gen_Var for outlif is invalid in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lpkgv_wo_outlif - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_lpkgv_wo_outlif_get_f) (
    int unit);

/**
 * \brief returns define data of destination_offset
 * Module - 'l2', Submodule - 'olp', data - 'destination_offset'
 * destination offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     destination_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_destination_offset_get_f) (
    int unit);

/**
 * \brief returns define data of outlif_offset
 * Module - 'l2', Submodule - 'olp', data - 'outlif_offset'
 * outlif offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     outlif_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_outlif_offset_get_f) (
    int unit);

/**
 * \brief returns define data of eei_offset
 * Module - 'l2', Submodule - 'olp', data - 'eei_offset'
 * eei offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     eei_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_eei_offset_get_f) (
    int unit);

/**
 * \brief returns define data of fec_offset
 * Module - 'l2', Submodule - 'olp', data - 'fec_offset'
 * fec offset in learn payload
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fec_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_fec_offset_get_f) (
    int unit);

/**
 * \brief returns define data of jr_mode_enhanced_performance_enable
 * Module - 'l2', Submodule - 'olp', data - 'jr_mode_enhanced_performance_enable'
 * Enhance performance in jr mode
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     jr_mode_enhanced_performance_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnx_data_l2_olp_jr_mode_enhanced_performance_enable_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNX_DATA_IF_L2 - OLP:
 * {
 */
/**
 * \brief Interface for l2 olp data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnx_data_l2_olp_feature_get_f feature_get;
    /**
     * returns define data of lpkgv_shift
     */
    dnx_data_l2_olp_lpkgv_shift_get_f lpkgv_shift_get;
    /**
     * returns define data of lpkgv_mask
     */
    dnx_data_l2_olp_lpkgv_mask_get_f lpkgv_mask_get;
    /**
     * returns define data of lpkgv_with_outlif
     */
    dnx_data_l2_olp_lpkgv_with_outlif_get_f lpkgv_with_outlif_get;
    /**
     * returns define data of lpkgv_wo_outlif
     */
    dnx_data_l2_olp_lpkgv_wo_outlif_get_f lpkgv_wo_outlif_get;
    /**
     * returns define data of destination_offset
     */
    dnx_data_l2_olp_destination_offset_get_f destination_offset_get;
    /**
     * returns define data of outlif_offset
     */
    dnx_data_l2_olp_outlif_offset_get_f outlif_offset_get;
    /**
     * returns define data of eei_offset
     */
    dnx_data_l2_olp_eei_offset_get_f eei_offset_get;
    /**
     * returns define data of fec_offset
     */
    dnx_data_l2_olp_fec_offset_get_f fec_offset_get;
    /**
     * returns define data of jr_mode_enhanced_performance_enable
     */
    dnx_data_l2_olp_jr_mode_enhanced_performance_enable_get_f jr_mode_enhanced_performance_enable_get;
} dnx_data_if_l2_olp_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNX_DATA_IF_L2:
 * {
 */
/**
 * \brief Interface for l2 data
 */
typedef struct
{
    /**
     * Interface for l2 general data
     */
    dnx_data_if_l2_general_t general;
    /**
     * Interface for l2 feature data
     */
    dnx_data_if_l2_feature_t feature;
    /**
     * Interface for l2 vsi data
     */
    dnx_data_if_l2_vsi_t vsi;
    /**
     * Interface for l2 vlan_domain data
     */
    dnx_data_if_l2_vlan_domain_t vlan_domain;
    /**
     * Interface for l2 dma data
     */
    dnx_data_if_l2_dma_t dma;
    /**
     * Interface for l2 age_and_flush_machine data
     */
    dnx_data_if_l2_age_and_flush_machine_t age_and_flush_machine;
    /**
     * Interface for l2 olp data
     */
    dnx_data_if_l2_olp_t olp;
} dnx_data_if_l2_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnx_data_if_l2_t dnx_data_l2;
/*
 * }
 */
/*}*/
#endif /*_DNX_DATA_L2_H_*/
/* *INDENT-ON* */
