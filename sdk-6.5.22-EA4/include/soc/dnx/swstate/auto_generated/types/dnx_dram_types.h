/** \file dnx/swstate/auto_generated/types/dnx_dram_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */

#ifndef __DNX_DRAM_TYPES_H__
#define __DNX_DRAM_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <include/bcm/switch.h>
#include <include/shared/shr_thread_manager.h>
#include <soc/dnxc/swstate/types/sw_state_mutex.h>
/*
 * TYPEDEFs
 */

typedef sw_state_user_def_t* dnx_power_down_callback_userdata_t;

/*
 * ENUMs
 */

/**
 * Enum used to determine the DRAM temperature monitoring thread state
 */
typedef enum {
    /**
     * DRAM monitoring thread is operating at normal temperature state
     */
    DNX_DRAM_NORMAL_TEMP = 0,
    /**
     * DRAM monitoring thread is operating at high temperature state
     */
    DNX_DRAM_HIGH_TEMP = 1,
    /**
     * DRAM monitoring thread is operating at low temperature state
     */
    DNX_DRAM_LOW_TEMP = 2
} dnx_dram_temperature_monitoring_state_e;

/*
 * STRUCTs
 */

typedef struct {
    /**
     * indication that the info in this struct was init to real values
     */
    uint32 is_init;
    /**
     * check JEDEC for additional info
     */
    uint32 gen2_test;
    /**
     * check JEDEC for additional info
     */
    uint32 ecc;
    /**
     * check JEDEC for additional info
     */
    uint32 density;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturer_id;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturing_location;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturing_year;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturing_week;
    /**
     * check JEDEC for additional info
     */
    uint32 serial_number[2];
    /**
     * check JEDEC for additional info
     */
    uint32 addressing_mode;
    /**
     * check JEDEC for additional info
     */
    uint32 channel_available;
    /**
     * check JEDEC for additional info
     */
    uint32 hbm_stack_hight;
    /**
     * check JEDEC for additional info
     */
    uint32 model_part_number;
} hbm_dram_vendor_info_hbm_t;

typedef struct {
    /**
     * indication that the info in this struct was init to real values
     */
    uint32 is_init;
    /**
     * check JEDEC for additional info
     */
    uint32 manufacturer_vendor_code;
    /**
     * check JEDEC for additional info
     */
    uint32 revision_id;
    /**
     * check JEDEC for additional info
     */
    uint32 density;
    /**
     * check JEDEC for additional info
     */
    uint32 internal_wck;
    /**
     * check JEDEC for additional info
     */
    uint32 wck_granularity;
    /**
     * check JEDEC for additional info
     */
    uint32 wck_frequency;
    /**
     * check JEDEC for additional info
     */
    uint32 vddq_off;
} gddr6_dram_vendor_info_t;

typedef struct {
    /**
     * mutex to prevent race condition on access to deleted dram buffers file
     */
    sw_state_mutex_t deleted_buffers_file_mutex;
    /**
     * mutex to prevent race condition on access to hbm phy firmware
     */
    sw_state_mutex_t firmware_mutex;
} dnx_dram_sync_manager_t;

typedef struct {
    /**
     * pointer to power down callback function
     */
    bcm_switch_dram_power_down_callback_t callback;
    /**
     * user data pointer
     */
    dnx_power_down_callback_userdata_t userdata;
    /**
     * power to dram is currently on
     */
    uint32 power_on;
} dnx_power_down_t;

/**
 * DB for used by dram and dram buffers
 */
typedef struct {
    /**
     * is DRAM initialized
     */
    int is_initialized;
    /**
     * manages sync between different threads
     */
    dnx_dram_sync_manager_t sync_manager;
    /**
     * power down callback information (as register by the user)
     */
    dnx_power_down_t power_down_callback;
    /**
     * if set - bist used during tuning will be override by native tune configuration. if not - last bist configuration used will also be used during tuning
     */
    int override_bist_configurations_during_tuning;
    /**
     * if set - bist used during tuning will perform channel soft reset after each run.
     */
    int channel_soft_init_after_bist;
    /**
     * -1 - all cores, 0 - core 0, 1 - core 1. this configurations will choose the core on which the traffic will run when using custom mode when tuning the dram
     */
    int traffic_tuning_core_mode;
    /**
     * if set dynamic calibration is enabled (or just temporarily disabled)
     */
    int dynamic_calibration_enabled;
    /**
     * if set dynamic calibration was enabled after dram tune
     */
    int dynamic_calibration_was_enabled_after_dram_tune[2];
    /**
     * temperature monitoring thread state as defined in the enum
     */
    dnx_dram_temperature_monitoring_state_e temperature_monitoring_thread_state;
    /**
     * a handle for the thread that is created
     */
    shr_thread_manager_handler_t temperature_monitoring_thread_handler;
    /**
     * HBM vendor info
     */
    hbm_dram_vendor_info_hbm_t vendor_info[2];
    /**
     * gddr6 vendor info
     */
    gddr6_dram_vendor_info_t gddr6_vendor_info[2];
} dnx_dram_db_t;


#endif /* __DNX_DRAM_TYPES_H__ */
