/** \file dnx/swstate/auto_generated/types/dnx_field_group_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */

#ifndef __DNX_FIELD_GROUP_TYPES_H__
#define __DNX_FIELD_GROUP_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <bcm_int/dnx/kbp/kbp_mngr.h>
#include <include/soc/dnx/dbal/auto_generated/dbal_defines_tables.h>
#include <include/soc/dnx/dbal/dbal_structures.h>
#include <include/soc/dnx/dnx_data/auto_generated/dnx_data_max_elk.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_actions_types.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_key_types.h>
/*
 * MACROs
 */

/**
 * The number of qualifiers that can be packed together into a segemnt for external TCAM if DNX_FIELD_GROUP_ADD_FLAG_PACK_QUALIFIERS flag is used.
 */
#define DNX_FIELD_GROUP_EXTERNAL_NOF_QUALS_PER_SEGMENT SAL_UINT8_NOF_BITS

/**
 * The number of qualifiers that can be packed together into a segemnt for external TCAM if DNX_FIELD_GROUP_ADD_FLAG_PACK_QUALIFIERS flag is used.
 */
#define DNX_FIELD_GROUP_EXTERNAL_PACKED_QUAL_INDEX_INVALID ((uint8)(-1))

/*
 * ENUMs
 */

/**
 * Holds possible flags for Field Group configuration
 * Used in dnx_field_group_add()
 */
typedef enum {
    /**
     * Field Group is created WITH_ID,
     * I.e. user specifies which Field Group ID should be allocated
     */
    DNX_FIELD_GROUP_ADD_FLAG_WITH_ID = 0x1,
    /**
     * external counters enable
     */
    DNX_FIELD_GROUP_ADD_FLAG_EXTERNAL_COUNTERS = 0x2,
    /**
     * For external TCAM field groups, combine qualifiers whose size is not byte aligned to less segments.
     */
    DNX_FIELD_GROUP_ADD_FLAG_PACK_QUALIFIERS = 0x4,
    DNX_FIELD_GROUP_ADD_FLAG_NOF
} dnx_field_group_add_flags_e;

/**
 * Holds possible flags for Field Group context attach
 * Used in dnx_field_group_context_attach()
 */
typedef enum {
    /**
     * Aligns the MSB of a direct extraction field group to an offset on the key that is a multiplication of 32 bits.
     */
    DNX_FIELD_GROUP_CONTEXT_ATTACH_FLAG_32_RESULT_MSB_ALIGN = 0x1,
    DNX_FIELD_GROUP_CONTEXT_ATTACH_FLAG_NOF
} dnx_field_group_context_attach_flags_e;

/**
 * Holds possible flags for Field Group compare mode
 * This flags indicate specific resources that context should reserve (i.e. for compare operation) for FG
 * Relevant only in case of TCAM FG, which is created for iPMF1 stage
 * Used in dnx_field_group_context_attach()
 */
typedef enum {
    DNX_FIELD_GROUP_COMPARE_ID_FIRST = 0x0,
    DNX_FIELD_GROUP_COMPARE_ID_NONE = DNX_FIELD_GROUP_COMPARE_ID_FIRST,
    /**
     * Flag can be used in TCAM FG only to indicate that this FG will be compared against CMP1,
     * internally SDK will try to allocate key B
     */
    DNX_FIELD_GROUP_COMPARE_ID_CMP_1 = 0x1,
    /**
     * Flag can be used in TCAM FG only to indicate that this FG will be compared against CMP2,
     * internally SDK will try to allocate key D
     */
    DNX_FIELD_GROUP_COMPARE_ID_CMP_2 = 0x2,
    DNX_FIELD_GROUP_COMPARE_ID_NOF
} dnx_field_group_compare_id_e;

/**
 * Holds possible flags for ACE ID configuration
 * Used in dnx_field_ace_format_add()
 */
typedef enum {
    /**
     * ACE Format is created WITH_ID,
     * I.e. user specifies which ACE ID should be allocated
     */
    DNX_FIELD_ACE_FORMAT_ADD_FLAG_WITH_ID = 0x1,
    DNX_FIELD_ACE_FORMAT_ADD_FLAG_NOF
} dnx_field_ace_format_add_flags_e;

/**
 * Holds cache mode for TCAM entries
 * Used in dnx_field_group_entry_add()
 */
typedef enum {
    DNX_FIELD_GROUP_CACHE_MODE_FIRST = 0x0,
    /**
     * Clear cache
     */
    DNX_FIELD_GROUP_CACHE_MODE_CLEAR = DNX_FIELD_GROUP_CACHE_MODE_FIRST,
    /**
     * Start cache mode
     */
    DNX_FIELD_GROUP_CACHE_MODE_START = 0x1,
    /**
     * Install all pending entries to the hardware tables
     */
    DNX_FIELD_GROUP_CACHE_MODE_INSTALL = 0x2,
    DNX_FIELD_GROUP_CACHE_MODE_NOF
} dnx_field_group_cache_mode_e;

/*
 * STRUCTs
 */

/**
 * Structure Holds information for context's
 * allocated resources such as: Context id, key id.. etc
 * dnx_field_group_context_attach() generated information
 */
typedef struct {
    /**
     * If set to True, the information was set, i.e. program (context) was attached
     */
    uint8 context_info_valid;
    /**
     * Hold the information regarding the key allocated for the Context ID
     * Several usages:
     * 1. KBR config in the Key module
     * 2. FEM/FES config
     */
    dnx_field_key_id_t key_id;
    /**
     * Attach Info of the qualifiers inside the key.
     * Indexes match the qual_type in the key_template
     */
    dnx_field_qual_attach_info_t qual_attach_info[DNX_DATA_MAX_FIELD_GROUP_NOF_QUALS_PER_FG];
    /**
     * Holds the number of qualifiers in iPMF2 that are cascading from this FG on this context (only relevant for iPMF1 FGs).
     * When the value of this variable is larger than 0, the FG can't be detached from the context.
     */
    uint16 nof_cascading_refs;
    /**
     * Payload location inside the payload buffer returned from the external tcam.
     */
    uint32 payload_offset;
    /**
     * Payload Id for current field group inside the payload buffer. Payloads returned from the external
     * tcam are acumulated sequentially. Indicates the valid hit bit for current field group.
     */
    uint32 payload_id;
    /**
     * Flags with which Field Group was attached to a context.
     */
    dnx_field_group_context_attach_flags_e flags;
} dnx_field_attach_context_info_t;

/**
 * Holds the TCAM information that needs to be saved in SWSTATE for a TCAM FG
 */
typedef struct {
    /**
     * If true, forces SDK to auto select TCAM bank ids to be reserved, ignoring tcam_bank_ids
     */
    int auto_tcam_bank_select;
    /**
     * Number of TCAM banks to reserve for the given field group.
     */
    int nof_tcam_banks;
    /**
     * The list of TCAM bank IDs to reserve for the field group to be created.
     * This list is only valid for TCAM field groups.
     */
    int* tcam_bank_ids;
} dnx_field_group_fg_tcam_sw_info_t;

typedef struct {
    char value[DBAL_MAX_STRING_LENGTH];
} field_group_name_t;

/**
 * This structure hold the information of created FG Database.
 * The information is needed for supporting invoked bcm API's after DB was created (when Actions being configured, TCAM filling..)
 * For functions, use dnx_field_group_fg_info_for_sw_t (which contains maximal array sizes) instead.
 */
typedef struct {
    /**
     * Field stage, for which stage the Database was created
     */
    dnx_field_stage_e field_stage;
    /**
     * Field group type: The field group may be:TCAM, Direct Table, direct extraction...
     */
    dnx_field_group_type_e fg_type;
    /**
     * Field group name.
     */
    field_group_name_t name;
    /**
     * Hold the array of PMF programs that are attached to Field Group
     * each index in array is related to PMF program ID
     * I.e PMF program 7 information is located in index 7
     */
    dnx_field_attach_context_info_t context_info[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_CONTEXTS];
    /**
     * Mapping of the qualifier inside the key
     */
    dnx_field_key_template_t key_template;
    /**
     * This enum indicate the size of the Key, some Field Groups
     * use only part of the key
     */
    dnx_field_key_length_type_e key_length_type;
    /**
     * This enum indicate the size of the payload block used.
     * For example a TCAM field group can use 32, 64 or 128 bit payloads.
     * Not used by HASH or direct extraction field groups.
     */
    dnx_field_action_length_type_e action_length_type;
    /**
     * Hold the information regarding the configured actions for Field Group database
     * Later will also be used by 'entry_add' API to construct 'payload' for TCAM lookup result
     * in same order as action were placed in action place method
     */
    dnx_field_actions_fg_payload_sw_info_t actions_payload_info;
    /**
     * Holds the ID of DBAL table that was created of pair (key,action_payload) which
     * is later used by entry_add to add entries to TCAM
     */
    dbal_tables_e dbal_table_id;
    /**
     * Flags with which Field Group was created, needed for Get functionality
     */
    dnx_field_group_add_flags_e flags;
    /**
     * Holds the TCAM information that needs to be saved in SWSTATE for a TCAM FG
     */
    dnx_field_group_fg_tcam_sw_info_t tcam_info;
} dnx_field_group_fg_sw_info_t;

typedef struct {
    char value[DBAL_MAX_STRING_LENGTH];
} field_ace_format_name_t;

/**
 * This structure hold the information of created ACE Format.
 * The information is needed for supporting invoked bcm API's after ACE format was created.
 * For functions, use dnx_field_ace_format_info_t (which contains maximal array sizes) instead.
 */
typedef struct {
    /**
     * Hold the information regarding the configured actions for the ACE Format.
     * Later will also be used by 'entry_add' API to construct 'payload' for PPMC lookup result
     * in same order as action were placed in action place method
     */
    dnx_field_actions_ace_payload_sw_info_t actions_payload_info;
    /**
     * Flags with which ACE Format was created, needed for Get functionality
     */
    dnx_field_ace_format_add_flags_e flags;
    /**
     * ACE Format name.
     */
    field_ace_format_name_t name;
} dnx_field_ace_format_sw_info_t;

/**
 * Holds the information that is required for segment configuration. stored in SWSTATE for a KBP FG
 */
typedef struct {
    /**
     * This is the index of the qualifier attach_info that is stored in qual_attach_info in dnx_field_attach_context_info_t
     * The index is stored for a postponed hw configuration of the ffc's for the ACL KBP group.
     * The index represents the information required for the segment configuration (in the Master Key)
     * Note: this qual_idx is also valid for receiving the qual_type from the key_template. The other
     * information in the key_template is irrelevant.
     * An array for all packed qualifers packed into the segment if we enable packing of qualifiers in the field group.
     */
    uint8 qual_idx[DNX_FIELD_GROUP_EXTERNAL_NOF_QUALS_PER_SEGMENT];
    /**
     * This is the id of the field_group for a given qualifier.
     * Used for retrieving the qual_attach_info.
     */
    dnx_field_group_t fg_id;
} dnx_field_group_kbp_segment_info_t;

/**
 * Holds the information about the master key. That info is required for KBP ACL configuration.
 * Stored in SWSTATE for a KBP
 */
typedef struct {
    /**
     * This is the info that is used to receive the information for a given segment
     * in the Master Key. The segment information is per Opcode.
     */
    dnx_field_group_kbp_segment_info_t segment_info[DNX_KBP_MAX_NOF_SEGMENTS_PER_MASTER_KEY];
    /**
     * Indicates the number of segments (including zero padding) used by FWD, before new segments are added by ACL.
     */
    uint8 nof_fwd_segments;
} dnx_field_group_kbp_master_key_info_t;

/**
 * Holds the information that is required for KBP ACL configuration. stored in SWSTATE for a KBP FG
 */
typedef struct {
    /**
     * This is the info that is used to receive the information for
     * the Master Key. The information is per Opcode.
     */
    dnx_field_group_kbp_master_key_info_t master_key_info;
    /**
     * Holds the information about the validity of the opcode. The information is per Opcode.
     */
    uint8 is_valid;
} dnx_field_group_kbp_info_t;

/**
 * Hold the needed info to manage Field group database module
 */
typedef struct {
    /**
     * Hold the information about the Field groups.
     */
    dnx_field_group_fg_sw_info_t* fg_info;
    /**
     * Hold the information about the ACE Formats.
     */
    dnx_field_ace_format_sw_info_t* ace_format_info;
    /**
     * Hold the information about the KBP ACL configuration.
     */
    dnx_field_group_kbp_info_t kbp_info[DNX_KBP_MAX_NOF_OPCODES];
} dnx_field_group_sw_t;


#endif /* __DNX_FIELD_GROUP_TYPES_H__ */
