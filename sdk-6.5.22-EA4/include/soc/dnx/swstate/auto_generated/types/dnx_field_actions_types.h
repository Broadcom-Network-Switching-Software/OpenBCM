/** \file dnx/swstate/auto_generated/types/dnx_field_actions_types.h
 *
 * sw state types (structs/enums/typedefs)
 *
 * DO NOT EDIT THIS FILE!
 * This file is auto-generated.
 * Edits to this file will be lost when it is regenerated.
 */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */

#ifndef __DNX_FIELD_ACTIONS_TYPES_H__
#define __DNX_FIELD_ACTIONS_TYPES_H__

#include <soc/dnxc/swstate/dnxc_sw_state_h_includes.h>
#include <soc/dnx/swstate/auto_generated/types/dnx_field_types.h>
/*
 * MACROs
 */

/**
 * Indication that all actions should be ignored. May be default value but illegal as run-time input.
 * See 'ignore_actions' element in 'dnx_field_fg_id_info_t' below.
 */
#define DNX_FIELD_IGNORE_ALL_ACTIONS (uint8)(-1)

/**
 * Indication that all actions should be incorporated (configured).
 * See 'ignore_actions' element in 'dnx_field_fg_id_info_t' below.
 */
#define DNX_FIELD_IGNORE_NO_ACTIONS (uint8)(0)

/**
 * Invalid indication for 'FEM map index' (index into 'actions' array in hw). See, for example, dnx_field_fem_is_hw_action_the_same()
 */
#define DNX_FIELD_FEM_MAP_INDEX_INVALID ((dnx_field_fem_map_index_t)(-1))

/*
 * TYPEDEFs
 */

/**
 * Container of 5-bits which indicate the MS bit of the four
 * bits, on the 'key select' which are to be used as 'condition'.
 * See field FIELD_FEM_CONDITION_MS_BIT on FIELD_PMF_A_FEM_CONDITION_MS_BIT
 * on hl_acl_field_fen_definition.xml
 */
typedef uint8 dnx_field_fem_condition_ms_bit_t;

/**
 * Container of 2-bits identifiers of a FEM index that selects which of the actions
 * will be applied for specified 'FEM program' and 'FEM id'.
 * See, for example, field table FIELD_FEM_MAP_INDEX on FIELD_PMF_A_FEM_ADDER_FEMS_2_15_MAP
 * on hl_acl_field_fen_definition.xml.
 */
typedef uint8 dnx_field_fem_map_index_t;

/**
 * Container of 4-bits which may be used by corresponding actions.
 * See 'dnx_field_fem_bit_val_t' or
 * field FIELD_FEM_MAP_DATA on FIELD_PMF_A_FEM_MAP_INDEX
 * on hl_acl_field_fen_definition.xml.
 */
typedef uint8 dnx_field_fem_map_data_t;

/**
 * Container of 1-bits which indicates whether the action, corresponding
 * to a specific 'condition', is valid or not.
 * See field FIELD_FEM_ACTION_VALID on FIELD_PMF_A_FEM_MAP_INDEX
 * on hl_acl_field_fen_definition.xml.
 */
typedef uint8 dnx_field_fem_action_valid_t;

/**
 * Container of 2-bits identifiers of a 'FEM program'
 * See, for example, table FIELD_PMF_A_FEM_MAP_INDEX
 * on hl_acl_field_fem_definition.xml
 * or field FIELD_FEM_PGM_ID
 * on field_types_definition.xml
 */
typedef uint8 dnx_field_fem_program_t;

/**
 * Container of 6-bits descriprot of each action bit on FIELD_FEM_BIT_VAL
 * See tables FIELD_PMF_A_FEM_FIELD_SELECT_FEMS_2_15_MAP and FIELD_PMF_A_FEM_FIELD_SELECT_FEMS_0_1_MAP
 * on hl_acl_field_fem_definition.xml
 */
typedef uint8 dnx_field_fem_bit_val_t;

/**
 * Container of 24-bits value that is assigned to 'adder' (which is the value
 * added to the extracted action as a last step for calculating action value.
 * See table FIELD_PMF_A_FEM_ADDER_FEMS_2_15_MAP on hl_acl_field_fem_definition.xml
 */
typedef uint32 dnx_field_fem_adder_t;

/*
 * ENUMs
 */

/**
 * Holds possible flags for Action creation
 * Used in dnx_field_action_create()
 */
typedef enum {
    /**
     * Action is creaated WITH_ID,
     * I.e. user sepcifies which ID should be allocated
     */
    DNX_FIELD_ACTION_FLAG_WITH_ID = 0x1,
    DNX_FIELD_ACTION_FLAG_NOF
} dnx_field_action_flags_e;

/**
 * \brief
 * Identifiers of the various formats accepted on
 * any of the fields FIELD_SELECT_MAP_* on any of
 * the tables IPPC_FEM_*_MAP_TABLE
 */
typedef enum {
    /**
     * Invalid bit format
     */
    DNX_FIELD_FEM_BIT_FORMAT_INVALID = -1,
    /**
     * Set first so that 'nof' is made meaningful.
     */
    DNX_FIELD_FEM_BIT_FORMAT_FIRST = 0,
    /**
     * Action bit is to be taken from indicated bit on specified key_select.
     */
    DNX_FIELD_FEM_BIT_FORMAT_FROM_KEY_SELECT = DNX_FIELD_FEM_BIT_FORMAT_FIRST,
    /**
     * Action bit is to be taken from indicated bit on map_data (one of four).
     * See field MAP_DATA on FEM_MAP_INDEX_TABLE.
     */
    DNX_FIELD_FEM_BIT_FORMAT_FROM_MAP_DATA,
    /**
     * Action bit is to be taken from this field (bit 0).
     */
    DNX_FIELD_FEM_BIT_FORMAT_FROM_THIS_FIELD,
    DNX_FIELD_FEM_BIT_FORMAT_NUM
} dnx_field_fem_bit_format_e;

/*
 * STRUCTs
 */

/**
 * Structure for containing info about all actions supported by a specific field group.
 * Note that, since this structure is involved in 'large dimension' arrays, we use 'space saving'  types (such as 'uint8').
 * See dnx_field_actions_place_actions().
 * See dnx_field_actions_fg_payload_info_t.
 */
typedef struct {
    /**
     * DNX 'action'.
     * Encoded with ACTION CLASS, Stage and ID
     * If either
     * db_info_dnx_action is DNX_FIELD_ACTION_INVALID or
     * db_info_actions_size_wo_valid is '0'
     * then all other elements below are meaningless.
     * 
     * It is assumed that the first 'db_info_dnx_action' which is marked 'invalid' (DNX_FIELD_ACTION_INVALID)
     * indicates the end of valid entries.
     */
    dnx_field_action_t dnx_action;
    /**
     * Indication on whether this action uses its ls bit
     * as 'valid' indication for this action:
     * If 'dont_use_valid_bit' is '1' then lsb is NOT used as 'valid' indication
     * If 'dont_use_valid_bit' is '0' then lsb IS used as 'valid' indication.
     */
    uint8 dont_use_valid_bit;
    /**
     * LS bit of this action int the payload.
     * If the action uses valid bit, this is the location of the valid bit.
     * If the action doesn't use valid bit, this is the location of the lsb of the action.
     * 
     * Here is an example to clarify what LSB stands for:
     * Suppose the size of 'actions_block' is 32 and suppose
     * it was loaded by 0x11223344 and suppose a specific action, XX, is
     * located at LSB '0' and its length is 8 bits then its value is 0x44.
     * Suppose the following action is located at LSB '8' and its
     * size is 4 bits then its value would be 0x3 and its 'index_within_block'
     * would be '1'.
     */
    uint8 lsb;
} __ATTRIBUTE_PACKED__ dnx_field_action_in_group_info_t;

/**
 * Structure for containing info about all needed information of field group payload to add an entry.
 * For functions, use dnx_field_actions_fg_payload_info_t (which contains maximal array size) instead.
 */
typedef struct {
    /**
     * Holds all the relevant info to constuct a payload of entry for a Field Group.
     * Each action, configured for Field Group, is specified by size (bits) and place (lsb)
     * End of list of valid entries is marked by an entry with 'dnx_action = DNX_FIELD_ACTION_INVALID'
     */
    dnx_field_action_in_group_info_t actions_on_payload_info[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_ACTION_PER_GROUP];
} __ATTRIBUTE_PACKED__ dnx_field_actions_fg_payload_sw_info_t;

/**
 * Structure for containing info about all needed information of ACE format payload to add an entry.
 * Difference from dnx_field_actions_fg_payload_info_t is in array size.
 * For functions, use dnx_field_actions_ace_payload_info_t (which contains maximal array size) instead.
 */
typedef struct {
    /**
     * Holds all the relevant info to constuct a payload of entry for an ACE format.
     * Each action is specified by size (bits) and place (lsb)
     * End of list of valid entries is marked by an entry with 'dnx_action = DNX_FIELD_ACTION_INVALID'
     */
    dnx_field_action_in_group_info_t actions_on_payload_info[DNX_DATA_MAX_FIELD_ACE_NOF_ACTION_PER_ACE_FORMAT];
} __ATTRIBUTE_PACKED__ dnx_field_actions_ace_payload_sw_info_t;

/**
 * Structure holds info of action that was created by bcm_field_action_create()
 */
typedef struct {
    /**
     * TRUE if the entry is valid, false otherwise
     */
    uint32 valid;
    /**
     * DBAL field id
     */
    dbal_fields_e field_id;
    /**
     * Size of the created action
     */
    uint32 size;
    /**
     * A constant value to be appended to the action value at the MSB.
     */
    uint32 prefix;
    /**
     * The number of bits in the prefix.
     */
    uint8 prefix_size;
    /**
     * BCM user action ID that maps to the user defined qualifier
     */
    int bcm_id;
    /**
     * Number of Field Groups referring to this action
     */
    uint32 ref_count;
    /**
     * DNX level flags.
     * Saved for Get function to return all configured flags
     */
    dnx_field_action_flags_e flags;
    /**
     * The DNX action upon which the user defined action is based.
     * Contains the DNX action ID, the stage and the class of the action.
     */
    dnx_field_action_t base_dnx_action;
} __ATTRIBUTE_PACKED__ dnx_field_user_action_info_t;

typedef union {
    /**
     * The number of the bit, on input 32-bits key_select, which is to be use as this action-bit.
     */
    dnx_field_fem_bit_val_t bit_on_key_select;
    /**
     * The number of the bit, on map_data field on IPPC_FEM_MAP_INDEX_TABLE, which is to be
     * use as this action-bit. See FIELD_PMF_A_FEM_MAP_INDEX.
     */
    dnx_field_fem_bit_val_t bit_on_map_data;
    /**
     * The value of the bit which is to be use as this action-bit.
     */
    dnx_field_fem_bit_val_t bit_value;
    /**
     * The value of this union as a plain uint8 variable. All other elements are assumed to be
     * of 'uint8' type. This is used for blind comparison.
     */
    uint8 bit_descriptor_value;
} dnx_field_fem_bit_value_t;

/**
 * \brief
 * Logical representation of bit descriptor as per field of
 * type FIELD_SELECT_MAP_* (See IPPC_FEM_*_MAP_TABLE, and 'dnx_field_fem_bit_val_t')
 * \see
 * * dnx_field_fem_bit_format_e
 */
typedef struct {
    /**
     * Indicator on which of the elements is valid.
     */
    dnx_field_fem_bit_format_e fem_bit_format;
    
    dnx_field_fem_bit_value_t fem_bit_value;
} __ATTRIBUTE_PACKED__ dnx_field_fem_bit_info_t;

/**
 * \brief
 * Logical representation of all fields related to all 'action value bits' on
 * a single action.
 * Note that there are four such actions per one 'FEM id'
 * Note that, depending on FEM id, the number of bits, composing action value,
 * may be either 4 (FEMs 0/1) or 24 (FEMs 2/15).
 * See IPPC_FEM_*_MAP_TABLE, and 'dnx_field_fem_bit_info_t'
 * \see
 * * dnx_field_fem_bit_info_t
 * * dnx_field_fem_bit_format_e
 * * IPPC_FEM_*_MAP_TABLE.
 */
typedef struct {
    /**
     * Action type (7 bits) corresponding to the 24 bits (or 4 bits) action value,
     * as composed from fem_bit_info[]
     * Note that the dimension of fem_bit_info[] is the maximal value between
     * dnx_data_field.stage.stage_info_get(unit, DNX_FIELD_STAGE_IPMF1)->nof_bits_in_fem_action_fems_0_1
     * and
     * dnx_data_field.stage.stage_info_get(unit, DNX_FIELD_STAGE_IPMF1)->nof_bits_in_fem_action_fems_2_15
     * See dbal_enum_value_field_ipmf1_action_e.
     */
    dnx_field_action_type_t fem_action;
    /**
     * Descriptor of each bit on action value. See 'dnx_field_fem_bit_info_t'.
     */
    dnx_field_fem_bit_info_t fem_bit_info[DNX_DATA_MAX_FIELD_COMMON_MAX_VAL_NOF_BITS_IN_FEM_ACTION];
    /**
     * Container of the 24 bits value that is adder to extracted action value,
     * as composed from fem_bit_info[]
     * Note that, in HW, there is no 'adder' for fems_0_1. It is only there for fems_2_15.
     * See dbal_enum_value_field_ipmf1_action_e.
     */
    dnx_field_fem_adder_t fem_adder;
} __ATTRIBUTE_PACKED__ dnx_field_fem_action_entry_t;

/**
 * \brief
 * Logical representation of all fields contained in a single 'condition'
 * in the specified table.
 * \see
 * * HW table: IPPC_FEM_MAP_INDEX_TABLE
 * * DBAL table: FIELD_PMF_A_FEM_MAP_INDEX
 */
typedef struct {
    /**
     * Indicator for which 'FEM map index' is intended to be pointed by
     * this structure.
     * For each ('FEM id','FEM program','FEM condition'), there are, potentially,
     * 4 indices, corresponding to 4 actions.
     */
    dnx_field_fem_map_index_t fem_map_index;
    /**
     * Value of 'FEM map dat' intended to be use by actions corresponding to
     * this structure.
     * This is currently not used.
     */
    dnx_field_fem_map_data_t fem_map_data;
    /**
     * Action valid flag (1 bit) corresponding to ('FEM id','FEM program', FEM condition').
     * If set to '0' then pointed action will NOT be executed.
     * See
     * field FIELD_FEM_ACTION_VALID on FIELD_PMF_A_FEM_MAP_INDEX
     * on hl_acl_field_fen_definition.xml
     * Use dnx_field_fem_action_valid_t rather than dbal_enum_value_field_field_fem_action_valid_e
     * to save space on SW state.
     */
    dnx_field_fem_action_valid_t fem_action_valid;
} __ATTRIBUTE_PACKED__ dnx_field_fem_condition_entry_t;

/**
 * Structure holds input params of one Field Group on one FEM. These are parameters which are required at context attach' operation.
 * See dnx_field_fem_action_add()
 * See dnx_field_fem_state_t
 */
typedef struct {
    /**
     * If this Field group uses this FEM, this is its identifier.
     * A value of DNX_FIELD_GROUP_INVALID indicates 'no field group'.
     * In that case, all other parameters corresponding to field group, are not meaningful.
     */
    dnx_field_group_t fg_id;
    /**
     * Location (starting from LS bit of meaningful data), on 'key template', where the
     * 32-bits, known as 'fem key select', are to be taken. This is the location within
     * the meaningful bits only. See header of dnx_field_fem_action_add(). See 'fg_id' below.
     * Note that location on actual input to FEM, such as, say, key I, is set after allocation,
     * on 'context attach', and can be found on swstate. See dnx_field_group_context_info_get()
     */
    uint8 input_offset;
    /**
     * Number of meaningful, on input to FEM, on the 'chuck' referred to,
     * as 'fem key select'. See header of dnx_field_fem_action_add(). See 'fg_id' below.
     */
    uint8 input_size;
    /**
     * Identifier of a TCAM field group from whose result, the LS 16 bits are to be taken.
     * A value of DNX_FIELD_GROUP_INVALID indicates 'no such field group'.
     */
    dnx_field_group_t second_fg_id;
    /**
     * Bit map of 4 bits. If a bit is non-zero then corrsponding 'fem_action_entry' and 'fem_adder'
     * are ignored. For example, if BIT(0) is '1' then 'fem_action_entry[0]' and 'fem_adder[0]'
     * are ignored. This allows for actions of the same FEM to be used, via a few 'FEM programs',
     * by more than one FG or, even, by the same FG (but for a different set of conditions).
     * Note that if the caller tries to overwrite an action/adder which is NOT marked as 'invalid'
     * then this procedure will eject an error!.
     */
    uint8 ignore_actions;
    /**
     * List of the 'encoded' actions which were specified for this FEM on this selected 'FEM programs'.
     * A value of 'DNX_FIELD_ACTION_INVALID' indicates invalid entry.
     */
    dnx_field_action_t* fem_encoded_actions;
} __ATTRIBUTE_PACKED__ dnx_field_fg_id_info_t;

/**
 * Structure holds params of one FEM and allocations related to that FEM
 */
typedef struct {
    /**
     * Information on all potential Field Groups which use this FEM.
     * A value of 'fg_id=DNX_FIELD_GROUP_INVALID' indicates invalid entry.
     * We currently allow one field group per one pair ('FEM id','FEM program')
     */
    dnx_field_fg_id_info_t* fg_id_info;
} __ATTRIBUTE_PACKED__ dnx_field_fem_state_t;

/**
 * Sw State Db of Action Field Sub-Module.
 */
typedef struct {
    /**
     * Hold the Action params
     */
    dnx_field_user_action_info_t info[DNX_DATA_MAX_FIELD_ACTION_USER_NOF];
    /**
     * Hold information on params of each FEM and allocations related to each FEM
     */
    dnx_field_fem_state_t* fem_info;
} dnx_field_action_sw_db_t;


#endif /* __DNX_FIELD_ACTIONS_TYPES_H__ */
