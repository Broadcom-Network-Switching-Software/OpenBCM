/** \file dnxf_data_internal_port.h
 * 
 * MODULE DEVICE DATA - DNXF_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNXF_DATA_INTERNAL_PORT_H_
/*{*/
#define _DNXF_DATA_INTERNAL_PORT_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_internal.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_port.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnxf_data_port_submodule_general,
    dnxf_data_port_submodule_stat,
    dnxf_data_port_submodule_static_add,
    dnxf_data_port_submodule_lane_map,
    dnxf_data_port_submodule_pll,
    dnxf_data_port_submodule_synce,
    dnxf_data_port_submodule_retimer,
    dnxf_data_port_submodule_features,

    /**
     * Must be last one!
     */
    _dnxf_data_port_submodule_nof
} dnxf_data_port_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GENERAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_general_feature_get(
    int unit,
    dnxf_data_port_general_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_general_define_nof_links,
    dnxf_data_port_general_define_nof_pms,
    dnxf_data_port_general_define_max_bucket_fill_rate,
    dnxf_data_port_general_define_link_mask,
    dnxf_data_port_general_define_aldwp_max_val,
    dnxf_data_port_general_define_fmac_clock_khz,
    dnxf_data_port_general_define_speed_max,
    dnxf_data_port_general_define_fw_load_method,
    dnxf_data_port_general_define_fw_crc_check,
    dnxf_data_port_general_define_fw_load_verify,
    dnxf_data_port_general_define_mac_bucket_fill_rate,

    /**
     * Must be last one!
     */
    _dnxf_data_port_general_define_nof
} dnxf_data_port_general_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_links
 * Module - 'port', Submodule - 'general', data - 'nof_links'
 * Number of links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_nof_links_get(
    int unit);

/**
 * \brief returns define data of nof_pms
 * Module - 'port', Submodule - 'general', data - 'nof_pms'
 * Number of port macros.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_nof_pms_get(
    int unit);

/**
 * \brief returns define data of max_bucket_fill_rate
 * Module - 'port', Submodule - 'general', data - 'max_bucket_fill_rate'
 * Max bucket fill rate.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_bucket_fill_rate - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_max_bucket_fill_rate_get(
    int unit);

/**
 * \brief returns define data of link_mask
 * Module - 'port', Submodule - 'general', data - 'link_mask'
 * Mask adjusted to number of links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     link_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_link_mask_get(
    int unit);

/**
 * \brief returns define data of aldwp_max_val
 * Module - 'port', Submodule - 'general', data - 'aldwp_max_val'
 * Maximum value of ALDWP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aldwp_max_val - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_aldwp_max_val_get(
    int unit);

/**
 * \brief returns define data of fmac_clock_khz
 * Module - 'port', Submodule - 'general', data - 'fmac_clock_khz'
 * FMAC clock frequency [KHz]
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fmac_clock_khz_get(
    int unit);

/**
 * \brief returns define data of speed_max
 * Module - 'port', Submodule - 'general', data - 'speed_max'
 * Maximum speed of a port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     speed_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_speed_max_get(
    int unit);

/**
 * \brief returns numeric data of fw_load_method
 * Module - 'port', Submodule - 'general', data - 'fw_load_method'
 * The method of the firmware load.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_load_method - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fw_load_method_get(
    int unit);

/**
 * \brief returns numeric data of fw_crc_check
 * Module - 'port', Submodule - 'general', data - 'fw_crc_check'
 * Enable firmware CRC check.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_crc_check - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fw_crc_check_get(
    int unit);

/**
 * \brief returns numeric data of fw_load_verify
 * Module - 'port', Submodule - 'general', data - 'fw_load_verify'
 * Enable firmware load verification.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_load_verify - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_fw_load_verify_get(
    int unit);

/**
 * \brief returns numeric data of mac_bucket_fill_rate
 * Module - 'port', Submodule - 'general', data - 'mac_bucket_fill_rate'
 * Mac bucket fill rate.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_bucket_fill_rate - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_general_mac_bucket_fill_rate_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_general_table_supported_phys,
    dnxf_data_port_general_table_fmac_bus_size,

    /**
     * Must be last one!
     */
    _dnxf_data_port_general_table_nof
} dnxf_data_port_general_table_e;

/* Get Data */
/**
 * \brief get table supported_phys entry 
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_phys - returns the relevant entry values grouped in struct - see dnxf_data_port_general_supported_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_supported_phys_t * dnxf_data_port_general_supported_phys_get(
    int unit);

/**
 * \brief get table fmac_bus_size entry 
 * Fabric MAC bus size [bits]
 * 
 * \param [in] unit - unit #
 * \param [in] mode - Fabric MAC mode (FEC type)
 * 
 * \return
 *     fmac_bus_size - returns the relevant entry values grouped in struct - see dnxf_data_port_general_fmac_bus_size_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_general_fmac_bus_size_t * dnxf_data_port_general_fmac_bus_size_get(
    int unit,
    int mode);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'supported_phys'
 * general data about phys
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_supported_phys_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'general', table - 'fmac_bus_size'
 * Fabric MAC bus size [bits]
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_general_fmac_bus_size_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)supported_phys info
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_phys - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_supported_phys_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fmac_bus_size info
 * Fabric MAC bus size [bits]
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_bus_size - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_general_fmac_bus_size_info_get(
    int unit);

/*
 * SUBMODULE STAT:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_stat_feature_get(
    int unit,
    dnxf_data_port_stat_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_stat_define_thread_interval,
    dnxf_data_port_stat_define_thread_flags,
    dnxf_data_port_stat_define_thread_counter_pri,
    dnxf_data_port_stat_define_thread_timeout,

    /**
     * Must be last one!
     */
    _dnxf_data_port_stat_define_nof
} dnxf_data_port_stat_define_e;

/* Get Data */
/**
 * \brief returns numeric data of thread_interval
 * Module - 'port', Submodule - 'stat', data - 'thread_interval'
 * Statistics thread interval in microseconds.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_interval_get(
    int unit);

/**
 * \brief returns numeric data of thread_flags
 * Module - 'port', Submodule - 'stat', data - 'thread_flags'
 * Statistics thread flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_flags_get(
    int unit);

/**
 * \brief returns numeric data of thread_counter_pri
 * Module - 'port', Submodule - 'stat', data - 'thread_counter_pri'
 * Counter thread priority.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_counter_pri - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_counter_pri_get(
    int unit);

/**
 * \brief returns numeric data of thread_timeout
 * Module - 'port', Submodule - 'stat', data - 'thread_timeout'
 * Statistics thread sync operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_stat_thread_timeout_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_stat_table_nof
} dnxf_data_port_stat_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE STATIC_ADD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_static_add_feature_get(
    int unit,
    dnxf_data_port_static_add_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_static_add_define_nof
} dnxf_data_port_static_add_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_static_add_table_port_info,
    dnxf_data_port_static_add_table_serdes_lane_config,
    dnxf_data_port_static_add_table_serdes_tx_taps,
    dnxf_data_port_static_add_table_quad_info,

    /**
     * Must be last one!
     */
    _dnxf_data_port_static_add_table_nof
} dnxf_data_port_static_add_table_e;

/* Get Data */
/**
 * \brief get table port_info entry 
 * General port info
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     port_info - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_port_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_port_info_t * dnxf_data_port_static_add_port_info_get(
    int unit,
    int port);

/**
 * \brief get table serdes_lane_config entry 
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     serdes_lane_config - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_serdes_lane_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_serdes_lane_config_t * dnxf_data_port_static_add_serdes_lane_config_get(
    int unit,
    int port);

/**
 * \brief get table serdes_tx_taps entry 
 * TX FIR parameters
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     serdes_tx_taps - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_serdes_tx_taps_t * dnxf_data_port_static_add_serdes_tx_taps_get(
    int unit,
    int port);

/**
 * \brief get table quad_info entry 
 * General quad info
 * 
 * \param [in] unit - unit #
 * \param [in] quad - Quad ID.
 * 
 * \return
 *     quad_info - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_quad_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_static_add_quad_info_t * dnxf_data_port_static_add_quad_info_get(
    int unit,
    int quad);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'port_info'
 * General port info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_port_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'serdes_lane_config'
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_serdes_lane_config_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'serdes_tx_taps'
 * TX FIR parameters
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_serdes_tx_taps_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'static_add', table - 'quad_info'
 * General quad info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_static_add_quad_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)port_info info
 * General port info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     port_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_port_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)serdes_lane_config info
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     serdes_lane_config - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_serdes_lane_config_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)serdes_tx_taps info
 * TX FIR parameters
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     serdes_tx_taps - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_serdes_tx_taps_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)quad_info info
 * General quad info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     quad_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_static_add_quad_info_info_get(
    int unit);

/*
 * SUBMODULE LANE_MAP:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_lane_map_feature_get(
    int unit,
    dnxf_data_port_lane_map_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_lane_map_define_lane_map_bound,

    /**
     * Must be last one!
     */
    _dnxf_data_port_lane_map_define_nof
} dnxf_data_port_lane_map_define_e;

/* Get Data */
/**
 * \brief returns define data of lane_map_bound
 * Module - 'port', Submodule - 'lane_map', data - 'lane_map_bound'
 * Lane swapping is allowed within this nof links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lane_map_bound - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_lane_map_lane_map_bound_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_lane_map_table_info,

    /**
     * Must be last one!
     */
    _dnxf_data_port_lane_map_table_nof
} dnxf_data_port_lane_map_table_e;

/* Get Data */
/**
 * \brief get table info entry 
 * Shows the DB for the mapping between the lanes and the serdeses.
 * 
 * \param [in] unit - unit #
 * \param [in] lane - Use lane as a key to return its serdes mapping values
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnxf_data_port_lane_map_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_lane_map_info_t * dnxf_data_port_lane_map_info_get(
    int unit,
    int lane);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'lane_map', table - 'info'
 * Shows the DB for the mapping between the lanes and the serdeses.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_lane_map_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)info info
 * Shows the DB for the mapping between the lanes and the serdeses.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_lane_map_info_info_get(
    int unit);

/*
 * SUBMODULE PLL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_pll_feature_get(
    int unit,
    dnxf_data_port_pll_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_port_pll_define_nof_lcpll,
    dnxf_data_port_pll_define_nof_port_in_lcpll,
    dnxf_data_port_pll_define_fabric_clock_freq_in_default,
    dnxf_data_port_pll_define_fabric_clock_freq_out_default,
    dnxf_data_port_pll_define_nof_plls_per_pm,
    dnxf_data_port_pll_define_nof_config_words,

    /**
     * Must be last one!
     */
    _dnxf_data_port_pll_define_nof
} dnxf_data_port_pll_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_lcpll
 * Module - 'port', Submodule - 'pll', data - 'nof_lcpll'
 * Number of LCPLL.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lcpll - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_lcpll_get(
    int unit);

/**
 * \brief returns define data of nof_port_in_lcpll
 * Module - 'port', Submodule - 'pll', data - 'nof_port_in_lcpll'
 * Number of ports for each LCPLL.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_in_lcpll - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_port_in_lcpll_get(
    int unit);

/**
 * \brief returns define data of fabric_clock_freq_in_default
 * Module - 'port', Submodule - 'pll', data - 'fabric_clock_freq_in_default'
 * Fabric Clock freq in default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_clock_freq_in_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_fabric_clock_freq_in_default_get(
    int unit);

/**
 * \brief returns define data of fabric_clock_freq_out_default
 * Module - 'port', Submodule - 'pll', data - 'fabric_clock_freq_out_default'
 * Fabric Clock freq out default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_clock_freq_out_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_fabric_clock_freq_out_default_get(
    int unit);

/**
 * \brief returns define data of nof_plls_per_pm
 * Module - 'port', Submodule - 'pll', data - 'nof_plls_per_pm'
 * Number of PLLs per port macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_plls_per_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_plls_per_pm_get(
    int unit);

/**
 * \brief returns define data of nof_config_words
 * Module - 'port', Submodule - 'pll', data - 'nof_config_words'
 * Number of PLL configuration words
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_config_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_port_pll_nof_config_words_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_pll_table_info,
    dnxf_data_port_pll_table_force_single_pll,
    dnxf_data_port_pll_table_config,

    /**
     * Must be last one!
     */
    _dnxf_data_port_pll_table_nof
} dnxf_data_port_pll_table_e;

/* Get Data */
/**
 * \brief get table info entry 
 * General PLL info
 * 
 * \param [in] unit - unit #
 * \param [in] pll - PLL ID.
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_pll_info_t * dnxf_data_port_pll_info_get(
    int unit,
    int pll);

/**
 * \brief get table force_single_pll entry 
 * 
 * \param [in] unit - unit #
 * \param [in] pm - pm id
 * 
 * \return
 *     force_single_pll - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_force_single_pll_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_pll_force_single_pll_t * dnxf_data_port_pll_force_single_pll_get(
    int unit,
    int pm);

/**
 * \brief get table config entry 
 * PLL configuration
 * 
 * \param [in] unit - unit #
 * \param [in] fabric_ref_clk_in - PLL Input Reference Clock
 * \param [in] fabric_ref_clk_out - PLL Output Reference Clock
 * 
 * \return
 *     config - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_pll_config_t * dnxf_data_port_pll_config_get(
    int unit,
    int fabric_ref_clk_in,
    int fabric_ref_clk_out);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'pll', table - 'info'
 * General PLL info
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_pll_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'pll', table - 'force_single_pll'
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_pll_force_single_pll_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'pll', table - 'config'
 * PLL configuration
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_pll_config_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)info info
 * General PLL info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_pll_info_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)force_single_pll info
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     force_single_pll - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_pll_force_single_pll_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)config info
 * PLL configuration
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     config - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_pll_config_info_get(
    int unit);

/*
 * SUBMODULE SYNCE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_synce_feature_get(
    int unit,
    dnxf_data_port_synce_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_synce_define_nof
} dnxf_data_port_synce_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_synce_table_cfg,

    /**
     * Must be last one!
     */
    _dnxf_data_port_synce_table_nof
} dnxf_data_port_synce_table_e;

/* Get Data */
/**
 * \brief get table cfg entry 
 * Fabric Sync Ethernet information.
 * 
 * \param [in] unit - unit #
 * \param [in] synce_index - SYNCE clock index.
 * 
 * \return
 *     cfg - returns the relevant entry values grouped in struct - see dnxf_data_port_synce_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_synce_cfg_t * dnxf_data_port_synce_cfg_get(
    int unit,
    int synce_index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'synce', table - 'cfg'
 * Fabric Sync Ethernet information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_synce_cfg_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)cfg info
 * Fabric Sync Ethernet information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     cfg - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_synce_cfg_info_get(
    int unit);

/*
 * SUBMODULE RETIMER:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_retimer_feature_get(
    int unit,
    dnxf_data_port_retimer_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_retimer_define_nof
} dnxf_data_port_retimer_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_port_retimer_table_links_connection,

    /**
     * Must be last one!
     */
    _dnxf_data_port_retimer_table_nof
} dnxf_data_port_retimer_table_e;

/* Get Data */
/**
 * \brief get table links_connection entry 
 * Link pairs for pass-through retimer
 * 
 * \param [in] unit - unit #
 * \param [in] link - link id
 * 
 * \return
 *     links_connection - returns the relevant entry values grouped in struct - see dnxf_data_port_retimer_links_connection_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_port_retimer_links_connection_t * dnxf_data_port_retimer_links_connection_get(
    int unit,
    int link);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'port', Submodule - 'retimer', table - 'links_connection'
 * Link pairs for pass-through retimer
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_retimer_links_connection_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)links_connection info
 * Link pairs for pass-through retimer
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     links_connection - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_port_retimer_links_connection_info_get(
    int unit);

/*
 * SUBMODULE FEATURES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_port_features_feature_get(
    int unit,
    dnxf_data_port_features_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_features_define_nof
} dnxf_data_port_features_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_features_table_nof
} dnxf_data_port_features_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_port_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_INTERNAL_PORT_H_*/
/* *INDENT-ON* */
