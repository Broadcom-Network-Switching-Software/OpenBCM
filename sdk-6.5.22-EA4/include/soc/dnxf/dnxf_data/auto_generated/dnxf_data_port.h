/** \file dnxf_data_port.h
 * 
 * MODULE DATA INTERFACE - 
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNXF_DATA_PORT_H_
/*{*/
#define _DNXF_DATA_PORT_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/property.h>
#include <sal/limits.h>
#include <shared/shrextend/shrextend_debug.h>
#include <shared/utilex/utilex_framework.h>
#include <soc/dnxc/dnxc_data/dnxc_data_utils.h>
#include <soc/dnxc/dnxc_data/dnxc_data_mgmt.h>
#include <bcm/port.h>
#include <bcm/types.h>
#include <shared/pbmp.h>
#include <soc/portmod/portmod.h>
#include <soc/dnxc/dnxc_port.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_max_port.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * MODULE FUNCTIONS:
 * {
 */
/**
 * \brief Init default data structure - dnxf_data_if_port
 * 
 * \param [in] unit - Unit #
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_if_port_init(
    int unit);

/*
 * }
 */

/*
 * SUBMODULE  - GENERAL:
 * General attributes
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule general table supported_phys
 * Table info:
 * general data about phys
 */
typedef struct
{
    /**
     * bitmap of supported phys.
     */
    bcm_pbmp_t pbmp;
} dnxf_data_port_general_supported_phys_t;

/**
 * \brief Holds values of submodule general table fmac_bus_size
 * Table info:
 * Fabric MAC bus size [bits]
 */
typedef struct
{
    /**
     * The bus size [bits]
     */
    int size;
} dnxf_data_port_general_fmac_bus_size_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Indicates if MAC cell shaper is supported for the given device
     */
    dnxf_data_port_general_mac_cell_shaper_supported,
    /**
     * should serdes bandwidth be updated
     */
    dnxf_data_port_general_bw_update,

    /**
     * Must be last one!
     */
    _dnxf_data_port_general_feature_nof
} dnxf_data_port_general_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_general_feature_get_f) (
    int unit,
    dnxf_data_port_general_feature_e feature);

/**
 * \brief returns define data of nof_links
 * Module - 'port', Submodule - 'general', data - 'nof_links'
 * Number of links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_nof_links_get_f) (
    int unit);

/**
 * \brief returns define data of nof_pms
 * Module - 'port', Submodule - 'general', data - 'nof_pms'
 * Number of port macros.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pms - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_nof_pms_get_f) (
    int unit);

/**
 * \brief returns define data of max_bucket_fill_rate
 * Module - 'port', Submodule - 'general', data - 'max_bucket_fill_rate'
 * Max bucket fill rate.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_bucket_fill_rate - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_max_bucket_fill_rate_get_f) (
    int unit);

/**
 * \brief returns define data of link_mask
 * Module - 'port', Submodule - 'general', data - 'link_mask'
 * Mask adjusted to number of links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     link_mask - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_link_mask_get_f) (
    int unit);

/**
 * \brief returns define data of aldwp_max_val
 * Module - 'port', Submodule - 'general', data - 'aldwp_max_val'
 * Maximum value of ALDWP.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     aldwp_max_val - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_aldwp_max_val_get_f) (
    int unit);

/**
 * \brief returns define data of fmac_clock_khz
 * Module - 'port', Submodule - 'general', data - 'fmac_clock_khz'
 * FMAC clock frequency [KHz]
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_fmac_clock_khz_get_f) (
    int unit);

/**
 * \brief returns define data of speed_max
 * Module - 'port', Submodule - 'general', data - 'speed_max'
 * Maximum speed of a port
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     speed_max - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_speed_max_get_f) (
    int unit);

/**
 * \brief returns numeric data of fw_load_method
 * Module - 'port', Submodule - 'general', data - 'fw_load_method'
 * The method of the firmware load.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_load_method - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_fw_load_method_get_f) (
    int unit);

/**
 * \brief returns numeric data of fw_crc_check
 * Module - 'port', Submodule - 'general', data - 'fw_crc_check'
 * Enable firmware CRC check.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_crc_check - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_fw_crc_check_get_f) (
    int unit);

/**
 * \brief returns numeric data of fw_load_verify
 * Module - 'port', Submodule - 'general', data - 'fw_load_verify'
 * Enable firmware load verification.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fw_load_verify - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_fw_load_verify_get_f) (
    int unit);

/**
 * \brief returns numeric data of mac_bucket_fill_rate
 * Module - 'port', Submodule - 'general', data - 'mac_bucket_fill_rate'
 * Mac bucket fill rate.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mac_bucket_fill_rate - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_general_mac_bucket_fill_rate_get_f) (
    int unit);

/**
 * \brief get table supported_phys entry 
 * general data about phys
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     supported_phys - returns the relevant entry values grouped in struct - see dnxf_data_port_general_supported_phys_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_general_supported_phys_t *(
    *dnxf_data_port_general_supported_phys_get_f) (
    int unit);

/**
 * \brief get table fmac_bus_size entry 
 * Fabric MAC bus size [bits]
 * 
 * \param [in] unit - unit #
 * \param [in] mode - Fabric MAC mode (FEC type)
 * 
 * \return
 *     fmac_bus_size - returns the relevant entry values grouped in struct - see dnxf_data_port_general_fmac_bus_size_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_general_fmac_bus_size_t *(
    *dnxf_data_port_general_fmac_bus_size_get_f) (
    int unit,
    int mode);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - GENERAL:
 * {
 */
/**
 * \brief Interface for port general data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_general_feature_get_f feature_get;
    /**
     * returns define data of nof_links
     */
    dnxf_data_port_general_nof_links_get_f nof_links_get;
    /**
     * returns define data of nof_pms
     */
    dnxf_data_port_general_nof_pms_get_f nof_pms_get;
    /**
     * returns define data of max_bucket_fill_rate
     */
    dnxf_data_port_general_max_bucket_fill_rate_get_f max_bucket_fill_rate_get;
    /**
     * returns define data of link_mask
     */
    dnxf_data_port_general_link_mask_get_f link_mask_get;
    /**
     * returns define data of aldwp_max_val
     */
    dnxf_data_port_general_aldwp_max_val_get_f aldwp_max_val_get;
    /**
     * returns define data of fmac_clock_khz
     */
    dnxf_data_port_general_fmac_clock_khz_get_f fmac_clock_khz_get;
    /**
     * returns define data of speed_max
     */
    dnxf_data_port_general_speed_max_get_f speed_max_get;
    /**
     * returns numeric data of fw_load_method
     */
    dnxf_data_port_general_fw_load_method_get_f fw_load_method_get;
    /**
     * returns numeric data of fw_crc_check
     */
    dnxf_data_port_general_fw_crc_check_get_f fw_crc_check_get;
    /**
     * returns numeric data of fw_load_verify
     */
    dnxf_data_port_general_fw_load_verify_get_f fw_load_verify_get;
    /**
     * returns numeric data of mac_bucket_fill_rate
     */
    dnxf_data_port_general_mac_bucket_fill_rate_get_f mac_bucket_fill_rate_get;
    /**
     * get table supported_phys entry 
     */
    dnxf_data_port_general_supported_phys_get_f supported_phys_get;
    /**
     * get general info table about table (for example key size)supported_phys info
     */
    dnxc_data_table_info_get_f supported_phys_info_get;
    /**
     * get table fmac_bus_size entry 
     */
    dnxf_data_port_general_fmac_bus_size_get_f fmac_bus_size_get;
    /**
     * get general info table about table (for example key size)fmac_bus_size info
     */
    dnxc_data_table_info_get_f fmac_bus_size_info_get;
} dnxf_data_if_port_general_t;

/*
 * }
 */

/*
 * SUBMODULE  - STAT:
 * Port Statistics information
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_stat_feature_nof
} dnxf_data_port_stat_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_stat_feature_get_f) (
    int unit,
    dnxf_data_port_stat_feature_e feature);

/**
 * \brief returns numeric data of thread_interval
 * Module - 'port', Submodule - 'stat', data - 'thread_interval'
 * Statistics thread interval in microseconds.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_stat_thread_interval_get_f) (
    int unit);

/**
 * \brief returns numeric data of thread_flags
 * Module - 'port', Submodule - 'stat', data - 'thread_flags'
 * Statistics thread flags.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_flags - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_stat_thread_flags_get_f) (
    int unit);

/**
 * \brief returns numeric data of thread_counter_pri
 * Module - 'port', Submodule - 'stat', data - 'thread_counter_pri'
 * Counter thread priority.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_counter_pri - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_stat_thread_counter_pri_get_f) (
    int unit);

/**
 * \brief returns numeric data of thread_timeout
 * Module - 'port', Submodule - 'stat', data - 'thread_timeout'
 * Statistics thread sync operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thread_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_stat_thread_timeout_get_f) (
    int unit);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - STAT:
 * {
 */
/**
 * \brief Interface for port stat data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_stat_feature_get_f feature_get;
    /**
     * returns numeric data of thread_interval
     */
    dnxf_data_port_stat_thread_interval_get_f thread_interval_get;
    /**
     * returns numeric data of thread_flags
     */
    dnxf_data_port_stat_thread_flags_get_f thread_flags_get;
    /**
     * returns numeric data of thread_counter_pri
     */
    dnxf_data_port_stat_thread_counter_pri_get_f thread_counter_pri_get;
    /**
     * returns numeric data of thread_timeout
     */
    dnxf_data_port_stat_thread_timeout_get_f thread_timeout_get;
} dnxf_data_if_port_stat_t;

/*
 * }
 */

/*
 * SUBMODULE  - STATIC_ADD:
 * General static add information
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule static_add table port_info
 * Table info:
 * General port info
 */
typedef struct
{
    /**
     * Sets the data transfer speed with which the port is initialized
     */
    int speed;
    /**
     * Does the port has its link training enabled
     */
    uint32 link_training;
    /**
     * Specifies the FEC type
     */
    bcm_port_phy_fec_t fec_type;
    /**
     * Switch TX phy polarity
     */
    uint32 tx_polarity;
    /**
     * Switch RX phy polarity
     */
    uint32 rx_polarity;
    /**
     * Shows if the link is connected to repeater device
     */
    uint32 connected_to_repeater;
    /**
     * is the precoding enabled on TX side
     */
    uint32 tx_pam4_precoder;
    /**
     * has the link partner enabled pre-coding on its TX side. In other words - enable the decoding on my RX side.
     */
    uint32 lp_tx_precoder;
} dnxf_data_port_static_add_port_info_t;

/**
 * \brief Holds values of submodule static_add table serdes_lane_config
 * Table info:
 * serdes lane configurations, related to firmware
 */
typedef struct
{
    /**
     * dfe filter
     */
    soc_dnxc_port_dfe_mode_t dfe;
    /**
     * media type
     */
    int media_type;
    /**
     * unreliable los
     */
    int unreliable_los;
    /**
     * cl72 auto polarity
     */
    int cl72_auto_polarity_enable;
    /**
     * cl72 restart timeout
     */
    int cl72_restart_timeout_enable;
    /**
     * force nr or force er
     */
    soc_dnxc_port_channel_mode_t channel_mode;
} dnxf_data_port_static_add_serdes_lane_config_t;

/**
 * \brief Holds values of submodule static_add table serdes_tx_taps
 * Table info:
 * TX FIR parameters
 */
typedef struct
{
    /**
     * pre2
     */
    int pre2;
    /**
     * pre
     */
    int pre;
    /**
     * main
     */
    int main;
    /**
     * post
     */
    int post;
    /**
     * post2
     */
    int post2;
    /**
     * post3
     */
    int post3;
    /**
     * tx tap mode - 3 or 6 taps
     */
    bcm_port_phy_tx_tap_mode_t tx_tap_mode;
    /**
     * signalling mode - pam4 or nrz
     */
    bcm_port_phy_signalling_mode_t signalling_mode;
} dnxf_data_port_static_add_serdes_tx_taps_t;

/**
 * \brief Holds values of submodule static_add table quad_info
 * Table info:
 * General quad info
 */
typedef struct
{
    /**
     * Is the quad enabled.
     */
    int quad_enable;
} dnxf_data_port_static_add_quad_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_static_add_feature_nof
} dnxf_data_port_static_add_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_static_add_feature_get_f) (
    int unit,
    dnxf_data_port_static_add_feature_e feature);

/**
 * \brief get table port_info entry 
 * General port info
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     port_info - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_port_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_static_add_port_info_t *(
    *dnxf_data_port_static_add_port_info_get_f) (
    int unit,
    int port);

/**
 * \brief get table serdes_lane_config entry 
 * serdes lane configurations, related to firmware
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     serdes_lane_config - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_serdes_lane_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_static_add_serdes_lane_config_t *(
    *dnxf_data_port_static_add_serdes_lane_config_get_f) (
    int unit,
    int port);

/**
 * \brief get table serdes_tx_taps entry 
 * TX FIR parameters
 * 
 * \param [in] unit - unit #
 * \param [in] port - Link ID.
 * 
 * \return
 *     serdes_tx_taps - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_serdes_tx_taps_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_static_add_serdes_tx_taps_t *(
    *dnxf_data_port_static_add_serdes_tx_taps_get_f) (
    int unit,
    int port);

/**
 * \brief get table quad_info entry 
 * General quad info
 * 
 * \param [in] unit - unit #
 * \param [in] quad - Quad ID.
 * 
 * \return
 *     quad_info - returns the relevant entry values grouped in struct - see dnxf_data_port_static_add_quad_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_static_add_quad_info_t *(
    *dnxf_data_port_static_add_quad_info_get_f) (
    int unit,
    int quad);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - STATIC_ADD:
 * {
 */
/**
 * \brief Interface for port static_add data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_static_add_feature_get_f feature_get;
    /**
     * get table port_info entry 
     */
    dnxf_data_port_static_add_port_info_get_f port_info_get;
    /**
     * get general info table about table (for example key size)port_info info
     */
    dnxc_data_table_info_get_f port_info_info_get;
    /**
     * get table serdes_lane_config entry 
     */
    dnxf_data_port_static_add_serdes_lane_config_get_f serdes_lane_config_get;
    /**
     * get general info table about table (for example key size)serdes_lane_config info
     */
    dnxc_data_table_info_get_f serdes_lane_config_info_get;
    /**
     * get table serdes_tx_taps entry 
     */
    dnxf_data_port_static_add_serdes_tx_taps_get_f serdes_tx_taps_get;
    /**
     * get general info table about table (for example key size)serdes_tx_taps info
     */
    dnxc_data_table_info_get_f serdes_tx_taps_info_get;
    /**
     * get table quad_info entry 
     */
    dnxf_data_port_static_add_quad_info_get_f quad_info_get;
    /**
     * get general info table about table (for example key size)quad_info info
     */
    dnxc_data_table_info_get_f quad_info_info_get;
} dnxf_data_if_port_static_add_t;

/*
 * }
 */

/*
 * SUBMODULE  - LANE_MAP:
 * General lane map attributes
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule lane_map table info
 * Table info:
 * Shows the DB for the mapping between the lanes and the serdeses.
 */
typedef struct
{
    /**
     * The connected serdes rx id.
     */
    uint32 serdes_rx_id;
    /**
     * The connected serdes tx id.
     */
    uint32 serdes_tx_id;
} dnxf_data_port_lane_map_info_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_lane_map_feature_nof
} dnxf_data_port_lane_map_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_lane_map_feature_get_f) (
    int unit,
    dnxf_data_port_lane_map_feature_e feature);

/**
 * \brief returns define data of lane_map_bound
 * Module - 'port', Submodule - 'lane_map', data - 'lane_map_bound'
 * Lane swapping is allowed within this nof links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     lane_map_bound - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_lane_map_lane_map_bound_get_f) (
    int unit);

/**
 * \brief get table info entry 
 * Shows the DB for the mapping between the lanes and the serdeses.
 * 
 * \param [in] unit - unit #
 * \param [in] lane - Use lane as a key to return its serdes mapping values
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnxf_data_port_lane_map_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_lane_map_info_t *(
    *dnxf_data_port_lane_map_info_get_f) (
    int unit,
    int lane);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - LANE_MAP:
 * {
 */
/**
 * \brief Interface for port lane_map data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_lane_map_feature_get_f feature_get;
    /**
     * returns define data of lane_map_bound
     */
    dnxf_data_port_lane_map_lane_map_bound_get_f lane_map_bound_get;
    /**
     * get table info entry 
     */
    dnxf_data_port_lane_map_info_get_f info_get;
    /**
     * get general info table about table (for example key size)info info
     */
    dnxc_data_table_info_get_f info_info_get;
} dnxf_data_if_port_lane_map_t;

/*
 * }
 */

/*
 * SUBMODULE  - PLL:
 * General PLL attributes
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule pll table info
 * Table info:
 * General PLL info
 */
typedef struct
{
    /**
     * Shows the value for the fabric PLL input reference clock.
     */
    uint32 fabric_ref_clk_in;
    /**
     * Shows the value for the fabric PLL output reference clock.
     */
    uint32 fabric_ref_clk_out;
} dnxf_data_port_pll_info_t;

/**
 * \brief Holds values of submodule pll table force_single_pll
 */
typedef struct
{
    /**
     * is enabled
     */
    int enable;
} dnxf_data_port_pll_force_single_pll_t;

/**
 * \brief Holds values of submodule pll table config
 * Table info:
 * PLL configuration
 */
typedef struct
{
    /**
     * PLL configuration words
     */
    uint32 data[DNXF_DATA_MAX_PORT_PLL_NOF_CONFIG_WORDS];
    /**
     * Is configuration valid (boolean)
     */
    uint32 valid;
} dnxf_data_port_pll_config_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_pll_feature_nof
} dnxf_data_port_pll_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_pll_feature_get_f) (
    int unit,
    dnxf_data_port_pll_feature_e feature);

/**
 * \brief returns define data of nof_lcpll
 * Module - 'port', Submodule - 'pll', data - 'nof_lcpll'
 * Number of LCPLL.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_lcpll - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_pll_nof_lcpll_get_f) (
    int unit);

/**
 * \brief returns define data of nof_port_in_lcpll
 * Module - 'port', Submodule - 'pll', data - 'nof_port_in_lcpll'
 * Number of ports for each LCPLL.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_port_in_lcpll - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_pll_nof_port_in_lcpll_get_f) (
    int unit);

/**
 * \brief returns define data of fabric_clock_freq_in_default
 * Module - 'port', Submodule - 'pll', data - 'fabric_clock_freq_in_default'
 * Fabric Clock freq in default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_clock_freq_in_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_pll_fabric_clock_freq_in_default_get_f) (
    int unit);

/**
 * \brief returns define data of fabric_clock_freq_out_default
 * Module - 'port', Submodule - 'pll', data - 'fabric_clock_freq_out_default'
 * Fabric Clock freq out default.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fabric_clock_freq_out_default - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_pll_fabric_clock_freq_out_default_get_f) (
    int unit);

/**
 * \brief returns define data of nof_plls_per_pm
 * Module - 'port', Submodule - 'pll', data - 'nof_plls_per_pm'
 * Number of PLLs per port macro
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_plls_per_pm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_pll_nof_plls_per_pm_get_f) (
    int unit);

/**
 * \brief returns define data of nof_config_words
 * Module - 'port', Submodule - 'pll', data - 'nof_config_words'
 * Number of PLL configuration words
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_config_words - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef uint32(
    *dnxf_data_port_pll_nof_config_words_get_f) (
    int unit);

/**
 * \brief get table info entry 
 * General PLL info
 * 
 * \param [in] unit - unit #
 * \param [in] pll - PLL ID.
 * 
 * \return
 *     info - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_pll_info_t *(
    *dnxf_data_port_pll_info_get_f) (
    int unit,
    int pll);

/**
 * \brief get table force_single_pll entry 
 * 
 * \param [in] unit - unit #
 * \param [in] pm - pm id
 * 
 * \return
 *     force_single_pll - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_force_single_pll_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_pll_force_single_pll_t *(
    *dnxf_data_port_pll_force_single_pll_get_f) (
    int unit,
    int pm);

/**
 * \brief get table config entry 
 * PLL configuration
 * 
 * \param [in] unit - unit #
 * \param [in] fabric_ref_clk_in - PLL Input Reference Clock
 * \param [in] fabric_ref_clk_out - PLL Output Reference Clock
 * 
 * \return
 *     config - returns the relevant entry values grouped in struct - see dnxf_data_port_pll_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_pll_config_t *(
    *dnxf_data_port_pll_config_get_f) (
    int unit,
    int fabric_ref_clk_in,
    int fabric_ref_clk_out);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - PLL:
 * {
 */
/**
 * \brief Interface for port pll data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_pll_feature_get_f feature_get;
    /**
     * returns define data of nof_lcpll
     */
    dnxf_data_port_pll_nof_lcpll_get_f nof_lcpll_get;
    /**
     * returns define data of nof_port_in_lcpll
     */
    dnxf_data_port_pll_nof_port_in_lcpll_get_f nof_port_in_lcpll_get;
    /**
     * returns define data of fabric_clock_freq_in_default
     */
    dnxf_data_port_pll_fabric_clock_freq_in_default_get_f fabric_clock_freq_in_default_get;
    /**
     * returns define data of fabric_clock_freq_out_default
     */
    dnxf_data_port_pll_fabric_clock_freq_out_default_get_f fabric_clock_freq_out_default_get;
    /**
     * returns define data of nof_plls_per_pm
     */
    dnxf_data_port_pll_nof_plls_per_pm_get_f nof_plls_per_pm_get;
    /**
     * returns define data of nof_config_words
     */
    dnxf_data_port_pll_nof_config_words_get_f nof_config_words_get;
    /**
     * get table info entry 
     */
    dnxf_data_port_pll_info_get_f info_get;
    /**
     * get general info table about table (for example key size)info info
     */
    dnxc_data_table_info_get_f info_info_get;
    /**
     * get table force_single_pll entry 
     */
    dnxf_data_port_pll_force_single_pll_get_f force_single_pll_get;
    /**
     * get general info table about table (for example key size)force_single_pll info
     */
    dnxc_data_table_info_get_f force_single_pll_info_get;
    /**
     * get table config entry 
     */
    dnxf_data_port_pll_config_get_f config_get;
    /**
     * get general info table about table (for example key size)config info
     */
    dnxc_data_table_info_get_f config_info_get;
} dnxf_data_if_port_pll_t;

/*
 * }
 */

/*
 * SUBMODULE  - SYNCE:
 * General SYNCE attributes.
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule synce table cfg
 * Table info:
 * Fabric Sync Ethernet information.
 */
typedef struct
{
    /**
     * Specifies which is the source clock port
     */
    int source_clock_port;
    /**
     * Specifiers the clock divider
     */
    uint32 source_clock_divider;
} dnxf_data_port_synce_cfg_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_port_synce_feature_nof
} dnxf_data_port_synce_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_synce_feature_get_f) (
    int unit,
    dnxf_data_port_synce_feature_e feature);

/**
 * \brief get table cfg entry 
 * Fabric Sync Ethernet information.
 * 
 * \param [in] unit - unit #
 * \param [in] synce_index - SYNCE clock index.
 * 
 * \return
 *     cfg - returns the relevant entry values grouped in struct - see dnxf_data_port_synce_cfg_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_synce_cfg_t *(
    *dnxf_data_port_synce_cfg_get_f) (
    int unit,
    int synce_index);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - SYNCE:
 * {
 */
/**
 * \brief Interface for port synce data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_synce_feature_get_f feature_get;
    /**
     * get table cfg entry 
     */
    dnxf_data_port_synce_cfg_get_f cfg_get;
    /**
     * get general info table about table (for example key size)cfg info
     */
    dnxc_data_table_info_get_f cfg_info_get;
} dnxf_data_if_port_synce_t;

/*
 * }
 */

/*
 * SUBMODULE  - RETIMER:
 * retimer database
 * {
 */
/*
 * Table value structure
 */
/**
 * \brief Holds values of submodule retimer table links_connection
 * Table info:
 * Link pairs for pass-through retimer
 */
typedef struct
{
    /**
     * the connected link id
     */
    soc_port_t connected_link;
} dnxf_data_port_retimer_links_connection_t;

/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    /**
     * Shows if retimer is supported
     */
    dnxf_data_port_retimer_is_supported,

    /**
     * Must be last one!
     */
    _dnxf_data_port_retimer_feature_nof
} dnxf_data_port_retimer_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_retimer_feature_get_f) (
    int unit,
    dnxf_data_port_retimer_feature_e feature);

/**
 * \brief get table links_connection entry 
 * Link pairs for pass-through retimer
 * 
 * \param [in] unit - unit #
 * \param [in] link - link id
 * 
 * \return
 *     links_connection - returns the relevant entry values grouped in struct - see dnxf_data_port_retimer_links_connection_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef const dnxf_data_port_retimer_links_connection_t *(
    *dnxf_data_port_retimer_links_connection_get_f) (
    int unit,
    int link);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - RETIMER:
 * {
 */
/**
 * \brief Interface for port retimer data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_retimer_feature_get_f feature_get;
    /**
     * get table links_connection entry 
     */
    dnxf_data_port_retimer_links_connection_get_f links_connection_get;
    /**
     * get general info table about table (for example key size)links_connection info
     */
    dnxc_data_table_info_get_f links_connection_info_get;
} dnxf_data_if_port_retimer_t;

/*
 * }
 */

/*
 * SUBMODULE  - FEATURES:
 * Per devices features
 * {
 */
/*
 * Table value structure
 */
/*
 * Feature enum
 */
/**
 * \brief 
 * Submodule features
 */
typedef enum
{
    dnxf_data_port_features_isolation_needed_before_disable,

    /**
     * Must be last one!
     */
    _dnxf_data_port_features_feature_nof
} dnxf_data_port_features_feature_e;

/*
 * Submodule functions typedefs
 */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
typedef int(
    *dnxf_data_port_features_feature_get_f) (
    int unit,
    dnxf_data_port_features_feature_e feature);

/*
 * SUBMODULE INTERFACE DNXF_DATA_IF_PORT - FEATURES:
 * {
 */
/**
 * \brief Interface for port features data
 */
typedef struct
{
    /**
     * get submodule feature - disabled/enabled
     */
    dnxf_data_port_features_feature_get_f feature_get;
} dnxf_data_if_port_features_t;

/*
 * }
 */

/*
 * MODULE INTERFACE DNXF_DATA_IF_PORT:
 * {
 */
/**
 * \brief Interface for port data
 */
typedef struct
{
    /**
     * Interface for port general data
     */
    dnxf_data_if_port_general_t general;
    /**
     * Interface for port stat data
     */
    dnxf_data_if_port_stat_t stat;
    /**
     * Interface for port static_add data
     */
    dnxf_data_if_port_static_add_t static_add;
    /**
     * Interface for port lane_map data
     */
    dnxf_data_if_port_lane_map_t lane_map;
    /**
     * Interface for port pll data
     */
    dnxf_data_if_port_pll_t pll;
    /**
     * Interface for port synce data
     */
    dnxf_data_if_port_synce_t synce;
    /**
     * Interface for port retimer data
     */
    dnxf_data_if_port_retimer_t retimer;
    /**
     * Interface for port features data
     */
    dnxf_data_if_port_features_t features;
} dnxf_data_if_port_t;

/*
 * }
 */
/*
 * Extern:
 * {
 */
/**
 * \brief
 * Module structured interface - used to get the required data stored in dnx data
 */
extern dnxf_data_if_port_t dnxf_data_port;
/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_PORT_H_*/
/* *INDENT-ON* */
