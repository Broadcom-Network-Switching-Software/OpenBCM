/** \file dnxf_data_internal_fabric.h
 * 
 * MODULE DEVICE DATA - DNXF_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNXF_DATA_INTERNAL_FABRIC_H_
/*{*/
#define _DNXF_DATA_INTERNAL_FABRIC_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_internal.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_fabric.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnxf_data_fabric_submodule_general,
    dnxf_data_fabric_submodule_pipes,
    dnxf_data_fabric_submodule_multicast,
    dnxf_data_fabric_submodule_fifos,
    dnxf_data_fabric_submodule_congestion,
    dnxf_data_fabric_submodule_cell,
    dnxf_data_fabric_submodule_topology,
    dnxf_data_fabric_submodule_gpd,
    dnxf_data_fabric_submodule_reachability,
    dnxf_data_fabric_submodule_hw_snake,
    dnxf_data_fabric_submodule_system_upgrade,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_submodule_nof
} dnxf_data_fabric_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GENERAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_general_feature_get(
    int unit,
    dnxf_data_fabric_general_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_general_define_max_nof_pipes,
    dnxf_data_fabric_general_define_device_mode,
    dnxf_data_fabric_general_define_local_routing_enable_uc,
    dnxf_data_fabric_general_define_local_routing_enable_mc,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_general_define_nof
} dnxf_data_fabric_general_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_pipes
 * Module - 'fabric', Submodule - 'general', data - 'max_nof_pipes'
 * The maximum number of pipes that the device supports.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_pipes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_general_max_nof_pipes_get(
    int unit);

/**
 * \brief returns numeric data of device_mode
 * Module - 'fabric', Submodule - 'general', data - 'device_mode'
 * Sets the device operational mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_general_device_mode_get(
    int unit);

/**
 * \brief returns numeric data of local_routing_enable_uc
 * Module - 'fabric', Submodule - 'general', data - 'local_routing_enable_uc'
 * Enables unicast local routing from FE1 to FE3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     local_routing_enable_uc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_general_local_routing_enable_uc_get(
    int unit);

/**
 * \brief returns numeric data of local_routing_enable_mc
 * Module - 'fabric', Submodule - 'general', data - 'local_routing_enable_mc'
 * Enables multicast local routing from FE1 to FE3.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     local_routing_enable_mc - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_general_local_routing_enable_mc_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_general_table_nof
} dnxf_data_fabric_general_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE PIPES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_pipes_feature_get(
    int unit,
    dnxf_data_fabric_pipes_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_pipes_define_max_nof_pipes,
    dnxf_data_fabric_pipes_define_nof_valid_mapping_options,
    dnxf_data_fabric_pipes_define_nof_pipes,
    dnxf_data_fabric_pipes_define_system_contains_multiple_pipe_device,
    dnxf_data_fabric_pipes_define_system_tdm_priority,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_pipes_define_nof
} dnxf_data_fabric_pipes_define_e;

/* Get Data */
/**
 * \brief returns define data of max_nof_pipes
 * Module - 'fabric', Submodule - 'pipes', data - 'max_nof_pipes'
 * Max number of pipes supported by the device
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_nof_pipes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_pipes_max_nof_pipes_get(
    int unit);

/**
 * \brief returns numeric data of nof_valid_mapping_options
 * Module - 'fabric', Submodule - 'pipes', data - 'nof_valid_mapping_options'
 * Number of all valid cast/priority to pipe mapping options 
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_valid_mapping_options - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_pipes_nof_valid_mapping_options_get(
    int unit);

/**
 * \brief returns numeric data of nof_pipes
 * Module - 'fabric', Submodule - 'pipes', data - 'nof_pipes'
 * Configure number of fabric pipes.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pipes - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_pipes_nof_pipes_get(
    int unit);

/**
 * \brief returns numeric data of system_contains_multiple_pipe_device
 * Module - 'fabric', Submodule - 'pipes', data - 'system_contains_multiple_pipe_device'
 * Determines if there is a multiple pipe device in the system
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_contains_multiple_pipe_device - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_pipes_system_contains_multiple_pipe_device_get(
    int unit);

/**
 * \brief returns numeric data of system_tdm_priority
 * Module - 'fabric', Submodule - 'pipes', data - 'system_tdm_priority'
 * Mark a CGM fabric priority as TDM
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_tdm_priority - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_pipes_system_tdm_priority_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_fabric_pipes_table_map,
    dnxf_data_fabric_pipes_table_valid_map_config,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_pipes_table_nof
} dnxf_data_fabric_pipes_table_e;

/* Get Data */
/**
 * \brief get table map entry 
 * map traffic cast X priority to fabric pipe
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map - returns the relevant entry values grouped in struct - see dnxf_data_fabric_pipes_map_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_fabric_pipes_map_t * dnxf_data_fabric_pipes_map_get(
    int unit);

/**
 * \brief get table valid_map_config entry 
 * pipes map valid configurations
 * 
 * \param [in] unit - unit #
 * \param [in] mapping_option_idx - The configuration running number
 * 
 * \return
 *     valid_map_config - returns the relevant entry values grouped in struct - see dnxf_data_fabric_pipes_valid_map_config_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_fabric_pipes_valid_map_config_t * dnxf_data_fabric_pipes_valid_map_config_get(
    int unit,
    int mapping_option_idx);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'fabric', Submodule - 'pipes', table - 'map'
 * map traffic cast X priority to fabric pipe
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_pipes_map_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'fabric', Submodule - 'pipes', table - 'valid_map_config'
 * pipes map valid configurations
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_pipes_valid_map_config_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)map info
 * map traffic cast X priority to fabric pipe
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     map - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_fabric_pipes_map_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)valid_map_config info
 * pipes map valid configurations
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     valid_map_config - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_fabric_pipes_valid_map_config_info_get(
    int unit);

/*
 * SUBMODULE MULTICAST:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_multicast_feature_get(
    int unit,
    dnxf_data_fabric_multicast_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_multicast_define_table_row_size_in_uint32,
    dnxf_data_fabric_multicast_define_id_range,
    dnxf_data_fabric_multicast_define_mode,
    dnxf_data_fabric_multicast_define_priority_map_enable,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_multicast_define_nof
} dnxf_data_fabric_multicast_define_e;

/* Get Data */
/**
 * \brief returns define data of table_row_size_in_uint32
 * Module - 'fabric', Submodule - 'multicast', data - 'table_row_size_in_uint32'
 * Multicast table row size in UINT32s.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_row_size_in_uint32 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_multicast_table_row_size_in_uint32_get(
    int unit);

/**
 * \brief returns numeric data of id_range
 * Module - 'fabric', Submodule - 'multicast', data - 'id_range'
 * Specifies the MC IDs range.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     id_range - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_multicast_id_range_get(
    int unit);

/**
 * \brief returns numeric data of mode
 * Module - 'fabric', Submodule - 'multicast', data - 'mode'
 * Specifies the MC mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_multicast_mode_get(
    int unit);

/**
 * \brief returns numeric data of priority_map_enable
 * Module - 'fabric', Submodule - 'multicast', data - 'priority_map_enable'
 * Enable mapping internal multicast priority according to MC-ID ranges.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     priority_map_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_multicast_priority_map_enable_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_multicast_table_nof
} dnxf_data_fabric_multicast_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE FIFOS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_fifos_feature_get(
    int unit,
    dnxf_data_fabric_fifos_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_fifos_define_granularity,
    dnxf_data_fabric_fifos_define_min_depth,
    dnxf_data_fabric_fifos_define_max_unused_resources,
    dnxf_data_fabric_fifos_define_rx_resources,
    dnxf_data_fabric_fifos_define_mid_resources,
    dnxf_data_fabric_fifos_define_tx_resources,
    dnxf_data_fabric_fifos_define_rx_full_offset,
    dnxf_data_fabric_fifos_define_mid_full_offset,
    dnxf_data_fabric_fifos_define_tx_full_offset,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_fifos_define_nof
} dnxf_data_fabric_fifos_define_e;

/* Get Data */
/**
 * \brief returns define data of granularity
 * Module - 'fabric', Submodule - 'fifos', data - 'granularity'
 * FIFO granularity
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     granularity - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_granularity_get(
    int unit);

/**
 * \brief returns define data of min_depth
 * Module - 'fabric', Submodule - 'fifos', data - 'min_depth'
 * Minimal FIFO depth
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     min_depth - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_min_depth_get(
    int unit);

/**
 * \brief returns define data of max_unused_resources
 * Module - 'fabric', Submodule - 'fifos', data - 'max_unused_resources'
 * Maximal unused resources allowed per FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_unused_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_max_unused_resources_get(
    int unit);

/**
 * \brief returns define data of rx_resources
 * Module - 'fabric', Submodule - 'fifos', data - 'rx_resources'
 * Maximal Available Resources per RX FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_rx_resources_get(
    int unit);

/**
 * \brief returns define data of mid_resources
 * Module - 'fabric', Submodule - 'fifos', data - 'mid_resources'
 * Maximal Available Resources per MIDDLE FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mid_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_mid_resources_get(
    int unit);

/**
 * \brief returns define data of tx_resources
 * Module - 'fabric', Submodule - 'fifos', data - 'tx_resources'
 * Maximal Available Resources per TX FIFO
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_resources - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_tx_resources_get(
    int unit);

/**
 * \brief returns define data of rx_full_offset
 * Module - 'fabric', Submodule - 'fifos', data - 'rx_full_offset'
 * RX FULL-to-DEPTH offset
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_full_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_rx_full_offset_get(
    int unit);

/**
 * \brief returns define data of mid_full_offset
 * Module - 'fabric', Submodule - 'fifos', data - 'mid_full_offset'
 * MID FULL-to-DEPTH offset
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mid_full_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_mid_full_offset_get(
    int unit);

/**
 * \brief returns define data of tx_full_offset
 * Module - 'fabric', Submodule - 'fifos', data - 'tx_full_offset'
 * TX FULL-to-DEPTH offset
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_full_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_fifos_tx_full_offset_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_fabric_fifos_table_rx_depth_per_pipe,
    dnxf_data_fabric_fifos_table_mid_depth_per_pipe,
    dnxf_data_fabric_fifos_table_tx_depth_per_pipe,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_fifos_table_nof
} dnxf_data_fabric_fifos_table_e;

/* Get Data */
/**
 * \brief get table rx_depth_per_pipe entry 
 * RX FIFO depth per pipe
 * 
 * \param [in] unit - unit #
 * \param [in] pipe_id - Pipe ID.
 * 
 * \return
 *     rx_depth_per_pipe - returns the relevant entry values grouped in struct - see dnxf_data_fabric_fifos_rx_depth_per_pipe_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_fabric_fifos_rx_depth_per_pipe_t * dnxf_data_fabric_fifos_rx_depth_per_pipe_get(
    int unit,
    int pipe_id);

/**
 * \brief get table mid_depth_per_pipe entry 
 * Middle FIFO depth per pipe
 * 
 * \param [in] unit - unit #
 * \param [in] pipe_id - Pipe ID.
 * 
 * \return
 *     mid_depth_per_pipe - returns the relevant entry values grouped in struct - see dnxf_data_fabric_fifos_mid_depth_per_pipe_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_fabric_fifos_mid_depth_per_pipe_t * dnxf_data_fabric_fifos_mid_depth_per_pipe_get(
    int unit,
    int pipe_id);

/**
 * \brief get table tx_depth_per_pipe entry 
 * TX FIFO depth per pipe
 * 
 * \param [in] unit - unit #
 * \param [in] pipe_id - Pipe ID.
 * 
 * \return
 *     tx_depth_per_pipe - returns the relevant entry values grouped in struct - see dnxf_data_fabric_fifos_tx_depth_per_pipe_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_fabric_fifos_tx_depth_per_pipe_t * dnxf_data_fabric_fifos_tx_depth_per_pipe_get(
    int unit,
    int pipe_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'fabric', Submodule - 'fifos', table - 'rx_depth_per_pipe'
 * RX FIFO depth per pipe
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_fifos_rx_depth_per_pipe_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'fabric', Submodule - 'fifos', table - 'mid_depth_per_pipe'
 * Middle FIFO depth per pipe
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_fifos_mid_depth_per_pipe_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'fabric', Submodule - 'fifos', table - 'tx_depth_per_pipe'
 * TX FIFO depth per pipe
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_fifos_tx_depth_per_pipe_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)rx_depth_per_pipe info
 * RX FIFO depth per pipe
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_depth_per_pipe - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_fabric_fifos_rx_depth_per_pipe_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)mid_depth_per_pipe info
 * Middle FIFO depth per pipe
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mid_depth_per_pipe - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_fabric_fifos_mid_depth_per_pipe_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)tx_depth_per_pipe info
 * TX FIFO depth per pipe
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tx_depth_per_pipe - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_fabric_fifos_tx_depth_per_pipe_info_get(
    int unit);

/*
 * SUBMODULE CONGESTION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_congestion_feature_get(
    int unit,
    dnxf_data_fabric_congestion_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_congestion_define_nof_profiles,
    dnxf_data_fabric_congestion_define_nof_threshold_priorities,
    dnxf_data_fabric_congestion_define_nof_threshold_levels,
    dnxf_data_fabric_congestion_define_nof_threshold_index_dimensions,
    dnxf_data_fabric_congestion_define_nof_thresholds,
    dnxf_data_fabric_congestion_define_nof_dfl_banks,
    dnxf_data_fabric_congestion_define_nof_dfl_sub_banks,
    dnxf_data_fabric_congestion_define_nof_dfl_bank_entries,
    dnxf_data_fabric_congestion_define_nof_rci_bits,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_congestion_define_nof
} dnxf_data_fabric_congestion_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_profiles
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_profiles'
 * Number of CGM profiles.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_profiles - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_profiles_get(
    int unit);

/**
 * \brief returns define data of nof_threshold_priorities
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_threshold_priorities'
 * Number of CGM threhold priorities.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_threshold_priorities - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_threshold_priorities_get(
    int unit);

/**
 * \brief returns define data of nof_threshold_levels
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_threshold_levels'
 * Number of CGM threhold levels.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_threshold_levels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_threshold_levels_get(
    int unit);

/**
 * \brief returns define data of nof_threshold_index_dimensions
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_threshold_index_dimensions'
 * Number of threshold index dimendions used to indicate the application of the threshold value.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_threshold_index_dimensions - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_threshold_index_dimensions_get(
    int unit);

/**
 * \brief returns define data of nof_thresholds
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_thresholds'
 * Number of CGM thresholds for each device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_thresholds - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_thresholds_get(
    int unit);

/**
 * \brief returns define data of nof_dfl_banks
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_dfl_banks'
 * Number of DFL banks.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dfl_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_dfl_banks_get(
    int unit);

/**
 * \brief returns define data of nof_dfl_sub_banks
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_dfl_sub_banks'
 * Number of sub-banks for each DFL bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dfl_sub_banks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_dfl_sub_banks_get(
    int unit);

/**
 * \brief returns define data of nof_dfl_bank_entries
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_dfl_bank_entries'
 * Number of overall entries in each DFL bank.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dfl_bank_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_dfl_bank_entries_get(
    int unit);

/**
 * \brief returns define data of nof_rci_bits
 * Module - 'fabric', Submodule - 'congestion', data - 'nof_rci_bits'
 * Number of RCI indication bits.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_rci_bits - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_congestion_nof_rci_bits_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_fabric_congestion_table_thresholds_info,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_congestion_table_nof
} dnxf_data_fabric_congestion_table_e;

/* Get Data */
/**
 * \brief get table thresholds_info entry 
 * Congestion manager thresholds information.
 * 
 * \param [in] unit - unit #
 * \param [in] threshold_id - The name of the threshold follwing the convention _SHR_FABRIC[Stage][Name][Index]th.
 * 
 * \return
 *     thresholds_info - returns the relevant entry values grouped in struct - see dnxf_data_fabric_congestion_thresholds_info_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_fabric_congestion_thresholds_info_t * dnxf_data_fabric_congestion_thresholds_info_get(
    int unit,
    int threshold_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'fabric', Submodule - 'congestion', table - 'thresholds_info'
 * Congestion manager thresholds information.
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_congestion_thresholds_info_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)thresholds_info info
 * Congestion manager thresholds information.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     thresholds_info - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_fabric_congestion_thresholds_info_info_get(
    int unit);

/*
 * SUBMODULE CELL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_cell_feature_get(
    int unit,
    dnxf_data_fabric_cell_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_cell_define_fifo_dma_fabric_cell_nof_entries_per_cell,
    dnxf_data_fabric_cell_define_rx_cpu_cell_max_payload_size,
    dnxf_data_fabric_cell_define_rx_max_nof_cpu_buffers,
    dnxf_data_fabric_cell_define_source_routed_cells_header_offset,
    dnxf_data_fabric_cell_define_fifo_dma_nof_channels,
    dnxf_data_fabric_cell_define_fifo_dma_entry_size,
    dnxf_data_fabric_cell_define_fifo_dma_max_nof_entries,
    dnxf_data_fabric_cell_define_fifo_dma_min_nof_entries,
    dnxf_data_fabric_cell_define_fifo_dma_enable,
    dnxf_data_fabric_cell_define_fifo_dma_buffer_size,
    dnxf_data_fabric_cell_define_fifo_dma_threshold,
    dnxf_data_fabric_cell_define_fifo_dma_timeout,
    dnxf_data_fabric_cell_define_rx_thread_pri,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_cell_define_nof
} dnxf_data_fabric_cell_define_e;

/* Get Data */
/**
 * \brief returns define data of fifo_dma_fabric_cell_nof_entries_per_cell
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_fabric_cell_nof_entries_per_cell'
 * Number of entries per one cell (chunk).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_fabric_cell_nof_entries_per_cell - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_fabric_cell_nof_entries_per_cell_get(
    int unit);

/**
 * \brief returns define data of rx_cpu_cell_max_payload_size
 * Module - 'fabric', Submodule - 'cell', data - 'rx_cpu_cell_max_payload_size'
 * Payload size of data cpu cells (bits).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_cpu_cell_max_payload_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_rx_cpu_cell_max_payload_size_get(
    int unit);

/**
 * \brief returns define data of rx_max_nof_cpu_buffers
 * Module - 'fabric', Submodule - 'cell', data - 'rx_max_nof_cpu_buffers'
 * Number of rx CPU buffers.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_max_nof_cpu_buffers - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_rx_max_nof_cpu_buffers_get(
    int unit);

/**
 * \brief returns define data of source_routed_cells_header_offset
 * Module - 'fabric', Submodule - 'cell', data - 'source_routed_cells_header_offset'
 * Offset in the header fields of sr cells.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     source_routed_cells_header_offset - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_source_routed_cells_header_offset_get(
    int unit);

/**
 * \brief returns define data of fifo_dma_nof_channels
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_nof_channels'
 * Number of channels used for fifo DMA.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_nof_channels - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_nof_channels_get(
    int unit);

/**
 * \brief returns define data of fifo_dma_entry_size
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_entry_size'
 * DMA entry size in bytes
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_entry_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_entry_size_get(
    int unit);

/**
 * \brief returns define data of fifo_dma_max_nof_entries
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_max_nof_entries'
 * MAX number of entries in DMA buffer.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_max_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_max_nof_entries_get(
    int unit);

/**
 * \brief returns define data of fifo_dma_min_nof_entries
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_min_nof_entries'
 * MIN number of entries in DMA buffer.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_min_nof_entries - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_min_nof_entries_get(
    int unit);

/**
 * \brief returns numeric data of fifo_dma_enable
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_enable'
 * Deterimins if to use or not to use FIFO DMA.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_enable_get(
    int unit);

/**
 * \brief returns numeric data of fifo_dma_buffer_size
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_buffer_size'
 * Size of the host memory stored allocated by the CPU.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_buffer_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_buffer_size_get(
    int unit);

/**
 * \brief returns numeric data of fifo_dma_threshold
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_threshold'
 * The number of writes by the DMA until a threshold based interrupt is triggered
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_threshold - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_threshold_get(
    int unit);

/**
 * \brief returns numeric data of fifo_dma_timeout
 * Module - 'fabric', Submodule - 'cell', data - 'fifo_dma_timeout'
 * The amount of time in microseconds that passes from the first write by the DMA until a timeout based interrupt is triggered.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fifo_dma_timeout - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_fifo_dma_timeout_get(
    int unit);

/**
 * \brief returns numeric data of rx_thread_pri
 * Module - 'fabric', Submodule - 'cell', data - 'rx_thread_pri'
 * Rx thread priority.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rx_thread_pri - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_cell_rx_thread_pri_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_cell_table_nof
} dnxf_data_fabric_cell_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE TOPOLOGY:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_topology_feature_get(
    int unit,
    dnxf_data_fabric_topology_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_topology_define_max_link_score,
    dnxf_data_fabric_topology_define_nof_system_modid,
    dnxf_data_fabric_topology_define_nof_local_modid,
    dnxf_data_fabric_topology_define_nof_local_modid_fe13,
    dnxf_data_fabric_topology_define_load_balancing_mode,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_topology_define_nof
} dnxf_data_fabric_topology_define_e;

/* Get Data */
/**
 * \brief returns define data of max_link_score
 * Module - 'fabric', Submodule - 'topology', data - 'max_link_score'
 * Max link score.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_link_score - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_topology_max_link_score_get(
    int unit);

/**
 * \brief returns define data of nof_system_modid
 * Module - 'fabric', Submodule - 'topology', data - 'nof_system_modid'
 * Number of system modids.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_system_modid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_topology_nof_system_modid_get(
    int unit);

/**
 * \brief returns define data of nof_local_modid
 * Module - 'fabric', Submodule - 'topology', data - 'nof_local_modid'
 * Number of local modids.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_local_modid - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_topology_nof_local_modid_get(
    int unit);

/**
 * \brief returns define data of nof_local_modid_fe13
 * Module - 'fabric', Submodule - 'topology', data - 'nof_local_modid_fe13'
 * Number of local modids in FE13 mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_local_modid_fe13 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_topology_nof_local_modid_fe13_get(
    int unit);

/**
 * \brief returns numeric data of load_balancing_mode
 * Module - 'fabric', Submodule - 'topology', data - 'load_balancing_mode'
 * Sets the load balancing method.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     load_balancing_mode - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_topology_load_balancing_mode_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_topology_table_nof
} dnxf_data_fabric_topology_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE GPD:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_gpd_feature_get(
    int unit,
    dnxf_data_fabric_gpd_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_gpd_define_in_time,
    dnxf_data_fabric_gpd_define_out_time,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_gpd_define_nof
} dnxf_data_fabric_gpd_define_e;

/* Get Data */
/**
 * \brief returns define data of in_time
 * Module - 'fabric', Submodule - 'gpd', data - 'in_time'
 * Time interval between 2 GPD cells to enter GPD mode (usec).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     in_time - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_gpd_in_time_get(
    int unit);

/**
 * \brief returns define data of out_time
 * Module - 'fabric', Submodule - 'gpd', data - 'out_time'
 * Time to get out of GPD mode if no GPD cells arrived (msec).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     out_time - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_gpd_out_time_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_gpd_table_nof
} dnxf_data_fabric_gpd_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE REACHABILITY:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_reachability_feature_get(
    int unit,
    dnxf_data_fabric_reachability_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_reachability_define_table_row_size_in_uint32,
    dnxf_data_fabric_reachability_define_table_group_size,
    dnxf_data_fabric_reachability_define_rmgr_units,
    dnxf_data_fabric_reachability_define_rmgr_nof_links,
    dnxf_data_fabric_reachability_define_gpd_rmgr_time_factor,
    dnxf_data_fabric_reachability_define_gen_rate_link_delta,
    dnxf_data_fabric_reachability_define_gen_rate_full_cycle,
    dnxf_data_fabric_reachability_define_gpd_gen_rate_full_cycle,
    dnxf_data_fabric_reachability_define_watchdog_rate,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_reachability_define_nof
} dnxf_data_fabric_reachability_define_e;

/* Get Data */
/**
 * \brief returns define data of table_row_size_in_uint32
 * Module - 'fabric', Submodule - 'reachability', data - 'table_row_size_in_uint32'
 * RTP table Row Size in UINT32s.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_row_size_in_uint32 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_table_row_size_in_uint32_get(
    int unit);

/**
 * \brief returns define data of table_group_size
 * Module - 'fabric', Submodule - 'reachability', data - 'table_group_size'
 * RMHMT Group Size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_group_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_table_group_size_get(
    int unit);

/**
 * \brief returns define data of rmgr_units
 * Module - 'fabric', Submodule - 'reachability', data - 'rmgr_units'
 * RTP RMGR resolution.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rmgr_units - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_rmgr_units_get(
    int unit);

/**
 * \brief returns define data of rmgr_nof_links
 * Module - 'fabric', Submodule - 'reachability', data - 'rmgr_nof_links'
 * RTP RMGR number of links that should be taken into account.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     rmgr_nof_links - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_rmgr_nof_links_get(
    int unit);

/**
 * \brief returns define data of gpd_rmgr_time_factor
 * Module - 'fabric', Submodule - 'reachability', data - 'gpd_rmgr_time_factor'
 * Factor waiting for the GPD to spread in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     gpd_rmgr_time_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_gpd_rmgr_time_factor_get(
    int unit);

/**
 * \brief returns define data of gen_rate_link_delta
 * Module - 'fabric', Submodule - 'reachability', data - 'gen_rate_link_delta'
 * Reachability gen rate between links.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     gen_rate_link_delta - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_gen_rate_link_delta_get(
    int unit);

/**
 * \brief returns define data of gen_rate_full_cycle
 * Module - 'fabric', Submodule - 'reachability', data - 'gen_rate_full_cycle'
 * RTP Reachability gen rate full cycle.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     gen_rate_full_cycle - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_gen_rate_full_cycle_get(
    int unit);

/**
 * \brief returns define data of gpd_gen_rate_full_cycle
 * Module - 'fabric', Submodule - 'reachability', data - 'gpd_gen_rate_full_cycle'
 * RTP GPD Reachability gen rate full cycle (nsec).
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     gpd_gen_rate_full_cycle - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_gpd_gen_rate_full_cycle_get(
    int unit);

/**
 * \brief returns define data of watchdog_rate
 * Module - 'fabric', Submodule - 'reachability', data - 'watchdog_rate'
 * RTP Reachability watchdog rate.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     watchdog_rate - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_reachability_watchdog_rate_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_reachability_table_nof
} dnxf_data_fabric_reachability_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE HW_SNAKE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_hw_snake_feature_get(
    int unit,
    dnxf_data_fabric_hw_snake_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_hw_snake_define_nof
} dnxf_data_fabric_hw_snake_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_hw_snake_table_nof
} dnxf_data_fabric_hw_snake_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE SYSTEM_UPGRADE:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_fabric_system_upgrade_feature_get(
    int unit,
    dnxf_data_fabric_system_upgrade_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_fabric_system_upgrade_define_max_master_id,
    dnxf_data_fabric_system_upgrade_define_param_0,
    dnxf_data_fabric_system_upgrade_define_param_1,
    dnxf_data_fabric_system_upgrade_define_param_2,
    dnxf_data_fabric_system_upgrade_define_param_3,
    dnxf_data_fabric_system_upgrade_define_param_4,
    dnxf_data_fabric_system_upgrade_define_param_5,
    dnxf_data_fabric_system_upgrade_define_param_7,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_system_upgrade_define_nof
} dnxf_data_fabric_system_upgrade_define_e;

/* Get Data */
/**
 * \brief returns define data of max_master_id
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'max_master_id'
 * fabric system upgrade maximum master id
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     max_master_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_max_master_id_get(
    int unit);

/**
 * \brief returns define data of param_0
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'param_0'
 * fabric system upgrade param 0
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     param_0 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_param_0_get(
    int unit);

/**
 * \brief returns define data of param_1
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'param_1'
 * fabric system upgrade param 1
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     param_1 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_param_1_get(
    int unit);

/**
 * \brief returns define data of param_2
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'param_2'
 * fabric system upgrade param 2
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     param_2 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_param_2_get(
    int unit);

/**
 * \brief returns define data of param_3
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'param_3'
 * fabric system upgrade param 3
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     param_3 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_param_3_get(
    int unit);

/**
 * \brief returns define data of param_4
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'param_4'
 * fabric system upgrade param 4
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     param_4 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_param_4_get(
    int unit);

/**
 * \brief returns define data of param_5
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'param_5'
 * fabric system upgrade param 5
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     param_5 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_param_5_get(
    int unit);

/**
 * \brief returns define data of param_7
 * Module - 'fabric', Submodule - 'system_upgrade', data - 'param_7'
 * fabric system upgrade param 7
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     param_7 - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_fabric_system_upgrade_param_7_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_fabric_system_upgrade_table_target,

    /**
     * Must be last one!
     */
    _dnxf_data_fabric_system_upgrade_table_nof
} dnxf_data_fabric_system_upgrade_table_e;

/* Get Data */
/**
 * \brief get table target entry 
 * fabric system upgrade target values
 * 
 * \param [in] unit - unit #
 * \param [in] target - target
 * 
 * \return
 *     target - returns the relevant entry values grouped in struct - see dnxf_data_fabric_system_upgrade_target_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_fabric_system_upgrade_target_t * dnxf_data_fabric_system_upgrade_target_get(
    int unit,
    int target);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'fabric', Submodule - 'system_upgrade', table - 'target'
 * fabric system upgrade target values
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_system_upgrade_target_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)target info
 * fabric system upgrade target values
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     target - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_fabric_system_upgrade_target_info_get(
    int unit);

/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_fabric_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_INTERNAL_FABRIC_H_*/
/* *INDENT-ON* */
