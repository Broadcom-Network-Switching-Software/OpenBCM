/** \file dnxf_data_internal_device.h
 * 
 * MODULE DEVICE DATA - DNXF_DATA
 * 
 * Device Data
 * SW component that maintains per device data
 * For additional details about Device Data Component goto 'dnxc_data_mgmt.h'
 *        
 *     
 * 
 * AUTO-GENERATED BY AUTOCODER!
 * DO NOT EDIT THIS FILE!
 */
/* *INDENT-OFF* */
/*
 * This license is set out in https://raw.githubusercontent.com/Broadcom-Network-Switching-Software/OpenBCM/master/Legal/LICENSE file.
 * 
 * Copyright 2007-2021 Broadcom Inc. All rights reserved.
 */
#ifndef _DNXF_DATA_INTERNAL_DEVICE_H_
/*{*/
#define _DNXF_DATA_INTERNAL_DEVICE_H_
/*
 * INCLUDE FILES:
 * {
 */
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_internal.h>
#include <soc/dnxf/dnxf_data/auto_generated/dnxf_data_device.h>
/*
 * }
 */

/*!
* \brief This file is only used by DNX (JR2 family). Including it by
* software that is not specific to DNX is an error.
*/
#ifndef BCM_DNXF_SUPPORT
#error "This file is for use by DNX (JR2) family only!"
#endif

/*
 * TYPEDEFS:
 * {
 */
/**
 * \brief 
 * Submodule enum
 */
typedef enum
{
    dnxf_data_device_submodule_general,
    dnxf_data_device_submodule_access,
    dnxf_data_device_submodule_blocks,
    dnxf_data_device_submodule_interrupts,
    dnxf_data_device_submodule_custom_features,
    dnxf_data_device_submodule_properties,
    dnxf_data_device_submodule_ha,
    dnxf_data_device_submodule_emulation,

    /**
     * Must be last one!
     */
    _dnxf_data_device_submodule_nof
} dnxf_data_device_submodule_e;

/*
 * }
 */

/*
 * SUBMODULE GENERAL:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_general_feature_get(
    int unit,
    dnxf_data_device_general_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_general_define_nof_pvt_monitors,
    dnxf_data_device_general_define_pvt_base,
    dnxf_data_device_general_define_pvt_factor,
    dnxf_data_device_general_define_nof_cores,
    dnxf_data_device_general_define_hard_reset_disable,
    dnxf_data_device_general_define_core_clock_khz,
    dnxf_data_device_general_define_system_ref_core_clock_khz,
    dnxf_data_device_general_define_device_id,

    /**
     * Must be last one!
     */
    _dnxf_data_device_general_define_nof
} dnxf_data_device_general_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_pvt_monitors
 * Module - 'device', Submodule - 'general', data - 'nof_pvt_monitors'
 * Number of device PVT monitors
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_pvt_monitors - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_nof_pvt_monitors_get(
    int unit);

/**
 * \brief returns define data of pvt_base
 * Module - 'device', Submodule - 'general', data - 'pvt_base'
 * PVT base. Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_base - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_general_pvt_base_get(
    int unit);

/**
 * \brief returns define data of pvt_factor
 * Module - 'device', Submodule - 'general', data - 'pvt_factor'
 * PVT factor Used for correct calculation of the monitor readings
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     pvt_factor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_general_pvt_factor_get(
    int unit);

/**
 * \brief returns define data of nof_cores
 * Module - 'device', Submodule - 'general', data - 'nof_cores'
 * Number of cores in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_cores - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_nof_cores_get(
    int unit);

/**
 * \brief returns numeric data of hard_reset_disable
 * Module - 'device', Submodule - 'general', data - 'hard_reset_disable'
 * Init device without hard reset.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     hard_reset_disable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_hard_reset_disable_get(
    int unit);

/**
 * \brief returns numeric data of core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'core_clock_khz'
 * Specifies system core clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_core_clock_khz_get(
    int unit);

/**
 * \brief returns numeric data of system_ref_core_clock_khz
 * Module - 'device', Submodule - 'general', data - 'system_ref_core_clock_khz'
 * Specifies system reference clock speed in kHz.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     system_ref_core_clock_khz - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_system_ref_core_clock_khz_get(
    int unit);

/**
 * \brief returns numeric data of device_id
 * Module - 'device', Submodule - 'general', data - 'device_id'
 * BCM Device ID (8XXX)
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     device_id - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_general_device_id_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_general_table_nof
} dnxf_data_device_general_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE ACCESS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_access_feature_get(
    int unit,
    dnxf_data_device_access_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_access_define_table_dma_enable,
    dnxf_data_device_access_define_tdma_timeout_usec,
    dnxf_data_device_access_define_tdma_intr_enable,
    dnxf_data_device_access_define_tslam_dma_enable,
    dnxf_data_device_access_define_tslam_timeout_usec,
    dnxf_data_device_access_define_tslam_int_enable,
    dnxf_data_device_access_define_mdio_int_divisor,
    dnxf_data_device_access_define_mdio_ext_divisor,
    dnxf_data_device_access_define_mdio_int_div_out_delay,
    dnxf_data_device_access_define_mdio_ext_div_out_delay,
    dnxf_data_device_access_define_bist_enable,
    dnxf_data_device_access_define_sbus_dma_interval,
    dnxf_data_device_access_define_sbus_dma_intr_enable,
    dnxf_data_device_access_define_mem_clear_chunk_size,

    /**
     * Must be last one!
     */
    _dnxf_data_device_access_define_nof
} dnxf_data_device_access_define_e;

/* Get Data */
/**
 * \brief returns numeric data of table_dma_enable
 * Module - 'device', Submodule - 'access', data - 'table_dma_enable'
 * Enable/disable table DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     table_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_table_dma_enable_get(
    int unit);

/**
 * \brief returns numeric data of tdma_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tdma_timeout_usec'
 * Table DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tdma_timeout_usec_get(
    int unit);

/**
 * \brief returns numeric data of tdma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'tdma_intr_enable'
 * Table DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tdma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tdma_intr_enable_get(
    int unit);

/**
 * \brief returns numeric data of tslam_dma_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_dma_enable'
 * Enable/disable tslam DMA operations.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_dma_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tslam_dma_enable_get(
    int unit);

/**
 * \brief returns numeric data of tslam_timeout_usec
 * Module - 'device', Submodule - 'access', data - 'tslam_timeout_usec'
 * Tslam DMA operation timeout.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_timeout_usec - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tslam_timeout_usec_get(
    int unit);

/**
 * \brief returns numeric data of tslam_int_enable
 * Module - 'device', Submodule - 'access', data - 'tslam_int_enable'
 * Tslam DMA done is interrupt driven or by polling.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     tslam_int_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_tslam_int_enable_get(
    int unit);

/**
 * \brief returns numeric data of mdio_int_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_int_divisor'
 * mdio_int_divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_int_divisor_get(
    int unit);

/**
 * \brief returns numeric data of mdio_ext_divisor
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_divisor'
 * mdio_ext_divisor.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_divisor - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_ext_divisor_get(
    int unit);

/**
 * \brief returns numeric data of mdio_int_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_int_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for internal divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_int_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_int_div_out_delay_get(
    int unit);

/**
 * \brief returns numeric data of mdio_ext_div_out_delay
 * Module - 'device', Submodule - 'access', data - 'mdio_ext_div_out_delay'
 * number of clock delay between the rising edge of MDC and the starting data of MDIO for external divisor
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mdio_ext_div_out_delay - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mdio_ext_div_out_delay_get(
    int unit);

/**
 * \brief returns numeric data of bist_enable
 * Module - 'device', Submodule - 'access', data - 'bist_enable'
 * Determines if to run Memory Built-In Self-Test (MBIST) of internal memory (tables) during startup.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     bist_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_bist_enable_get(
    int unit);

/**
 * \brief returns numeric data of sbus_dma_interval
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_interval'
 * sbus DMA operation interval.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_interval - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_sbus_dma_interval_get(
    int unit);

/**
 * \brief returns numeric data of sbus_dma_intr_enable
 * Module - 'device', Submodule - 'access', data - 'sbus_dma_intr_enable'
 * sbus DMA interrupt enable.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sbus_dma_intr_enable - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_sbus_dma_intr_enable_get(
    int unit);

/**
 * \brief returns numeric data of mem_clear_chunk_size
 * Module - 'device', Submodule - 'access', data - 'mem_clear_chunk_size'
 * sbus DMA chunk size.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mem_clear_chunk_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_access_mem_clear_chunk_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_access_table_nof
} dnxf_data_device_access_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE BLOCKS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_blocks_feature_get(
    int unit,
    dnxf_data_device_blocks_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_blocks_define_nof_all_blocks,
    dnxf_data_device_blocks_define_nof_instances_fmac,
    dnxf_data_device_blocks_define_nof_links_in_fmac,
    dnxf_data_device_blocks_define_nof_instances_fsrd,
    dnxf_data_device_blocks_define_nof_instances_brdc_fsrd,
    dnxf_data_device_blocks_define_nof_instances_dch,
    dnxf_data_device_blocks_define_nof_links_in_dch,
    dnxf_data_device_blocks_define_nof_dch_link_groups,
    dnxf_data_device_blocks_define_nof_instances_cch,
    dnxf_data_device_blocks_define_nof_links_in_cch,
    dnxf_data_device_blocks_define_nof_links_in_dcq,
    dnxf_data_device_blocks_define_nof_instances_rtp,
    dnxf_data_device_blocks_define_nof_instances_occg,
    dnxf_data_device_blocks_define_nof_instances_eci,
    dnxf_data_device_blocks_define_nof_instances_cmic,
    dnxf_data_device_blocks_define_nof_instances_mesh_topology,
    dnxf_data_device_blocks_define_nof_instances_brdc_fmach,
    dnxf_data_device_blocks_define_nof_instances_brdc_fmacl,
    dnxf_data_device_blocks_define_nof_instances_lcm,
    dnxf_data_device_blocks_define_nof_instances_mct,
    dnxf_data_device_blocks_define_nof_instances_qrh,
    dnxf_data_device_blocks_define_nof_instances_dcml,
    dnxf_data_device_blocks_define_nof_links_in_dcml,
    dnxf_data_device_blocks_define_nof_links_in_lcm,
    dnxf_data_device_blocks_define_nof_links_in_qrh,
    dnxf_data_device_blocks_define_nof_dtm_fifos,
    dnxf_data_device_blocks_define_nof_links_in_fsrd,
    dnxf_data_device_blocks_define_nof_links_in_phy_core,
    dnxf_data_device_blocks_define_nof_fmacs_in_fsrd,

    /**
     * Must be last one!
     */
    _dnxf_data_device_blocks_define_nof
} dnxf_data_device_blocks_define_e;

/* Get Data */
/**
 * \brief returns define data of nof_all_blocks
 * Module - 'device', Submodule - 'blocks', data - 'nof_all_blocks'
 * Number of block instances in the device.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_all_blocks - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_all_blocks_get(
    int unit);

/**
 * \brief returns define data of nof_instances_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fmac'
 * Number of FMAC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_fmac_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_fmac
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fmac'
 * Number of links for each FMAC block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fmac - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_fmac_get(
    int unit);

/**
 * \brief returns define data of nof_instances_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_fsrd'
 * Number of FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_fsrd_get(
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fsrd'
 * Number of BRoaDCast FSRD instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_brdc_fsrd_get(
    int unit);

/**
 * \brief returns define data of nof_instances_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dch'
 * Number of DCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_dch_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_dch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dch'
 * Number of links for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_dch_get(
    int unit);

/**
 * \brief returns define data of nof_dch_link_groups
 * Module - 'device', Submodule - 'blocks', data - 'nof_dch_link_groups'
 * Number of link groups for each DCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dch_link_groups - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_dch_link_groups_get(
    int unit);

/**
 * \brief returns define data of nof_instances_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cch'
 * Number of CCH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_cch_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_cch
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_cch'
 * Number of links for each CCH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_cch - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_cch_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_dcq
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcq'
 * Number of links for each DCQ block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcq - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_dcq_get(
    int unit);

/**
 * \brief returns define data of nof_instances_rtp
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_rtp'
 * Number of RTP instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_rtp - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_rtp_get(
    int unit);

/**
 * \brief returns define data of nof_instances_occg
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_occg'
 * Number of OCCG instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_occg - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_occg_get(
    int unit);

/**
 * \brief returns define data of nof_instances_eci
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_eci'
 * Number of ECI instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_eci - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_eci_get(
    int unit);

/**
 * \brief returns define data of nof_instances_cmic
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_cmic'
 * Number of CMIC instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_cmic - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_cmic_get(
    int unit);

/**
 * \brief returns define data of nof_instances_mesh_topology
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mesh_topology'
 * Number of MESH Topology instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mesh_topology - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_mesh_topology_get(
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmach
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmach'
 * Number of BRoaDCast FMACH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmach - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_brdc_fmach_get(
    int unit);

/**
 * \brief returns define data of nof_instances_brdc_fmacl
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_brdc_fmacl'
 * Number of BRoaDCast FMACL instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_brdc_fmacl - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_brdc_fmacl_get(
    int unit);

/**
 * \brief returns define data of nof_instances_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_lcm'
 * Number of LCM instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_lcm_get(
    int unit);

/**
 * \brief returns define data of nof_instances_mct
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_mct'
 * Number of MCT instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_mct - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_mct_get(
    int unit);

/**
 * \brief returns define data of nof_instances_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_qrh'
 * Number of QRH instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_qrh_get(
    int unit);

/**
 * \brief returns define data of nof_instances_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_instances_dcml'
 * Number of DCML instances.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_instances_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_instances_dcml_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_dcml
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_dcml'
 * Number of links for each DCML block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_dcml - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_dcml_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_lcm
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_lcm'
 * Number of links for each LCM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_lcm - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_lcm_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_qrh
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_qrh'
 * Number of links for each QRH block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_qrh - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_qrh_get(
    int unit);

/**
 * \brief returns define data of nof_dtm_fifos
 * Module - 'device', Submodule - 'blocks', data - 'nof_dtm_fifos'
 * Number of FIFOs for each DTM block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_dtm_fifos - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_dtm_fifos_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_fsrd'
 * Number of links for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_fsrd_get(
    int unit);

/**
 * \brief returns define data of nof_links_in_phy_core
 * Module - 'device', Submodule - 'blocks', data - 'nof_links_in_phy_core'
 * Number of links in each PHY core.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_links_in_phy_core - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_links_in_phy_core_get(
    int unit);

/**
 * \brief returns define data of nof_fmacs_in_fsrd
 * Module - 'device', Submodule - 'blocks', data - 'nof_fmacs_in_fsrd'
 * Number of FMAC blocks for each FSRD block.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_fmacs_in_fsrd - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_blocks_nof_fmacs_in_fsrd_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_device_blocks_table_override,
    dnxf_data_device_blocks_table_fsrd_sbus_chain,
    dnxf_data_device_blocks_table_fmac_sbus_chain,

    /**
     * Must be last one!
     */
    _dnxf_data_device_blocks_table_nof
} dnxf_data_device_blocks_table_e;

/* Get Data */
/**
 * \brief get table override entry 
 * blocks enable/disable override
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     override - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_override_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_override_t * dnxf_data_device_blocks_override_get(
    int unit,
    int index);

/**
 * \brief get table fsrd_sbus_chain entry 
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] fsrd_id - FSRD ID
 * 
 * \return
 *     fsrd_sbus_chain - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fsrd_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_fsrd_sbus_chain_t * dnxf_data_device_blocks_fsrd_sbus_chain_get(
    int unit,
    int fsrd_id);

/**
 * \brief get table fmac_sbus_chain entry 
 * The order of FMACs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * \param [in] fmac_id - FMAC ID
 * 
 * \return
 *     fmac_sbus_chain - returns the relevant entry values grouped in struct - see dnxf_data_device_blocks_fmac_sbus_chain_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_blocks_fmac_sbus_chain_t * dnxf_data_device_blocks_fmac_sbus_chain_get(
    int unit,
    int fmac_id);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'override'
 * blocks enable/disable override
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_override_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'fsrd_sbus_chain'
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_fsrd_sbus_chain_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'blocks', table - 'fmac_sbus_chain'
 * The order of FMACs in the SBUS chain
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_blocks_fmac_sbus_chain_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)override info
 * blocks enable/disable override
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     override - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_override_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fsrd_sbus_chain info
 * The order of FSRDs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fsrd_sbus_chain - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_fsrd_sbus_chain_info_get(
    int unit);

/**
 * \brief get general info table about table (for example key size)fmac_sbus_chain info
 * The order of FMACs in the SBUS chain
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     fmac_sbus_chain - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_blocks_fmac_sbus_chain_info_get(
    int unit);

/*
 * SUBMODULE INTERRUPTS:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_interrupts_feature_get(
    int unit,
    dnxf_data_device_interrupts_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_interrupts_define_nof_interrupts,

    /**
     * Must be last one!
     */
    _dnxf_data_device_interrupts_define_nof
} dnxf_data_device_interrupts_define_e;

/* Get Data */
/**
 * \brief returns numeric data of nof_interrupts
 * Module - 'device', Submodule - 'interrupts', data - 'nof_interrupts'
 * Number of interrupts.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     nof_interrupts - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_interrupts_nof_interrupts_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_interrupts_table_nof
} dnxf_data_device_interrupts_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE CUSTOM_FEATURES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_custom_features_feature_get(
    int unit,
    dnxf_data_device_custom_features_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_custom_features_define_mesh_topology_size,
    dnxf_data_device_custom_features_define_mesh_topology_fast,

    /**
     * Must be last one!
     */
    _dnxf_data_device_custom_features_define_nof
} dnxf_data_device_custom_features_define_e;

/* Get Data */
/**
 * \brief returns numeric data of mesh_topology_size
 * Module - 'device', Submodule - 'custom_features', data - 'mesh_topology_size'
 * To determine if there is a multiple pipe device in the system.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_topology_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_custom_features_mesh_topology_size_get(
    int unit);

/**
 * \brief returns numeric data of mesh_topology_fast
 * Module - 'device', Submodule - 'custom_features', data - 'mesh_topology_fast'
 * Device is in mesh topology fast mode.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     mesh_topology_fast - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_custom_features_mesh_topology_fast_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_custom_features_table_nof
} dnxf_data_device_custom_features_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE PROPERTIES:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_properties_feature_get(
    int unit,
    dnxf_data_device_properties_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_properties_define_nof
} dnxf_data_device_properties_define_e;

/* Get Data */
/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{
    dnxf_data_device_properties_table_unsupported,

    /**
     * Must be last one!
     */
    _dnxf_data_device_properties_table_nof
} dnxf_data_device_properties_table_e;

/* Get Data */
/**
 * \brief get table unsupported entry 
 * unsupported soc properties
 * 
 * \param [in] unit - unit #
 * \param [in] index - running index
 * 
 * \return
 *     unsupported - returns the relevant entry values grouped in struct - see dnxf_data_device_properties_unsupported_t
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxf_data_device_properties_unsupported_t * dnxf_data_device_properties_unsupported_get(
    int unit,
    int index);

/* Get Value Str */
/**
 * \brief Get table value as string
 * Module - 'device', Submodule - 'properties', table - 'unsupported'
 * unsupported soc properties
 * 
 * \param [in] unit - Unit #
 * \param [out] buffer - buffer for the value
 * \param [in] key0 - key #0 index - 0 if not used
 * \param [in] key1 - key #1 index - 0 if not used
 * \param [in] value_index - value index to get - the index is alligned with values array in table structure
 * 
 * \return
 *     err - See shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_properties_unsupported_entry_str_get(
    int unit,
    char *buffer,
    int key0,
    int key1,
    int value_index);

/* Get Table info */
/**
 * \brief get general info table about table (for example key size)unsupported info
 * unsupported soc properties
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     unsupported - returns table info
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
const dnxc_data_table_info_t * dnxf_data_device_properties_unsupported_info_get(
    int unit);

/*
 * SUBMODULE HA:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_ha_feature_get(
    int unit,
    dnxf_data_device_ha_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_ha_define_warmboot_support,
    dnxf_data_device_ha_define_sw_state_max_size,

    /**
     * Must be last one!
     */
    _dnxf_data_device_ha_define_nof
} dnxf_data_device_ha_define_e;

/* Get Data */
/**
 * \brief returns numeric data of warmboot_support
 * Module - 'device', Submodule - 'ha', data - 'warmboot_support'
 * specify if unit should support wb
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     warmboot_support - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_ha_warmboot_support_get(
    int unit);

/**
 * \brief returns numeric data of sw_state_max_size
 * Module - 'device', Submodule - 'ha', data - 'sw_state_max_size'
 * specify the amount of memory (in bytes) preallocated for sw state
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     sw_state_max_size - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_ha_sw_state_max_size_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_ha_table_nof
} dnxf_data_device_ha_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * SUBMODULE EMULATION:
 * {
 */
/*
 * Features
 */
/* Feature enum - placed in if header (should be exposed to component user */
/* Get Data */
/**
 * \brief get submodule feature - disabled/enabled
 * 
 * \param [in] unit - Unit #
 * \param [in] feature - feature to get (see enum definition for more details
 * 
 * \return
 *     is_supported - returns 1 if and only if supported and 0 otherwise
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
int dnxf_data_device_emulation_feature_get(
    int unit,
    dnxf_data_device_emulation_feature_e feature);

/*
 * Defines
 */
/**
 * \brief 
 * Define enum
 */
typedef enum
{
    dnxf_data_device_emulation_define_emulation_system,

    /**
     * Must be last one!
     */
    _dnxf_data_device_emulation_define_nof
} dnxf_data_device_emulation_define_e;

/* Get Data */
/**
 * \brief returns numeric data of emulation_system
 * Module - 'device', Submodule - 'emulation', data - 'emulation_system'
 * Checking if the device is ran on emulation.
 * 
 * \param [in] unit - unit #
 * 
 * \return
 *     emulation_system - the required data value
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
uint32 dnxf_data_device_emulation_emulation_system_get(
    int unit);

/*
 * Tables
 */
/**
 * \brief 
 * Table enum
 */
typedef enum
{

    /**
     * Must be last one!
     */
    _dnxf_data_device_emulation_table_nof
} dnxf_data_device_emulation_table_e;

/* Get Data */
/* Get Value Str */
/* Get Table info */
/*
 * FUNCTIONS:
 * {
 */
/**
 * \brief Init module
 * 
 * \param [in] unit - Unit #
 * \param [out] module_data - pointer to module data
 * 
 * \return
 *     rv - see 'shr_error_e
 * \remark
 *   * Auto-generated using device data autocoder
 * \see
 *   * None
 */
shr_error_e dnxf_data_device_init(
    int unit,
    dnxc_data_module_t *module_data);

/*
 * }
 */
/*}*/
#endif /*_DNXF_DATA_INTERNAL_DEVICE_H_*/
/* *INDENT-ON* */
